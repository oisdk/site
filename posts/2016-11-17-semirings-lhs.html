<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Semirings - Donnacha Oisín Kidney</title>
        <style>body{color:black;font-family:Garamond,Times New Roman,serif;font-size:15px;margin:0px auto 0px auto;padding-left:5px;padding-right:5px;max-width:650px}math{font-size:13px}img{max-width:600px}summary{outline:0}div#header{border-bottom:3px double black;margin-bottom:30px;padding:12px 0px 12px 0px}div#logo a{color:black;float:left;font-size:20px;text-decoration:none}div#header #navigation{text-align:right}div#header #navigation a{color:black;font-family:Garamond,Times New Roman,Serif;font-size:18px;margin-left:10px;text-decoration:none;text-transform:uppercase}div#footer{font-family:Garamond,Times New Roman,Serif;border-top:solid 2px black;color:#555;font-size:12px;margin-top:30px;padding:12px 0px 12px 0px;text-align:right}h1{font-family:Garamond,Times New Roman,Serif;font-size:22px;font-weight:normal}h2{font-family:Garamond,Times New Roman,Serif;font-size:20px;font-weight:normal}div.info{color:#555;font-size:15px;font-style:italic}span.quiet{color:#828282;font-style:italic}a{color:black;word-wrap:break-word}ul.post-list{margin-left:0px;padding-left:0px;list-style-type:none}.hidden_source{display:none}ol.serieslist{counter-reset:item;list-style-type:none;padding-left:20}ol li.serieslist:before{content:'Part ' counter(item,decimal) ':';counter-increment:item}table.sourceCode,tr.sourceCode,td.lineNumbers,td.sourceCode,table.sourceCode pre{margin:0;padding:0;border:0;vertical-align:baseline;border:none}td.lineNumbers{border-right:1px solid #AAAAAA;text-align:right;color:#AAAAAA;padding-right:5px;padding-left:5px}td.sourceCode{padding-left:5px}.sourceCode,code,pre,.Agda{font-size:10px;font-family:menlo,monospace}.sourceCode span.kw{color:#262C6A}.sourceCode span.dt{color:#476A97}.sourceCode span.dv{color:#262C6A}.sourceCode span.bn{color:#262C6A}.sourceCode span.fl{color:#262C6A}.sourceCode span.ch{color:#262C6A}.sourceCode span.st{color:#702C51}.sourceCode span.co{color:#435138}.sourceCode span.ot{color:#262C6A}.sourceCode span.al{color:red}.sourceCode span.fu{color:#000000}.sourceCode span.re{color:#000000}.sourceCode span.er{color:red}li{margin-bottom:2px}li:last-child{margin-bottom:0px}.Agda .Comment{color:#B22222}.Agda .Background{}.Agda .Markup{color:#000000}.Agda .Keyword{color:#CD6600}.Agda .String{color:#B22222}.Agda .Number{color:#A020F0}.Agda .Symbol{color:#404040}.Agda .PrimitiveType{color:#0000CD}.Agda .Pragma{color:black}.Agda .Operator{}.Agda .Bound{color:black}.Agda .Generalizable{color:black}.Agda .InductiveConstructor{color:#008B00}.Agda .CoinductiveConstructor{color:#8B7500}.Agda .Datatype{color:#0000CD}.Agda .Field{color:#EE1289}.Agda .Function{color:#0000CD}.Agda .Module{color:#A020F0}.Agda .Postulate{color:#0000CD}.Agda .Primitive{color:#0000CD}.Agda .Record{color:#0000CD}.Agda .DottedPattern{}.Agda .UnsolvedMeta{color:black;background:yellow}.Agda .UnsolvedConstraint{color:black;background:yellow}.Agda .TerminationProblem{color:black;background:#FFA07A}.Agda .IncompletePattern{color:black;background:#F5DEB3}.Agda .Error{color:red;text-decoration:underline}.Agda .TypeChecks{color:black;background:#ADD8E6}.Agda a{text-decoration:none}.Agda a[href]:hover{background-color:#B4EEB4}.sourceCode{overflow-x:auto}</style>
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Donnacha Oisín Kidney</a>
            </div>
            <div id="navigation">
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../rss.xml">Feed</a>
            </div>
        </div>

        <div id="content">
            <h2>Semirings</h2>

            <div class="info">
    Posted on November 17, 2016
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a title="All pages tagged 'Haskell'." href="../tags/Haskell.html">Haskell</a>, <a title="All pages tagged 'Semirings'." href="../tags/Semirings.html">Semirings</a>
    
</div>

<div class="sourceCode" id="cb1"><pre class="sourceCode haskell literate hidden_source"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving, TypeFamilies #-}</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="ot">{-# LANGUAGE DeriveFunctor, DeriveFoldable, DeriveTraversable #-}</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="ot">{-# LANGUAGE PatternSynonyms, ViewPatterns, LambdaCase #-}</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a><span class="ot">{-# LANGUAGE RankNTypes, FlexibleInstances, FlexibleContexts #-}</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a><span class="ot">{-# LANGUAGE OverloadedStrings, OverloadedLists, MonadComprehensions #-}</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a><span class="kw">module</span> <span class="dt">Semirings</span> <span class="kw">where</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map.Strict</span> <span class="kw">as</span> <span class="dt">Map</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a><span class="kw">import</span>           <span class="dt">Data.Map.Strict</span>      (<span class="dt">Map</span>)</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a><span class="kw">import</span>           <span class="dt">Data.Monoid</span>  <span class="kw">hiding</span>  (<span class="dt">Endo</span>(..))</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true"></a><span class="kw">import</span>           <span class="dt">Data.Foldable</span> <span class="kw">hiding</span> (toList)</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true"></a><span class="kw">import</span>           <span class="dt">Control.Applicative</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true"></a><span class="kw">import</span>           <span class="dt">Control.Arrow</span>        (first)</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true"></a><span class="kw">import</span>           <span class="dt">Control.Monad.Cont</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true"></a><span class="kw">import</span>           <span class="dt">Data.Functor.Identity</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true"></a><span class="kw">import</span>           <span class="dt">GHC.Exts</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true"></a><span class="kw">import</span>           <span class="dt">Data.List</span> <span class="kw">hiding</span>     (insert)</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true"></a><span class="kw">import</span>           <span class="dt">Data.Maybe</span>           (mapMaybe)</span></code></pre></div>
<p>I’ve been playing around a lot with semirings recently. A semiring is anything with addition, multiplication, zero and one. You can represent that in Haskell as:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">class</span> <span class="dt">Semiring</span> a <span class="kw">where</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a><span class="ot">  zero ::</span> a</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a><span class="ot">  one  ::</span> a</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>  <span class="kw">infixl</span> <span class="dv">7</span> <span class="op">&lt;.&gt;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a><span class="ot">  (&lt;.&gt;) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>  <span class="kw">infixl</span> <span class="dv">6</span> <span class="op">&lt;+&gt;</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a><span class="ot">  (&lt;+&gt;) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>It’s kind of like a combination of two <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Monoid.html">monoids</a>. It has the normal monoid laws:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a>x <span class="op">&lt;+&gt;</span> (y <span class="op">&lt;+&gt;</span> z) <span class="ot">=</span> (x <span class="op">&lt;+&gt;</span> y) <span class="op">&lt;+&gt;</span> z</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>x <span class="op">&lt;.&gt;</span> (y <span class="op">&lt;.&gt;</span> z) <span class="ot">=</span> (x <span class="op">&lt;.&gt;</span> y) <span class="op">&lt;.&gt;</span> z</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>x <span class="op">&lt;+&gt;</span> zero <span class="ot">=</span> zero <span class="op">&lt;+&gt;</span> x <span class="ot">=</span> x</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>x <span class="op">&lt;.&gt;</span> one  <span class="ot">=</span> one  <span class="op">&lt;.&gt;</span> x <span class="ot">=</span> x</span></code></pre></div>
<p>And a few extra:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a>x <span class="op">&lt;+&gt;</span> y <span class="ot">=</span> y <span class="op">&lt;+&gt;</span> x</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>x <span class="op">&lt;.&gt;</span> (y <span class="op">&lt;+&gt;</span> z) <span class="ot">=</span> (x <span class="op">&lt;.&gt;</span> y) <span class="op">&lt;+&gt;</span> (x <span class="op">&lt;.&gt;</span> z)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>(x <span class="op">&lt;+&gt;</span> y) <span class="op">&lt;.&gt;</span> z <span class="ot">=</span> (x <span class="op">&lt;.&gt;</span> z) <span class="op">&lt;+&gt;</span> (y <span class="op">&lt;.&gt;</span> z)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>zero <span class="op">&lt;.&gt;</span> a <span class="ot">=</span> a <span class="op">&lt;.&gt;</span> zero <span class="ot">=</span> zero</span></code></pre></div>
<p>I should note that what I’m calling a semiring here is often called a <a href="https://ncatlab.org/nlab/show/rig">rig</a>. I actually prefer the name “rig”: a rig is a ring without <strong>n</strong>egatives (cute!); whereas a <em>semi</em>ring is a rig without neutral elements, which mirrors the definition of a semigroup. The nomenclature in this area is a bit of a mess, though, so I went with the more commonly-used name for the sake of googleability.</p>
<p>At first glance, it looks quite numeric. Indeed, <a href="https://pursuit.purescript.org/packages/purescript-prelude/1.1.0/docs/Data.Semiring">PureScript</a> uses it as the basis for its numeric hierarchy. (In my experience so far, it’s nicer to use than Haskell’s <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Num"><code class="sourceCode haskell"><span class="dt">Num</span></code></a>)</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Semiring</span> <span class="dt">Integer</span> <span class="kw">where</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>  zero <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>  one  <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>  (<span class="op">&lt;+&gt;</span>) <span class="ot">=</span> (<span class="op">+</span>)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>  (<span class="op">&lt;.&gt;</span>) <span class="ot">=</span> (<span class="op">*</span>)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Semiring</span> <span class="dt">Double</span> <span class="kw">where</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a>  zero <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a>  one  <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true"></a>  (<span class="op">&lt;+&gt;</span>) <span class="ot">=</span> (<span class="op">+</span>)</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true"></a>  (<span class="op">&lt;.&gt;</span>) <span class="ot">=</span> (<span class="op">*</span>)</span></code></pre></div>
<p>However, there are far more types which can form a valid <code class="sourceCode haskell"><span class="dt">Semiring</span></code> instance than can form a valid <code class="sourceCode haskell"><span class="dt">Num</span></code> instance: the <code class="sourceCode haskell"><span class="fu">negate</span></code> method, for example, excludes types representing the natural numbers:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">ChurchNat</span> <span class="ot">=</span> <span class="dt">ChurchNat</span> </span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>  {<span class="ot"> runNat ::</span> <span class="kw">forall</span> a<span class="op">.</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a}</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a> </span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Nat</span> <span class="ot">=</span> <span class="dt">Zero</span> <span class="op">|</span> <span class="dt">Succ</span> <span class="dt">Nat</span></span></code></pre></div>
<p>These form perfectly sensible semirings, though:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Semiring</span> <span class="dt">ChurchNat</span> <span class="kw">where</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>  zero <span class="ot">=</span> <span class="dt">ChurchNat</span> (<span class="fu">const</span> <span class="fu">id</span>)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>  one <span class="ot">=</span> <span class="dt">ChurchNat</span> (<span class="op">$</span>)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>  <span class="dt">ChurchNat</span> n <span class="op">&lt;+&gt;</span> <span class="dt">ChurchNat</span> m <span class="ot">=</span> <span class="dt">ChurchNat</span> (\f <span class="ot">-&gt;</span> n f <span class="op">.</span> m f)</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>  <span class="dt">ChurchNat</span> n <span class="op">&lt;.&gt;</span> <span class="dt">ChurchNat</span> m <span class="ot">=</span> <span class="dt">ChurchNat</span> (n <span class="op">.</span> m)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Semiring</span> <span class="dt">Nat</span> <span class="kw">where</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a>  zero <span class="ot">=</span> <span class="dt">Zero</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a>  one <span class="ot">=</span> <span class="dt">Succ</span> <span class="dt">Zero</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true"></a>  <span class="dt">Zero</span> <span class="op">&lt;+&gt;</span> x <span class="ot">=</span> x</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true"></a>  <span class="dt">Succ</span> x <span class="op">&lt;+&gt;</span> y <span class="ot">=</span> <span class="dt">Succ</span> (x <span class="op">&lt;+&gt;</span> y)</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true"></a>  <span class="dt">Zero</span> <span class="op">&lt;.&gt;</span> _ <span class="ot">=</span> <span class="dt">Zero</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true"></a>  <span class="dt">Succ</span> <span class="dt">Zero</span> <span class="op">&lt;.&gt;</span> x <span class="ot">=</span>x</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true"></a>  <span class="dt">Succ</span> x <span class="op">&lt;.&gt;</span> y <span class="ot">=</span> y <span class="op">&lt;+&gt;</span> (x <span class="op">&lt;.&gt;</span> y)</span></code></pre></div>
<p>The other missing method is <code class="sourceCode haskell"><span class="fu">fromInteger</span></code>, which means decidedly non-numeric types are allowed:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Semiring</span> <span class="dt">Bool</span> <span class="kw">where</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>  zero <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>  one  <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>  (<span class="op">&lt;+&gt;</span>) <span class="ot">=</span> (<span class="op">||</span>)</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>  (<span class="op">&lt;.&gt;</span>) <span class="ot">=</span> (<span class="op">&amp;&amp;</span>)</span></code></pre></div>
<p>We can provide a more general definition of the <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Monoid.html#t:Sum"><code class="sourceCode haskell"><span class="dt">Sum</span></code></a> and <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Monoid.html#t:Product"><code class="sourceCode haskell"><span class="dt">Product</span></code></a> newtypes from <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Monoid.html#g:3">Data.Monoid</a>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">Add</span> a <span class="ot">=</span> <span class="dt">Add</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>  {<span class="ot"> getAdd ::</span> a</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Read</span>, <span class="dt">Show</span>, <span class="dt">Semiring</span>)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">Mul</span> a <span class="ot">=</span> <span class="dt">Mul</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a>  {<span class="ot"> getMul ::</span> a</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a>  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Read</span>, <span class="dt">Show</span>, <span class="dt">Semiring</span>)</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true"></a></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Add</span> <span class="kw">where</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true"></a>  <span class="fu">fmap</span> f (<span class="dt">Add</span> x) <span class="ot">=</span> <span class="dt">Add</span> (f x)</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true"></a></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Add</span> <span class="kw">where</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true"></a>  <span class="fu">pure</span> <span class="ot">=</span> <span class="dt">Add</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true"></a>  <span class="dt">Add</span> f <span class="op">&lt;*&gt;</span> <span class="dt">Add</span> x <span class="ot">=</span> <span class="dt">Add</span> (f x)</span></code></pre></div>
<p>I’m using <code class="sourceCode haskell"><span class="dt">Add</span></code> and <code class="sourceCode haskell"><span class="dt">Mul</span></code> here to avoid name clashing.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Semiring</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Add</span> a) <span class="kw">where</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>  <span class="fu">mempty</span> <span class="ot">=</span> <span class="dt">Add</span> zero</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a>  <span class="dt">Add</span> x <span class="ot">`mappend`</span> <span class="dt">Add</span> y <span class="ot">=</span> <span class="dt">Add</span> (x <span class="op">&lt;+&gt;</span> y)</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Semiring</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Mul</span> a) <span class="kw">where</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a>  <span class="fu">mempty</span> <span class="ot">=</span> <span class="dt">Mul</span> one</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a>  <span class="dt">Mul</span> x <span class="ot">`mappend`</span> <span class="dt">Mul</span> y <span class="ot">=</span> <span class="dt">Mul</span> (x <span class="op">&lt;.&gt;</span> y)</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true"></a>  </span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true"></a><span class="ot">add ::</span> (<span class="dt">Semiring</span> a, <span class="dt">Foldable</span> f) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> a</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true"></a>add <span class="ot">=</span> getAdd <span class="op">.</span> <span class="fu">foldMap</span> <span class="dt">Add</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true"></a></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true"></a><span class="ot">mul ::</span> (<span class="dt">Semiring</span> a, <span class="dt">Foldable</span> f) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> a</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true"></a>mul <span class="ot">=</span> getMul <span class="op">.</span> <span class="fu">foldMap</span> <span class="dt">Mul</span></span></code></pre></div>
<p><code class="sourceCode haskell">add</code> and <code class="sourceCode haskell">mul</code> are equivalent to <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Foldable.html#v:sum"><code class="sourceCode haskell"><span class="fu">sum</span></code></a> and <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Foldable.html#v:product"><code class="sourceCode haskell"><span class="fu">product</span></code></a>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell literate prop"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a>add xs <span class="op">==</span> <span class="fu">sum</span> (<span class="ot">xs ::</span> [<span class="dt">Integer</span>])</span></code></pre></div>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell literate prop"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a>mul xs <span class="op">==</span> <span class="fu">product</span> (<span class="ot">xs ::</span> [<span class="dt">Integer</span>])</span></code></pre></div>
<p>But they now work with a wider array of types: non-negative numbers, as we’ve seen, but specialised to <code class="sourceCode haskell"><span class="dt">Bool</span></code> we get the familiar <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Monoid.html#t:Any"><code class="sourceCode haskell"><span class="dt">Any</span></code></a> and <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Monoid.html#t:All"><code class="sourceCode haskell"><span class="dt">All</span></code></a> newtypes (and their corresponding folds).</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell literate prop"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a>add xs <span class="op">==</span> <span class="fu">or</span> (<span class="ot">xs ::</span> [<span class="dt">Bool</span>])</span></code></pre></div>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell literate prop"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a>mul xs <span class="op">==</span> <span class="fu">and</span> (<span class="ot">xs ::</span> [<span class="dt">Bool</span>])</span></code></pre></div>
<p>So far, nothing amazing. We avoid a little bit of code duplication, that’s all.</p>
<h2 id="a-semiring-map">A Semiring Map</h2>
<p>In older versions of Python, <a href="https://www.python.org/dev/peps/pep-0218/">there was no native set type</a>. In its place, dictionaries were used, where the values would be booleans. In a similar fashion, before the <a href="https://docs.python.org/2/library/collections.html#collections.Counter">Counter</a> type was added in 2.7, the traditional way of representing a multiset was using a dictionary where the values were integers.</p>
<p>Using semirings, both of these data structures can have the same type:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">GeneralMap</span> a b <span class="ot">=</span> <span class="dt">GeneralMap</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a>  {<span class="ot"> getMap ::</span> <span class="dt">Map</span> a b</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a>  } <span class="kw">deriving</span> (<span class="dt">Functor</span>, <span class="dt">Foldable</span>, <span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>)</span></code></pre></div>
<p>If operations are defined in terms of the <code class="sourceCode haskell"><span class="dt">Semiring</span></code> class, the same code will work on a set <em>and</em> a multiset:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span class="ot">insert ::</span> (<span class="dt">Ord</span> a, <span class="dt">Semiring</span> b) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a b <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a b</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a>insert x <span class="ot">=</span> <span class="dt">GeneralMap</span> <span class="op">.</span> Map.insertWith (<span class="op">&lt;+&gt;</span>) x one <span class="op">.</span> getMap</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a><span class="ot">delete ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a b <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a b</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true"></a>delete x <span class="ot">=</span> <span class="dt">GeneralMap</span> <span class="op">.</span> Map.delete x <span class="op">.</span> getMap</span></code></pre></div>
<p>How to get back the dictionary-like behaviour, then? Well, operations like <code class="sourceCode haskell"><span class="fu">lookup</span></code> and <code class="sourceCode haskell">assoc</code> are better suited to a <code class="sourceCode haskell"><span class="dt">Monoid</span></code> constraint, rather than <code class="sourceCode haskell"><span class="dt">Semiring</span></code>:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span class="fu">lookup</span><span class="ot"> ::</span> (<span class="dt">Ord</span> a, <span class="dt">Monoid</span> b) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a b <span class="ot">-&gt;</span> b</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a><span class="fu">lookup</span> x <span class="ot">=</span> fold <span class="op">.</span> Map.lookup x <span class="op">.</span> getMap</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a><span class="ot">assoc ::</span> (<span class="dt">Ord</span> a, <span class="dt">Applicative</span> f, <span class="dt">Monoid</span> (f b)) </span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a>      <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a (f b) <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a (f b)</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true"></a>assoc k v <span class="ot">=</span> <span class="dt">GeneralMap</span> <span class="op">.</span> Map.insertWith <span class="fu">mappend</span> k (<span class="fu">pure</span> v) <span class="op">.</span> getMap</span></code></pre></div>
<p><code class="sourceCode haskell"><span class="fu">lookup</span></code> is a function which should work on sets and multisets: however <code class="sourceCode haskell"><span class="dt">Bool</span></code> and <code class="sourceCode haskell"><span class="dt">Integer</span></code> don’t have <code class="sourceCode haskell"><span class="dt">Monoid</span></code> instances. To fix this, we can use the <code class="sourceCode haskell"><span class="dt">Add</span></code> newtype from earlier. The interface for each of these data structures can now be expressed like this:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">Set</span>      a   <span class="ot">=</span> <span class="dt">GeneralMap</span> a (<span class="dt">Add</span> <span class="dt">Bool</span>)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">MultiSet</span> a   <span class="ot">=</span> <span class="dt">GeneralMap</span> a (<span class="dt">Add</span> <span class="dt">Integer</span>)</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">Map</span>      a b <span class="ot">=</span> <span class="dt">GeneralMap</span> a (<span class="dt">First</span> b)</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">MultiMap</span> a b <span class="ot">=</span> <span class="dt">GeneralMap</span> a [b]</span></code></pre></div>
<p>And each of the functions on the <code class="sourceCode haskell"><span class="dt">GeneralMap</span></code> specialises like this:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a><span class="co">-- Set</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a><span class="ot">insert ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Set</span> a <span class="ot">-&gt;</span> <span class="dt">Set</span> a</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true"></a><span class="fu">lookup</span><span class="ot"> ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Set</span> a <span class="ot">-&gt;</span> <span class="dt">Add</span> <span class="dt">Bool</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true"></a><span class="ot">delete ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Set</span> a <span class="ot">-&gt;</span> <span class="dt">Set</span> a</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true"></a></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true"></a><span class="co">-- MultiSet</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true"></a><span class="ot">insert ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">MultiSet</span> a <span class="ot">-&gt;</span> <span class="dt">MultiSet</span> a</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true"></a><span class="fu">lookup</span><span class="ot"> ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">MultiSet</span> a <span class="ot">-&gt;</span> <span class="dt">Add</span> <span class="dt">Integer</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true"></a><span class="ot">delete ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">MultiSet</span> a <span class="ot">-&gt;</span> <span class="dt">MultiSet</span> a</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true"></a></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true"></a><span class="co">-- Map</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true"></a><span class="ot">assoc  ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Map</span> a b <span class="ot">-&gt;</span> <span class="dt">Map</span> a b</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true"></a><span class="fu">lookup</span><span class="ot"> ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Map</span> a b <span class="ot">-&gt;</span> <span class="dt">First</span> b</span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true"></a><span class="ot">delete ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Map</span> a b <span class="ot">-&gt;</span> <span class="dt">Map</span> a b</span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true"></a></span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true"></a><span class="co">-- MultiMap</span></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true"></a><span class="ot">assoc  ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">MultiMap</span> a b <span class="ot">-&gt;</span> <span class="dt">MultiMap</span> a b</span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true"></a><span class="fu">lookup</span><span class="ot"> ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">MultiMap</span> a b <span class="ot">-&gt;</span> [b]</span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true"></a><span class="ot">delete ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">MultiMap</span> a b <span class="ot">-&gt;</span> <span class="dt">MultiMap</span> a b</span></code></pre></div>
<p>This was actually where I first came across semirings: I was trying to avoid code duplication for a trie implementation. I wanted to get the Boom Hierarchy <span class="citation" data-cites="boom_further_1981">(<a href="#ref-boom_further_1981" role="doc-biblioref">1981</a>)</span> (plus maps) from the same underlying implementation.</p>
<p>It works <em>okay</em>. On the one hand, it’s nice that you don’t have to wrap the map type itself to get the different behaviour. There’s only one <code class="sourceCode haskell">delete</code> function, which works on sets, maps, multisets, etc. I don’t need to import the <code class="sourceCode haskell"><span class="dt">TrieSet</span></code> module qualified, to differentiate between the <em>four</em> <code class="sourceCode haskell">delete</code> functions I’ve written.</p>
<p>On the other hand, the <code class="sourceCode haskell"><span class="dt">Add</span></code> wrapper is a pain: having <code class="sourceCode haskell"><span class="fu">lookup</span></code> return the wrapped values is ugly, and the <code class="sourceCode haskell"><span class="dt">Applicative</span></code> constraint is unwieldy (we only use it for <code class="sourceCode haskell"><span class="fu">pure</span></code>). Both of those problems could be solved by using something like the <a href="https://hackage.haskell.org/package/newtype-0.2/docs/Control-Newtype.html#t:Newtype"><code class="sourceCode haskell"><span class="dt">Newtype</span></code></a> or <a href="https://hackage.haskell.org/package/lens-4.15.1/docs/Control-Lens-Wrapped.html#t:Wrapped"><code class="sourceCode haskell"><span class="dt">Wrapped</span></code></a> class, which provide facilities for wrapping and unwrapping, but that might be overkill.</p>
<p>While <code class="sourceCode haskell"><span class="dt">Monoid</span></code> and <code class="sourceCode haskell"><span class="dt">Semiring</span></code> can take you pretty far, even to a <code class="sourceCode haskell"><span class="dt">Monoid</span></code> instance:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a><span class="ot">fromList ::</span> (<span class="dt">Ord</span> a, <span class="dt">Semiring</span> b, <span class="dt">Foldable</span> f) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a b</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a>fromList <span class="ot">=</span> <span class="fu">foldr</span> insert (<span class="dt">GeneralMap</span> Map.empty)</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true"></a></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true"></a><span class="ot">fromAssocs ::</span> (<span class="dt">Ord</span> a, <span class="dt">Applicative</span> f, <span class="dt">Monoid</span> (f b), <span class="dt">Foldable</span> t) </span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true"></a>           <span class="ot">=&gt;</span> t (a, b) <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a (f b)</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true"></a>fromAssocs <span class="ot">=</span> <span class="fu">foldr</span> (<span class="fu">uncurry</span> assoc) (<span class="dt">GeneralMap</span> Map.empty)</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true"></a></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true"></a><span class="kw">instance</span> (<span class="dt">Ord</span> a, <span class="dt">Monoid</span> b) <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">GeneralMap</span> a b) <span class="kw">where</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true"></a>  <span class="fu">mempty</span> <span class="ot">=</span> <span class="dt">GeneralMap</span> Map.empty</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true"></a>  <span class="fu">mappend</span> (<span class="dt">GeneralMap</span> x) (<span class="dt">GeneralMap</span> y) <span class="ot">=</span> </span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true"></a>    <span class="dt">GeneralMap</span> (Map.unionWith <span class="fu">mappend</span> x y)</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true"></a></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true"></a><span class="ot">singleton ::</span> <span class="dt">Semiring</span> b <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a b</span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true"></a>singleton x <span class="ot">=</span> <span class="dt">GeneralMap</span> (Map.singleton x one)</span></code></pre></div>
<p>They seem to fall down around functions like <code class="sourceCode haskell">intersection</code>:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a><span class="ot">intersection ::</span> (<span class="dt">Ord</span> a, <span class="dt">Semiring</span> b)</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a>             <span class="ot">=&gt;</span> <span class="dt">GeneralMap</span> a b <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a b <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a b</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true"></a>intersection (<span class="dt">GeneralMap</span> x) (<span class="dt">GeneralMap</span> y) <span class="ot">=</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true"></a>  <span class="dt">GeneralMap</span> (Map.intersectionWith (<span class="op">&lt;.&gt;</span>) x y)</span></code></pre></div>
<p>It works for sets, but it doesn’t make sense for multisets, and it doesn’t work for maps.</p>
<p>I couldn’t find a semiring for the map-like types which would give me a sensible intersection. I’m probably after a different algebraic structure.</p>
<h2 id="a-probability-semiring">A Probability Semiring</h2>
<p>While looking for a semiring to represent a valid intersection, I came across the probability semiring. It’s just the normal semiring over the rationals, with a lower bound of 0, and an upper of 1.</p>
<p>It’s useful in some cool ways: you can combine it with a list to get the probability monad <span class="citation" data-cites="erwig_functional_2006">(Erwig and Kollmansberger <a href="#ref-erwig_functional_2006" role="doc-biblioref">2006</a>)</span>. There’s an example in PureScript’s <a href="https://pursuit.purescript.org/packages/purescript-distributions/">Distributions</a> package.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">Prob</span> s a <span class="ot">=</span> <span class="dt">Prob</span> {<span class="ot"> runProb ::</span> [(a,s)] }</span></code></pre></div>
<p>There are some drawbacks to this representation, performance-wise. In particular, there’s a combinatorial explosion on every monadic bind. One of the strategies to reduce this explosion is to use a map:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">Prob</span> s a <span class="ot">=</span> <span class="dt">Prob</span> {<span class="ot"> runProb ::</span> <span class="dt">Map</span> a s }</span></code></pre></div>
<p>Because this doesn’t allow duplicate keys, it will flatten the association list on every bind. Unfortunately, the performance gain doesn’t always materialize, and in some cases there’s a performance <em>loss</em> <span class="citation" data-cites="larsen_memory_2011">(Larsen <a href="#ref-larsen_memory_2011" role="doc-biblioref">2011</a>)</span>. Also, the <code class="sourceCode haskell"><span class="dt">Ord</span></code> constraint on the keys prevents it from conforming to <code class="sourceCode haskell"><span class="dt">Monad</span></code> (at least not without <a href="http://okmij.org/ftp/Haskell/set-monad.html">difficulty</a>).</p>
<p>Interestingly, this type is exactly the same as the <code class="sourceCode haskell"><span class="dt">GeneralMap</span></code> from before. This is a theme I kept running into, actually: the <code class="sourceCode haskell"><span class="dt">GeneralMap</span></code> type represents not just maps, multimaps, sets, multisets, but also a whole host of other data structures.</p>
<h2 id="cont">Cont</h2>
<p>Edward Kmett had an interesting blog post about “Free Modules and Functional Linear Functionals” <span class="citation" data-cites="kmett_modules_2011">(<a href="#ref-kmett_modules_2011" role="doc-biblioref">2011</a><a href="#ref-kmett_modules_2011" role="doc-biblioref">b</a>)</span>. In it, he talked about this type:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a><span class="kw">infixr</span> <span class="dv">0</span> <span class="op">$*</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">Linear</span> r a <span class="ot">=</span> <span class="dt">Linear</span> {<span class="ot"> ($*) ::</span> (a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r }</span></code></pre></div>
<p>Also known as <a href="https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Cont.html#t:Cont"><code class="sourceCode haskell"><span class="dt">Cont</span></code></a>, the continuation monad. It can encode the probability monad:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a><span class="ot">fromProbs ::</span> (<span class="dt">Semiring</span> s, <span class="dt">Applicative</span> m) <span class="ot">=&gt;</span> [(a,s)] <span class="ot">-&gt;</span> <span class="dt">ContT</span> s m a</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true"></a>fromProbs xs <span class="ot">=</span> <span class="dt">ContT</span> <span class="op">$</span> \k <span class="ot">-&gt;</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true"></a>  <span class="fu">foldr</span> (\(x,s) a <span class="ot">-&gt;</span> liftA2 (<span class="op">&lt;+&gt;</span>) (<span class="fu">fmap</span> (s<span class="op">&lt;.&gt;</span>) (k x)) a) (<span class="fu">pure</span> zero) xs</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true"></a></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true"></a><span class="ot">probOfT ::</span> (<span class="dt">Semiring</span> r, <span class="dt">Applicative</span> m) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">ContT</span> r m a <span class="ot">-&gt;</span> m r</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true"></a>probOfT e c <span class="ot">=</span> runContT c (\x <span class="ot">-&gt;</span> <span class="kw">if</span> e x <span class="kw">then</span> <span class="fu">pure</span> one <span class="kw">else</span> <span class="fu">pure</span> zero)</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true"></a></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true"></a><span class="ot">probOf ::</span> <span class="dt">Semiring</span> r <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Cont</span> r a <span class="ot">-&gt;</span> r</span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true"></a>probOf e <span class="ot">=</span> runIdentity <span class="op">.</span> probOfT e</span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true"></a></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true"></a><span class="ot">uniform ::</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">ContT</span> <span class="dt">Double</span> m a</span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true"></a>uniform xs <span class="ot">=</span></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true"></a>  <span class="kw">let</span> s <span class="ot">=</span> <span class="fl">1.0</span> <span class="op">/</span> <span class="fu">fromIntegral</span> (<span class="fu">length</span> xs)</span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true"></a>  <span class="kw">in</span> fromProbs (<span class="fu">map</span> (<span class="fu">flip</span> (,) s) xs)</span></code></pre></div>
<p>Multiplication isn’t paid for on every bind, making this (potentially) a more efficient implementation than both the map and the association list.</p>
<p>You can actually make the whole thing a semiring:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true"></a><span class="kw">instance</span> (<span class="dt">Semiring</span> r, <span class="dt">Applicative</span> m) <span class="ot">=&gt;</span> <span class="dt">Semiring</span> (<span class="dt">ContT</span> r m a) <span class="kw">where</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true"></a>  one  <span class="ot">=</span> <span class="dt">ContT</span> (<span class="fu">const</span> (<span class="fu">pure</span> one))</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true"></a>  zero <span class="ot">=</span> <span class="dt">ContT</span> (<span class="fu">const</span> (<span class="fu">pure</span> zero))</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true"></a>  f <span class="op">&lt;+&gt;</span> g <span class="ot">=</span> <span class="dt">ContT</span> (\k <span class="ot">-&gt;</span> liftA2 (<span class="op">&lt;+&gt;</span>) (runContT f k) (runContT g k))</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true"></a>  f <span class="op">&lt;.&gt;</span> g <span class="ot">=</span> <span class="dt">ContT</span> (\k <span class="ot">-&gt;</span> liftA2 (<span class="op">&lt;.&gt;</span>) (runContT f k) (runContT g k))</span></code></pre></div>
<p>Which gives you a lovely <code class="sourceCode haskell"><span class="dt">Alternative</span></code> instance:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true"></a><span class="kw">instance</span> (<span class="dt">Semiring</span> r, <span class="dt">Applicative</span> m) <span class="ot">=&gt;</span> <span class="dt">Alternative</span> (<span class="dt">ContT</span> r m) <span class="kw">where</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true"></a>  (<span class="op">&lt;|&gt;</span>) <span class="ot">=</span> (<span class="op">&lt;+&gt;</span>)</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true"></a>  empty <span class="ot">=</span> zero</span></code></pre></div>
<p>This sheds some light on what was going on with the unsatisfactory <code class="sourceCode haskell">intersection</code> function on <code class="sourceCode haskell"><span class="dt">GeneralMap</span></code>: it’s actually <em>multiplication</em>. If you wanted to stretch the analogy and make <code class="sourceCode haskell"><span class="dt">GeneralMap</span></code> conform to <code class="sourceCode haskell"><span class="dt">Semiring</span></code>, you could use the empty map for <code class="sourceCode haskell">zero</code>, <code class="sourceCode haskell"><span class="fu">mappend</span></code> for <code class="sourceCode haskell"><span class="op">&lt;+&gt;</span></code>, but you’d run into trouble for <code class="sourceCode haskell">one</code>. <code class="sourceCode haskell">one</code> is the map where every possible key has a value of one. In other words, you’d have to enumerate over every possible value for the keys. Interestingly, there’s kind of the inverse problem for Cont: while it has an easy <code class="sourceCode haskell"><span class="dt">Semiring</span></code> instance, in order to <em>inspect</em> the values you have to enumerate over all the possible keys.</p>
<p>I now have a name for the probability monad / general map / Cont thing: a <em>covector</em>.</p>
<p>I think that the transformer version of Cont has a valid interpretation, also. If I ever understand <span class="citation" data-cites="hirschowitz_modules_2010">Hirschowitz and Maggesi (<a href="#ref-hirschowitz_modules_2010" role="doc-biblioref">2010</a>)</span> I’ll put it into a later follow-up post.</p>
<h2 id="conditional-choice">Conditional choice</h2>
<p>As a short digression, you can beef up the <code class="sourceCode haskell"><span class="op">&lt;|&gt;</span></code> operator a little, with something like <a href="http://zenzike.com/posts/2011-08-01-the-conditional-choice-operator">the conditional choice operator</a>:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">BiWeighted</span> s <span class="ot">=</span> s <span class="op">:|:</span> s</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true"></a><span class="kw">infixl</span> <span class="dv">8</span> <span class="op">:|:</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true"></a></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true"></a><span class="ot">(|&gt;) ::</span> (<span class="dt">Applicative</span> m, <span class="dt">Semiring</span> s)</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true"></a>     <span class="ot">=&gt;</span> <span class="dt">BiWeighted</span> s</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true"></a>     <span class="ot">-&gt;</span> <span class="dt">ContT</span> s m a</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true"></a>     <span class="ot">-&gt;</span> <span class="dt">ContT</span> s m a</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true"></a>     <span class="ot">-&gt;</span> <span class="dt">ContT</span> s m a</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true"></a>((lp <span class="op">:|:</span> rp) <span class="op">|&gt;</span> r) l <span class="ot">=</span></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true"></a>  (mapContT<span class="op">.</span><span class="fu">fmap</span><span class="op">.</span>(<span class="op">&lt;.&gt;</span>)) lp l <span class="op">&lt;|&gt;</span> (mapContT<span class="op">.</span><span class="fu">fmap</span><span class="op">.</span>(<span class="op">&lt;.&gt;</span>)) rp r</span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true"></a><span class="co">--</span></span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true"></a><span class="ot">(&lt;|) ::</span> <span class="dt">ContT</span> s m a</span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true"></a>     <span class="ot">-&gt;</span> (<span class="dt">ContT</span> s m a <span class="ot">-&gt;</span> <span class="dt">ContT</span> s m a)</span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true"></a>     <span class="ot">-&gt;</span> <span class="dt">ContT</span> s m a</span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true"></a>l <span class="op">&lt;|</span> r <span class="ot">=</span> r l</span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true"></a></span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true"></a><span class="kw">infixr</span> <span class="dv">0</span> <span class="op">&lt;|</span></span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true"></a><span class="kw">infixr</span> <span class="dv">0</span> <span class="op">|&gt;</span></span></code></pre></div>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true"></a>probOf (<span class="ch">'a'</span><span class="op">==</span>) (uniform <span class="st">&quot;a&quot;</span> <span class="op">&lt;|</span> <span class="fl">0.4</span> <span class="op">:|:</span> <span class="fl">0.6</span> <span class="op">|&gt;</span> uniform <span class="st">&quot;b&quot;</span>)</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true"></a><span class="fl">0.4</span></span></code></pre></div>
<h2 id="unleak">UnLeak</h2>
<p>If you fiddle around with the probability monad, you can break it apart in interesting ways. For instance, extracting the <code class="sourceCode haskell"><span class="dt">WriterT</span></code> monad transformer gives you:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true"></a><span class="dt">WriterT</span> (<span class="dt">Product</span> <span class="dt">Double</span>) []</span></code></pre></div>
<p>Eric Kidd describes it as <code class="sourceCode haskell"><span class="dt">PerhapsT</span></code>: a <code class="sourceCode haskell"><span class="dt">Maybe</span></code> with attached probability in his <a href="http://www.randomhacks.net/2007/02/21/refactoring-probability-distributions/">excellent blog post</a> <span class="citation" data-cites="kidd_build_2007">(and his paper in <a href="#ref-kidd_build_2007" role="doc-biblioref">2007</a>)</span>.</p>
<p>Straight away, we can optimise this representation by transforming the <a href="https://mail.haskell.org/pipermail/libraries/2013-March/019528.html">leaky</a> <code class="sourceCode haskell"><span class="dt">WriterT</span></code> into a state monad:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">WeightedT</span> s m a <span class="ot">=</span> <span class="dt">WeightedT</span> </span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true"></a>  {<span class="ot"> getWeightedT ::</span> s <span class="ot">-&gt;</span> m (a, s)</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true"></a>  } <span class="kw">deriving</span> <span class="dt">Functor</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true"></a>  </span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="dt">WeightedT</span> s m) <span class="kw">where</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true"></a>  <span class="fu">pure</span> x <span class="ot">=</span> <span class="dt">WeightedT</span> <span class="op">$</span> \s <span class="ot">-&gt;</span> <span class="fu">pure</span> (x,s)</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true"></a>  <span class="dt">WeightedT</span> fs <span class="op">&lt;*&gt;</span> <span class="dt">WeightedT</span> xs <span class="ot">=</span> <span class="dt">WeightedT</span> <span class="op">$</span> \s <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true"></a>    (f, p) <span class="ot">&lt;-</span> fs s</span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true"></a>    (x, t) <span class="ot">&lt;-</span> xs p</span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true"></a>    <span class="fu">pure</span> (f x, t)</span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true"></a>  </span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">WeightedT</span> s m) <span class="kw">where</span></span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true"></a>  <span class="dt">WeightedT</span> x <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> <span class="dt">WeightedT</span> <span class="op">$</span> \s <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true"></a>    (x, p) <span class="ot">&lt;-</span> x s</span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true"></a>    getWeightedT (f x) p</span></code></pre></div>
<p>I’m not sure yet, but I think this might have something to do with the isomorphism between <code class="sourceCode haskell"><span class="dt">Cont</span> ((<span class="ot">-&gt;</span>) s)</code> and <code>State s</code> <span class="citation" data-cites="kmett_free_2011">(Kmett <a href="#ref-kmett_free_2011" role="doc-biblioref">2011</a><a href="#ref-kmett_free_2011" role="doc-biblioref">a</a>)</span>.</p>
<p>You can even make it look like a normal (non-transformer) writer with some pattern synonyms:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">Weighted</span> s <span class="ot">=</span> <span class="dt">WeightedT</span> s <span class="dt">Identity</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true"></a></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true"></a><span class="kw">pattern</span> <span class="dt">Weighted</span> w <span class="ot">&lt;-</span> (runIdentity <span class="op">.</span> <span class="fu">flip</span> getWeightedT zero <span class="ot">-&gt;</span> w) <span class="kw">where</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true"></a>  <span class="dt">Weighted</span> (x,w) <span class="ot">=</span> <span class="dt">WeightedT</span> (\s <span class="ot">-&gt;</span> <span class="dt">Identity</span> (x, s <span class="op">&lt;.&gt;</span> w) )</span></code></pre></div>
<p>And you can pretend that you’ve just got a normal tuple:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true"></a><span class="ot">half ::</span> a <span class="ot">-&gt;</span> <span class="dt">Weighted</span> <span class="dt">Double</span> a</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true"></a>half x <span class="ot">=</span> <span class="dt">Weighted</span> (x, <span class="fl">0.5</span>)</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true"></a></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true"></a><span class="ot">runWeighted ::</span> <span class="dt">Semiring</span> s <span class="ot">=&gt;</span> <span class="dt">Weighted</span> s a <span class="ot">-&gt;</span> (a, s)</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true"></a>runWeighted (<span class="dt">Weighted</span> w) <span class="ot">=</span> w</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true"></a></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true"></a><span class="ot">evalWeighted ::</span> <span class="dt">Semiring</span> s <span class="ot">=&gt;</span> <span class="dt">Weighted</span> s a <span class="ot">-&gt;</span> a</span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true"></a>evalWeighted (<span class="dt">Weighted</span> (x,_)) <span class="ot">=</span> x</span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true"></a></span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true"></a><span class="ot">execWeighted ::</span> <span class="dt">Semiring</span> s <span class="ot">=&gt;</span> <span class="dt">Weighted</span> s a <span class="ot">-&gt;</span> s</span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true"></a>execWeighted (<span class="dt">Weighted</span> (_,s)) <span class="ot">=</span> s</span></code></pre></div>
<h2 id="free">Free</h2>
<p>Looking back at Cont, it is reminiscent of a particular encoding of the free monoid from <span class="citation" data-cites="doel_free_2015">Doel (<a href="#ref-doel_free_2015" role="doc-biblioref">2015</a>)</span>:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">FreeMonoid</span> a <span class="ot">=</span> <span class="dt">FreeMonoid</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true"></a>  { <span class="kw">forall</span> m<span class="op">.</span> <span class="dt">Monoid</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m) <span class="ot">-&gt;</span> m }</span></code></pre></div>
<p>So possibly covectors represent the free semiring, in some way.</p>
<p>Another encoding which looks free-ish is one of the efficient implementations of the probability monad from <span class="citation" data-cites="larsen_memory_2011">Larsen (<a href="#ref-larsen_memory_2011" role="doc-biblioref">2011</a>)</span>:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Dist</span> a <span class="kw">where</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true"></a>  <span class="dt">Certainly</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Dist</span> a <span class="co">-- only possible value</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true"></a>  <span class="dt">Choice</span><span class="ot"> ::</span> <span class="dt">Probability</span> <span class="ot">-&gt;</span> <span class="dt">Dist</span> a <span class="ot">-&gt;</span> <span class="dt">Dist</span> a <span class="ot">-&gt;</span> <span class="dt">Dist</span> a</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true"></a>  <span class="dt">Fmap</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Dist</span> a <span class="ot">-&gt;</span> <span class="dt">Dist</span> b</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true"></a>  <span class="dt">Join</span><span class="ot"> ::</span> <span class="dt">Dist</span> (<span class="dt">Dist</span> a) <span class="ot">-&gt;</span> <span class="dt">Dist</span> a</span></code></pre></div>
<p>This looks an awful lot like a weighted <a href="https://hackage.haskell.org/package/free-4.12.4/docs/Control-Alternative-Free.html">free alternative</a>. Is it a free semiring, then?</p>
<p>Maybe. There’s a parallel between the relationship between monoids and semirings and applicatives and <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Applicative.html#t:Alternative"><code class="sourceCode haskell"><span class="dt">Alternative</span></code></a>s <span class="citation" data-cites="rivas_monoids_2015">(Rivas, Jaskelioff, and Schrijvers <a href="#ref-rivas_monoids_2015" role="doc-biblioref">2015</a>)</span>. In a way, where monads are monoids in the category of endofunctors, alternatives are <em>semirings</em> in the category of endofunctors.</p>
<p>This parallel probably isn’t what I first thought it was. First of all, the above paper uses near-semirings, not semirings. A near-semiring is a semiring where the requirements for left distribution of multiplication over addition and commutative addition are dropped. Secondly, the class which most mirrors near-semirings is <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Monad.html#t:MonadPlus"><code class="sourceCode haskell"><span class="dt">MonadPlus</span></code></a>, not alternative. (alternative doesn’t have annihilation) Thirdly, right distribution of multiplication over addition <em>isn’t</em> required <code class="sourceCode haskell"><span class="dt">MonadPlus</span></code>: it’s a further law required on top of the existing laws. Fourthly, most types in the Haskell ecosystem today which conform to <code class="sourceCode haskell"><span class="dt">MonadPlus</span></code> <em>don’t</em> conform to this extra law: in fact, those that do seem to be lists of some kind or another.</p>
<p>A further class is probably needed on top of the two already there, with the extra laws <span class="citation" data-cites="fischer_reinventing_2009">(called <code class="sourceCode haskell"><span class="dt">Nondet</span></code> in Fischer <a href="#ref-fischer_reinventing_2009" role="doc-biblioref">2009</a>)</span>.</p>
<p>An actual free near-semiring looks like this:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Free</span> f x <span class="ot">=</span> <span class="dt">Free</span> {<span class="ot"> unFree ::</span> [<span class="dt">FFree</span> f x] }</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">FFree</span> f x <span class="ot">=</span> <span class="dt">Pure</span> x <span class="op">|</span> <span class="dt">Con</span> (f (<span class="dt">Free</span> f x))</span></code></pre></div>
<p>Specialised to the <code class="sourceCode haskell"><span class="dt">Identity</span></code> monad, that becomes:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Forest</span> a <span class="ot">=</span> <span class="dt">Forest</span> {<span class="ot"> unForest ::</span> [<span class="dt">Tree</span> x] }</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Tree</span> x <span class="ot">=</span> <span class="dt">Leaf</span> x <span class="op">|</span> <span class="dt">Branch</span> (<span class="dt">Forest</span> x)</span></code></pre></div>
<p>De-specialised to the <a href="https://hackage.haskell.org/package/free-4.12.4/docs/Control-Monad-Trans-Free.html">free monad transformer</a>, it becomes:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">FreeT</span> f m a <span class="ot">=</span> <span class="dt">FreeT</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true"></a>  {<span class="ot"> runFreeT ::</span> m (<span class="dt">FreeF</span> f a (<span class="dt">FreeT</span> f m a)) }</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true"></a></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">FreeF</span> f a b</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true"></a>  <span class="ot">=</span> <span class="dt">Pure</span> a</span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Free</span> (f b)</span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true"></a></span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">FreeNearSemiring</span> f <span class="ot">=</span> <span class="dt">FreeT</span> f []</span></code></pre></div>
<p>These definitions all lend themselves to combinatorial search <span class="citation" data-cites="spivey_algebras_2009 fischer_reinventing_2009 piponi_monad_2009">(Spivey <a href="#ref-spivey_algebras_2009" role="doc-biblioref">2009</a>; Fischer <a href="#ref-fischer_reinventing_2009" role="doc-biblioref">2009</a>; Piponi <a href="#ref-piponi_monad_2009" role="doc-biblioref">2009</a>)</span>, with one extra operation needed: <code class="sourceCode haskell">wrap</code>.</p>
<h2 id="odds">Odds</h2>
<p>Does the <a href="../posts/2016-09-27-odds-lhs.html">odds monad</a> fit in to any of this?</p>
<p>While <code class="sourceCode haskell"><span class="dt">WriterT</span> (<span class="dt">Product</span> <span class="dt">Rational</span>) []</code> is a valid definition of the traditional probability monad, it’s <em>not</em> the same as the odds monad. If you take the odds monad, and parameterize it over the weight of the tail, you get this:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Odds</span> m a <span class="ot">=</span> <span class="dt">Certain</span> a <span class="op">|</span> <span class="dt">Choice</span> (m (a, <span class="dt">Odds</span> a))</span></code></pre></div>
<p>Which looks remarkably like <a href="http://www.haskellforall.com/2016/07/list-transformer-beginner-friendly-listt.html"><code class="sourceCode haskell"><span class="dt">ListT</span></code> done right</a>:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">ListT</span> m a <span class="ot">=</span> <span class="dt">ListT</span> {<span class="ot"> next ::</span> m (<span class="dt">Step</span> m a) }</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Step</span> m a <span class="ot">=</span> <span class="dt">Cons</span> a (<span class="dt">ListT</span> m a) <span class="op">|</span> <span class="dt">Nil</span></span></code></pre></div>
<p>That suggests a relationship between probability and odds:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true"></a><span class="dt">WriterT</span> (<span class="dt">Product</span>  <span class="dt">Rational</span>) [] <span class="ot">=</span> <span class="dt">Probability</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true"></a><span class="dt">ListT</span>   (<span class="dt">Weighted</span> <span class="dt">Rational</span>)    <span class="ot">=</span> <span class="dt">Odds</span></span></code></pre></div>
<p><code class="sourceCode haskell"><span class="dt">ListT</span></code> isn’t a perfect match, though: it allows empty lists. To correct this, you could use the <a href="https://hackage.haskell.org/package/free-4.12.4/docs/Control-Comonad-Cofree.html">Cofree Comonad</a>:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Cofree</span> f a <span class="ot">=</span> a <span class="op">:&lt;</span> (f (<span class="dt">Cofree</span> f a))</span></code></pre></div>
<p>Subbing in <code class="sourceCode haskell"><span class="dt">Maybe</span></code> for <code class="sourceCode haskell">f</code>, you get a non-empty list. A <em>weighted</em> <code class="sourceCode haskell"><span class="dt">Maybe</span></code> is basically <a href="http://www.randomhacks.net/2007/02/21/refactoring-probability-distributions/"><code class="sourceCode haskell"><span class="dt">PerhapsT</span></code></a>, as was mentioned earlier.</p>
<h2 id="generalizing-semirings">Generalizing Semirings</h2>
<p>Types in haskell also form a semiring.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true"></a>(<span class="op">&lt;.&gt;</span>) <span class="ot">=</span> (,)</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true"></a>one <span class="ot">=</span> ()</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true"></a></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true"></a>(<span class="op">&lt;+&gt;</span>) <span class="ot">=</span> <span class="dt">Either</span></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true"></a>zero <span class="ot">=</span> <span class="dt">Void</span></span></code></pre></div>
<p>There’s a subset of semirings which are <a href="https://en.wikipedia.org/wiki/Semiring#Star_semirings">star semirings</a>. They have an operation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>*</mo><annotation encoding="application/x-tex">*</annotation></semantics></math> such that:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>*</mo><mo>=</mo><mn>1</mn><mo>+</mo><mi>a</mi><mi>a</mi><mo>*</mo><mo>=</mo><mn>1</mn><mo>+</mo><mi>a</mi><mo>*</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">a* = 1 + aa* = 1 + a*a</annotation></semantics></math></p>
<p>Or, as a class:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true"></a><span class="kw">class</span> <span class="dt">Semiring</span> a <span class="ot">=&gt;</span> <span class="dt">StarSemiring</span> a <span class="kw">where</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true"></a><span class="ot">  star ::</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true"></a>  star x <span class="ot">=</span> one <span class="op">&lt;+&gt;</span> plus x</span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true"></a><span class="ot">  plus ::</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true"></a>  plus x <span class="ot">=</span> x <span class="op">&lt;.&gt;</span> star x</span></code></pre></div>
<p>Using this on types, you get:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true"></a>star a <span class="ot">=</span> <span class="dt">Either</span> () (a, star a)</span></code></pre></div>
<p>Which is just a standard list! Some pseudo-haskell on alternatives will give you:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true"></a><span class="ot">star ::</span> (<span class="dt">Alternative</span> f, <span class="dt">Monoid</span> a) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> f a</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true"></a>star x <span class="ot">=</span> (x <span class="op">&lt;.&gt;</span> star x) <span class="op">&lt;+&gt;</span> <span class="fu">pure</span> <span class="fu">mempty</span> <span class="kw">where</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true"></a>  (<span class="op">&lt;.&gt;</span>) <span class="ot">=</span> liftA2 <span class="fu">mappend</span></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true"></a>  (<span class="op">&lt;+&gt;</span>) <span class="ot">=</span> <span class="op">&lt;|&gt;</span></span></code></pre></div>
<p>Also known as <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Applicative.html#v:many"><code class="sourceCode haskell">many</code></a>. (although note that this breaks all the laws)</p>
<p>The <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>*</mo><annotation encoding="application/x-tex">*</annotation></semantics></math> for rationals is defined as <span class="citation" data-cites="droste_semirings_2009">(Droste and Kuich <a href="#ref-droste_semirings_2009" role="doc-biblioref">2009</a>, p8)</span>:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>*</mo><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd columnalign="left"><mfrac><mn>1</mn><mrow><mn>1</mn><mo>−</mo><mi>a</mi></mrow></mfrac></mtd><mtd columnalign="left"><mspace width="1.0em"></mspace><mrow><mtext mathvariant="normal">if </mtext><mspace width="0.333em"></mspace></mrow></mtd><mtd columnalign="left"><mn>0</mn><mo>≤</mo><mi>a</mi><mo>&lt;</mo><mn>1</mn><mo>,</mo></mtd></mtr><mtr><mtd columnalign="left"><mi>∞</mi></mtd><mtd columnalign="left"><mspace width="1.0em"></mspace><mrow><mtext mathvariant="normal">if </mtext><mspace width="0.333em"></mspace></mrow></mtd><mtd columnalign="left"><mi>a</mi><mo>≥</mo><mn>1</mn><mi>.</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">a* = \begin{cases}
  \frac{1}{1 - a} &amp; \quad \text{if  } &amp; 0 \leq a \lt 1, \\
  \infty          &amp; \quad \text{if  } &amp; a \geq 1.
\end{cases}</annotation></semantics></math></p>
<p>So, combining the probability with the type-level business, the star of <code>Writer s a</code> is:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true"></a><span class="dt">Either</span> (<span class="dv">1</span>, a) (a, s <span class="op">/</span> (<span class="dv">1</span> <span class="op">-</span> s), star (<span class="dt">Writer</span> s a))</span></code></pre></div>
<p>Or, to put it another way: the odds monad!</p>
<h2 id="endo">Endo</h2>
<p>An <a href="https://ncatlab.org/nlab/show/endomorphism">endomorphism</a> is a morphism from an object to itself. A less general definition (and the one <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Monoid.html#t:Endo">most often used</a> in Haskell) is a function of the type <code class="sourceCode haskell">a <span class="ot">-&gt;</span> a</code>:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">Endo</span> a <span class="ot">=</span> <span class="dt">Endo</span> {<span class="ot"> appEndo ::</span> a <span class="ot">-&gt;</span> a }</span></code></pre></div>
<p>It forms a monoid under composition:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Monoid</span> (<span class="dt">Endo</span> a) <span class="kw">where</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true"></a>  <span class="fu">mempty</span> <span class="ot">=</span> <span class="dt">Endo</span> <span class="fu">id</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true"></a>  <span class="fu">mappend</span> (<span class="dt">Endo</span> f) (<span class="dt">Endo</span> g) <span class="ot">=</span> <span class="dt">Endo</span> (f <span class="op">.</span> g)</span></code></pre></div>
<p>If the underlying type is itself a commutative monoid, it also forms near-semiring:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Monoid</span> a <span class="ot">=&gt;</span> <span class="dt">Semiring</span> (<span class="dt">Endo</span> a) <span class="kw">where</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true"></a>  <span class="dt">Endo</span> f <span class="op">&lt;+&gt;</span> <span class="dt">Endo</span> g <span class="ot">=</span> <span class="dt">Endo</span> (\x <span class="ot">-&gt;</span> f x <span class="op">&lt;&gt;</span> g x)</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true"></a>  zero <span class="ot">=</span> <span class="dt">Endo</span> (<span class="fu">const</span> <span class="fu">mempty</span>)</span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true"></a>  one <span class="ot">=</span> <span class="dt">Endo</span> <span class="fu">id</span></span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true"></a>  <span class="dt">Endo</span> f <span class="op">&lt;.&gt;</span> <span class="dt">Endo</span> g <span class="ot">=</span> <span class="dt">Endo</span> (f <span class="op">.</span> g)</span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true"></a>  </span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true"></a><span class="kw">instance</span> (<span class="dt">Monoid</span> a, <span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">StarSemiring</span> (<span class="dt">Endo</span> a) <span class="kw">where</span></span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true"></a>  star (<span class="dt">Endo</span> f) <span class="ot">=</span> <span class="dt">Endo</span> converge <span class="kw">where</span></span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true"></a>    converge x <span class="ot">=</span> x <span class="op">&lt;&gt;</span> (<span class="kw">if</span> y <span class="op">==</span> <span class="fu">mempty</span> <span class="kw">then</span> y <span class="kw">else</span> converge y) <span class="kw">where</span></span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true"></a>      y <span class="ot">=</span> f x</span></code></pre></div>
<p>Here’s something interesting: there’s a similarity here to the semiring for church numerals. In fact, as far as I can tell, the functions are <em>exactly</em> the same when applied to endomorphisms of endomorphisms. To the extent that you could define church numerals with something as simple as this:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">ChurchEndoNat</span> <span class="ot">=</span> <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">Endo</span> (<span class="dt">Endo</span> a)</span></code></pre></div>
<p>And it works!</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true"></a>two,<span class="ot"> three ::</span> <span class="dt">ChurchEndoNat</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true"></a>two <span class="ot">=</span> one <span class="op">&lt;+&gt;</span> one</span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true"></a>three <span class="ot">=</span> one <span class="op">&lt;+&gt;</span> two</span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true"></a></span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true"></a><span class="ot">unChurch ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">ChurchEndoNat</span> <span class="ot">-&gt;</span> a</span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true"></a>unChurch f <span class="ot">=</span> appEndo (appEndo f (<span class="dt">Endo</span> (<span class="dv">1</span><span class="op">+</span>))) <span class="dv">0</span></span></code></pre></div>
<div class="sourceCode" id="cb53"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true"></a>unChurch (two <span class="op">&lt;.&gt;</span> three)</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true"></a><span class="dv">6</span></span></code></pre></div>
<h2 id="regex">Regex</h2>
<p>One of the most important applications (and a source of much of the notation) is regular expressions. In fact, the free semiring looks like a haskell datatype for regular expressions:</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">FreeStar</span> a</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true"></a> <span class="ot">=</span> <span class="dt">Gen</span> a</span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true"></a> <span class="op">|</span> <span class="dt">Zer</span></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true"></a> <span class="op">|</span> <span class="dt">One</span></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true"></a> <span class="op">|</span> <span class="dt">FreeStar</span> a <span class="op">:&lt;+&gt;</span> <span class="dt">FreeStar</span> a</span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true"></a> <span class="op">|</span> <span class="dt">FreeStar</span> a <span class="op">:&lt;.&gt;</span> <span class="dt">FreeStar</span> a</span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true"></a> <span class="op">|</span> <span class="dt">Star</span> (<span class="dt">FreeStar</span> a)</span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true"></a></span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Semiring</span> (<span class="dt">FreeStar</span> a) <span class="kw">where</span></span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true"></a>  (<span class="op">&lt;+&gt;</span>) <span class="ot">=</span> (<span class="op">:&lt;+&gt;</span>)</span>
<span id="cb54-11"><a href="#cb54-11" aria-hidden="true"></a>  (<span class="op">&lt;.&gt;</span>) <span class="ot">=</span> (<span class="op">:&lt;.&gt;</span>)</span>
<span id="cb54-12"><a href="#cb54-12" aria-hidden="true"></a>  zero <span class="ot">=</span> <span class="dt">Zer</span></span>
<span id="cb54-13"><a href="#cb54-13" aria-hidden="true"></a>  one <span class="ot">=</span> <span class="dt">One</span></span>
<span id="cb54-14"><a href="#cb54-14" aria-hidden="true"></a>  </span>
<span id="cb54-15"><a href="#cb54-15" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">StarSemiring</span> (<span class="dt">FreeStar</span> a) <span class="kw">where</span></span>
<span id="cb54-16"><a href="#cb54-16" aria-hidden="true"></a>  star <span class="ot">=</span> <span class="dt">Star</span></span>
<span id="cb54-17"><a href="#cb54-17" aria-hidden="true"></a>  </span>
<span id="cb54-18"><a href="#cb54-18" aria-hidden="true"></a><span class="ot">interpret ::</span> <span class="dt">StarSemiring</span> s <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> s) <span class="ot">-&gt;</span> <span class="dt">FreeStar</span> a <span class="ot">-&gt;</span> s</span>
<span id="cb54-19"><a href="#cb54-19" aria-hidden="true"></a>interpret f <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb54-20"><a href="#cb54-20" aria-hidden="true"></a>  <span class="dt">Gen</span> x <span class="ot">-&gt;</span> f x</span>
<span id="cb54-21"><a href="#cb54-21" aria-hidden="true"></a>  <span class="dt">Zer</span> <span class="ot">-&gt;</span> zero</span>
<span id="cb54-22"><a href="#cb54-22" aria-hidden="true"></a>  <span class="dt">One</span> <span class="ot">-&gt;</span> one</span>
<span id="cb54-23"><a href="#cb54-23" aria-hidden="true"></a>  l <span class="op">:&lt;+&gt;</span> r <span class="ot">-&gt;</span> interpret f l <span class="op">&lt;+&gt;</span> interpret f r</span>
<span id="cb54-24"><a href="#cb54-24" aria-hidden="true"></a>  l <span class="op">:&lt;.&gt;</span> r <span class="ot">-&gt;</span> interpret f l <span class="op">&lt;.&gt;</span> interpret f r</span>
<span id="cb54-25"><a href="#cb54-25" aria-hidden="true"></a>  <span class="dt">Star</span> x <span class="ot">-&gt;</span> star (interpret f x)</span></code></pre></div>
<p>Then, interpreting the regex is as simple as writing an interpreter (with some help from <code class="sourceCode haskell"><span class="dt">Endo</span></code>):</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true"></a><span class="ot">asRegex ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> <span class="dt">FreeStar</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true"></a>asRegex fs <span class="ot">=</span> <span class="fu">any</span> <span class="fu">null</span> <span class="op">.</span> appEndo (interpret f fs) <span class="op">.</span> <span class="fu">pure</span> <span class="kw">where</span></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true"></a>  f p <span class="ot">=</span> <span class="dt">Endo</span> <span class="op">.</span> mapMaybe <span class="op">$</span> \<span class="kw">case</span></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true"></a>    (x<span class="op">:</span>xs) <span class="op">|</span> p x <span class="ot">-&gt;</span> <span class="dt">Just</span> xs</span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true"></a>    _ <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true"></a></span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true"></a><span class="ot">char' ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">FreeStar</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true"></a>char' c <span class="ot">=</span> <span class="dt">Gen</span> (c<span class="op">==</span>)</span></code></pre></div>
<p>Actually, you don’t need the free version at all!</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true"></a><span class="ot">runRegex ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> <span class="dt">Endo</span> [[a]] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true"></a>runRegex fs <span class="ot">=</span> <span class="fu">any</span> <span class="fu">null</span> <span class="op">.</span> appEndo fs <span class="op">.</span> <span class="fu">pure</span></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true"></a></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true"></a><span class="ot">char ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Endo</span> [[a]]</span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true"></a>char c <span class="ot">=</span> <span class="dt">Endo</span> <span class="op">.</span> mapMaybe <span class="op">$</span> \<span class="kw">case</span></span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true"></a>  (x<span class="op">:</span>xs) <span class="op">|</span> c <span class="op">==</span> x <span class="ot">-&gt;</span> <span class="dt">Just</span> xs</span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true"></a>  _ <span class="ot">-&gt;</span> <span class="dt">Nothing</span>  </span></code></pre></div>
<p>With some <code class="sourceCode haskell"><span class="op">-</span><span class="dt">XOverloadedStrings</span></code> magic, you get a pretty nice interface:</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">IsString</span> (<span class="dt">Endo</span> [<span class="dt">String</span>]) <span class="kw">where</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true"></a>  fromString <span class="ot">=</span> mul <span class="op">.</span> <span class="fu">map</span> char <span class="op">.</span> <span class="fu">reverse</span></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true"></a>  </span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true"></a><span class="ot">(&lt;^&gt;) ::</span> <span class="dt">Semiring</span> s <span class="ot">=&gt;</span> s <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> s</span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true"></a>(<span class="op">&lt;^&gt;</span>) <span class="ot">=</span> <span class="fu">flip</span> (<span class="op">&lt;.&gt;</span>)</span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true"></a></span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true"></a><span class="ot">greet ::</span> <span class="dt">Endo</span> [<span class="dt">String</span>]</span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true"></a>greet <span class="ot">=</span> <span class="st">&quot;H&quot;</span> <span class="op">&lt;^&gt;</span> (<span class="st">&quot;a&quot;</span> <span class="op">&lt;+&gt;</span> <span class="st">&quot;e&quot;</span>) <span class="op">&lt;^&gt;</span> <span class="st">&quot;llo&quot;</span></span></code></pre></div>
<div class="sourceCode" id="cb58"><pre class="sourceCode haskell literate example hidden_source"><code class="sourceCode haskell"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true"></a><span class="op">:</span>set <span class="op">-</span><span class="dt">XOverloadedStrings</span></span></code></pre></div>
<div class="sourceCode" id="cb59"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true"></a>runRegex greet <span class="st">&quot;Hello&quot;</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true"></a><span class="dt">True</span></span></code></pre></div>
<div class="sourceCode" id="cb60"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true"></a>runRegex greet <span class="st">&quot;Hallo&quot;</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true"></a><span class="dt">True</span></span></code></pre></div>
<div class="sourceCode" id="cb61"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true"></a>runRegex greet <span class="st">&quot;Halo&quot;</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true"></a><span class="dt">False</span></span></code></pre></div>
<h2 id="efficiency">Efficiency</h2>
<p>Of course, that’s about as slow as it gets when it comes to regexes. A faster representation is a <a href="https://swtch.com/~rsc/regexp/regexp1.html">nondeterministic finite automaton</a>. One such implementation in haskell is <a href="https://github.com/Gabriel439/slides/blob/master/regex/regex.md">Gabriel Gonzalez’s</a>.</p>
<p>The regex type in that example can be immediately made to conform to <code class="sourceCode haskell"><span class="dt">Semiring</span></code> and <code class="sourceCode haskell"><span class="dt">StarSemiring</span></code>. However, it might be more interesting to translate the <em>implementation</em> into using semirings. The type of a regex looks like this:</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">State</span> <span class="ot">=</span> <span class="dt">Int</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true"></a></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true"></a>{<span class="ot"> _startingStates         ::</span> <span class="dt">Set</span> <span class="dt">State</span></span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true"></a>,<span class="ot"> _transitionFunction     ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="ot">-&gt;</span> <span class="dt">Set</span> <span class="dt">State</span></span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true"></a>,<span class="ot"> _acceptingStates        ::</span> <span class="dt">Set</span> <span class="dt">State</span> }</span></code></pre></div>
<p>The set data structure jumps out as an opportunity to sub in arbitrary semirings.Swapping in the <code class="sourceCode haskell"><span class="dt">GeneralMap</span></code> is reasonably easy:</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">State</span> <span class="ot">=</span> <span class="dt">Int</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true"></a></span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Regex</span> i s <span class="ot">=</span> <span class="dt">Regex</span></span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true"></a>  {<span class="ot"> _numberOfStates     ::</span> <span class="dt">Int</span> </span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true"></a>  ,<span class="ot"> _startingStates     ::</span> <span class="dt">GeneralMap</span> <span class="dt">State</span> s</span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true"></a>  ,<span class="ot"> _transitionFunction ::</span> i <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> <span class="dt">State</span> s</span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true"></a>  ,<span class="ot"> _acceptingStates    ::</span> <span class="dt">GeneralMap</span> <span class="dt">State</span> s }</span>
<span id="cb63-8"><a href="#cb63-8" aria-hidden="true"></a></span>
<span id="cb63-9"><a href="#cb63-9" aria-hidden="true"></a><span class="ot">isEnd ::</span> <span class="dt">Semiring</span> s <span class="ot">=&gt;</span> <span class="dt">Regex</span> i s <span class="ot">-&gt;</span> s</span>
<span id="cb63-10"><a href="#cb63-10" aria-hidden="true"></a>isEnd (<span class="dt">Regex</span> _ as _ bs) <span class="ot">=</span> add (intersection as bs)</span>
<span id="cb63-11"><a href="#cb63-11" aria-hidden="true"></a></span>
<span id="cb63-12"><a href="#cb63-12" aria-hidden="true"></a><span class="ot">match ::</span> <span class="dt">Regex</span> <span class="dt">Char</span> (<span class="dt">Add</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb63-13"><a href="#cb63-13" aria-hidden="true"></a>match r <span class="ot">=</span> getAdd <span class="op">.</span> isEnd <span class="op">.</span> foldl' run r <span class="kw">where</span></span>
<span id="cb63-14"><a href="#cb63-14" aria-hidden="true"></a>  run (<span class="dt">Regex</span> n (<span class="dt">GeneralMap</span> as) f bs) i <span class="ot">=</span> <span class="dt">Regex</span> n as' f bs</span>
<span id="cb63-15"><a href="#cb63-15" aria-hidden="true"></a>    <span class="kw">where</span> as' <span class="ot">=</span> <span class="fu">mconcat</span> [ <span class="fu">fmap</span> (v<span class="op">&lt;.&gt;</span>) (f i k)  <span class="op">|</span> (k,v) <span class="ot">&lt;-</span> Map.assocs as ]</span>
<span id="cb63-16"><a href="#cb63-16" aria-hidden="true"></a></span>
<span id="cb63-17"><a href="#cb63-17" aria-hidden="true"></a></span>
<span id="cb63-18"><a href="#cb63-18" aria-hidden="true"></a><span class="ot">satisfy ::</span> <span class="dt">Semiring</span> s <span class="ot">=&gt;</span> (i <span class="ot">-&gt;</span> s) <span class="ot">-&gt;</span> <span class="dt">Regex</span> i (<span class="dt">Add</span> s)</span>
<span id="cb63-19"><a href="#cb63-19" aria-hidden="true"></a>satisfy predicate <span class="ot">=</span> <span class="dt">Regex</span> <span class="dv">2</span> as f bs</span>
<span id="cb63-20"><a href="#cb63-20" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb63-21"><a href="#cb63-21" aria-hidden="true"></a>    as <span class="ot">=</span> singleton <span class="dv">0</span></span>
<span id="cb63-22"><a href="#cb63-22" aria-hidden="true"></a>    bs <span class="ot">=</span> singleton <span class="dv">1</span></span>
<span id="cb63-23"><a href="#cb63-23" aria-hidden="true"></a></span>
<span id="cb63-24"><a href="#cb63-24" aria-hidden="true"></a>    f i <span class="dv">0</span> <span class="ot">=</span> assoc <span class="dv">1</span> (predicate i) <span class="fu">mempty</span></span>
<span id="cb63-25"><a href="#cb63-25" aria-hidden="true"></a>    f _ _ <span class="ot">=</span> <span class="fu">mempty</span></span>
<span id="cb63-26"><a href="#cb63-26" aria-hidden="true"></a></span>
<span id="cb63-27"><a href="#cb63-27" aria-hidden="true"></a><span class="ot">once ::</span> <span class="dt">Eq</span> i <span class="ot">=&gt;</span> i <span class="ot">-&gt;</span> <span class="dt">Regex</span> i (<span class="dt">Add</span> <span class="dt">Bool</span>)</span>
<span id="cb63-28"><a href="#cb63-28" aria-hidden="true"></a>once x <span class="ot">=</span> satisfy (<span class="op">==</span> x)</span>
<span id="cb63-29"><a href="#cb63-29" aria-hidden="true"></a></span>
<span id="cb63-30"><a href="#cb63-30" aria-hidden="true"></a><span class="ot">shift ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> <span class="dt">State</span> s <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> <span class="dt">State</span> s</span>
<span id="cb63-31"><a href="#cb63-31" aria-hidden="true"></a>shift n <span class="ot">=</span> <span class="dt">GeneralMap</span> <span class="op">.</span> Map.fromAscList <span class="op">.</span> (<span class="fu">map</span><span class="op">.</span>first) (<span class="op">+</span> n) <span class="op">.</span> Map.toAscList <span class="op">.</span> getMap</span>
<span id="cb63-32"><a href="#cb63-32" aria-hidden="true"></a></span>
<span id="cb63-33"><a href="#cb63-33" aria-hidden="true"></a><span class="kw">instance</span> (<span class="dt">Semiring</span> s, <span class="dt">Monoid</span> s) <span class="ot">=&gt;</span> <span class="dt">Semiring</span> (<span class="dt">Regex</span> i s) <span class="kw">where</span></span>
<span id="cb63-34"><a href="#cb63-34" aria-hidden="true"></a></span>
<span id="cb63-35"><a href="#cb63-35" aria-hidden="true"></a>  one <span class="ot">=</span> <span class="dt">Regex</span> <span class="dv">1</span> (singleton <span class="dv">0</span>) (\_ _ <span class="ot">-&gt;</span> <span class="fu">mempty</span>) (singleton <span class="dv">0</span>)</span>
<span id="cb63-36"><a href="#cb63-36" aria-hidden="true"></a>  zero <span class="ot">=</span> <span class="dt">Regex</span> <span class="dv">0</span> <span class="fu">mempty</span> (\_ _ <span class="ot">-&gt;</span> <span class="fu">mempty</span>) <span class="fu">mempty</span></span>
<span id="cb63-37"><a href="#cb63-37" aria-hidden="true"></a></span>
<span id="cb63-38"><a href="#cb63-38" aria-hidden="true"></a>  <span class="dt">Regex</span> nL asL fL bsL <span class="op">&lt;+&gt;</span> <span class="dt">Regex</span> nR asR fR bsR <span class="ot">=</span> <span class="dt">Regex</span> n as f bs</span>
<span id="cb63-39"><a href="#cb63-39" aria-hidden="true"></a>    <span class="kw">where</span></span>
<span id="cb63-40"><a href="#cb63-40" aria-hidden="true"></a>      n  <span class="ot">=</span> nL <span class="op">+</span> nR</span>
<span id="cb63-41"><a href="#cb63-41" aria-hidden="true"></a>      as <span class="ot">=</span> <span class="fu">mappend</span> asL (shift nL asR)</span>
<span id="cb63-42"><a href="#cb63-42" aria-hidden="true"></a>      bs <span class="ot">=</span> <span class="fu">mappend</span> bsL (shift nL bsR)</span>
<span id="cb63-43"><a href="#cb63-43" aria-hidden="true"></a>      f i s <span class="op">|</span> s <span class="op">&lt;</span> nL    <span class="ot">=</span> fL i s</span>
<span id="cb63-44"><a href="#cb63-44" aria-hidden="true"></a>            <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> shift nL (fR i (s <span class="op">-</span> nL))</span>
<span id="cb63-45"><a href="#cb63-45" aria-hidden="true"></a></span>
<span id="cb63-46"><a href="#cb63-46" aria-hidden="true"></a>  <span class="dt">Regex</span> nL asL fL bsL <span class="op">&lt;.&gt;</span> <span class="dt">Regex</span> nR asR fR bsR <span class="ot">=</span> <span class="dt">Regex</span> n as f bs <span class="kw">where</span></span>
<span id="cb63-47"><a href="#cb63-47" aria-hidden="true"></a></span>
<span id="cb63-48"><a href="#cb63-48" aria-hidden="true"></a>    n <span class="ot">=</span> nL <span class="op">+</span> nR</span>
<span id="cb63-49"><a href="#cb63-49" aria-hidden="true"></a></span>
<span id="cb63-50"><a href="#cb63-50" aria-hidden="true"></a>    as <span class="ot">=</span> <span class="kw">let</span> ss <span class="ot">=</span> add (intersection asL bsL)</span>
<span id="cb63-51"><a href="#cb63-51" aria-hidden="true"></a>         <span class="kw">in</span> <span class="fu">mappend</span> asL (<span class="fu">fmap</span> (ss<span class="op">&lt;.&gt;</span>) (shift nL asR))</span>
<span id="cb63-52"><a href="#cb63-52" aria-hidden="true"></a></span>
<span id="cb63-53"><a href="#cb63-53" aria-hidden="true"></a>    f i s <span class="ot">=</span></span>
<span id="cb63-54"><a href="#cb63-54" aria-hidden="true"></a>        <span class="kw">if</span> s <span class="op">&lt;</span> nL</span>
<span id="cb63-55"><a href="#cb63-55" aria-hidden="true"></a>        <span class="kw">then</span> <span class="kw">let</span> ss <span class="ot">=</span> add (intersection r bsL)</span>
<span id="cb63-56"><a href="#cb63-56" aria-hidden="true"></a>             <span class="kw">in</span> <span class="fu">mappend</span> r (<span class="fu">fmap</span> (ss<span class="op">&lt;.&gt;</span>) (shift nL asR))</span>
<span id="cb63-57"><a href="#cb63-57" aria-hidden="true"></a>        <span class="kw">else</span> shift nL (fR i (s <span class="op">-</span> nL))</span>
<span id="cb63-58"><a href="#cb63-58" aria-hidden="true"></a>      <span class="kw">where</span></span>
<span id="cb63-59"><a href="#cb63-59" aria-hidden="true"></a>        r <span class="ot">=</span> fL i s</span>
<span id="cb63-60"><a href="#cb63-60" aria-hidden="true"></a>    bs <span class="ot">=</span> shift nL bsR</span>
<span id="cb63-61"><a href="#cb63-61" aria-hidden="true"></a></span>
<span id="cb63-62"><a href="#cb63-62" aria-hidden="true"></a><span class="kw">instance</span> (<span class="dt">StarSemiring</span> s, <span class="dt">Monoid</span> s) <span class="ot">=&gt;</span> <span class="dt">StarSemiring</span> (<span class="dt">Regex</span> i s) <span class="kw">where</span></span>
<span id="cb63-63"><a href="#cb63-63" aria-hidden="true"></a>  star (<span class="dt">Regex</span> n as f bs) <span class="ot">=</span> <span class="dt">Regex</span> n as f' as</span>
<span id="cb63-64"><a href="#cb63-64" aria-hidden="true"></a>    <span class="kw">where</span></span>
<span id="cb63-65"><a href="#cb63-65" aria-hidden="true"></a>      f' i s <span class="ot">=</span></span>
<span id="cb63-66"><a href="#cb63-66" aria-hidden="true"></a>          <span class="kw">let</span> r <span class="ot">=</span> f i s</span>
<span id="cb63-67"><a href="#cb63-67" aria-hidden="true"></a>              ss <span class="ot">=</span> add (intersection r bs)</span>
<span id="cb63-68"><a href="#cb63-68" aria-hidden="true"></a>          <span class="kw">in</span> <span class="fu">mappend</span> r (<span class="fu">fmap</span> (ss<span class="op">&lt;.&gt;</span>) as)</span>
<span id="cb63-69"><a href="#cb63-69" aria-hidden="true"></a></span>
<span id="cb63-70"><a href="#cb63-70" aria-hidden="true"></a>  plus (<span class="dt">Regex</span> n as f bs) <span class="ot">=</span> <span class="dt">Regex</span> n as f' bs</span>
<span id="cb63-71"><a href="#cb63-71" aria-hidden="true"></a>    <span class="kw">where</span></span>
<span id="cb63-72"><a href="#cb63-72" aria-hidden="true"></a>      f' i s <span class="ot">=</span></span>
<span id="cb63-73"><a href="#cb63-73" aria-hidden="true"></a>          <span class="kw">let</span> r <span class="ot">=</span> f i s</span>
<span id="cb63-74"><a href="#cb63-74" aria-hidden="true"></a>              ss <span class="ot">=</span> add (intersection r bs)</span>
<span id="cb63-75"><a href="#cb63-75" aria-hidden="true"></a>          <span class="kw">in</span> <span class="fu">mappend</span> r (<span class="fu">fmap</span> (ss<span class="op">&lt;.&gt;</span>) as)</span>
<span id="cb63-76"><a href="#cb63-76" aria-hidden="true"></a></span>
<span id="cb63-77"><a href="#cb63-77" aria-hidden="true"></a></span>
<span id="cb63-78"><a href="#cb63-78" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">IsString</span> (<span class="dt">Regex</span> <span class="dt">Char</span> (<span class="dt">Add</span> <span class="dt">Bool</span>)) <span class="kw">where</span></span>
<span id="cb63-79"><a href="#cb63-79" aria-hidden="true"></a>  fromString <span class="ot">=</span> mul <span class="op">.</span> <span class="fu">map</span> once</span></code></pre></div>
<p>This begins to show some of the real power of using semirings and covectors. We have a normal regular expression implementation when we use the covector over bools. Use the probability semiring, and you’ve got probabilistic parsing.</p>
<p>Swap in the <a href="https://ncatlab.org/nlab/show/max-plus+algebra">tropical semiring</a>: a semiring over the reals where addition is the max function, and multiplication is addition of reals. Now you’ve got a depth-first parser.</p>
<p>That’s how you might swap in different interpretations. How about swapping in different <em>implementations</em>? Well, there might be some use to swapping in the <a href="https://en.wikipedia.org/wiki/CYK_algorithm">CYK algorithm</a>, or the Gauss-Jordan-Floyd-Warshall-McNaughton-Yamada algorithm <span class="citation" data-cites="oconnor_very_2011">(O’Connor <a href="#ref-oconnor_very_2011" role="doc-biblioref">2011</a>)</span>.</p>
<p>Alternatively, you can swap in the underlying data structure. Instead of a map, if you use an integer (each bit being a value, the keys being the bit position), you have a super-fast implementation (and the final implementation used in the original example). Finally, you could use a different representation of the state transfer function: a matrix.</p>
<h2 id="square-matrices">Square Matrices</h2>
<p>A square matrix can be understood as a map from pairs of indices to values. This lets us use it to represent the state transfer function. Take, for instance, a regular expression with three possible states. Its state transfer function might look like this:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">transfer</mtext><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd columnalign="left"><mn>1</mn><mspace width="1.0em"></mspace></mtd><mtd columnalign="left"><mo stretchy="false" form="prefix">{</mo><mn>2</mn><mo>,</mo><mn>3</mn><mo stretchy="false" form="postfix">}</mo></mtd></mtr><mtr><mtd columnalign="left"><mn>2</mn><mspace width="1.0em"></mspace></mtd><mtd columnalign="left"><mo stretchy="false" form="prefix">{</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo></mtd></mtr><mtr><mtd columnalign="left"><mn>3</mn><mspace width="1.0em"></mspace></mtd><mtd columnalign="left"><mi>∅</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\text{transfer} = \begin{cases}
1 \quad &amp; \{ 2, 3 \} \\
2 \quad &amp; \{ 1 \} \\
3 \quad &amp; \emptyset
\end{cases}</annotation></semantics></math></p>
<p>It has the type of:</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true"></a><span class="dt">State</span> <span class="ot">-&gt;</span> <span class="dt">Set</span> <span class="dt">State</span></span></code></pre></div>
<p>Where <code class="sourceCode haskell"><span class="dt">State</span></code> is an integer. You can represent the set as a vector, where each position is a key, and each value is whether or not that key is present:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">transfer</mtext><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd columnalign="left"><mn>1</mn><mspace width="1.0em"></mspace></mtd><mtd columnalign="left"><mn>0</mn></mtd><mtd columnalign="left"><mn>1</mn></mtd><mtd columnalign="left"><mn>1</mn></mtd></mtr><mtr><mtd columnalign="left"><mn>2</mn><mspace width="1.0em"></mspace></mtd><mtd columnalign="left"><mn>1</mn></mtd><mtd columnalign="left"><mn>0</mn></mtd><mtd columnalign="left"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="left"><mn>3</mn><mspace width="1.0em"></mspace></mtd><mtd columnalign="left"><mn>0</mn></mtd><mtd columnalign="left"><mn>0</mn></mtd><mtd columnalign="left"><mn>0</mn></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\text{transfer} = \begin{cases}
1 \quad &amp; 0 &amp; 1 &amp; 1 \\
2 \quad &amp; 1 &amp; 0 &amp; 0 \\
3 \quad &amp; 0 &amp; 0 &amp; 0 \end{cases}</annotation></semantics></math></p>
<p>Then, the matrix representation is obvious:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">transfer</mtext><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center"><mn>0</mn></mtd><mtd columnalign="center"><mn>1</mn></mtd><mtd columnalign="center"><mn>1</mn></mtd></mtr><mtr><mtd columnalign="center"><mn>1</mn></mtd><mtd columnalign="center"><mn>0</mn></mtd><mtd columnalign="center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center"><mn>0</mn></mtd><mtd columnalign="center"><mn>0</mn></mtd><mtd columnalign="center"><mn>0</mn></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\text{transfer} = \left( \begin{array}{ccc}
0 &amp; 1 &amp; 1 \\
1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 \end{array} \right)</annotation></semantics></math></p>
<p>This is the semiring of square matrices. It is, of course, yet <em>another</em> covector. The “keys” are the transfers: <code class="sourceCode haskell"><span class="dv">1</span> <span class="ot">-&gt;</span> <span class="dv">2</span></code> or <code class="sourceCode haskell"><span class="dv">2</span> <span class="ot">-&gt;</span> <span class="dv">3</span></code>, represented by the indices of the matrix. The “values” are whether or not that transfer is permitted.</p>
<p>The algorithms for the usual semiring operations on matrices like this are well-known and well-optimized. I haven’t yet benchmarked them in Haskell using the matrix libraries, so I don’t know how they compare to the other approaches. In the meantime, there’s an elegant list-based implementation in <span class="citation" data-cites="dolan_fun_2013">Dolan (<a href="#ref-dolan_fun_2013" role="doc-biblioref">2013</a>)</span>:</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Matrix</span> a <span class="ot">=</span> <span class="dt">Scalar</span> a</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true"></a>              <span class="op">|</span> <span class="dt">Matrix</span> [[a]]</span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true"></a>              </span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true"></a><span class="ot">mjoin ::</span> (<span class="dt">Matrix</span> a, <span class="dt">Matrix</span> a, <span class="dt">Matrix</span> a, <span class="dt">Matrix</span> a) <span class="ot">-&gt;</span> <span class="dt">Matrix</span> a</span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true"></a>mjoin (<span class="dt">Matrix</span> ws, <span class="dt">Matrix</span> xs, <span class="dt">Matrix</span> ys, <span class="dt">Matrix</span> zs) <span class="ot">=</span></span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true"></a>  <span class="dt">Matrix</span> ((<span class="fu">zipWith</span> (<span class="op">++</span>) ws xs) <span class="op">++</span> (<span class="fu">zipWith</span> (<span class="op">++</span>) ys zs))</span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true"></a>  </span>
<span id="cb65-8"><a href="#cb65-8" aria-hidden="true"></a><span class="ot">msplit ::</span> <span class="dt">Matrix</span> a <span class="ot">-&gt;</span> (<span class="dt">Matrix</span> a, <span class="dt">Matrix</span> a, <span class="dt">Matrix</span> a, <span class="dt">Matrix</span> a)</span>
<span id="cb65-9"><a href="#cb65-9" aria-hidden="true"></a>msplit (<span class="dt">Matrix</span> (row<span class="op">:</span>rows)) <span class="ot">=</span> </span>
<span id="cb65-10"><a href="#cb65-10" aria-hidden="true"></a>  (<span class="dt">Matrix</span> [[first]], <span class="dt">Matrix</span> [top]</span>
<span id="cb65-11"><a href="#cb65-11" aria-hidden="true"></a>  ,<span class="dt">Matrix</span> left,      <span class="dt">Matrix</span> rest )</span>
<span id="cb65-12"><a href="#cb65-12" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb65-13"><a href="#cb65-13" aria-hidden="true"></a>    (first<span class="op">:</span>top) <span class="ot">=</span> row</span>
<span id="cb65-14"><a href="#cb65-14" aria-hidden="true"></a>    (left,rest) <span class="ot">=</span> <span class="fu">unzip</span> (<span class="fu">map</span> (\(x<span class="op">:</span>xs) <span class="ot">-&gt;</span> ([x],xs)) rows)</span>
<span id="cb65-15"><a href="#cb65-15" aria-hidden="true"></a>    </span>
<span id="cb65-16"><a href="#cb65-16" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Semiring</span> a <span class="ot">=&gt;</span> <span class="dt">Semiring</span> (<span class="dt">Matrix</span> a) <span class="kw">where</span></span>
<span id="cb65-17"><a href="#cb65-17" aria-hidden="true"></a>  zero <span class="ot">=</span> <span class="dt">Scalar</span> zero</span>
<span id="cb65-18"><a href="#cb65-18" aria-hidden="true"></a>  one <span class="ot">=</span> <span class="dt">Scalar</span> one</span>
<span id="cb65-19"><a href="#cb65-19" aria-hidden="true"></a>  <span class="dt">Scalar</span> x <span class="op">&lt;+&gt;</span> <span class="dt">Scalar</span> y <span class="ot">=</span> <span class="dt">Scalar</span> (x <span class="op">&lt;+&gt;</span> y)</span>
<span id="cb65-20"><a href="#cb65-20" aria-hidden="true"></a>  <span class="dt">Matrix</span> x <span class="op">&lt;+&gt;</span> <span class="dt">Matrix</span> y <span class="ot">=</span></span>
<span id="cb65-21"><a href="#cb65-21" aria-hidden="true"></a>    <span class="dt">Matrix</span> (<span class="fu">zipWith</span> (<span class="fu">zipWith</span> (<span class="op">&lt;+&gt;</span>)) x y)</span>
<span id="cb65-22"><a href="#cb65-22" aria-hidden="true"></a>  <span class="dt">Scalar</span> x <span class="op">&lt;+&gt;</span> m <span class="ot">=</span> m <span class="op">&lt;+&gt;</span> <span class="dt">Scalar</span> x</span>
<span id="cb65-23"><a href="#cb65-23" aria-hidden="true"></a>  <span class="dt">Matrix</span> [[x]] <span class="op">&lt;+&gt;</span> <span class="dt">Scalar</span> y <span class="ot">=</span> <span class="dt">Matrix</span> [[x <span class="op">&lt;+&gt;</span> y]]</span>
<span id="cb65-24"><a href="#cb65-24" aria-hidden="true"></a>  x <span class="op">&lt;+&gt;</span> y <span class="ot">=</span> mjoin (first <span class="op">&lt;+&gt;</span> y, top, left, rest <span class="op">&lt;+&gt;</span> y)</span>
<span id="cb65-25"><a href="#cb65-25" aria-hidden="true"></a>    <span class="kw">where</span> (first, top, left, rest) <span class="ot">=</span> msplit x</span>
<span id="cb65-26"><a href="#cb65-26" aria-hidden="true"></a>  <span class="dt">Scalar</span> x <span class="op">&lt;.&gt;</span> <span class="dt">Scalar</span> y <span class="ot">=</span> <span class="dt">Scalar</span> (x <span class="op">&lt;.&gt;</span> y)</span>
<span id="cb65-27"><a href="#cb65-27" aria-hidden="true"></a>  <span class="dt">Scalar</span> x <span class="op">&lt;.&gt;</span> <span class="dt">Matrix</span> y <span class="ot">=</span> <span class="dt">Matrix</span> ((<span class="fu">map</span><span class="op">.</span><span class="fu">map</span>) (x<span class="op">&lt;.&gt;</span>) y)</span>
<span id="cb65-28"><a href="#cb65-28" aria-hidden="true"></a>  <span class="dt">Matrix</span> x <span class="op">&lt;.&gt;</span> <span class="dt">Scalar</span> y <span class="ot">=</span> <span class="dt">Matrix</span> ((<span class="fu">map</span><span class="op">.</span><span class="fu">map</span>) (<span class="op">&lt;.&gt;</span>y) x)</span>
<span id="cb65-29"><a href="#cb65-29" aria-hidden="true"></a>  <span class="dt">Matrix</span> x <span class="op">&lt;.&gt;</span> <span class="dt">Matrix</span> y <span class="ot">=</span> </span>
<span id="cb65-30"><a href="#cb65-30" aria-hidden="true"></a>    <span class="dt">Matrix</span> [ [ <span class="fu">foldl1</span> (<span class="op">&lt;+&gt;</span>) (<span class="fu">zipWith</span> (<span class="op">&lt;.&gt;</span>) row col) <span class="op">|</span> col <span class="ot">&lt;-</span> cols ] </span>
<span id="cb65-31"><a href="#cb65-31" aria-hidden="true"></a>           <span class="op">|</span> row <span class="ot">&lt;-</span> x ] <span class="kw">where</span> cols <span class="ot">=</span> transpose y</span>
<span id="cb65-32"><a href="#cb65-32" aria-hidden="true"></a></span>
<span id="cb65-33"><a href="#cb65-33" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">StarSemiring</span> a <span class="ot">=&gt;</span> <span class="dt">StarSemiring</span> (<span class="dt">Matrix</span> a) <span class="kw">where</span></span>
<span id="cb65-34"><a href="#cb65-34" aria-hidden="true"></a>  star (<span class="dt">Matrix</span> [[x]]) <span class="ot">=</span> <span class="dt">Matrix</span> [[star x]]</span>
<span id="cb65-35"><a href="#cb65-35" aria-hidden="true"></a>  star m <span class="ot">=</span> mjoin (first' <span class="op">&lt;+&gt;</span> top' <span class="op">&lt;.&gt;</span> rest' <span class="op">&lt;.&gt;</span> left'</span>
<span id="cb65-36"><a href="#cb65-36" aria-hidden="true"></a>                 ,top' <span class="op">&lt;.&gt;</span> rest', rest' <span class="op">&lt;.&gt;</span> left', rest')</span>
<span id="cb65-37"><a href="#cb65-37" aria-hidden="true"></a>    <span class="kw">where</span></span>
<span id="cb65-38"><a href="#cb65-38" aria-hidden="true"></a>      (first, top, left, rest) <span class="ot">=</span> msplit m</span>
<span id="cb65-39"><a href="#cb65-39" aria-hidden="true"></a>      first' <span class="ot">=</span> star first</span>
<span id="cb65-40"><a href="#cb65-40" aria-hidden="true"></a>      top' <span class="ot">=</span> first' <span class="op">&lt;.&gt;</span> top</span>
<span id="cb65-41"><a href="#cb65-41" aria-hidden="true"></a>      left' <span class="ot">=</span> left <span class="op">&lt;.&gt;</span> first'</span>
<span id="cb65-42"><a href="#cb65-42" aria-hidden="true"></a>      rest' <span class="ot">=</span> star (rest <span class="op">&lt;+&gt;</span> left' <span class="op">&lt;.&gt;</span> top)</span></code></pre></div>
<h2 id="permutation-parsing">Permutation parsing</h2>
<p>A lot of the use from semirings comes from “attaching” them to other values. Attaching a semiring to effects (in the form of an applicative) can give you <em>repetition</em> of those effects. The excellent <a href="http://hackage.haskell.org/package/ReplicateEffects">ReplicateEffects</a> library explores this concept in depth.</p>
<p>It’s based on this type:</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Replicate</span> a b</span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true"></a>  <span class="ot">=</span> <span class="dt">Nil</span></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Cons</span> (<span class="dt">Maybe</span> b) (<span class="dt">Replicate</span> a (a <span class="ot">-&gt;</span> b))</span></code></pre></div>
<p>This type can be made to conform to <code class="sourceCode haskell"><span class="dt">Semiring</span></code> (and <code class="sourceCode haskell"><span class="dt">Starsemiring</span></code>, etc) trivially.</p>
<p>In the simplest case, it has the same behaviour as <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Monad.html#v:replicateM"><code class="sourceCode haskell">replicateM</code></a>. Even the more complex combinators, like <code class="sourceCode haskell">atLeast</code>, can be built on <code class="sourceCode haskell"><span class="dt">Alternative</span></code>:</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true"></a><span class="ot">atLeast ::</span> <span class="dt">Alternative</span> f <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f [a]</span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true"></a>atLeast m f <span class="ot">=</span> go (<span class="fu">max</span> <span class="dv">0</span> m) <span class="kw">where</span></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true"></a>  go <span class="dv">0</span> <span class="ot">=</span> many f</span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true"></a>  go n <span class="ot">=</span> liftA2 (<span class="op">:</span>) f (go (n<span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true"></a>  </span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true"></a><span class="ot">atMost ::</span> <span class="dt">Alternative</span> f <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f [a]</span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true"></a>atMost m f <span class="ot">=</span> go (<span class="fu">max</span> <span class="dv">0</span> m) <span class="kw">where</span></span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true"></a>  go <span class="dv">0</span> <span class="ot">=</span> <span class="fu">pure</span> []</span>
<span id="cb67-9"><a href="#cb67-9" aria-hidden="true"></a>  go n <span class="ot">=</span> liftA2 (<span class="op">:</span>) f (go (n<span class="op">-</span><span class="dv">1</span>)) <span class="op">&lt;|&gt;</span> <span class="fu">pure</span> []</span></code></pre></div>
<p>There are two main benefits over using the standard alternative implementation. First, you can choose greedy or lazy evaluation of the effects <em>after</em> the replication is built.</p>
<p>Secondly, the <em>order</em> of the effects doesn’t have to be specified. This allows you to execute permutations of the effects, in a permutation parser, for instance. The permutation is totally decoupled from the declaration of the repetition (it’s in a totally separate library, in fact: <a href="http://hackage.haskell.org/package/PermuteEffects">PermuteEffects</a>). Its construction is reminiscent of the <a href="https://hackage.haskell.org/package/free-4.12.4/docs/Control-Alternative-Free.html#t:AltF">free alternative</a>.</p>
<p>Having the replicate type conform to <code class="sourceCode haskell"><span class="dt">Semiring</span></code> is all well and good: what I’m interested in is seeing if its implementation is another semiring-based object in disguise. I’ll revisit this in a later post.</p>
<h2 id="algebraic-search">Algebraic Search</h2>
<p>List comprehension notation is one of my all-time favourite bits of syntactic sugar. It seems almost <em>too</em> declarative to have a reasonable implementation strategy. The vast majority of the time, it actually works in a sensible way. There are exceptions, though. Take a reasonable definition of a list of Pythagorean triples:</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true"></a>[ (x,y,z) <span class="op">|</span> x <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="op">..</span>], y <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="op">..</span>], z <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="op">..</span>], x<span class="op">*</span>x <span class="op">+</span> y<span class="op">*</span>y <span class="op">==</span> z<span class="op">*</span>z ]</span></code></pre></div>
<p>This expression will diverge without yielding a single triple. It will search through every possible value for <code class="sourceCode haskell">z</code> before incrementing either <code class="sourceCode haskell">x</code> or <code class="sourceCode haskell">y</code>. Since there are infinite values for <code class="sourceCode haskell">z</code>, it will never find a triple. In other words, vanilla list comprehensions in Haskell perform depth-first search.</p>
<p>In order to express other kinds of search (either breadth-first or depth-bounded), different monads are needed. These monads are explored in <span class="citation" data-cites="fischer_reinventing_2009">Fischer (<a href="#ref-fischer_reinventing_2009" role="doc-biblioref">2009</a>)</span> and <span class="citation" data-cites="spivey_algebras_2009">Spivey (<a href="#ref-spivey_algebras_2009" role="doc-biblioref">2009</a>)</span>.</p>
<p>You can actually use the <em>exact</em> same notation as above with arbitrary alternative monads using <code class="sourceCode haskell"><span class="op">-</span><span class="dt">XMonadComprehensions</span></code> and <code class="sourceCode haskell"><span class="op">-</span><span class="dt">XOverloadedLists</span></code>.</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true"></a><span class="ot">trips ::</span> ( <span class="dt">Alternative</span> m</span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true"></a>         , <span class="dt">Monad</span> m</span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true"></a>         , <span class="dt">IsList</span> (m <span class="dt">Integer</span>)</span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true"></a>         , <span class="dt">Enum</span> (<span class="dt">Item</span> (m <span class="dt">Integer</span>))</span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true"></a>         , <span class="dt">Num</span> (<span class="dt">Item</span> (m <span class="dt">Integer</span>)))</span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true"></a>      <span class="ot">=&gt;</span> m (<span class="dt">Integer</span>,<span class="dt">Integer</span>,<span class="dt">Integer</span>)</span>
<span id="cb69-7"><a href="#cb69-7" aria-hidden="true"></a>trips <span class="ot">=</span> [ (x,y,z) <span class="op">|</span> x <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="op">..</span>], y <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="op">..</span>], z <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="op">..</span>], x<span class="op">*</span>x <span class="op">+</span> y<span class="op">*</span>y <span class="op">==</span> z<span class="op">*</span>z ]</span></code></pre></div>
<p>So then, here’s the challenge: swap in different <code class="sourceCode haskell">m</code>s via a type annotation, and prevent <code class="sourceCode haskell">trips</code> from diverging before getting any triples.</p>
<p>As one example, here’s some code adapted from <span class="citation" data-cites="fischer_reinventing_2009">Fischer (<a href="#ref-fischer_reinventing_2009" role="doc-biblioref">2009</a>)</span>:</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true"></a><span class="kw">instance</span> (<span class="dt">Monoid</span> r, <span class="dt">Applicative</span> m) <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">ContT</span> r m a) <span class="kw">where</span></span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true"></a>  <span class="fu">mempty</span> <span class="ot">=</span> <span class="dt">ContT</span> (<span class="fu">const</span> (<span class="fu">pure</span> <span class="fu">mempty</span>))</span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true"></a>  <span class="fu">mappend</span> (<span class="dt">ContT</span> f) (<span class="dt">ContT</span> g) <span class="ot">=</span> <span class="dt">ContT</span> (\x <span class="ot">-&gt;</span> liftA2 <span class="fu">mappend</span> (f x) (g x))</span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true"></a>  </span>
<span id="cb70-5"><a href="#cb70-5" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">List</span> a <span class="ot">=</span> <span class="dt">List</span> </span>
<span id="cb70-6"><a href="#cb70-6" aria-hidden="true"></a>  {<span class="ot"> runList ::</span> <span class="kw">forall</span> m<span class="op">.</span> <span class="dt">Monoid</span> m <span class="ot">=&gt;</span> <span class="dt">Cont</span> m a } <span class="kw">deriving</span> <span class="dt">Functor</span></span>
<span id="cb70-7"><a href="#cb70-7" aria-hidden="true"></a></span>
<span id="cb70-8"><a href="#cb70-8" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Foldable</span> <span class="dt">List</span> <span class="kw">where</span> <span class="fu">foldMap</span> <span class="ot">=</span> <span class="fu">flip</span> (runCont<span class="op">.</span>runList)</span>
<span id="cb70-9"><a href="#cb70-9" aria-hidden="true"></a>  </span>
<span id="cb70-10"><a href="#cb70-10" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">List</span> a) <span class="kw">where</span> <span class="fu">show</span> <span class="ot">=</span> <span class="fu">show</span> <span class="op">.</span> <span class="fu">foldr</span> (<span class="op">:</span>) []</span>
<span id="cb70-11"><a href="#cb70-11" aria-hidden="true"></a></span>
<span id="cb70-12"><a href="#cb70-12" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Monoid</span> (<span class="dt">List</span> a) <span class="kw">where</span></span>
<span id="cb70-13"><a href="#cb70-13" aria-hidden="true"></a>  <span class="fu">mappend</span> (<span class="dt">List</span> x) (<span class="dt">List</span> y) <span class="ot">=</span> <span class="dt">List</span> (<span class="fu">mappend</span> x y)</span>
<span id="cb70-14"><a href="#cb70-14" aria-hidden="true"></a>  <span class="fu">mempty</span> <span class="ot">=</span> <span class="dt">List</span> <span class="fu">mempty</span></span>
<span id="cb70-15"><a href="#cb70-15" aria-hidden="true"></a>  </span>
<span id="cb70-16"><a href="#cb70-16" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Monoid</span> a <span class="ot">=&gt;</span> <span class="dt">Semiring</span> (<span class="dt">List</span> a) <span class="kw">where</span></span>
<span id="cb70-17"><a href="#cb70-17" aria-hidden="true"></a>  zero <span class="ot">=</span> <span class="fu">mempty</span></span>
<span id="cb70-18"><a href="#cb70-18" aria-hidden="true"></a>  (<span class="op">&lt;+&gt;</span>) <span class="ot">=</span> <span class="fu">mappend</span></span>
<span id="cb70-19"><a href="#cb70-19" aria-hidden="true"></a>  (<span class="op">&lt;.&gt;</span>) <span class="ot">=</span> liftA2 <span class="fu">mappend</span></span>
<span id="cb70-20"><a href="#cb70-20" aria-hidden="true"></a>  one <span class="ot">=</span> <span class="fu">pure</span> <span class="fu">mempty</span></span>
<span id="cb70-21"><a href="#cb70-21" aria-hidden="true"></a></span>
<span id="cb70-22"><a href="#cb70-22" aria-hidden="true"></a><span class="ot">bfs ::</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> [a]</span>
<span id="cb70-23"><a href="#cb70-23" aria-hidden="true"></a>bfs <span class="ot">=</span> toList <span class="op">.</span> fold <span class="op">.</span> levels <span class="op">.</span> anyOf</span>
<span id="cb70-24"><a href="#cb70-24" aria-hidden="true"></a></span>
<span id="cb70-25"><a href="#cb70-25" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">Levels</span> a <span class="ot">=</span> <span class="dt">Levels</span> {<span class="ot"> levels ::</span> [<span class="dt">List</span> a] } <span class="kw">deriving</span> <span class="dt">Functor</span></span>
<span id="cb70-26"><a href="#cb70-26" aria-hidden="true"></a></span>
<span id="cb70-27"><a href="#cb70-27" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Levels</span> <span class="kw">where</span></span>
<span id="cb70-28"><a href="#cb70-28" aria-hidden="true"></a>  <span class="fu">pure</span> x <span class="ot">=</span> <span class="dt">Levels</span> [<span class="fu">pure</span> x]</span>
<span id="cb70-29"><a href="#cb70-29" aria-hidden="true"></a>  <span class="dt">Levels</span> fs <span class="op">&lt;*&gt;</span> <span class="dt">Levels</span> xs <span class="ot">=</span> <span class="dt">Levels</span> [ f <span class="op">&lt;*&gt;</span> x <span class="op">|</span> f <span class="ot">&lt;-</span> fs, x <span class="ot">&lt;-</span> xs ]</span>
<span id="cb70-30"><a href="#cb70-30" aria-hidden="true"></a>  </span>
<span id="cb70-31"><a href="#cb70-31" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Alternative</span> <span class="dt">Levels</span> <span class="kw">where</span></span>
<span id="cb70-32"><a href="#cb70-32" aria-hidden="true"></a>  empty <span class="ot">=</span> <span class="dt">Levels</span> []</span>
<span id="cb70-33"><a href="#cb70-33" aria-hidden="true"></a>  <span class="dt">Levels</span> x <span class="op">&lt;|&gt;</span> <span class="dt">Levels</span> y <span class="ot">=</span> <span class="dt">Levels</span> (<span class="fu">mempty</span> <span class="op">:</span> merge x y)</span>
<span id="cb70-34"><a href="#cb70-34" aria-hidden="true"></a></span>
<span id="cb70-35"><a href="#cb70-35" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">IsList</span> (<span class="dt">List</span> a) <span class="kw">where</span></span>
<span id="cb70-36"><a href="#cb70-36" aria-hidden="true"></a>  <span class="kw">type</span> <span class="dt">Item</span> (<span class="dt">List</span> a) <span class="ot">=</span> a</span>
<span id="cb70-37"><a href="#cb70-37" aria-hidden="true"></a>  fromList <span class="ot">=</span> anyOf</span>
<span id="cb70-38"><a href="#cb70-38" aria-hidden="true"></a>  toList <span class="ot">=</span> <span class="fu">foldr</span> (<span class="op">:</span>) []</span>
<span id="cb70-39"><a href="#cb70-39" aria-hidden="true"></a>  </span>
<span id="cb70-40"><a href="#cb70-40" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">List</span> <span class="kw">where</span></span>
<span id="cb70-41"><a href="#cb70-41" aria-hidden="true"></a>  <span class="fu">pure</span> x <span class="ot">=</span> <span class="dt">List</span> (<span class="fu">pure</span> x)</span>
<span id="cb70-42"><a href="#cb70-42" aria-hidden="true"></a>  (<span class="op">&lt;*&gt;</span>) <span class="ot">=</span> ap</span>
<span id="cb70-43"><a href="#cb70-43" aria-hidden="true"></a></span>
<span id="cb70-44"><a href="#cb70-44" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Alternative</span> <span class="dt">List</span> <span class="kw">where</span></span>
<span id="cb70-45"><a href="#cb70-45" aria-hidden="true"></a>  empty <span class="ot">=</span> <span class="fu">mempty</span></span>
<span id="cb70-46"><a href="#cb70-46" aria-hidden="true"></a>  (<span class="op">&lt;|&gt;</span>) <span class="ot">=</span> <span class="fu">mappend</span></span>
<span id="cb70-47"><a href="#cb70-47" aria-hidden="true"></a></span>
<span id="cb70-48"><a href="#cb70-48" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">List</span> <span class="kw">where</span></span>
<span id="cb70-49"><a href="#cb70-49" aria-hidden="true"></a>  x <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> <span class="fu">foldMap</span> f x</span>
<span id="cb70-50"><a href="#cb70-50" aria-hidden="true"></a></span>
<span id="cb70-51"><a href="#cb70-51" aria-hidden="true"></a><span class="ot">anyOf ::</span> (<span class="dt">Alternative</span> m, <span class="dt">Foldable</span> f) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> m a</span>
<span id="cb70-52"><a href="#cb70-52" aria-hidden="true"></a>anyOf <span class="ot">=</span> getAlt <span class="op">.</span> <span class="fu">foldMap</span> (<span class="dt">Alt</span> <span class="op">.</span> <span class="fu">pure</span>)</span>
<span id="cb70-53"><a href="#cb70-53" aria-hidden="true"></a></span>
<span id="cb70-54"><a href="#cb70-54" aria-hidden="true"></a><span class="ot">merge ::</span> [<span class="dt">List</span> a] <span class="ot">-&gt;</span> [<span class="dt">List</span> a] <span class="ot">-&gt;</span> [<span class="dt">List</span> a]</span>
<span id="cb70-55"><a href="#cb70-55" aria-hidden="true"></a>merge []      ys    <span class="ot">=</span> ys</span>
<span id="cb70-56"><a href="#cb70-56" aria-hidden="true"></a>merge xs      []    <span class="ot">=</span> xs</span>
<span id="cb70-57"><a href="#cb70-57" aria-hidden="true"></a>merge (x<span class="op">:</span>xs) (y<span class="op">:</span>ys) <span class="ot">=</span> <span class="fu">mappend</span> x y <span class="op">:</span> merge xs ys</span></code></pre></div>
<div class="sourceCode" id="cb71"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true"></a><span class="fu">take</span> <span class="dv">3</span> (bfs trips)</span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true"></a>[(<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>),(<span class="dv">4</span>,<span class="dv">3</span>,<span class="dv">5</span>),(<span class="dv">6</span>,<span class="dv">8</span>,<span class="dv">10</span>)]</span></code></pre></div>
<p>The only relevance to semirings is the merge function. The semiring over lists is the semiring over polynomials:</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Semiring</span> a <span class="ot">=&gt;</span> <span class="dt">Semiring</span> [a] <span class="kw">where</span></span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true"></a>  one <span class="ot">=</span> [one]</span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true"></a>  zero <span class="ot">=</span> []</span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true"></a>  [] <span class="op">&lt;+&gt;</span> ys <span class="ot">=</span> ys</span>
<span id="cb72-5"><a href="#cb72-5" aria-hidden="true"></a>  xs <span class="op">&lt;+&gt;</span> [] <span class="ot">=</span> xs</span>
<span id="cb72-6"><a href="#cb72-6" aria-hidden="true"></a>  (x<span class="op">:</span>xs) <span class="op">&lt;+&gt;</span> (y<span class="op">:</span>ys) <span class="ot">=</span> (x <span class="op">&lt;+&gt;</span> y) <span class="op">:</span> (xs <span class="op">&lt;+&gt;</span> ys)</span>
<span id="cb72-7"><a href="#cb72-7" aria-hidden="true"></a>  [] <span class="op">&lt;.&gt;</span> _ <span class="ot">=</span> []</span>
<span id="cb72-8"><a href="#cb72-8" aria-hidden="true"></a>  _ <span class="op">&lt;.&gt;</span> [] <span class="ot">=</span> []</span>
<span id="cb72-9"><a href="#cb72-9" aria-hidden="true"></a>  (x<span class="op">:</span>xs) <span class="op">&lt;.&gt;</span> (y<span class="op">:</span>ys) <span class="ot">=</span></span>
<span id="cb72-10"><a href="#cb72-10" aria-hidden="true"></a>    (x <span class="op">&lt;.&gt;</span> y) <span class="op">:</span> (<span class="fu">map</span> (x <span class="op">&lt;.&gt;</span>) ys <span class="op">&lt;+&gt;</span> <span class="fu">map</span> (<span class="op">&lt;.&gt;</span> y) xs <span class="op">&lt;+&gt;</span> (xs <span class="op">&lt;.&gt;</span> ys))</span></code></pre></div>
<p>The <code class="sourceCode haskell"><span class="op">&lt;+&gt;</span></code> is the same as the <code class="sourceCode haskell">merge</code> function. I think the <code class="sourceCode haskell"><span class="op">&lt;.&gt;</span></code> might be a more valid definition of the <code class="sourceCode haskell"><span class="op">&lt;*&gt;</span></code> function, also.</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Levels</span> <span class="kw">where</span></span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true"></a>  <span class="fu">pure</span> x <span class="ot">=</span> <span class="dt">Levels</span> [<span class="fu">pure</span> x]</span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true"></a>  <span class="dt">Levels</span> [] <span class="op">&lt;*&gt;</span> _ <span class="ot">=</span> <span class="dt">Levels</span> []</span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true"></a>  _ <span class="op">&lt;*&gt;</span> <span class="dt">Levels</span> [] <span class="ot">=</span> <span class="dt">Levels</span> []</span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true"></a>  <span class="dt">Levels</span> (f<span class="op">:</span>fs) <span class="op">&lt;*&gt;</span> <span class="dt">Levels</span> (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="dt">Levels</span> <span class="op">$</span></span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true"></a>    (f <span class="op">&lt;*&gt;</span> x) <span class="op">:</span> levels (<span class="dt">Levels</span> (<span class="fu">fmap</span> (f <span class="op">&lt;*&gt;</span>) xs) </span>
<span id="cb73-7"><a href="#cb73-7" aria-hidden="true"></a>             <span class="op">&lt;|&gt;</span> <span class="dt">Levels</span> (<span class="fu">fmap</span> (<span class="op">&lt;*&gt;</span> x) fs)</span>
<span id="cb73-8"><a href="#cb73-8" aria-hidden="true"></a>             <span class="op">&lt;|&gt;</span> (<span class="dt">Levels</span> fs <span class="op">&lt;*&gt;</span> <span class="dt">Levels</span> xs))</span></code></pre></div>
<h2 id="conclusion">Conclusion</h2>
<p>I’ve only scratched the surface of this abstraction. There are several other interesting semirings: polynomials, logs, Viterbi, Łukasiewicz, languages, multisets, bidirectional parsers, etc. Hopefully I’ll eventually be able to put this stuff into a library or something. In the meantime, I definitely will write some posts on the application to context-free parsing, bidirectional parsing (I just read <span class="citation" data-cites="breitner_showcasing_2016">Breitner (<a href="#ref-breitner_showcasing_2016" role="doc-biblioref">2016</a>)</span>) and search.</p>
<h2 class="unnumbered" id="references">References</h2>
<div id="refs" class="references hanging-indent" role="doc-bibliography">
<div id="ref-boom_further_1981">
<p>Boom, H. J. 1981. “Further thoughts on Abstracto.” <em>Working Paper ELC-9, IFIP WG 2.1</em>. <a href="http://www.kestrel.edu/home/people/meertens/publications/papers/Abstracto_reader.pdf">http://www.kestrel.edu/home/people/meertens/publications/papers/Abstracto_reader.pdf</a>.</p>
</div>
<div id="ref-breitner_showcasing_2016">
<p>Breitner, Joachim. 2016. “Showcasing Applicative.” <em>Joachim Breitner’s Blog</em>. <a href="http://www.joachim-breitner.de/blog/710-Showcasing_Applicative">http://www.joachim-breitner.de/blog/710-Showcasing_Applicative</a>.</p>
</div>
<div id="ref-doel_free_2015">
<p>Doel, Dan. 2015. “Free Monoids in Haskell.” <em>The Comonad.Reader</em>. <a href="http://comonad.com/reader/2015/free-monoids-in-haskell/">http://comonad.com/reader/2015/free-monoids-in-haskell/</a>.</p>
</div>
<div id="ref-dolan_fun_2013">
<p>Dolan, Stephen. 2013. “Fun with semirings: a functional pearl on the abuse of linear algebra.” In, 48:101. ACM Press. doi:<a href="https://doi.org/10.1145/2500365.2500613">10.1145/2500365.2500613</a>. <a href="https://www.cl.cam.ac.uk/~sd601/papers/semirings.pdf">https://www.cl.cam.ac.uk/~sd601/papers/semirings.pdf</a>.</p>
</div>
<div id="ref-droste_semirings_2009">
<p>Droste, Manfred, and Werner Kuich. 2009. “Semirings and Formal Power Series.” In <em>Handbook of Weighted Automata</em>, ed by. Manfred Droste, Werner Kuich, and Heiko Vogler, 1:3–28. Monographs in Theoretical Computer Science. An EATCS Series. Berlin, Heidelberg: Springer Berlin Heidelberg. <a href="http://staff.mmcs.sfedu.ru/~ulysses/Edu/Marktoberdorf_2009/working_material/Esparsa/Kuich.%20Semirings%20and%20FPS.pdf">http://staff.mmcs.sfedu.ru/~ulysses/Edu/Marktoberdorf_2009/working_material/Esparsa/Kuich.%20Semirings%20and%20FPS.pdf</a>.</p>
</div>
<div id="ref-erwig_functional_2006">
<p>Erwig, Martin, and Steve Kollmansberger. 2006. “Functional pearls: Probabilistic functional programming in Haskell.” <em>Journal of Functional Programming</em> 16 (1): 21–34. doi:<a href="https://doi.org/10.1017/S0956796805005721">10.1017/S0956796805005721</a>. <a href="http://web.engr.oregonstate.edu/~erwig/papers/abstracts.html#JFP06a">http://web.engr.oregonstate.edu/~erwig/papers/abstracts.html#JFP06a</a>.</p>
</div>
<div id="ref-fischer_reinventing_2009">
<p>Fischer, Sebastian. 2009. “Reinventing Haskell Backtracking.” In <em>Informatik 2009, Im Fokus das Leben (ATPS’09)</em>. GI Edition. <a href="http://www-ps.informatik.uni-kiel.de/~sebf/data/pub/atps09.pdf">http://www-ps.informatik.uni-kiel.de/~sebf/data/pub/atps09.pdf</a>.</p>
</div>
<div id="ref-hirschowitz_modules_2010">
<p>Hirschowitz, André, and Marco Maggesi. 2010. “Modules over monads and initial semantics.” <em>Information and Computation</em> 208 (5). Special Issue: 14th Workshop on Logic, Language, Information and Computation (WoLLIC 2007) (May): 545–564. doi:<a href="https://doi.org/10.1016/j.ic.2009.07.003">10.1016/j.ic.2009.07.003</a>. <a href="https://pdfs.semanticscholar.org/3e0c/c79e8cda9246cb954da6fd8aaaa394fecdc3.pdf">https://pdfs.semanticscholar.org/3e0c/c79e8cda9246cb954da6fd8aaaa394fecdc3.pdf</a>.</p>
</div>
<div id="ref-kidd_build_2007">
<p>Kidd, Eric. 2007. “Build your own probability monads.” <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.129.9502&amp;rep=rep1&amp;type=pdf">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.129.9502&amp;rep=rep1&amp;type=pdf</a>.</p>
</div>
<div id="ref-kmett_free_2011">
<p>Kmett, Edward. 2011a. “Free Monads for Less (Part 2 of 3): Yoneda.” <em>The Comonad.Reader</em>. <a href="http://comonad.com/reader/2011/free-monads-for-less-2/">http://comonad.com/reader/2011/free-monads-for-less-2/</a>.</p>
</div>
<div id="ref-kmett_modules_2011">
<p>———. 2011b. “Modules and Functional Linear Functionals.” <em>The Comonad.Reader</em>. <a href="http://comonad.com/reader/2011/free-modules-and-functional-linear-functionals/">http://comonad.com/reader/2011/free-modules-and-functional-linear-functionals/</a>.</p>
</div>
<div id="ref-larsen_memory_2011">
<p>Larsen, Ken Friis. 2011. “Memory Efficient Implementation of Probability Monads.” <a href="http://www.diku.dk/~kflarsen/t/ProbMonad-unpublished.pdf">http://www.diku.dk/~kflarsen/t/ProbMonad-unpublished.pdf</a>.</p>
</div>
<div id="ref-oconnor_very_2011">
<p>O’Connor, Russell. 2011. “A Very General Method of Computing Shortest Paths.” <em>Russell O’Connor’s Blog</em>. <a href="http://r6.ca/blog/20110808T035622Z.html">http://r6.ca/blog/20110808T035622Z.html</a>.</p>
</div>
<div id="ref-piponi_monad_2009">
<p>Piponi, Dan. 2009. “A Monad for Combinatorial Search with Heuristics.” <em>A Neighborhood of Infinity</em>. <a href="http://blog.sigfpe.com/2009/07/monad-for-combinatorial-search-with.html">http://blog.sigfpe.com/2009/07/monad-for-combinatorial-search-with.html</a>.</p>
</div>
<div id="ref-rivas_monoids_2015">
<p>Rivas, Exequiel, Mauro Jaskelioff, and Tom Schrijvers. 2015. “From monoids to near-semirings: the essence of MonadPlus and Alternative.” In <em>Proceedings of the 17th International Symposium on Principles and Practice of Declarative Programming</em>, 196–207. ACM. doi:<a href="https://doi.org/10.1145/2790449.2790514">10.1145/2790449.2790514</a>. <a href="http://www.fceia.unr.edu.ar/~mauro/pubs/FromMonoidstoNearsemirings.pdf">http://www.fceia.unr.edu.ar/~mauro/pubs/FromMonoidstoNearsemirings.pdf</a>.</p>
</div>
<div id="ref-spivey_algebras_2009">
<p>Spivey, J. Michael. 2009. “Algebras for combinatorial search.” <em>Journal of Functional Programming</em> 19 (3-4) (July): 469–487. doi:<a href="https://doi.org/10.1017/S0956796809007321">10.1017/S0956796809007321</a>. <a href="https://pdfs.semanticscholar.org/db3e/373bb6e7e7837ebc524da0a25903958554ed.pdf">https://pdfs.semanticscholar.org/db3e/373bb6e7e7837ebc524da0a25903958554ed.pdf</a>.</p>
</div>
</div>

        </div>
    </body>
</html>
