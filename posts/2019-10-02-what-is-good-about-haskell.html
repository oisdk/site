<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>What is Good About Haskell? - Donnacha Ois√≠n Kidney</title>
        <style>body{color:black;font-family:Garamond,Times New Roman,serif;font-size:14px;margin:0px auto 0px auto;padding-left:5px;padding-right:5px;max-width:600px}math{font-size:13px}img{max-width:600px}div#header{border-bottom:3px double black;margin-bottom:30px;padding:12px 0px 12px 0px}div#logo a{color:black;float:left;font-size:20px;text-decoration:none}div#header #navigation{text-align:right}div#header #navigation a{color:black;font-family:Garamond,Times New Roman,Serif;font-size:18px;margin-left:10px;text-decoration:none;text-transform:uppercase}div#footer{font-family:Garamond,Times New Roman,Serif;border-top:solid 2px black;color:#555;font-size:12px;margin-top:30px;padding:12px 0px 12px 0px;text-align:right}h1{font-family:Garamond,Times New Roman,Serif;font-size:22px;font-weight:normal}h2{font-family:Garamond,Times New Roman,Serif;font-size:20px;font-weight:normal}div.info{color:#555;font-size:15px;font-style:italic}span.quiet{color:#828282;font-style:italic}a{color:black;word-wrap:break-word}ul.post-list{margin-left:0px;padding-left:0px;list-style-type:none}.hidden_source{display:none}ol.serieslist{counter-reset:item;list-style-type:none;padding-left:20}ol li.serieslist:before{content:'Part ' counter(item,decimal) ':';counter-increment:item}table.sourceCode,tr.sourceCode,td.lineNumbers,td.sourceCode,table.sourceCode pre{margin:0;padding:0;border:0;vertical-align:baseline;border:none}td.lineNumbers{border-right:1px solid #AAAAAA;text-align:right;color:#AAAAAA;padding-right:5px;padding-left:5px}td.sourceCode{padding-left:5px}.sourceCode,code,pre,.Agda{font-size:11px;font-family:menlo,monospace}.sourceCode span.kw{color:#262C6A}.sourceCode span.dt{color:#476A97}.sourceCode span.dv{color:#262C6A}.sourceCode span.bn{color:#262C6A}.sourceCode span.fl{color:#262C6A}.sourceCode span.ch{color:#262C6A}.sourceCode span.st{color:#702C51}.sourceCode span.co{color:#435138}.sourceCode span.ot{color:#262C6A}.sourceCode span.al{color:red}.sourceCode span.fu{color:#000000}.sourceCode span.re{color:#000000}.sourceCode span.er{color:red}li{margin-bottom:2px}li:last-child{margin-bottom:0px}.Agda .Comment{color:#B22222}.Agda .Background{}.Agda .Markup{color:#000000}.Agda .Keyword{color:#CD6600}.Agda .String{color:#B22222}.Agda .Number{color:#A020F0}.Agda .Symbol{color:#404040}.Agda .PrimitiveType{color:#0000CD}.Agda .Pragma{color:black}.Agda .Operator{}.Agda .Bound{color:black}.Agda .Generalizable{color:black}.Agda .InductiveConstructor{color:#008B00}.Agda .CoinductiveConstructor{color:#8B7500}.Agda .Datatype{color:#0000CD}.Agda .Field{color:#EE1289}.Agda .Function{color:#0000CD}.Agda .Module{color:#A020F0}.Agda .Postulate{color:#0000CD}.Agda .Primitive{color:#0000CD}.Agda .Record{color:#0000CD}.Agda .DottedPattern{}.Agda .UnsolvedMeta{color:black;background:yellow}.Agda .UnsolvedConstraint{color:black;background:yellow}.Agda .TerminationProblem{color:black;background:#FFA07A}.Agda .IncompletePattern{color:black;background:#F5DEB3}.Agda .Error{color:red;text-decoration:underline}.Agda .TypeChecks{color:black;background:#ADD8E6}.Agda a{text-decoration:none}.Agda a[href]:hover{background-color:#B4EEB4}.sourceCode{overflow-x:auto}</style>
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Donnacha Ois√≠n Kidney</a>
            </div>
            <div id="navigation">
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../rss.xml">Feed</a>
            </div>
        </div>

        <div id="content">
            <h2>What is Good About Haskell?</h2>

            <div class="info">
    Posted on October  2, 2019
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a title="All pages tagged 'Haskell'." href="../tags/Haskell.html">Haskell</a>
    
</div>

<p>Update 5/10/2019: check the bottom of this post for some links to comments and discussion.</p>
<p>Beginners to Haskell are often confused as to what‚Äôs so great about the language. Much of the proselytizing online focuses on pretty abstract (and often poorly defined) concepts like ‚Äúpurity‚Äù, ‚Äústrong types‚Äù, and (god forbid) ‚Äúmonads‚Äù. These things are difficult to understand, somewhat controversial, and not obviously beneficial (especially when you‚Äôve only been using the language for a short amount of time).</p>
<p>The real tragedy is that Haskell (and other ML-family languages) are <em>packed</em> with simple, decades-old features like pattern matching and algebraic data types which have massive, clear benefits and few (if any) downsides. Some of these ideas are finally filtering in to mainstream languages (like Swift and Rust) where they‚Äôre used to great effect, but the vast majority of programmers out there haven‚Äôt yet been exposed to them.</p>
<p>This post aims to demonstrate some of these features in a simple (but hopefully not too simple) example. I‚Äôm going to write and package up a simple sorting algorithm in both Haskell and Python, and compare the code in each. I‚Äôm choosing Python because I like it and beginners like it, but also because it‚Äôs missing most of the features I‚Äôll be demonstrating. It‚Äôs important to note I‚Äôm not comparing Haskell and Python as languages: the Python code is just there as a reference for people less familiar with Haskell. What‚Äôs more, the comparison is unfair, as the example deliberately plays to Haskell‚Äôs strengths (so I can show off the features I‚Äôm interested in): it wouldn‚Äôt be difficult to pick an example that makes Python look good and Haskell look poor.</p>
<p>This post is not meant to say ‚ÄúHaskell is great, and your language sucks‚Äù! It‚Äôs not even really about Haskell: much of what I‚Äôm talking about here applies equally well to Ocaml, Rust, etc. I‚Äôm really writing this as a response to the notion that functional features are somehow experimental, overly complex, or ultimately compromised. As a result of that idea, I feel like these features are left out of a lot of modern languages which would benefit from them. There exists a small set of simple, battle-tested PL ideas, which have been used for nearly forty years now: this post aims to demonstrate them, and argue for their inclusion in every general-purpose programming language that‚Äôs being designed today.</p>
<h1 id="the-algorithm">The Algorithm</h1>
<p>We‚Äôll be using a <a href="https://en.wikipedia.org/wiki/Skew_heap">skew heap</a> to sort lists in both languages. The basic idea is to repeatedly insert stuff into the heap, and then repeatedly ‚Äúpop‚Äù the smallest element from the heap until it‚Äôs empty. It‚Äôs not in-place, but it is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n \log n)</annotation></semantics></math>, and actually performs pretty well in practice.</p>
<h1 id="a-tree">A Tree</h1>
<p>A Skew Heap is represented by a <em>binary tree</em>:</p>
<style>
.column {
    float: left;
    width: 50%;
}
.row:after {
    content: "";
    display: table;
    clear: both;
}
</style>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Tree</span> a</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>  <span class="ot">=</span> <span class="dt">Leaf</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Node</span> a (<span class="dt">Tree</span> a) (<span class="dt">Tree</span> a)</span></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">class</span> Tree:</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>  <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, is_node, data, lchild, rchild):</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>    <span class="va">self</span>._is_node <span class="op">=</span> is_node</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>    <span class="va">self</span>._data <span class="op">=</span> data</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>    <span class="va">self</span>._lchild <span class="op">=</span> lchild</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>    <span class="va">self</span>._rchild <span class="op">=</span> rchild</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>    </span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a><span class="kw">def</span> leaf():</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a>  <span class="cf">return</span> Tree(<span class="va">False</span>, <span class="va">None</span>, <span class="va">None</span>, <span class="va">None</span>)</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true"></a><span class="kw">def</span> node(data, lchild, rchild):</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true"></a>  <span class="cf">return</span> Tree(<span class="va">True</span>, data, lchild, rchild)</span></code></pre></div>
</div>
</div>
<p>I want to point out the precision of the Haskell definition: a tree is either a leaf (an empty tree), or a node, with a payload and two children. There are no special cases, and it took us one line to write (spread to 3 here for legibility on smaller screens).</p>
<p>In Python, we have to write a few more lines<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. This representation uses the <code>_is_node</code> field is <code>False</code> for an empty tree (a leaf). If it‚Äôs <code>True</code>, the other fields are filled. We write some helper functions to give us constructors like the leaf and node ones for the Haskell example.</p>
<p>This isn‚Äôt the standard definition of a binary tree in Python, in fact it might looks a little weird to most Python people. Let‚Äôs run through some alternatives and their issues.</p>
<ol>
<li><p>The standard definition:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">class</span> Tree:</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>  <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, data, lchild, rchild):</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>    <span class="va">self</span>._data <span class="op">=</span> data</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>    <span class="va">self</span>._lchild <span class="op">=</span> lchild</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>    <span class="va">self</span>._rchild <span class="op">=</span> rchild</span></code></pre></div>
<p>Instead of having a separate field for ‚Äúis this a leaf or a node‚Äù, the empty tree is simply <code>None</code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">def</span> leaf():</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>    <span class="cf">return</span> <span class="va">None</span></span></code></pre></div>
<p>With this approach, if we define any <em>methods</em> on a tree, they won‚Äôt work on the empty tree!</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="op">&gt;&gt;&gt;</span> leaf().size()</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a><span class="pp">AttributeError</span>: <span class="st">'NoneType'</span> <span class="bu">object</span> has no attribute <span class="st">'size'</span></span></code></pre></div></li>
<li><p>We‚Äôll do inheritance! Python even has a handy <code>abc</code> library to help us with some of this:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="im">from</span> abc <span class="im">import</span> ABC, abstractmethod</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a><span class="kw">class</span> Tree(ABC):</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>    <span class="at">@abstractmethod</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>    <span class="kw">def</span> size(<span class="va">self</span>):</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a>        <span class="cf">raise</span> <span class="va">NotImplemented</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a><span class="kw">class</span> Leaf(Tree):</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true"></a>        <span class="cf">pass</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true"></a></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true"></a>    <span class="kw">def</span> size(<span class="va">self</span>):</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true"></a></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true"></a><span class="kw">class</span> Node(Tree):</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, data, lchild, rchild):</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true"></a>        <span class="va">self</span>._data <span class="op">=</span> data</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true"></a>        <span class="va">self</span>._lchild <span class="op">=</span> lchild</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true"></a>        <span class="va">self</span>._rchild <span class="op">=</span> rchild</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true"></a></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true"></a>    <span class="kw">def</span> size(<span class="va">self</span>):</span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true"></a>        <span class="cf">return</span> <span class="dv">1</span> <span class="op">+</span> <span class="va">self</span>._lchild.size() <span class="op">+</span> <span class="va">self</span>._rchild.size()</span></code></pre></div>
<p>Methods will now work on an empty tree, but we‚Äôre faced with 2 problems: first, this is very verbose, and pretty complex. Secondly, we can‚Äôt write a mutating method which changes a tree from a leaf to a node. In other words, we can‚Äôt write an <code>insert</code> method!</p></li>
<li><p>We won‚Äôt represent a leaf as the whole <em>tree</em> being <code>None</code>, just the data!</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="kw">def</span> leaf():</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>    <span class="cf">return</span> Tree(<span class="va">None</span>, <span class="va">None</span>, <span class="va">None</span>)</span></code></pre></div>
<p>This (surprisingly) pops up in a few places. While it solves the problem of methods, and the mutation problem, it has a serious bug. We can‚Äôt have <code>None</code> as an element in the tree! In other words, if we ask our eventual algorithm to sort a list which contains <code>None</code>, it will silently discard some of the list, returning the wrong answer.</p></li>
</ol>
<p>There are yet more options (using a wrapper class), none of them ideal. Another thing to point out is that, even with our definition with a tag, we can only represent types with 2 possible states. If there was another type of node in the tree, we couldn‚Äôt simply use a boolean tag: we‚Äôd have to switch to integers (and remember the meaning of each integer), or strings! Yuck!</p>
<p>What Python is fundamentally missing here is <em>algebraic data types</em>. This is a way of building up all of your types out of products (‚Äúmy type has this <em>and</em> this‚Äù) and sums (‚Äúmy type is this <em>or</em> this‚Äù). Python can do products perfectly well: that‚Äôs what classes are. The tree class itself is the product of <code>Bool</code>, <code>data</code>, <code>Tree</code>, and <code>Tree</code>. However it‚Äôs missing an <em>entire half of the equation</em>! This is why you just can‚Äôt express binary trees as cleanly as you can in Swift, Haskell, OCaml, etc. Python, as well as a host of other languages like Go, Java, etc, will let you express <em>one</em> kind of ‚Äúsum‚Äù type: ‚Äúor nothing‚Äù (the null pointer). However, it‚Äôs clunky and poorly handled in all of those languages (the method problems above demonstrate the issues in Python), and doesn‚Äôt work for anything other than that one special case.</p>
<p>Again, there‚Äôs nothing about algebraic data types that makes them ill-suited to mainstream or imperative languages. Swift uses them, and <a href="https://www.caseyliss.com/2016/2/27/swift-enums">people love them</a>!</p>
<h1 id="a-function">A Function</h1>
<p>The core operation on skew heaps is the <em>skew merge</em>.</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="ot">merge ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>merge <span class="dt">Leaf</span> ys <span class="ot">=</span> ys</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>merge xs <span class="dt">Leaf</span> <span class="ot">=</span> xs</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>merge xs<span class="op">@</span>(<span class="dt">Node</span> x xl xr) ys<span class="op">@</span>(<span class="dt">Node</span> y yl yr)</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>   <span class="op">|</span> x <span class="op">&lt;=</span> y    <span class="ot">=</span> <span class="dt">Node</span> x (merge ys xr) xl</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a>   <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="dt">Node</span> y (merge xs yr) yl</span></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="kw">def</span> merge(lhs, rhs):</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>  <span class="cf">if</span> <span class="kw">not</span> lhs._is_node:</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>    <span class="cf">return</span> rhs</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a>  <span class="cf">if</span> <span class="kw">not</span> rhs._is_node:</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a>    <span class="cf">return</span> lhs</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a>  <span class="cf">if</span> lhs._data <span class="op">&lt;=</span> rhs._data:</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a>    <span class="cf">return</span> Tree(lhs._data,</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true"></a>                merge(rhs, lhs._rchild),</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true"></a>                lhs._lchild)</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true"></a>  <span class="cf">else</span>:</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true"></a>    <span class="cf">return</span> Tree(rhs._data,</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true"></a>                merge(lhs, rhs._rchild),</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true"></a>                rhs._lchild)</span></code></pre></div>
</div>
</div>
<p>The standout feature here is pattern matching. In Haskell, we‚Äôre able to write the function as we might describe it: ‚Äúin this case, I‚Äôll do this, in this other case, I‚Äôll do this, etc.‚Äù. In Python, we are forced to think of the truth tables and sequential testing. What do I mean by truth tables? Consider the following version of the Python function above:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="kw">def</span> merge(lhs, rhs):</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>  <span class="cf">if</span> lhs._is_node:</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a>    <span class="cf">if</span> rhs._is_node:</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a>      <span class="cf">if</span> lhs._data <span class="op">&lt;=</span> rhs._data:</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a>        <span class="cf">return</span> Tree(lhs._data,</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a>                    merge(rhs, lhs._rchild),</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a>                    lhs._lchild)</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true"></a>      <span class="cf">else</span>:</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true"></a>        <span class="cf">return</span> Tree(rhs._data,</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true"></a>                    merge(lhs, rhs._rchild),</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true"></a>                    rhs._lchild)</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true"></a>    <span class="cf">else</span>:</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true"></a>      <span class="cf">return</span> lhs</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true"></a>  <span class="cf">else</span>:</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true"></a>    <span class="cf">return</span> rhs</span></code></pre></div>
<p>You may even write this version first: it initially seems more natural (because <code>_is_node</code> is used in the positive). Here‚Äôs the question, though: does it do the same thing as the previous version? Are you <em>sure</em>? Which else is connected to which if? Does every if have an else? (some linters will suggest you <em>remove</em> some of the elses above, since the if-clause has a <code>return</code> statement in it!)</p>
<p>The fact of the matter is that we are forced to do truth tables of every condition in our minds, rather than <em>saying what we mean</em> (as we do in the Haskell version).</p>
<p>The other thing we‚Äôre saved from in the Haskell version is accessing undefined fields. In the Python function, we know accessing <code>lhs._data</code> is correct since we verified that <code>lhs</code> is a node. But the logic to do this verification is complex: we checked if it <em>wasn‚Äôt</em> a node, and returned if that was true‚Ä¶ so if it <em>is true</em> that <code>lhs</code> <em>isn‚Äôt</em> a node, we would have returned, but we didn‚Äôt, so‚Ä¶</p>
<p>Bear in mind all of these logic checks happened four lines before the actual access: this can get much uglier in practice! Compare this to the Haskell version: <em>we only get to bind variables if we‚Äôre sure they exist</em>. The syntax itself prevents us from accessing fields which aren‚Äôt defined, in a simple way.</p>
<p>Pattern matching has existed for years in many different forms: even C has switch statements. The added feature of destructuring is available in languages like Swift, Rust, and the whole ML family. Ask for it in your language today!</p>
<p>Now that we have that function, we get to define others in terms of it:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="ot">insert ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a>insert x <span class="ot">=</span> merge (<span class="dt">Node</span> x <span class="dt">Leaf</span> <span class="dt">Leaf</span>)</span></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb12"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="kw">def</span> insert(element, tree):</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a>    tree.__dict__ <span class="op">=</span> merge(node(element, leaf(), leaf()),</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a>                          tree).__dict__.copy()</span></code></pre></div>
</div>
</div>
<h1 id="a-word-on-types">A Word on Types</h1>
<p>I haven‚Äôt mentioned Haskell‚Äôs type system so far, as it‚Äôs been quite unobtrusive in the examples. And that‚Äôs kind of the point: despite more complex examples you‚Äôll see online demonstrating the power of type classes and higher-kinded types, Haskell‚Äôs type system <em>excels</em> in these simpler cases.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="ot">merge ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a</span></code></pre></div>
<p>Without much ceremony, this signature tells us:</p>
<ol>
<li>The function takes two trees, and returns a third.</li>
<li>Both trees have to be filled with the same types of elements.</li>
<li>Those elements must have an order defined on them.</li>
</ol>
<h1 id="type-inference">Type Inference</h1>
<p>I feel a lot of people miss the point of this particular feature. Technically speaking, this feature allows us to write fewer type signatures, as Haskell will be able to guess most of them. Coming from something like Java, you might think that that‚Äôs an opportunity to shorten up some verbose code. It‚Äôs not! You‚Äôll rarely find a Haskell program these days missing top-level type signatures: it‚Äôs easier to read a program with explicit type signatures, so people are advised to put them as much as possible.</p>
<p>(Amusingly, I often find older Haskell code snippets which are entirely devoid of type signatures. It seems that programmers were so excited about Hindley-Milner type inference that they would put it to the test as often as they could.)</p>
<p>Type inference in Haskell is actually useful in a different way. First, if I write the <em>implementation</em> of the <code>merge</code> function, the compiler will tell <em>me</em> the signature, which is extremely helpful for more complex examples. Take the following, for instance:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a>f x <span class="ot">=</span> ((x <span class="op">*</span> <span class="dv">2</span>) <span class="op">^</span> <span class="dv">3</span>) <span class="op">/</span> <span class="dv">4</span></span></code></pre></div>
<p>Remembering precisely which numeric type <code>x</code> needs to be is a little difficult (<code>Floating</code>? <code>Real</code>? <code>Fractional</code>?), but if I just ask the compiler it will tell me without difficulty.</p>
<p>The second use is kind of the opposite: if I have a hole in my program where I need to fill in some code, Haskell can help me along by telling me the <em>type</em> of that hole automatically. This is often enough information to figure out the entire implementation! In fact, there are some programs which will use this capability of the type checker to fill in the hole with valid programs, synthesising your code for you.</p>
<p>So often strong type systems can make you feel like you‚Äôre fighting more and more against the compiler. I hope these couple examples show that it doesn‚Äôt have to be that way.</p>
<h1 id="when-things-go-wrong">When Things Go Wrong</h1>
<p>The next function is ‚Äúpop-min‚Äù:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="ot">popMin ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, <span class="dt">Tree</span> a)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a>popMin <span class="dt">Leaf</span> <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a>popMin (<span class="dt">Node</span> x xl xr) <span class="ot">=</span> <span class="dt">Just</span> (x, merge xl xr)</span></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb16"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span class="kw">def</span> popMin(tree):</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a>  <span class="cf">if</span> tree._is_node:</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a>    res <span class="op">=</span> tree._data</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a>    tree.__dict__ <span class="op">=</span> merge(tree._lchild, tree._rchild).__dict__.copy()</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true"></a>    <span class="cf">return</span> res</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true"></a>  <span class="cf">else</span>:</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true"></a>    <span class="cf">raise</span> <span class="pp">IndexError</span></span></code></pre></div>
</div>
</div>
<p>At first glance, this function should be right at home in Python. It <em>mutates</em> its input, and it has an error case. The code we‚Äôve written here for Python is pretty idiomatic, also: other than the ugly deep copy, we‚Äôre basically just mutating the object, and using an exception for the exceptional state (when the tree is empty). Even the exception we use is the same exception as when you try and <code>pop()</code> from an empty list.</p>
<p>The Haskell code here mainly demonstrates a difference in API style you‚Äôll see between the two languages. If something isn‚Äôt found, we just use <code>Maybe</code>. And instead of mutating the original variable, we return the new state in the second part of a tuple. What‚Äôs nice about this is that we‚Äôre only using simple core features like algebraic data types to emulate pretty complex features like exceptions in Python.</p>
<p>You may have heard that ‚ÄúHaskell uses monads to do mutation and exceptions‚Äù. This is not true. Yes, state and exceptions have patterns which technically speaking are ‚Äúmonadic‚Äù. But make no mistake: when we want to model ‚Äúexceptions‚Äù in Haskell, we really just return a maybe (or an either). And when we want to do ‚Äúmutation‚Äù, we return a tuple, where the second element is the updated state. You don‚Äôt have to understand monads to use them, and you certainly don‚Äôt ‚Äúneed‚Äù monads to do them. To drive the point home, the above code could actually equivalently have a type which mentions ‚Äúthe state monad‚Äù and ‚Äúthe maybe monad‚Äù:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span class="ot">popMin ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">StateT</span> (<span class="dt">Tree</span> a) <span class="dt">Maybe</span> a</span></code></pre></div>
<p>But there‚Äôs no need to!</p>
<h1 id="gluing-it-all-together">Gluing It All Together</h1>
<p>The main part of our task is now done: all that is left is to glue the various bits and pieces together. Remember, the overall algorithm builds up the heap from a list, and then tears it down using <code>popMin</code>. First, then, to build up the heap.</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a><span class="ot">listToHeap ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Tree</span> a</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a>listToHeap <span class="ot">=</span> <span class="fu">foldr</span> insert <span class="dt">Leaf</span></span></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb19"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a><span class="kw">def</span> listToHeap(elements):</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a>  res <span class="op">=</span> leaf()</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true"></a>  <span class="cf">for</span> el <span class="kw">in</span> elements:</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true"></a>    insert(el, res)</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true"></a>  <span class="cf">return</span> res</span></code></pre></div>
</div>
</div>
<p>To my eye, the Haskell code here is significantly more ‚Äúreadable‚Äù than the Python. I know that‚Äôs a very subjective judgement, but <code>foldr</code> is a function so often used that it‚Äôs immediately clear what‚Äôs happening in this example.</p>
<p>Why didn‚Äôt we use a similar function in Python, then? We actually could have: python does have an equivalent to <code>foldr</code>, called <code>reduce</code> (it‚Äôs <a href="https://docs.python.org/3/library/functools.html#functools.reduce">been relegated to functools</a> since Python 3 (also technically it‚Äôs equivalent to <code>foldl</code>, not <code>foldr</code>)). We‚Äôre encouraged <em>not</em> to use it, though: the more pythonic code uses a for loop. Also, it wouldn‚Äôt work for our use case: the <code>insert</code> function we wrote is <em>mutating</em>, which doesn‚Äôt gel well with <code>reduce</code>.</p>
<p>I think this demonstrates another benefit of simple, functional APIs. If you keep things simple, and build things out of functions, they‚Äôll tend to glue together <em>well</em>, without having to write any glue code yourself. The for loop, in my opinion, is ‚Äúglue code‚Äù. The next function, <code>heapToList</code>, illustrates this even more so:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a><span class="ot">heapToList ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a>heapToList <span class="ot">=</span> unfoldr popMin</span></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb21"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a><span class="kw">def</span> heapToList(tree):</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a>  res <span class="op">=</span> []</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true"></a>  <span class="cf">try</span>:</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true"></a>    <span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true"></a>      res.append(popMin(tree))</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true"></a>  <span class="cf">except</span> <span class="pp">IndexError</span>:</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true"></a>    <span class="cf">return</span> res</span></code></pre></div>
</div>
</div>
<p>Again, things are kept simple in the Haskell example. We‚Äôve stuck to data types and functions, and these data types and functions mesh well with each other. You might be aware that there‚Äôs some deep and interesting mathematics behind the <code>foldr</code> and <code>unfoldr</code> functions going on, and <a href="https://kseo.github.io/posts/2016-12-12-unfold-and-fold.html">how they relate</a>. We don‚Äôt need to know any of that here, though: they just work together well.</p>
<p>Again, Python does have a function which is equivalent to <code>unfoldr</code>: <a href="https://docs.python.org/3/library/functions.html#iter"><code>iter</code></a> has an overload which will repeatedly call a function until it hits a sentinel value. But this doesn‚Äôt fit with the rest of the iterator model! Most iterators are terminated with the <code>StopIteration</code> exception; ours (like the <code>pop</code> function on lists) is terminated by the <code>IndexError</code> exception; and this function excepts a third version, terminated by a sentinel!</p>
<p>Finally, let‚Äôs write <code>sort</code>:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a><span class="fu">sort</span><span class="ot"> ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a><span class="fu">sort</span> <span class="ot">=</span> heapToList <span class="op">.</span> listToHeap</span></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb23"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a><span class="kw">def</span> sort(elements):</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a>  <span class="cf">return</span> heapToList(listToHeap(elements))</span></code></pre></div>
</div>
</div>
<p>This is just driving home the point: programs work <em>well</em> when they‚Äôre built out of functions, and you <em>want</em> your language to encourage you to build things out of functions. In this case, the <code>sort</code> function is built out of two smaller ones: it‚Äôs the <em>essence</em> of function composition.</p>
<h1 id="laziness">Laziness</h1>
<p>So I fully admit that laziness is one of the features of Haskell that does have downsides. I don‚Äôt think every language should be lazy, but I did want to say a little about it in regards to the sorting example here.</p>
<p>I tend to think that people overstate how hard it makes reasoning about space: it actually follows pretty straightforward rules, which you can generally step through in yourself (compared to, for instance, rewrite rules, which are often black magic!)</p>
<p>In modern programming, people will tend to use laziness it anyway. Python is a great example: the <a href="https://docs.python.org/3/library/itertools.html">itertools</a> library is almost entirely lazy. Actually making use of the laziness, though, is difficult and error-prone. Above, for instance, the <code>heapToList</code> function is lazy in Haskell, but strict in Python. Converting it to a lazy version is not the most difficult thing in the world:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a><span class="kw">def</span> heapToList(tree):</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true"></a>  <span class="cf">try</span>:</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true"></a>    <span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true"></a>      <span class="cf">yield</span> popMin(tree)</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true"></a>  <span class="cf">except</span> <span class="pp">IndexError</span>:</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true"></a>    <span class="cf">pass</span></span></code></pre></div>
<p>But now, suddenly, the entire list API won‚Äôt work. What‚Äôs more, if we try and access the <em>first</em> element of the returned value, we mutate the whole thing: anyone else looking at the output of the generator will have it mutated out from under them!</p>
<p>Laziness fundamentally makes this more reusable. Take our <code>popMin</code> function: if we just want to view the smallest element, without reconstructing the rest of the tree, we can actually use <code>popMin</code> as-is. If we don‚Äôt use the second element of the tuple we don‚Äôt pay for it. In Python, we need to write a second function.</p>
<h1 id="testing">Testing</h1>
<p>Testing the <code>sort</code> function in Haskell is ridiculously easy. Say we have an example sorting function that we trust, maybe a slow but obvious insertion sort, and we want to make sure that our fast heap sort here does the same thing. This is the test:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a>quickCheck (\xs <span class="ot">-&gt;</span> <span class="fu">sort</span> (<span class="ot">xs ::</span> [<span class="dt">Int</span>]) <span class="op">===</span> insertionSort xs)</span></code></pre></div>
<p>In that single line, the <a href="https://hackage.haskell.org/package/QuickCheck">QuickCheck</a> library will automatically generate random input, run each sort function on it, and compare the two outputs, giving a rich diff if they don‚Äôt match.</p>
<h1 id="conclusion">Conclusion</h1>
<p>This post was meant to show a few features like pattern-matching, algebraic data types, and function-based APIs in a good light. These ideas aren‚Äôt revolutionary any more, and plenty of languages have them, but unfortunately several languages don‚Äôt. Hopefully the example here illustrates a little why these features are good, and pushes back against the idea that algebraic data types are too complex for mainstream languages.</p>
<h1 id="update-5102019">Update 5/10/2019</h1>
<p>This got posted to <a href="https://reddit.com/r/haskell/comments/dclflr/what_is_good_about_haskell/">/r/haskell</a> and <a href="https://news.ycombinator.com/item?id=21145014">hackernews</a>. You can find me arguing in the comments there a little bit: I‚Äôm <a href="https://news.ycombinator.com/user?id=oisdk"><code>oisdk</code> on hackernews</a> and <a href="https://reddit.com/user/foBrowsing">u/foBrowsing on reddit</a>.</p>
<p>There are two topics that came up a bunch that I‚Äôd like to add to this post. First I‚Äôll just quote <a href="https://news.ycombinator.com/item?id=21145374">one of the comments</a> from <a href="https://news.ycombinator.com/user?id=Beltiras">Beltiras</a>:</p>
<blockquote>
<p>Friend of mine is always trying to convert me. Asked me to read this yesterday evening. This is my take on the article:</p>
</blockquote>
<blockquote>
<p>Most of my daily job goes into gluing services (API endpoints to databases or other services, some business logic in the middle). I don‚Äôt need to see yet another exposition of how to do algorithmic tasks. Haven‚Äôt seen one of those since doing my BSc. Show me the tools available to write a daemon, an http server, API endpoints, ORM-type things and you will have provided me with tools to tackle what I do. I‚Äôll never write a binary tree or search or a linked list at work.</p>
</blockquote>
<blockquote>
<p>If you want to convince me, show me what I need to know to do what I do.</p>
</blockquote>
<p>and <a href="https://news.ycombinator.com/item?id=21151580">my response</a>:</p>
<blockquote>
<p>I wasn‚Äôt really trying to convince anyone to use Haskell at their day job: I am just a college student, after all, so I would have no idea what I was talking about!</p>
</blockquote>
<blockquote>
<p>I wrote the article a while ago after being frustrated using a bunch of Go and Python at an internship. Often I really wanted simple algebraic data types and pattern-matching, but when I looked up why Go didn‚Äôt have them I saw a lot of justifications that amounted to ‚Äúfunctional features are too complex and we‚Äôre making a simple language. Haskell is notoriously complex‚Äù. In my opinion, the <code>res, err := fun(); if err != nil</code> (for example) pattern was much more complex than the alternative with pattern-matching. So I wanted to write an article demonstrating that, while Haskell has a lot of out-there stuff in it, there‚Äôs a bunch of simple ideas which really shouldn‚Äôt be missing from any modern general-purpose language.</p>
</blockquote>
<blockquote>
<p>As to why I used a binary tree as the example, I thought it was pretty self-contained, and I find skew heaps quite interesting.</p>
</blockquote>
<p>The second topic was basically people having a go at my ugly Python; to which I say: fair enough! It is not my best. I wasn‚Äôt trying necessarily to write the best Python I could here, though, rather I was trying to write the ‚Äúnormal‚Äù implementation of a binary tree. If I was to implement a binary tree of some sort myself, though, I would certainly write it in an immutable style rather than the style here. Bear in mind as well that much of what I‚Äôm arguing for is stylistic: I think (for instance) that it would be better to use <code>reduce</code> in Python more, and I think the move away from it is a bad thing. So of course I‚Äôm not going to use reduce when I‚Äôm showing the Python version: I‚Äôm doing a compare and contrast!</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>Yes, I know about the new dataclasses feature. However, it‚Äôs wrapped up with the (also new) type hints module, and as such is much more complicated to use. As the purpose of the Python code here is to provide something of a lingua franca for non-Haskellers, I decided against using it. That said, the problems outlined are <em>not</em> solved by dataclasses.<a href="#fnref1" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
</ol>
</section>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
