<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Permutations By Sorting - Donnacha Ois√≠n Kidney</title>
        <style>body{color:black;font-family:Garamond,Times New Roman,serif;font-size:14px;margin:0px auto 0px auto;padding-left:5px;padding-right:5px;max-width:600px}math{font-size:13px}img{max-width:600px}div#header{border-bottom:3px double black;margin-bottom:30px;padding:12px 0px 12px 0px}div#logo a{color:black;float:left;font-size:20px;text-decoration:none}div#header #navigation{text-align:right}div#header #navigation a{color:black;font-family:Garamond,Times New Roman,Serif;font-size:18px;margin-left:10px;text-decoration:none;text-transform:uppercase}div#footer{font-family:Garamond,Times New Roman,Serif;border-top:solid 2px black;color:#555;font-size:12px;margin-top:30px;padding:12px 0px 12px 0px;text-align:right}h1{font-family:Garamond,Times New Roman,Serif;font-size:22px;font-weight:normal}h2{font-family:Garamond,Times New Roman,Serif;font-size:20px;font-weight:normal}div.info{color:#555;font-size:15px;font-style:italic}span.quiet{color:#828282;font-style:italic}a{color:black;word-wrap:break-word}ul.post-list{margin-left:0px;padding-left:0px;list-style-type:none}.hidden_source{display:none}ol.serieslist{counter-reset:item;list-style-type:none;padding-left:20}ol li.serieslist:before{content:'Part ' counter(item,decimal) ':';counter-increment:item}table.sourceCode,tr.sourceCode,td.lineNumbers,td.sourceCode,table.sourceCode pre{margin:0;padding:0;border:0;vertical-align:baseline;border:none}td.lineNumbers{border-right:1px solid #AAAAAA;text-align:right;color:#AAAAAA;padding-right:5px;padding-left:5px}td.sourceCode{padding-left:5px}.sourceCode,code,.Agda{font-size:10px;font-family:menlo,monospace}.sourceCode span.kw{color:#262C6A}.sourceCode span.dt{color:#476A97}.sourceCode span.dv{color:#262C6A}.sourceCode span.bn{color:#262C6A}.sourceCode span.fl{color:#262C6A}.sourceCode span.ch{color:#262C6A}.sourceCode span.st{color:#702C51}.sourceCode span.co{color:#435138}.sourceCode span.ot{color:#262C6A}.sourceCode span.al{color:red}.sourceCode span.fu{color:#000000}.sourceCode span.re{color:#000000}.sourceCode span.er{color:red}li{margin-bottom:2px}li:last-child{margin-bottom:0px}.Agda .Comment{color:#B22222}.Agda .Background{}.Agda .Markup{color:#000000}.Agda .Keyword{color:#CD6600}.Agda .String{color:#B22222}.Agda .Number{color:#A020F0}.Agda .Symbol{color:#404040}.Agda .PrimitiveType{color:#0000CD}.Agda .Pragma{color:black}.Agda .Operator{}.Agda .Bound{color:black}.Agda .Generalizable{color:black}.Agda .InductiveConstructor{color:#008B00}.Agda .CoinductiveConstructor{color:#8B7500}.Agda .Datatype{color:#0000CD}.Agda .Field{color:#EE1289}.Agda .Function{color:#0000CD}.Agda .Module{color:#A020F0}.Agda .Postulate{color:#0000CD}.Agda .Primitive{color:#0000CD}.Agda .Record{color:#0000CD}.Agda .DottedPattern{}.Agda .UnsolvedMeta{color:black;background:yellow}.Agda .UnsolvedConstraint{color:black;background:yellow}.Agda .TerminationProblem{color:black;background:#FFA07A}.Agda .IncompletePattern{color:black;background:#F5DEB3}.Agda .Error{color:red;text-decoration:underline}.Agda .TypeChecks{color:black;background:#ADD8E6}.Agda a{text-decoration:none}.Agda a[href]:hover{background-color:#B4EEB4}.sourceCode{overflow-x:auto}</style>
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Donnacha Ois√≠n Kidney</a>
            </div>
            <div id="navigation">
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../rss.xml">Feed</a>
            </div>
        </div>

        <div id="content">
            <h2>Permutations By Sorting</h2>

            <div class="info">
    Posted on March 24, 2019
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="../tags/Haskell.html">Haskell</a>, <a href="../tags/Agda.html">Agda</a>
    
</div>

<p>A naive‚Äîand wrong‚Äîway to shuffle a list is to assign each element in the list a random number, and then sort it. It might not be immediately obvious why: <span class="citation" data-cites="kiselyov_provably_2002">Kiselyov (<a href="#ref-kiselyov_provably_2002">2002</a>)</span> has a good explanation as to the problem. One way to think about it is like this: choosing <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> random numbers each in the range <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">[0,n)</annotation></semantics></math> has <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>n</mi><mi>n</mi></msup><annotation encoding="application/x-tex">n^n</annotation></semantics></math> possible outcomes, whereas there are <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>!</mi></mrow><annotation encoding="application/x-tex">n!</annotation></semantics></math> permutations. Since these don‚Äôt necessarily divide evenly into each other, you‚Äôre going to have some bias.</p>
<h1 id="factorial-numbers">Factorial Numbers</h1>
<p>The first part of the fix is to figure out a way to get some random data that has only <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>!</mi></mrow><annotation encoding="application/x-tex">n!</annotation></semantics></math> possible values. The trick here will be to mimic the structure of a factorial itself: taking <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">n = 5</annotation></semantics></math>, the previous technique would have yielded:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn><mo>√ó</mo><mn>5</mn><mo>√ó</mo><mn>5</mn><mo>√ó</mo><mn>5</mn><mo>√ó</mo><mn>5</mn><mo>=</mo><msup><mn>5</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">5 \times 5 \times 5 \times 5 \times 5 = 5^5</annotation></semantics></math></p>
<p>possible values. But we want:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn><mo>√ó</mo><mn>4</mn><mo>√ó</mo><mn>3</mn><mo>√ó</mo><mn>2</mn><mo>√ó</mo><mn>1</mn><mo>=</mo><mn>5</mn><mi>!</mi></mrow><annotation encoding="application/x-tex">5 \times 4 \times 3 \times 2 \times 1 = 5!</annotation></semantics></math></p>
<p>The solution is simple, then! Simply decrement the range by one for each position in the output list. In Haskell:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">nums ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> [<span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">nums <span class="dv">0</span> <span class="fu">=</span> pure []</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">nums n <span class="fu">=</span> (<span class="fu">:</span>) <span class="fu">&lt;$&gt;</span> randomR (<span class="dv">0</span>,n) <span class="fu">&lt;*&gt;</span> nums (n<span class="fu">-</span><span class="dv">1</span>)</a></code></pre></div>
<p>As an aside, what we‚Äôve done here is constructed a list of digits in the <a href="https://en.wikipedia.org/wiki/Factorial_number_system">factorial number system</a>.</p>
<h1 id="sorts">Sorts</h1>
<p>Unfortunately, while we‚Äôve figured out a way to get properly distributed random data, we can‚Äôt yet sort it to shuffle our list. If we look at the 6 factorial numbers generated for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">n = 5</annotation></semantics></math>, we can see the problem:</p>
<pre><code>000
010
100
110
200
210</code></pre>
<p>Different values in the list will produce the same sort: <code>100</code> and <code>200</code>, for instance.</p>
<h1 id="lehmer-codes">Lehmer Codes</h1>
<p>We need a way to map the numbers above to a particular permutations: that‚Äôs precisely the problem solved by <a href="https://en.wikipedia.org/wiki/Lehmer_code">Lehmer codes</a>. For the numbers <code>110</code>, we can think of each digit as the relative position to put that item from the string into. Some Haskell code might make it clear:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">insert ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">insert <span class="dv">0</span> x xs <span class="fu">=</span> x <span class="fu">:</span> xs</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">insert i x (y<span class="fu">:</span>ys) <span class="fu">=</span> y <span class="fu">:</span> insert (i<span class="fu">-</span><span class="dv">1</span>) x ys</a>
<a class="sourceLine" id="cb3-4" data-line-number="4"></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="ot">shuffle ::</span> [a] <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">shuffle xs ys <span class="fu">=</span> foldr (uncurry insert) [] (zip ys xs)</a></code></pre></div>
<p>And we can step through its execution:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">shuffle <span class="st">&quot;abc&quot;</span> [<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>]</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">foldr (uncurry insert) [] [(<span class="dv">1</span>,<span class="ch">'a'</span>),(<span class="dv">1</span>,<span class="ch">'b'</span>),(<span class="dv">0</span>,<span class="ch">'c'</span>)]</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">insert <span class="dv">1</span> <span class="ch">'a'</span> (insert <span class="dv">1</span> <span class="ch">'b'</span> (insert <span class="dv">0</span> <span class="ch">'c'</span> []))</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">insert <span class="dv">1</span> <span class="ch">'a'</span> (insert <span class="dv">1</span> <span class="ch">'b'</span> <span class="st">&quot;c&quot;</span>)</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">insert <span class="dv">1</span> <span class="ch">'a'</span> <span class="st">&quot;cb&quot;</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6"><span class="ch">'c'</span> <span class="fu">:</span> insert <span class="dv">0</span> <span class="ch">'a'</span> <span class="st">&quot;b&quot;</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7"><span class="st">&quot;cab&quot;</span></a></code></pre></div>
<h1 id="dualities-of-sorts">Dualities of Sorts</h1>
<p>Notice the similarity of the function above to a standard insertion sort:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">insert ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">insert x [] <span class="fu">=</span> x <span class="fu">:</span> []</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">insert x (y<span class="fu">:</span>ys)</a>
<a class="sourceLine" id="cb5-4" data-line-number="4"> <span class="fu">|</span> x <span class="fu">&lt;=</span> y <span class="fu">=</span> x <span class="fu">:</span> y <span class="fu">:</span> ys</a>
<a class="sourceLine" id="cb5-5" data-line-number="5"> <span class="fu">|</span> otherwise <span class="fu">=</span> y <span class="fu">:</span> insert x ys</a>
<a class="sourceLine" id="cb5-6" data-line-number="6"></a>
<a class="sourceLine" id="cb5-7" data-line-number="7"><span class="ot">insertSort ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb5-8" data-line-number="8">insertSort <span class="fu">=</span> foldr insert []</a></code></pre></div>
<p>The ‚Äúcomparison‚Äù is a little strange‚Äîwe have to take into account relative position‚Äîbut the shape is almost identical. Once I spot something like that, my first thought is to see if the relationship extends to a better <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n \log n)</annotation></semantics></math> sort, but there‚Äôs something else I‚Äôd like to look at first.</p>
<p>‚ÄúA Duality of Sorts‚Äù <span class="citation" data-cites="hinze_duality_2013">(Hinze, Magalh√£es, and Wu <a href="#ref-hinze_duality_2013">2013</a>)</span> is a paper based on the interesting symmetry between insertion sort and selection sort <span class="citation" data-cites="haran_sorting_2016">(There‚Äôs also a video of Graham Hutton explaining the idea; Haran <a href="#ref-haran_sorting_2016">2016</a>)</span>.</p>
<p>With that paper in mind, can we rewrite <code>shuffle</code> as a selection-based algorithm? We can indeed!</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">pop ::</span> [(<span class="dt">Int</span>,a)] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, [(<span class="dt">Int</span>,a)])</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">pop [] <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">pop ((<span class="dv">0</span>,x)<span class="fu">:</span>xs) <span class="fu">=</span> <span class="dt">Just</span> (x, xs)</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">pop ((i,x)<span class="fu">:</span>xs) <span class="fu">=</span> (fmap<span class="fu">.</span>fmap) ((i<span class="fu">-</span><span class="dv">1</span>,x)<span class="fu">:</span>) (pop xs)</a>
<a class="sourceLine" id="cb6-5" data-line-number="5"></a>
<a class="sourceLine" id="cb6-6" data-line-number="6"><span class="ot">shuffle ::</span> [a] <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">shuffle xs ys <span class="fu">=</span> unfoldr pop (zip ys xs)</a></code></pre></div>
<p>While the symmetry is pleasing, the paper details how to make the relationship explicit, using the same function for both selection and insertion sort:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1">swop <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">swop (<span class="dt">Cons</span> a (x , <span class="dt">Nil</span>)) <span class="fu">=</span> <span class="dt">Cons</span> a (<span class="dt">Left</span> x)</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">swop (<span class="dt">Cons</span> a (x , <span class="dt">Cons</span> b x'))</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">  <span class="fu">|</span> fst a <span class="fu">==</span> <span class="dv">0</span> <span class="fu">=</span> <span class="dt">Cons</span> a (<span class="dt">Left</span> x)</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">  <span class="fu">|</span> otherwise  <span class="fu">=</span> <span class="dt">Cons</span> b (<span class="dt">Right</span> (<span class="dt">Cons</span> (first pred a) x'))</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">  </a>
<a class="sourceLine" id="cb7-7" data-line-number="7"><span class="ot">ishuffle ::</span> [(<span class="dt">Int</span>,a)] <span class="ot">-&gt;</span> [(<span class="dt">Int</span>,a)]</a>
<a class="sourceLine" id="cb7-8" data-line-number="8">ishuffle <span class="fu">=</span> cata (apo (swop <span class="fu">.</span> fmap (id <span class="fu">&amp;&amp;&amp;</span> project)))</a>
<a class="sourceLine" id="cb7-9" data-line-number="9"></a>
<a class="sourceLine" id="cb7-10" data-line-number="10"><span class="ot">sshuffle ::</span> [(<span class="dt">Int</span>,a)] <span class="ot">-&gt;</span> [(<span class="dt">Int</span>,a)]</a>
<a class="sourceLine" id="cb7-11" data-line-number="11">sshuffle <span class="fu">=</span> ana (para (fmap (id <span class="fu">|||</span> embed) <span class="fu">.</span> swop))</a></code></pre></div>
<h1 id="improved-efficiency">Improved Efficiency</h1>
<p>So now we have to upgrade our sorts: in the paper, merge sort is the more efficient sort chosen, similarly to what I chose <a href="2018-12-21-balancing-scans.html#random-shuffles">previously</a>.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">merge [] ys <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">merge xs [] <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">merge ((x,i)<span class="fu">:</span>xs) ((y,j)<span class="fu">:</span>ys)</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">  <span class="fu">|</span> i <span class="fu">&lt;=</span> j    <span class="fu">=</span> (x,i) <span class="fu">:</span> merge xs ((y,j<span class="fu">-</span>i)<span class="fu">:</span>ys)</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">  <span class="fu">|</span> otherwise <span class="fu">=</span> (y,j) <span class="fu">:</span> merge ((x,i<span class="fu">-</span>j<span class="fu">-</span><span class="dv">1</span>)<span class="fu">:</span>xs) ys</a>
<a class="sourceLine" id="cb8-6" data-line-number="6">  </a>
<a class="sourceLine" id="cb8-7" data-line-number="7"><span class="ot">treeFold ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb8-8" data-line-number="8">treeFold f <span class="fu">=</span> go</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-10" data-line-number="10">    go x [] <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb8-11" data-line-number="11">    go a (b<span class="fu">:</span>l) <span class="fu">=</span> go (f a b) (pairMap l)</a>
<a class="sourceLine" id="cb8-12" data-line-number="12">    pairMap (x<span class="fu">:</span>y<span class="fu">:</span>rest) <span class="fu">=</span> f x y <span class="fu">:</span> pairMap rest</a>
<a class="sourceLine" id="cb8-13" data-line-number="13">    pairMap xs <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb8-14" data-line-number="14">    </a>
<a class="sourceLine" id="cb8-15" data-line-number="15">shuffle xs inds <span class="fu">=</span> map fst <span class="fu">$</span> treeFold merge [] <span class="fu">$</span> map pure <span class="fu">$</span> zip xs inds</a></code></pre></div>
<p>However, I feel like merge sort is an upgrade of <em>insertion</em> sort, not selection sort. Indeed, if you do the ‚Äúsplit‚Äù step of merge sort badly, i.e.¬†by splitting very unevenly, merge sort in fact <em>becomes</em> insertion sort!</p>
<p>So there‚Äôs a missing bit of this table:</p>
<table>
<thead>
<tr class="header">
<th></th>
<th style="text-align: center;">Insertion</th>
<th style="text-align: center;">Selection</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n^2)</annotation></semantics></math></td>
<td style="text-align: center;">Insertion sort</td>
<td style="text-align: center;">Selection sort</td>
</tr>
<tr class="even">
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n \log n)</annotation></semantics></math></td>
<td style="text-align: center;">Merge sort</td>
<td style="text-align: center;">???</td>
</tr>
</tbody>
</table>
<p>I think it‚Äôs clear that quicksort is the algorithm that fits in there: again, done badly it degrades to selection sort (if you intentionally pick the pivot to be the worst element possible, i.e.¬†the smallest element).</p>
<p>There are more symmetries: merge sort splits the lists using their structure, and merges them using the ordering of the elements. Quicksort is the opposite, merging by concatenation, but splitting using order. Finally, in merge sort adjacent elements are in the correct order after the recursive call, but the two sides of the split are not. Again, quicksort is precisely the opposite: adjacent elements have not been compared (<em>before</em> the recursive call), but the two sides of the split are correctly ordered.</p>
<p>Anyway, I haven‚Äôt yet formalised this duality (and I don‚Äôt know if I can), but we <em>can</em> use it to produce a quicksort-based shuffle algorithm:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1">partition <span class="fu">=</span> foldr f (const ([],[]))</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">    f (y,j) ys i</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">      <span class="fu">|</span> i <span class="fu">&lt;=</span> j    <span class="fu">=</span> fmap  ((y,j<span class="fu">-</span>i)<span class="fu">:</span>) (ys i)</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">      <span class="fu">|</span> otherwise <span class="fu">=</span> first ((y,j)<span class="fu">:</span>) (ys (i<span class="fu">-</span><span class="dv">1</span>))</a>
<a class="sourceLine" id="cb9-6" data-line-number="6">      </a>
<a class="sourceLine" id="cb9-7" data-line-number="7"><span class="ot">shuffle ::</span> [a] <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb9-8" data-line-number="8">shuffle xs ys <span class="fu">=</span> go (zip xs ys)</a>
<a class="sourceLine" id="cb9-9" data-line-number="9">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-10" data-line-number="10">    go [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb9-11" data-line-number="11">    go ((x,i)<span class="fu">:</span>xs) <span class="fu">=</span> <span class="kw">case</span> partition xs i <span class="kw">of</span></a>
<a class="sourceLine" id="cb9-12" data-line-number="12">        (ls,rs) <span class="ot">-&gt;</span> go ls <span class="fu">++</span> [x] <span class="fu">++</span> go rs</a></code></pre></div>
<p>That‚Äôs all for this post! The algorithms can all be translated into Agda or Idris: I‚Äôm currently working on a way to represent permutations that isn‚Äôt <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n^2)</annotation></semantics></math> using them. If I figure out a way to properly dualise quicksort and merge sort I‚Äôll do a small write up as well <span class="citation" data-cites="hinze_sorting_2012">(I‚Äôm currently working my way through Hinze et al. <a href="#ref-hinze_sorting_2012">2012</a> for ideas)</span>. Finally, I‚Äôd like to explore some other sorting algorithms as permutation algorithms: sorting networks seem especially related to ‚Äúpermutations by swapping‚Äù.</p>
<h1 id="references" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-haran_sorting_2016">
<p>Haran, Brady. 2016. ‚ÄúSorting Secret.‚Äù <a href="https://www.youtube.com/watch?v=pcJHkWwjNl4" class="uri">https://www.youtube.com/watch?v=pcJHkWwjNl4</a>.</p>
</div>
<div id="ref-hinze_sorting_2012">
<p>Hinze, Ralf, Daniel W.H. James, Thomas Harper, Nicolas Wu, and Jos√© Pedro Magalh√£es. 2012. ‚ÄúSorting with bialgebras and distributive laws.‚Äù In <em>Proceedings of the 8th ACM SIGPLAN workshop on Generic programming - WGP ‚Äô12</em>, 69. Copenhagen, Denmark: ACM Press. doi:<a href="https://doi.org/10.1145/2364394.2364405">10.1145/2364394.2364405</a>.</p>
</div>
<div id="ref-hinze_duality_2013">
<p>Hinze, Ralf, Jos√© Pedro Magalh√£es, and Nicolas Wu. 2013. ‚ÄúA Duality of Sorts.‚Äù In <em>The Beauty of Functional Code: Essays Dedicated to Rinus Plasmeijer on the Occasion of His 61st Birthday</em>, ed by. Peter Achten and Pieter Koopman, 151‚Äì167. Lecture Notes in Computer Science. Berlin, Heidelberg: Springer Berlin Heidelberg. doi:<a href="https://doi.org/10.1007/978-3-642-40355-2_11">10.1007/978-3-642-40355-2_11</a>.</p>
</div>
<div id="ref-kiselyov_provably_2002">
<p>Kiselyov, Oleg. 2002. ‚ÄúProvably perfect random shuffling and its pure functional implementations.‚Äù <em>http://okmij.org</em>. <a href="http://okmij.org/ftp/Haskell/AlgorithmsH.html#perfect-shuffle" class="uri">http://okmij.org/ftp/Haskell/AlgorithmsH.html#perfect-shuffle</a>.</p>
</div>
</div>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
