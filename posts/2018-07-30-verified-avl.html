<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Verified AVL Trees in Haskell and Agda - Donnacha Oisín Kidney</title>
        <style>body{color:black;font-family:Garamond,Times New Roman,serif;font-size:14px;margin:0px auto 0px auto;padding-left:5px;padding-right:5px;max-width:600px}math{font-size:13px}img{max-width:600px}div#header{border-bottom:3px double black;margin-bottom:30px;padding:12px 0px 12px 0px}div#logo a{color:black;float:left;font-size:20px;text-decoration:none}div#header #navigation{text-align:right}div#header #navigation a{color:black;font-family:Garamond,Times New Roman,Serif;font-size:18px;margin-left:10px;text-decoration:none;text-transform:uppercase}div#footer{font-family:Garamond,Times New Roman,Serif;border-top:solid 2px black;color:#555;font-size:12px;margin-top:30px;padding:12px 0px 12px 0px;text-align:right}h1{font-family:Garamond,Times New Roman,Serif;font-size:22px;font-weight:normal}h2{font-family:Garamond,Times New Roman,Serif;font-size:20px;font-weight:normal}div.info{color:#555;font-size:15px;font-style:italic}span.quiet{color:#828282;font-style:italic}a{color:black;word-wrap:break-word}ul{margin-left:0px;padding-left:0px;list-style-type:none}.hidden_source{display:none}ol.serieslist{counter-reset:item;list-style-type:none;padding-left:20}ol li.serieslist:before{content:'Part ' counter(item,decimal) ':';counter-increment:item}table.sourceCode,tr.sourceCode,td.lineNumbers,td.sourceCode,table.sourceCode pre{margin:0;padding:0;border:0;vertical-align:baseline;border:none}td.lineNumbers{border-right:1px solid #AAAAAA;text-align:right;color:#AAAAAA;padding-right:5px;padding-left:5px}td.sourceCode{padding-left:5px}.sourceCode,code{font-size:10px;font-family:menlo,monospace}.sourceCode span.kw{color:#262C6A}.sourceCode span.dt{color:#476A97}.sourceCode span.dv{color:#262C6A}.sourceCode span.bn{color:#262C6A}.sourceCode span.fl{color:#262C6A}.sourceCode span.ch{color:#262C6A}.sourceCode span.st{color:#702C51}.sourceCode span.co{color:#435138}.sourceCode span.ot{color:#262C6A}.sourceCode span.al{color:red}.sourceCode span.fu{color:#000000}.sourceCode span.re{color:#000000}.sourceCode span.er{color:red}</style>
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Donnacha Oisín Kidney</a>
            </div>
            <div id="navigation">
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../rss.xml">Feed</a>
                <a href="../snippets.html">Snippets</a>
            </div>
        </div>

        <div id="content">
            <h2>Verified AVL Trees in Haskell and Agda</h2>

            <div class="info">
    Posted on July 30, 2018
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="../tags/Haskell.html">Haskell</a>, <a href="../tags/Agda.html">Agda</a>
    
</div>

<p>I’ve been writing a lot of Agda recently, and had the occasion to write a <a href="https://en.wikipedia.org/wiki/Fenwick_tree">Fenwick tree</a> that did some rebalancing. I went with <a href="https://en.wikipedia.org/wiki/AVL_tree">AVL</a>-style rebalancing (rather than <a href="https://en.wikipedia.org/wiki/Red–black_tree">red-black</a> or <a href="https://en.wikipedia.org/wiki/Weight-balanced_tree">trees of bounded balance</a>). I’d written pretty full implementations of the other two before, and the Agda standard library <span class="citation" data-cites="danielsson_agda_2018">(Danielsson <a href="#ref-danielsson_agda_2018">2018</a>)</span> has an implementation already that I was able to use as a starting point. Also, apparently, AVL trees seem to perform better than red-black trees in practice <span class="citation" data-cites="pfaff_performance_2004">(Pfaff <a href="#ref-pfaff_performance_2004">2004</a>)</span>.</p>
<p>This post will be similar in style to Stephanie Weirich’s talk <span class="citation" data-cites="weirich_depending_2014">(<a href="#ref-weirich_depending_2014">2014</a>)</span>, which compares an Agda implementation of verified red-black trees to a Haskell one. When there’s two columns of code side-by-side, the left-hand side is Haskell, the right Agda.</p>
<p>The method of constructing the ordering proof is taken from “How to Keep Your Neighbours in Order” <span class="citation" data-cites="mcbride_how_2014">(<a href="#ref-mcbride_how_2014">2014</a>)</span> by Conor McBride; the structural proofs are somewhat inspired by the implementation in the Agda standard library, but are mainly my own.</p>
<h1 id="height">Height</h1>
<p>AVL trees are more strictly balanced than red-black trees: the height of neighboring subtrees can differ by at most one. To store the height, we will start as every dependently-typed program does: with Peano numbers.</p>
<style>
.column {
    float: left;
    width: 50%;
}
.row:after {
    content: "";
    display: table;
    clear: both;
}
</style>
<div class="row">
<div class="column">
<p>Haskell</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> <span class="dt">N</span> <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">|</span> <span class="dt">S</span> <span class="dt">N</span></a></code></pre></div>
</div>
<div class="column">
<p>Agda</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> ℕ <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  zero <span class="ot">:</span> ℕ</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  suc  <span class="ot">:</span> ℕ <span class="ot">→</span> ℕ</a></code></pre></div>
</div>
</div>
<p>The trees will be balanced one of three possible ways: left-heavy, right-heavy, or even. We can represent these three cases in a GADT in the case of Haskell, or an indexed datatype in the case of Agda:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Balance</span><span class="ot"> ::</span> <span class="dt">N</span> <span class="ot">-&gt;</span> <span class="dt">N</span> <span class="ot">-&gt;</span> <span class="dt">N</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">      <span class="dt">L</span><span class="ot"> ::</span> <span class="dt">Balance</span> (<span class="dt">S</span> n) n    (<span class="dt">S</span> n)</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">      <span class="dt">O</span><span class="ot"> ::</span> <span class="dt">Balance</span>  n    n     n</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">      <span class="dt">R</span><span class="ot"> ::</span> <span class="dt">Balance</span>  n   (<span class="dt">S</span> n) (<span class="dt">S</span> n)</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb4"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">data</span> ⟨<span class="ot">_</span>⊔<span class="ot">_</span>⟩≡<span class="ot">_</span> <span class="ot">:</span> ℕ <span class="ot">→</span> ℕ <span class="ot">→</span> ℕ <span class="ot">→</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  ◿  <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">→</span> ⟨ suc  n ⊔      n ⟩≡ suc  n</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  ▽  <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">→</span> ⟨      n ⊔      n ⟩≡      n</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">  ◺  <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">→</span> ⟨      n ⊔ suc  n ⟩≡ suc  n</a></code></pre></div>
</div>
</div>
<p>Those unfamiliar with Agda might be a little intimidated by the mixfix operator in the balance definition: we’re using it here because the type can be seen of a proof that:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">max(x,y) = z</annotation></semantics></math></p>
<p>Or, using the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>⊔</mo><annotation encoding="application/x-tex">\sqcup</annotation></semantics></math> operator:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>⊔</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">(x \sqcup y) = z</annotation></semantics></math></p>
<p>We’ll use this proof in the tree itself, as we’ll need to know the maximum of the height of a node’s two subtrees to find the height of the node. Before we do that, we’ll need a couple helper functions for manipulating the balance:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">balr ::</span> <span class="dt">Balance</span> x y z <span class="ot">-&gt;</span> <span class="dt">Balance</span> z x z</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">balr <span class="dt">L</span> <span class="fu">=</span> <span class="dt">O</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">balr <span class="dt">O</span> <span class="fu">=</span> <span class="dt">O</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">balr <span class="dt">R</span> <span class="fu">=</span> <span class="dt">L</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5"></a>
<a class="sourceLine" id="cb5-6" data-line-number="6"><span class="ot">ball ::</span> <span class="dt">Balance</span> x y z <span class="ot">-&gt;</span> <span class="dt">Balance</span> y z z</a>
<a class="sourceLine" id="cb5-7" data-line-number="7">ball <span class="dt">L</span> <span class="fu">=</span> <span class="dt">R</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8">ball <span class="dt">O</span> <span class="fu">=</span> <span class="dt">O</span></a>
<a class="sourceLine" id="cb5-9" data-line-number="9">ball <span class="dt">R</span> <span class="fu">=</span> <span class="dt">O</span></a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb6"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb6-1" data-line-number="1">⃕ <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>x y z<span class="ot">}</span> <span class="ot">→</span> ⟨ x ⊔ y ⟩≡ z <span class="ot">→</span> ⟨ z ⊔ x ⟩≡ z</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">⃕  ◿  <span class="ot">=</span> ▽</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">⃕  ▽  <span class="ot">=</span> ▽</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">⃕  ◺  <span class="ot">=</span> ◿</a>
<a class="sourceLine" id="cb6-5" data-line-number="5"></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">⃔ <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>x y z<span class="ot">}</span> <span class="ot">→</span> ⟨ x ⊔ y ⟩≡ z <span class="ot">→</span> ⟨ y ⊔ z ⟩≡ z</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">⃔  ◿  <span class="ot">=</span> ◺</a>
<a class="sourceLine" id="cb6-8" data-line-number="8">⃔  ▽  <span class="ot">=</span> ▽</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">⃔  ◺  <span class="ot">=</span> ▽</a></code></pre></div>
</div>
</div>
<h1 id="ordering">Ordering</h1>
<p>Along with the verification of the structure of the tree, we will also want to verify that its contents are ordered correctly. Unfortunately, this property is a little out of reach for Haskell, but it’s 100% doable in Agda. First, we’ll need a way to describe orders on a data type. In Haskell, we might write:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Ord</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="ot">  (==) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="ot">  (&lt;)  ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a></code></pre></div>
</div>
<div class="column">
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>*</mo><mo>*</mo><mo>*</mo></mrow><annotation encoding="application/x-tex">***</annotation></semantics></math>
</div>
</div>
<p>That <code class="sourceCode haskell"><span class="dt">Bool</span></code> throws away any information gained in the comparison, though: we want to supply a proof with the result of the comparison. First, equality:</p>
<div class="row">
<div class="column">
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>*</mo><mo>*</mo><mo>*</mo></mrow><annotation encoding="application/x-tex">***</annotation></semantics></math>
</div>
<div class="column">
<div class="sourceCode" id="cb8"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">infix</span> <span class="dv">4</span> <span class="ot">_</span>≡<span class="ot">_</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="kw">data</span> <span class="ot">_</span>≡<span class="ot">_</span> <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">(</span>x <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">:</span> A <span class="ot">→</span> <span class="dt">Set</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  refl <span class="ot">:</span> x ≡ x</a></code></pre></div>
</div>
</div>
<p>This is one of the many ways to describe equality in Agda. It’s a type with only one constructor, and it can only be constructed when its two arguments are the same. When we pattern match on the constructor, then, we’re given a proof that whatever things those arguments refer to must be the same.</p>
<p>Next, we need to describe an order. For this, we’ll need two types: the empty type, and the unit type.</p>
<div class="row">
<div class="column">
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>*</mo><mo>*</mo><mo>*</mo></mrow><annotation encoding="application/x-tex">***</annotation></semantics></math>
</div>
<div class="column">
<div class="sourceCode" id="cb9"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">data</span> ⊥ <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="kw">data</span> ⊤ <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span> ⟨⟩ <span class="ot">:</span> ⊤</a></code></pre></div>
</div>
</div>
<p>These are kind of like type-level Bools, with one extra, powerful addition: they keep their proof after construction. Because <code class="sourceCode agda">⊥</code> has no constructors, if someone tells you they’re going to give you one, you can be pretty sure they’re lying. How do we use this? Well, first, on the numbers:</p>
<div class="row">
<div class="column">
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>*</mo><mo>*</mo><mo>*</mo></mrow><annotation encoding="application/x-tex">***</annotation></semantics></math>
</div>
<div class="column">
<div class="sourceCode" id="cb10"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">_</span>ℕ&lt;<span class="ot">_</span> <span class="ot">:</span> ℕ <span class="ot">→</span> ℕ <span class="ot">→</span> <span class="dt">Set</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">x     ℕ&lt; zero  <span class="ot">=</span> ⊥</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">zero  ℕ&lt; suc y <span class="ot">=</span> ⊤</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">suc x ℕ&lt; suc y <span class="ot">=</span> x ℕ&lt; y</a></code></pre></div>
</div>
</div>
<p>Therefore, if we ask for something of type <code class="sourceCode agda">x ℕ&lt; y</code> (for some <code>x</code> and <code>y</code>), we know that it only exists when <code>x</code> really is less than <code>y</code> (according to the definition above).</p>
<p>For our actual code, we’ll parameterize the whole thing over some abstract key type. We’ll do this using a module (a feature recently added to Haskell, as it happens). That might look something like this:</p>
<div class="row">
<div class="column">
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>*</mo><mo>*</mo><mo>*</mo></mrow><annotation encoding="application/x-tex">***</annotation></semantics></math>
</div>
<div class="column">
<div class="sourceCode" id="cb11"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">module</span> AVL</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">  <span class="ot">{</span>k r<span class="ot">}</span> <span class="ot">(</span>Key <span class="ot">:</span> <span class="dt">Set</span> k<span class="ot">)</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  <span class="ot">{_</span>&lt;<span class="ot">_</span> <span class="ot">:</span> Rel Key r<span class="ot">}</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4">  <span class="ot">(</span>isStrictTotalOrder</a>
<a class="sourceLine" id="cb11-5" data-line-number="5">  <span class="ot">:</span> IsStrictTotalOrder <span class="ot">_</span>≡<span class="ot">_</span> <span class="ot">_</span>&lt;<span class="ot">_)</span></a>
<a class="sourceLine" id="cb11-6" data-line-number="6">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-7" data-line-number="7"></a>
<a class="sourceLine" id="cb11-8" data-line-number="8">  <span class="kw">open</span> IsStrictTotalOrder isStrictTotalOrder</a></code></pre></div>
</div>
</div>
<p>(the <code class="sourceCode agda">k</code> and <code class="sourceCode agda">r</code> here, as well as the <code class="sourceCode agda">Lift</code>ing noise below, are to do with Agda’s universe system, which I’ll try explain in a bit)</p>
<p>Now, the trick for the ordering is to keep a proof that two neighboring values are ordered correctly in the tree at each leaf (as there’s a leaf between every pair of nodes, this is exactly the place you <em>should</em> store such a proof). A problem arises with the extremal leaves in the tree (leftmost and rightmost): each leaf is missing one neighboring value, so how can it store a proof of order? The solution is to affix two elements to our key type which we define as the greatest and least elements of the set.</p>
<div class="row">
<div class="column">
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>*</mo><mo>*</mo><mo>*</mo></mrow><annotation encoding="application/x-tex">***</annotation></semantics></math>
</div>
<div class="column">
<div class="sourceCode" id="cb12"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">infix</span> <span class="dv">5</span> [<span class="ot">_</span>]</a>
<a class="sourceLine" id="cb12-2" data-line-number="2"></a>
<a class="sourceLine" id="cb12-3" data-line-number="3"><span class="kw">data</span> [∙] <span class="ot">:</span> <span class="dt">Set</span> k <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">  ⌊⌋ ⌈⌉ <span class="ot">:</span> [∙]</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">  [<span class="ot">_</span>]   <span class="ot">:</span> <span class="ot">(</span>k <span class="ot">:</span> Key<span class="ot">)</span> <span class="ot">→</span> [∙]</a>
<a class="sourceLine" id="cb12-6" data-line-number="6"></a>
<a class="sourceLine" id="cb12-7" data-line-number="7"><span class="kw">infix</span> <span class="dv">4</span> <span class="ot">_</span>[&lt;]<span class="ot">_</span></a>
<a class="sourceLine" id="cb12-8" data-line-number="8"></a>
<a class="sourceLine" id="cb12-9" data-line-number="9"><span class="ot">_</span>[&lt;]<span class="ot">_</span> <span class="ot">:</span> [∙] <span class="ot">→</span> [∙] <span class="ot">→</span> <span class="dt">Set</span> r</a>
<a class="sourceLine" id="cb12-10" data-line-number="10">⌊⌋     [&lt;] ⌊⌋    <span class="ot">=</span> Lift r ⊥</a>
<a class="sourceLine" id="cb12-11" data-line-number="11">⌊⌋     [&lt;] ⌈⌉    <span class="ot">=</span> Lift r ⊤</a>
<a class="sourceLine" id="cb12-12" data-line-number="12">⌊⌋     [&lt;] [ <span class="ot">_</span> ] <span class="ot">=</span> Lift r ⊤</a>
<a class="sourceLine" id="cb12-13" data-line-number="13">⌈⌉     [&lt;] <span class="ot">_</span>     <span class="ot">=</span> Lift r ⊥</a>
<a class="sourceLine" id="cb12-14" data-line-number="14">[ <span class="ot">_</span> ]  [&lt;] ⌊⌋    <span class="ot">=</span> Lift r ⊥</a>
<a class="sourceLine" id="cb12-15" data-line-number="15">[ <span class="ot">_</span> ]  [&lt;] ⌈⌉    <span class="ot">=</span> Lift r ⊤</a>
<a class="sourceLine" id="cb12-16" data-line-number="16">[ x ]  [&lt;] [ y ] <span class="ot">=</span> x &lt; y</a></code></pre></div>
</div>
</div>
<h1 id="the-tree-type">The Tree Type</h1>
<p>After all that, we can get bring back Haskell into the story, and define or tree types:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"></a>
<a class="sourceLine" id="cb13-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Tree</span><span class="ot"> ::</span> <span class="dt">N</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">          <span class="ot">-&gt;</span> <span class="dt">Type</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4">          <span class="ot">-&gt;</span> <span class="dt">Type</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5">          <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-6" data-line-number="6">  <span class="dt">Leaf</span><span class="ot"> ::</span> <span class="dt">Tree</span> <span class="dt">Z</span> k v</a>
<a class="sourceLine" id="cb13-7" data-line-number="7">  <span class="dt">Node</span><span class="ot"> ::</span> k</a>
<a class="sourceLine" id="cb13-8" data-line-number="8">       <span class="ot">-&gt;</span> v</a>
<a class="sourceLine" id="cb13-9" data-line-number="9">       <span class="ot">-&gt;</span> <span class="dt">Balance</span> lh rh h</a>
<a class="sourceLine" id="cb13-10" data-line-number="10">       <span class="ot">-&gt;</span> <span class="dt">Tree</span> lh k v</a>
<a class="sourceLine" id="cb13-11" data-line-number="11">       <span class="ot">-&gt;</span> <span class="dt">Tree</span> rh k v</a>
<a class="sourceLine" id="cb13-12" data-line-number="12">       <span class="ot">-&gt;</span> <span class="dt">Tree</span> (<span class="dt">S</span> h) k v</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb14"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw">data</span> Tree <span class="ot">{</span>v<span class="ot">}</span> </a>
<a class="sourceLine" id="cb14-2" data-line-number="2">          <span class="ot">(</span>V <span class="ot">:</span> Key <span class="ot">→</span> <span class="dt">Set</span> v<span class="ot">)</span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3">          <span class="ot">(</span>l u <span class="ot">:</span> [∙]<span class="ot">)</span> <span class="ot">:</span> ℕ <span class="ot">→</span></a>
<a class="sourceLine" id="cb14-4" data-line-number="4">          <span class="dt">Set</span> <span class="ot">(</span>k ⊔ v ⊔ r<span class="ot">)</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-5" data-line-number="5">  leaf  <span class="ot">:</span> <span class="ot">(</span>l&lt;u <span class="ot">:</span> l [&lt;] u<span class="ot">)</span> <span class="ot">→</span> Tree V l u <span class="dv">0</span></a>
<a class="sourceLine" id="cb14-6" data-line-number="6">  node  <span class="ot">:</span> <span class="ot">∀</span>  <span class="ot">{</span>h lh rh<span class="ot">}</span></a>
<a class="sourceLine" id="cb14-7" data-line-number="7">             <span class="ot">(</span>k <span class="ot">:</span> Key<span class="ot">)</span></a>
<a class="sourceLine" id="cb14-8" data-line-number="8">             <span class="ot">(</span>v <span class="ot">:</span> V k<span class="ot">)</span></a>
<a class="sourceLine" id="cb14-9" data-line-number="9">             <span class="ot">(</span>bl <span class="ot">:</span> ⟨ lh ⊔ rh ⟩≡ h<span class="ot">)</span></a>
<a class="sourceLine" id="cb14-10" data-line-number="10">             <span class="ot">(</span>lk <span class="ot">:</span> Tree V l [ k ] lh<span class="ot">)</span></a>
<a class="sourceLine" id="cb14-11" data-line-number="11">             <span class="ot">(</span>ku <span class="ot">:</span> Tree V [ k ] u rh<span class="ot">)</span> <span class="ot">→</span></a>
<a class="sourceLine" id="cb14-12" data-line-number="12">             Tree V l u <span class="ot">(</span>suc h<span class="ot">)</span></a></code></pre></div>
</div>
</div>
<p>The two definitions are similar, but have a few obvious differences. The Agda version stores the ordering proof at the leaves, as well as the bounds as indices. Its <a href="https://pigworker.wordpress.com/2015/01/09/universe-hierarchies/"><em>universe</em></a> is also different: briefly, universes are one of the ways to avoid Russell’s paradox when you’re dealing with dependent types.</p>
<p>In normal, standard Haskell, we think of types as things that describe values (how quaint!). When you’ve got a list, everything in the list has the same type, and that is good and right.</p>
<p>These days, though, we’re not so constrained:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:-</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2"><span class="kw">data</span> <span class="dt">List</span> xs <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-3" data-line-number="3">  <span class="dt">Nil</span><span class="ot"> ::</span> <span class="dt">List</span> <span class="ch">'[]</span></a>
<a class="sourceLine" id="cb15-4" data-line-number="4"><span class="ot">  (:-) ::</span> x <span class="ot">-&gt;</span> <span class="dt">List</span> xs <span class="ot">-&gt;</span> <span class="dt">List</span> (x <span class="fu">:</span> xs)</a></code></pre></div>
</div>
<div class="column">
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>*</mo><mo>*</mo><mo>*</mo></mrow><annotation encoding="application/x-tex">***</annotation></semantics></math>
</div>
</div>
<p>This can quite happily store elements of different types:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="ot">example ::</span> <span class="dt">List</span> [<span class="dt">Bool</span>, <span class="dt">String</span>, <span class="dt">Integer</span>]</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">example <span class="fu">=</span> <span class="dt">True</span> <span class="fu">:-</span> <span class="st">&quot;true&quot;</span> <span class="fu">:-</span> <span class="dv">1</span> <span class="fu">:-</span> <span class="dt">Nil</span></a></code></pre></div>
</div>
<div class="column">
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>*</mo><mo>*</mo><mo>*</mo></mrow><annotation encoding="application/x-tex">***</annotation></semantics></math>
</div>
</div>
<p>And look at that bizarre-looking list on the wrong side of “<code class="sourceCode haskell"><span class="ot">::</span></code>”! Types aren’t just describing values, they’re acting like values themselves. What type does <code class="sourceCode haskell">[<span class="dt">Bool</span>, <span class="dt">String</span>, <span class="dt">Integer</span>]</code> even have, anyway? Why, <code class="sourceCode haskell">[<span class="dt">Type</span>]</code> of course!</p>
<p>So we see that types can be put in lists, and types have types: the natural question then is:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="dt">Type</span><span class="ot"> ::</span> <span class="fu">???</span></a></code></pre></div>
</div>
<div class="column">
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>*</mo><mo>*</mo><mo>*</mo></mrow><annotation encoding="application/x-tex">***</annotation></semantics></math>
</div>
</div>
<p>And this is where Haskell and Agda diverge: in Haskell, we say <code class="sourceCode haskell"><span class="dt">Type</span><span class="ot"> ::</span> <span class="dt">Type</span></code> (as the old extension <code class="sourceCode haskell"><span class="dt">TypeInType</span></code> implied), and that’s that. From a certain point of view, we’ve opened the door to Russell’s paradox (we’ve allowed a set to be a member of itself). This isn’t an issue in Haskell, though, as the type-level language was already inconsistent.</p>
<p>Agda goes another way, saying that <code class="sourceCode agda"><span class="dt">Set</span></code> (Agda’s equivalent for <code class="sourceCode haskell"><span class="dt">Type</span></code>) has the type <code class="sourceCode agda"><span class="dt">Set₁</span></code>, and <code class="sourceCode agda"><span class="dt">Set₁</span></code> has the type <code class="sourceCode agda"><span class="dt">Set₂</span></code>, and so on<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>. These different sets are called “universes” and their numbers “levels”. When we write <code class="sourceCode agda">k ⊔ v ⊔ r</code>, we’re saying we want to take the greatest universe level from those three possible levels: the level of the key, the value, and the relation, respectively.</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="dt">Type</span><span class="ot"> ::</span> <span class="dt">Type</span></a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb19"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="dt">Set</span> <span class="ot">:</span> <span class="dt">Set₁</span></a></code></pre></div>
</div>
</div>
<h1 id="rotations">Rotations</h1>
<p>AVL trees maintain their invariants through relatively simple rotations. We’ll start with the right rotation, which fixes an imbalance of two on the left. Because the size of the tree returned might change, we’ll need to wrap it in a datatype:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Inserted</span><span class="ot"> ::</span> <span class="dt">Type</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2">              <span class="ot">-&gt;</span> <span class="dt">Type</span></a>
<a class="sourceLine" id="cb20-3" data-line-number="3">              <span class="ot">-&gt;</span> <span class="dt">N</span></a>
<a class="sourceLine" id="cb20-4" data-line-number="4">              <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-5" data-line-number="5">        <span class="dt">Stay</span><span class="ot"> ::</span> <span class="dt">Tree</span> n k v</a>
<a class="sourceLine" id="cb20-6" data-line-number="6">             <span class="ot">-&gt;</span> <span class="dt">Inserted</span> k v n</a>
<a class="sourceLine" id="cb20-7" data-line-number="7">        <span class="dt">Incr</span><span class="ot"> ::</span> <span class="dt">Tree</span> (<span class="dt">S</span> n) k v</a>
<a class="sourceLine" id="cb20-8" data-line-number="8">             <span class="ot">-&gt;</span> <span class="dt">Inserted</span> k v n</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb21"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb21-1" data-line-number="1">Inserted  <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>v<span class="ot">}</span> </a>
<a class="sourceLine" id="cb21-2" data-line-number="2">              <span class="ot">(</span>V <span class="ot">:</span> Key <span class="ot">→</span> <span class="dt">Set</span> v<span class="ot">)</span></a>
<a class="sourceLine" id="cb21-3" data-line-number="3">              <span class="ot">(</span>l u <span class="ot">:</span> [∙]<span class="ot">)</span></a>
<a class="sourceLine" id="cb21-4" data-line-number="4">              <span class="ot">(</span>n <span class="ot">:</span> ℕ<span class="ot">)</span> <span class="ot">→</span></a>
<a class="sourceLine" id="cb21-5" data-line-number="5">              <span class="dt">Set</span> <span class="ot">(</span>k ⊔ v ⊔ r<span class="ot">)</span></a>
<a class="sourceLine" id="cb21-6" data-line-number="6">Inserted V l u n <span class="ot">=</span></a>
<a class="sourceLine" id="cb21-7" data-line-number="7">  ∃[ inc? ] Tree V l u <span class="ot">(</span>if inc?</a>
<a class="sourceLine" id="cb21-8" data-line-number="8">                           then suc n</a>
<a class="sourceLine" id="cb21-9" data-line-number="9">                           else n<span class="ot">)</span></a>
<a class="sourceLine" id="cb21-10" data-line-number="10"></a>
<a class="sourceLine" id="cb21-11" data-line-number="11"><span class="kw">pattern</span> 0+ tr <span class="ot">=</span> false  , tr</a>
<a class="sourceLine" id="cb21-12" data-line-number="12"><span class="kw">pattern</span> 1+ tr <span class="ot">=</span> true   , tr</a></code></pre></div>
</div>
</div>
<p>We could actually have the Agda definition be the same as Haskell’s, it doesn’t make much difference. I’m mainly using it here to demonstrate dependent pairs in Agda. The first member of the pair is just a boolean (increased in height/not increased in height). The second member is a tree whose height <em>depends</em> on the actual value of the boolean. The <code class="sourceCode agda">∃</code> business is just a fancy syntax; it also waggles its eyebrows at the way a (dependent) pair of type <code>(x , y)</code> means “There exists an x such that y”.</p>
<p>Using this, we can write the type for right-rotation:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="ot">rotr ::</span> k</a>
<a class="sourceLine" id="cb22-2" data-line-number="2">     <span class="ot">-&gt;</span> v</a>
<a class="sourceLine" id="cb22-3" data-line-number="3">     <span class="ot">-&gt;</span> <span class="dt">Tree</span> (<span class="dt">S</span> (<span class="dt">S</span> rh)) k v</a>
<a class="sourceLine" id="cb22-4" data-line-number="4">     <span class="ot">-&gt;</span> <span class="dt">Tree</span> rh k v</a>
<a class="sourceLine" id="cb22-5" data-line-number="5">     <span class="ot">-&gt;</span> <span class="dt">Inserted</span> k v (<span class="dt">S</span> (<span class="dt">S</span> rh))</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb23"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb23-1" data-line-number="1">rotʳ <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>lb ub rh v<span class="ot">}</span> <span class="ot">{</span>V <span class="ot">:</span> Key <span class="ot">→</span> <span class="dt">Set</span> v<span class="ot">}</span></a>
<a class="sourceLine" id="cb23-2" data-line-number="2">     <span class="ot">→</span> <span class="ot">(</span>k <span class="ot">:</span> Key<span class="ot">)</span></a>
<a class="sourceLine" id="cb23-3" data-line-number="3">     <span class="ot">→</span> V k</a>
<a class="sourceLine" id="cb23-4" data-line-number="4">     <span class="ot">→</span> Tree V lb [ k ] <span class="ot">(</span>suc <span class="ot">(</span>suc rh<span class="ot">))</span></a>
<a class="sourceLine" id="cb23-5" data-line-number="5">     <span class="ot">→</span> Tree V [ k ] ub rh</a>
<a class="sourceLine" id="cb23-6" data-line-number="6">     <span class="ot">→</span> Inserted V lb ub <span class="ot">(</span>suc <span class="ot">(</span>suc rh<span class="ot">))</span></a></code></pre></div>
</div>
</div>
<p>There are two possible cases, single rotation:</p>
<style>
.tree {
  margin: auto;
  width: 30%;
}
</style>
<div class="tree">
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1">   ┌a       ┌a</a>
<a class="sourceLine" id="cb24-2" data-line-number="2"> ┌y┤       y┤</a>
<a class="sourceLine" id="cb24-3" data-line-number="3"> │ └b <span class="fu">---&gt;</span>  │ ┌b</a>
<a class="sourceLine" id="cb24-4" data-line-number="4">x┤          └x┤</a>
<a class="sourceLine" id="cb24-5" data-line-number="5"> └c           └c</a></code></pre></div>
</div>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1">rotr x xv (<span class="dt">Node</span> y yv <span class="dt">L</span> a b) c <span class="fu">=</span></a>
<a class="sourceLine" id="cb25-2" data-line-number="2">  <span class="dt">Stay</span> (<span class="dt">Node</span> y yv <span class="dt">O</span> a (<span class="dt">Node</span> x xv <span class="dt">O</span> b c))</a>
<a class="sourceLine" id="cb25-3" data-line-number="3">rotr x xv (<span class="dt">Node</span> y yv <span class="dt">O</span> a b) c <span class="fu">=</span></a>
<a class="sourceLine" id="cb25-4" data-line-number="4">  <span class="dt">Incr</span> (<span class="dt">Node</span> y yv <span class="dt">R</span> a (<span class="dt">Node</span> x xv <span class="dt">L</span> b c))</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb26"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb26-1" data-line-number="1">rotʳ x xv <span class="ot">(</span>node y yv ◿ a b<span class="ot">)</span> c <span class="ot">=</span></a>
<a class="sourceLine" id="cb26-2" data-line-number="2">  0+ <span class="ot">(</span>node y yv ▽ a <span class="ot">(</span>node x xv ▽  b c<span class="ot">))</span></a>
<a class="sourceLine" id="cb26-3" data-line-number="3">rotʳ x xv <span class="ot">(</span>node y yv ▽ a b<span class="ot">)</span> c <span class="ot">=</span></a>
<a class="sourceLine" id="cb26-4" data-line-number="4">  1+ <span class="ot">(</span>node y yv ◺ a <span class="ot">(</span>node x xv ◿  b c<span class="ot">))</span></a></code></pre></div>
</div>
</div>
<p>And double:</p>
<div class="tree">
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1">   ┌a           ┌a</a>
<a class="sourceLine" id="cb27-2" data-line-number="2"> ┌y┤          ┌y┤</a>
<a class="sourceLine" id="cb27-3" data-line-number="3"> │ │ ┌b       │ └b</a>
<a class="sourceLine" id="cb27-4" data-line-number="4"> │ └z┤  <span class="fu">---&gt;</span> z┤</a>
<a class="sourceLine" id="cb27-5" data-line-number="5"> │   └c       │ ┌c</a>
<a class="sourceLine" id="cb27-6" data-line-number="6">x┤            └x┤</a>
<a class="sourceLine" id="cb27-7" data-line-number="7"> └d             └d</a></code></pre></div>
</div>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1">rotr x xv (<span class="dt">Node</span> y yv <span class="dt">R</span> a </a>
<a class="sourceLine" id="cb28-2" data-line-number="2">            (<span class="dt">Node</span> z zv bl b c)) d <span class="fu">=</span></a>
<a class="sourceLine" id="cb28-3" data-line-number="3">  <span class="dt">Stay</span> (<span class="dt">Node</span> z zv <span class="dt">O</span> </a>
<a class="sourceLine" id="cb28-4" data-line-number="4">         (<span class="dt">Node</span> y yv (balr bl) a b)</a>
<a class="sourceLine" id="cb28-5" data-line-number="5">         (<span class="dt">Node</span> x xv (ball bl) c d))</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb29"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb29-1" data-line-number="1">rotʳ x xv <span class="ot">(</span>node y yv ◺  a</a>
<a class="sourceLine" id="cb29-2" data-line-number="2">            <span class="ot">(</span>node z zv bl b c<span class="ot">))</span> d <span class="ot">=</span></a>
<a class="sourceLine" id="cb29-3" data-line-number="3">  0+ <span class="ot">(</span>node z zv ▽</a>
<a class="sourceLine" id="cb29-4" data-line-number="4">       <span class="ot">(</span>node y yv <span class="ot">(</span>⃕ bl<span class="ot">)</span> a b<span class="ot">)</span></a>
<a class="sourceLine" id="cb29-5" data-line-number="5">       <span class="ot">(</span>node x xv <span class="ot">(</span>⃔ bl<span class="ot">)</span> c d<span class="ot">))</span></a></code></pre></div>
</div>
</div>
<p>I won’t bore you with left-rotation: suffice to say, it’s the opposite of right-rotation.</p>
<h1 id="insertion">Insertion</h1>
<p>Finally, the main event: insertion. Once the above functions have all been defined, it’s not very difficult, as it happens: by and large, the types guide you to the right answer. Of course, this is only after we decided to use the pivotal pragmatism and balance approach.</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" data-line-number="1">insertWith</a>
<a class="sourceLine" id="cb30-2" data-line-number="2"><span class="ot">    ::</span> <span class="dt">Ord</span> k</a>
<a class="sourceLine" id="cb30-3" data-line-number="3">    <span class="ot">=&gt;</span> (v <span class="ot">-&gt;</span> v <span class="ot">-&gt;</span> v)</a>
<a class="sourceLine" id="cb30-4" data-line-number="4">    <span class="ot">-&gt;</span> k</a>
<a class="sourceLine" id="cb30-5" data-line-number="5">    <span class="ot">-&gt;</span> v</a>
<a class="sourceLine" id="cb30-6" data-line-number="6">    <span class="ot">-&gt;</span> <span class="dt">Tree</span> h k v</a>
<a class="sourceLine" id="cb30-7" data-line-number="7">    <span class="ot">-&gt;</span> <span class="dt">Inserted</span> k v h</a>
<a class="sourceLine" id="cb30-8" data-line-number="8">insertWith _ v vc <span class="dt">Leaf</span> <span class="fu">=</span></a>
<a class="sourceLine" id="cb30-9" data-line-number="9">  <span class="dt">Incr</span> (<span class="dt">Node</span> v vc <span class="dt">O</span> <span class="dt">Leaf</span> <span class="dt">Leaf</span>)</a>
<a class="sourceLine" id="cb30-10" data-line-number="10">insertWith f v vc (<span class="dt">Node</span> k kc bl tl tr) <span class="fu">=</span></a>
<a class="sourceLine" id="cb30-11" data-line-number="11">  <span class="kw">case</span> compare v k <span class="kw">of</span></a>
<a class="sourceLine" id="cb30-12" data-line-number="12">    <span class="dt">LT</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb30-13" data-line-number="13">      <span class="kw">case</span> insertWith f v vc tl <span class="kw">of</span></a>
<a class="sourceLine" id="cb30-14" data-line-number="14">        <span class="dt">Stay</span> tl' <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb30-15" data-line-number="15">          <span class="dt">Stay</span> (<span class="dt">Node</span> k kc bl tl' tr)</a>
<a class="sourceLine" id="cb30-16" data-line-number="16">        <span class="dt">Incr</span> tl' <span class="ot">-&gt;</span> <span class="kw">case</span> bl <span class="kw">of</span></a>
<a class="sourceLine" id="cb30-17" data-line-number="17">          <span class="dt">L</span> <span class="ot">-&gt;</span> rotr k kc tl' tr</a>
<a class="sourceLine" id="cb30-18" data-line-number="18">          <span class="dt">O</span> <span class="ot">-&gt;</span> <span class="dt">Incr</span> (<span class="dt">Node</span> k kc <span class="dt">L</span> tl' tr)</a>
<a class="sourceLine" id="cb30-19" data-line-number="19">          <span class="dt">R</span> <span class="ot">-&gt;</span> <span class="dt">Stay</span> (<span class="dt">Node</span> k kc <span class="dt">O</span> tl' tr)</a>
<a class="sourceLine" id="cb30-20" data-line-number="20">    <span class="dt">EQ</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb30-21" data-line-number="21">      <span class="dt">Stay</span> (<span class="dt">Node</span> v (f vc kc) bl tl tr)</a>
<a class="sourceLine" id="cb30-22" data-line-number="22">    <span class="dt">GT</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb30-23" data-line-number="23">      <span class="kw">case</span> insertWith f v vc tr <span class="kw">of</span></a>
<a class="sourceLine" id="cb30-24" data-line-number="24">        <span class="dt">Stay</span> tr' <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb30-25" data-line-number="25">          <span class="dt">Stay</span> (<span class="dt">Node</span> k kc bl tl tr')</a>
<a class="sourceLine" id="cb30-26" data-line-number="26">        <span class="dt">Incr</span> tr' <span class="ot">-&gt;</span> <span class="kw">case</span> bl <span class="kw">of</span></a>
<a class="sourceLine" id="cb30-27" data-line-number="27">          <span class="dt">L</span> <span class="ot">-&gt;</span> <span class="dt">Stay</span> (<span class="dt">Node</span> k kc <span class="dt">O</span> tl tr')</a>
<a class="sourceLine" id="cb30-28" data-line-number="28">          <span class="dt">O</span> <span class="ot">-&gt;</span> <span class="dt">Incr</span> (<span class="dt">Node</span> k kc <span class="dt">R</span> tl tr')</a>
<a class="sourceLine" id="cb30-29" data-line-number="29">          <span class="dt">R</span> <span class="ot">-&gt;</span> rotl k kc tl tr'</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb31"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb31-1" data-line-number="1">insert <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>l u h v<span class="ot">}</span></a>
<a class="sourceLine" id="cb31-2" data-line-number="2">           <span class="ot">{</span>V <span class="ot">:</span> Key <span class="ot">→</span> <span class="dt">Set</span> v<span class="ot">}</span></a>
<a class="sourceLine" id="cb31-3" data-line-number="3">           <span class="ot">(</span>k <span class="ot">:</span> Key<span class="ot">)</span></a>
<a class="sourceLine" id="cb31-4" data-line-number="4">       <span class="ot">→</span> V k</a>
<a class="sourceLine" id="cb31-5" data-line-number="5">       <span class="ot">→</span> <span class="ot">(</span>V k <span class="ot">→</span> V k <span class="ot">→</span> V k<span class="ot">)</span></a>
<a class="sourceLine" id="cb31-6" data-line-number="6">       <span class="ot">→</span> Tree V l u h</a>
<a class="sourceLine" id="cb31-7" data-line-number="7">       <span class="ot">→</span> l &lt; k &lt; u</a>
<a class="sourceLine" id="cb31-8" data-line-number="8">       <span class="ot">→</span> Inserted V l u h</a>
<a class="sourceLine" id="cb31-9" data-line-number="9">insert v vc f <span class="ot">(</span>leaf l&lt;u<span class="ot">)</span> <span class="ot">(</span>l , u<span class="ot">)</span> <span class="ot">=</span></a>
<a class="sourceLine" id="cb31-10" data-line-number="10">  1+ <span class="ot">(</span>node v vc ▽ <span class="ot">(</span>leaf l<span class="ot">)</span> <span class="ot">(</span>leaf u<span class="ot">))</span></a>
<a class="sourceLine" id="cb31-11" data-line-number="11">insert v vc f <span class="ot">(</span>node k kc bl tl tr<span class="ot">)</span> prf</a>
<a class="sourceLine" id="cb31-12" data-line-number="12">  <span class="kw">with</span> compare v k</a>
<a class="sourceLine" id="cb31-13" data-line-number="13">insert v vc f <span class="ot">(</span>node k kc bl tl tr<span class="ot">)</span> <span class="ot">(</span>l , <span class="ot">_)</span></a>
<a class="sourceLine" id="cb31-14" data-line-number="14">    <span class="ot">|</span> tri&lt; a <span class="ot">_</span> <span class="ot">_</span> <span class="kw">with</span> insert v vc f tl <span class="ot">(</span>l , a<span class="ot">)</span></a>
<a class="sourceLine" id="cb31-15" data-line-number="15"><span class="ot">...</span> <span class="ot">|</span> 0+ tl′ <span class="ot">=</span> 0+ <span class="ot">(</span>node k kc bl tl′ tr<span class="ot">)</span></a>
<a class="sourceLine" id="cb31-16" data-line-number="16"><span class="ot">...</span> <span class="ot">|</span> 1+ tl′ <span class="kw">with</span> bl</a>
<a class="sourceLine" id="cb31-17" data-line-number="17"><span class="ot">...</span> <span class="ot">|</span> ◿ <span class="ot">=</span> rotʳ k kc tl′ tr</a>
<a class="sourceLine" id="cb31-18" data-line-number="18"><span class="ot">...</span> <span class="ot">|</span> ▽ <span class="ot">=</span> 1+ <span class="ot">(</span>node k kc  ◿  tl′ tr<span class="ot">)</span></a>
<a class="sourceLine" id="cb31-19" data-line-number="19"><span class="ot">...</span> <span class="ot">|</span> ◺ <span class="ot">=</span> 0+ <span class="ot">(</span>node k kc  ▽  tl′ tr<span class="ot">)</span></a>
<a class="sourceLine" id="cb31-20" data-line-number="20">insert v vc f <span class="ot">(</span>node k kc bl tl tr<span class="ot">)</span> <span class="ot">_</span></a>
<a class="sourceLine" id="cb31-21" data-line-number="21">    <span class="ot">|</span> tri≈ <span class="ot">_</span> refl <span class="ot">_</span> <span class="ot">=</span></a>
<a class="sourceLine" id="cb31-22" data-line-number="22">        0+ <span class="ot">(</span>node k <span class="ot">(</span>f vc kc<span class="ot">)</span> bl tl tr<span class="ot">)</span></a>
<a class="sourceLine" id="cb31-23" data-line-number="23">insert v vc f <span class="ot">(</span>node k kc bl tl tr<span class="ot">)</span> <span class="ot">(_</span> , u<span class="ot">)</span></a>
<a class="sourceLine" id="cb31-24" data-line-number="24">    <span class="ot">|</span> tri&gt; <span class="ot">_</span> <span class="ot">_</span> c <span class="kw">with</span> insert v vc f tr <span class="ot">(</span>c , u<span class="ot">)</span></a>
<a class="sourceLine" id="cb31-25" data-line-number="25"><span class="ot">...</span> <span class="ot">|</span> 0+ tr′ <span class="ot">=</span> 0+ <span class="ot">(</span>node k kc bl tl tr′<span class="ot">)</span></a>
<a class="sourceLine" id="cb31-26" data-line-number="26"><span class="ot">...</span> <span class="ot">|</span> 1+ tr′ <span class="kw">with</span> bl</a>
<a class="sourceLine" id="cb31-27" data-line-number="27"><span class="ot">...</span> <span class="ot">|</span> ◿ <span class="ot">=</span> 0+ <span class="ot">(</span>node k kc ▽ tl tr′<span class="ot">)</span></a>
<a class="sourceLine" id="cb31-28" data-line-number="28"><span class="ot">...</span> <span class="ot">|</span> ▽ <span class="ot">=</span> 1+ <span class="ot">(</span>node k kc ◺ tl tr′<span class="ot">)</span></a>
<a class="sourceLine" id="cb31-29" data-line-number="29"><span class="ot">...</span> <span class="ot">|</span> ◺ <span class="ot">=</span> rotˡ k kc tl tr′</a></code></pre></div>
</div>
</div>
<h1 id="conclusion">Conclusion</h1>
<p>Overall, I’ve been enjoying programming in Agda. The things I liked and didn’t like surprised me:</p>
<dl>
<dt>Editor Support</dt>
<dd><p>Is excellent. I use <a href="http://spacemacs.org">spacemacs</a>, and the whole thing worked pretty seamlessly. Proof search and auto was maybe not as powerful as Idris’, although that might be down to lack of experience (note—as I write this, I see you can enable case-splitting in proof search, so it looks like I was right about my lack of experience). In many ways, it was much better than Haskell’s editor support: personally, I have never managed to get case-splitting to work in my Haskell setup, never mind some of the fancier features that you get in Agda.</p>
<p>It’s worth noting that my experience with Idris is similar: maybe it’s something about dependent types?</p>
<p>Of course, I missed lots of extra tools, like linters, code formatters, etc., but the tight integration with the compiler was so useful it more than made up for it.</p>
<p>Also, I’d implore anyone who’s had trouble with emacs before to give <a href="http://spacemacs.org">spacemacs</a> a go. It works well out-of-the-box, and has a system for keybinding discovery that <em>actually works</em>.</p>
</dd>
<dt>Documentation</dt>
<dd><p>Pretty good, considering. There are some missing parts (<a href="https://agda.readthedocs.io/en/v2.5.4.1/language/rewriting.html">rewriting</a> and <a href="https://agda.readthedocs.io/en/v2.5.4.1/language/telescopes.html">telescopes</a> are both stubs on the documentation site), but there seemed to be more fully worked-out examples available online for different concepts when I needed to figure them out.</p>
</dd>
</dl>
<p>Now, the thing about a lot of these complaints/commendations (<em>especially</em> with regards to tooling and personal setups) is that people tend to be pretty bad about evaluating how difficult finicky tasks like editor setups are. Once you’ve gotten the hang of some of this stuff, you forget that you ever didn’t. Agda is the second dependently-typed language I’ve really gone for a deepish dive on, and I’ve been using spacemacs for a while, so YMMV.</p>
<p>One area of the language itself that I would have liked to see more on was irrelevance. Looking back at the definition of the tree type, in the Haskell version there’s no singleton storing the height (the balance type stores all the information we need), which means that it definitely doesn’t exist at runtime. As I understand it, that implies that the type should be irrelevant in the equivalent Agda. However, when I actually mark it as irrelevant, everything works fine, except that missing cases warnings start showing up. I couldn’t figure out why: Haskell was able to infer full case coverage without the index, after all. Equality proof erasure, also: is it safe? Consistent?</p>
<p>All in all, I’d encourage more Haskellers to give Agda a try. It’s fun, interesting, and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="script"><mi>𝒰</mi><mi>𝓃</mi><mi>𝒾</mi><mi>𝒸</mi><mi>ℴ</mi><mi>𝒹</mi><mi>ℯ</mi></mstyle><annotation encoding="application/x-tex">\mathcal{Unicode}</annotation></semantics></math>!</p>
<h1 id="further-reading">Further Reading</h1>
<p>No “deletion is left as an exercise to the reader” here, no sir! Fuller implementations of both the Haskell and Agda versions of the code here are available: first, a pdf of the Agda code with lovely colours is <a href="../pdfs/AVL.pdf">here</a>. The accompanying repository is <a href="https://github.com/oisdk/agda-avl">here</a>, and the equivalent for the Haskell code is <a href="https://github.com/oisdk/verified-avl">here</a>. Of course, if you would rather read something by someone who knows what they’re talking about, please see the</p>
<h1 id="references" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-danielsson_agda_2018">
<p>Danielsson, Nils Anders. 2018. “The Agda standard library.” <a href="https://agda.github.io/agda-stdlib/README.html" class="uri">https://agda.github.io/agda-stdlib/README.html</a>.</p>
</div>
<div id="ref-mcbride_how_2014">
<p>McBride, Conor Thomas. 2014. “How to Keep Your Neighbours in Order.” In <em>Proceedings of the 19th ACM SIGPLAN International Conference on Functional Programming</em>, 297–309. ICFP ’14. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/2628136.2628163">10.1145/2628136.2628163</a>. <a href="https://personal.cis.strath.ac.uk/conor.mcbride/pub/Pivotal.pdf" class="uri">https://personal.cis.strath.ac.uk/conor.mcbride/pub/Pivotal.pdf</a>.</p>
</div>
<div id="ref-pfaff_performance_2004">
<p>Pfaff, Ben. 2004. “Performance Analysis of BSTs in System Software.” In <em>Proceedings of the Joint International Conference on Measurement and Modeling of Computer Systems</em>, 410–411. SIGMETRICS ’04/performance ’04. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/1005686.1005742">10.1145/1005686.1005742</a>. <a href="https://benpfaff.org/papers/libavl.pdf" class="uri">https://benpfaff.org/papers/libavl.pdf</a>.</p>
</div>
<div id="ref-weirich_depending_2014">
<p>Weirich, Stephanie. 2014. “Depending on Types.” In <em>Proceedings of the 19th ACM SIGPLAN International Conference on Functional Programming</em>, 241–241. ICFP ’14. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/2628136.2631168">10.1145/2628136.2631168</a>. <a href="https://www.cis.upenn.edu/~sweirich/talks/icfp14.pdf" class="uri">https://www.cis.upenn.edu/~sweirich/talks/icfp14.pdf</a>.</p>
</div>
</div>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>My phrasing is maybe a little confusing here. When <code class="sourceCode haskell"><span class="dt">Set</span></code> “has the type” <code class="sourceCode agda"><span class="dt">Set₁</span></code> it means that <code class="sourceCode haskell"><span class="dt">Set</span></code> is <em>in</em> <code class="sourceCode agda"><span class="dt">Set₁</span></code>, not the other way around.<a href="#fnref1" class="footnote-back">↩</a></p></li>
</ol>
</section>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
