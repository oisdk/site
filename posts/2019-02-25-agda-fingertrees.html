<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Finger Trees in Agda - Donnacha OisÃ­n Kidney</title>
        <style>body{color:black;font-family:Garamond,Times New Roman,serif;font-size:14px;margin:0px auto 0px auto;padding-left:5px;padding-right:5px;max-width:600px}math{font-size:13px}img{max-width:600px}summary{outline:0}div#header{border-bottom:3px double black;margin-bottom:30px;padding:12px 0px 12px 0px}div#logo a{color:black;float:left;font-size:20px;text-decoration:none}div#header #navigation{text-align:right}div#header #navigation a{color:black;font-family:Garamond,Times New Roman,Serif;font-size:18px;margin-left:10px;text-decoration:none;text-transform:uppercase}div#footer{font-family:Garamond,Times New Roman,Serif;border-top:solid 2px black;color:#555;font-size:12px;margin-top:30px;padding:12px 0px 12px 0px;text-align:right}h1{font-family:Garamond,Times New Roman,Serif;font-size:22px;font-weight:normal}h2{font-family:Garamond,Times New Roman,Serif;font-size:20px;font-weight:normal}div.info{color:#555;font-size:15px;font-style:italic}span.quiet{color:#828282;font-style:italic}a{color:black;word-wrap:break-word}ul.post-list{margin-left:0px;padding-left:0px;list-style-type:none}.hidden_source{display:none}ol.serieslist{counter-reset:item;list-style-type:none;padding-left:20}ol li.serieslist:before{content:'Part ' counter(item,decimal) ':';counter-increment:item}table.sourceCode,tr.sourceCode,td.lineNumbers,td.sourceCode,table.sourceCode pre{margin:0;padding:0;border:0;vertical-align:baseline;border:none}td.lineNumbers{border-right:1px solid #AAAAAA;text-align:right;color:#AAAAAA;padding-right:5px;padding-left:5px}td.sourceCode{padding-left:5px}.sourceCode,code,pre,.Agda{font-size:11px;font-family:menlo,monospace}.sourceCode span.kw{color:#262C6A}.sourceCode span.dt{color:#476A97}.sourceCode span.dv{color:#262C6A}.sourceCode span.bn{color:#262C6A}.sourceCode span.fl{color:#262C6A}.sourceCode span.ch{color:#262C6A}.sourceCode span.st{color:#702C51}.sourceCode span.co{color:#435138}.sourceCode span.ot{color:#262C6A}.sourceCode span.al{color:red}.sourceCode span.fu{color:#000000}.sourceCode span.re{color:#000000}.sourceCode span.er{color:red}li{margin-bottom:2px}li:last-child{margin-bottom:0px}.Agda .Comment{color:#B22222}.Agda .Background{}.Agda .Markup{color:#000000}.Agda .Keyword{color:#CD6600}.Agda .String{color:#B22222}.Agda .Number{color:#A020F0}.Agda .Symbol{color:#404040}.Agda .PrimitiveType{color:#0000CD}.Agda .Pragma{color:black}.Agda .Operator{}.Agda .Bound{color:black}.Agda .Generalizable{color:black}.Agda .InductiveConstructor{color:#008B00}.Agda .CoinductiveConstructor{color:#8B7500}.Agda .Datatype{color:#0000CD}.Agda .Field{color:#EE1289}.Agda .Function{color:#0000CD}.Agda .Module{color:#A020F0}.Agda .Postulate{color:#0000CD}.Agda .Primitive{color:#0000CD}.Agda .Record{color:#0000CD}.Agda .DottedPattern{}.Agda .UnsolvedMeta{color:black;background:yellow}.Agda .UnsolvedConstraint{color:black;background:yellow}.Agda .TerminationProblem{color:black;background:#FFA07A}.Agda .IncompletePattern{color:black;background:#F5DEB3}.Agda .Error{color:red;text-decoration:underline}.Agda .TypeChecks{color:black;background:#ADD8E6}.Agda a{text-decoration:none}.Agda a[href]:hover{background-color:#B4EEB4}.sourceCode{overflow-x:auto}</style>
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Donnacha OisÃ­n Kidney</a>
            </div>
            <div id="navigation">
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../rss.xml">Feed</a>
            </div>
        </div>

        <div id="content">
            <h2>Finger Trees in Agda</h2>

            <div class="info">
    Posted on February 25, 2019
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a title="All pages tagged 'Agda'." href="../tags/Agda.html">Agda</a>
    
</div>

<hr />
<h2 id="this-post-is-available-with-clickable-code-here"><a href="https://oisdk.github.io/agda-indexed-fingertree/Data.FingerTree.html">This Post is Available With Clickable Code Here</a></h2>
<p>This whole post is written with clickable identifiers and ascii art at the above link. I also provide the normal version below in case there are any problems rendering.</p>
<hr />
<p>As I have talked about <a href="../posts/2019-01-15-binomial-urn.html">previously</a>, a large class of divide-and conquer algorithms rely on â€œgoodâ€ partitioning for the divide step. If you then want to make the algorithms incremental, you keep all of those partitions (with their summaries) in some â€œgoodâ€ arrangement <span class="citation" data-cites="mu_queueing_2016">(Mu, Chiang, and Lyu <a href="#ref-mu_queueing_2016" role="doc-biblioref">2016</a>)</span>. Several common data structures are designed around this principle: binomial heaps, for instance, store partitions of size <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mi>n</mi></msup><annotation encoding="application/x-tex">2^n</annotation></semantics></math>. Different ways of storing partitions favours different use cases: switch from a binomial heap to a skew binomial, for instance, and you get constant-time <code>cons</code>.</p>
<p>The standout data structure in this area is Hinze and Patersonâ€™s finger tree <span class="citation" data-cites="Hinze-Paterson:FingerTree">(Hinze and Paterson <a href="#ref-Hinze-Paterson:FingerTree" role="doc-biblioref">2006</a>)</span>. It caches summaries in a pretty amazing way, allowing for (amortised) <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math> <code>cons</code> and <code>snoc</code> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math> <code>split</code> and <code>append</code>. These features allow it to be used for a huge variety of things: <a href="http://hackage.haskell.org/package/containers-0.6.0.1/docs/Data-Sequence.html">Data.Sequence</a> uses it as a random-access sequence, but it can also work as a priority queue, a search tree, a priority search tree <span class="citation" data-cites="hinze_simple_2001">(Hinze <a href="#ref-hinze_simple_2001" role="doc-biblioref">2001</a>)</span>, an interval tree, an order statistic treeâ€¦</p>
<p>All of these applications solely rely on an underlying monoid. As a result, I thought it would be a great data structure to implement in Agda, so that youâ€™d get all of the other data structures with minimal effort <span class="citation" data-cites="sozeau_program-ing_2007">(similar thinking motivated a Coq implementation; Sozeau <a href="#ref-sozeau_program-ing_2007" role="doc-biblioref">2007</a>)</span>.</p>
<h1 id="scope-of-the-verification">Scope of the Verification</h1>
<p>There would be no real point to implementing a finger tree in Agda if we didnâ€™t also prove some things about it. The scope of the proofs Iâ€™ve done so far are intrinsic proofs of the summaries in the tree. In other words, the type of <code>cons</code> is as follows:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a>cons <span class="ot">:</span> <span class="ot">âˆ€</span> x <span class="ot">{</span>xs<span class="ot">}</span> <span class="ot">â†’</span> Tree xs <span class="ot">â†’</span> Tree <span class="ot">(</span>Î¼ x âˆ™ xs<span class="ot">)</span></span></code></pre></div>
<p>This is enough to prove things about the derived data structures (like the correctness of sorting if itâ€™s used as a priority queue), but itâ€™s worth pointing out what I <em>havenâ€™t</em> proved (yet):</p>
<ol>
<li>Invariants on the structure (â€œsafeâ€ and â€œunsafeâ€ digits and so on).</li>
<li>The time complexity or performance of any operations.</li>
</ol>
<p>To be honest, Iâ€™m not even sure that my current implementation is correct in these regards! Iâ€™ll probably have a go at proving them in the future <span class="citation" data-cites="danielsson_lightweight_2008">(possibly using Danielsson <a href="#ref-danielsson_lightweight_2008" role="doc-biblioref">2008</a>)</span>.</p>
<h1 id="monoids-and-proofs">Monoids and Proofs</h1>
<p>The bad news is that finger trees are a relatively complex data structure, and weâ€™re going to need a <em>lot</em> of proofs to write a verified version. The good news is that monoids (in contrast to rings) are extremely easy to prove automatically. In this project, I used reflection to do so, but I think it should be possible to do with instance resolution also.</p>
<h1 id="measures">Measures</h1>
<p>First things first, we need a way to talk about the summaries of elements weâ€™re interested in. This is captured by the following record type:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">record</span> Ïƒ <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">(</span>Î£ <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">(</span>a âŠ” r<span class="ot">)</span> <span class="kw">where</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>  <span class="kw">field</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>    Î¼ <span class="ot">:</span> Î£ <span class="ot">â†’</span> ğ“¡</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>    </span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a><span class="kw">open</span> Ïƒ â¦ƒ <span class="ot">...</span> â¦„</span></code></pre></div>
<p><code>ğ“¡</code> is the type of the summaries, and <code>Î¼</code> means â€œsummariseâ€. The silly symbols are used for brevity: weâ€™re going to be using this thing everywhere, so itâ€™s important to keep it short. Hereâ€™s an example instance for lists:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">instance</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>  Ïƒ-List <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">{</span>Î£ <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">â†’</span> â¦ƒ <span class="ot">_</span> <span class="ot">:</span> Ïƒ Î£ â¦„ <span class="ot">â†’</span> Ïƒ <span class="ot">(</span>List Î£<span class="ot">)</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>  Î¼ â¦ƒ Ïƒ-List â¦„ <span class="ot">=</span> List<span class="ot">.</span>foldr <span class="ot">(_</span>âˆ™<span class="ot">_</span> âˆ˜ Î¼<span class="ot">)</span> Îµ</span></code></pre></div>
<h1 id="working-with-setoids">Working With Setoids</h1>
<p>As I mentioned, the tree is going to be verified intrinsically. In other word its type will look something like this:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a>Tree <span class="ot">:</span> ğ“¡ <span class="ot">â†’</span> <span class="dt">Set</span></span></code></pre></div>
<p>But before running off to define that the obvious way, I should mention that I made the annoying decision to use a setoid (rather than propositional equality) based monoid. This means that we donâ€™t get substitution, making the obvious definition untenable.</p>
<p>I figured out a solution to the problem, but Iâ€™m not sure if Iâ€™m happy with it. Thatâ€™s actually the main motivation for writing this post: Iâ€™m curious if other people have better techniques for this kind of thing.</p>
<p>To clarify: â€œthis kind of thingâ€ is writing intrinsic (correct-by-construction) proofs when a setoid is involved. Intrinsic proofs usually lend themselves to elegance: to prove that <code>map</code> preserves a vectorâ€™s length, for instance, basically requires no proof at all:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a>map <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>a b n<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">{</span>B <span class="ot">:</span> <span class="dt">Set</span> b<span class="ot">}</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>    <span class="ot">â†’</span> <span class="ot">(</span>A <span class="ot">â†’</span> B<span class="ot">)</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>    <span class="ot">â†’</span> Vec A n</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>    <span class="ot">â†’</span> Vec B n</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>map f [] <span class="ot">=</span> []</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>map f <span class="ot">(</span>x âˆ· xs<span class="ot">)</span> <span class="ot">=</span> f x âˆ· map f xs</span></code></pre></div>
<p>But thatâ€™s because pattern matching works well with propositional equality: in the first clause, <code>n</code> is set to <code>0</code> automatically. If we were working with setoid equality, weâ€™d instead maybe get a proof that <code>n â‰ˆ 0</code>, and weâ€™d have to figure a way to work that into the types.</p>
<h1 id="fibres">Fibres</h1>
<p>The first part of the solution is to define a wrapper type which stores information about the size of the thing it contains:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="kw">record</span> Î¼âŸ¨<span class="ot">_</span>âŸ©â‰ˆ<span class="ot">_</span> <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">(</span>Î£ <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">)</span> â¦ƒ <span class="ot">_</span> <span class="ot">:</span> Ïƒ Î£ â¦„ <span class="ot">(</span>ğ“‚ <span class="ot">:</span> ğ“¡<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">(</span>a âŠ” r âŠ” m<span class="ot">)</span> <span class="kw">where</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>  <span class="kw">constructor</span> <span class="ot">_</span>â‡‘[<span class="ot">_</span>]</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>  <span class="kw">field</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>    ğ“¢ <span class="ot">:</span> Î£</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>    ğ’» <span class="ot">:</span> Î¼ ğ“¢ â‰ˆ ğ“‚</span></code></pre></div>
<p>Technically speaking, I think this is known as a â€œfibreâ€. <code>Î¼âŸ¨ Î£ âŸ©â‰ˆ ğ“‚</code> means â€œThere exists a <code>Î£</code> such that <code>Î¼ Î£ â‰ˆ ğ“‚</code>â€. Next, weâ€™ll need some combinators to work with:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="kw">infixl</span> <span class="dv">2</span> <span class="ot">_</span>â‰ˆ[<span class="ot">_</span>]</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a><span class="ot">_</span>â‰ˆ[<span class="ot">_</span>] <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">{</span>Î£ <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> â¦ƒ <span class="ot">_</span> <span class="ot">:</span> Ïƒ Î£ â¦„ <span class="ot">{</span>x <span class="ot">:</span> ğ“¡<span class="ot">}</span> <span class="ot">â†’</span> Î¼âŸ¨ Î£ âŸ©â‰ˆ x <span class="ot">â†’</span> <span class="ot">âˆ€</span> <span class="ot">{</span>y<span class="ot">}</span> <span class="ot">â†’</span> x â‰ˆ y <span class="ot">â†’</span> Î¼âŸ¨ Î£ âŸ©â‰ˆ y</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>ğ“¢ <span class="ot">(</span>xs â‰ˆ[ yâ‰ˆz ]<span class="ot">)</span> <span class="ot">=</span> ğ“¢ xs</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>ğ’» <span class="ot">(</span>xs â‰ˆ[ yâ‰ˆz ]<span class="ot">)</span> <span class="ot">=</span> trans <span class="ot">(</span>ğ’» xs<span class="ot">)</span> yâ‰ˆz</span></code></pre></div>
<p>This makes it possible to â€œrewriteâ€ the summary, given a proof of equivalence.</p>
<h1 id="do-notation">Do Notation</h1>
<p>The wrapper on its own isnâ€™t enough to save us from hundreds of lines of proofs. Once you do computation on its contents, you still need to join it up with its original proof of equivalence. In other words, youâ€™ll need to drill into the return type of a function, find the place you used the relevant type variable, and apply the relevant proof from the type above. This can really clutter proofs. Instead, we can use Agdaâ€™s new support for do notation to try and get a cleaner notation for everything. Hereâ€™s a big block of code:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="kw">infixl</span> <span class="dv">2</span> arg-syntax</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a><span class="kw">record</span> Arg <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">(</span>Î£ <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">)</span> â¦ƒ <span class="ot">_</span> <span class="ot">:</span> Ïƒ Î£ â¦„ <span class="ot">(</span>ğ“‚ <span class="ot">:</span> ğ“¡<span class="ot">)</span> <span class="ot">(</span>f <span class="ot">:</span> ğ“¡ <span class="ot">â†’</span> ğ“¡<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">(</span>m âŠ” r âŠ” a<span class="ot">)</span> <span class="kw">where</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>  <span class="kw">constructor</span> arg-syntax</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>  <span class="kw">field</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>    âŸ¨fâŸ© <span class="ot">:</span> Congruentâ‚ f</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a>    arg <span class="ot">:</span> Î¼âŸ¨ Î£ âŸ©â‰ˆ ğ“‚</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a><span class="kw">open</span> Arg</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a><span class="kw">syntax</span> arg-syntax <span class="ot">(Î»</span> sz <span class="ot">â†’</span> eâ‚<span class="ot">)</span> xs <span class="ot">=</span> xs [ eâ‚ âŸ¿ sz ]</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true"></a></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true"></a><span class="kw">infixl</span> <span class="dv">1</span> <span class="ot">_</span>&gt;&gt;=<span class="ot">_</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true"></a><span class="ot">_</span>&gt;&gt;=<span class="ot">_</span> <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>a b<span class="ot">}</span> <span class="ot">{</span>Î£â‚ <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">{</span>Î£â‚‚ <span class="ot">:</span> <span class="dt">Set</span> b<span class="ot">}</span> â¦ƒ <span class="ot">_</span> <span class="ot">:</span> Ïƒ Î£â‚ â¦„ â¦ƒ <span class="ot">_</span> <span class="ot">:</span> Ïƒ Î£â‚‚ â¦„ <span class="ot">{</span>ğ“‚ f<span class="ot">}</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true"></a>      <span class="ot">â†’</span> Arg Î£â‚ ğ“‚ f</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true"></a>      <span class="ot">â†’</span> <span class="ot">((</span>x <span class="ot">:</span> Î£â‚<span class="ot">)</span> <span class="ot">â†’</span> â¦ƒ xâ‰ˆ <span class="ot">:</span> Î¼ x â‰ˆ ğ“‚ â¦„ <span class="ot">â†’</span> Î¼âŸ¨ Î£â‚‚ âŸ©â‰ˆ f <span class="ot">(</span>Î¼ x<span class="ot">))</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true"></a>      <span class="ot">â†’</span> Î¼âŸ¨ Î£â‚‚ âŸ©â‰ˆ f ğ“‚</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true"></a>arg-syntax cng xs &gt;&gt;= k <span class="ot">=</span> k <span class="ot">(</span>ğ“¢ xs<span class="ot">)</span> â¦ƒ ğ’» xs â¦„ â‰ˆ[ cng <span class="ot">(</span>ğ’» xs<span class="ot">)</span> ]</span></code></pre></div>
<p>First, we define a wrapper for types parameterised by their summary, with a way to lift an underlying equality up into some expression <code>f</code>. The <code>&gt;&gt;=</code> operator just connects up all of the relevant bits. An example is whatâ€™s needed:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a>listToTree <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">{</span>Î£ <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> â¦ƒ <span class="ot">_</span> <span class="ot">:</span> Ïƒ Î£ â¦„ <span class="ot">â†’</span> <span class="ot">(</span>xs <span class="ot">:</span> List Î£<span class="ot">)</span> <span class="ot">â†’</span> Î¼âŸ¨ Tree Î£ âŸ©â‰ˆ Î¼ xs</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>listToTree [] <span class="ot">=</span> empty â‡‘</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>listToTree <span class="ot">(</span>x âˆ· xs<span class="ot">)</span> <span class="ot">=</span> [ â„³ â†¯ ]â‰ˆ <span class="kw">do</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a>  ys â† listToTree xs [ Î¼ x âˆ™&gt; s âŸ¿ s ]</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a>  x â—‚ ys</span></code></pre></div>
<p>The first line is the base case, nothing interesting going on there. The second line begins the do-notation, but first applies <code>[ â„³ â†¯ ]â‰ˆ</code>: this calls the automated solver. The second line makes the recursive call, and with the syntax:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a>[ Î¼ x âˆ™&gt; s âŸ¿ s ]</span></code></pre></div>
<p>It tells us where the size of the bound variable will end up in the outer expression.</p>
<div id="refs" class="references hanging-indent" role="doc-bibliography">
<div id="ref-danielsson_lightweight_2008">
<p>Danielsson, Nils Anders. 2008. â€œLightweight Semiformal Time Complexity Analysis for Purely Functional Data Structures.â€ In <em>Proceedings of the 35th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</em>, 133â€“144. POPL â€™08. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/1328438.1328457">10.1145/1328438.1328457</a>.</p>
</div>
<div id="ref-hinze_simple_2001">
<p>Hinze, Ralf. 2001. â€œA Simple Implementation Technique for Priority Search Queues.â€ In <em>Proceedings of the 2001 International Conference on Functional Programming</em>, 110â€“121. ACM Press. doi:<a href="https://doi.org/10.1145/507635.507650">10.1145/507635.507650</a>.</p>
</div>
<div id="ref-Hinze-Paterson:FingerTree">
<p>Hinze, Ralf, and Ross Paterson. 2006. â€œFinger Trees: A Simple General-Purpose Data Structure.â€ <em>Journal of Functional Programming</em> 16 (2): 197â€“217.</p>
</div>
<div id="ref-mu_queueing_2016">
<p>Mu, Shin-Cheng, Yu-Hsi Chiang, and Yu-Han Lyu. 2016. â€œQueueing and Glueing for Optimal Partitioning (Functional Pearl).â€ In <em>Proceedings of the 21st ACM SIGPLAN International Conference on Functional Programming</em>, 158â€“167. ICFP 2016. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/2951913.2951923">10.1145/2951913.2951923</a>.</p>
</div>
<div id="ref-sozeau_program-ing_2007">
<p>Sozeau, Matthieu. 2007. â€œProgram-Ing Finger Trees in Coq.â€ In <em>Proceedings of the 12th ACM SIGPLAN International Conference on Functional Programming</em>, 13â€“24. ICFP â€™07. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/1291151.1291156">10.1145/1291151.1291156</a>.</p>
</div>
</div>

        </div>
    </body>
</html>
