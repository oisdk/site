<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Finger Trees in Agda - Donnacha Ois√≠n Kidney</title>
        <style>body{color:black;font-family:Garamond,Times New Roman,serif;font-size:14px;margin:0px auto 0px auto;padding-left:5px;padding-right:5px;max-width:600px}math{font-size:13px}img{max-width:600px}summary{outline:0}div#header{border-bottom:3px double black;margin-bottom:30px;padding:12px 0px 12px 0px}div#logo a{color:black;float:left;font-size:20px;text-decoration:none}div#header #navigation{text-align:right}div#header #navigation a{color:black;font-family:Garamond,Times New Roman,Serif;font-size:18px;margin-left:10px;text-decoration:none;text-transform:uppercase}div#footer{font-family:Garamond,Times New Roman,Serif;border-top:solid 2px black;color:#555;font-size:12px;margin-top:30px;padding:12px 0px 12px 0px;text-align:right}h1{font-family:Garamond,Times New Roman,Serif;font-size:22px;font-weight:normal}h2{font-family:Garamond,Times New Roman,Serif;font-size:20px;font-weight:normal}div.info{color:#555;font-size:15px;font-style:italic}span.quiet{color:#828282;font-style:italic}a{color:black;word-wrap:break-word}ul.post-list{margin-left:0px;padding-left:0px;list-style-type:none}.hidden_source{display:none}ol.serieslist{counter-reset:item;list-style-type:none;padding-left:20}ol li.serieslist:before{content:'Part ' counter(item,decimal) ':';counter-increment:item}table.sourceCode,tr.sourceCode,td.lineNumbers,td.sourceCode,table.sourceCode pre{margin:0;padding:0;border:0;vertical-align:baseline;border:none}td.lineNumbers{border-right:1px solid #AAAAAA;text-align:right;color:#AAAAAA;padding-right:5px;padding-left:5px}td.sourceCode{padding-left:5px}.sourceCode,code,pre,.Agda{font-size:11px;font-family:menlo,monospace}.sourceCode span.kw{color:#262C6A}.sourceCode span.dt{color:#476A97}.sourceCode span.dv{color:#262C6A}.sourceCode span.bn{color:#262C6A}.sourceCode span.fl{color:#262C6A}.sourceCode span.ch{color:#262C6A}.sourceCode span.st{color:#702C51}.sourceCode span.co{color:#435138}.sourceCode span.ot{color:#262C6A}.sourceCode span.al{color:red}.sourceCode span.fu{color:#000000}.sourceCode span.re{color:#000000}.sourceCode span.er{color:red}li{margin-bottom:2px}li:last-child{margin-bottom:0px}.Agda .Comment{color:#B22222}.Agda .Background{}.Agda .Markup{color:#000000}.Agda .Keyword{color:#CD6600}.Agda .String{color:#B22222}.Agda .Number{color:#A020F0}.Agda .Symbol{color:#404040}.Agda .PrimitiveType{color:#0000CD}.Agda .Pragma{color:black}.Agda .Operator{}.Agda .Bound{color:black}.Agda .Generalizable{color:black}.Agda .InductiveConstructor{color:#008B00}.Agda .CoinductiveConstructor{color:#8B7500}.Agda .Datatype{color:#0000CD}.Agda .Field{color:#EE1289}.Agda .Function{color:#0000CD}.Agda .Module{color:#A020F0}.Agda .Postulate{color:#0000CD}.Agda .Primitive{color:#0000CD}.Agda .Record{color:#0000CD}.Agda .DottedPattern{}.Agda .UnsolvedMeta{color:black;background:yellow}.Agda .UnsolvedConstraint{color:black;background:yellow}.Agda .TerminationProblem{color:black;background:#FFA07A}.Agda .IncompletePattern{color:black;background:#F5DEB3}.Agda .Error{color:red;text-decoration:underline}.Agda .TypeChecks{color:black;background:#ADD8E6}.Agda a{text-decoration:none}.Agda a[href]:hover{background-color:#B4EEB4}.sourceCode{overflow-x:auto}</style>
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Donnacha Ois√≠n Kidney</a>
            </div>
            <div id="navigation">
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../rss.xml">Feed</a>
            </div>
        </div>

        <div id="content">
            <h2>Finger Trees in Agda</h2>

            <div class="info">
    Posted on February 25, 2019
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a title="All pages tagged 'Agda'." href="../tags/Agda.html">Agda</a>
    
</div>

<hr />
<h2 id="this-post-is-available-with-clickable-code-here"><a href="https://oisdk.github.io/agda-indexed-fingertree/Data.FingerTree.html">This Post is Available With Clickable Code Here</a></h2>
<p>This whole post is written with clickable identifiers and ascii art at the above link. I also provide the normal version below in case there are any problems rendering.</p>
<hr />
<p>As I have talked about <a href="../posts/2019-01-15-binomial-urn.html">previously</a>, a large class of divide-and conquer algorithms rely on ‚Äúgood‚Äù partitioning for the divide step. If you then want to make the algorithms incremental, you keep all of those partitions (with their summaries) in some ‚Äúgood‚Äù arrangement <span class="citation" data-cites="mu_queueing_2016">(Mu, Chiang, and Lyu <a href="#ref-mu_queueing_2016" role="doc-biblioref">2016</a>)</span>. Several common data structures are designed around this principle: binomial heaps, for instance, store partitions of size <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mi>n</mi></msup><annotation encoding="application/x-tex">2^n</annotation></semantics></math>. Different ways of storing partitions favours different use cases: switch from a binomial heap to a skew binomial, for instance, and you get constant-time <code>cons</code>.</p>
<p>The standout data structure in this area is Hinze and Paterson‚Äôs finger tree <span class="citation" data-cites="Hinze-Paterson:FingerTree">(Hinze and Paterson <a href="#ref-Hinze-Paterson:FingerTree" role="doc-biblioref">2006</a>)</span>. It caches summaries in a pretty amazing way, allowing for (amortised) <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math> <code>cons</code> and <code>snoc</code> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math> <code>split</code> and <code>append</code>. These features allow it to be used for a huge variety of things: <a href="http://hackage.haskell.org/package/containers-0.6.0.1/docs/Data-Sequence.html">Data.Sequence</a> uses it as a random-access sequence, but it can also work as a priority queue, a search tree, a priority search tree <span class="citation" data-cites="hinze_simple_2001">(Hinze <a href="#ref-hinze_simple_2001" role="doc-biblioref">2001</a>)</span>, an interval tree, an order statistic tree‚Ä¶</p>
<p>All of these applications solely rely on an underlying monoid. As a result, I thought it would be a great data structure to implement in Agda, so that you‚Äôd get all of the other data structures with minimal effort <span class="citation" data-cites="sozeau_program-ing_2007">(similar thinking motivated a Coq implementation; Sozeau <a href="#ref-sozeau_program-ing_2007" role="doc-biblioref">2007</a>)</span>.</p>
<h1 id="scope-of-the-verification">Scope of the Verification</h1>
<p>There would be no real point to implementing a finger tree in Agda if we didn‚Äôt also prove some things about it. The scope of the proofs I‚Äôve done so far are intrinsic proofs of the summaries in the tree. In other words, the type of <code>cons</code> is as follows:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a>cons <span class="ot">:</span> <span class="ot">‚àÄ</span> x <span class="ot">{</span>xs<span class="ot">}</span> <span class="ot">‚Üí</span> Tree xs <span class="ot">‚Üí</span> Tree <span class="ot">(</span>Œº x ‚àô xs<span class="ot">)</span></span></code></pre></div>
<p>This is enough to prove things about the derived data structures (like the correctness of sorting if it‚Äôs used as a priority queue), but it‚Äôs worth pointing out what I <em>haven‚Äôt</em> proved (yet):</p>
<ol>
<li>Invariants on the structure (‚Äúsafe‚Äù and ‚Äúunsafe‚Äù digits and so on).</li>
<li>The time complexity or performance of any operations.</li>
</ol>
<p>To be honest, I‚Äôm not even sure that my current implementation is correct in these regards! I‚Äôll probably have a go at proving them in the future <span class="citation" data-cites="danielsson_lightweight_2008">(possibly using Danielsson <a href="#ref-danielsson_lightweight_2008" role="doc-biblioref">2008</a>)</span>.</p>
<h1 id="monoids-and-proofs">Monoids and Proofs</h1>
<p>The bad news is that finger trees are a relatively complex data structure, and we‚Äôre going to need a <em>lot</em> of proofs to write a verified version. The good news is that monoids (in contrast to rings) are extremely easy to prove automatically. In this project, I used reflection to do so, but I think it should be possible to do with instance resolution also.</p>
<h1 id="measures">Measures</h1>
<p>First things first, we need a way to talk about the summaries of elements we‚Äôre interested in. This is captured by the following record type:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">record</span> œÉ <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">(</span>Œ£ <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">(</span>a ‚äî r<span class="ot">)</span> <span class="kw">where</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>  <span class="kw">field</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>    Œº <span class="ot">:</span> Œ£ <span class="ot">‚Üí</span> ùì°</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>    </span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a><span class="kw">open</span> œÉ ‚¶É <span class="ot">...</span> ‚¶Ñ</span></code></pre></div>
<p><code>ùì°</code> is the type of the summaries, and <code>Œº</code> means ‚Äúsummarise‚Äù. The silly symbols are used for brevity: we‚Äôre going to be using this thing everywhere, so it‚Äôs important to keep it short. Here‚Äôs an example instance for lists:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">instance</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>  œÉ-List <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">{</span>Œ£ <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">‚Üí</span> ‚¶É <span class="ot">_</span> <span class="ot">:</span> œÉ Œ£ ‚¶Ñ <span class="ot">‚Üí</span> œÉ <span class="ot">(</span>List Œ£<span class="ot">)</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>  Œº ‚¶É œÉ-List ‚¶Ñ <span class="ot">=</span> List<span class="ot">.</span>foldr <span class="ot">(_</span>‚àô<span class="ot">_</span> ‚àò Œº<span class="ot">)</span> Œµ</span></code></pre></div>
<h1 id="working-with-setoids">Working With Setoids</h1>
<p>As I mentioned, the tree is going to be verified intrinsically. In other word its type will look something like this:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a>Tree <span class="ot">:</span> ùì° <span class="ot">‚Üí</span> <span class="dt">Set</span></span></code></pre></div>
<p>But before running off to define that the obvious way, I should mention that I made the annoying decision to use a setoid (rather than propositional equality) based monoid. This means that we don‚Äôt get substitution, making the obvious definition untenable.</p>
<p>I figured out a solution to the problem, but I‚Äôm not sure if I‚Äôm happy with it. That‚Äôs actually the main motivation for writing this post: I‚Äôm curious if other people have better techniques for this kind of thing.</p>
<p>To clarify: ‚Äúthis kind of thing‚Äù is writing intrinsic (correct-by-construction) proofs when a setoid is involved. Intrinsic proofs usually lend themselves to elegance: to prove that <code>map</code> preserves a vector‚Äôs length, for instance, basically requires no proof at all:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a>map <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>a b n<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">{</span>B <span class="ot">:</span> <span class="dt">Set</span> b<span class="ot">}</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>    <span class="ot">‚Üí</span> <span class="ot">(</span>A <span class="ot">‚Üí</span> B<span class="ot">)</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>    <span class="ot">‚Üí</span> Vec A n</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>    <span class="ot">‚Üí</span> Vec B n</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>map f [] <span class="ot">=</span> []</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>map f <span class="ot">(</span>x ‚à∑ xs<span class="ot">)</span> <span class="ot">=</span> f x ‚à∑ map f xs</span></code></pre></div>
<p>But that‚Äôs because pattern matching works well with propositional equality: in the first clause, <code>n</code> is set to <code>0</code> automatically. If we were working with setoid equality, we‚Äôd instead maybe get a proof that <code>n ‚âà 0</code>, and we‚Äôd have to figure a way to work that into the types.</p>
<h1 id="fibres">Fibres</h1>
<p>The first part of the solution is to define a wrapper type which stores information about the size of the thing it contains:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="kw">record</span> Œº‚ü®<span class="ot">_</span>‚ü©‚âà<span class="ot">_</span> <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">(</span>Œ£ <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">)</span> ‚¶É <span class="ot">_</span> <span class="ot">:</span> œÉ Œ£ ‚¶Ñ <span class="ot">(</span>ùìÇ <span class="ot">:</span> ùì°<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">(</span>a ‚äî r ‚äî m<span class="ot">)</span> <span class="kw">where</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>  <span class="kw">constructor</span> <span class="ot">_</span>‚áë[<span class="ot">_</span>]</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>  <span class="kw">field</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>    ùì¢ <span class="ot">:</span> Œ£</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>    ùíª <span class="ot">:</span> Œº ùì¢ ‚âà ùìÇ</span></code></pre></div>
<p>Technically speaking, I think this is known as a ‚Äúfibre‚Äù. <code>Œº‚ü® Œ£ ‚ü©‚âà ùìÇ</code> means ‚ÄúThere exists a <code>Œ£</code> such that <code>Œº Œ£ ‚âà ùìÇ</code>‚Äù. Next, we‚Äôll need some combinators to work with:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="kw">infixl</span> <span class="dv">2</span> <span class="ot">_</span>‚âà[<span class="ot">_</span>]</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a><span class="ot">_</span>‚âà[<span class="ot">_</span>] <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">{</span>Œ£ <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> ‚¶É <span class="ot">_</span> <span class="ot">:</span> œÉ Œ£ ‚¶Ñ <span class="ot">{</span>x <span class="ot">:</span> ùì°<span class="ot">}</span> <span class="ot">‚Üí</span> Œº‚ü® Œ£ ‚ü©‚âà x <span class="ot">‚Üí</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>y<span class="ot">}</span> <span class="ot">‚Üí</span> x ‚âà y <span class="ot">‚Üí</span> Œº‚ü® Œ£ ‚ü©‚âà y</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>ùì¢ <span class="ot">(</span>xs ‚âà[ y‚âàz ]<span class="ot">)</span> <span class="ot">=</span> ùì¢ xs</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>ùíª <span class="ot">(</span>xs ‚âà[ y‚âàz ]<span class="ot">)</span> <span class="ot">=</span> trans <span class="ot">(</span>ùíª xs<span class="ot">)</span> y‚âàz</span></code></pre></div>
<p>This makes it possible to ‚Äúrewrite‚Äù the summary, given a proof of equivalence.</p>
<h1 id="do-notation">Do Notation</h1>
<p>The wrapper on its own isn‚Äôt enough to save us from hundreds of lines of proofs. Once you do computation on its contents, you still need to join it up with its original proof of equivalence. In other words, you‚Äôll need to drill into the return type of a function, find the place you used the relevant type variable, and apply the relevant proof from the type above. This can really clutter proofs. Instead, we can use Agda‚Äôs new support for do notation to try and get a cleaner notation for everything. Here‚Äôs a big block of code:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="kw">infixl</span> <span class="dv">2</span> arg-syntax</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a><span class="kw">record</span> Arg <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">(</span>Œ£ <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">)</span> ‚¶É <span class="ot">_</span> <span class="ot">:</span> œÉ Œ£ ‚¶Ñ <span class="ot">(</span>ùìÇ <span class="ot">:</span> ùì°<span class="ot">)</span> <span class="ot">(</span>f <span class="ot">:</span> ùì° <span class="ot">‚Üí</span> ùì°<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">(</span>m ‚äî r ‚äî a<span class="ot">)</span> <span class="kw">where</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>  <span class="kw">constructor</span> arg-syntax</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>  <span class="kw">field</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>    ‚ü®f‚ü© <span class="ot">:</span> Congruent‚ÇÅ f</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a>    arg <span class="ot">:</span> Œº‚ü® Œ£ ‚ü©‚âà ùìÇ</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a><span class="kw">open</span> Arg</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a><span class="kw">syntax</span> arg-syntax <span class="ot">(Œª</span> sz <span class="ot">‚Üí</span> e‚ÇÅ<span class="ot">)</span> xs <span class="ot">=</span> xs [ e‚ÇÅ ‚üø sz ]</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true"></a></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true"></a><span class="kw">infixl</span> <span class="dv">1</span> <span class="ot">_</span>&gt;&gt;=<span class="ot">_</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true"></a><span class="ot">_</span>&gt;&gt;=<span class="ot">_</span> <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>a b<span class="ot">}</span> <span class="ot">{</span>Œ£‚ÇÅ <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">{</span>Œ£‚ÇÇ <span class="ot">:</span> <span class="dt">Set</span> b<span class="ot">}</span> ‚¶É <span class="ot">_</span> <span class="ot">:</span> œÉ Œ£‚ÇÅ ‚¶Ñ ‚¶É <span class="ot">_</span> <span class="ot">:</span> œÉ Œ£‚ÇÇ ‚¶Ñ <span class="ot">{</span>ùìÇ f<span class="ot">}</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true"></a>      <span class="ot">‚Üí</span> Arg Œ£‚ÇÅ ùìÇ f</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true"></a>      <span class="ot">‚Üí</span> <span class="ot">((</span>x <span class="ot">:</span> Œ£‚ÇÅ<span class="ot">)</span> <span class="ot">‚Üí</span> ‚¶É x‚âà <span class="ot">:</span> Œº x ‚âà ùìÇ ‚¶Ñ <span class="ot">‚Üí</span> Œº‚ü® Œ£‚ÇÇ ‚ü©‚âà f <span class="ot">(</span>Œº x<span class="ot">))</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true"></a>      <span class="ot">‚Üí</span> Œº‚ü® Œ£‚ÇÇ ‚ü©‚âà f ùìÇ</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true"></a>arg-syntax cng xs &gt;&gt;= k <span class="ot">=</span> k <span class="ot">(</span>ùì¢ xs<span class="ot">)</span> ‚¶É ùíª xs ‚¶Ñ ‚âà[ cng <span class="ot">(</span>ùíª xs<span class="ot">)</span> ]</span></code></pre></div>
<p>First, we define a wrapper for types parameterised by their summary, with a way to lift an underlying equality up into some expression <code>f</code>. The <code>&gt;&gt;=</code> operator just connects up all of the relevant bits. An example is what‚Äôs needed:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a>listToTree <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">{</span>Œ£ <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> ‚¶É <span class="ot">_</span> <span class="ot">:</span> œÉ Œ£ ‚¶Ñ <span class="ot">‚Üí</span> <span class="ot">(</span>xs <span class="ot">:</span> List Œ£<span class="ot">)</span> <span class="ot">‚Üí</span> Œº‚ü® Tree Œ£ ‚ü©‚âà Œº xs</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>listToTree [] <span class="ot">=</span> empty ‚áë</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>listToTree <span class="ot">(</span>x ‚à∑ xs<span class="ot">)</span> <span class="ot">=</span> [ ‚Ñ≥ ‚ÜØ ]‚âà <span class="kw">do</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a>  ys ‚Üê listToTree xs [ Œº x ‚àô&gt; s ‚üø s ]</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a>  x ‚óÇ ys</span></code></pre></div>
<p>The first line is the base case, nothing interesting going on there. The second line begins the do-notation, but first applies <code>[ ‚Ñ≥ ‚ÜØ ]‚âà</code>: this calls the automated solver. The second line makes the recursive call, and with the syntax:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a>[ Œº x ‚àô&gt; s ‚üø s ]</span></code></pre></div>
<p>It tells us where the size of the bound variable will end up in the outer expression.</p>
<div id="refs" class="references hanging-indent" role="doc-bibliography">
<div id="ref-danielsson_lightweight_2008">
<p>Danielsson, Nils Anders. 2008. ‚ÄúLightweight Semiformal Time Complexity Analysis for Purely Functional Data Structures.‚Äù In <em>Proceedings of the 35th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</em>, 133‚Äì144. POPL ‚Äô08. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/1328438.1328457">10.1145/1328438.1328457</a>.</p>
</div>
<div id="ref-hinze_simple_2001">
<p>Hinze, Ralf. 2001. ‚ÄúA Simple Implementation Technique for Priority Search Queues.‚Äù In <em>Proceedings of the 2001 International Conference on Functional Programming</em>, 110‚Äì121. ACM Press. doi:<a href="https://doi.org/10.1145/507635.507650">10.1145/507635.507650</a>.</p>
</div>
<div id="ref-Hinze-Paterson:FingerTree">
<p>Hinze, Ralf, and Ross Paterson. 2006. ‚ÄúFinger Trees: A Simple General-Purpose Data Structure.‚Äù <em>Journal of Functional Programming</em> 16 (2): 197‚Äì217.</p>
</div>
<div id="ref-mu_queueing_2016">
<p>Mu, Shin-Cheng, Yu-Hsi Chiang, and Yu-Han Lyu. 2016. ‚ÄúQueueing and Glueing for Optimal Partitioning (Functional Pearl).‚Äù In <em>Proceedings of the 21st ACM SIGPLAN International Conference on Functional Programming</em>, 158‚Äì167. ICFP 2016. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/2951913.2951923">10.1145/2951913.2951923</a>.</p>
</div>
<div id="ref-sozeau_program-ing_2007">
<p>Sozeau, Matthieu. 2007. ‚ÄúProgram-Ing Finger Trees in Coq.‚Äù In <em>Proceedings of the 12th ACM SIGPLAN International Conference on Functional Programming</em>, 13‚Äì24. ICFP ‚Äô07. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/1291151.1291156">10.1145/1291151.1291156</a>.</p>
</div>
</div>

        </div>
    </body>
</html>
