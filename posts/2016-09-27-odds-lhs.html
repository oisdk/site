<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>A Different Probability Monad - Donnacha Oisín Kidney</title>
        <style>body{color:black;font-family:Garamond,Times New Roman,serif;font-size:14px;margin:0px auto 0px auto;padding-left:5px;padding-right:5px;max-width:600px}math{font-size:13px}img{max-width:600px}summary{outline:0}div#header{border-bottom:3px double black;margin-bottom:30px;padding:12px 0px 12px 0px}div#logo a{color:black;float:left;font-size:20px;text-decoration:none}div#header #navigation{text-align:right}div#header #navigation a{color:black;font-family:Garamond,Times New Roman,Serif;font-size:18px;margin-left:10px;text-decoration:none;text-transform:uppercase}div#footer{font-family:Garamond,Times New Roman,Serif;border-top:solid 2px black;color:#555;font-size:12px;margin-top:30px;padding:12px 0px 12px 0px;text-align:right}h1{font-family:Garamond,Times New Roman,Serif;font-size:22px;font-weight:normal}h2{font-family:Garamond,Times New Roman,Serif;font-size:20px;font-weight:normal}div.info{color:#555;font-size:15px;font-style:italic}span.quiet{color:#828282;font-style:italic}a{color:black;word-wrap:break-word}ul.post-list{margin-left:0px;padding-left:0px;list-style-type:none}.hidden_source{display:none}ol.serieslist{counter-reset:item;list-style-type:none;padding-left:20}ol li.serieslist:before{content:'Part ' counter(item,decimal) ':';counter-increment:item}table.sourceCode,tr.sourceCode,td.lineNumbers,td.sourceCode,table.sourceCode pre{margin:0;padding:0;border:0;vertical-align:baseline;border:none}td.lineNumbers{border-right:1px solid #AAAAAA;text-align:right;color:#AAAAAA;padding-right:5px;padding-left:5px}td.sourceCode{padding-left:5px}.sourceCode,code,pre,.Agda{font-size:11px;font-family:menlo,monospace}.sourceCode span.kw{color:#262C6A}.sourceCode span.dt{color:#476A97}.sourceCode span.dv{color:#262C6A}.sourceCode span.bn{color:#262C6A}.sourceCode span.fl{color:#262C6A}.sourceCode span.ch{color:#262C6A}.sourceCode span.st{color:#702C51}.sourceCode span.co{color:#435138}.sourceCode span.ot{color:#262C6A}.sourceCode span.al{color:red}.sourceCode span.fu{color:#000000}.sourceCode span.re{color:#000000}.sourceCode span.er{color:red}li{margin-bottom:2px}li:last-child{margin-bottom:0px}.Agda .Comment{color:#B22222}.Agda .Background{}.Agda .Markup{color:#000000}.Agda .Keyword{color:#CD6600}.Agda .String{color:#B22222}.Agda .Number{color:#A020F0}.Agda .Symbol{color:#404040}.Agda .PrimitiveType{color:#0000CD}.Agda .Pragma{color:black}.Agda .Operator{}.Agda .Bound{color:black}.Agda .Generalizable{color:black}.Agda .InductiveConstructor{color:#008B00}.Agda .CoinductiveConstructor{color:#8B7500}.Agda .Datatype{color:#0000CD}.Agda .Field{color:#EE1289}.Agda .Function{color:#0000CD}.Agda .Module{color:#A020F0}.Agda .Postulate{color:#0000CD}.Agda .Primitive{color:#0000CD}.Agda .Record{color:#0000CD}.Agda .DottedPattern{}.Agda .UnsolvedMeta{color:black;background:yellow}.Agda .UnsolvedConstraint{color:black;background:yellow}.Agda .TerminationProblem{color:black;background:#FFA07A}.Agda .IncompletePattern{color:black;background:#F5DEB3}.Agda .Error{color:red;text-decoration:underline}.Agda .TypeChecks{color:black;background:#ADD8E6}.Agda a{text-decoration:none}.Agda a[href]:hover{background-color:#B4EEB4}.sourceCode{overflow-x:auto}</style>
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Donnacha Oisín Kidney</a>
            </div>
            <div id="navigation">
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../rss.xml">Feed</a>
            </div>
        </div>

        <div id="content">
            <h2>A Different Probability Monad</h2>

            <div class="info">
    Posted on September 27, 2016
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a title="All pages tagged 'Haskell'." href="../tags/Haskell.html">Haskell</a>, <a title="All pages tagged 'Probability'." href="../tags/Probability.html">Probability</a>
    
</div>

<p>One of the more unusual monads is the “probability monad”:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell literate hidden_source"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="ot">{-# language PatternSynonyms, ViewPatterns #-}</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="ot">{-# language DeriveFunctor, DeriveFoldable #-}</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="ot">{-# language BangPatterns #-}</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a><span class="kw">module</span> <span class="dt">Prob</span> <span class="kw">where</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Control.Arrow</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Data.Ratio</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Data.Foldable</span></span></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">Probability</span> a <span class="ot">=</span> <span class="dt">Probability</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>  {<span class="ot"> runProb ::</span> [(a,<span class="dt">Rational</span>)] }</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>  </span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Coin</span> <span class="ot">=</span> <span class="dt">Heads</span> <span class="op">|</span> <span class="dt">Tails</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a><span class="ot">toss ::</span> <span class="dt">Probability</span> <span class="dt">Coin</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>toss <span class="ot">=</span> <span class="dt">Probability</span> [(<span class="dt">Heads</span>, <span class="dv">1</span> <span class="op">%</span> <span class="dv">2</span>), (<span class="dt">Tails</span>, <span class="dv">1</span> <span class="op">%</span> <span class="dv">2</span>)]</span></code></pre></div>
<p>Although it’s a little inefficient, it’s an elegant representation. I’ve written about it before <a href="2015-08-03-monty-hall.html">here</a>.</p>
<p>It has some notable deficiencies, though. For instance: the user has to constantly check that all the probabilities add up to one. Its list can be empty, which doesn’t make sense. Also, individual outcomes can appear more than once in the same list.</p>
<p>A first go a fixing the problem might look something like this:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">Distrib</span> a <span class="ot">=</span> <span class="dt">Distrib</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>  {<span class="ot"> runDist ::</span> [(a,<span class="dt">Rational</span>)] }</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a><span class="ot">tossProb ::</span> <span class="dt">Distrib</span> <span class="dt">Coin</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>tossProb <span class="ot">=</span> <span class="dt">Distrib</span> [(<span class="dt">Heads</span>, <span class="dv">1</span>), (<span class="dt">Tails</span>, <span class="dv">1</span>)]</span></code></pre></div>
<p>The type is the same as before: it’s the semantics which have changed. The second field of the tuples no longer have to add up to one. The list can still be empty, though, and now finding the probability of, say, the head, looks like this:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="ot">probHead ::</span> <span class="dt">Distrib</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>probHead (<span class="dt">Distrib</span> xs<span class="op">@</span>((_,p)<span class="op">:</span>_)) <span class="ot">=</span> p <span class="op">/</span> <span class="fu">sum</span> [ q <span class="op">|</span> (_,q) <span class="ot">&lt;-</span> xs ]</span></code></pre></div>
<p>Infinite lists aren’t possible, either.</p>
<p>One other way to look at the problem is to mimic the structure of cons-lists. Something like this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Odds</span> a <span class="ot">=</span> <span class="dt">Certainly</span> a</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>            <span class="op">|</span> <span class="dt">Odds</span> a <span class="dt">Rational</span> (<span class="dt">Odds</span> a)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>            <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Functor</span>, <span class="dt">Foldable</span>, <span class="dt">Show</span>)</span></code></pre></div>
<p>Here, the <code class="sourceCode haskell"><span class="dt">Odds</span></code> constructor (analogous to <code class="sourceCode haskell">(<span class="op">:</span>)</code>) contains the betting-style odds of the head element vs. <em>the rest of the list</em>. The coin from before is represented by:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="ot">tossOdds ::</span> <span class="dt">Odds</span> <span class="dt">Coin</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>tossOdds <span class="ot">=</span> <span class="dt">Odds</span> <span class="dt">Heads</span> (<span class="dv">1</span> <span class="op">%</span> <span class="dv">1</span>) (<span class="dt">Certainly</span> <span class="dt">Tails</span>)</span></code></pre></div>
<p>This representation has tons of nice properties. First, let’s use some pattern-synonym magic for rationals:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="kw">pattern</span><span class="ot"> (:%) ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Rational</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a><span class="kw">pattern</span> n <span class="op">:%</span> d <span class="ot">&lt;-</span> (<span class="fu">numerator</span> <span class="op">&amp;&amp;&amp;</span> <span class="fu">denominator</span> <span class="ot">-&gt;</span> (n,d)) <span class="kw">where</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>  n <span class="op">:%</span> d <span class="ot">=</span> n <span class="op">%</span> d</span></code></pre></div>
<p>Then, finding the probability of the head element is this:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="ot">probHeadOdds ::</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>probHeadOdds (<span class="dt">Certainly</span> _) <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>probHeadOdds (<span class="dt">Odds</span> _ (n <span class="op">:%</span> d) _) <span class="ot">=</span> n <span class="op">:%</span> (n <span class="op">+</span> d)</span></code></pre></div>
<p>The representation can handle infinite lists no problem:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a>probHeadOdds (<span class="dt">Odds</span> <span class="ch">'a'</span> (<span class="dv">1</span> <span class="op">:%</span> <span class="dv">1</span>) <span class="fu">undefined</span>)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a><span class="dv">1</span> <span class="op">%</span> <span class="dv">2</span></span></code></pre></div>
<p>Taking the tail preserves semantics, also. To do some more involved manipulation, a fold helper is handy:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="ot">foldOdds ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Rational</span> <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> b</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>foldOdds f b <span class="ot">=</span> r <span class="kw">where</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a>  r (<span class="dt">Certainly</span> x) <span class="ot">=</span> b x</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a>  r (<span class="dt">Odds</span> x p xs) <span class="ot">=</span> f x p (r xs)</span></code></pre></div>
<p>You can use this function to find the probability of a given item:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="ot">probOfEvent ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a>probOfEvent e <span class="ot">=</span> foldOdds f b <span class="kw">where</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a>  b x <span class="ot">=</span> <span class="kw">if</span> e <span class="op">==</span> x <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a>  f x n r <span class="ot">=</span> (<span class="kw">if</span> e <span class="op">==</span> x <span class="kw">then</span> n <span class="kw">else</span> r) <span class="op">/</span> (n <span class="op">+</span> <span class="dv">1</span>)</span></code></pre></div>
<p>This assumes that each item only occurs once. A function which combines multiple events might look like this:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="ot">probOf ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a>probOf p <span class="ot">=</span> foldOdds f b <span class="kw">where</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a>  b x <span class="ot">=</span> <span class="kw">if</span> p x <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a>  f x n r <span class="ot">=</span> (<span class="kw">if</span> p x <span class="kw">then</span> r <span class="op">+</span> n <span class="kw">else</span> r) <span class="op">/</span> (n <span class="op">+</span> <span class="dv">1</span>)</span></code></pre></div>
<p>Some utility functions to create <code class="sourceCode haskell"><span class="dt">Odds</span></code>:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="ot">equalOdds ::</span> <span class="dt">Foldable</span> f <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Odds</span> a)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a>equalOdds xs <span class="ot">=</span> <span class="kw">case</span> <span class="fu">length</span> xs <span class="kw">of</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a>  <span class="dv">0</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a>  n <span class="ot">-&gt;</span> <span class="dt">Just</span> (<span class="fu">foldr</span> f <span class="fu">undefined</span> xs (n <span class="op">-</span> <span class="dv">1</span>)) <span class="kw">where</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a>    f y a <span class="dv">0</span> <span class="ot">=</span> <span class="dt">Certainly</span> y</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a>    f y a n <span class="ot">=</span> <span class="dt">Odds</span> y (<span class="dv">1</span> <span class="op">%</span> <span class="fu">fromIntegral</span> n) (a (n <span class="op">-</span> <span class="dv">1</span>))</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true"></a><span class="ot">fromDistrib ::</span> [(a,<span class="dt">Integer</span>)] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Odds</span> a)</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true"></a>fromDistrib [] <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true"></a>fromDistrib xs <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> f (tot<span class="op">*</span>lst) xs <span class="kw">where</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true"></a>  (tot,lst) <span class="ot">=</span> foldl' (\(<span class="op">!</span>t,_) e <span class="ot">-&gt;</span> (t<span class="op">+</span>e,e)) (<span class="dv">0</span>,<span class="fu">undefined</span>) (<span class="fu">map</span> <span class="fu">snd</span> xs)</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true"></a>  f _ [(x,_)] <span class="ot">=</span> <span class="dt">Certainly</span> x</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true"></a>  f n ((x,p)<span class="op">:</span>xs) <span class="ot">=</span> <span class="dt">Odds</span> x (mp <span class="op">%</span> np) (f np xs) <span class="kw">where</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true"></a>    mp <span class="ot">=</span> p <span class="op">*</span> lst</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true"></a>    np <span class="ot">=</span> n <span class="op">-</span> mp</span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true"></a>                  </span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true"></a><span class="ot">probOfEach ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true"></a>probOfEach x xs <span class="ot">=</span> probOf (x<span class="op">==</span>) xs</span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true"></a></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true"></a><span class="ot">propOf ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Rational</span></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true"></a>propOf _ [] <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true"></a>propOf x xs <span class="ot">=</span> <span class="dt">Just</span> <span class="op">.</span> <span class="fu">uncurry</span> (<span class="op">%</span>) <span class="op">$</span></span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true"></a>  foldl' (\(<span class="op">!</span>n,<span class="op">!</span>m) e <span class="ot">-&gt;</span> (<span class="kw">if</span> x <span class="op">==</span> e <span class="kw">then</span> n<span class="op">+</span><span class="dv">1</span> <span class="kw">else</span> n, m<span class="op">+</span><span class="dv">1</span>)) (<span class="dv">0</span>,<span class="dv">0</span>) xs</span></code></pre></div>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell literate prop"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a>propOf x xs <span class="op">==</span> <span class="fu">fmap</span> (probOfEach x) (equalOdds xs)</span></code></pre></div>
<p>And finally, the instances:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="ot">append ::</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span> <span class="ot">-&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Odds</span> a</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a>append <span class="ot">=</span> foldOdds f <span class="dt">Odds</span> <span class="kw">where</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a>  f e r a p ys <span class="ot">=</span> <span class="dt">Odds</span> e ip (a op ys) <span class="kw">where</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a>    ip <span class="ot">=</span> p <span class="op">*</span> r <span class="op">/</span> (p <span class="op">+</span> r <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true"></a>    op <span class="ot">=</span> p <span class="op">/</span> (r <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true"></a></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true"></a><span class="ot">flatten ::</span> <span class="dt">Odds</span> (<span class="dt">Odds</span> a) <span class="ot">-&gt;</span> <span class="dt">Odds</span> a</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true"></a>flatten <span class="ot">=</span> foldOdds append <span class="fu">id</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true"></a></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Odds</span> <span class="kw">where</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true"></a>  <span class="fu">pure</span> <span class="ot">=</span> <span class="dt">Certainly</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true"></a>  fs <span class="op">&lt;*&gt;</span> xs <span class="ot">=</span> flatten (<span class="fu">fmap</span> (<span class="op">&lt;$&gt;</span> xs) fs)</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true"></a>  </span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Odds</span> <span class="kw">where</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true"></a>  x <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> flatten (f <span class="op">&lt;$&gt;</span> x)</span></code></pre></div>

        </div>
    </body>
</html>
