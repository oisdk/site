<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Keeping Formal Verification in Bounds - Donnacha Oisín Kidney</title>
        <style>body{color:black;font-family:Garamond,Times New Roman,serif;font-size:14px;margin:0px auto 0px auto;padding-left:5px;padding-right:5px;max-width:600px}math{font-size:13px}img{max-width:600px}div#header{border-bottom:3px double black;margin-bottom:30px;padding:12px 0px 12px 0px}div#logo a{color:black;float:left;font-size:20px;text-decoration:none}div#header #navigation{text-align:right}div#header #navigation a{color:black;font-family:Garamond,Times New Roman,Serif;font-size:18px;margin-left:10px;text-decoration:none;text-transform:uppercase}div#footer{font-family:Garamond,Times New Roman,Serif;border-top:solid 2px black;color:#555;font-size:12px;margin-top:30px;padding:12px 0px 12px 0px;text-align:right}h1{font-family:Garamond,Times New Roman,Serif;font-size:22px;font-weight:normal}h2{font-family:Garamond,Times New Roman,Serif;font-size:20px;font-weight:normal}div.info{color:#555;font-size:15px;font-style:italic}span.quiet{color:#828282;font-style:italic}a{color:black;word-wrap:break-word}ul{margin-left:0px;padding-left:0px;list-style-type:none}.hidden_source{display:none}ol.serieslist{counter-reset:item;list-style-type:none;padding-left:20}ol li.serieslist:before{content:'Part ' counter(item,decimal) ':';counter-increment:item}table.sourceCode,tr.sourceCode,td.lineNumbers,td.sourceCode,table.sourceCode pre{margin:0;padding:0;border:0;vertical-align:baseline;border:none}td.lineNumbers{border-right:1px solid #AAAAAA;text-align:right;color:#AAAAAA;padding-right:5px;padding-left:5px}td.sourceCode{padding-left:5px}.sourceCode,code{font-size:10px;font-family:menlo,monospace}.sourceCode span.kw{color:#262C6A}.sourceCode span.dt{color:#476A97}.sourceCode span.dv{color:#262C6A}.sourceCode span.bn{color:#262C6A}.sourceCode span.fl{color:#262C6A}.sourceCode span.ch{color:#262C6A}.sourceCode span.st{color:#702C51}.sourceCode span.co{color:#435138}.sourceCode span.ot{color:#262C6A}.sourceCode span.al{color:red}.sourceCode span.fu{color:#000000}.sourceCode span.re{color:#000000}.sourceCode span.er{color:red}</style>
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Donnacha Oisín Kidney</a>
            </div>
            <div id="navigation">
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../rss.xml">Feed</a>
                <a href="../snippets.html">Snippets</a>
            </div>
        </div>

        <div id="content">
            <h2>Keeping Formal Verification in Bounds</h2>

            <div class="info">
    Posted on November 20, 2018
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="../tags/Haskell.html">Haskell</a>, <a href="../tags/Agda.html">Agda</a>
    
</div>

<p>One of the favorite pastimes of both Haskell and Agda programmers alike is verifying data structures. Among my favorite examples are Red-Black trees <span class="citation" data-cites="might_missing_2015 weirich_depending_2014">(Might <a href="#ref-might_missing_2015">2015</a>; Weirich <a href="#ref-weirich_depending_2014">2014</a>, verified for balance)</span>, perfect binary trees <span class="citation" data-cites="hinze_perfect_1999">(Hinze <a href="#ref-hinze_perfect_1999">1999</a>)</span>, square matrices <span class="citation" data-cites="okasaki_fast_1999">(Okasaki <a href="#ref-okasaki_fast_1999">1999</a><a href="#ref-okasaki_fast_1999">a</a>)</span>, search trees <span class="citation" data-cites="mcbride_how_2014">(McBride <a href="#ref-mcbride_how_2014">2014</a>, verified for balance and order)</span>, and binomial heaps <span class="citation" data-cites="hinze_numerical_1998">(Hinze <a href="#ref-hinze_numerical_1998">1998</a>, verified for structure)</span>.</p>
<p>There are many ways to verify data structures. One technique which has had recent massive success is to convert Haskell code to Coq, and then verify the Coq translation: this was the route taken by <span class="citation" data-cites="breitner_ready_2018-1">Breitner et al. (<a href="#ref-breitner_ready_2018-1">2018</a>)</span> to verify <code>Set</code> and <code>IntSet</code> in containers (a mammoth achievement, in my opinion).</p>
<p>This approach has some obvious advantages: you separate implementation from testing (which is usually a good idea), and your verification language can be different from your implementation language, with each tailored towards its particular domain.</p>
<p>LiquidHaskell <span class="citation" data-cites="bakst_liquidhaskell_2018">(Bakst et al. <a href="#ref-bakst_liquidhaskell_2018">2018</a>)</span> (and other tools like it) adds an extra type system to Haskell tailor-made for verification. The added type system (refinement types) is more automated (the typechecker uses Z3), more suited for “invariant”-like things (it supports subtyping), and has a bunch of domain-specific built-ins (reasoning about sets, equations, etc.). I’d encourage anyone who hasn’t used it to give it a try: especially if you’re experienced writing any kind of proof in a language like Agda or Idris, LiquidHaskell proofs are <em>shockingly</em> simple and easy.</p>
<p>What I’m going to focus on today, though, is writing <em>correct-by-construction</em> data structures, using Haskell and Agda’s own type systems. In particular, I’m going to look at how to write <em>fast</em> verification. In the other two approaches, we don’t really care about the “speed” of the proofs: sure, it’s nice to speed up compilation and so on, but we don’t have to worry about our implementation suffering at runtime because of some complex proof. When writing correct-by-construction code, though, our task is doubly hard: we now have to worry about the time complexity of both the implementation <em>and the proofs</em>.</p>
<p>In this post, I’m going to demonstrate some techniques to write proofs that stay within the complexity bounds of the algorithms they’re verifying (without cheating!). Along the way I’m going to verify some data structures I haven’t seen verified before (a skew-binary random-access list).</p>
<h1 id="technique-1-start-with-an-unverified-implementation-then-index">Technique 1: Start With an Unverified Implementation, then Index</h1>
<p>To demonstrate the first two techniques, we’re going to write a type for modular arithmetic. For a more tactile metaphor, think of the flip clock:</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/c/c3/Split-flap_display.jpg" /></p>
<p>Each digit can be incremented <span class="math inline">\(n\)</span> times, where <span class="math inline">\(n\)</span> is whatever base you’re using (12 for our flip-clock above). Once you hit the limit, it flips the next digit along. We’ll start with just one digit, and then just string them together to get our full type. That in mind, our “digit” type has two requirements:</p>
<ol>
<li>It should be incrementable.</li>
<li>Once it hits its limit, it should flip back to zero, and let us know that a flip was performed.</li>
</ol>
<p>Anyone who’s used a little Agda or Idris will be familiar with the <code>Fin</code> type:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> Fin <span class="ot">:</span> ℕ <span class="ot">→</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  zero <span class="ot">:</span> <span class="ot">{</span>n <span class="ot">:</span> ℕ<span class="ot">}</span> <span class="ot">→</span> Fin <span class="ot">(</span>suc n<span class="ot">)</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  suc  <span class="ot">:</span> <span class="ot">{</span>n <span class="ot">:</span> ℕ<span class="ot">}</span> <span class="ot">→</span> Fin n <span class="ot">→</span> Fin <span class="ot">(</span>suc n<span class="ot">)</span></a></code></pre></div>
<p><code>Fin n</code> is the standard way to encode “numbers smaller than <code>n</code>”. However, for digits they’re entirely unsuitable: since the limit parameter changes on successor, the kind of increment we want is <span class="math inline">\(\mathcal{O}(n)\)</span>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb2-1" data-line-number="1">try-suc <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">→</span> Fin n <span class="ot">→</span> Maybe <span class="ot">(</span>Fin n<span class="ot">)</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">try-suc <span class="ot">(</span>suc x<span class="ot">)</span> <span class="ot">=</span> Maybe<span class="ot">.</span>map suc <span class="ot">(</span>try-suc x<span class="ot">)</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">try-suc <span class="ot">{</span>suc n<span class="ot">}</span> zero <span class="kw">with</span> n</a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="ot">...</span> <span class="ot">|</span> zero <span class="ot">=</span> nothing</a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="ot">...</span> <span class="ot">|</span> suc <span class="ot">_</span> <span class="ot">=</span> just <span class="ot">(</span>suc zero<span class="ot">)</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6"></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">suc-flip <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">→</span> Fin n <span class="ot">→</span> Fin n × Bool</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">suc-flip <span class="ot">{</span>suc n<span class="ot">}</span> x <span class="ot">=</span> maybe <span class="ot">(_</span>, false<span class="ot">)</span> <span class="ot">(</span>zero , true<span class="ot">)</span> <span class="ot">(</span>try-suc x<span class="ot">)</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9">suc-flip <span class="ot">{</span>zero<span class="ot">}</span> <span class="ot">()</span></a></code></pre></div>
<p>If we keep going down this path with proofs in mind, we might next look at the various <span class="math inline">\(\leq\)</span> proofs in the Agda standard library (<a href="https://github.com/agda/agda-stdlib/blob/18b45b151f44cee2114fa4b3c1ad9ea532baf919/src/Data/Nat/Base.agda#L28">here</a>, <a href="https://github.com/agda/agda-stdlib/blob/18b45b151f44cee2114fa4b3c1ad9ea532baf919/src/Data/Nat/Base.agda#L117">here</a>, and <a href="https://github.com/agda/agda-stdlib/blob/18b45b151f44cee2114fa4b3c1ad9ea532baf919/src/Data/Nat/Base.agda#L133">here</a>), and see if we can we can wrangle them into doing what we want.</p>
<p>For me, though, this wasn’t a fruitful approach. Instead, we’ll try and think of how we’d do this without proving anything, and then see if there’s any place in the resulting data structure we can hang some proof.</p>
<p>So, in an unproven way, let’s start with some numbers. Since we’re going to be incrementing, they’d better be unary:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">data</span> ℕ <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  zero <span class="ot">:</span> ℕ</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">  suc <span class="ot">:</span> ℕ <span class="ot">→</span> ℕ</a></code></pre></div>
<p>And then, for the “flippable” type, we’ll just store the limit alongside the value:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">record</span> Flipper <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  <span class="kw">constructor</span> <span class="ot">_</span>&amp;<span class="ot">_</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  <span class="kw">field</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">    val <span class="ot">:</span> ℕ</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">    lim <span class="ot">:</span> ℕ</a></code></pre></div>
<p>We’re not there yet: to check if we’ve gone over the limit, we’ll still have to compare <code>val</code> and <code>lim</code>. Hopefully you can guess the optimization we’ll make: instead of storing the limit, we’ll store the space left:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">record</span> Flipper <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">  <span class="kw">constructor</span> <span class="ot">_</span>&amp;<span class="ot">_</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  <span class="kw">field</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">    space <span class="ot">:</span> ℕ</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">    val   <span class="ot">:</span> ℕ</a></code></pre></div>
<p>And we get our flip function:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb6-1" data-line-number="1">suc-flip <span class="ot">:</span> Flipper <span class="ot">→</span> Flipper × Bool</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">suc-flip <span class="ot">(</span>zero  &amp; n<span class="ot">)</span> <span class="ot">=</span> <span class="ot">(</span>suc n &amp; zero <span class="ot">)</span>, true</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">suc-flip <span class="ot">(</span>suc m &amp; n<span class="ot">)</span> <span class="ot">=</span> <span class="ot">(</span>m     &amp; suc n<span class="ot">)</span>, false</a></code></pre></div>
<p>When there’s no space left, the digit must be maximal (9 in decimal, for instance), so it’ll be one less than the base. That lets us stick it in for the base, rather than recalculating. In the other case, we just take one from the space left, and add it to the value.</p>
<p>So, to “prove” this implementation, we might first reach for an equality proof that <code>val + space</code> is equal to your base. Don’t! Both <code>val</code> and <code>space</code> are inductive structures, which could be giving us information on every application of <code>suc</code>! Let’s set our sights on <code>val</code> and see how we can hang our proofs off of it.</p>
<p>We’re going to upgrade our Peano number with some information, which means that our resulting type is going to look an awful lot like a Peano number. In other words, two cases: <code>zero</code> and <code>suc</code>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">data</span> Val <span class="ot">_</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  zero-case <span class="ot">:</span> Val <span class="ot">_</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  suc-case  <span class="ot">:</span> Val <span class="ot">_</span> <span class="ot">→</span> Val <span class="ot">_</span></a></code></pre></div>
<p>For the <code>suc-case</code>, remember we only want to be allowed to increment it when the space left is more than zero. So let’s encode it:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">data</span> Val <span class="ot">_</span> <span class="ot">:</span> ℕ <span class="ot">→</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  zero-case <span class="ot">:</span> Val <span class="ot">_</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  suc-case  <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>space<span class="ot">}</span> <span class="ot">→</span> Val <span class="ot">_</span> <span class="ot">(</span>suc space<span class="ot">)</span> <span class="ot">→</span> Val <span class="ot">_</span> space</a></code></pre></div>
<p>And for the <code>zero-case</code>, the space left is just the base. So let’s stick the base into the type as well:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">data</span> Val <span class="ot">(</span>base <span class="ot">:</span> ℕ<span class="ot">)</span> <span class="ot">:</span> ℕ <span class="ot">→</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">  zero-case <span class="ot">:</span> Val base base</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  suc-case  <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>space<span class="ot">}</span> <span class="ot">→</span> Val base <span class="ot">(</span>suc space<span class="ot">)</span> <span class="ot">→</span> Val base space</a></code></pre></div>
<p>(We’ve changed around the way “base” works: it’s now one smaller. So to encode base-10 you’d have <code>Val 9 space</code>. You can get back to the other encoding with a simple wrapper, this way just makes things slightly easier from now on).</p>
<p>Finally, our flipper:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">record</span> Flipper <span class="ot">(</span>base <span class="ot">:</span> ℕ<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">  <span class="kw">constructor</span> <span class="ot">_</span>&amp;<span class="ot">_</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  <span class="kw">field</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4">    space <span class="ot">:</span> ℕ</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">    val <span class="ot">:</span> Val base space</a>
<a class="sourceLine" id="cb10-6" data-line-number="6"></a>
<a class="sourceLine" id="cb10-7" data-line-number="7">suc-flip <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">→</span> Flipper n <span class="ot">→</span> Flipper n × Bool</a>
<a class="sourceLine" id="cb10-8" data-line-number="8">suc-flip <span class="ot">(</span>zero  &amp; m<span class="ot">)</span> <span class="ot">=</span> <span class="ot">(_</span> &amp;  zero-case<span class="ot">)</span> , true</a>
<a class="sourceLine" id="cb10-9" data-line-number="9">suc-flip <span class="ot">(</span>suc n &amp; m<span class="ot">)</span> <span class="ot">=</span> <span class="ot">(</span>n &amp; suc-case m<span class="ot">)</span> , false</a></code></pre></div>
<p>Great! Everything works.</p>
<p>You may have noticed that the <code>Val</code> type is actually a proof for <span class="math inline">\(\geq\)</span> in disguise:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">data</span> <span class="ot">_</span>≥<span class="ot">_</span> <span class="ot">(</span>m <span class="ot">:</span> ℕ<span class="ot">)</span> <span class="ot">:</span> ℕ <span class="ot">→</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2">  m≥m <span class="ot">:</span> m ≥ m</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  m≥p <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">→</span> m ≥ suc n <span class="ot">→</span> m ≥ n</a></code></pre></div>
<p>And the flipper itself is just an existential in disguise:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb12-1" data-line-number="1">Flipper <span class="ot">:</span> ℕ <span class="ot">→</span> <span class="dt">Set</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">Flipper n <span class="ot">=</span> ∃ <span class="ot">(</span>n ≥<span class="ot">_)</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3"></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">suc-flip <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">→</span> Flipper n <span class="ot">→</span> Flipper n × Bool</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">suc-flip <span class="ot">(</span>zero  , m<span class="ot">)</span> <span class="ot">=</span> <span class="ot">(_</span> , m≥m  <span class="ot">)</span>, true</a>
<a class="sourceLine" id="cb12-6" data-line-number="6">suc-flip <span class="ot">(</span>suc n , m<span class="ot">)</span> <span class="ot">=</span> <span class="ot">(</span>n , m≥p m<span class="ot">)</span>, false</a></code></pre></div>
<p>Hopefully this explanation will help you understand how to get from the specification to those 8 lines. This technique is going to come in especially handy later when we base data structures off of number systems.</p>
<h1 id="technique-2-once-you-eliminate-the-impossible-whatever-remains-no-matter-how-improbable-must-be-the-truth.">Technique 2: Once you eliminate the impossible, whatever remains, no matter how improbable, must be the truth.</h1>
<p>For this next trick, we’ll add an extra operation to the flipper type above: conversion from a natural number. We want to be able to do it in <span class="math inline">\(\mathcal{O}(n)\)</span> time, and we won’t allow ourselves to change the original type definition. Here’s the type we’re aiming for:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb13-1" data-line-number="1">fromNat <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>m<span class="ot">}</span> <span class="ot">(</span>n <span class="ot">:</span> ℕ<span class="ot">)</span> <span class="ot">→</span> <span class="ot">(</span>m≥n <span class="ot">:</span> m ≥ n<span class="ot">)</span> <span class="ot">→</span> Flipper m</a></code></pre></div>
<p>We pass in a proof that the natural number we’re converting from is indeed in range (it’s marked irrelevant so we don’t pay for it). Here’s a non-answer:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb14-1" data-line-number="1">fromNat <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>m<span class="ot">}</span> <span class="ot">(</span>n <span class="ot">:</span> ℕ<span class="ot">)</span> <span class="ot">→</span> <span class="ot">{</span>m≥n <span class="ot">:</span> m ≥ n<span class="ot">}</span> <span class="ot">→</span> Flipper m</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">fromNat n <span class="ot">{</span>m≥n<span class="ot">}</span> <span class="ot">=</span> n , m≥n</a></code></pre></div>
<p>While this looks fine, it’s actually the <em>inverse</em> of what we want. We defined the inductive structure to be indicated by the inequality proof itself. Let’s make the desired output explicit:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb15-1" data-line-number="1">toNat <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n m<span class="ot">}</span> <span class="ot">→</span> n ≥ m <span class="ot">→</span> ℕ</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">toNat m≥m <span class="ot">=</span> zero</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">toNat <span class="ot">(</span>m≥p n≥m<span class="ot">)</span> <span class="ot">=</span> suc <span class="ot">(</span>toNat n≥m<span class="ot">)</span></a>
<a class="sourceLine" id="cb15-4" data-line-number="4"></a>
<a class="sourceLine" id="cb15-5" data-line-number="5">fromNat-≡ <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n<span class="ot">}</span> m</a>
<a class="sourceLine" id="cb15-6" data-line-number="6">          <span class="ot">→</span> <span class="ot">.(</span>n≥m <span class="ot">:</span> n ≥ m<span class="ot">)</span></a>
<a class="sourceLine" id="cb15-7" data-line-number="7">          <span class="ot">→</span>  Σ[ n-m ∈ Flipper n ] toNat <span class="ot">(</span>proj₂ n-m<span class="ot">)</span> ≡ m</a></code></pre></div>
<p>And finally we can try an implementation:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb16-1" data-line-number="1">fromNat-≡ zero    <span class="ot">_</span>   <span class="ot">=</span> <span class="ot">(_</span> , m≥m<span class="ot">)</span> , refl</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">fromNat-≡ <span class="ot">(</span>suc m<span class="ot">)</span> n≥m <span class="ot">=</span> ??? <span class="ot">(</span>fromNat-≡ m <span class="ot">(</span>m≥p n≥m<span class="ot">))</span></a></code></pre></div>
<p>In the <code>???</code> there, we want some kind of successor function. The problem is that we would also need to prove that we <em>can</em> do a successor call. Except we don’t want to do that: proving that there’s space left is an expensive operation, and one we can avoid with another trick: first, we <em>assume</em> that there’s space left.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb17-1" data-line-number="1">fromNat-≡ zero    n≥m <span class="ot">=</span> <span class="ot">(</span> <span class="ot">_</span> , m≥m<span class="ot">)</span> , refl</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">fromNat-≡ <span class="ot">(</span>suc n<span class="ot">)</span> n≥m <span class="kw">with</span> fromNat-≡ n <span class="ot">(</span>m≥p n≥m<span class="ot">)</span></a>
<a class="sourceLine" id="cb17-3" data-line-number="3"><span class="ot">...</span> <span class="ot">|</span> <span class="ot">(</span>suc space , n-1<span class="ot">)</span>, x≡m  <span class="ot">=</span> <span class="ot">(</span>space , m≥p n-1<span class="ot">)</span>, cong suc x≡m</a>
<a class="sourceLine" id="cb17-4" data-line-number="4"><span class="ot">...</span> <span class="ot">|</span> <span class="ot">(</span>zero      , n-1<span class="ot">)</span>, refl <span class="ot">=</span> ???</a></code></pre></div>
<p>But what about the second case? Well, we have to prove this impossible. What if it’s an extremely complex, expensive proof? It doesn’t matter! It will never be run! In contrast to proving the “happy path” correct, if we can confine all of the ugly complex cases to the unhappy paths, we can spend as long as we want proving them impossible without having to worry about runtime cost. Here’s the full function.</p>
<details>
<p><summary> <code>fromNat</code> implementation </summary></p>
<div class="sourceCode" id="cb18"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb18-1" data-line-number="1">fromNat-≡ <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n<span class="ot">}</span> m</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">          <span class="ot">→</span> <span class="ot">.(</span>n≥m <span class="ot">:</span> n ≥ m<span class="ot">)</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3">          <span class="ot">→</span>  Σ[ n-m ∈ Flipper n ] toNat <span class="ot">(</span>proj₂ n-m<span class="ot">)</span> ≡ m</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">fromNat-≡ zero    n≥m <span class="ot">=</span> <span class="ot">(</span> <span class="ot">_</span> , m≥m<span class="ot">)</span> , refl</a>
<a class="sourceLine" id="cb18-5" data-line-number="5">fromNat-≡ <span class="ot">(</span>suc n<span class="ot">)</span> n≥m <span class="kw">with</span> fromNat-≡ n <span class="ot">(</span>m≥p n≥m<span class="ot">)</span></a>
<a class="sourceLine" id="cb18-6" data-line-number="6"><span class="ot">...</span> <span class="ot">|</span> <span class="ot">(</span>suc space , n-1<span class="ot">)</span>, x≡m  <span class="ot">=</span> <span class="ot">(</span>space , m≥p n-1<span class="ot">)</span>, cong suc x≡m</a>
<a class="sourceLine" id="cb18-7" data-line-number="7"><span class="ot">...</span> <span class="ot">|</span> <span class="ot">(</span>zero      , n≥0<span class="ot">)</span>, refl <span class="ot">=</span> Irrel<span class="ot">.</span>⊥-elim <span class="ot">(</span>contra <span class="ot">_</span> zero n≥0 n≥m<span class="ot">)</span></a>
<a class="sourceLine" id="cb18-8" data-line-number="8">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-9" data-line-number="9">  <span class="kw">import</span> Data<span class="ot">.</span>Nat<span class="ot">.</span>Properties as <span class="dt">Prop</span></a>
<a class="sourceLine" id="cb18-10" data-line-number="10"></a>
<a class="sourceLine" id="cb18-11" data-line-number="11">  n≱sk+n <span class="ot">:</span> <span class="ot">∀</span> n k <span class="ot">{</span>sk+n<span class="ot">}</span> <span class="ot">→</span> sk+n ≡ suc k ℕ<span class="ot">.</span>+ n <span class="ot">→</span> n ≥ sk+n <span class="ot">→</span> ⊥</a>
<a class="sourceLine" id="cb18-12" data-line-number="12">  n≱sk+n n k wit <span class="ot">(</span>m≥p n≥sk+n<span class="ot">)</span> <span class="ot">=</span> n≱sk+n n <span class="ot">(</span>suc k<span class="ot">)</span> <span class="ot">(</span>cong suc wit<span class="ot">)</span> n≥sk+n</a>
<a class="sourceLine" id="cb18-13" data-line-number="13">  n≱sk+n n k wit m≥m <span class="kw">with</span> <span class="dt">Prop</span><span class="ot">.</span>+-cancelʳ-≡ <span class="dv">0</span> <span class="ot">(</span>suc k<span class="ot">)</span> wit</a>
<a class="sourceLine" id="cb18-14" data-line-number="14">  <span class="ot">...</span> <span class="ot">|</span> <span class="ot">()</span></a>
<a class="sourceLine" id="cb18-15" data-line-number="15"></a>
<a class="sourceLine" id="cb18-16" data-line-number="16">  contra <span class="ot">:</span> <span class="ot">∀</span> n m <span class="ot">→</span> <span class="ot">(</span>n≥m <span class="ot">:</span> n ≥ m<span class="ot">)</span> <span class="ot">→</span> n ≥ suc <span class="ot">(</span>m ℕ<span class="ot">.</span>+ toNat n≥m<span class="ot">)</span> <span class="ot">→</span> ⊥</a>
<a class="sourceLine" id="cb18-17" data-line-number="17">  contra n m m≥m n≥st <span class="ot">=</span> n≱sk+n n zero <span class="ot">(</span>cong suc <span class="ot">(</span><span class="dt">Prop</span><span class="ot">.</span>+-identityʳ n<span class="ot">))</span> n≥st</a>
<a class="sourceLine" id="cb18-18" data-line-number="18">  contra n m <span class="ot">(</span>m≥p n≥m<span class="ot">)</span> n≥st <span class="ot">=</span></a>
<a class="sourceLine" id="cb18-19" data-line-number="19">    contra</a>
<a class="sourceLine" id="cb18-20" data-line-number="20">      n</a>
<a class="sourceLine" id="cb18-21" data-line-number="21">      <span class="ot">(</span>suc m<span class="ot">)</span></a>
<a class="sourceLine" id="cb18-22" data-line-number="22">      n≥m</a>
<a class="sourceLine" id="cb18-23" data-line-number="23">      <span class="ot">(</span>subst <span class="ot">(λ</span> x <span class="ot">→</span> n ≥ suc x<span class="ot">)</span> <span class="ot">(</span><span class="dt">Prop</span><span class="ot">.</span>+-suc m <span class="ot">(</span>toNat n≥m<span class="ot">))</span> n≥st<span class="ot">)</span></a>
<a class="sourceLine" id="cb18-24" data-line-number="24"></a>
<a class="sourceLine" id="cb18-25" data-line-number="25">fromNat <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n<span class="ot">}</span> m <span class="ot">→</span> <span class="ot">.(</span>n≥m <span class="ot">:</span> n ≥ m<span class="ot">)</span> <span class="ot">→</span> Flipper n</a>
<a class="sourceLine" id="cb18-26" data-line-number="26">fromNat m n≥m <span class="ot">=</span> proj₁ <span class="ot">(</span>fromNat-≡ m n≥m<span class="ot">)</span></a></code></pre></div>
</details>
<h1 id="technique-3-make-indices-correct-by-construction">Technique 3: Make Indices Correct-By-Construction</h1>
<p>We’re going to switch into Haskell now, and in particular to functional arrays. These are data structures which aren’t real arrays, but they offer you the kind of interface you’d want from an array in a functional setting. You can’t get better than <span class="math inline">\(\mathcal{O}(\log n)\)</span> indexing, unfortunately <span class="citation" data-cites="ben-amram_pointers_1992">(Ben-Amram and Galil <a href="#ref-ben-amram_pointers_1992">1992</a>)</span>, but often it’s enough.</p>
<p>The first “functional array” we’re going to be looking at nested binary random-access lists. It has <span class="math inline">\(\mathcal{O}(\log n)\)</span> indexing, as you might expect, and amortized single-threaded <span class="math inline">\(\mathcal{O}(1)\)</span> <code>cons</code>.</p>
<p>It starts out like a binary random-access list (“random-access list” is another name for “functional array”). You can find a full explanation of the structure in your nearest copy of Purely Functional Data Structures <span class="citation" data-cites="okasaki_purely_1999">(Okasaki <a href="#ref-okasaki_purely_1999">1999</a><a href="#ref-okasaki_purely_1999">b</a>)</span>, but briefly: the structure mimics a binary number, in that it’s a list of “bits”. At each set bit, it stores a tree with <span class="math inline">\(2^i\)</span> elements, where <span class="math inline">\(i\)</span> is the position in the list. In this way, every binary number <span class="math inline">\(n\)</span> has an analogous list of “bits” which contains, in total, <span class="math inline">\(n\)</span> elements.</p>
<p>The “nested” part refers to how we’re going to implement the trees. It works a little like this:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a <span class="fu">=</span> <span class="dt">Leaf</span> a <span class="fu">|</span> <span class="dt">Node</span> (<span class="dt">Tree</span> (a,a))</a></code></pre></div>
<p>You might have to squint at that definition for a second to understand it: instead of storing two trees at the <code>Node</code> constructor (which is what you’d usually do), we store a tree with double the elements. This has two advantages: all of the children have the same number of elements (this tree, for instance, is always some power of 2), and it also cuts down on memory use.</p>
<p>For the binary random-access list, we’ll use the nested encoding of trees to encode the contents of each bit. There’s an implementation of this very thing on Hackage <span class="citation" data-cites="komuves_nested-sequence_2016">(Komuves and Divianszky <a href="#ref-komuves_nested-sequence_2016">2016</a>)</span>, and Okasaki himself wrote something very similar to it <span class="citation" data-cites="okasaki_fast_1999">(<a href="#ref-okasaki_fast_1999">1999</a><a href="#ref-okasaki_fast_1999">a</a>)</span>, but we’re going to go a little further than both of those by indexing the type by its size. Here it is:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Bit</span> <span class="fu">=</span> <span class="dt">O</span> <span class="fu">|</span> <span class="dt">I</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2"></a>
<a class="sourceLine" id="cb20-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Seq</span> ns a <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-4" data-line-number="4">    <span class="dt">Nil</span><span class="ot">  ::</span>                      <span class="dt">Seq</span> <span class="ch">'[]      a</span></a>
<a class="sourceLine" id="cb20-5" data-line-number="5">    <span class="dt">Even</span><span class="ot"> ::</span>      <span class="dt">Seq</span> xs (a,a) <span class="ot">-&gt;</span> <span class="dt">Seq</span> (<span class="dt">O</span> <span class="fu">:</span> xs) a</a>
<a class="sourceLine" id="cb20-6" data-line-number="6">    <span class="dt">Odd</span><span class="ot">  ::</span> a <span class="ot">-&gt;</span> <span class="dt">Seq</span> xs (a,a) <span class="ot">-&gt;</span> <span class="dt">Seq</span> (<span class="dt">I</span> <span class="fu">:</span> xs) a</a></code></pre></div>
<p>The operations we’re interested will be <code>cons</code> and <code>uncons</code>: for the indices, they correspond to incrementing and decrementing the numbers, respectively. As such, we’ll need type-level functions for those:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">Inc</span> (<span class="ot">ns ::</span> [<span class="dt">Bit</span>])<span class="ot"> ::</span> [<span class="dt">Bit</span>] <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-2" data-line-number="2">    <span class="dt">Inc</span> <span class="ch">'[] = '</span>[<span class="dt">I</span>]</a>
<a class="sourceLine" id="cb21-3" data-line-number="3">    <span class="dt">Inc</span> (<span class="dt">O</span> <span class="fu">:</span> xs) <span class="fu">=</span> <span class="dt">I</span> <span class="fu">:</span> xs</a>
<a class="sourceLine" id="cb21-4" data-line-number="4">    <span class="dt">Inc</span> (<span class="dt">I</span> <span class="fu">:</span> xs) <span class="fu">=</span> <span class="dt">O</span> <span class="fu">:</span> <span class="dt">Inc</span> xs</a></code></pre></div>
<p>And now the <code>cons</code> function:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="ot">cons ::</span> a <span class="ot">-&gt;</span> <span class="dt">Seq</span> ns a <span class="ot">-&gt;</span> <span class="dt">Seq</span> (<span class="dt">Inc</span> ns) a</a>
<a class="sourceLine" id="cb22-2" data-line-number="2">cons x <span class="dt">Nil</span>        <span class="fu">=</span> <span class="dt">Odd</span> x <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb22-3" data-line-number="3">cons x (<span class="dt">Even</span>  xs) <span class="fu">=</span> <span class="dt">Odd</span> x xs</a>
<a class="sourceLine" id="cb22-4" data-line-number="4">cons x (<span class="dt">Odd</span> y ys) <span class="fu">=</span> <span class="dt">Even</span> (cons (x,y) ys)</a></code></pre></div>
<p>However, we’re going to run into trouble if we try to write <code>uncons</code>:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">Dec</span> (<span class="ot">ns ::</span> [<span class="dt">Bit</span>])<span class="ot"> ::</span> [<span class="dt">Bit</span>] <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-2" data-line-number="2">    <span class="dt">Dec</span> (<span class="dt">I</span> <span class="fu">:</span> xs) <span class="fu">=</span> <span class="dt">O</span> <span class="fu">:</span> xs</a>
<a class="sourceLine" id="cb23-3" data-line-number="3">    <span class="dt">Dec</span> (<span class="dt">O</span> <span class="fu">:</span> xs) <span class="fu">=</span> <span class="dt">I</span> <span class="fu">:</span> <span class="dt">Dec</span> xs</a>
<a class="sourceLine" id="cb23-4" data-line-number="4">    <span class="dt">Dec</span> <span class="ch">'[] = ???</span></a>
<a class="sourceLine" id="cb23-5" data-line-number="5">    </a>
<a class="sourceLine" id="cb23-6" data-line-number="6"><span class="ot">uncons ::</span> <span class="dt">Seq</span> ns a <span class="ot">-&gt;</span> (a, <span class="dt">Seq</span> (<span class="dt">Dec</span> ns) a)</a>
<a class="sourceLine" id="cb23-7" data-line-number="7">uncons (<span class="dt">Odd</span> x xs) <span class="fu">=</span> (x, <span class="dt">Even</span> xs)</a>
<a class="sourceLine" id="cb23-8" data-line-number="8">uncons (<span class="dt">Even</span>  xs) <span class="fu">=</span> <span class="kw">case</span> uncons xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb23-9" data-line-number="9">    ((x,y),ys) <span class="ot">-&gt;</span> (x, <span class="dt">Odd</span> y ys)</a>
<a class="sourceLine" id="cb23-10" data-line-number="10">uncons <span class="dt">Nil</span> <span class="fu">=</span> <span class="fu">???</span></a></code></pre></div>
<p>We <em>should</em> be able to write this function without returning a <code>Maybe</code>. Because we statically know the size, we can encode “only nonempty sequences”. The problem is that <code>Seq [] a</code> isn’t the only non-empty sequence: there’s also <code>Seq [O] a</code> and <code>Seq [O,O] a</code>, and so on. Our binary number system is redundant, because it contains trailing zeroes.</p>
<p>We could add some kind of proof into the data structure, but that would (again) be expensive. Instead, we can make the index <em>itself</em> correct-by-construction, by choosing a non-redundant representation of binary numbers.</p>
<p>Here’s the trick: instead of having a list of bits, we’re going to have a list of “the distance to the next one”. This eliminates the redundancy, and translates into our data structure like so:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="kw">data</span> <span class="dt">N</span> <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">|</span> <span class="dt">S</span> <span class="dt">N</span></a>
<a class="sourceLine" id="cb24-2" data-line-number="2"></a>
<a class="sourceLine" id="cb24-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Nest</span> n ns a <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-4" data-line-number="4">    <span class="dt">Odd</span><span class="ot">  ::</span> a <span class="ot">-&gt;</span> (<span class="dt">Seq</span>    ns (a,a)) <span class="ot">-&gt;</span> <span class="dt">Nest</span> <span class="dt">Z</span>     ns a</a>
<a class="sourceLine" id="cb24-5" data-line-number="5">    <span class="dt">Even</span><span class="ot"> ::</span>      (<span class="dt">Nest</span> n ns (a,a)) <span class="ot">-&gt;</span> <span class="dt">Nest</span> (<span class="dt">S</span> n) ns a</a>
<a class="sourceLine" id="cb24-6" data-line-number="6"></a>
<a class="sourceLine" id="cb24-7" data-line-number="7"><span class="kw">data</span> <span class="dt">Seq</span> ns a <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-8" data-line-number="8">    <span class="dt">Nil</span><span class="ot">  ::</span> <span class="dt">Seq</span> <span class="ch">'[] a</span></a>
<a class="sourceLine" id="cb24-9" data-line-number="9">    <span class="dt">Cons</span><span class="ot"> ::</span> <span class="dt">Nest</span> n ns a <span class="ot">-&gt;</span> <span class="dt">Seq</span> (n <span class="fu">:</span> ns) a</a></code></pre></div>
<p>Lovely! Crucially for our <code>uncons</code>, we now know that any non-empty list of bits is a non-zero list of bits, so we can type “nonempty sequence” easily:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">Dec</span> (<span class="ot">n ::</span> <span class="dt">N</span>) (<span class="ot">ns ::</span> [<span class="dt">N</span>]) <span class="fu">=</span> (<span class="ot">r ::</span> [<span class="dt">N</span>]) <span class="fu">|</span> r <span class="ot">-&gt;</span> n ns <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-2" data-line-number="2">    <span class="dt">Dec</span> (<span class="dt">S</span> n) ns       <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">:</span> <span class="dt">Dec</span> n ns</a>
<a class="sourceLine" id="cb25-3" data-line-number="3">    <span class="dt">Dec</span> <span class="dt">Z</span>     <span class="ch">'[]      = '</span>[]</a>
<a class="sourceLine" id="cb25-4" data-line-number="4">    <span class="dt">Dec</span> <span class="dt">Z</span>     (n <span class="fu">:</span> ns) <span class="fu">=</span> <span class="dt">S</span> n <span class="fu">:</span> ns</a>
<a class="sourceLine" id="cb25-5" data-line-number="5"></a>
<a class="sourceLine" id="cb25-6" data-line-number="6"><span class="ot">uncons ::</span> <span class="dt">Seq</span> (n <span class="fu">:</span> ns) a <span class="ot">-&gt;</span> (a, <span class="dt">Seq</span> (<span class="dt">Dec</span> n ns) a)</a>
<a class="sourceLine" id="cb25-7" data-line-number="7">uncons (<span class="dt">Cons</span> xs') <span class="fu">=</span> go xs'</a>
<a class="sourceLine" id="cb25-8" data-line-number="8">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-9" data-line-number="9"><span class="ot">    go ::</span> <span class="dt">Nest</span> n ns a <span class="ot">-&gt;</span> (a, <span class="dt">Seq</span> (<span class="dt">Dec</span> n ns) a)</a>
<a class="sourceLine" id="cb25-10" data-line-number="10">    go (<span class="dt">Odd</span> x <span class="dt">Nil</span>) <span class="fu">=</span> (x, <span class="dt">Nil</span>)</a>
<a class="sourceLine" id="cb25-11" data-line-number="11">    go (<span class="dt">Odd</span> x (<span class="dt">Cons</span> xs)) <span class="fu">=</span> (x, <span class="dt">Cons</span> (<span class="dt">Even</span> xs))</a>
<a class="sourceLine" id="cb25-12" data-line-number="12">    go (<span class="dt">Even</span> xs) <span class="fu">=</span> <span class="kw">case</span> go xs <span class="kw">of</span> ((x,y),ys) <span class="ot">-&gt;</span> (x, <span class="dt">Cons</span> (<span class="dt">Odd</span> y ys))</a></code></pre></div>
<p>We’re still not done, though: here’s our new type family for incrementing things.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">Inc</span> (<span class="ot">ns ::</span> [<span class="dt">N</span>])<span class="ot"> ::</span> [<span class="dt">N</span>] <span class="kw">where</span></a>
<a class="sourceLine" id="cb26-2" data-line-number="2">    <span class="dt">Inc</span> <span class="ch">'[] = '</span>[<span class="dt">Z</span>]</a>
<a class="sourceLine" id="cb26-3" data-line-number="3">    <span class="dt">Inc</span> (<span class="dt">S</span> n <span class="fu">:</span> ns) <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">:</span> n <span class="fu">:</span> ns</a>
<a class="sourceLine" id="cb26-4" data-line-number="4">    <span class="dt">Inc</span> (<span class="dt">Z</span>   <span class="fu">:</span> ns) <span class="fu">=</span> <span class="dt">Carry</span> (<span class="dt">Inc</span> ns)</a>
<a class="sourceLine" id="cb26-5" data-line-number="5">    </a>
<a class="sourceLine" id="cb26-6" data-line-number="6"><span class="kw">type</span> family <span class="dt">Carry</span> (<span class="ot">ns ::</span> [<span class="dt">N</span>])<span class="ot"> ::</span> [<span class="dt">N</span>] <span class="kw">where</span></a>
<a class="sourceLine" id="cb26-7" data-line-number="7">    <span class="dt">Carry</span> <span class="ch">'[] = '</span>[]</a>
<a class="sourceLine" id="cb26-8" data-line-number="8">    <span class="dt">Carry</span> (n <span class="fu">:</span> ns) <span class="fu">=</span> <span class="dt">S</span> n <span class="fu">:</span> ns</a></code></pre></div>
<p>The <code>Carry</code> there is ugly, and that ugliness carries into the <code>cons</code> function:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="ot">cons ::</span> a <span class="ot">-&gt;</span> <span class="dt">Seq</span> ns a <span class="ot">-&gt;</span> <span class="dt">Seq</span> (<span class="dt">Inc</span> ns) a</a>
<a class="sourceLine" id="cb27-2" data-line-number="2">cons x <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Cons</span> (<span class="dt">Odd</span> x <span class="dt">Nil</span>)</a>
<a class="sourceLine" id="cb27-3" data-line-number="3">cons x' (<span class="dt">Cons</span> xs') <span class="fu">=</span> go x' xs'</a>
<a class="sourceLine" id="cb27-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb27-5" data-line-number="5"><span class="ot">    go ::</span> a <span class="ot">-&gt;</span> <span class="dt">Nest</span> n ns a <span class="ot">-&gt;</span> <span class="dt">Seq</span> (<span class="dt">Inc</span> (n<span class="fu">:</span>ns)) a</a>
<a class="sourceLine" id="cb27-6" data-line-number="6">    go x (<span class="dt">Even</span>  xs) <span class="fu">=</span> <span class="dt">Cons</span> (<span class="dt">Odd</span> x (<span class="dt">Cons</span> xs))</a>
<a class="sourceLine" id="cb27-7" data-line-number="7">    go x (<span class="dt">Odd</span> y <span class="dt">Nil</span>) <span class="fu">=</span> <span class="dt">Cons</span> (<span class="dt">Even</span> (<span class="dt">Odd</span> (x,y) <span class="dt">Nil</span>))</a>
<a class="sourceLine" id="cb27-8" data-line-number="8">    go x (<span class="dt">Odd</span> y (<span class="dt">Cons</span> ys)) <span class="fu">=</span> carry (go (x,y) ys)</a>
<a class="sourceLine" id="cb27-9" data-line-number="9"></a>
<a class="sourceLine" id="cb27-10" data-line-number="10"><span class="ot">    carry ::</span> <span class="dt">Seq</span> ns (a,a) <span class="ot">-&gt;</span> <span class="dt">Seq</span> (<span class="dt">Carry</span> ns) a</a>
<a class="sourceLine" id="cb27-11" data-line-number="11">    carry <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb27-12" data-line-number="12">    carry (<span class="dt">Cons</span> xs) <span class="fu">=</span> <span class="dt">Cons</span> (<span class="dt">Even</span> xs)</a></code></pre></div>
<p>To clean it up, we’re going to use another technique.</p>
<h1 id="technique-4-provide-information-on-indices-as-early-as-possible">Technique 4: Provide Information on Indices as Early as Possible</h1>
<p>You occasionally see people wonder about the usual definition of addition on Peano numbers:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb28-1" data-line-number="1"><span class="ot">_</span>+<span class="ot">_</span> <span class="ot">:</span> ℕ <span class="ot">→</span> ℕ <span class="ot">→</span> ℕ</a>
<a class="sourceLine" id="cb28-2" data-line-number="2">zero  + m <span class="ot">=</span> m</a>
<a class="sourceLine" id="cb28-3" data-line-number="3">suc n + m <span class="ot">=</span> suc <span class="ot">(</span>n + m<span class="ot">)</span></a></code></pre></div>
<p>It’s very simple, with only two equations. When someone sees the following error, then:</p>
<blockquote>
<p><code>couldn't match type n with n + 0</code></p>
</blockquote>
<p>They might be tempted to add it as an equation to the function:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb29-1" data-line-number="1"><span class="ot">_</span>+<span class="ot">_</span> <span class="ot">:</span> ℕ <span class="ot">→</span> ℕ <span class="ot">→</span> ℕ</a>
<a class="sourceLine" id="cb29-2" data-line-number="2">zero  + m    <span class="ot">=</span> m</a>
<a class="sourceLine" id="cb29-3" data-line-number="3">n     + zero <span class="ot">=</span> n</a>
<a class="sourceLine" id="cb29-4" data-line-number="4">suc n + m    <span class="ot">=</span> suc <span class="ot">(</span>n + m<span class="ot">)</span></a></code></pre></div>
<p>Similarly, when someone sees the other error commonly found with <span class="math inline">\(+\)</span>:</p>
<blockquote>
<p><code>couldn't match type S n + m with n + S m</code></p>
</blockquote>
<p>They’ll add that equation in too! In fact, that particular equation will provide a valid definition of <span class="math inline">\(+\)</span>:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="ot">_</span>+<span class="ot">_</span> <span class="ot">:</span> ℕ <span class="ot">→</span> ℕ <span class="ot">→</span> ℕ</a>
<a class="sourceLine" id="cb30-2" data-line-number="2">zero  + m <span class="ot">=</span> m</a>
<a class="sourceLine" id="cb30-3" data-line-number="3">suc n + m <span class="ot">=</span> n + suc m</a></code></pre></div>
<p>So why is the first definition of + the one almost always used? Because it <em>maximizes output information from minimal input</em>. Take the second implementation above, the one with the zero on the right. In this function, we have to look at the second argument in the second clause: in other words, we don’t get to find out about the output until we’ve looked at both <code>n</code> and <code>m</code>. In the usual definition, if you know the first argument is <code>suc</code> something, you also know the <em>output</em> must be <code>suc</code> something.</p>
<p>Similarly with the third implementation: we have to examine the first argument in its <em>entirety</em> before we wrap the output in a constructor. Yes, we can of course prove that they’re all equivalent, but remember: proofs are expensive, and we’re looking for speed here. So the first definition of <span class="math inline">\(+\)</span> is our best bet, since it tells us the most without having to prove anything.</p>
<p>Looking back at our definition of <code>Inc</code>, we can actually provide more information a little sooner:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">Inc</span> (<span class="ot">ns ::</span> [<span class="dt">N</span>])<span class="ot"> ::</span> [<span class="dt">N</span>] <span class="kw">where</span></a>
<a class="sourceLine" id="cb31-2" data-line-number="2">    <span class="dt">Inc</span> <span class="ch">'[] = '</span>[<span class="dt">Z</span>]</a>
<a class="sourceLine" id="cb31-3" data-line-number="3">    <span class="dt">Inc</span> (<span class="dt">S</span> n <span class="fu">:</span> ns) <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">:</span> n <span class="fu">:</span> ns</a>
<a class="sourceLine" id="cb31-4" data-line-number="4">    <span class="dt">Inc</span> (<span class="dt">Z</span>   <span class="fu">:</span> ns) <span class="fu">=</span> <span class="dt">Carry</span> (<span class="dt">Inc</span> ns)</a></code></pre></div>
<p>In all of the outputs, the list is non-empty. We can encode that, by having two different functions for the head and tail of the list:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">IncHead</span> (<span class="ot">ns ::</span> [<span class="dt">N</span>])<span class="ot"> ::</span> <span class="dt">N</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-2" data-line-number="2">    <span class="dt">IncHead</span> <span class="ch">'[] = Z</span></a>
<a class="sourceLine" id="cb32-3" data-line-number="3">    <span class="dt">IncHead</span> (n <span class="fu">:</span> ns) <span class="fu">=</span> <span class="dt">IncHead'</span> n ns</a>
<a class="sourceLine" id="cb32-4" data-line-number="4"></a>
<a class="sourceLine" id="cb32-5" data-line-number="5"><span class="kw">type</span> family <span class="dt">IncHead'</span> (<span class="ot">n ::</span> <span class="dt">N</span>) (<span class="ot">ns ::</span> [<span class="dt">N</span>])<span class="ot"> ::</span> <span class="dt">N</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-6" data-line-number="6">    <span class="dt">IncHead'</span> (<span class="dt">S</span> n) ns <span class="fu">=</span> <span class="dt">Z</span></a>
<a class="sourceLine" id="cb32-7" data-line-number="7">    <span class="dt">IncHead'</span> <span class="dt">Z</span> ns <span class="fu">=</span> <span class="dt">S</span> (<span class="dt">IncHead</span> ns)</a>
<a class="sourceLine" id="cb32-8" data-line-number="8"></a>
<a class="sourceLine" id="cb32-9" data-line-number="9"><span class="kw">type</span> family <span class="dt">IncTail</span> (<span class="ot">ns ::</span> [<span class="dt">N</span>])<span class="ot"> ::</span> [<span class="dt">N</span>] <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-10" data-line-number="10">    <span class="dt">IncTail</span> <span class="ch">'[] = '</span>[]</a>
<a class="sourceLine" id="cb32-11" data-line-number="11">    <span class="dt">IncTail</span> (n <span class="fu">:</span> ns) <span class="fu">=</span> <span class="dt">IncTail'</span> n ns</a>
<a class="sourceLine" id="cb32-12" data-line-number="12"></a>
<a class="sourceLine" id="cb32-13" data-line-number="13"><span class="kw">type</span> family <span class="dt">IncTail'</span> (<span class="ot">n ::</span> <span class="dt">N</span>) (<span class="ot">ns ::</span> [<span class="dt">N</span>])<span class="ot"> ::</span> [<span class="dt">N</span>] <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-14" data-line-number="14">    <span class="dt">IncTail'</span> (<span class="dt">S</span> n) ns <span class="fu">=</span> n <span class="fu">:</span> ns</a>
<a class="sourceLine" id="cb32-15" data-line-number="15">    <span class="dt">IncTail'</span> <span class="dt">Z</span> ns <span class="fu">=</span> <span class="dt">IncTail</span> ns</a>
<a class="sourceLine" id="cb32-16" data-line-number="16"></a>
<a class="sourceLine" id="cb32-17" data-line-number="17"><span class="kw">type</span> <span class="dt">Inc</span> (<span class="ot">ns ::</span> [<span class="dt">N</span>]) <span class="fu">=</span> <span class="dt">IncHead</span> ns <span class="fu">:</span> <span class="dt">IncTail</span> ns</a></code></pre></div>
<p>This tells the typechecker that we’re not returning an empty sequence right away, so we don’t have to pattern-match to prove it later, giving us a more efficient function.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" data-line-number="1"><span class="ot">cons ::</span> a <span class="ot">-&gt;</span> <span class="dt">Seq</span> ns a <span class="ot">-&gt;</span> <span class="dt">Seq</span> (<span class="dt">Inc</span> ns) a</a>
<a class="sourceLine" id="cb33-2" data-line-number="2">cons x' xs' <span class="fu">=</span> <span class="dt">Cons</span> (go x' xs')</a>
<a class="sourceLine" id="cb33-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb33-4" data-line-number="4"><span class="ot">    go ::</span> a <span class="ot">-&gt;</span> <span class="dt">Seq</span> ns a <span class="ot">-&gt;</span> <span class="dt">Nest</span> (<span class="dt">IncHead</span> ns) (<span class="dt">IncTail</span> ns) a</a>
<a class="sourceLine" id="cb33-5" data-line-number="5">    go x <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Odd</span> x <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb33-6" data-line-number="6">    go x (<span class="dt">Cons</span> (<span class="dt">Even</span>  xs)) <span class="fu">=</span> <span class="dt">Odd</span> x (<span class="dt">Cons</span> xs)</a>
<a class="sourceLine" id="cb33-7" data-line-number="7">    go x (<span class="dt">Cons</span> (<span class="dt">Odd</span> y ys)) <span class="fu">=</span> <span class="dt">Even</span> (go (x,y) ys)</a></code></pre></div>
<h1 id="technique-5-lazy-proofs">Technique 5: Lazy Proofs</h1>
<p>Briefly after introducing the binary random-access list, Okasaki describes the <em>skew-binary</em> random-access list. As well as having the same indexing cost as the type above, it supports <span class="math inline">\(\mathcal{O}(1)\)</span> <code>cons</code>. But wait—didn’t the previous structure have <span class="math inline">\(\mathcal{O}(1)\)</span> <code>cons</code>? Not really. Unfortunately, in a pure functional setting, imperative-style amortization measurements aren’t always valid. Say we perform a <code>cons</code> in the worst case, and it takes <span class="math inline">\(\log n\)</span> time. In an imperative setting, that’s no problem, because all of the rest of the operations are not going to be on the worst-case. In a pure setting, though, the old structure is still sitting around. You can still access it, and you can still get that awful worst-case time.</p>
<p>This is where the skew binary tree comes in. It’s based on the <a href="https://en.wikipedia.org/wiki/Skew_binary_number_system">skew binary numbers</a>: these work similarly to binary, but you’re allowed have (at most) a single 2 digit before any ones. This gives you <span class="math inline">\(\mathcal{O}(1)\)</span> incrementing and decrementing, which is what we need here. Let’s get started.</p>
<p>First, our type-level numbers. We’re going to use the sparse encoding as above, but we need some way to encode “you’re only allowed one 2”. The most lightweight way to do it I can think of is by implicitly assuming the second number in the list of gaps is one less than the others. In other words, we encode a 2 with <code>[n, 0, m]</code>. That <code>0</code> means that at position <code>n</code> there’s a 2, not a 1.</p>
<p>The corresponding type families for increment and decrement are clearly <span class="math inline">\(\mathcal{O}(1)\)</span>:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">Inc</span> (<span class="ot">ns ::</span> [<span class="dt">N</span>]) <span class="fu">=</span> (<span class="ot">ms ::</span> [<span class="dt">N</span>]) <span class="fu">|</span> ms <span class="ot">-&gt;</span> ns <span class="kw">where</span></a>
<a class="sourceLine" id="cb34-2" data-line-number="2">    <span class="dt">Inc</span> <span class="ch">'[]              = Z   : '</span>[]</a>
<a class="sourceLine" id="cb34-3" data-line-number="3">    <span class="dt">Inc</span> (x  <span class="fu">:</span> <span class="ch">'[])       = Z   : x  : '</span>[]</a>
<a class="sourceLine" id="cb34-4" data-line-number="4">    <span class="dt">Inc</span> (x  <span class="fu">:</span> <span class="dt">Z</span>    <span class="fu">:</span> xs) <span class="fu">=</span> <span class="dt">S</span> x <span class="fu">:</span> xs</a>
<a class="sourceLine" id="cb34-5" data-line-number="5">    <span class="dt">Inc</span> (x1 <span class="fu">:</span> <span class="dt">S</span> x2 <span class="fu">:</span> xs) <span class="fu">=</span> <span class="dt">Z</span>   <span class="fu">:</span> x1 <span class="fu">:</span> x2 <span class="fu">:</span> xs</a>
<a class="sourceLine" id="cb34-6" data-line-number="6"></a>
<a class="sourceLine" id="cb34-7" data-line-number="7"><span class="kw">type</span> family <span class="dt">Dec</span> (<span class="ot">n ::</span> <span class="dt">N</span>) (<span class="ot">ns ::</span> [<span class="dt">N</span>]) <span class="fu">=</span> (<span class="ot">ms ::</span> [<span class="dt">N</span>]) <span class="fu">|</span> ms <span class="ot">-&gt;</span> n ns <span class="kw">where</span></a>
<a class="sourceLine" id="cb34-8" data-line-number="8">    <span class="dt">Dec</span> (<span class="dt">S</span> x)  xs            <span class="fu">=</span> x  <span class="fu">:</span> <span class="dt">Z</span> <span class="fu">:</span> xs</a>
<a class="sourceLine" id="cb34-9" data-line-number="9">    <span class="dt">Dec</span> <span class="dt">Z</span>     <span class="ch">'[]            = '</span>[]</a>
<a class="sourceLine" id="cb34-10" data-line-number="10">    <span class="dt">Dec</span> <span class="dt">Z</span>     (x  <span class="fu">:</span> <span class="ch">'[])     = x  : '</span>[]</a>
<a class="sourceLine" id="cb34-11" data-line-number="11">    <span class="dt">Dec</span> <span class="dt">Z</span>     (x1 <span class="fu">:</span> x2 <span class="fu">:</span> xs) <span class="fu">=</span> x1 <span class="fu">:</span> <span class="dt">S</span> x2 <span class="fu">:</span> xs</a></code></pre></div>
<p>We don’t need to split this into head and tail families as we did before because there’s no recursive call: we know all we’re ever going to know about the output following <em>any</em> match on the input.</p>
<p>There’s another problem before we write the implementation: we can’t use the <code>Nest</code> construction that we had before, because then the head would be buried in <span class="math inline">\(\log n\)</span> constructors (or thereabouts). Instead, we’re going to have to use GADTs to encode the “gap” type, alongside the relevant tree. This gap type is going to be very similar to the <span class="math inline">\(\geq\)</span> proof we had for the modular counters, but with an extra parameter:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb35-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Gap</span> (<span class="ot">n ::</span> <span class="dt">N</span>) (<span class="ot">g ::</span> <span class="dt">N</span>) (<span class="ot">m ::</span> <span class="dt">N</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb35-2" data-line-number="2">    <span class="dt">Zy</span><span class="ot"> ::</span> <span class="dt">Gap</span> n <span class="dt">Z</span> n</a>
<a class="sourceLine" id="cb35-3" data-line-number="3">    <span class="dt">Sy</span><span class="ot"> ::</span> <span class="dt">Gap</span> n g m <span class="ot">-&gt;</span> <span class="dt">Gap</span> n (<span class="dt">S</span> g) (<span class="dt">S</span> m)</a></code></pre></div>
<p><code>Gap n g m</code> means there is a gap of <code>g</code> between <code>n</code> and <code>m</code>. Or, stated another way, it means <code>n + g = m</code>. Its inductive structure mimics the <code>g</code> parameter (it’s basically the <code>g</code> parameter itself with some added information).</p>
<p>With all of that together, here’s the definition of the array itself:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">Tree</span> (<span class="ot">n ::</span> <span class="dt">N</span>) (<span class="ot">a ::</span> <span class="dt">Type</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb36-2" data-line-number="2">    <span class="dt">Tree</span> <span class="dt">Z</span> a <span class="fu">=</span> a</a>
<a class="sourceLine" id="cb36-3" data-line-number="3">    <span class="dt">Tree</span> (<span class="dt">S</span> n) a <span class="fu">=</span> <span class="dt">Node</span> n a</a>
<a class="sourceLine" id="cb36-4" data-line-number="4"></a>
<a class="sourceLine" id="cb36-5" data-line-number="5"><span class="kw">data</span> <span class="dt">Node</span> n a <span class="fu">=</span> <span class="dt">Node</span> a (<span class="dt">Tree</span> n a) (<span class="dt">Tree</span> n a)</a>
<a class="sourceLine" id="cb36-6" data-line-number="6"></a>
<a class="sourceLine" id="cb36-7" data-line-number="7"><span class="kw">data</span> <span class="dt">SeqTail</span> (<span class="ot">n ::</span> <span class="dt">N</span>) (<span class="ot">ns ::</span> [<span class="dt">N</span>]) (<span class="ot">a ::</span> <span class="dt">Type</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb36-8" data-line-number="8">    <span class="dt">NilT</span><span class="ot">  ::</span> <span class="dt">SeqTail</span> n <span class="ch">'[] a</span></a>
<a class="sourceLine" id="cb36-9" data-line-number="9">    <span class="dt">ConsT</span><span class="ot"> ::</span> <span class="dt">Gap</span> n g m</a>
<a class="sourceLine" id="cb36-10" data-line-number="10">          <span class="ot">-&gt;</span> <span class="dt">Tree</span> m a</a>
<a class="sourceLine" id="cb36-11" data-line-number="11">          <span class="ot">-&gt;</span> <span class="dt">SeqTail</span> (<span class="dt">S</span> m) ms a</a>
<a class="sourceLine" id="cb36-12" data-line-number="12">          <span class="ot">-&gt;</span> <span class="dt">SeqTail</span> n (g <span class="fu">:</span> ms) a</a>
<a class="sourceLine" id="cb36-13" data-line-number="13"></a>
<a class="sourceLine" id="cb36-14" data-line-number="14"><span class="kw">data</span> <span class="dt">Seq</span> (<span class="ot">ns ::</span> [<span class="dt">N</span>]) (<span class="ot">a ::</span> <span class="dt">Type</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb36-15" data-line-number="15">    <span class="dt">Nil</span><span class="ot">  ::</span> <span class="dt">Seq</span> <span class="ch">'[] a</span></a>
<a class="sourceLine" id="cb36-16" data-line-number="16">    <span class="dt">Cons</span><span class="ot"> ::</span> <span class="dt">Gap</span> <span class="dt">Z</span> g n</a>
<a class="sourceLine" id="cb36-17" data-line-number="17">         <span class="ot">-&gt;</span> <span class="dt">Tree</span> n a</a>
<a class="sourceLine" id="cb36-18" data-line-number="18">         <span class="ot">-&gt;</span> <span class="dt">SeqTail</span> n ns a</a>
<a class="sourceLine" id="cb36-19" data-line-number="19">         <span class="ot">-&gt;</span> <span class="dt">Seq</span> (g <span class="fu">:</span> ns) a</a></code></pre></div>
<p>The <code>cons</code> operation again mimics the increment function, but there’s one final snag before it’ll typecheck:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb37-1" data-line-number="1"><span class="ot">cons ::</span> a <span class="ot">-&gt;</span> <span class="dt">Seq</span> ns a <span class="ot">-&gt;</span> <span class="dt">Seq</span> (<span class="dt">Inc</span> ns) a</a>
<a class="sourceLine" id="cb37-2" data-line-number="2">cons x <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Cons</span> <span class="dt">Zy</span> x <span class="dt">NilT</span></a>
<a class="sourceLine" id="cb37-3" data-line-number="3">cons x (<span class="dt">Cons</span> zn y <span class="dt">NilT</span>) <span class="fu">=</span> <span class="dt">Cons</span> <span class="dt">Zy</span> x (<span class="dt">ConsT</span> zn y <span class="dt">NilT</span>)</a>
<a class="sourceLine" id="cb37-4" data-line-number="4">cons x (<span class="dt">Cons</span> zn y1 (<span class="dt">ConsT</span> <span class="dt">Zy</span> y2 ys)) <span class="fu">=</span> <span class="dt">Cons</span>(<span class="dt">Sy</span> zn) (<span class="dt">Node</span> x y1 y2) ys</a>
<a class="sourceLine" id="cb37-5" data-line-number="5">cons x (<span class="dt">Cons</span> zn y1 (<span class="dt">ConsT</span> (<span class="dt">Sy</span> nm) y2 ys)) <span class="fu">=</span></a>
<a class="sourceLine" id="cb37-6" data-line-number="6">    <span class="dt">Cons</span> <span class="dt">Zy</span> x (<span class="dt">ConsT</span> zn y1 (<span class="dt">ConsT</span> <span class="fu">???</span> y2 ys))</a></code></pre></div>
<p>On the final line, the <code>???</code> is missing. In the unverified version, <code>nm</code> would slot right in there. Here, though, if we try it we get an error, which basically amounts to:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb38-1" data-line-number="1"><span class="dt">Gap</span> n g m <span class="fu">/=</span> <span class="dt">Gap</span> (<span class="dt">S</span> n) g (<span class="dt">S</span> m)</a></code></pre></div>
<p>At this point, I’d usually throw out the inductive-style proof, and replace it with a proof of equality, which I’d aggressively erase in all of the functions. I said at the beginning I wouldn’t cheat, though, so here’s what I’ll do instead:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb39-1" data-line-number="1"><span class="ot">gapr ::</span> <span class="dt">Gap</span> n g m <span class="ot">-&gt;</span> <span class="dt">Gap</span> (<span class="dt">S</span> n) g (<span class="dt">S</span> m)</a>
<a class="sourceLine" id="cb39-2" data-line-number="2">gapr <span class="dt">Zy</span>       <span class="fu">=</span> <span class="dt">Zy</span></a>
<a class="sourceLine" id="cb39-3" data-line-number="3">gapr (<span class="dt">Sy</span> pnm) <span class="fu">=</span> <span class="dt">Sy</span> (gapr pnm)</a>
<a class="sourceLine" id="cb39-4" data-line-number="4"></a>
<a class="sourceLine" id="cb39-5" data-line-number="5"><span class="ot">cons ::</span> a <span class="ot">-&gt;</span> <span class="dt">Seq</span> ns a <span class="ot">-&gt;</span> <span class="dt">Seq</span> (<span class="dt">Inc</span> ns) a</a>
<a class="sourceLine" id="cb39-6" data-line-number="6">cons x <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Cons</span> <span class="dt">Zy</span> x <span class="dt">NilT</span></a>
<a class="sourceLine" id="cb39-7" data-line-number="7">cons x (<span class="dt">Cons</span> zn y <span class="dt">NilT</span>) <span class="fu">=</span> <span class="dt">Cons</span> <span class="dt">Zy</span> x (<span class="dt">ConsT</span> zn y <span class="dt">NilT</span>)</a>
<a class="sourceLine" id="cb39-8" data-line-number="8">cons x (<span class="dt">Cons</span> zn y1 (<span class="dt">ConsT</span> <span class="dt">Zy</span> y2 ys)) <span class="fu">=</span> <span class="dt">Cons</span> (<span class="dt">Sy</span> zn) (<span class="dt">Node</span> x y1 y2) ys</a>
<a class="sourceLine" id="cb39-9" data-line-number="9">cons x (<span class="dt">Cons</span> zn y1 (<span class="dt">ConsT</span> (<span class="dt">Sy</span> nm) y2 ys)) <span class="fu">=</span></a>
<a class="sourceLine" id="cb39-10" data-line-number="10">    <span class="dt">Cons</span> <span class="dt">Zy</span> x (<span class="dt">ConsT</span> zn y1 (<span class="dt">ConsT</span> (gapr nm) y2 ys))</a></code></pre></div>
<p>At first glance, we’ve lost the complexity bounds. That <code>gapr</code> operation is <span class="math inline">\(\log n\)</span> (or something), and we’re performing it pretty frequently. We might keep the amortized bounds, but isn’t that not really worthy in a pure setting?</p>
<p>That would all be true, if it weren’t for laziness. Because we <em>delay</em> the evaluation of <code>gapr</code>, we won’t have to pay for it all in one big thunk. In fact, because it’s basically a unary number, we only have to pay for one part of it at a time. I haven’t yet fully worked out the proofs, but I’m pretty sure we’re guaranteed <span class="math inline">\(\mathcal{O}(1)\)</span> worst-case time here too.</p>
<h1 id="technique-6-when-all-else-fails-prove-it-later">Technique 6: When All Else Fails, Prove it Later</h1>
<p>About a year ago, I <a href="../posts/2017-04-23-verifying-data-structures-in-haskell-lhs.html">tried</a> to write a verified version of binomial heaps, which could then be used for sorting traversable containers. Unfortunately, I couldn’t figure out how to write delete-min, and gave up. I <em>did</em> recognize that the redundancy of the binary representation was a problem, but I couldn’t figure out much more than that.</p>
<p>Now, though, we have a new non-redundant representation of binary numbers, and some handy techniques to go along with it.</p>
<p>Unfortunately, I ran into a similar roadblock in the implementation. Here’s the point where I was stuck:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb40-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Zipper</span> a n xs <span class="fu">=</span> <span class="dt">Zipper</span> a (<span class="dt">Node</span> n a) (<span class="dt">Binomial</span> n xs a)</a>
<a class="sourceLine" id="cb40-2" data-line-number="2"></a>
<a class="sourceLine" id="cb40-3" data-line-number="3"><span class="ot">slideLeft ::</span> <span class="dt">Zipper</span> a (<span class="dt">S</span> n) xs <span class="ot">-&gt;</span> <span class="dt">Zipper</span> a n (<span class="dt">Z</span> <span class="fu">:</span> xs)</a>
<a class="sourceLine" id="cb40-4" data-line-number="4">slideLeft (<span class="dt">Zipper</span> m (t <span class="fu">:&lt;</span> ts) hs) <span class="fu">=</span> <span class="dt">Zipper</span> m ts (<span class="dt">Cons</span> (<span class="dt">Odd</span> t hs))</a>
<a class="sourceLine" id="cb40-5" data-line-number="5"></a>
<a class="sourceLine" id="cb40-6" data-line-number="6"><span class="ot">minView ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Binomial</span> n (x <span class="fu">:</span> xs) a <span class="ot">-&gt;</span> (a, <span class="dt">Binomial</span> n (<span class="dt">Decr</span> x xs) a)</a>
<a class="sourceLine" id="cb40-7" data-line-number="7">minView (<span class="dt">Cons</span> xs') <span class="fu">=</span> unZipper (go xs')</a>
<a class="sourceLine" id="cb40-8" data-line-number="8">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb40-9" data-line-number="9">    unZipper (<span class="dt">Zipper</span> x _ xs) <span class="fu">=</span> (x, xs)</a>
<a class="sourceLine" id="cb40-10" data-line-number="10"></a>
<a class="sourceLine" id="cb40-11" data-line-number="11"><span class="ot">    go ::</span> forall a n x xs<span class="fu">.</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Nest</span> n x xs a <span class="ot">-&gt;</span> <span class="dt">Zipper</span> a n (<span class="dt">Decr</span> x xs)</a>
<a class="sourceLine" id="cb40-12" data-line-number="12">    go (<span class="dt">Even</span> xs) <span class="fu">=</span> slideLeft (go xs)</a>
<a class="sourceLine" id="cb40-13" data-line-number="13">    go (<span class="dt">Odd</span> (<span class="dt">Root</span> x ts) <span class="dt">Empty</span>) <span class="fu">=</span> <span class="dt">Zipper</span> x ts <span class="dt">Empty</span></a>
<a class="sourceLine" id="cb40-14" data-line-number="14">    go (<span class="dt">Odd</span> c<span class="fu">@</span>(<span class="dt">Root</span> x ts) (<span class="dt">Cons</span> xs)) <span class="fu">=</span></a>
<a class="sourceLine" id="cb40-15" data-line-number="15">        <span class="kw">case</span> go xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb40-16" data-line-number="16">            (<span class="dt">Zipper</span> m (t' <span class="fu">:&lt;</span> _) hs)</a>
<a class="sourceLine" id="cb40-17" data-line-number="17">              <span class="fu">|</span> m <span class="fu">&gt;=</span> x <span class="ot">-&gt;</span> <span class="dt">Zipper</span> x ts (<span class="dt">Cons</span> (<span class="dt">Even</span> xs))</a>
<a class="sourceLine" id="cb40-18" data-line-number="18">              <span class="fu">|</span> otherwise <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb40-19" data-line-number="19">                  <span class="dt">Zipper</span> m ts</a>
<a class="sourceLine" id="cb40-20" data-line-number="20">                      (<span class="kw">case</span> hs <span class="kw">of</span></a>
<a class="sourceLine" id="cb40-21" data-line-number="21">                           <span class="dt">Empty</span> <span class="ot">-&gt;</span> <span class="dt">Cons</span> (<span class="dt">Even</span> (<span class="dt">Odd</span> (mergeTree c t') <span class="dt">Empty</span>))</a>
<a class="sourceLine" id="cb40-22" data-line-number="22">                           <span class="dt">Cons</span> hs' <span class="ot">-&gt;</span> <span class="dt">Cons</span> (<span class="dt">Even</span> (carryOneNest (mergeTree c t') hs')))</a></code></pre></div>
<p>The last two lines don’t typecheck! The errors were complex, but effectively they stated:</p>
<blockquote>
<p><code>Could not deduce</code></p>
<blockquote>
<p><code class="sourceCode haskell">x <span class="fu">:</span> xs <span class="fu">~</span> [<span class="dt">Z</span>]</code></p>
</blockquote>
<p><code>from the context</code></p>
<blockquote>
<p><code class="sourceCode haskell"><span class="dt">Decr</span> x xs <span class="fu">~</span> []</code></p>
</blockquote>
</blockquote>
<p>and:</p>
<blockquote>
<p><code>Could not deduce</code></p>
<blockquote>
<p><code class="sourceCode haskell">x <span class="fu">:</span> xs <span class="fu">~</span> <span class="dt">Inc</span> (y <span class="fu">:</span> ys)</code></p>
</blockquote>
<p><code>from the context</code></p>
<blockquote>
<p><code class="sourceCode haskell"><span class="dt">Decr</span> x xs <span class="fu">~</span> y <span class="fu">:</span> ys</code></p>
</blockquote>
</blockquote>
<p>The thing is, all of those look pretty provable. So, for this technique, we first figure out what proofs we need, and <em>assume</em> we have them. This means changing <code>minView</code> to the following:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb41-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Zipper</span> a n xs <span class="fu">=</span> <span class="dt">Zipper</span> a (<span class="dt">Node</span> n a) (<span class="dt">Binomial</span> n xs a)</a>
<a class="sourceLine" id="cb41-2" data-line-number="2"></a>
<a class="sourceLine" id="cb41-3" data-line-number="3"><span class="ot">slideLeft ::</span> <span class="dt">Zipper</span> a (<span class="dt">S</span> n) xs <span class="ot">-&gt;</span> <span class="dt">Zipper</span> a n (<span class="dt">Z</span> <span class="fu">:</span> xs)</a>
<a class="sourceLine" id="cb41-4" data-line-number="4">slideLeft (<span class="dt">Zipper</span> m (t <span class="fu">:&lt;</span> ts) hs) <span class="fu">=</span> <span class="dt">Zipper</span> m ts (<span class="dt">Cons</span> (<span class="dt">Odd</span> t hs))</a>
<a class="sourceLine" id="cb41-5" data-line-number="5"></a>
<a class="sourceLine" id="cb41-6" data-line-number="6"><span class="ot">minView ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Binomial</span> n (x <span class="fu">:</span> xs) a <span class="ot">-&gt;</span> (a, <span class="dt">Binomial</span> n (<span class="dt">Decr</span> x xs) a)</a>
<a class="sourceLine" id="cb41-7" data-line-number="7">minView (<span class="dt">Cons</span> xs') <span class="fu">=</span> unZipper (go xs')</a>
<a class="sourceLine" id="cb41-8" data-line-number="8">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb41-9" data-line-number="9">    unZipper (<span class="dt">Zipper</span> x _ xs) <span class="fu">=</span> (x, xs)</a>
<a class="sourceLine" id="cb41-10" data-line-number="10"></a>
<a class="sourceLine" id="cb41-11" data-line-number="11"><span class="ot">    go ::</span> forall a n x xs<span class="fu">.</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Nest</span> n x xs a <span class="ot">-&gt;</span> <span class="dt">Zipper</span> a n (<span class="dt">Decr</span> x xs)</a>
<a class="sourceLine" id="cb41-12" data-line-number="12">    go (<span class="dt">Even</span> xs) <span class="fu">=</span> slideLeft (go xs)</a>
<a class="sourceLine" id="cb41-13" data-line-number="13">    go (<span class="dt">Odd</span> (<span class="dt">Root</span> x ts) <span class="dt">Empty</span>) <span class="fu">=</span> <span class="dt">Zipper</span> x ts <span class="dt">Empty</span></a>
<a class="sourceLine" id="cb41-14" data-line-number="14">    go (<span class="dt">Odd</span> c<span class="fu">@</span>(<span class="dt">Root</span> x ts) (<span class="dt">Cons</span> xs)) <span class="fu">=</span></a>
<a class="sourceLine" id="cb41-15" data-line-number="15">        <span class="kw">case</span> go xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb41-16" data-line-number="16">            (<span class="dt">Zipper</span> m (t' <span class="fu">:&lt;</span> _) (<span class="ot">hs ::</span> <span class="dt">Binomial</span> (<span class="dt">S</span> n) (<span class="dt">Decr</span> y ys) a))</a>
<a class="sourceLine" id="cb41-17" data-line-number="17">              <span class="fu">|</span> m <span class="fu">&gt;=</span> x <span class="ot">-&gt;</span> <span class="dt">Zipper</span> x ts (<span class="dt">Cons</span> (<span class="dt">Even</span> xs))</a>
<a class="sourceLine" id="cb41-18" data-line-number="18">              <span class="fu">|</span> otherwise <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb41-19" data-line-number="19">                  <span class="dt">Zipper</span> m ts</a>
<a class="sourceLine" id="cb41-20" data-line-number="20">                      (<span class="kw">case</span> hs <span class="kw">of</span></a>
<a class="sourceLine" id="cb41-21" data-line-number="21">                           <span class="dt">Empty</span> <span class="ot">-&gt;</span> gcastWith (lemma1 <span class="fu">@</span>y <span class="fu">@</span>ys <span class="dt">Refl</span>)</a>
<a class="sourceLine" id="cb41-22" data-line-number="22">                               <span class="dt">Cons</span> (<span class="dt">Even</span> (<span class="dt">Odd</span> (mergeTree c t') <span class="dt">Empty</span>))</a>
<a class="sourceLine" id="cb41-23" data-line-number="23">                           <span class="dt">Cons</span> hs' <span class="ot">-&gt;</span> gcastWith (lemma2 <span class="fu">@</span>y <span class="fu">@</span>ys <span class="dt">Refl</span>)</a>
<a class="sourceLine" id="cb41-24" data-line-number="24">                               <span class="dt">Cons</span> (<span class="dt">Even</span> (carryOneNest (mergeTree c t') hs')))</a></code></pre></div>
<p>And writing in the templates for our lemmas:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb42-1" data-line-number="1"><span class="ot">lemma1 ::</span> forall x xs<span class="fu">.</span> <span class="dt">Decr</span> x xs <span class="fu">:~:</span> <span class="ch">'[] -&gt; x : xs :~: Z : '</span>[]</a>
<a class="sourceLine" id="cb42-2" data-line-number="2">lemma1 <span class="fu">=</span> _</a>
<a class="sourceLine" id="cb42-3" data-line-number="3"></a>
<a class="sourceLine" id="cb42-4" data-line-number="4"><span class="ot">lemma2 ::</span> forall x xs y ys<span class="fu">.</span> <span class="dt">Decr</span> x xs <span class="fu">:~:</span> y <span class="fu">:</span> ys <span class="ot">-&gt;</span> x <span class="fu">:</span> xs <span class="fu">:~:</span> <span class="dt">Inc</span> (y <span class="fu">:</span> ys)</a>
<a class="sourceLine" id="cb42-5" data-line-number="5">lemma2 <span class="fu">=</span> _</a></code></pre></div>
<p>We now need to provide the <em>implementations</em> for <code>lemma1</code> and <code>lemma2</code>. With this approach, even if we fail to do the next steps, we can cop out here and sub in <code>unsafeCoerce Refl</code> in place of the two proofs, maintaining the efficiency. We won’t need to, though!</p>
<p>Unlike in Agda, the types for those proofs won’t be around at runtime, so we won’t have anything to pattern match on. We’ll need to look for things in the surrounding area which could act like singletons for the lemmas.</p>
<p>It turns out that the <code>xs</code> and <code>hs'</code> floating around can do exactly that: they tell us about the type-level <code>y</code> and <code>x</code>. So we just pass them to the lemmas (where they’re needed). This changes the last 4 lines of <code>minView</code> to:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb43-1" data-line-number="1"><span class="dt">Empty</span> <span class="ot">-&gt;</span> gcastWith (lemma1 <span class="dt">Refl</span> xs)</a>
<a class="sourceLine" id="cb43-2" data-line-number="2">    <span class="dt">Cons</span> (<span class="dt">Even</span> (<span class="dt">Odd</span> (mergeTree c t') <span class="dt">Empty</span>))</a>
<a class="sourceLine" id="cb43-3" data-line-number="3"><span class="dt">Cons</span> hs' <span class="ot">-&gt;</span> gcastWith (lemma2 <span class="dt">Refl</span> xs hs')</a>
<a class="sourceLine" id="cb43-4" data-line-number="4">    <span class="dt">Cons</span> (<span class="dt">Even</span> (carryOneNest (mergeTree c t') hs'))</a></code></pre></div>
<p>Now, we just have to fill in the lemmas! If we were lucky, they’d actually be constant-time.</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb44-1" data-line-number="1"><span class="ot">lemma1 ::</span> forall x xs n a<span class="fu">.</span> <span class="dt">Decr</span> x xs <span class="fu">:~:</span> <span class="ch">'[]</span></a>
<a class="sourceLine" id="cb44-2" data-line-number="2">       <span class="ot">-&gt;</span>  <span class="dt">Nest</span> n x xs a</a>
<a class="sourceLine" id="cb44-3" data-line-number="3">       <span class="ot">-&gt;</span> x <span class="fu">:</span> xs <span class="fu">:~:</span> <span class="dt">Z</span> <span class="fu">:</span> <span class="ch">'[]</span></a>
<a class="sourceLine" id="cb44-4" data-line-number="4">lemma1 <span class="dt">Refl</span> (<span class="dt">Odd</span> _ <span class="dt">Empty</span>) <span class="fu">=</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb44-5" data-line-number="5"></a>
<a class="sourceLine" id="cb44-6" data-line-number="6"><span class="ot">lemma2 ::</span> forall x xs y ys n a<span class="fu">.</span></a>
<a class="sourceLine" id="cb44-7" data-line-number="7">          <span class="dt">Decr</span> x xs <span class="fu">:~:</span> y <span class="fu">:</span> ys</a>
<a class="sourceLine" id="cb44-8" data-line-number="8">       <span class="ot">-&gt;</span> <span class="dt">Nest</span> n x xs a</a>
<a class="sourceLine" id="cb44-9" data-line-number="9">       <span class="ot">-&gt;</span> <span class="dt">Nest</span> n y ys a</a>
<a class="sourceLine" id="cb44-10" data-line-number="10">       <span class="ot">-&gt;</span> x <span class="fu">:</span> xs <span class="fu">:~:</span> <span class="dt">Inc</span> (y <span class="fu">:</span> ys)</a>
<a class="sourceLine" id="cb44-11" data-line-number="11">lemma2 <span class="dt">Refl</span> (<span class="dt">Even</span> (<span class="dt">Odd</span> _ <span class="dt">Empty</span>)) (<span class="dt">Odd</span> _ <span class="dt">Empty</span>) <span class="fu">=</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb44-12" data-line-number="12">lemma2 <span class="dt">Refl</span> (<span class="dt">Odd</span> _ (<span class="dt">Cons</span> _)) (<span class="dt">Even</span> _) <span class="fu">=</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb44-13" data-line-number="13">lemma2 <span class="dt">Refl</span> (<span class="dt">Even</span> xs) (<span class="dt">Odd</span> _ (<span class="dt">Cons</span> ys)) <span class="fu">=</span></a>
<a class="sourceLine" id="cb44-14" data-line-number="14">  gcastWith (lemma2 <span class="dt">Refl</span> xs ys) <span class="dt">Refl</span></a></code></pre></div>
<p>If they <em>had</em> been constant-time, that would have let us throw them out: each proof would essentially show you what cases needed to be scrutinized to satisfy the typechecker. You then just scrutinize those cases in the actual function, and it should all typecheck.</p>
<p>As it is, <code>lemma2</code> is actually ok. It does cost <span class="math inline">\(\mathcal{O}(\log n)\)</span>, but so does <code>carryOneNest</code>: we’ve maintained the complexity! We <em>could</em> stop here, satisfied.</p>
<p>There’s another option, though, one that I picked up from Stephanie Weirich’s talk <span class="citation" data-cites="weirich_dependent_2017">(<a href="#ref-weirich_dependent_2017">2017</a>)</span>: you thread the requirement through the function as an equality constraint. It won’t always work, but when your function’s call graph matches that of the proof, the constraint will indeed be satisfied, with no runtime cost. In this case, we can whittle down the proof obligation to the following:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb45-1" data-line-number="1"><span class="dt">Inc</span> (<span class="dt">Decr</span> x xs) <span class="fu">~</span> (x <span class="fu">:</span> xs)</a></code></pre></div>
<p>Now we change the recursive <code>go</code> into continuation-passing style, and add that constraint to its signature, and everything works!</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb46-1" data-line-number="1"><span class="ot">minView ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Binomial</span> n (x <span class="fu">:</span> xs) a <span class="ot">-&gt;</span> (a, <span class="dt">Binomial</span> n (<span class="dt">Decr</span> x xs) a)</a>
<a class="sourceLine" id="cb46-2" data-line-number="2">minView (<span class="dt">Cons</span> xs') <span class="fu">=</span> go xs' \(<span class="dt">Zipper</span> x _ xs) <span class="ot">-&gt;</span> (x,xs)</a>
<a class="sourceLine" id="cb46-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb46-4" data-line-number="4"><span class="ot">    go ::</span> <span class="dt">Ord</span> a</a>
<a class="sourceLine" id="cb46-5" data-line-number="5">       <span class="ot">=&gt;</span> <span class="dt">Nest</span> n x xs a</a>
<a class="sourceLine" id="cb46-6" data-line-number="6">       <span class="ot">-&gt;</span> (<span class="dt">Inc</span> (<span class="dt">Decr</span> x xs) <span class="fu">~</span> (x <span class="fu">:</span> xs) <span class="ot">=&gt;</span> <span class="dt">Zipper</span> a n (<span class="dt">Decr</span> x xs) <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb46-7" data-line-number="7">    go (<span class="dt">Even</span> xs) k <span class="fu">=</span> go xs \(<span class="dt">Zipper</span> m (t <span class="fu">:&lt;</span> ts) hs) <span class="ot">-&gt;</span> k (<span class="dt">Zipper</span> m ts (<span class="dt">Cons</span> (<span class="dt">Odd</span> t hs)))</a>
<a class="sourceLine" id="cb46-8" data-line-number="8">    go (<span class="dt">Odd</span> (<span class="dt">Root</span> x ts) <span class="dt">Empty</span>) k <span class="fu">=</span> k (<span class="dt">Zipper</span> x ts <span class="dt">Empty</span>)</a>
<a class="sourceLine" id="cb46-9" data-line-number="9">    go (<span class="dt">Odd</span> c<span class="fu">@</span>(<span class="dt">Root</span> x cs) (<span class="dt">Cons</span> xs)) k <span class="fu">=</span></a>
<a class="sourceLine" id="cb46-10" data-line-number="10">        go xs</a>
<a class="sourceLine" id="cb46-11" data-line-number="11">            \<span class="kw">case</span></a>
<a class="sourceLine" id="cb46-12" data-line-number="12">                <span class="dt">Zipper</span> m _ _ <span class="fu">|</span> m <span class="fu">&gt;=</span> x <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb46-13" data-line-number="13">                    k (<span class="dt">Zipper</span> x cs (<span class="dt">Cons</span> (<span class="dt">Even</span> xs)))</a>
<a class="sourceLine" id="cb46-14" data-line-number="14">                <span class="dt">Zipper</span> m (t <span class="fu">:&lt;</span> ts) <span class="dt">Empty</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb46-15" data-line-number="15">                    k (<span class="dt">Zipper</span> m ts (<span class="dt">Cons</span> (<span class="dt">Even</span> (<span class="dt">Odd</span> (mergeTree c t) <span class="dt">Empty</span>))))</a>
<a class="sourceLine" id="cb46-16" data-line-number="16">                <span class="dt">Zipper</span> m (t <span class="fu">:&lt;</span> ts) (<span class="dt">Cons</span> hs) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb46-17" data-line-number="17">                    k (<span class="dt">Zipper</span> m ts (<span class="dt">Cons</span> (<span class="dt">Even</span> (carryOneNest (mergeTree c t) hs))))</a></code></pre></div>
<h1 id="conclusion">Conclusion</h1>
<p>As I mentioned in the beginning, a huge amount of this stuff is <em>much</em> easier using other systems. On top of that, there’s currently a lot of work being done on dependent type erasure, so that proofs like the above don’t even exist at runtime. In other words, there’s a chance that all of these techniques will soon be useless!</p>
<p>Efficient proof-carrying code makes for an interesting puzzle, though, even if it is a bit of a hair shirt.</p>
<h1 id="code">Code</h1>
<p>Fuller implementations of the structures here are in <a href="https://github.com/oisdk/pure-arrays">this</a> git repository.</p>
<h1 id="references" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-bakst_liquidhaskell_2018">
<p>Bakst, Alexander, Ranjit Jhala, Ming Kawaguchi, Patrick Rondon, Eric Seidel, Michael Smith, Anish Tondwalkar, Chris Tetreault, and Niki Vazou. 2018. “LiquidHaskell: Liquid Types For Haskell.” ucsd-progsys. <a href="https://github.com/ucsd-progsys/liquidhaskell" class="uri">https://github.com/ucsd-progsys/liquidhaskell</a>.</p>
</div>
<div id="ref-ben-amram_pointers_1992">
<p>Ben-Amram, Amir M., and Zvi Galil. 1992. “On Pointers Versus Addresses.” <em>J. ACM</em> 39 (3) (July): 617–648. doi:<a href="https://doi.org/10.1145/146637.146666">10.1145/146637.146666</a>. <a href="http://doi.acm.org/10.1145/146637.146666" class="uri">http://doi.acm.org/10.1145/146637.146666</a>.</p>
</div>
<div id="ref-breitner_ready_2018-1">
<p>Breitner, Joachim, Antal Spector-Zabusky, Yao Li, Christine Rizkallah, John Wiegley, and Stephanie Weirich. 2018. “Ready, Set, Verify! Applying Hs-to-coq to Real-world Haskell Code (Experience Report).” <em>Proc. ACM Program. Lang.</em> 2 (ICFP) (July): 89:1–89:16. doi:<a href="https://doi.org/10.1145/3236784">10.1145/3236784</a>. <a href="http://doi.acm.org/10.1145/3236784" class="uri">http://doi.acm.org/10.1145/3236784</a>.</p>
</div>
<div id="ref-hinze_numerical_1998">
<p>Hinze, Ralf. 1998. <em>Numerical Representations as Higher-Order Nested Datatypes</em>. Institut für Informatik III, Universität Bonn. <a href="http://www.cs.ox.ac.uk/ralf.hinze/publications/\#R5" class="uri">http://www.cs.ox.ac.uk/ralf.hinze/publications/\#R5</a>.</p>
</div>
<div id="ref-hinze_perfect_1999">
<p>———. 1999. <em>Perfect Trees and Bit-reversal Permutations</em>.</p>
</div>
<div id="ref-komuves_nested-sequence_2016">
<p>Komuves, Balazs, and Peter Divianszky. 2016. “Nested-sequence: List-like data structures with O(Log(n)) random access.” <a href="http://hackage.haskell.org/package/nested-sequence" class="uri">http://hackage.haskell.org/package/nested-sequence</a>.</p>
</div>
<div id="ref-mcbride_how_2014">
<p>McBride, Conor Thomas. 2014. “How to Keep Your Neighbours in Order.” In <em>Proceedings of the 19th ACM SIGPLAN International Conference on Functional Programming</em>, 297–309. ICFP ’14. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/2628136.2628163">10.1145/2628136.2628163</a>. <a href="https://personal.cis.strath.ac.uk/conor.mcbride/pub/Pivotal.pdf" class="uri">https://personal.cis.strath.ac.uk/conor.mcbride/pub/Pivotal.pdf</a>.</p>
</div>
<div id="ref-might_missing_2015">
<p>Might, Matthew. 2015. “Missing method: How to delete from Okasaki’s red-black trees.” <em>matt.might.net</em>. <a href="http://matt.might.net/articles/red-black-delete/" class="uri">http://matt.might.net/articles/red-black-delete/</a>.</p>
</div>
<div id="ref-okasaki_fast_1999">
<p>Okasaki, Chris. 1999a. “From Fast Exponentiation to Square Matrices: An Adventure in Types.” In <em>Proceedings of the ACM SIGPLAN International Conference on Functional Programming (ICFP’99), Paris, France, September 27-29, 1999</em>, 34:28. ACM. <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.456.357\&amp;rep=rep1\&amp;type=pdf" class="uri">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.456.357\&amp;rep=rep1\&amp;type=pdf</a>.</p>
</div>
<div id="ref-okasaki_purely_1999">
<p>———. 1999b. <em>Purely Functional Data Structures</em>. Cambridge University Press.</p>
</div>
<div id="ref-weirich_depending_2014">
<p>Weirich, Stephanie. 2014. “Depending on Types.” In <em>Proceedings of the 19th ACM SIGPLAN International Conference on Functional Programming</em>, 241–241. ICFP ’14. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/2628136.2631168">10.1145/2628136.2631168</a>. <a href="https://www.cis.upenn.edu/~sweirich/talks/icfp14.pdf" class="uri">https://www.cis.upenn.edu/~sweirich/talks/icfp14.pdf</a>.</p>
</div>
<div id="ref-weirich_dependent_2017">
<p>———. 2017. “Dependent Types in Haskell.” St. Louis, MO, USA. <a href="https://www.youtube.com/watch?v=wNa3MMbhwS4" class="uri">https://www.youtube.com/watch?v=wNa3MMbhwS4</a>.</p>
</div>
</div>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
