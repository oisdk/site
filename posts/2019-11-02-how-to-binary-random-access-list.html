<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>How to do Binary Random-Access Lists Simply - Donnacha Oisín Kidney</title>
        <style>body{color:black;font-family:Garamond,Times New Roman,serif;font-size:14px;margin:0px auto 0px auto;padding-left:5px;padding-right:5px;max-width:600px}math{font-size:13px}img{max-width:600px}div#header{border-bottom:3px double black;margin-bottom:30px;padding:12px 0px 12px 0px}div#logo a{color:black;float:left;font-size:20px;text-decoration:none}div#header #navigation{text-align:right}div#header #navigation a{color:black;font-family:Garamond,Times New Roman,Serif;font-size:18px;margin-left:10px;text-decoration:none;text-transform:uppercase}div#footer{font-family:Garamond,Times New Roman,Serif;border-top:solid 2px black;color:#555;font-size:12px;margin-top:30px;padding:12px 0px 12px 0px;text-align:right}h1{font-family:Garamond,Times New Roman,Serif;font-size:22px;font-weight:normal}h2{font-family:Garamond,Times New Roman,Serif;font-size:20px;font-weight:normal}div.info{color:#555;font-size:15px;font-style:italic}span.quiet{color:#828282;font-style:italic}a{color:black;word-wrap:break-word}ul.post-list{margin-left:0px;padding-left:0px;list-style-type:none}.hidden_source{display:none}ol.serieslist{counter-reset:item;list-style-type:none;padding-left:20}ol li.serieslist:before{content:'Part ' counter(item,decimal) ':';counter-increment:item}table.sourceCode,tr.sourceCode,td.lineNumbers,td.sourceCode,table.sourceCode pre{margin:0;padding:0;border:0;vertical-align:baseline;border:none}td.lineNumbers{border-right:1px solid #AAAAAA;text-align:right;color:#AAAAAA;padding-right:5px;padding-left:5px}td.sourceCode{padding-left:5px}.sourceCode,code,.Agda{font-size:10px;font-family:menlo,monospace}.sourceCode span.kw{color:#262C6A}.sourceCode span.dt{color:#476A97}.sourceCode span.dv{color:#262C6A}.sourceCode span.bn{color:#262C6A}.sourceCode span.fl{color:#262C6A}.sourceCode span.ch{color:#262C6A}.sourceCode span.st{color:#702C51}.sourceCode span.co{color:#435138}.sourceCode span.ot{color:#262C6A}.sourceCode span.al{color:red}.sourceCode span.fu{color:#000000}.sourceCode span.re{color:#000000}.sourceCode span.er{color:red}li{margin-bottom:2px}li:last-child{margin-bottom:0px}.Agda .Comment{color:#B22222}.Agda .Background{}.Agda .Markup{color:#000000}.Agda .Keyword{color:#CD6600}.Agda .String{color:#B22222}.Agda .Number{color:#A020F0}.Agda .Symbol{color:#404040}.Agda .PrimitiveType{color:#0000CD}.Agda .Pragma{color:black}.Agda .Operator{}.Agda .Bound{color:black}.Agda .Generalizable{color:black}.Agda .InductiveConstructor{color:#008B00}.Agda .CoinductiveConstructor{color:#8B7500}.Agda .Datatype{color:#0000CD}.Agda .Field{color:#EE1289}.Agda .Function{color:#0000CD}.Agda .Module{color:#A020F0}.Agda .Postulate{color:#0000CD}.Agda .Primitive{color:#0000CD}.Agda .Record{color:#0000CD}.Agda .DottedPattern{}.Agda .UnsolvedMeta{color:black;background:yellow}.Agda .UnsolvedConstraint{color:black;background:yellow}.Agda .TerminationProblem{color:black;background:#FFA07A}.Agda .IncompletePattern{color:black;background:#F5DEB3}.Agda .Error{color:red;text-decoration:underline}.Agda .TypeChecks{color:black;background:#ADD8E6}.Agda a{text-decoration:none}.Agda a[href]:hover{background-color:#B4EEB4}.sourceCode{overflow-x:auto}</style>
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Donnacha Oisín Kidney</a>
            </div>
            <div id="navigation">
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../rss.xml">Feed</a>
            </div>
        </div>

        <div id="content">
            <h2>How to do Binary Random-Access Lists Simply</h2>

            <div class="info">
    Posted on November  2, 2019
</div>
<div class="info">
    
        Part 1 of a <a href="../series/Random%20Access%20Lists.html">2-part series on Random Access Lists</a>
    
</div>
<div class="info">
    
        Tags: <a title="All pages tagged 'Agda'." href="../tags/Agda.html">Agda</a>
    
</div>

<p>“Heterogeneous Random-Access Lists” by Wouter Swierstra <span class="citation" data-cites="swierstraHeterogeneousRandomaccessLists2019">(<a href="#ref-swierstraHeterogeneousRandomaccessLists2019" role="doc-biblioref">2019</a>)</span> describes how to write a simple binary random-access list <span class="citation" data-cites="okasakiPurelyFunctionalRandomaccess1995">(Okasaki <a href="#ref-okasakiPurelyFunctionalRandomaccess1995" role="doc-biblioref">1995</a>)</span> to use as a heterogeneous tuple. If you haven’t tried to implement the data structure described in the paper before, you might not realise the just how <em>elegant</em> the implementation is. The truth is that arriving at the definitions presented is difficult: behind every simple function is a litany of complex and ugly alternatives that had to be tried and discarded first before settling on the final answer.</p>
<p>In this post I want to go through a very similar structure, with special focus on the “wrong turns” in implementation which can lead to headache.</p>
<!--
<pre class="Agda"><a id="768" class="Symbol">{-#</a> <a id="772" class="Keyword">OPTIONS</a> <a id="780" class="Pragma">--cubical</a> <a id="790" class="Pragma">--safe</a> <a id="797" class="Symbol">#-}</a>

<a id="802" class="Keyword">open</a> <a id="807" class="Keyword">import</a> <a id="814" href="../code/binary/Prelude.html" class="Module">Prelude</a>

<a id="823" class="Keyword">variable</a>
  <a id="834" href="#834" class="Generalizable">t</a> <a id="836" class="Symbol">:</a> <a id="838" href="../code/binary/Agda.Primitive.html#408" class="Postulate">Level</a>
  <a id="846" href="#846" class="Generalizable">T</a> <a id="848" class="Symbol">:</a> <a id="850" href="../code/binary/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="852" class="Symbol">→</a> <a id="854" class="PrimitiveType">Set</a> <a id="858" href="#834" class="Generalizable">t</a>
  <a id="862" href="#862" class="Generalizable">p</a> <a id="864" class="Symbol">:</a> <a id="866" href="../code/binary/Agda.Primitive.html#408" class="Postulate">Level</a>
  <a id="874" href="#874" class="Generalizable">P</a> <a id="876" class="Symbol">:</a> <a id="878" class="PrimitiveType">Set</a> <a id="882" href="#862" class="Generalizable">p</a>
</pre>-->
<h1 id="two-proofs-on-ℕ-and-how-to-avoid-them">Two Proofs on ℕ, and How to Avoid Them</h1>
<p>Here are a couple of important identities on ℕ:</p>
<pre class="Agda"><a id="+0"></a><a id="992" href="#992" class="Function">+0</a> <a id="995" class="Symbol">:</a> <a id="997" class="Symbol">∀</a> <a id="999" href="#999" class="Bound">n</a> <a id="1001" class="Symbol">→</a> <a id="1003" href="#999" class="Bound">n</a> <a id="1005" href="../code/binary/Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="1007" href="../code/binary/Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a> <a id="1012" href="../code/binary/Agda.Builtin.Cubical.Path.html#353" class="Function Operator">≡</a> <a id="1014" href="#999" class="Bound">n</a>
<a id="1016" href="#992" class="Function">+0</a> <a id="1019" href="../code/binary/Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a>    <a id="1027" class="Symbol">=</a> <a id="1029" href="../code/binary/Cubical.Foundations.Prelude.html#856" class="Function">refl</a>
<a id="1034" href="#992" class="Function">+0</a> <a id="1037" class="Symbol">(</a><a id="1038" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="1042" href="#1042" class="Bound">n</a><a id="1043" class="Symbol">)</a> <a id="1045" class="Symbol">=</a> <a id="1047" href="../code/binary/Cubical.Foundations.Prelude.html#1057" class="Function">cong</a> <a id="1052" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="1056" class="Symbol">(</a><a id="1057" href="#992" class="Function">+0</a> <a id="1060" href="#1042" class="Bound">n</a><a id="1061" class="Symbol">)</a>

<a id="+-suc"></a><a id="1064" href="#1064" class="Function">+-suc</a> <a id="1070" class="Symbol">:</a> <a id="1072" class="Symbol">∀</a> <a id="1074" href="#1074" class="Bound">n</a> <a id="1076" href="#1076" class="Bound">m</a> <a id="1078" class="Symbol">→</a> <a id="1080" href="#1074" class="Bound">n</a> <a id="1082" href="../code/binary/Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="1084" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="1088" href="#1076" class="Bound">m</a> <a id="1090" href="../code/binary/Agda.Builtin.Cubical.Path.html#353" class="Function Operator">≡</a> <a id="1092" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="1096" href="#1074" class="Bound">n</a> <a id="1098" href="../code/binary/Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="1100" href="#1076" class="Bound">m</a>
<a id="1102" href="#1064" class="Function">+-suc</a> <a id="1108" href="../code/binary/Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a>    <a id="1116" href="#1116" class="Bound">m</a> <a id="1118" class="Symbol">=</a> <a id="1120" href="../code/binary/Cubical.Foundations.Prelude.html#856" class="Function">refl</a>
<a id="1125" href="#1064" class="Function">+-suc</a> <a id="1131" class="Symbol">(</a><a id="1132" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="1136" href="#1136" class="Bound">n</a><a id="1137" class="Symbol">)</a> <a id="1139" href="#1139" class="Bound">m</a> <a id="1141" class="Symbol">=</a> <a id="1143" href="../code/binary/Cubical.Foundations.Prelude.html#1057" class="Function">cong</a> <a id="1148" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="1152" class="Symbol">(</a><a id="1153" href="#1064" class="Function">+-suc</a> <a id="1159" href="#1136" class="Bound">n</a> <a id="1161" href="#1139" class="Bound">m</a><a id="1162" class="Symbol">)</a>
</pre>
<p>These two show up all the time as proof obligations from the compiler (i.e. “couldn’t match type <code>n + suc m</code> with <code>suc n + m</code>”). The solution is obvious, right? <code>subst</code> in one of the proofs above and you’re on your way. Wait! There might be a better way.</p>
<p>We’re going to look at reversing a vector as an example. We have a normal-looking length-indexed vector:</p>
<pre class="Agda"><a id="1539" class="Keyword">infixr</a> <a id="1546" class="Number">5</a> <a id="1548" href="#7886" class="InductiveConstructor Operator">_∷_</a>
<a id="1552" class="Keyword">data</a> <a id="Vec"></a><a id="1557" href="#1557" class="Datatype">Vec</a> <a id="1561" class="Symbol">(</a><a id="1562" href="#1562" class="Bound">A</a> <a id="1564" class="Symbol">:</a> <a id="1566" class="PrimitiveType">Set</a> <a id="1570" href="../code/binary/Prelude.html#454" class="Generalizable">a</a><a id="1571" class="Symbol">)</a> <a id="1573" class="Symbol">:</a> <a id="1575" href="../code/binary/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="1577" class="Symbol">→</a> <a id="1579" class="PrimitiveType">Set</a> <a id="1583" href="#1570" class="Bound">a</a> <a id="1585" class="Keyword">where</a>
  <a id="Vec.[]"></a><a id="1593" href="#1593" class="InductiveConstructor">[]</a> <a id="1596" class="Symbol">:</a> <a id="1598" href="#1557" class="Datatype">Vec</a> <a id="1602" href="#1562" class="Bound">A</a> <a id="1604" href="../code/binary/Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a>
  <a id="Vec._∷_"></a><a id="1611" href="#1611" class="InductiveConstructor Operator">_∷_</a> <a id="1615" class="Symbol">:</a> <a id="1617" href="#1562" class="Bound">A</a> <a id="1619" class="Symbol">→</a> <a id="1621" href="#1557" class="Datatype">Vec</a> <a id="1625" href="#1562" class="Bound">A</a> <a id="1627" href="../code/binary/Prelude.html#506" class="Generalizable">n</a> <a id="1629" class="Symbol">→</a> <a id="1631" href="#1557" class="Datatype">Vec</a> <a id="1635" href="#1562" class="Bound">A</a> <a id="1637" class="Symbol">(</a><a id="1638" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="1642" href="../code/binary/Prelude.html#506" class="Generalizable">n</a><a id="1643" class="Symbol">)</a>
</pre>
<p>Reversing a list is easy: we do it the standard way, in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n)</annotation></semantics></math> time, with an accumulator:</p>
<pre class="Agda"><a id="list-reverse"></a><a id="1759" href="#1759" class="Function">list-reverse</a> <a id="1772" class="Symbol">:</a> <a id="1774" href="../code/binary/Prelude.html#760" class="Datatype">List</a> <a id="1779" href="../code/binary/Prelude.html#470" class="Generalizable">A</a> <a id="1781" class="Symbol">→</a> <a id="1783" href="../code/binary/Prelude.html#760" class="Datatype">List</a> <a id="1788" href="../code/binary/Prelude.html#470" class="Generalizable">A</a>
<a id="1790" href="#1759" class="Function">list-reverse</a> <a id="1803" class="Symbol">=</a> <a id="1805" href="#1821" class="Function">go</a> <a id="1808" href="../code/binary/Prelude.html#793" class="InductiveConstructor">[]</a>
  <a id="1813" class="Keyword">where</a>
  <a id="1821" href="#1821" class="Function">go</a> <a id="1824" class="Symbol">:</a> <a id="1826" href="../code/binary/Prelude.html#760" class="Datatype">List</a> <a id="1831" href="../code/binary/Prelude.html#470" class="Generalizable">A</a> <a id="1833" class="Symbol">→</a> <a id="1835" href="../code/binary/Prelude.html#760" class="Datatype">List</a> <a id="1840" href="../code/binary/Prelude.html#470" class="Generalizable">A</a> <a id="1842" class="Symbol">→</a> <a id="1844" href="../code/binary/Prelude.html#760" class="Datatype">List</a> <a id="1849" href="../code/binary/Prelude.html#470" class="Generalizable">A</a>
  <a id="1853" href="#1821" class="Function">go</a> <a id="1856" href="#1856" class="Bound">acc</a> <a id="1860" href="../code/binary/Prelude.html#793" class="InductiveConstructor">[]</a> <a id="1863" class="Symbol">=</a> <a id="1865" href="#1856" class="Bound">acc</a>
  <a id="1871" href="#1821" class="Function">go</a> <a id="1874" href="#1874" class="Bound">acc</a> <a id="1878" class="Symbol">(</a><a id="1879" href="#1879" class="Bound">x</a> <a id="1881" href="../code/binary/Prelude.html#807" class="InductiveConstructor Operator">∷</a> <a id="1883" href="#1883" class="Bound">xs</a><a id="1885" class="Symbol">)</a> <a id="1887" class="Symbol">=</a> <a id="1889" href="#1821" class="Function">go</a> <a id="1892" class="Symbol">(</a><a id="1893" href="#1879" class="Bound">x</a> <a id="1895" href="../code/binary/Prelude.html#807" class="InductiveConstructor Operator">∷</a> <a id="1897" href="#1874" class="Bound">acc</a><a id="1900" class="Symbol">)</a> <a id="1902" href="#1883" class="Bound">xs</a>
</pre>
<p>Transferring over to a vector and we see our friends <code>+-suc</code> and <code>+0</code>.</p>
<pre class="Agda"><a id="vec-reverse₁"></a><a id="1990" href="#1990" class="Function">vec-reverse₁</a> <a id="2003" class="Symbol">:</a> <a id="2005" href="#1557" class="Datatype">Vec</a> <a id="2009" href="../code/binary/Prelude.html#470" class="Generalizable">A</a> <a id="2011" href="../code/binary/Prelude.html#506" class="Generalizable">n</a> <a id="2013" class="Symbol">→</a> <a id="2015" href="#1557" class="Datatype">Vec</a> <a id="2019" href="../code/binary/Prelude.html#470" class="Generalizable">A</a> <a id="2021" href="../code/binary/Prelude.html#506" class="Generalizable">n</a>
<a id="2023" href="#1990" class="Function">vec-reverse₁</a> <a id="2036" href="#2036" class="Bound">xs</a> <a id="2039" class="Symbol">=</a> <a id="2041" href="../code/binary/Cubical.Foundations.Prelude.html#4264" class="Function">subst</a> <a id="2047" class="Symbol">(</a><a id="2048" href="#1557" class="Datatype">Vec</a> <a id="2052" class="Symbol">_)</a> <a id="2055" class="Symbol">(</a><a id="2056" href="#992" class="Function">+0</a> <a id="2059" class="Symbol">_)</a> <a id="2062" class="Symbol">(</a><a id="2063" href="#2083" class="Function">go</a> <a id="2066" href="#1593" class="InductiveConstructor">[]</a> <a id="2069" href="#2036" class="Bound">xs</a><a id="2071" class="Symbol">)</a>
  <a id="2075" class="Keyword">where</a>
  <a id="2083" href="#2083" class="Function">go</a> <a id="2086" class="Symbol">:</a> <a id="2088" href="#1557" class="Datatype">Vec</a> <a id="2092" href="../code/binary/Prelude.html#470" class="Generalizable">A</a> <a id="2094" href="../code/binary/Prelude.html#506" class="Generalizable">n</a> <a id="2096" class="Symbol">→</a> <a id="2098" href="#1557" class="Datatype">Vec</a> <a id="2102" href="../code/binary/Prelude.html#470" class="Generalizable">A</a> <a id="2104" href="../code/binary/Prelude.html#508" class="Generalizable">m</a> <a id="2106" class="Symbol">→</a> <a id="2108" href="#1557" class="Datatype">Vec</a> <a id="2112" href="../code/binary/Prelude.html#470" class="Generalizable">A</a> <a id="2114" class="Symbol">(</a><a id="2115" href="../code/binary/Prelude.html#508" class="Generalizable">m</a> <a id="2117" href="../code/binary/Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="2119" href="../code/binary/Prelude.html#506" class="Generalizable">n</a><a id="2120" class="Symbol">)</a>
  <a id="2124" href="#2083" class="Function">go</a> <a id="2127" href="#2127" class="Bound">acc</a> <a id="2131" href="#1593" class="InductiveConstructor">[]</a> <a id="2134" class="Symbol">=</a> <a id="2136" href="#2127" class="Bound">acc</a>
  <a id="2142" href="#2083" class="Function">go</a> <a id="2145" href="#2145" class="Bound">acc</a> <a id="2149" class="Symbol">(</a><a id="2150" href="#2150" class="Bound">x</a> <a id="2152" href="#1611" class="InductiveConstructor Operator">∷</a> <a id="2154" href="#2154" class="Bound">xs</a><a id="2156" class="Symbol">)</a> <a id="2158" class="Symbol">=</a> <a id="2160" href="../code/binary/Cubical.Foundations.Prelude.html#4264" class="Function">subst</a> <a id="2166" class="Symbol">(</a><a id="2167" href="#1557" class="Datatype">Vec</a> <a id="2171" class="Symbol">_)</a> <a id="2174" class="Symbol">(</a><a id="2175" href="#1064" class="Function">+-suc</a> <a id="2181" class="Symbol">_</a> <a id="2183" class="Symbol">_)</a> <a id="2186" class="Symbol">(</a><a id="2187" href="#2083" class="Function">go</a> <a id="2190" class="Symbol">(</a><a id="2191" href="#2150" class="Bound">x</a> <a id="2193" href="#1611" class="InductiveConstructor Operator">∷</a> <a id="2195" href="#2145" class="Bound">acc</a><a id="2198" class="Symbol">)</a> <a id="2200" href="#2154" class="Bound">xs</a><a id="2202" class="Symbol">)</a>
</pre>
<p>The solution, as with so many things, is to use a fold instead of explicit recursion. Folds on vectors are a little more aggressively typed than those on lists:</p>
<pre class="Agda"><a id="vec-foldr"></a><a id="2378" href="#2378" class="Function">vec-foldr</a> <a id="2388" class="Symbol">:</a> <a id="2390" class="Symbol">(</a><a id="2391" href="#2391" class="Bound">B</a> <a id="2393" class="Symbol">:</a> <a id="2395" href="../code/binary/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="2397" class="Symbol">→</a> <a id="2399" href="../code/binary/Cubical.Core.Primitives.html#957" class="Function">Type</a> <a id="2404" href="../code/binary/Prelude.html#456" class="Generalizable">b</a><a id="2405" class="Symbol">)</a>
          <a id="2417" class="Symbol">→</a> <a id="2419" class="Symbol">(∀</a> <a id="2422" class="Symbol">{</a><a id="2423" href="#2423" class="Bound">n</a><a id="2424" class="Symbol">}</a> <a id="2426" class="Symbol">→</a> <a id="2428" href="../code/binary/Prelude.html#470" class="Generalizable">A</a> <a id="2430" class="Symbol">→</a> <a id="2432" href="#2391" class="Bound">B</a> <a id="2434" href="#2423" class="Bound">n</a> <a id="2436" class="Symbol">→</a> <a id="2438" href="#2391" class="Bound">B</a> <a id="2440" class="Symbol">(</a><a id="2441" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="2445" href="#2423" class="Bound">n</a><a id="2446" class="Symbol">))</a>
          <a id="2459" class="Symbol">→</a> <a id="2461" href="#2391" class="Bound">B</a> <a id="2463" href="../code/binary/Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a>
          <a id="2478" class="Symbol">→</a> <a id="2480" href="#1557" class="Datatype">Vec</a> <a id="2484" href="../code/binary/Prelude.html#470" class="Generalizable">A</a> <a id="2486" href="../code/binary/Prelude.html#506" class="Generalizable">n</a>
          <a id="2498" class="Symbol">→</a> <a id="2500" href="#2391" class="Bound">B</a> <a id="2502" href="../code/binary/Prelude.html#506" class="Generalizable">n</a>
<a id="2504" href="#2378" class="Function">vec-foldr</a> <a id="2514" href="#2514" class="Bound">B</a> <a id="2516" href="#2516" class="Bound">f</a> <a id="2518" href="#2518" class="Bound">b</a> <a id="2520" href="#1593" class="InductiveConstructor">[]</a> <a id="2523" class="Symbol">=</a> <a id="2525" href="#2518" class="Bound">b</a>
<a id="2527" href="#2378" class="Function">vec-foldr</a> <a id="2537" href="#2537" class="Bound">B</a> <a id="2539" href="#2539" class="Bound">f</a> <a id="2541" href="#2541" class="Bound">b</a> <a id="2543" class="Symbol">(</a><a id="2544" href="#2544" class="Bound">x</a> <a id="2546" href="#1611" class="InductiveConstructor Operator">∷</a> <a id="2548" href="#2548" class="Bound">xs</a><a id="2550" class="Symbol">)</a> <a id="2552" class="Symbol">=</a> <a id="2554" href="#2539" class="Bound">f</a> <a id="2556" href="#2544" class="Bound">x</a> <a id="2558" class="Symbol">(</a><a id="2559" href="#2378" class="Function">vec-foldr</a> <a id="2569" href="#2537" class="Bound">B</a> <a id="2571" href="#2539" class="Bound">f</a> <a id="2573" href="#2541" class="Bound">b</a> <a id="2575" href="#2548" class="Bound">xs</a><a id="2577" class="Symbol">)</a>
</pre>
<p>We allow the output type to be indexed by the list of the vector. This is a good thing, bear in mind: we need that extra information to properly type <code>reverse</code>.</p>
<p>For reverse, unfortunately, we need a <em>left</em>-leaning fold, which is a little trickier to implement than <code>vec-foldr</code>.</p>
<pre class="Agda"><a id="vec-foldl"></a><a id="2872" href="#2872" class="Function">vec-foldl</a> <a id="2882" class="Symbol">:</a> <a id="2884" class="Symbol">(</a><a id="2885" href="#2885" class="Bound">B</a> <a id="2887" class="Symbol">:</a> <a id="2889" href="../code/binary/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="2891" class="Symbol">→</a> <a id="2893" class="PrimitiveType">Set</a> <a id="2897" href="../code/binary/Prelude.html#456" class="Generalizable">b</a><a id="2898" class="Symbol">)</a>
          <a id="2910" class="Symbol">→</a> <a id="2912" class="Symbol">(∀</a> <a id="2915" class="Symbol">{</a><a id="2916" href="#2916" class="Bound">n</a><a id="2917" class="Symbol">}</a> <a id="2919" class="Symbol">→</a> <a id="2921" href="#2885" class="Bound">B</a> <a id="2923" href="#2916" class="Bound">n</a> <a id="2925" class="Symbol">→</a> <a id="2927" href="../code/binary/Prelude.html#470" class="Generalizable">A</a> <a id="2929" class="Symbol">→</a> <a id="2931" href="#2885" class="Bound">B</a> <a id="2933" class="Symbol">(</a><a id="2934" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="2938" href="#2916" class="Bound">n</a><a id="2939" class="Symbol">))</a>
          <a id="2952" class="Symbol">→</a> <a id="2954" href="#2885" class="Bound">B</a> <a id="2956" href="../code/binary/Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a>
          <a id="2971" class="Symbol">→</a> <a id="2973" href="#1557" class="Datatype">Vec</a> <a id="2977" href="../code/binary/Prelude.html#470" class="Generalizable">A</a> <a id="2979" href="../code/binary/Prelude.html#506" class="Generalizable">n</a>
          <a id="2991" class="Symbol">→</a> <a id="2993" href="#2885" class="Bound">B</a> <a id="2995" href="../code/binary/Prelude.html#506" class="Generalizable">n</a>
<a id="2997" href="#2872" class="Function">vec-foldl</a> <a id="3007" href="#3007" class="Bound">B</a> <a id="3009" href="#3009" class="Bound">f</a> <a id="3011" href="#3011" class="Bound">b</a> <a id="3013" href="#1593" class="InductiveConstructor">[]</a> <a id="3016" class="Symbol">=</a> <a id="3018" href="#3011" class="Bound">b</a>
<a id="3020" href="#2872" class="Function">vec-foldl</a> <a id="3030" href="#3030" class="Bound">B</a> <a id="3032" href="#3032" class="Bound">f</a> <a id="3034" href="#3034" class="Bound">b</a> <a id="3036" class="Symbol">(</a><a id="3037" href="#3037" class="Bound">x</a> <a id="3039" href="#1611" class="InductiveConstructor Operator">∷</a> <a id="3041" href="#3041" class="Bound">xs</a><a id="3043" class="Symbol">)</a> <a id="3045" class="Symbol">=</a> <a id="3047" href="#2872" class="Function">vec-foldl</a> <a id="3057" class="Symbol">(</a><a id="3058" href="#3030" class="Bound">B</a> <a id="3060" href="../code/binary/Prelude.html#942" class="Function Operator">∘</a> <a id="3062" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a><a id="3065" class="Symbol">)</a> <a id="3067" href="#3032" class="Bound">f</a> <a id="3069" class="Symbol">(</a><a id="3070" href="#3032" class="Bound">f</a> <a id="3072" href="#3034" class="Bound">b</a> <a id="3074" href="#3037" class="Bound">x</a><a id="3075" class="Symbol">)</a> <a id="3077" href="#3041" class="Bound">xs</a>
</pre>
<p>With this we can finally <code>reverse</code>.</p>
<pre class="Agda"><a id="vec-reverse"></a><a id="3130" href="#3130" class="Function">vec-reverse</a> <a id="3142" class="Symbol">:</a> <a id="3144" href="#1557" class="Datatype">Vec</a> <a id="3148" href="../code/binary/Prelude.html#470" class="Generalizable">A</a> <a id="3150" href="../code/binary/Prelude.html#506" class="Generalizable">n</a> <a id="3152" class="Symbol">→</a> <a id="3154" href="#1557" class="Datatype">Vec</a> <a id="3158" href="../code/binary/Prelude.html#470" class="Generalizable">A</a> <a id="3160" href="../code/binary/Prelude.html#506" class="Generalizable">n</a>
<a id="3162" href="#3130" class="Function">vec-reverse</a> <a id="3174" class="Symbol">=</a> <a id="3176" href="#2872" class="Function">vec-foldl</a> <a id="3186" class="Symbol">(</a><a id="3187" href="#1557" class="Datatype">Vec</a> <a id="3191" class="Symbol">_)</a> <a id="3194" class="Symbol">(λ</a> <a id="3197" href="#3197" class="Bound">xs</a> <a id="3200" href="#3200" class="Bound">x</a> <a id="3202" class="Symbol">→</a> <a id="3204" href="#3200" class="Bound">x</a> <a id="3206" href="#1611" class="InductiveConstructor Operator">∷</a> <a id="3208" href="#3197" class="Bound">xs</a><a id="3210" class="Symbol">)</a> <a id="3212" href="#1593" class="InductiveConstructor">[]</a>
</pre>
<p>The real trick in this function is that the type of the return value changes as we fold. If you think about it, it’s the same optimisation that we make for the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n)</annotation></semantics></math> reverse on lists: the <code>B</code> type above is the “difference list” in types, allowing us to append on to the end without <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n^2)</annotation></semantics></math> proofs.</p>
<p>As an aside, this same trick can let us type the convolve-TABA <span class="citation" data-cites="danvyThereBackAgain2005 fonerThereBackAgain2016">(Danvy and Goldberg <a href="#ref-danvyThereBackAgain2005" role="doc-biblioref">2005</a>; Foner <a href="#ref-fonerThereBackAgain2016" role="doc-biblioref">2016</a>)</span> function quite simply:</p>
<pre class="Agda"><a id="convolve"></a><a id="3636" href="#3636" class="Function">convolve</a> <a id="3645" class="Symbol">:</a> <a id="3647" href="#1557" class="Datatype">Vec</a> <a id="3651" href="../code/binary/Prelude.html#470" class="Generalizable">A</a> <a id="3653" href="../code/binary/Prelude.html#506" class="Generalizable">n</a> <a id="3655" class="Symbol">→</a> <a id="3657" href="#1557" class="Datatype">Vec</a> <a id="3661" href="../code/binary/Prelude.html#482" class="Generalizable">B</a> <a id="3663" href="../code/binary/Prelude.html#506" class="Generalizable">n</a> <a id="3665" class="Symbol">→</a> <a id="3667" href="#1557" class="Datatype">Vec</a> <a id="3671" class="Symbol">(</a><a id="3672" href="../code/binary/Prelude.html#470" class="Generalizable">A</a> <a id="3674" href="../code/binary/Prelude.html#621" class="Function Operator">×</a> <a id="3676" href="../code/binary/Prelude.html#482" class="Generalizable">B</a><a id="3677" class="Symbol">)</a> <a id="3679" href="../code/binary/Prelude.html#506" class="Generalizable">n</a>
<a id="3681" href="#3636" class="Function">convolve</a> <a id="3690" class="Symbol">=</a>
  <a id="3694" href="#2872" class="Function">vec-foldl</a>
    <a id="3708" class="Symbol">(λ</a> <a id="3711" href="#3711" class="Bound">n</a> <a id="3713" class="Symbol">→</a> <a id="3715" href="#1557" class="Datatype">Vec</a> <a id="3719" class="Symbol">_</a> <a id="3721" href="#3711" class="Bound">n</a> <a id="3723" class="Symbol">→</a> <a id="3725" href="#1557" class="Datatype">Vec</a> <a id="3729" class="Symbol">_</a> <a id="3731" href="#3711" class="Bound">n</a><a id="3732" class="Symbol">)</a>
    <a id="3738" class="Symbol">(λ</a> <a id="3741" class="Symbol">{</a> <a id="3743" href="#3743" class="Bound">k</a> <a id="3745" href="#3745" class="Bound">x</a> <a id="3747" class="Symbol">(</a><a id="3748" href="#3748" class="Bound">y</a> <a id="3750" href="#1611" class="InductiveConstructor Operator">∷</a> <a id="3752" href="#3752" class="Bound">ys</a><a id="3754" class="Symbol">)</a> <a id="3756" class="Symbol">→</a> <a id="3758" class="Symbol">(</a><a id="3759" href="#3745" class="Bound">x</a> <a id="3761" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="3763" href="#3748" class="Bound">y</a><a id="3764" class="Symbol">)</a> <a id="3766" href="#1611" class="InductiveConstructor Operator">∷</a> <a id="3768" href="#3743" class="Bound">k</a> <a id="3770" href="#3752" class="Bound">ys</a><a id="3772" class="Symbol">})</a>
    <a id="3779" class="Symbol">(λ</a> <a id="3782" href="#3782" class="Bound">_</a> <a id="3784" class="Symbol">→</a> <a id="3786" href="#1593" class="InductiveConstructor">[]</a><a id="3788" class="Symbol">)</a>
</pre>
<h1 id="binary-numbers">Binary Numbers</h1>
<p>Binary numbers come up a lot in dependently-typed programming languages: they offer an alternative representation of ℕ that’s tolerably efficient (well, depending on who’s doing the tolerating). In contrast to the Peano numbers, though, there are a huge number of ways to implement them.</p>
<p>I’m going to recommend one particular implementation over the others, but before I do I want to define a function on ℕ:</p>
<pre class="Agda"><a id="2*"></a><a id="4231" href="#4231" class="Function">2*</a> <a id="4234" class="Symbol">:</a> <a id="4236" href="../code/binary/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="4238" class="Symbol">→</a> <a id="4240" href="../code/binary/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a>
<a id="4242" href="#4231" class="Function">2*</a> <a id="4245" href="../code/binary/Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a> <a id="4250" class="Symbol">=</a> <a id="4252" href="../code/binary/Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a>
<a id="4257" href="#4231" class="Function">2*</a> <a id="4260" class="Symbol">(</a><a id="4261" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="4265" href="#4265" class="Bound">n</a><a id="4266" class="Symbol">)</a> <a id="4268" class="Symbol">=</a> <a id="4270" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="4274" class="Symbol">(</a><a id="4275" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="4279" class="Symbol">(</a><a id="4280" href="#4231" class="Function">2*</a> <a id="4283" href="#4265" class="Bound">n</a><a id="4284" class="Symbol">))</a>
</pre>
<p>In all of the implementations of binary numbers we’ll need a function like this. It is absolutely crucial that it is defined in the way above: the other obvious definition (<code>2* n = n + n</code>) is a nightmare for proofs.</p>
<p>Right, now on to some actual binary numbers. The obvious way (a list of bits) is insufficient, as it allows multiple representations of the same number (because of the trailing zeroes). Picking a more clever implementation is tricky, though. One way splits it into two types:</p>
<pre class="Agda"><a id="4794" class="Keyword">module</a> <a id="OneTerminated"></a><a id="4801" href="#4801" class="Module">OneTerminated</a> <a id="4815" class="Keyword">where</a>
  <a id="4823" class="Keyword">infixl</a> <a id="4830" class="Number">5</a> <a id="4832" href="#4893" class="InductiveConstructor Operator">_0ᵇ</a> <a id="4836" href="#4897" class="InductiveConstructor Operator">_1ᵇ</a>
  <a id="4842" class="Keyword">infixr</a> <a id="4849" class="Number">4</a> <a id="4851" href="#4949" class="InductiveConstructor Operator">𝕓_</a>

  <a id="4857" class="Keyword">data</a> <a id="OneTerminated.𝔹⁺"></a><a id="4862" href="#4862" class="Datatype">𝔹⁺</a> <a id="4865" class="Symbol">:</a> <a id="4867" class="PrimitiveType">Set</a> <a id="4871" class="Keyword">where</a>
    <a id="OneTerminated.𝔹⁺.1ᵇ"></a><a id="4881" href="#4881" class="InductiveConstructor">1ᵇ</a> <a id="4884" class="Symbol">:</a> <a id="4886" href="#4862" class="Datatype">𝔹⁺</a>
    <a id="OneTerminated.𝔹⁺._0ᵇ"></a><a id="4893" href="#4893" class="InductiveConstructor Operator">_0ᵇ</a> <a id="OneTerminated.𝔹⁺._1ᵇ"></a><a id="4897" href="#4897" class="InductiveConstructor Operator">_1ᵇ</a> <a id="4901" class="Symbol">:</a> <a id="4903" href="#4862" class="Datatype">𝔹⁺</a> <a id="4906" class="Symbol">→</a> <a id="4908" href="#4862" class="Datatype">𝔹⁺</a>

  <a id="4914" class="Keyword">data</a> <a id="OneTerminated.𝔹"></a><a id="4919" href="#4919" class="Datatype">𝔹</a> <a id="4921" class="Symbol">:</a> <a id="4923" class="PrimitiveType">Set</a> <a id="4927" class="Keyword">where</a>
    <a id="OneTerminated.𝔹.𝕓0ᵇ"></a><a id="4937" href="#4937" class="InductiveConstructor">𝕓0ᵇ</a> <a id="4941" class="Symbol">:</a> <a id="4943" href="#4919" class="Datatype">𝔹</a>
    <a id="OneTerminated.𝔹.𝕓_"></a><a id="4949" href="#4949" class="InductiveConstructor Operator">𝕓_</a> <a id="4952" class="Symbol">:</a> <a id="4954" href="#4862" class="Datatype">𝔹⁺</a> <a id="4957" class="Symbol">→</a> <a id="4959" href="#4919" class="Datatype">𝔹</a>
</pre>
<p>𝔹⁺ is the strictly positive natural numbers (i.e. the naturals starting from 1). 𝔹 adds a zero to that set. This removes the possibility for trailing zeroes, thereby making this representation unique for every natural number.</p>
<details>
<p><summary>Evaluation is pretty standard</summary></p>
<pre class="Agda">  <a id="OneTerminated.⟦_⇓⟧⁺"></a><a id="5262" href="#5262" class="Function Operator">⟦_⇓⟧⁺</a> <a id="5268" class="Symbol">:</a> <a id="5270" href="#4862" class="Datatype">𝔹⁺</a> <a id="5273" class="Symbol">→</a> <a id="5275" href="../code/binary/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a>
  <a id="5279" href="#5262" class="Function Operator">⟦</a> <a id="5281" href="#4881" class="InductiveConstructor">1ᵇ</a>   <a id="5286" href="#5262" class="Function Operator">⇓⟧⁺</a> <a id="5290" class="Symbol">=</a> <a id="5292" class="Number">1</a>
  <a id="5296" href="#5262" class="Function Operator">⟦</a> <a id="5298" href="#5298" class="Bound">x</a> <a id="5300" href="#4893" class="InductiveConstructor Operator">0ᵇ</a> <a id="5303" href="#5262" class="Function Operator">⇓⟧⁺</a> <a id="5307" class="Symbol">=</a>      <a id="5314" href="#4231" class="Function">2*</a> <a id="5317" href="#5262" class="Function Operator">⟦</a> <a id="5319" href="#5298" class="Bound">x</a> <a id="5321" href="#5262" class="Function Operator">⇓⟧⁺</a>
  <a id="5327" href="#5262" class="Function Operator">⟦</a> <a id="5329" href="#5329" class="Bound">x</a> <a id="5331" href="#4897" class="InductiveConstructor Operator">1ᵇ</a> <a id="5334" href="#5262" class="Function Operator">⇓⟧⁺</a> <a id="5338" class="Symbol">=</a> <a id="5340" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="5344" class="Symbol">(</a><a id="5345" href="#4231" class="Function">2*</a> <a id="5348" href="#5262" class="Function Operator">⟦</a> <a id="5350" href="#5329" class="Bound">x</a> <a id="5352" href="#5262" class="Function Operator">⇓⟧⁺</a><a id="5355" class="Symbol">)</a>

  <a id="OneTerminated.⟦_⇓⟧"></a><a id="5360" href="#5360" class="Function Operator">⟦_⇓⟧</a> <a id="5365" class="Symbol">:</a> <a id="5367" href="#4919" class="Datatype">𝔹</a> <a id="5369" class="Symbol">→</a> <a id="5371" href="../code/binary/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a>
  <a id="5375" href="#5360" class="Function Operator">⟦</a> <a id="5377" href="#4937" class="InductiveConstructor">𝕓0ᵇ</a>  <a id="5382" href="#5360" class="Function Operator">⇓⟧</a> <a id="5385" class="Symbol">=</a> <a id="5387" class="Number">0</a>
  <a id="5391" href="#5360" class="Function Operator">⟦</a> <a id="5393" href="#4949" class="InductiveConstructor Operator">𝕓</a> <a id="5395" href="#5395" class="Bound">x</a>  <a id="5398" href="#5360" class="Function Operator">⇓⟧</a> <a id="5401" class="Symbol">=</a> <a id="5403" href="#5262" class="Function Operator">⟦</a> <a id="5405" href="#5395" class="Bound">x</a> <a id="5407" href="#5262" class="Function Operator">⇓⟧⁺</a>
</pre>
</details>
<p>The odd syntax lets us write binary numbers in the natural way:</p>
<pre class="Agda">  <a id="5503" href="#5503" class="Function">_</a> <a id="5505" class="Symbol">:</a> <a id="5507" href="#5360" class="Function Operator">⟦</a> <a id="5509" href="#4949" class="InductiveConstructor Operator">𝕓</a> <a id="5511" href="#4881" class="InductiveConstructor">1ᵇ</a> <a id="5514" href="#4893" class="InductiveConstructor Operator">0ᵇ</a> <a id="5517" href="#4897" class="InductiveConstructor Operator">1ᵇ</a> <a id="5520" href="#5360" class="Function Operator">⇓⟧</a> <a id="5523" href="../code/binary/Agda.Builtin.Cubical.Path.html#353" class="Function Operator">≡</a> <a id="5525" class="Number">5</a>
  <a id="5529" class="Symbol">_</a> <a id="5531" class="Symbol">=</a> <a id="5533" href="../code/binary/Cubical.Foundations.Prelude.html#856" class="Function">refl</a>

  <a id="5541" href="#5541" class="Function">_</a> <a id="5543" class="Symbol">:</a> <a id="5545" href="#5360" class="Function Operator">⟦</a> <a id="5547" href="#4949" class="InductiveConstructor Operator">𝕓</a> <a id="5549" href="#4881" class="InductiveConstructor">1ᵇ</a> <a id="5552" href="#4893" class="InductiveConstructor Operator">0ᵇ</a> <a id="5555" href="#4893" class="InductiveConstructor Operator">0ᵇ</a> <a id="5558" href="#4897" class="InductiveConstructor Operator">1ᵇ</a> <a id="5561" href="#5360" class="Function Operator">⇓⟧</a> <a id="5564" href="../code/binary/Agda.Builtin.Cubical.Path.html#353" class="Function Operator">≡</a> <a id="5566" class="Number">9</a>
  <a id="5570" class="Symbol">_</a> <a id="5572" class="Symbol">=</a> <a id="5574" href="../code/binary/Cubical.Foundations.Prelude.html#856" class="Function">refl</a>
</pre>
<p>I would actually recommend this representation for most use-cases, especially when you’re using binary numbers “as binary numbers”, rather than as an abstract type for faster computation.</p>
<p>Another clever representation is one I wrote about before: the “gapless” representation. This is far too much trouble for what it’s worth.</p>
<p>Finally, my favourite representation at the moment is <em>zeroless</em>. It has a unique representation for each number, just like the two above, but it is still a list of bits. The difference is that the bits here are 1 and 2, not 0 and 1. I like to reuse types in combination with pattern synonyms (rather than defining new types), as it can often make parallels between different functions clearer.</p>
<pre class="Agda"><a id="Bit"></a><a id="6317" href="#6317" class="Function">Bit</a> <a id="6321" class="Symbol">:</a> <a id="6323" class="PrimitiveType">Set</a>
<a id="6327" href="#6317" class="Function">Bit</a> <a id="6331" class="Symbol">=</a> <a id="6333" href="../code/binary/Prelude.html#1369" class="Datatype">Bool</a>

<a id="6339" class="Keyword">pattern</a> <a id="1ᵇ"></a><a id="6347" href="#6347" class="InductiveConstructor">1ᵇ</a> <a id="6350" class="Symbol">=</a> <a id="6352" href="../code/binary/Prelude.html#1388" class="InductiveConstructor">false</a>
<a id="6358" class="Keyword">pattern</a> <a id="2ᵇ"></a><a id="6366" href="#6366" class="InductiveConstructor">2ᵇ</a> <a id="6369" class="Symbol">=</a> <a id="6371" href="../code/binary/Prelude.html#1403" class="InductiveConstructor">true</a>

<a id="𝔹"></a><a id="6377" href="#6377" class="Function">𝔹</a> <a id="6379" class="Symbol">:</a> <a id="6381" class="PrimitiveType">Set</a>
<a id="6385" href="#6377" class="Function">𝔹</a> <a id="6387" class="Symbol">=</a> <a id="6389" href="../code/binary/Prelude.html#760" class="Datatype">List</a> <a id="6394" href="#6317" class="Function">Bit</a>
</pre>
<!--
<pre class="Agda"><a id="6416" class="Keyword">variable</a>
  <a id="6427" href="#6427" class="Generalizable">d</a> <a id="6429" class="Symbol">:</a> <a id="6431" href="#6317" class="Function">Bit</a>
  <a id="6437" href="#6437" class="Generalizable">ds</a> <a id="6440" class="Symbol">:</a> <a id="6442" href="#6377" class="Function">𝔹</a>
</pre>-->
<p>Functions like <code>inc</code> are not difficult to implement:</p>
<pre class="Agda"><a id="inc"></a><a id="6515" href="#6515" class="Function">inc</a> <a id="6519" class="Symbol">:</a> <a id="6521" href="#6377" class="Function">𝔹</a> <a id="6523" class="Symbol">→</a> <a id="6525" href="#6377" class="Function">𝔹</a>
<a id="6527" href="#6515" class="Function">inc</a> <a id="6531" href="../code/binary/Prelude.html#793" class="InductiveConstructor">[]</a> <a id="6534" class="Symbol">=</a> <a id="6536" href="#6347" class="InductiveConstructor">1ᵇ</a> <a id="6539" href="../code/binary/Prelude.html#807" class="InductiveConstructor Operator">∷</a> <a id="6541" href="../code/binary/Prelude.html#793" class="InductiveConstructor">[]</a>
<a id="6544" href="#6515" class="Function">inc</a> <a id="6548" class="Symbol">(</a><a id="6549" href="#6347" class="InductiveConstructor">1ᵇ</a> <a id="6552" href="../code/binary/Prelude.html#807" class="InductiveConstructor Operator">∷</a> <a id="6554" href="#6554" class="Bound">xs</a><a id="6556" class="Symbol">)</a> <a id="6558" class="Symbol">=</a> <a id="6560" href="#6366" class="InductiveConstructor">2ᵇ</a> <a id="6563" href="../code/binary/Prelude.html#807" class="InductiveConstructor Operator">∷</a> <a id="6565" href="#6554" class="Bound">xs</a>
<a id="6568" href="#6515" class="Function">inc</a> <a id="6572" class="Symbol">(</a><a id="6573" href="#6366" class="InductiveConstructor">2ᵇ</a> <a id="6576" href="../code/binary/Prelude.html#807" class="InductiveConstructor Operator">∷</a> <a id="6578" href="#6578" class="Bound">xs</a><a id="6580" class="Symbol">)</a> <a id="6582" class="Symbol">=</a> <a id="6584" href="#6347" class="InductiveConstructor">1ᵇ</a> <a id="6587" href="../code/binary/Prelude.html#807" class="InductiveConstructor Operator">∷</a> <a id="6589" href="#6515" class="Function">inc</a> <a id="6593" href="#6578" class="Bound">xs</a>
</pre>
<p>And evaluation:</p>
<pre class="Agda"><a id="_∷⇓_"></a><a id="6626" href="#6626" class="Function Operator">_∷⇓_</a> <a id="6631" class="Symbol">:</a> <a id="6633" href="#6317" class="Function">Bit</a> <a id="6637" class="Symbol">→</a> <a id="6639" href="../code/binary/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="6641" class="Symbol">→</a> <a id="6643" href="../code/binary/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a>
<a id="6645" href="#6347" class="InductiveConstructor">1ᵇ</a> <a id="6648" href="#6626" class="Function Operator">∷⇓</a> <a id="6651" href="#6651" class="Bound">xs</a> <a id="6654" class="Symbol">=</a>      <a id="6661" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="6665" class="Symbol">(</a><a id="6666" href="#4231" class="Function">2*</a> <a id="6669" href="#6651" class="Bound">xs</a><a id="6671" class="Symbol">)</a>
<a id="6673" href="#6366" class="InductiveConstructor">2ᵇ</a> <a id="6676" href="#6626" class="Function Operator">∷⇓</a> <a id="6679" href="#6679" class="Bound">xs</a> <a id="6682" class="Symbol">=</a> <a id="6684" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="6688" class="Symbol">(</a><a id="6689" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="6693" class="Symbol">(</a><a id="6694" href="#4231" class="Function">2*</a> <a id="6697" href="#6679" class="Bound">xs</a><a id="6699" class="Symbol">))</a>

<a id="⟦_⇓⟧"></a><a id="6703" href="#6703" class="Function Operator">⟦_⇓⟧</a> <a id="6708" class="Symbol">:</a> <a id="6710" href="#6377" class="Function">𝔹</a> <a id="6712" class="Symbol">→</a> <a id="6714" href="../code/binary/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a>
<a id="6716" href="#6703" class="Function Operator">⟦_⇓⟧</a> <a id="6721" class="Symbol">=</a> <a id="6723" href="../code/binary/Prelude.html#834" class="Function">foldr</a> <a id="6729" href="#6626" class="Function Operator">_∷⇓_</a> <a id="6734" href="../code/binary/Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a>
</pre>
<p>Since we’re working in Cubical Agda, we might as well go on and prove that 𝔹 is isomorphic to ℕ. I’ll include the proof here for completeness, but it’s not relevant to the rest of the post (although it is very short, as a consequence of the simple definitions).</p>
<details>
<p><summary>Proof that 𝔹 and ℕ are isomorphic</summary></p>
<pre class="Agda"><a id="⟦_⇑⟧"></a><a id="7079" href="#7079" class="Function Operator">⟦_⇑⟧</a> <a id="7084" class="Symbol">:</a> <a id="7086" href="../code/binary/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="7088" class="Symbol">→</a> <a id="7090" href="#6377" class="Function">𝔹</a>
<a id="7092" href="#7079" class="Function Operator">⟦</a> <a id="7094" href="../code/binary/Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a>  <a id="7100" href="#7079" class="Function Operator">⇑⟧</a> <a id="7103" class="Symbol">=</a> <a id="7105" href="../code/binary/Prelude.html#793" class="InductiveConstructor">[]</a>
<a id="7108" href="#7079" class="Function Operator">⟦</a> <a id="7110" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="7114" href="#7114" class="Bound">n</a> <a id="7116" href="#7079" class="Function Operator">⇑⟧</a> <a id="7119" class="Symbol">=</a> <a id="7121" href="#6515" class="Function">inc</a> <a id="7125" href="#7079" class="Function Operator">⟦</a> <a id="7127" href="#7114" class="Bound">n</a> <a id="7129" href="#7079" class="Function Operator">⇑⟧</a>

<a id="2*⇔1ᵇ∷"></a><a id="7133" href="#7133" class="Function">2*⇔1ᵇ∷</a> <a id="7140" class="Symbol">:</a> <a id="7142" class="Symbol">∀</a> <a id="7144" href="#7144" class="Bound">n</a> <a id="7146" class="Symbol">→</a> <a id="7148" href="#6515" class="Function">inc</a> <a id="7152" href="#7079" class="Function Operator">⟦</a> <a id="7154" href="#4231" class="Function">2*</a> <a id="7157" href="#7144" class="Bound">n</a> <a id="7159" href="#7079" class="Function Operator">⇑⟧</a> <a id="7162" href="../code/binary/Agda.Builtin.Cubical.Path.html#353" class="Function Operator">≡</a> <a id="7164" href="#6347" class="InductiveConstructor">1ᵇ</a> <a id="7167" href="../code/binary/Prelude.html#807" class="InductiveConstructor Operator">∷</a> <a id="7169" href="#7079" class="Function Operator">⟦</a> <a id="7171" href="#7144" class="Bound">n</a> <a id="7173" href="#7079" class="Function Operator">⇑⟧</a>
<a id="7176" href="#7133" class="Function">2*⇔1ᵇ∷</a> <a id="7183" href="../code/binary/Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a> <a id="7188" class="Symbol">=</a> <a id="7190" href="../code/binary/Cubical.Foundations.Prelude.html#856" class="Function">refl</a>
<a id="7195" href="#7133" class="Function">2*⇔1ᵇ∷</a> <a id="7202" class="Symbol">(</a><a id="7203" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="7207" href="#7207" class="Bound">n</a><a id="7208" class="Symbol">)</a> <a id="7210" class="Symbol">=</a> <a id="7212" href="../code/binary/Cubical.Foundations.Prelude.html#1057" class="Function">cong</a> <a id="7217" class="Symbol">(</a><a id="7218" href="#6515" class="Function">inc</a> <a id="7222" href="../code/binary/Prelude.html#942" class="Function Operator">∘</a> <a id="7224" href="#6515" class="Function">inc</a><a id="7227" class="Symbol">)</a> <a id="7229" class="Symbol">(</a><a id="7230" href="#7133" class="Function">2*⇔1ᵇ∷</a> <a id="7237" href="#7207" class="Bound">n</a><a id="7238" class="Symbol">)</a>

<a id="𝔹→ℕ→𝔹"></a><a id="7241" href="#7241" class="Function">𝔹→ℕ→𝔹</a> <a id="7247" class="Symbol">:</a> <a id="7249" class="Symbol">∀</a> <a id="7251" href="#7251" class="Bound">n</a> <a id="7253" class="Symbol">→</a> <a id="7255" href="#7079" class="Function Operator">⟦</a> <a id="7257" href="#6703" class="Function Operator">⟦</a> <a id="7259" href="#7251" class="Bound">n</a> <a id="7261" href="#6703" class="Function Operator">⇓⟧</a> <a id="7264" href="#7079" class="Function Operator">⇑⟧</a> <a id="7267" href="../code/binary/Agda.Builtin.Cubical.Path.html#353" class="Function Operator">≡</a> <a id="7269" href="#7251" class="Bound">n</a>
<a id="7271" href="#7241" class="Function">𝔹→ℕ→𝔹</a> <a id="7277" href="../code/binary/Prelude.html#793" class="InductiveConstructor">[]</a> <a id="7280" class="Symbol">=</a> <a id="7282" href="../code/binary/Cubical.Foundations.Prelude.html#856" class="Function">refl</a>
<a id="7287" href="#7241" class="Function">𝔹→ℕ→𝔹</a> <a id="7293" class="Symbol">(</a><a id="7294" href="#6347" class="InductiveConstructor">1ᵇ</a> <a id="7297" href="../code/binary/Prelude.html#807" class="InductiveConstructor Operator">∷</a> <a id="7299" href="#7299" class="Bound">xs</a><a id="7301" class="Symbol">)</a> <a id="7303" class="Symbol">=</a>           <a id="7315" href="#7133" class="Function">2*⇔1ᵇ∷</a> <a id="7322" href="#6703" class="Function Operator">⟦</a> <a id="7324" href="#7299" class="Bound">xs</a> <a id="7327" href="#6703" class="Function Operator">⇓⟧</a>  <a id="7331" href="../code/binary/Cubical.Foundations.Prelude.html#1705" class="Function Operator">;</a> <a id="7333" href="../code/binary/Cubical.Foundations.Prelude.html#1057" class="Function">cong</a> <a id="7338" class="Symbol">(</a><a id="7339" href="#6347" class="InductiveConstructor">1ᵇ</a> <a id="7342" href="../code/binary/Prelude.html#807" class="InductiveConstructor Operator">∷_</a><a id="7344" class="Symbol">)</a> <a id="7346" class="Symbol">(</a><a id="7347" href="#7241" class="Function">𝔹→ℕ→𝔹</a> <a id="7353" href="#7299" class="Bound">xs</a><a id="7355" class="Symbol">)</a>
<a id="7357" href="#7241" class="Function">𝔹→ℕ→𝔹</a> <a id="7363" class="Symbol">(</a><a id="7364" href="#6366" class="InductiveConstructor">2ᵇ</a> <a id="7367" href="../code/binary/Prelude.html#807" class="InductiveConstructor Operator">∷</a> <a id="7369" href="#7369" class="Bound">xs</a><a id="7371" class="Symbol">)</a> <a id="7373" class="Symbol">=</a> <a id="7375" href="../code/binary/Cubical.Foundations.Prelude.html#1057" class="Function">cong</a> <a id="7380" href="#6515" class="Function">inc</a> <a id="7384" class="Symbol">(</a><a id="7385" href="#7133" class="Function">2*⇔1ᵇ∷</a> <a id="7392" href="#6703" class="Function Operator">⟦</a> <a id="7394" href="#7369" class="Bound">xs</a> <a id="7397" href="#6703" class="Function Operator">⇓⟧</a><a id="7399" class="Symbol">)</a> <a id="7401" href="../code/binary/Cubical.Foundations.Prelude.html#1705" class="Function Operator">;</a> <a id="7403" href="../code/binary/Cubical.Foundations.Prelude.html#1057" class="Function">cong</a> <a id="7408" class="Symbol">(</a><a id="7409" href="#6366" class="InductiveConstructor">2ᵇ</a> <a id="7412" href="../code/binary/Prelude.html#807" class="InductiveConstructor Operator">∷_</a><a id="7414" class="Symbol">)</a> <a id="7416" class="Symbol">(</a><a id="7417" href="#7241" class="Function">𝔹→ℕ→𝔹</a> <a id="7423" href="#7369" class="Bound">xs</a><a id="7425" class="Symbol">)</a>

<a id="inc⇔suc"></a><a id="7428" href="#7428" class="Function">inc⇔suc</a> <a id="7436" class="Symbol">:</a> <a id="7438" class="Symbol">∀</a> <a id="7440" href="#7440" class="Bound">n</a> <a id="7442" class="Symbol">→</a> <a id="7444" href="#6703" class="Function Operator">⟦</a> <a id="7446" href="#6515" class="Function">inc</a> <a id="7450" href="#7440" class="Bound">n</a> <a id="7452" href="#6703" class="Function Operator">⇓⟧</a> <a id="7455" href="../code/binary/Agda.Builtin.Cubical.Path.html#353" class="Function Operator">≡</a> <a id="7457" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="7461" href="#6703" class="Function Operator">⟦</a> <a id="7463" href="#7440" class="Bound">n</a> <a id="7465" href="#6703" class="Function Operator">⇓⟧</a>
<a id="7468" href="#7428" class="Function">inc⇔suc</a> <a id="7476" href="../code/binary/Prelude.html#793" class="InductiveConstructor">[]</a> <a id="7479" class="Symbol">=</a> <a id="7481" href="../code/binary/Cubical.Foundations.Prelude.html#856" class="Function">refl</a>
<a id="7486" href="#7428" class="Function">inc⇔suc</a> <a id="7494" class="Symbol">(</a><a id="7495" href="#6347" class="InductiveConstructor">1ᵇ</a> <a id="7498" href="../code/binary/Prelude.html#807" class="InductiveConstructor Operator">∷</a> <a id="7500" href="#7500" class="Bound">xs</a><a id="7502" class="Symbol">)</a> <a id="7504" class="Symbol">=</a> <a id="7506" href="../code/binary/Cubical.Foundations.Prelude.html#856" class="Function">refl</a>
<a id="7511" href="#7428" class="Function">inc⇔suc</a> <a id="7519" class="Symbol">(</a><a id="7520" href="#6366" class="InductiveConstructor">2ᵇ</a> <a id="7523" href="../code/binary/Prelude.html#807" class="InductiveConstructor Operator">∷</a> <a id="7525" href="#7525" class="Bound">xs</a><a id="7527" class="Symbol">)</a> <a id="7529" class="Symbol">=</a> <a id="7531" href="../code/binary/Cubical.Foundations.Prelude.html#1057" class="Function">cong</a> <a id="7536" class="Symbol">(</a><a id="7537" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="7541" href="../code/binary/Prelude.html#942" class="Function Operator">∘</a> <a id="7543" href="#4231" class="Function">2*</a><a id="7545" class="Symbol">)</a> <a id="7547" class="Symbol">(</a><a id="7548" href="#7428" class="Function">inc⇔suc</a> <a id="7556" href="#7525" class="Bound">xs</a><a id="7558" class="Symbol">)</a>

<a id="ℕ→𝔹→ℕ"></a><a id="7561" href="#7561" class="Function">ℕ→𝔹→ℕ</a> <a id="7567" class="Symbol">:</a> <a id="7569" class="Symbol">∀</a> <a id="7571" href="#7571" class="Bound">n</a> <a id="7573" class="Symbol">→</a> <a id="7575" href="#6703" class="Function Operator">⟦</a> <a id="7577" href="#7079" class="Function Operator">⟦</a> <a id="7579" href="#7571" class="Bound">n</a> <a id="7581" href="#7079" class="Function Operator">⇑⟧</a> <a id="7584" href="#6703" class="Function Operator">⇓⟧</a> <a id="7587" href="../code/binary/Agda.Builtin.Cubical.Path.html#353" class="Function Operator">≡</a> <a id="7589" href="#7571" class="Bound">n</a>
<a id="7591" href="#7561" class="Function">ℕ→𝔹→ℕ</a> <a id="7597" href="../code/binary/Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a>    <a id="7605" class="Symbol">=</a> <a id="7607" href="../code/binary/Cubical.Foundations.Prelude.html#856" class="Function">refl</a>
<a id="7612" href="#7561" class="Function">ℕ→𝔹→ℕ</a> <a id="7618" class="Symbol">(</a><a id="7619" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="7623" href="#7623" class="Bound">n</a><a id="7624" class="Symbol">)</a> <a id="7626" class="Symbol">=</a> <a id="7628" href="#7428" class="Function">inc⇔suc</a> <a id="7636" href="#7079" class="Function Operator">⟦</a> <a id="7638" href="#7623" class="Bound">n</a> <a id="7640" href="#7079" class="Function Operator">⇑⟧</a> <a id="7643" href="../code/binary/Cubical.Foundations.Prelude.html#1705" class="Function Operator">;</a> <a id="7645" href="../code/binary/Cubical.Foundations.Prelude.html#1057" class="Function">cong</a> <a id="7650" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="7654" class="Symbol">(</a><a id="7655" href="#7561" class="Function">ℕ→𝔹→ℕ</a> <a id="7661" href="#7623" class="Bound">n</a><a id="7662" class="Symbol">)</a>

<a id="𝔹⇔ℕ"></a><a id="7665" href="#7665" class="Function">𝔹⇔ℕ</a> <a id="7669" class="Symbol">:</a> <a id="7671" href="#6377" class="Function">𝔹</a> <a id="7673" href="../code/binary/Prelude.html#416" class="Function Operator">⇔</a> <a id="7675" href="../code/binary/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a>
<a id="7677" href="#7665" class="Function">𝔹⇔ℕ</a> <a id="7681" class="Symbol">=</a> <a id="7683" href="../code/binary/Cubical.Foundations.Isomorphism.html#710" class="InductiveConstructor">iso</a> <a id="7687" href="#6703" class="Function Operator">⟦_⇓⟧</a> <a id="7692" href="#7079" class="Function Operator">⟦_⇑⟧</a> <a id="7697" href="#7561" class="Function">ℕ→𝔹→ℕ</a> <a id="7703" href="#7241" class="Function">𝔹→ℕ→𝔹</a>
</pre>
</details>
<h1 id="binary-arrays">Binary Arrays</h1>
<p>Now on to the data structure. Here’s its type.</p>
<pre class="Agda"><a id="7799" class="Keyword">infixr</a> <a id="7806" class="Number">5</a> <a id="7808" href="#7956" class="InductiveConstructor Operator">_1∷_</a> <a id="7813" href="#7994" class="InductiveConstructor Operator">_2∷_</a>
<a id="7818" class="Keyword">data</a> <a id="Array"></a><a id="7823" href="#7823" class="Datatype">Array</a> <a id="7829" class="Symbol">(</a><a id="7830" href="#7830" class="Bound">T</a> <a id="7832" class="Symbol">:</a> <a id="7834" href="../code/binary/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="7836" class="Symbol">→</a> <a id="7838" href="../code/binary/Cubical.Core.Primitives.html#957" class="Function">Type</a> <a id="7843" href="../code/binary/Prelude.html#454" class="Generalizable">a</a><a id="7844" class="Symbol">)</a> <a id="7846" class="Symbol">:</a> <a id="7848" href="#6377" class="Function">𝔹</a> <a id="7850" class="Symbol">→</a> <a id="7852" href="../code/binary/Cubical.Core.Primitives.html#957" class="Function">Type</a> <a id="7857" href="#7843" class="Bound">a</a> <a id="7859" class="Keyword">where</a>
  <a id="Array.[]"></a><a id="7867" href="#7867" class="InductiveConstructor">[]</a>  <a id="7871" class="Symbol">:</a> <a id="7873" href="#7823" class="Datatype">Array</a> <a id="7879" href="#7830" class="Bound">T</a> <a id="7881" href="../code/binary/Prelude.html#793" class="InductiveConstructor">[]</a>
  <a id="Array._∷_"></a><a id="7886" href="#7886" class="InductiveConstructor Operator">_∷_</a> <a id="7890" class="Symbol">:</a> <a id="7892" href="#7830" class="Bound">T</a> <a id="7894" class="Symbol">(</a><a id="7895" href="../code/binary/Prelude.html#1416" class="Function">bool</a> <a id="7900" class="Number">0</a> <a id="7902" class="Number">1</a> <a id="7904" href="#6427" class="Generalizable">d</a><a id="7905" class="Symbol">)</a> <a id="7907" class="Symbol">→</a> <a id="7909" href="#7823" class="Datatype">Array</a> <a id="7915" class="Symbol">(</a><a id="7916" href="#7830" class="Bound">T</a> <a id="7918" href="../code/binary/Prelude.html#942" class="Function Operator">∘</a> <a id="7920" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a><a id="7923" class="Symbol">)</a> <a id="7925" href="#6437" class="Generalizable">ds</a> <a id="7928" class="Symbol">→</a> <a id="7930" href="#7823" class="Datatype">Array</a> <a id="7936" href="#7830" class="Bound">T</a> <a id="7938" class="Symbol">(</a><a id="7939" href="#6427" class="Generalizable">d</a> <a id="7941" href="../code/binary/Prelude.html#807" class="InductiveConstructor Operator">∷</a> <a id="7943" href="#6437" class="Generalizable">ds</a><a id="7945" class="Symbol">)</a>

<a id="7948" class="Keyword">pattern</a> <a id="_1∷_"></a><a id="7956" href="#7956" class="InductiveConstructor Operator">_1∷_</a> <a id="7961" href="#7981" class="Bound">x</a> <a id="7963" href="#7983" class="Bound">xs</a> <a id="7966" class="Symbol">=</a> <a id="7968" class="InductiveConstructor Operator">_∷_</a> <a id="7972" class="Symbol">{</a>d <a id="7975" class="Symbol">=</a> <a id="7977" href="#6347" class="InductiveConstructor">1ᵇ</a><a id="7979" class="Symbol">}</a> <a id="7981" href="#7981" class="Bound">x</a> <a id="7983" href="#7983" class="Bound">xs</a>
<a id="7986" class="Keyword">pattern</a> <a id="_2∷_"></a><a id="7994" href="#7994" class="InductiveConstructor Operator">_2∷_</a> <a id="7999" href="#8019" class="Bound">x</a> <a id="8001" href="#8021" class="Bound">xs</a> <a id="8004" class="Symbol">=</a> <a id="8006" class="InductiveConstructor Operator">_∷_</a> <a id="8010" class="Symbol">{</a>d <a id="8013" class="Symbol">=</a> <a id="8015" href="#6366" class="InductiveConstructor">2ᵇ</a><a id="8017" class="Symbol">}</a> <a id="8019" href="#8019" class="Bound">x</a> <a id="8021" href="#8021" class="Bound">xs</a>
</pre>
<p>So it is a list-like structure, which contains elements of type <code>T</code>. <code>T</code> is the type of trees in the array: making the array generic over the types of trees is a slight departure from the norm. Usually, we would just use a perfect tree or something:</p>
<pre class="Agda"><a id="8288" class="Keyword">module</a> <a id="Prelim"></a><a id="8295" href="#8295" class="Module">Prelim</a> <a id="8302" class="Keyword">where</a>
  <a id="Prelim.Perfect"></a><a id="8310" href="#8310" class="Function">Perfect</a> <a id="8318" class="Symbol">:</a> <a id="8320" class="PrimitiveType">Set</a> <a id="8324" href="../code/binary/Prelude.html#454" class="Generalizable">a</a> <a id="8326" class="Symbol">→</a> <a id="8328" href="../code/binary/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="8330" class="Symbol">→</a> <a id="8332" class="PrimitiveType">Set</a> <a id="8336" href="../code/binary/Prelude.html#454" class="Generalizable">a</a>
  <a id="8340" href="#8310" class="Function">Perfect</a> <a id="8348" href="#8348" class="Bound">A</a> <a id="8350" href="../code/binary/Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a> <a id="8355" class="Symbol">=</a> <a id="8357" href="#8348" class="Bound">A</a>
  <a id="8361" href="#8310" class="Function">Perfect</a> <a id="8369" href="#8369" class="Bound">A</a> <a id="8371" class="Symbol">(</a><a id="8372" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="8376" href="#8376" class="Bound">n</a><a id="8377" class="Symbol">)</a> <a id="8379" class="Symbol">=</a> <a id="8381" href="#8310" class="Function">Perfect</a> <a id="8389" class="Symbol">(</a><a id="8390" href="#8369" class="Bound">A</a> <a id="8392" href="../code/binary/Prelude.html#621" class="Function Operator">×</a> <a id="8394" href="#8369" class="Bound">A</a><a id="8395" class="Symbol">)</a> <a id="8397" href="#8376" class="Bound">n</a>
</pre>
<p>By making the tree type a parameter, though, we actually <em>simplify</em> some of the code for manipulating the tree. It’s basically the same trick as the type-changing parameter in <code>vec-foldl</code>.</p>
<p>As well as that, of course, we can use the array with more exotic tree types. With binomial trees, for example, we get a binomial heap:</p>
<pre class="Agda"><a id="8739" class="Keyword">mutual</a>
  <a id="8748" class="Keyword">data</a> <a id="BinomNode"></a><a id="8753" href="#8753" class="Datatype">BinomNode</a> <a id="8763" class="Symbol">(</a><a id="8764" href="#8764" class="Bound">A</a> <a id="8766" class="Symbol">:</a> <a id="8768" class="PrimitiveType">Set</a> <a id="8772" href="../code/binary/Prelude.html#454" class="Generalizable">a</a><a id="8773" class="Symbol">)</a> <a id="8775" class="Symbol">:</a> <a id="8777" href="../code/binary/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="8779" class="Symbol">→</a> <a id="8781" class="PrimitiveType">Set</a> <a id="8785" href="#8772" class="Bound">a</a> <a id="8787" class="Keyword">where</a>
    <a id="BinomNode.binom-leaf"></a><a id="8797" href="#8797" class="InductiveConstructor">binom-leaf</a>   <a id="8810" class="Symbol">:</a> <a id="8812" href="#8753" class="Datatype">BinomNode</a> <a id="8822" href="#8764" class="Bound">A</a> <a id="8824" class="Number">0</a>
    <a id="BinomNode.binom-branch"></a><a id="8830" href="#8830" class="InductiveConstructor">binom-branch</a> <a id="8843" class="Symbol">:</a> <a id="8845" href="#8899" class="Function">Binomial</a> <a id="8854" href="#8764" class="Bound">A</a> <a id="8856" href="../code/binary/Prelude.html#506" class="Generalizable">n</a> <a id="8858" class="Symbol">→</a> <a id="8860" href="#8753" class="Datatype">BinomNode</a> <a id="8870" href="#8764" class="Bound">A</a> <a id="8872" href="../code/binary/Prelude.html#506" class="Generalizable">n</a> <a id="8874" class="Symbol">→</a> <a id="8876" href="#8753" class="Datatype">BinomNode</a> <a id="8886" href="#8764" class="Bound">A</a> <a id="8888" class="Symbol">(</a><a id="8889" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="8893" href="../code/binary/Prelude.html#506" class="Generalizable">n</a><a id="8894" class="Symbol">)</a>

  <a id="Binomial"></a><a id="8899" href="#8899" class="Function">Binomial</a> <a id="8908" class="Symbol">:</a> <a id="8910" class="PrimitiveType">Set</a> <a id="8914" href="../code/binary/Prelude.html#454" class="Generalizable">a</a> <a id="8916" class="Symbol">→</a> <a id="8918" href="../code/binary/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="8920" class="Symbol">→</a> <a id="8922" class="PrimitiveType">Set</a> <a id="8926" href="../code/binary/Prelude.html#454" class="Generalizable">a</a>
  <a id="8930" href="#8899" class="Function">Binomial</a> <a id="8939" href="#8939" class="Bound">A</a> <a id="8941" href="#8941" class="Bound">n</a> <a id="8943" class="Symbol">=</a> <a id="8945" href="#8939" class="Bound">A</a> <a id="8947" href="../code/binary/Prelude.html#621" class="Function Operator">×</a> <a id="8949" href="#8753" class="Datatype">BinomNode</a> <a id="8959" href="#8939" class="Bound">A</a> <a id="8961" href="#8941" class="Bound">n</a>
</pre>
<p>But we’ll stick to the random-access lists for now.</p>
<h1 id="top-down-and-bottom-up-trees">Top-down and Bottom-up Trees</h1>
<p>The perfect trees above are actually a specific instance of a more general data type: exponentiations of functors.</p>
<pre class="Agda"><a id="_^_"></a><a id="9177" href="#9177" class="Function Operator">_^_</a> <a id="9181" class="Symbol">:</a> <a id="9183" class="Symbol">(</a><a id="9184" class="PrimitiveType">Set</a> <a id="9188" href="../code/binary/Prelude.html#454" class="Generalizable">a</a> <a id="9190" class="Symbol">→</a> <a id="9192" class="PrimitiveType">Set</a> <a id="9196" href="../code/binary/Prelude.html#454" class="Generalizable">a</a><a id="9197" class="Symbol">)</a> <a id="9199" class="Symbol">→</a> <a id="9201" href="../code/binary/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="9203" class="Symbol">→</a> <a id="9205" class="PrimitiveType">Set</a> <a id="9209" href="../code/binary/Prelude.html#454" class="Generalizable">a</a> <a id="9211" class="Symbol">→</a> <a id="9213" class="PrimitiveType">Set</a> <a id="9217" href="../code/binary/Prelude.html#454" class="Generalizable">a</a>
<a id="9219" class="Symbol">(</a><a id="9220" href="#9220" class="Bound">F</a> <a id="9222" href="#9177" class="Function Operator">^</a> <a id="9224" href="../code/binary/Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a> <a id="9229" class="Symbol">)</a> <a id="9231" href="#9231" class="Bound">A</a> <a id="9233" class="Symbol">=</a> <a id="9235" href="#9231" class="Bound">A</a>
<a id="9237" class="Symbol">(</a><a id="9238" href="#9238" class="Bound">F</a> <a id="9240" href="#9177" class="Function Operator">^</a> <a id="9242" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="9246" href="#9246" class="Bound">n</a><a id="9247" class="Symbol">)</a> <a id="9249" href="#9249" class="Bound">A</a> <a id="9251" class="Symbol">=</a> <a id="9253" class="Symbol">(</a><a id="9254" href="#9238" class="Bound">F</a> <a id="9256" href="#9177" class="Function Operator">^</a> <a id="9258" href="#9246" class="Bound">n</a><a id="9259" class="Symbol">)</a> <a id="9261" class="Symbol">(</a><a id="9262" href="#9238" class="Bound">F</a> <a id="9264" href="#9249" class="Bound">A</a><a id="9265" class="Symbol">)</a>

<a id="Nest"></a><a id="9268" href="#9268" class="Function">Nest</a> <a id="9273" class="Symbol">:</a> <a id="9275" class="Symbol">(</a><a id="9276" class="PrimitiveType">Set</a> <a id="9280" href="../code/binary/Prelude.html#454" class="Generalizable">a</a> <a id="9282" class="Symbol">→</a> <a id="9284" class="PrimitiveType">Set</a> <a id="9288" href="../code/binary/Prelude.html#454" class="Generalizable">a</a><a id="9289" class="Symbol">)</a> <a id="9291" class="Symbol">→</a> <a id="9293" class="PrimitiveType">Set</a> <a id="9297" href="../code/binary/Prelude.html#454" class="Generalizable">a</a> <a id="9299" class="Symbol">→</a> <a id="9301" href="../code/binary/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="9303" class="Symbol">→</a> <a id="9305" class="PrimitiveType">Set</a> <a id="9309" href="../code/binary/Prelude.html#454" class="Generalizable">a</a>
<a id="9311" href="#9268" class="Function">Nest</a> <a id="9316" href="#9316" class="Bound">F</a> <a id="9318" href="#9318" class="Bound">A</a> <a id="9320" href="#9320" class="Bound">n</a> <a id="9322" class="Symbol">=</a> <a id="9324" class="Symbol">(</a><a id="9325" href="#9316" class="Bound">F</a> <a id="9327" href="#9177" class="Function Operator">^</a> <a id="9329" href="#9320" class="Bound">n</a><a id="9330" class="Symbol">)</a> <a id="9332" href="#9318" class="Bound">A</a>

<a id="Pair"></a><a id="9335" href="#9335" class="Function">Pair</a> <a id="9340" class="Symbol">:</a> <a id="9342" class="PrimitiveType">Set</a> <a id="9346" href="../code/binary/Prelude.html#454" class="Generalizable">a</a> <a id="9348" class="Symbol">→</a> <a id="9350" class="PrimitiveType">Set</a> <a id="9354" href="../code/binary/Prelude.html#454" class="Generalizable">a</a>
<a id="9356" href="#9335" class="Function">Pair</a> <a id="9361" href="#9361" class="Bound">A</a> <a id="9363" class="Symbol">=</a> <a id="9365" href="#9361" class="Bound">A</a> <a id="9367" href="../code/binary/Prelude.html#621" class="Function Operator">×</a> <a id="9369" href="#9361" class="Bound">A</a>

<a id="Perfect"></a><a id="9372" href="#9372" class="Function">Perfect</a> <a id="9380" class="Symbol">:</a> <a id="9382" class="PrimitiveType">Set</a> <a id="9386" href="../code/binary/Prelude.html#454" class="Generalizable">a</a> <a id="9388" class="Symbol">→</a> <a id="9390" href="../code/binary/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="9392" class="Symbol">→</a> <a id="9394" class="PrimitiveType">Set</a> <a id="9398" href="../code/binary/Prelude.html#454" class="Generalizable">a</a>
<a id="9400" href="#9372" class="Function">Perfect</a> <a id="9408" class="Symbol">=</a> <a id="9410" href="#9268" class="Function">Nest</a> <a id="9415" href="#9335" class="Function">Pair</a>
</pre>
<!--

<pre class="Agda"><a id="9439" class="Keyword">variable</a>
  <a id="9450" href="#9450" class="Generalizable">F</a> <a id="9452" class="Symbol">:</a> <a id="9454" class="PrimitiveType">Set</a> <a id="9458" href="../code/binary/Prelude.html#454" class="Generalizable">a</a> <a id="9460" class="Symbol">→</a> <a id="9462" class="PrimitiveType">Set</a> <a id="9466" href="../code/binary/Prelude.html#454" class="Generalizable">a</a>
</pre>
-->
<p>It’s a nested datatype, built in a bottom-up way. This is in contrast to, say, the binomial trees above, which are top-down.</p>
<h1 id="construction">Construction</h1>
<p>Our first function on the array is <code>cons</code>, which inserts an element:</p>
<pre class="Agda"><a id="cons"></a><a id="9698" href="#9698" class="Function">cons</a> <a id="9703" class="Symbol">:</a> <a id="9705" class="Symbol">(∀</a> <a id="9708" href="#9708" class="Bound">n</a> <a id="9710" class="Symbol">→</a> <a id="9712" href="#846" class="Generalizable">T</a> <a id="9714" href="#9708" class="Bound">n</a> <a id="9716" class="Symbol">→</a> <a id="9718" href="#846" class="Generalizable">T</a> <a id="9720" href="#9708" class="Bound">n</a> <a id="9722" class="Symbol">→</a> <a id="9724" href="#846" class="Generalizable">T</a> <a id="9726" class="Symbol">(</a><a id="9727" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="9731" href="#9708" class="Bound">n</a><a id="9732" class="Symbol">))</a>
     <a id="9740" class="Symbol">→</a> <a id="9742" href="#846" class="Generalizable">T</a> <a id="9744" class="Number">0</a> <a id="9746" class="Symbol">→</a> <a id="9748" href="#7823" class="Datatype">Array</a> <a id="9754" href="#846" class="Generalizable">T</a> <a id="9756" href="#6437" class="Generalizable">ds</a> <a id="9759" class="Symbol">→</a> <a id="9761" href="#7823" class="Datatype">Array</a> <a id="9767" href="#846" class="Generalizable">T</a> <a id="9769" class="Symbol">(</a><a id="9770" href="#6515" class="Function">inc</a> <a id="9774" href="#6437" class="Generalizable">ds</a><a id="9776" class="Symbol">)</a>
<a id="9778" href="#9698" class="Function">cons</a> <a id="9783" href="#9783" class="Bound">branch</a> <a id="9790" href="#9790" class="Bound">x</a> <a id="9792" href="#7867" class="InductiveConstructor">[]</a> <a id="9795" class="Symbol">=</a> <a id="9797" href="#9790" class="Bound">x</a> <a id="9799" href="#7956" class="InductiveConstructor Operator">1∷</a> <a id="9802" href="#7867" class="InductiveConstructor">[]</a>
<a id="9805" href="#9698" class="Function">cons</a> <a id="9810" href="#9810" class="Bound">branch</a> <a id="9817" href="#9817" class="Bound">x</a> <a id="9819" class="Symbol">(</a><a id="9820" href="#9820" class="Bound">y</a> <a id="9822" href="#7956" class="InductiveConstructor Operator">1∷</a> <a id="9825" href="#9825" class="Bound">ys</a><a id="9827" class="Symbol">)</a> <a id="9829" class="Symbol">=</a> <a id="9831" href="#9810" class="Bound">branch</a> <a id="9838" class="Number">0</a> <a id="9840" href="#9817" class="Bound">x</a> <a id="9842" href="#9820" class="Bound">y</a> <a id="9844" href="#7994" class="InductiveConstructor Operator">2∷</a> <a id="9847" href="#9825" class="Bound">ys</a>
<a id="9850" href="#9698" class="Function">cons</a> <a id="9855" href="#9855" class="Bound">branch</a> <a id="9862" href="#9862" class="Bound">x</a> <a id="9864" class="Symbol">(</a><a id="9865" href="#9865" class="Bound">y</a> <a id="9867" href="#7994" class="InductiveConstructor Operator">2∷</a> <a id="9870" href="#9870" class="Bound">ys</a><a id="9872" class="Symbol">)</a> <a id="9874" class="Symbol">=</a> <a id="9876" href="#9862" class="Bound">x</a> <a id="9878" href="#7956" class="InductiveConstructor Operator">1∷</a> <a id="9881" href="#9698" class="Function">cons</a> <a id="9886" class="Symbol">(</a><a id="9887" href="#9855" class="Bound">branch</a> <a id="9894" href="../code/binary/Prelude.html#942" class="Function Operator">∘</a> <a id="9896" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a><a id="9899" class="Symbol">)</a> <a id="9901" href="#9865" class="Bound">y</a> <a id="9903" href="#9870" class="Bound">ys</a>
</pre>
<p>Since we’re generic over the type of trees, we need to pass in the “branch” constructor (or function) for whatever tree type we end up using. Here’s how we’d implement such a branch function for perfect trees.</p>
<pre class="Agda"><a id="perf-branch"></a><a id="10130" href="#10130" class="Function">perf-branch</a> <a id="10142" class="Symbol">:</a> <a id="10144" class="Symbol">∀</a> <a id="10146" href="#10146" class="Bound">n</a> <a id="10148" class="Symbol">→</a> <a id="10150" href="#9372" class="Function">Perfect</a> <a id="10158" href="../code/binary/Prelude.html#470" class="Generalizable">A</a> <a id="10160" href="#10146" class="Bound">n</a> <a id="10162" class="Symbol">→</a> <a id="10164" href="#9372" class="Function">Perfect</a> <a id="10172" href="../code/binary/Prelude.html#470" class="Generalizable">A</a> <a id="10174" href="#10146" class="Bound">n</a> <a id="10176" class="Symbol">→</a> <a id="10178" href="#9372" class="Function">Perfect</a> <a id="10186" href="../code/binary/Prelude.html#470" class="Generalizable">A</a> <a id="10188" class="Symbol">(</a><a id="10189" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="10193" href="#10146" class="Bound">n</a><a id="10194" class="Symbol">)</a>
<a id="10196" href="#10130" class="Function">perf-branch</a> <a id="10208" href="../code/binary/Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a> <a id="10213" class="Symbol">=</a> <a id="10215" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">_,_</a>
<a id="10219" href="#10130" class="Function">perf-branch</a> <a id="10231" class="Symbol">(</a><a id="10232" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="10236" href="#10236" class="Bound">n</a><a id="10237" class="Symbol">)</a> <a id="10239" class="Symbol">=</a> <a id="10241" href="#10130" class="Function">perf-branch</a> <a id="10253" href="#10236" class="Bound">n</a>
</pre>
<p>One issue here is that the <code>perf-branch</code> function probably doesn’t optimise to the correct complexity, because the <code>n</code> has to be scrutinised repeatedly. The alternative is to define a <code>cons</code> for nested types, like so:</p>
<pre class="Agda"><a id="nest-cons"></a><a id="10487" href="#10487" class="Function">nest-cons</a> <a id="10497" class="Symbol">:</a> <a id="10499" class="Symbol">(∀</a> <a id="10502" class="Symbol">{</a><a id="10503" href="#10503" class="Bound">A</a><a id="10504" class="Symbol">}</a> <a id="10506" class="Symbol">→</a> <a id="10508" href="#10503" class="Bound">A</a> <a id="10510" class="Symbol">→</a> <a id="10512" href="#10503" class="Bound">A</a> <a id="10514" class="Symbol">→</a> <a id="10516" href="#9450" class="Generalizable">F</a> <a id="10518" href="#10503" class="Bound">A</a><a id="10519" class="Symbol">)</a> <a id="10521" class="Symbol">→</a> <a id="10523" href="../code/binary/Prelude.html#470" class="Generalizable">A</a> <a id="10525" class="Symbol">→</a> <a id="10527" href="#7823" class="Datatype">Array</a> <a id="10533" class="Symbol">(</a><a id="10534" href="#9268" class="Function">Nest</a> <a id="10539" href="#9450" class="Generalizable">F</a> <a id="10541" href="../code/binary/Prelude.html#470" class="Generalizable">A</a><a id="10542" class="Symbol">)</a> <a id="10544" href="#6437" class="Generalizable">ds</a> <a id="10547" class="Symbol">→</a> <a id="10549" href="#7823" class="Datatype">Array</a> <a id="10555" class="Symbol">(</a><a id="10556" href="#9268" class="Function">Nest</a> <a id="10561" href="#9450" class="Generalizable">F</a> <a id="10563" href="../code/binary/Prelude.html#470" class="Generalizable">A</a><a id="10564" class="Symbol">)</a> <a id="10566" class="Symbol">(</a><a id="10567" href="#6515" class="Function">inc</a> <a id="10571" href="#6437" class="Generalizable">ds</a><a id="10573" class="Symbol">)</a>
<a id="10575" href="#10487" class="Function">nest-cons</a> <a id="10585" href="#10585" class="Bound Operator">_∙_</a> <a id="10589" href="#10589" class="Bound">x</a> <a id="10591" href="#7867" class="InductiveConstructor">[]</a> <a id="10594" class="Symbol">=</a> <a id="10596" href="#10589" class="Bound">x</a> <a id="10598" href="#7886" class="InductiveConstructor Operator">∷</a> <a id="10600" href="#7867" class="InductiveConstructor">[]</a>
<a id="10603" href="#10487" class="Function">nest-cons</a> <a id="10613" href="#10613" class="Bound Operator">_∙_</a> <a id="10617" href="#10617" class="Bound">x</a> <a id="10619" class="Symbol">(</a><a id="10620" href="#10620" class="Bound">y</a> <a id="10622" href="#7956" class="InductiveConstructor Operator">1∷</a> <a id="10625" href="#10625" class="Bound">ys</a><a id="10627" class="Symbol">)</a> <a id="10629" class="Symbol">=</a> <a id="10631" class="Symbol">(</a><a id="10632" href="#10617" class="Bound">x</a> <a id="10634" href="#10613" class="Bound Operator">∙</a> <a id="10636" href="#10620" class="Bound">y</a><a id="10637" class="Symbol">)</a> <a id="10639" href="#7994" class="InductiveConstructor Operator">2∷</a> <a id="10642" href="#10625" class="Bound">ys</a>
<a id="10645" href="#10487" class="Function">nest-cons</a> <a id="10655" href="#10655" class="Bound Operator">_∙_</a> <a id="10659" href="#10659" class="Bound">x</a> <a id="10661" class="Symbol">(</a><a id="10662" href="#10662" class="Bound">y</a> <a id="10664" href="#7994" class="InductiveConstructor Operator">2∷</a> <a id="10667" href="#10667" class="Bound">ys</a><a id="10669" class="Symbol">)</a> <a id="10671" class="Symbol">=</a> <a id="10673" href="#10659" class="Bound">x</a> <a id="10675" href="#7886" class="InductiveConstructor Operator">∷</a> <a id="10677" href="#10487" class="Function">nest-cons</a> <a id="10687" href="#10655" class="Bound Operator">_∙_</a> <a id="10691" href="#10662" class="Bound">y</a> <a id="10693" href="#10667" class="Bound">ys</a>

<a id="perf-cons"></a><a id="10697" href="#10697" class="Function">perf-cons</a> <a id="10707" class="Symbol">:</a> <a id="10709" href="../code/binary/Prelude.html#470" class="Generalizable">A</a> <a id="10711" class="Symbol">→</a> <a id="10713" href="#7823" class="Datatype">Array</a> <a id="10719" class="Symbol">(</a><a id="10720" href="#9372" class="Function">Perfect</a> <a id="10728" href="../code/binary/Prelude.html#470" class="Generalizable">A</a><a id="10729" class="Symbol">)</a> <a id="10731" href="#6437" class="Generalizable">ds</a> <a id="10734" class="Symbol">→</a> <a id="10736" href="#7823" class="Datatype">Array</a> <a id="10742" class="Symbol">(</a><a id="10743" href="#9372" class="Function">Perfect</a> <a id="10751" href="../code/binary/Prelude.html#470" class="Generalizable">A</a><a id="10752" class="Symbol">)</a> <a id="10754" class="Symbol">(</a><a id="10755" href="#6515" class="Function">inc</a> <a id="10759" href="#6437" class="Generalizable">ds</a><a id="10761" class="Symbol">)</a>
<a id="10763" href="#10697" class="Function">perf-cons</a> <a id="10773" class="Symbol">=</a> <a id="10775" href="#10487" class="Function">nest-cons</a> <a id="10785" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">_,_</a>
</pre>
<h1 id="indexing">Indexing</h1>
<p>Again, we’re going to keep things general, allowing multiple index types. For those index types we’ll need a type like <code>Fin</code> but for binary numbers.</p>
<pre class="Agda"><a id="10964" class="Keyword">data</a> <a id="Fin𝔹"></a><a id="10969" href="#10969" class="Datatype">Fin𝔹</a> <a id="10974" class="Symbol">(</a><a id="10975" href="#10975" class="Bound">A</a> <a id="10977" class="Symbol">:</a> <a id="10979" class="PrimitiveType">Set</a> <a id="10983" href="../code/binary/Prelude.html#454" class="Generalizable">a</a><a id="10984" class="Symbol">)</a> <a id="10986" class="Symbol">:</a> <a id="10988" href="#6377" class="Function">𝔹</a> <a id="10990" class="Symbol">→</a> <a id="10992" href="../code/binary/Cubical.Core.Primitives.html#957" class="Function">Type</a> <a id="10997" href="#10983" class="Bound">a</a> <a id="10999" class="Keyword">where</a>
  <a id="Fin𝔹.here₁"></a><a id="11007" href="#11007" class="InductiveConstructor">here₁</a> <a id="11013" class="Symbol">:</a>                       <a id="11037" href="#10969" class="Datatype">Fin𝔹</a> <a id="11042" href="#10975" class="Bound">A</a> <a id="11044" class="Symbol">(</a><a id="11045" href="#6347" class="InductiveConstructor">1ᵇ</a> <a id="11048" href="../code/binary/Prelude.html#807" class="InductiveConstructor Operator">∷</a> <a id="11050" href="#6437" class="Generalizable">ds</a><a id="11052" class="Symbol">)</a>
  <a id="Fin𝔹.here₂"></a><a id="11056" href="#11056" class="InductiveConstructor">here₂</a> <a id="11062" class="Symbol">:</a> <a id="11064" class="Symbol">(</a><a id="11065" href="#11065" class="Bound">i</a> <a id="11067" class="Symbol">:</a> <a id="11069" href="#10975" class="Bound">A</a><a id="11070" class="Symbol">)</a>             <a id="11084" class="Symbol">→</a> <a id="11086" href="#10969" class="Datatype">Fin𝔹</a> <a id="11091" href="#10975" class="Bound">A</a> <a id="11093" class="Symbol">(</a><a id="11094" href="#6366" class="InductiveConstructor">2ᵇ</a> <a id="11097" href="../code/binary/Prelude.html#807" class="InductiveConstructor Operator">∷</a> <a id="11099" href="#6437" class="Generalizable">ds</a><a id="11101" class="Symbol">)</a>
  <a id="Fin𝔹.there"></a><a id="11105" href="#11105" class="InductiveConstructor">there</a> <a id="11111" class="Symbol">:</a> <a id="11113" class="Symbol">(</a><a id="11114" href="#11114" class="Bound">i</a> <a id="11116" class="Symbol">:</a> <a id="11118" href="#10975" class="Bound">A</a><a id="11119" class="Symbol">)</a> <a id="11121" class="Symbol">→</a> <a id="11123" href="#10969" class="Datatype">Fin𝔹</a> <a id="11128" href="#10975" class="Bound">A</a> <a id="11130" href="#6437" class="Generalizable">ds</a> <a id="11133" class="Symbol">→</a> <a id="11135" href="#10969" class="Datatype">Fin𝔹</a> <a id="11140" href="#10975" class="Bound">A</a> <a id="11142" class="Symbol">(</a><a id="11143" href="#6427" class="Generalizable">d</a>  <a id="11146" href="../code/binary/Prelude.html#807" class="InductiveConstructor Operator">∷</a> <a id="11148" href="#6437" class="Generalizable">ds</a><a id="11150" class="Symbol">)</a>

<a id="lookup"></a><a id="11153" href="#11153" class="Function">lookup</a> <a id="11160" class="Symbol">:</a> <a id="11162" class="Symbol">(∀</a> <a id="11165" class="Symbol">{</a><a id="11166" href="#11166" class="Bound">n</a><a id="11167" class="Symbol">}</a> <a id="11169" class="Symbol">→</a> <a id="11171" href="#874" class="Generalizable">P</a> <a id="11173" class="Symbol">→</a> <a id="11175" href="#846" class="Generalizable">T</a> <a id="11177" class="Symbol">(</a><a id="11178" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="11182" href="#11166" class="Bound">n</a><a id="11183" class="Symbol">)</a> <a id="11185" class="Symbol">→</a> <a id="11187" href="#846" class="Generalizable">T</a> <a id="11189" href="#11166" class="Bound">n</a><a id="11190" class="Symbol">)</a>
       <a id="11199" class="Symbol">→</a> <a id="11201" href="#7823" class="Datatype">Array</a> <a id="11207" href="#846" class="Generalizable">T</a> <a id="11209" href="#6437" class="Generalizable">ds</a>
       <a id="11219" class="Symbol">→</a> <a id="11221" href="#10969" class="Datatype">Fin𝔹</a> <a id="11226" href="#874" class="Generalizable">P</a> <a id="11228" href="#6437" class="Generalizable">ds</a>
       <a id="11238" class="Symbol">→</a> <a id="11240" href="#846" class="Generalizable">T</a> <a id="11242" class="Number">0</a>
<a id="11244" href="#11153" class="Function">lookup</a> <a id="11251" href="#11251" class="Bound">ind</a> <a id="11255" class="Symbol">(</a><a id="11256" href="#11256" class="Bound">x</a> <a id="11258" href="#7886" class="InductiveConstructor Operator">∷</a> <a id="11260" href="#11260" class="Bound">xs</a><a id="11262" class="Symbol">)</a> <a id="11264" href="#11007" class="InductiveConstructor">here₁</a> <a id="11270" class="Symbol">=</a> <a id="11272" href="#11256" class="Bound">x</a>
<a id="11274" href="#11153" class="Function">lookup</a> <a id="11281" href="#11281" class="Bound">ind</a> <a id="11285" class="Symbol">(</a><a id="11286" href="#11286" class="Bound">x</a> <a id="11288" href="#7886" class="InductiveConstructor Operator">∷</a> <a id="11290" href="#11290" class="Bound">xs</a><a id="11292" class="Symbol">)</a> <a id="11294" class="Symbol">(</a><a id="11295" href="#11056" class="InductiveConstructor">here₂</a> <a id="11301" href="#11301" class="Bound">i</a><a id="11302" class="Symbol">)</a> <a id="11304" class="Symbol">=</a> <a id="11306" href="#11281" class="Bound">ind</a> <a id="11310" href="#11301" class="Bound">i</a> <a id="11312" href="#11286" class="Bound">x</a>
<a id="11314" href="#11153" class="Function">lookup</a> <a id="11321" href="#11321" class="Bound">ind</a> <a id="11325" class="Symbol">(</a><a id="11326" href="#11326" class="Bound">x</a> <a id="11328" href="#7886" class="InductiveConstructor Operator">∷</a> <a id="11330" href="#11330" class="Bound">xs</a><a id="11332" class="Symbol">)</a> <a id="11334" class="Symbol">(</a><a id="11335" href="#11105" class="InductiveConstructor">there</a> <a id="11341" href="#11341" class="Bound">i</a> <a id="11343" href="#11343" class="Bound">is</a><a id="11345" class="Symbol">)</a> <a id="11347" class="Symbol">=</a> <a id="11349" href="#11321" class="Bound">ind</a> <a id="11353" href="#11341" class="Bound">i</a> <a id="11355" class="Symbol">(</a><a id="11356" href="#11153" class="Function">lookup</a> <a id="11363" href="#11321" class="Bound">ind</a> <a id="11367" href="#11330" class="Bound">xs</a> <a id="11370" href="#11343" class="Bound">is</a><a id="11372" class="Symbol">)</a>

<a id="nest-lookup"></a><a id="11375" href="#11375" class="Function">nest-lookup</a> <a id="11387" class="Symbol">:</a> <a id="11389" class="Symbol">(∀</a> <a id="11392" class="Symbol">{</a><a id="11393" href="#11393" class="Bound">A</a><a id="11394" class="Symbol">}</a> <a id="11396" class="Symbol">→</a> <a id="11398" href="#874" class="Generalizable">P</a> <a id="11400" class="Symbol">→</a> <a id="11402" href="#9450" class="Generalizable">F</a> <a id="11404" href="#11393" class="Bound">A</a> <a id="11406" class="Symbol">→</a> <a id="11408" href="#11393" class="Bound">A</a><a id="11409" class="Symbol">)</a>
            <a id="11423" class="Symbol">→</a> <a id="11425" href="#7823" class="Datatype">Array</a> <a id="11431" class="Symbol">(</a><a id="11432" href="#9268" class="Function">Nest</a> <a id="11437" href="#9450" class="Generalizable">F</a> <a id="11439" href="../code/binary/Prelude.html#470" class="Generalizable">A</a><a id="11440" class="Symbol">)</a> <a id="11442" href="#6437" class="Generalizable">ds</a>
            <a id="11457" class="Symbol">→</a> <a id="11459" href="#10969" class="Datatype">Fin𝔹</a> <a id="11464" href="#874" class="Generalizable">P</a> <a id="11466" href="#6437" class="Generalizable">ds</a>
            <a id="11481" class="Symbol">→</a> <a id="11483" href="../code/binary/Prelude.html#470" class="Generalizable">A</a>
<a id="11485" href="#11375" class="Function">nest-lookup</a> <a id="11497" href="#11497" class="Bound">ind</a> <a id="11501" class="Symbol">(</a><a id="11502" href="#11502" class="Bound">x</a> <a id="11504" href="#7886" class="InductiveConstructor Operator">∷</a> <a id="11506" href="#11506" class="Bound">xs</a><a id="11508" class="Symbol">)</a> <a id="11510" href="#11007" class="InductiveConstructor">here₁</a> <a id="11516" class="Symbol">=</a> <a id="11518" href="#11502" class="Bound">x</a>
<a id="11520" href="#11375" class="Function">nest-lookup</a> <a id="11532" href="#11532" class="Bound">ind</a> <a id="11536" class="Symbol">(</a><a id="11537" href="#11537" class="Bound">x</a> <a id="11539" href="#7886" class="InductiveConstructor Operator">∷</a> <a id="11541" href="#11541" class="Bound">xs</a><a id="11543" class="Symbol">)</a> <a id="11545" class="Symbol">(</a><a id="11546" href="#11056" class="InductiveConstructor">here₂</a> <a id="11552" href="#11552" class="Bound">i</a><a id="11553" class="Symbol">)</a> <a id="11555" class="Symbol">=</a> <a id="11557" href="#11532" class="Bound">ind</a> <a id="11561" href="#11552" class="Bound">i</a> <a id="11563" href="#11537" class="Bound">x</a>
<a id="11565" href="#11375" class="Function">nest-lookup</a> <a id="11577" href="#11577" class="Bound">ind</a> <a id="11581" class="Symbol">(</a><a id="11582" href="#11582" class="Bound">x</a> <a id="11584" href="#7886" class="InductiveConstructor Operator">∷</a> <a id="11586" href="#11586" class="Bound">xs</a><a id="11588" class="Symbol">)</a> <a id="11590" class="Symbol">(</a><a id="11591" href="#11105" class="InductiveConstructor">there</a> <a id="11597" href="#11597" class="Bound">i</a> <a id="11599" href="#11599" class="Bound">is</a><a id="11601" class="Symbol">)</a> <a id="11603" class="Symbol">=</a> <a id="11605" href="#11577" class="Bound">ind</a> <a id="11609" href="#11597" class="Bound">i</a> <a id="11611" class="Symbol">(</a><a id="11612" href="#11375" class="Function">nest-lookup</a> <a id="11624" href="#11577" class="Bound">ind</a> <a id="11628" href="#11586" class="Bound">xs</a> <a id="11631" href="#11599" class="Bound">is</a><a id="11633" class="Symbol">)</a>
</pre>
<p>We’ll once more use perfect to show how these generic functions can be concretised. For the index types into a perfect tree, we will use a <code>Bool</code>.</p>
<pre class="Agda"><a id="perf-lookup"></a><a id="11797" href="#11797" class="Function">perf-lookup</a> <a id="11809" class="Symbol">:</a> <a id="11811" href="#7823" class="Datatype">Array</a> <a id="11817" class="Symbol">(</a><a id="11818" href="#9372" class="Function">Perfect</a> <a id="11826" href="../code/binary/Prelude.html#470" class="Generalizable">A</a><a id="11827" class="Symbol">)</a> <a id="11829" href="#6437" class="Generalizable">ds</a> <a id="11832" class="Symbol">→</a> <a id="11834" href="#10969" class="Datatype">Fin𝔹</a> <a id="11839" href="../code/binary/Prelude.html#1369" class="Datatype">Bool</a> <a id="11844" href="#6437" class="Generalizable">ds</a> <a id="11847" class="Symbol">→</a> <a id="11849" href="../code/binary/Prelude.html#470" class="Generalizable">A</a>
<a id="11851" href="#11797" class="Function">perf-lookup</a> <a id="11863" class="Symbol">=</a> <a id="11865" href="#11375" class="Function">nest-lookup</a> <a id="11877" class="Symbol">(</a><a id="11878" href="../code/binary/Prelude.html#1416" class="Function">bool</a> <a id="11883" href="../code/binary/Agda.Builtin.Sigma.html#225" class="Field">fst</a> <a id="11887" href="../code/binary/Agda.Builtin.Sigma.html#237" class="Field">snd</a><a id="11890" class="Symbol">)</a>
</pre>
<h1 id="folding">Folding</h1>
<p>This next function is quite difficult to get right: a fold. We want to consume the binary array into a unary, cons-list type thing. Similarly to <code>foldl</code> on vectors, we will need to change the return type as we fold, but we will <em>also</em> need to convert from binary to unary, <em>as we fold</em>. The key ingredient is the following function:</p>
<pre class="Agda"><a id="2^_*_"></a><a id="12250" href="#12250" class="Function Operator">2^_*_</a> <a id="12256" class="Symbol">:</a> <a id="12258" href="../code/binary/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="12260" class="Symbol">→</a> <a id="12262" href="../code/binary/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="12264" class="Symbol">→</a> <a id="12266" href="../code/binary/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a>
<a id="12268" href="#12250" class="Function Operator">2^</a> <a id="12271" href="../code/binary/Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a>  <a id="12277" href="#12250" class="Function Operator">*</a> <a id="12279" href="#12279" class="Bound">n</a> <a id="12281" class="Symbol">=</a> <a id="12283" href="#12279" class="Bound">n</a>
<a id="12285" href="#12250" class="Function Operator">2^</a> <a id="12288" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="12292" href="#12292" class="Bound">m</a> <a id="12294" href="#12250" class="Function Operator">*</a> <a id="12296" href="#12296" class="Bound">n</a> <a id="12298" class="Symbol">=</a> <a id="12300" href="#4231" class="Function">2*</a> <a id="12303" class="Symbol">(</a><a id="12304" href="#12250" class="Function Operator">2^</a> <a id="12307" href="#12292" class="Bound">m</a> <a id="12309" href="#12250" class="Function Operator">*</a> <a id="12311" href="#12296" class="Bound">n</a><a id="12312" class="Symbol">)</a>
</pre>
<p>It will let us do the type-change-as-you-go trick from <code>foldl</code>, but in a binary setting. Here’s <code>foldr</code>:</p>
<pre class="Agda"><a id="array-foldr"></a><a id="12433" href="#12433" class="Function">array-foldr</a> <a id="12445" class="Symbol">:</a> <a id="12447" class="Symbol">(</a><a id="12448" href="#12448" class="Bound">B</a> <a id="12450" class="Symbol">:</a> <a id="12452" href="../code/binary/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="12454" class="Symbol">→</a> <a id="12456" href="../code/binary/Cubical.Core.Primitives.html#957" class="Function">Type</a> <a id="12461" href="../code/binary/Prelude.html#456" class="Generalizable">b</a><a id="12462" class="Symbol">)</a>
            <a id="12476" class="Symbol">→</a> <a id="12478" class="Symbol">(∀</a> <a id="12481" href="#12481" class="Bound">n</a> <a id="12483" class="Symbol">{</a><a id="12484" href="#12484" class="Bound">m</a><a id="12485" class="Symbol">}</a> <a id="12487" class="Symbol">→</a> <a id="12489" href="#846" class="Generalizable">T</a> <a id="12491" href="#12481" class="Bound">n</a> <a id="12493" class="Symbol">→</a> <a id="12495" href="#12448" class="Bound">B</a> <a id="12497" class="Symbol">(</a><a id="12498" href="#12250" class="Function Operator">2^</a> <a id="12501" href="#12481" class="Bound">n</a> <a id="12503" href="#12250" class="Function Operator">*</a> <a id="12505" href="#12484" class="Bound">m</a><a id="12506" class="Symbol">)</a> <a id="12508" class="Symbol">→</a> <a id="12510" href="#12448" class="Bound">B</a> <a id="12512" class="Symbol">(</a><a id="12513" href="#12250" class="Function Operator">2^</a> <a id="12516" href="#12481" class="Bound">n</a> <a id="12518" href="#12250" class="Function Operator">*</a> <a id="12520" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="12524" href="#12484" class="Bound">m</a><a id="12525" class="Symbol">))</a>
            <a id="12540" class="Symbol">→</a> <a id="12542" href="#12448" class="Bound">B</a> <a id="12544" class="Number">0</a> <a id="12546" class="Symbol">→</a> <a id="12548" href="#7823" class="Datatype">Array</a> <a id="12554" href="#846" class="Generalizable">T</a> <a id="12556" href="#6437" class="Generalizable">ds</a> <a id="12559" class="Symbol">→</a> <a id="12561" href="#12448" class="Bound">B</a> <a id="12563" href="#6703" class="Function Operator">⟦</a> <a id="12565" href="#6437" class="Generalizable">ds</a> <a id="12568" href="#6703" class="Function Operator">⇓⟧</a>
<a id="12571" href="#12433" class="Function">array-foldr</a> <a id="12583" href="#12583" class="Bound">B</a> <a id="12585" href="#12585" class="Bound">c</a> <a id="12587" href="#12587" class="Bound">b</a> <a id="12589" href="#7867" class="InductiveConstructor">[]</a>        <a id="12599" class="Symbol">=</a> <a id="12601" href="#12587" class="Bound">b</a>
<a id="12603" href="#12433" class="Function">array-foldr</a> <a id="12615" href="#12615" class="Bound">B</a> <a id="12617" href="#12617" class="Bound">c</a> <a id="12619" href="#12619" class="Bound">b</a> <a id="12621" class="Symbol">(</a><a id="12622" href="#12622" class="Bound">x</a> <a id="12624" href="#7956" class="InductiveConstructor Operator">1∷</a> <a id="12627" href="#12627" class="Bound">xs</a><a id="12629" class="Symbol">)</a> <a id="12631" class="Symbol">=</a> <a id="12633" href="#12617" class="Bound">c</a> <a id="12635" class="Number">0</a> <a id="12637" href="#12622" class="Bound">x</a> <a id="12639" class="Symbol">(</a><a id="12640" href="#12433" class="Function">array-foldr</a> <a id="12652" class="Symbol">(</a><a id="12653" href="#12615" class="Bound">B</a> <a id="12655" href="../code/binary/Prelude.html#942" class="Function Operator">∘</a> <a id="12657" href="#4231" class="Function">2*</a><a id="12659" class="Symbol">)</a> <a id="12661" class="Symbol">(</a><a id="12662" href="#12617" class="Bound">c</a> <a id="12664" href="../code/binary/Prelude.html#942" class="Function Operator">∘</a> <a id="12666" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a><a id="12669" class="Symbol">)</a> <a id="12671" href="#12619" class="Bound">b</a> <a id="12673" href="#12627" class="Bound">xs</a><a id="12675" class="Symbol">)</a>
<a id="12677" href="#12433" class="Function">array-foldr</a> <a id="12689" href="#12689" class="Bound">B</a> <a id="12691" href="#12691" class="Bound">c</a> <a id="12693" href="#12693" class="Bound">b</a> <a id="12695" class="Symbol">(</a><a id="12696" href="#12696" class="Bound">x</a> <a id="12698" href="#7994" class="InductiveConstructor Operator">2∷</a> <a id="12701" href="#12701" class="Bound">xs</a><a id="12703" class="Symbol">)</a> <a id="12705" class="Symbol">=</a> <a id="12707" href="#12691" class="Bound">c</a> <a id="12709" class="Number">1</a> <a id="12711" href="#12696" class="Bound">x</a> <a id="12713" class="Symbol">(</a><a id="12714" href="#12433" class="Function">array-foldr</a> <a id="12726" class="Symbol">(</a><a id="12727" href="#12689" class="Bound">B</a> <a id="12729" href="../code/binary/Prelude.html#942" class="Function Operator">∘</a> <a id="12731" href="#4231" class="Function">2*</a><a id="12733" class="Symbol">)</a> <a id="12735" class="Symbol">(</a><a id="12736" href="#12691" class="Bound">c</a> <a id="12738" href="../code/binary/Prelude.html#942" class="Function Operator">∘</a> <a id="12740" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a><a id="12743" class="Symbol">)</a> <a id="12745" href="#12693" class="Bound">b</a> <a id="12747" href="#12701" class="Bound">xs</a><a id="12749" class="Symbol">)</a>
</pre>
<p>And, as you should expect, here’s how to use this in combination with the perfect trees. Here we’ll build a binary random access list from a vector, and convert back to a vector.</p>
<pre class="Agda"><a id="perf-foldr"></a><a id="12944" href="#12944" class="Function">perf-foldr</a> <a id="12955" class="Symbol">:</a> <a id="12957" class="Symbol">(</a><a id="12958" href="#12958" class="Bound">B</a> <a id="12960" class="Symbol">:</a> <a id="12962" href="../code/binary/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="12964" class="Symbol">→</a> <a id="12966" href="../code/binary/Cubical.Core.Primitives.html#957" class="Function">Type</a> <a id="12971" href="../code/binary/Prelude.html#456" class="Generalizable">b</a><a id="12972" class="Symbol">)</a>
           <a id="12985" class="Symbol">→</a> <a id="12987" class="Symbol">(∀</a> <a id="12990" class="Symbol">{</a><a id="12991" href="#12991" class="Bound">n</a><a id="12992" class="Symbol">}</a> <a id="12994" class="Symbol">→</a> <a id="12996" href="../code/binary/Prelude.html#470" class="Generalizable">A</a> <a id="12998" class="Symbol">→</a> <a id="13000" href="#12958" class="Bound">B</a> <a id="13002" href="#12991" class="Bound">n</a> <a id="13004" class="Symbol">→</a> <a id="13006" href="#12958" class="Bound">B</a> <a id="13008" class="Symbol">(</a><a id="13009" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="13013" href="#12991" class="Bound">n</a><a id="13014" class="Symbol">))</a>
           <a id="13028" class="Symbol">→</a> <a id="13030" class="Symbol">∀</a> <a id="13032" href="#13032" class="Bound">n</a> <a id="13034" class="Symbol">{</a><a id="13035" href="#13035" class="Bound">m</a><a id="13036" class="Symbol">}</a>
           <a id="13049" class="Symbol">→</a> <a id="13051" href="#9372" class="Function">Perfect</a> <a id="13059" href="../code/binary/Prelude.html#470" class="Generalizable">A</a> <a id="13061" href="#13032" class="Bound">n</a>
           <a id="13074" class="Symbol">→</a> <a id="13076" href="#12958" class="Bound">B</a> <a id="13078" class="Symbol">(</a><a id="13079" href="#12250" class="Function Operator">2^</a> <a id="13082" href="#13032" class="Bound">n</a> <a id="13084" href="#12250" class="Function Operator">*</a> <a id="13086" href="#13035" class="Bound">m</a><a id="13087" class="Symbol">)</a>
           <a id="13100" class="Symbol">→</a> <a id="13102" href="#12958" class="Bound">B</a> <a id="13104" class="Symbol">(</a><a id="13105" href="#12250" class="Function Operator">2^</a> <a id="13108" href="#13032" class="Bound">n</a> <a id="13110" href="#12250" class="Function Operator">*</a> <a id="13112" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="13116" href="#13035" class="Bound">m</a><a id="13117" class="Symbol">)</a>
<a id="13119" href="#12944" class="Function">perf-foldr</a> <a id="13130" href="#13130" class="Bound">B</a> <a id="13132" href="#13132" class="Bound">f</a> <a id="13134" href="../code/binary/Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a> <a id="13139" class="Symbol">=</a> <a id="13141" href="#13132" class="Bound">f</a>
<a id="13143" href="#12944" class="Function">perf-foldr</a> <a id="13154" href="#13154" class="Bound">B</a> <a id="13156" href="#13156" class="Bound">f</a> <a id="13158" class="Symbol">(</a><a id="13159" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="13163" href="#13163" class="Bound">n</a><a id="13164" class="Symbol">)</a> <a id="13166" class="Symbol">=</a>
  <a id="13170" href="#12944" class="Function">perf-foldr</a> <a id="13181" class="Symbol">(</a><a id="13182" href="#13154" class="Bound">B</a> <a id="13184" href="../code/binary/Prelude.html#942" class="Function Operator">∘</a> <a id="13186" href="#4231" class="Function">2*</a><a id="13188" class="Symbol">)</a> <a id="13190" class="Symbol">(λ</a> <a id="13193" class="Symbol">{</a> <a id="13195" class="Symbol">(</a><a id="13196" href="#13196" class="Bound">x</a> <a id="13198" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="13200" href="#13200" class="Bound">y</a><a id="13201" class="Symbol">)</a> <a id="13203" href="#13203" class="Bound">zs</a> <a id="13206" class="Symbol">→</a> <a id="13208" href="#13156" class="Bound">f</a> <a id="13210" href="#13196" class="Bound">x</a> <a id="13212" class="Symbol">(</a><a id="13213" href="#13156" class="Bound">f</a> <a id="13215" href="#13200" class="Bound">y</a> <a id="13217" href="#13203" class="Bound">zs</a><a id="13219" class="Symbol">)</a> <a id="13221" class="Symbol">})</a> <a id="13224" href="#13163" class="Bound">n</a>

<a id="toVec"></a><a id="13227" href="#13227" class="Function">toVec</a> <a id="13233" class="Symbol">:</a> <a id="13235" href="#7823" class="Datatype">Array</a> <a id="13241" class="Symbol">(</a><a id="13242" href="#9372" class="Function">Perfect</a> <a id="13250" href="../code/binary/Prelude.html#470" class="Generalizable">A</a><a id="13251" class="Symbol">)</a> <a id="13253" href="#6437" class="Generalizable">ds</a> <a id="13256" class="Symbol">→</a> <a id="13258" href="#1557" class="Datatype">Vec</a> <a id="13262" href="../code/binary/Prelude.html#470" class="Generalizable">A</a> <a id="13264" href="#6703" class="Function Operator">⟦</a> <a id="13266" href="#6437" class="Generalizable">ds</a> <a id="13269" href="#6703" class="Function Operator">⇓⟧</a>
<a id="13272" href="#13227" class="Function">toVec</a> <a id="13278" class="Symbol">=</a> <a id="13280" href="#12433" class="Function">array-foldr</a> <a id="13292" class="Symbol">(</a><a id="13293" href="#1557" class="Datatype">Vec</a> <a id="13297" class="Symbol">_)</a> <a id="13300" class="Symbol">(</a><a id="13301" href="#12944" class="Function">perf-foldr</a> <a id="13312" class="Symbol">(</a><a id="13313" href="#1557" class="Datatype">Vec</a> <a id="13317" class="Symbol">_)</a> <a id="13320" href="#1611" class="InductiveConstructor Operator">_∷_</a><a id="13323" class="Symbol">)</a> <a id="13325" href="#1593" class="InductiveConstructor">[]</a>

<a id="fromVec"></a><a id="13329" href="#13329" class="Function">fromVec</a> <a id="13337" class="Symbol">:</a> <a id="13339" href="#1557" class="Datatype">Vec</a> <a id="13343" href="../code/binary/Prelude.html#470" class="Generalizable">A</a> <a id="13345" href="../code/binary/Prelude.html#506" class="Generalizable">n</a> <a id="13347" class="Symbol">→</a> <a id="13349" href="#7823" class="Datatype">Array</a> <a id="13355" class="Symbol">(</a><a id="13356" href="#9372" class="Function">Perfect</a> <a id="13364" href="../code/binary/Prelude.html#470" class="Generalizable">A</a><a id="13365" class="Symbol">)</a> <a id="13367" href="#7079" class="Function Operator">⟦</a> <a id="13369" href="../code/binary/Prelude.html#506" class="Generalizable">n</a> <a id="13371" href="#7079" class="Function Operator">⇑⟧</a>
<a id="13374" href="#13329" class="Function">fromVec</a> <a id="13382" class="Symbol">=</a> <a id="13384" href="#2378" class="Function">vec-foldr</a> <a id="13394" class="Symbol">(</a><a id="13395" href="#7823" class="Datatype">Array</a> <a id="13401" class="Symbol">(</a><a id="13402" href="#9372" class="Function">Perfect</a> <a id="13410" class="Symbol">_)</a> <a id="13413" href="../code/binary/Prelude.html#942" class="Function Operator">∘</a> <a id="13415" href="#7079" class="Function Operator">⟦_⇑⟧</a><a id="13419" class="Symbol">)</a> <a id="13421" href="#10697" class="Function">perf-cons</a> <a id="13431" href="#7867" class="InductiveConstructor">[]</a>
</pre>
<h1 id="lenses">Lenses</h1>
<p>That’s the end of the “simple” stuff! The binary random-access list I’ve presented above is about as simple as I can get it.</p>
<p>In this section, I want to look at some more complex (and more fun) things you can do with it. First: lenses.</p>
<p>Lenses aren’t super ergonomic in dependently-typed languages, but they do come with some advantages. The lens laws are quite strong, for instance, meaning that often by constructing programs using a lot of lenses gives us certain properties “for free”. Here, for instance, we can define the lenses for indexing.</p>
<pre class="Agda"><a id="14007" class="Keyword">open</a> <a id="14012" class="Keyword">import</a> <a id="14019" href="../code/binary/Lenses.html" class="Module">Lenses</a>
</pre>
<details>
<p><summary>Lenses into the head and tail of an array</summary></p>
<pre class="Agda"><a id="head"></a><a id="14111" href="#14111" class="Function">head</a> <a id="14116" class="Symbol">:</a> <a id="14118" href="../code/binary/Lenses.html#203" class="Record">Lens</a> <a id="14123" class="Symbol">(</a><a id="14124" href="#7823" class="Datatype">Array</a> <a id="14130" href="#846" class="Generalizable">T</a> <a id="14132" class="Symbol">(</a><a id="14133" href="#6427" class="Generalizable">d</a> <a id="14135" href="../code/binary/Prelude.html#807" class="InductiveConstructor Operator">∷</a> <a id="14137" href="#6437" class="Generalizable">ds</a><a id="14139" class="Symbol">))</a> <a id="14142" class="Symbol">(</a><a id="14143" href="#846" class="Generalizable">T</a> <a id="14145" class="Symbol">(</a><a id="14146" href="../code/binary/Prelude.html#1416" class="Function">bool</a> <a id="14151" class="Number">0</a> <a id="14153" class="Number">1</a> <a id="14155" href="#6427" class="Generalizable">d</a><a id="14156" class="Symbol">))</a>
<a id="14159" href="#14111" class="Function">head</a> <a id="14164" class="Symbol">.</a><a id="14165" href="../code/binary/Lenses.html#265" class="Field">into</a> <a id="14170" class="Symbol">(</a><a id="14171" href="#14171" class="Bound">x</a> <a id="14173" href="#7886" class="InductiveConstructor Operator">∷</a> <a id="14175" class="Symbol">_</a> <a id="14177" class="Symbol">)</a> <a id="14179" class="Symbol">.</a><a id="14180" href="../code/binary/Lenses.html#150" class="Field">get</a> <a id="14184" class="Symbol">=</a> <a id="14186" href="#14171" class="Bound">x</a>
<a id="14188" href="#14111" class="Function">head</a> <a id="14193" class="Symbol">.</a><a id="14194" href="../code/binary/Lenses.html#265" class="Field">into</a> <a id="14199" class="Symbol">(_</a> <a id="14202" href="#7886" class="InductiveConstructor Operator">∷</a> <a id="14204" href="#14204" class="Bound">xs</a><a id="14206" class="Symbol">)</a> <a id="14208" class="Symbol">.</a><a id="14209" href="../code/binary/Lenses.html#162" class="Field">set</a> <a id="14213" href="#14213" class="Bound">x</a> <a id="14215" class="Symbol">=</a> <a id="14217" href="#14213" class="Bound">x</a> <a id="14219" href="#7886" class="InductiveConstructor Operator">∷</a> <a id="14221" href="#14204" class="Bound">xs</a>
<a id="14224" href="#14111" class="Function">head</a> <a id="14229" class="Symbol">.</a><a id="14230" href="../code/binary/Lenses.html#293" class="Field">get-set</a> <a id="14238" class="Symbol">(_</a> <a id="14241" href="#7886" class="InductiveConstructor Operator">∷</a> <a id="14243" class="Symbol">_)</a> <a id="14246" class="Symbol">_</a> <a id="14248" class="Symbol">=</a> <a id="14250" href="../code/binary/Cubical.Foundations.Prelude.html#856" class="Function">refl</a>
<a id="14255" href="#14111" class="Function">head</a> <a id="14260" class="Symbol">.</a><a id="14261" href="../code/binary/Lenses.html#345" class="Field">set-get</a> <a id="14269" class="Symbol">(_</a> <a id="14272" href="#7886" class="InductiveConstructor Operator">∷</a> <a id="14274" class="Symbol">_)</a> <a id="14277" class="Symbol">=</a> <a id="14279" href="../code/binary/Cubical.Foundations.Prelude.html#856" class="Function">refl</a>
<a id="14284" href="#14111" class="Function">head</a> <a id="14289" class="Symbol">.</a><a id="14290" href="../code/binary/Lenses.html#395" class="Field">set-set</a> <a id="14298" class="Symbol">(_</a> <a id="14301" href="#7886" class="InductiveConstructor Operator">∷</a> <a id="14303" class="Symbol">_)</a> <a id="14306" class="Symbol">_</a> <a id="14308" class="Symbol">_</a> <a id="14310" class="Symbol">=</a> <a id="14312" href="../code/binary/Cubical.Foundations.Prelude.html#856" class="Function">refl</a>

<a id="tail"></a><a id="14318" href="#14318" class="Function">tail</a> <a id="14323" class="Symbol">:</a> <a id="14325" href="../code/binary/Lenses.html#203" class="Record">Lens</a> <a id="14330" class="Symbol">(</a><a id="14331" href="#7823" class="Datatype">Array</a> <a id="14337" href="#846" class="Generalizable">T</a> <a id="14339" class="Symbol">(</a><a id="14340" href="#6427" class="Generalizable">d</a> <a id="14342" href="../code/binary/Prelude.html#807" class="InductiveConstructor Operator">∷</a> <a id="14344" href="#6437" class="Generalizable">ds</a><a id="14346" class="Symbol">))</a> <a id="14349" class="Symbol">(</a><a id="14350" href="#7823" class="Datatype">Array</a> <a id="14356" class="Symbol">(</a><a id="14357" href="#846" class="Generalizable">T</a> <a id="14359" href="../code/binary/Prelude.html#942" class="Function Operator">∘</a> <a id="14361" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a><a id="14364" class="Symbol">)</a> <a id="14366" href="#6437" class="Generalizable">ds</a><a id="14368" class="Symbol">)</a>
<a id="14370" href="#14318" class="Function">tail</a> <a id="14375" class="Symbol">.</a><a id="14376" href="../code/binary/Lenses.html#265" class="Field">into</a> <a id="14381" class="Symbol">(_</a> <a id="14384" href="#7886" class="InductiveConstructor Operator">∷</a> <a id="14386" href="#14386" class="Bound">xs</a><a id="14388" class="Symbol">)</a> <a id="14390" class="Symbol">.</a><a id="14391" href="../code/binary/Lenses.html#150" class="Field">get</a> <a id="14395" class="Symbol">=</a> <a id="14397" href="#14386" class="Bound">xs</a>
<a id="14400" href="#14318" class="Function">tail</a> <a id="14405" class="Symbol">.</a><a id="14406" href="../code/binary/Lenses.html#265" class="Field">into</a> <a id="14411" class="Symbol">(</a><a id="14412" href="#14412" class="Bound">x</a> <a id="14414" href="#7886" class="InductiveConstructor Operator">∷</a> <a id="14416" class="Symbol">_</a> <a id="14418" class="Symbol">)</a> <a id="14420" class="Symbol">.</a><a id="14421" href="../code/binary/Lenses.html#162" class="Field">set</a> <a id="14425" href="#14425" class="Bound">xs</a> <a id="14428" class="Symbol">=</a> <a id="14430" href="#14412" class="Bound">x</a> <a id="14432" href="#7886" class="InductiveConstructor Operator">∷</a> <a id="14434" href="#14425" class="Bound">xs</a>
<a id="14437" href="#14318" class="Function">tail</a> <a id="14442" class="Symbol">.</a><a id="14443" href="../code/binary/Lenses.html#293" class="Field">get-set</a> <a id="14451" class="Symbol">(_</a> <a id="14454" href="#7886" class="InductiveConstructor Operator">∷</a> <a id="14456" class="Symbol">_)</a> <a id="14459" class="Symbol">_</a> <a id="14461" class="Symbol">=</a> <a id="14463" href="../code/binary/Cubical.Foundations.Prelude.html#856" class="Function">refl</a>
<a id="14468" href="#14318" class="Function">tail</a> <a id="14473" class="Symbol">.</a><a id="14474" href="../code/binary/Lenses.html#345" class="Field">set-get</a> <a id="14482" class="Symbol">(_</a> <a id="14485" href="#7886" class="InductiveConstructor Operator">∷</a> <a id="14487" class="Symbol">_)</a> <a id="14490" class="Symbol">=</a> <a id="14492" href="../code/binary/Cubical.Foundations.Prelude.html#856" class="Function">refl</a>
<a id="14497" href="#14318" class="Function">tail</a> <a id="14502" class="Symbol">.</a><a id="14503" href="../code/binary/Lenses.html#395" class="Field">set-set</a> <a id="14511" class="Symbol">(_</a> <a id="14514" href="#7886" class="InductiveConstructor Operator">∷</a> <a id="14516" class="Symbol">_)</a> <a id="14519" class="Symbol">_</a> <a id="14521" class="Symbol">_</a> <a id="14523" class="Symbol">=</a> <a id="14525" href="../code/binary/Cubical.Foundations.Prelude.html#856" class="Function">refl</a>
</pre>
</details>
<pre class="Agda"><a id="nest-lens"></a><a id="14555" href="#14555" class="Function">nest-lens</a> <a id="14565" class="Symbol">:</a> <a id="14567" class="Symbol">(∀</a> <a id="14570" class="Symbol">{</a><a id="14571" href="#14571" class="Bound">A</a><a id="14572" class="Symbol">}</a> <a id="14574" class="Symbol">→</a> <a id="14576" href="#874" class="Generalizable">P</a> <a id="14578" class="Symbol">→</a> <a id="14580" href="../code/binary/Lenses.html#203" class="Record">Lens</a> <a id="14585" class="Symbol">(</a><a id="14586" href="#9450" class="Generalizable">F</a> <a id="14588" href="#14571" class="Bound">A</a><a id="14589" class="Symbol">)</a> <a id="14591" href="#14571" class="Bound">A</a><a id="14592" class="Symbol">)</a>
          <a id="14604" class="Symbol">→</a> <a id="14606" href="#10969" class="Datatype">Fin𝔹</a> <a id="14611" href="#874" class="Generalizable">P</a> <a id="14613" href="#6437" class="Generalizable">ds</a>
          <a id="14626" class="Symbol">→</a> <a id="14628" href="../code/binary/Lenses.html#203" class="Record">Lens</a> <a id="14633" class="Symbol">(</a><a id="14634" href="#7823" class="Datatype">Array</a> <a id="14640" class="Symbol">(</a><a id="14641" href="#9268" class="Function">Nest</a> <a id="14646" href="#9450" class="Generalizable">F</a> <a id="14648" href="../code/binary/Prelude.html#470" class="Generalizable">A</a><a id="14649" class="Symbol">)</a> <a id="14651" href="#6437" class="Generalizable">ds</a><a id="14653" class="Symbol">)</a> <a id="14655" href="../code/binary/Prelude.html#470" class="Generalizable">A</a>
<a id="14657" href="#14555" class="Function">nest-lens</a> <a id="14667" href="#14667" class="Bound">ln</a> <a id="14670" href="#11007" class="InductiveConstructor">here₁</a>        <a id="14683" class="Symbol">=</a> <a id="14685" href="#14111" class="Function">head</a>
<a id="14690" href="#14555" class="Function">nest-lens</a> <a id="14700" href="#14700" class="Bound">ln</a> <a id="14703" class="Symbol">(</a><a id="14704" href="#11056" class="InductiveConstructor">here₂</a> <a id="14710" href="#14710" class="Bound">i</a><a id="14711" class="Symbol">)</a>    <a id="14716" class="Symbol">=</a> <a id="14718" href="#14111" class="Function">head</a> <a id="14723" href="../code/binary/Lenses.html#631" class="Function Operator">⋯</a> <a id="14725" href="#14700" class="Bound">ln</a> <a id="14728" href="#14710" class="Bound">i</a>
<a id="14730" href="#14555" class="Function">nest-lens</a> <a id="14740" href="#14740" class="Bound">ln</a> <a id="14743" class="Symbol">(</a><a id="14744" href="#11105" class="InductiveConstructor">there</a> <a id="14750" href="#14750" class="Bound">i</a> <a id="14752" href="#14752" class="Bound">is</a><a id="14754" class="Symbol">)</a> <a id="14756" class="Symbol">=</a> <a id="14758" href="#14318" class="Function">tail</a> <a id="14763" href="../code/binary/Lenses.html#631" class="Function Operator">⋯</a> <a id="14765" href="#14555" class="Function">nest-lens</a> <a id="14775" href="#14740" class="Bound">ln</a> <a id="14778" href="#14752" class="Bound">is</a> <a id="14781" href="../code/binary/Lenses.html#631" class="Function Operator">⋯</a> <a id="14783" href="#14740" class="Bound">ln</a> <a id="14786" href="#14750" class="Bound">i</a>
</pre>
<details>
<p><summary>Top-down version</summary></p>
<pre class="Agda"><a id="ind-lens"></a><a id="14848" href="#14848" class="Function">ind-lens</a> <a id="14857" class="Symbol">:</a> <a id="14859" class="Symbol">(∀</a> <a id="14862" class="Symbol">{</a><a id="14863" href="#14863" class="Bound">n</a><a id="14864" class="Symbol">}</a> <a id="14866" class="Symbol">→</a> <a id="14868" href="#874" class="Generalizable">P</a> <a id="14870" class="Symbol">→</a> <a id="14872" href="../code/binary/Lenses.html#203" class="Record">Lens</a> <a id="14877" class="Symbol">(</a><a id="14878" href="#846" class="Generalizable">T</a> <a id="14880" class="Symbol">(</a><a id="14881" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="14885" href="#14863" class="Bound">n</a><a id="14886" class="Symbol">))</a> <a id="14889" class="Symbol">(</a><a id="14890" href="#846" class="Generalizable">T</a> <a id="14892" href="#14863" class="Bound">n</a><a id="14893" class="Symbol">))</a>
         <a id="14905" class="Symbol">→</a> <a id="14907" href="#10969" class="Datatype">Fin𝔹</a> <a id="14912" href="#874" class="Generalizable">P</a> <a id="14914" href="#6437" class="Generalizable">ds</a>
         <a id="14926" class="Symbol">→</a> <a id="14928" href="../code/binary/Lenses.html#203" class="Record">Lens</a> <a id="14933" class="Symbol">(</a><a id="14934" href="#7823" class="Datatype">Array</a> <a id="14940" href="#846" class="Generalizable">T</a> <a id="14942" href="#6437" class="Generalizable">ds</a><a id="14944" class="Symbol">)</a> <a id="14946" class="Symbol">(</a><a id="14947" href="#846" class="Generalizable">T</a> <a id="14949" class="Number">0</a><a id="14950" class="Symbol">)</a>
<a id="14952" href="#14848" class="Function">ind-lens</a> <a id="14961" href="#14961" class="Bound">ln</a> <a id="14964" href="#11007" class="InductiveConstructor">here₁</a>        <a id="14977" class="Symbol">=</a> <a id="14979" href="#14111" class="Function">head</a>
<a id="14984" href="#14848" class="Function">ind-lens</a> <a id="14993" href="#14993" class="Bound">ln</a> <a id="14996" class="Symbol">(</a><a id="14997" href="#11056" class="InductiveConstructor">here₂</a> <a id="15003" href="#15003" class="Bound">i</a><a id="15004" class="Symbol">)</a>    <a id="15009" class="Symbol">=</a> <a id="15011" href="#14111" class="Function">head</a> <a id="15016" href="../code/binary/Lenses.html#631" class="Function Operator">⋯</a> <a id="15018" href="#14993" class="Bound">ln</a> <a id="15021" href="#15003" class="Bound">i</a>
<a id="15023" href="#14848" class="Function">ind-lens</a> <a id="15032" href="#15032" class="Bound">ln</a> <a id="15035" class="Symbol">(</a><a id="15036" href="#11105" class="InductiveConstructor">there</a> <a id="15042" href="#15042" class="Bound">i</a> <a id="15044" href="#15044" class="Bound">is</a><a id="15046" class="Symbol">)</a> <a id="15048" class="Symbol">=</a> <a id="15050" href="#14318" class="Function">tail</a> <a id="15055" href="../code/binary/Lenses.html#631" class="Function Operator">⋯</a> <a id="15057" href="#14848" class="Function">ind-lens</a> <a id="15066" href="#15032" class="Bound">ln</a> <a id="15069" href="#15044" class="Bound">is</a> <a id="15072" href="../code/binary/Lenses.html#631" class="Function Operator">⋯</a> <a id="15074" href="#15032" class="Bound">ln</a> <a id="15077" href="#15042" class="Bound">i</a>
</pre>
</details>
<h1 id="fenwick-trees">Fenwick Trees</h1>
<p>Finally, to demonstrate some of the versatility of this data structure, we’re going to implement a tree based on a <em>Fenwick</em> tree. This is a data structure for prefix sums: we can query the running total at any point, and <em>update</em> the value at a given point, in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math> time. We’re going to make it generic over a monoid:</p>
<pre class="Agda"><a id="15458" class="Keyword">module</a> <a id="15465" href="#15465" class="Module">_</a> <a id="15467" class="Symbol">{</a><a id="15468" href="#15468" class="Bound">ℓ</a><a id="15469" class="Symbol">}</a> <a id="15471" class="Symbol">(</a><a id="15472" href="#15472" class="Bound">mon</a> <a id="15476" class="Symbol">:</a> <a id="15478" href="../code/binary/Prelude.html#1125" class="Record">Monoid</a> <a id="15485" href="#15468" class="Bound">ℓ</a><a id="15486" class="Symbol">)</a> <a id="15488" class="Keyword">where</a>
  <a id="15496" class="Keyword">open</a> <a id="15501" href="../code/binary/Prelude.html#1125" class="Module">Monoid</a> <a id="15508" href="#15472" class="Bound">mon</a>

  <a id="15515" class="Keyword">record</a> <a id="15522" href="#15522" class="Record">Leaf</a> <a id="15527" class="Symbol">:</a> <a id="15529" class="PrimitiveType">Set</a> <a id="15533" href="#15468" class="Bound">ℓ</a> <a id="15535" class="Keyword">where</a>
    <a id="15545" class="Keyword">constructor</a> <a id="15557" href="#15557" class="InductiveConstructor">leaf</a>
    <a id="15566" class="Keyword">field</a> <a id="15572" href="#15572" class="Field">val</a> <a id="15576" class="Symbol">:</a> <a id="15578" href="../code/binary/Prelude.html#1182" class="Field">𝑆</a>
  <a id="15582" class="Keyword">open</a> <a id="15587" href="#15522" class="Module">Leaf</a>

  <a id="15595" class="Keyword">mutual</a>
    <a id="15606" href="#15606" class="Function">SumNode</a> <a id="15614" class="Symbol">:</a> <a id="15616" href="../code/binary/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="15618" class="Symbol">→</a> <a id="15620" class="PrimitiveType">Set</a> <a id="15624" href="#15468" class="Bound">ℓ</a>
    <a id="15630" href="#15606" class="Function">SumNode</a> <a id="15638" href="../code/binary/Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a> <a id="15643" class="Symbol">=</a> <a id="15645" href="#15522" class="Record">Leaf</a>
    <a id="15654" href="#15606" class="Function">SumNode</a> <a id="15662" class="Symbol">(</a><a id="15663" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="15667" href="#15667" class="Bound">n</a><a id="15668" class="Symbol">)</a> <a id="15670" class="Symbol">=</a> <a id="15672" href="#15699" class="Function">Summary</a> <a id="15680" href="#15667" class="Bound">n</a> <a id="15682" href="../code/binary/Prelude.html#621" class="Function Operator">×</a> <a id="15684" href="#15699" class="Function">Summary</a> <a id="15692" href="#15667" class="Bound">n</a>

    <a id="15699" href="#15699" class="Function">Summary</a> <a id="15707" class="Symbol">:</a> <a id="15709" href="../code/binary/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="15711" class="Symbol">→</a> <a id="15713" class="PrimitiveType">Set</a> <a id="15717" href="#15468" class="Bound">ℓ</a>
    <a id="15723" href="#15699" class="Function">Summary</a> <a id="15731" href="#15731" class="Bound">n</a> <a id="15733" class="Symbol">=</a> <a id="15735" href="../code/binary/Agda.Builtin.Sigma.html#139" class="Record">Σ</a> <a id="15737" href="../code/binary/Prelude.html#1182" class="Field">𝑆</a> <a id="15739" class="Symbol">(</a><a id="15740" href="../code/binary/Cubical.Foundations.Equiv.html#801" class="Function">fiber</a> <a id="15746" class="Symbol">(</a><a id="15747" href="#15760" class="Function">cmb</a> <a id="15751" href="#15731" class="Bound">n</a><a id="15752" class="Symbol">))</a>

    <a id="15760" href="#15760" class="Function">cmb</a> <a id="15764" class="Symbol">:</a> <a id="15766" class="Symbol">∀</a> <a id="15768" href="#15768" class="Bound">n</a> <a id="15770" class="Symbol">→</a> <a id="15772" href="#15606" class="Function">SumNode</a> <a id="15780" href="#15768" class="Bound">n</a> <a id="15782" class="Symbol">→</a> <a id="15784" href="../code/binary/Prelude.html#1182" class="Field">𝑆</a>
    <a id="15790" href="#15760" class="Function">cmb</a> <a id="15794" href="../code/binary/Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a> <a id="15799" class="Symbol">=</a> <a id="15801" href="#15572" class="Field">val</a>
    <a id="15809" href="#15760" class="Function">cmb</a> <a id="15813" class="Symbol">(</a><a id="15814" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="15818" class="Symbol">_)</a> <a id="15821" class="Symbol">(</a><a id="15822" href="#15822" class="Bound">x</a> <a id="15824" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="15826" href="#15826" class="Bound">y</a><a id="15827" class="Symbol">)</a> <a id="15829" class="Symbol">=</a> <a id="15831" href="../code/binary/Agda.Builtin.Sigma.html#225" class="Field">fst</a> <a id="15835" href="#15822" class="Bound">x</a> <a id="15837" href="../code/binary/Prelude.html#1196" class="Field Operator">∙</a> <a id="15839" href="../code/binary/Agda.Builtin.Sigma.html#225" class="Field">fst</a> <a id="15843" href="#15826" class="Bound">y</a>

  <a id="15848" href="#15848" class="Function">Fenwick</a> <a id="15856" class="Symbol">:</a> <a id="15858" href="#6377" class="Function">𝔹</a> <a id="15860" class="Symbol">→</a>  <a id="15863" class="PrimitiveType">Set</a> <a id="15867" href="#15468" class="Bound">ℓ</a>
  <a id="15871" href="#15848" class="Function">Fenwick</a> <a id="15879" class="Symbol">=</a> <a id="15881" href="#7823" class="Datatype">Array</a> <a id="15887" href="#15699" class="Function">Summary</a>
</pre>
<p>So it’s an array of perfect trees, with each branch in the tree containing a summary of its children. Constructing a tree is straightforward:</p>
<pre class="Agda">  <a id="16052" href="#16052" class="Function">comb</a> <a id="16057" class="Symbol">:</a> <a id="16059" class="Symbol">∀</a> <a id="16061" href="#16061" class="Bound">n</a> <a id="16063" class="Symbol">→</a> <a id="16065" href="#15699" class="Function">Summary</a> <a id="16073" href="#16061" class="Bound">n</a> <a id="16075" class="Symbol">→</a> <a id="16077" href="#15699" class="Function">Summary</a> <a id="16085" href="#16061" class="Bound">n</a> <a id="16087" class="Symbol">→</a> <a id="16089" href="#15699" class="Function">Summary</a> <a id="16097" class="Symbol">(</a><a id="16098" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="16102" href="#16061" class="Bound">n</a><a id="16103" class="Symbol">)</a>
  <a id="16107" href="#16052" class="Function">comb</a> <a id="16112" href="#16112" class="Bound">n</a> <a id="16114" href="#16114" class="Bound">xs</a> <a id="16117" href="#16117" class="Bound">ys</a> <a id="16120" class="Symbol">=</a> <a id="16122" class="Symbol">_</a> <a id="16124" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="16126" class="Symbol">(</a><a id="16127" href="#16114" class="Bound">xs</a> <a id="16130" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="16132" href="#16117" class="Bound">ys</a><a id="16134" class="Symbol">)</a> <a id="16136" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="16138" href="../code/binary/Cubical.Foundations.Prelude.html#856" class="Function">refl</a>

  <a id="16146" href="#16146" class="Function">sing</a> <a id="16151" class="Symbol">:</a> <a id="16153" href="../code/binary/Prelude.html#1182" class="Field">𝑆</a> <a id="16155" class="Symbol">→</a> <a id="16157" href="#15699" class="Function">Summary</a> <a id="16165" class="Number">0</a>
  <a id="16169" href="#16146" class="Function">sing</a> <a id="16174" href="#16174" class="Bound">x</a> <a id="16176" class="Symbol">=</a> <a id="16178" class="Symbol">_</a> <a id="16180" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="16182" href="#15557" class="InductiveConstructor">leaf</a> <a id="16187" href="#16174" class="Bound">x</a> <a id="16189" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="16191" href="../code/binary/Cubical.Foundations.Prelude.html#856" class="Function">refl</a>

  <a id="16199" href="#16199" class="Function">fFromVec</a> <a id="16208" class="Symbol">:</a> <a id="16210" href="#1557" class="Datatype">Vec</a> <a id="16214" href="../code/binary/Prelude.html#1182" class="Field">𝑆</a> <a id="16216" href="../code/binary/Prelude.html#506" class="Generalizable">n</a> <a id="16218" class="Symbol">→</a> <a id="16220" href="#15848" class="Function">Fenwick</a> <a id="16228" href="#7079" class="Function Operator">⟦</a> <a id="16230" href="../code/binary/Prelude.html#506" class="Generalizable">n</a> <a id="16232" href="#7079" class="Function Operator">⇑⟧</a>
  <a id="16237" href="#16199" class="Function">fFromVec</a> <a id="16246" class="Symbol">=</a> <a id="16248" href="#2378" class="Function">vec-foldr</a> <a id="16258" class="Symbol">(</a><a id="16259" href="#15848" class="Function">Fenwick</a> <a id="16267" href="../code/binary/Prelude.html#942" class="Function Operator">∘</a> <a id="16269" href="#7079" class="Function Operator">⟦_⇑⟧</a><a id="16273" class="Symbol">)</a> <a id="16275" class="Symbol">(</a><a id="16276" href="#9698" class="Function">cons</a> <a id="16281" href="#16052" class="Function">comb</a> <a id="16286" href="../code/binary/Prelude.html#942" class="Function Operator">∘</a> <a id="16288" href="#16146" class="Function">sing</a><a id="16292" class="Symbol">)</a> <a id="16294" href="#7867" class="InductiveConstructor">[]</a>
</pre>
<p>Updating a particular point involves a good bit of boilerplate, but isn’t too complex.</p>
<details>
<p><summary>Lenses into a single level of the tree</summary></p>
<pre class="Agda">  <a id="16469" href="#16469" class="Function">upd-lens</a> <a id="16478" class="Symbol">:</a> <a id="16480" href="../code/binary/Prelude.html#1369" class="Datatype">Bool</a> <a id="16485" class="Symbol">→</a> <a id="16487" href="../code/binary/Lenses.html#203" class="Record">Lens</a> <a id="16492" class="Symbol">(</a><a id="16493" href="#15699" class="Function">Summary</a> <a id="16501" class="Symbol">(</a><a id="16502" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="16506" href="../code/binary/Prelude.html#506" class="Generalizable">n</a><a id="16507" class="Symbol">))</a> <a id="16510" class="Symbol">(</a><a id="16511" href="#15699" class="Function">Summary</a> <a id="16519" href="../code/binary/Prelude.html#506" class="Generalizable">n</a><a id="16520" class="Symbol">)</a>
  <a id="16524" href="#16469" class="Function">upd-lens</a> <a id="16533" href="#16533" class="Bound">b</a> <a id="16535" class="Symbol">.</a><a id="16536" href="../code/binary/Lenses.html#265" class="Field">into</a> <a id="16541" class="Symbol">(_</a> <a id="16544" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="16546" href="#16546" class="Bound">xs</a> <a id="16549" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="16551" class="Symbol">_)</a> <a id="16554" class="Symbol">.</a><a id="16555" href="../code/binary/Lenses.html#150" class="Field">get</a> <a id="16559" class="Symbol">=</a> <a id="16561" href="../code/binary/Lenses.html#1464" class="Function">⦅pair⦆</a> <a id="16568" href="#16533" class="Bound">b</a> <a id="16570" class="Symbol">.</a><a id="16571" href="../code/binary/Lenses.html#265" class="Field">into</a> <a id="16576" href="#16546" class="Bound">xs</a> <a id="16579" class="Symbol">.</a><a id="16580" href="../code/binary/Lenses.html#150" class="Field">get</a>
  <a id="16586" href="#16469" class="Function">upd-lens</a> <a id="16595" href="#16595" class="Bound">b</a> <a id="16597" class="Symbol">.</a><a id="16598" href="../code/binary/Lenses.html#265" class="Field">into</a> <a id="16603" class="Symbol">(_</a> <a id="16606" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="16608" href="#16608" class="Bound">xs</a> <a id="16611" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="16613" class="Symbol">_)</a> <a id="16616" class="Symbol">.</a><a id="16617" href="../code/binary/Lenses.html#162" class="Field">set</a> <a id="16621" href="#16621" class="Bound">x</a> <a id="16623" class="Symbol">=</a> <a id="16625" class="Symbol">_</a> <a id="16627" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="16629" href="../code/binary/Lenses.html#1464" class="Function">⦅pair⦆</a> <a id="16636" href="#16595" class="Bound">b</a> <a id="16638" class="Symbol">.</a><a id="16639" href="../code/binary/Lenses.html#265" class="Field">into</a> <a id="16644" href="#16608" class="Bound">xs</a> <a id="16647" class="Symbol">.</a><a id="16648" href="../code/binary/Lenses.html#162" class="Field">set</a> <a id="16652" href="#16621" class="Bound">x</a> <a id="16654" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="16656" href="../code/binary/Cubical.Foundations.Prelude.html#856" class="Function">refl</a>
  <a id="16663" href="#16469" class="Function">upd-lens</a> <a id="16672" href="#16672" class="Bound">b</a> <a id="16674" class="Symbol">.</a><a id="16675" href="../code/binary/Lenses.html#293" class="Field">get-set</a> <a id="16683" class="Symbol">_</a> <a id="16685" class="Symbol">=</a> <a id="16687" href="../code/binary/Lenses.html#1464" class="Function">⦅pair⦆</a> <a id="16694" href="#16672" class="Bound">b</a> <a id="16696" class="Symbol">.</a><a id="16697" href="../code/binary/Lenses.html#293" class="Field">get-set</a> <a id="16705" class="Symbol">_</a>
  <a id="16709" href="#16469" class="Function">upd-lens</a> <a id="16718" href="../code/binary/Prelude.html#1388" class="InductiveConstructor">false</a> <a id="16724" class="Symbol">.</a><a id="16725" href="../code/binary/Lenses.html#345" class="Field">set-get</a> <a id="16733" class="Symbol">(</a><a id="16734" href="#16734" class="Bound">t</a> <a id="16736" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="16738" href="#16738" class="Bound">xs</a> <a id="16741" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="16743" href="#16743" class="Bound">p</a><a id="16744" class="Symbol">)</a> <a id="16746" href="#16746" class="Bound">i</a> <a id="16748" class="Symbol">.</a><a id="16749" href="../code/binary/Agda.Builtin.Sigma.html#225" class="Field">fst</a> <a id="16753" class="Symbol">=</a> <a id="16755" href="#16743" class="Bound">p</a> <a id="16757" href="#16746" class="Bound">i</a>
  <a id="16761" href="#16469" class="Function">upd-lens</a> <a id="16770" href="../code/binary/Prelude.html#1388" class="InductiveConstructor">false</a> <a id="16776" class="Symbol">.</a><a id="16777" href="../code/binary/Lenses.html#345" class="Field">set-get</a> <a id="16785" class="Symbol">(</a><a id="16786" href="#16786" class="Bound">t</a> <a id="16788" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="16790" href="#16790" class="Bound">xs</a> <a id="16793" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="16795" href="#16795" class="Bound">p</a><a id="16796" class="Symbol">)</a> <a id="16798" href="#16798" class="Bound">i</a> <a id="16800" class="Symbol">.</a><a id="16801" href="../code/binary/Agda.Builtin.Sigma.html#237" class="Field">snd</a> <a id="16805" class="Symbol">.</a><a id="16806" href="../code/binary/Agda.Builtin.Sigma.html#225" class="Field">fst</a> <a id="16810" class="Symbol">=</a> <a id="16812" href="#16790" class="Bound">xs</a>
  <a id="16817" href="#16469" class="Function">upd-lens</a> <a id="16826" href="../code/binary/Prelude.html#1388" class="InductiveConstructor">false</a> <a id="16832" class="Symbol">.</a><a id="16833" href="../code/binary/Lenses.html#345" class="Field">set-get</a> <a id="16841" class="Symbol">(</a><a id="16842" href="#16842" class="Bound">t</a> <a id="16844" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="16846" href="#16846" class="Bound">xs</a> <a id="16849" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="16851" href="#16851" class="Bound">p</a><a id="16852" class="Symbol">)</a> <a id="16854" href="#16854" class="Bound">i</a> <a id="16856" class="Symbol">.</a><a id="16857" href="../code/binary/Agda.Builtin.Sigma.html#237" class="Field">snd</a> <a id="16861" class="Symbol">.</a><a id="16862" href="../code/binary/Agda.Builtin.Sigma.html#237" class="Field">snd</a> <a id="16866" href="#16866" class="Bound">j</a> <a id="16868" class="Symbol">=</a> <a id="16870" href="#16851" class="Bound">p</a> <a id="16872" class="Symbol">(</a><a id="16873" href="#16854" class="Bound">i</a> <a id="16875" href="../code/binary/Agda.Primitive.Cubical.html#226" class="Primitive Operator">∧</a> <a id="16877" href="#16866" class="Bound">j</a><a id="16878" class="Symbol">)</a>
  <a id="16882" href="#16469" class="Function">upd-lens</a> <a id="16891" href="../code/binary/Prelude.html#1403" class="InductiveConstructor">true</a>  <a id="16897" class="Symbol">.</a><a id="16898" href="../code/binary/Lenses.html#345" class="Field">set-get</a> <a id="16906" class="Symbol">(</a><a id="16907" href="#16907" class="Bound">t</a> <a id="16909" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="16911" href="#16911" class="Bound">xs</a> <a id="16914" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="16916" href="#16916" class="Bound">p</a><a id="16917" class="Symbol">)</a> <a id="16919" href="#16919" class="Bound">i</a> <a id="16921" class="Symbol">.</a><a id="16922" href="../code/binary/Agda.Builtin.Sigma.html#225" class="Field">fst</a> <a id="16926" class="Symbol">=</a> <a id="16928" href="#16916" class="Bound">p</a> <a id="16930" href="#16919" class="Bound">i</a>
  <a id="16934" href="#16469" class="Function">upd-lens</a> <a id="16943" href="../code/binary/Prelude.html#1403" class="InductiveConstructor">true</a>  <a id="16949" class="Symbol">.</a><a id="16950" href="../code/binary/Lenses.html#345" class="Field">set-get</a> <a id="16958" class="Symbol">(</a><a id="16959" href="#16959" class="Bound">t</a> <a id="16961" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="16963" href="#16963" class="Bound">xs</a> <a id="16966" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="16968" href="#16968" class="Bound">p</a><a id="16969" class="Symbol">)</a> <a id="16971" href="#16971" class="Bound">i</a> <a id="16973" class="Symbol">.</a><a id="16974" href="../code/binary/Agda.Builtin.Sigma.html#237" class="Field">snd</a> <a id="16978" class="Symbol">.</a><a id="16979" href="../code/binary/Agda.Builtin.Sigma.html#225" class="Field">fst</a> <a id="16983" class="Symbol">=</a> <a id="16985" href="#16963" class="Bound">xs</a>
  <a id="16990" href="#16469" class="Function">upd-lens</a> <a id="16999" href="../code/binary/Prelude.html#1403" class="InductiveConstructor">true</a>  <a id="17005" class="Symbol">.</a><a id="17006" href="../code/binary/Lenses.html#345" class="Field">set-get</a> <a id="17014" class="Symbol">(</a><a id="17015" href="#17015" class="Bound">t</a> <a id="17017" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="17019" href="#17019" class="Bound">xs</a> <a id="17022" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="17024" href="#17024" class="Bound">p</a><a id="17025" class="Symbol">)</a> <a id="17027" href="#17027" class="Bound">i</a> <a id="17029" class="Symbol">.</a><a id="17030" href="../code/binary/Agda.Builtin.Sigma.html#237" class="Field">snd</a> <a id="17034" class="Symbol">.</a><a id="17035" href="../code/binary/Agda.Builtin.Sigma.html#237" class="Field">snd</a> <a id="17039" href="#17039" class="Bound">j</a> <a id="17041" class="Symbol">=</a> <a id="17043" href="#17024" class="Bound">p</a> <a id="17045" class="Symbol">(</a><a id="17046" href="#17027" class="Bound">i</a> <a id="17048" href="../code/binary/Agda.Primitive.Cubical.html#226" class="Primitive Operator">∧</a> <a id="17050" href="#17039" class="Bound">j</a><a id="17051" class="Symbol">)</a>
  <a id="17055" href="#16469" class="Function">upd-lens</a> <a id="17064" href="../code/binary/Prelude.html#1388" class="InductiveConstructor">false</a> <a id="17070" class="Symbol">.</a><a id="17071" href="../code/binary/Lenses.html#395" class="Field">set-set</a> <a id="17079" class="Symbol">_</a> <a id="17081" class="Symbol">_</a> <a id="17083" class="Symbol">_</a> <a id="17085" class="Symbol">=</a> <a id="17087" href="../code/binary/Cubical.Foundations.Prelude.html#856" class="Function">refl</a>
  <a id="17094" href="#16469" class="Function">upd-lens</a> <a id="17103" href="../code/binary/Prelude.html#1403" class="InductiveConstructor">true</a>  <a id="17109" class="Symbol">.</a><a id="17110" href="../code/binary/Lenses.html#395" class="Field">set-set</a> <a id="17118" class="Symbol">_</a> <a id="17120" class="Symbol">_</a> <a id="17122" class="Symbol">_</a> <a id="17124" class="Symbol">=</a> <a id="17126" href="../code/binary/Cubical.Foundations.Prelude.html#856" class="Function">refl</a>

  <a id="17134" href="#17134" class="Function">top</a> <a id="17138" class="Symbol">:</a> <a id="17140" href="../code/binary/Lenses.html#203" class="Record">Lens</a> <a id="17145" class="Symbol">(</a><a id="17146" href="#15699" class="Function">Summary</a> <a id="17154" class="Number">0</a><a id="17155" class="Symbol">)</a> <a id="17157" href="../code/binary/Prelude.html#1182" class="Field">𝑆</a>
  <a id="17161" href="#17134" class="Function">top</a> <a id="17165" class="Symbol">.</a><a id="17166" href="../code/binary/Lenses.html#265" class="Field">into</a> <a id="17171" href="#17171" class="Bound">x</a> <a id="17173" class="Symbol">.</a><a id="17174" href="../code/binary/Lenses.html#150" class="Field">get</a> <a id="17178" class="Symbol">=</a> <a id="17180" href="#17171" class="Bound">x</a> <a id="17182" class="Symbol">.</a><a id="17183" href="../code/binary/Agda.Builtin.Sigma.html#237" class="Field">snd</a> <a id="17187" class="Symbol">.</a><a id="17188" href="../code/binary/Agda.Builtin.Sigma.html#225" class="Field">fst</a> <a id="17192" class="Symbol">.</a><a id="17193" href="#15572" class="Field">val</a>
  <a id="17199" href="#17134" class="Function">top</a> <a id="17203" class="Symbol">.</a><a id="17204" href="../code/binary/Lenses.html#265" class="Field">into</a> <a id="17209" href="#17209" class="Bound">x</a> <a id="17211" class="Symbol">.</a><a id="17212" href="../code/binary/Lenses.html#162" class="Field">set</a> <a id="17216" href="#17216" class="Bound">y</a> <a id="17218" class="Symbol">.</a><a id="17219" href="../code/binary/Agda.Builtin.Sigma.html#225" class="Field">fst</a> <a id="17223" class="Symbol">=</a> <a id="17225" href="#17216" class="Bound">y</a>
  <a id="17229" href="#17134" class="Function">top</a> <a id="17233" class="Symbol">.</a><a id="17234" href="../code/binary/Lenses.html#265" class="Field">into</a> <a id="17239" href="#17239" class="Bound">x</a> <a id="17241" class="Symbol">.</a><a id="17242" href="../code/binary/Lenses.html#162" class="Field">set</a> <a id="17246" href="#17246" class="Bound">y</a> <a id="17248" class="Symbol">.</a><a id="17249" href="../code/binary/Agda.Builtin.Sigma.html#237" class="Field">snd</a> <a id="17253" class="Symbol">.</a><a id="17254" href="../code/binary/Agda.Builtin.Sigma.html#225" class="Field">fst</a> <a id="17258" class="Symbol">.</a><a id="17259" href="#15572" class="Field">val</a> <a id="17263" class="Symbol">=</a> <a id="17265" href="#17246" class="Bound">y</a>
  <a id="17269" href="#17134" class="Function">top</a> <a id="17273" class="Symbol">.</a><a id="17274" href="../code/binary/Lenses.html#265" class="Field">into</a> <a id="17279" href="#17279" class="Bound">x</a> <a id="17281" class="Symbol">.</a><a id="17282" href="../code/binary/Lenses.html#162" class="Field">set</a> <a id="17286" href="#17286" class="Bound">y</a> <a id="17288" class="Symbol">.</a><a id="17289" href="../code/binary/Agda.Builtin.Sigma.html#237" class="Field">snd</a> <a id="17293" class="Symbol">.</a><a id="17294" href="../code/binary/Agda.Builtin.Sigma.html#237" class="Field">snd</a> <a id="17298" class="Symbol">=</a> <a id="17300" href="../code/binary/Cubical.Foundations.Prelude.html#856" class="Function">refl</a>
  <a id="17307" href="#17134" class="Function">top</a> <a id="17311" class="Symbol">.</a><a id="17312" href="../code/binary/Lenses.html#293" class="Field">get-set</a> <a id="17320" class="Symbol">_</a> <a id="17322" class="Symbol">_</a> <a id="17324" class="Symbol">=</a> <a id="17326" href="../code/binary/Cubical.Foundations.Prelude.html#856" class="Function">refl</a>
  <a id="17333" href="#17134" class="Function">top</a> <a id="17337" class="Symbol">.</a><a id="17338" href="../code/binary/Lenses.html#345" class="Field">set-get</a> <a id="17346" class="Symbol">(</a><a id="17347" href="#17347" class="Bound">x</a> <a id="17349" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="17351" href="#17351" class="Bound">y</a> <a id="17353" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="17355" href="#17355" class="Bound">p</a><a id="17356" class="Symbol">)</a> <a id="17358" href="#17358" class="Bound">i</a> <a id="17360" class="Symbol">.</a><a id="17361" href="../code/binary/Agda.Builtin.Sigma.html#225" class="Field">fst</a> <a id="17365" class="Symbol">=</a> <a id="17367" href="#17355" class="Bound">p</a> <a id="17369" href="#17358" class="Bound">i</a>
  <a id="17373" href="#17134" class="Function">top</a> <a id="17377" class="Symbol">.</a><a id="17378" href="../code/binary/Lenses.html#345" class="Field">set-get</a> <a id="17386" class="Symbol">(</a><a id="17387" href="#17387" class="Bound">x</a> <a id="17389" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="17391" href="#17391" class="Bound">y</a> <a id="17393" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="17395" href="#17395" class="Bound">p</a><a id="17396" class="Symbol">)</a> <a id="17398" href="#17398" class="Bound">i</a> <a id="17400" class="Symbol">.</a><a id="17401" href="../code/binary/Agda.Builtin.Sigma.html#237" class="Field">snd</a> <a id="17405" class="Symbol">.</a><a id="17406" href="../code/binary/Agda.Builtin.Sigma.html#225" class="Field">fst</a> <a id="17410" class="Symbol">=</a> <a id="17412" href="#17391" class="Bound">y</a>
  <a id="17416" href="#17134" class="Function">top</a> <a id="17420" class="Symbol">.</a><a id="17421" href="../code/binary/Lenses.html#345" class="Field">set-get</a> <a id="17429" class="Symbol">(</a><a id="17430" href="#17430" class="Bound">x</a> <a id="17432" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="17434" href="#17434" class="Bound">y</a> <a id="17436" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="17438" href="#17438" class="Bound">p</a><a id="17439" class="Symbol">)</a> <a id="17441" href="#17441" class="Bound">i</a> <a id="17443" class="Symbol">.</a><a id="17444" href="../code/binary/Agda.Builtin.Sigma.html#237" class="Field">snd</a> <a id="17448" class="Symbol">.</a><a id="17449" href="../code/binary/Agda.Builtin.Sigma.html#237" class="Field">snd</a> <a id="17453" href="#17453" class="Bound">j</a> <a id="17455" class="Symbol">=</a> <a id="17457" href="#17438" class="Bound">p</a> <a id="17459" class="Symbol">(</a><a id="17460" href="#17441" class="Bound">i</a> <a id="17462" href="../code/binary/Agda.Primitive.Cubical.html#226" class="Primitive Operator">∧</a> <a id="17464" href="#17453" class="Bound">j</a><a id="17465" class="Symbol">)</a>
  <a id="17469" href="#17134" class="Function">top</a> <a id="17473" class="Symbol">.</a><a id="17474" href="../code/binary/Lenses.html#395" class="Field">set-set</a> <a id="17482" class="Symbol">_</a> <a id="17484" class="Symbol">_</a> <a id="17486" class="Symbol">_</a> <a id="17488" class="Symbol">=</a> <a id="17490" href="../code/binary/Cubical.Foundations.Prelude.html#856" class="Function">refl</a>
</pre>
</details>
<pre class="Agda">  <a id="17522" href="#17522" class="Function">update</a> <a id="17529" class="Symbol">:</a> <a id="17531" href="#10969" class="Datatype">Fin𝔹</a> <a id="17536" href="../code/binary/Prelude.html#1369" class="Datatype">Bool</a> <a id="17541" href="#6437" class="Generalizable">ds</a> <a id="17544" class="Symbol">→</a> <a id="17546" href="../code/binary/Lenses.html#203" class="Record">Lens</a> <a id="17551" class="Symbol">(</a><a id="17552" href="#15848" class="Function">Fenwick</a> <a id="17560" href="#6437" class="Generalizable">ds</a><a id="17562" class="Symbol">)</a> <a id="17564" href="../code/binary/Prelude.html#1182" class="Field">𝑆</a>
  <a id="17568" href="#17522" class="Function">update</a> <a id="17575" href="#17575" class="Bound">is</a> <a id="17578" class="Symbol">=</a> <a id="17580" href="#14848" class="Function">ind-lens</a> <a id="17589" href="#16469" class="Function">upd-lens</a> <a id="17598" href="#17575" class="Bound">is</a> <a id="17601" href="../code/binary/Lenses.html#631" class="Function Operator">⋯</a> <a id="17603" href="#17134" class="Function">top</a>
</pre>
<p>Finally, here’s how we get the summary up to a particular point in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math> time:</p>
<pre class="Agda">  <a id="17718" href="#17718" class="Function">running</a> <a id="17726" class="Symbol">:</a> <a id="17728" class="Symbol">(∀</a> <a id="17731" href="#17731" class="Bound">n</a> <a id="17733" class="Symbol">→</a> <a id="17735" href="../code/binary/Prelude.html#1369" class="Datatype">Bool</a> <a id="17740" class="Symbol">→</a> <a id="17742" href="#846" class="Generalizable">T</a> <a id="17744" class="Symbol">(</a><a id="17745" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="17749" href="#17731" class="Bound">n</a><a id="17750" class="Symbol">)</a> <a id="17752" class="Symbol">→</a> <a id="17754" href="../code/binary/Prelude.html#1182" class="Field">𝑆</a> <a id="17756" href="../code/binary/Prelude.html#621" class="Function Operator">×</a> <a id="17758" href="#846" class="Generalizable">T</a> <a id="17760" href="#17731" class="Bound">n</a><a id="17761" class="Symbol">)</a>
          <a id="17773" class="Symbol">→</a> <a id="17775" class="Symbol">(∀</a> <a id="17778" href="#17778" class="Bound">n</a> <a id="17780" class="Symbol">→</a> <a id="17782" href="#846" class="Generalizable">T</a> <a id="17784" href="#17778" class="Bound">n</a> <a id="17786" class="Symbol">→</a> <a id="17788" href="../code/binary/Prelude.html#1182" class="Field">𝑆</a><a id="17789" class="Symbol">)</a>
          <a id="17801" class="Symbol">→</a> <a id="17803" href="#7823" class="Datatype">Array</a> <a id="17809" href="#846" class="Generalizable">T</a> <a id="17811" href="#6437" class="Generalizable">ds</a>
          <a id="17824" class="Symbol">→</a> <a id="17826" href="#10969" class="Datatype">Fin𝔹</a> <a id="17831" href="../code/binary/Prelude.html#1369" class="Datatype">Bool</a> <a id="17836" href="#6437" class="Generalizable">ds</a>
          <a id="17849" class="Symbol">→</a> <a id="17851" href="../code/binary/Prelude.html#1182" class="Field">𝑆</a> <a id="17853" href="../code/binary/Prelude.html#621" class="Function Operator">×</a> <a id="17855" href="#846" class="Generalizable">T</a> <a id="17857" class="Number">0</a>
  <a id="17861" href="#17718" class="Function">running</a> <a id="17869" href="#17869" class="Bound">l</a> <a id="17871" href="#17871" class="Bound">s</a> <a id="17873" class="Symbol">(</a><a id="17874" href="#17874" class="Bound">x</a> <a id="17876" href="#7886" class="InductiveConstructor Operator">∷</a> <a id="17878" href="#17878" class="Bound">xs</a><a id="17880" class="Symbol">)</a> <a id="17882" class="Symbol">(</a><a id="17883" href="#11105" class="InductiveConstructor">there</a> <a id="17889" href="#17889" class="Bound">i</a> <a id="17891" href="#17891" class="Bound">is</a><a id="17893" class="Symbol">)</a> <a id="17895" class="Symbol">=</a>
    <a id="17901" class="Keyword">let</a> <a id="17905" href="#17905" class="Bound">y</a> <a id="17907" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="17909" href="#17909" class="Bound">ys</a> <a id="17912" class="Symbol">=</a> <a id="17914" href="#17718" class="Function">running</a> <a id="17922" class="Symbol">(</a><a id="17923" href="#17869" class="Bound">l</a> <a id="17925" href="../code/binary/Prelude.html#942" class="Function Operator">∘</a> <a id="17927" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a><a id="17930" class="Symbol">)</a> <a id="17932" class="Symbol">(</a><a id="17933" href="#17871" class="Bound">s</a> <a id="17935" href="../code/binary/Prelude.html#942" class="Function Operator">∘</a> <a id="17937" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a><a id="17940" class="Symbol">)</a> <a id="17942" href="#17878" class="Bound">xs</a> <a id="17945" href="#17891" class="Bound">is</a>
        <a id="17956" href="#17956" class="Bound">z</a> <a id="17958" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="17960" href="#17960" class="Bound">zs</a> <a id="17963" class="Symbol">=</a> <a id="17965" href="#17869" class="Bound">l</a> <a id="17967" class="Symbol">_</a> <a id="17969" href="#17889" class="Bound">i</a> <a id="17971" href="#17909" class="Bound">ys</a>
    <a id="17978" class="Keyword">in</a> <a id="17981" href="#17871" class="Bound">s</a> <a id="17983" class="Symbol">_</a> <a id="17985" href="#17874" class="Bound">x</a> <a id="17987" href="../code/binary/Prelude.html#1196" class="Field Operator">∙</a> <a id="17989" href="#17905" class="Bound">y</a> <a id="17991" href="../code/binary/Prelude.html#1196" class="Field Operator">∙</a> <a id="17993" href="#17956" class="Bound">z</a> <a id="17995" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="17997" href="#17960" class="Bound">zs</a>
  <a id="18002" href="#17718" class="Function">running</a> <a id="18010" href="#18010" class="Bound">l</a> <a id="18012" href="#18012" class="Bound">s</a> <a id="18014" class="Symbol">(</a><a id="18015" href="#18015" class="Bound">x</a> <a id="18017" href="#7956" class="InductiveConstructor Operator">1∷</a> <a id="18020" href="#18020" class="Bound">xs</a><a id="18022" class="Symbol">)</a> <a id="18024" href="#11007" class="InductiveConstructor">here₁</a> <a id="18030" class="Symbol">=</a> <a id="18032" href="../code/binary/Prelude.html#1216" class="Field">ε</a> <a id="18034" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="18036" href="#18015" class="Bound">x</a>
  <a id="18040" href="#17718" class="Function">running</a> <a id="18048" href="#18048" class="Bound">l</a> <a id="18050" href="#18050" class="Bound">s</a> <a id="18052" class="Symbol">(</a><a id="18053" href="#18053" class="Bound">x</a> <a id="18055" href="#7994" class="InductiveConstructor Operator">2∷</a> <a id="18058" href="#18058" class="Bound">xs</a><a id="18060" class="Symbol">)</a> <a id="18062" class="Symbol">(</a><a id="18063" href="#11056" class="InductiveConstructor">here₂</a> <a id="18069" href="#18069" class="Bound">i</a><a id="18070" class="Symbol">)</a> <a id="18072" class="Symbol">=</a> <a id="18074" href="#18048" class="Bound">l</a> <a id="18076" class="Symbol">_</a> <a id="18078" href="#18069" class="Bound">i</a> <a id="18080" href="#18053" class="Bound">x</a>

  <a id="18085" href="#18085" class="Function">prefix</a> <a id="18092" class="Symbol">:</a> <a id="18094" href="#15848" class="Function">Fenwick</a> <a id="18102" href="#6437" class="Generalizable">ds</a> <a id="18105" class="Symbol">→</a> <a id="18107" href="#10969" class="Datatype">Fin𝔹</a> <a id="18112" href="../code/binary/Prelude.html#1369" class="Datatype">Bool</a> <a id="18117" href="#6437" class="Generalizable">ds</a> <a id="18120" class="Symbol">→</a> <a id="18122" href="../code/binary/Prelude.html#1182" class="Field">𝑆</a>
  <a id="18126" href="#18085" class="Function">prefix</a> <a id="18133" href="#18133" class="Bound">xs</a> <a id="18136" href="#18136" class="Bound">is</a> <a id="18139" class="Symbol">=</a> <a id="18141" class="Keyword">let</a> <a id="18145" href="#18145" class="Bound">ys</a> <a id="18148" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="18150" href="#18150" class="Bound">zs</a> <a id="18153" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="18155" class="Symbol">_</a> <a id="18157" class="Symbol">=</a> <a id="18159" href="#17718" class="Function">running</a> <a id="18167" href="#18214" class="Function">ind</a> <a id="18171" class="Symbol">(λ</a> <a id="18174" href="#18174" class="Bound">_</a> <a id="18176" class="Symbol">→</a> <a id="18178" href="../code/binary/Agda.Builtin.Sigma.html#225" class="Field">fst</a><a id="18181" class="Symbol">)</a> <a id="18183" href="#18133" class="Bound">xs</a> <a id="18186" href="#18136" class="Bound">is</a> <a id="18189" class="Keyword">in</a> <a id="18192" href="#18145" class="Bound">ys</a> <a id="18195" href="../code/binary/Prelude.html#1196" class="Field Operator">∙</a> <a id="18197" href="#18150" class="Bound">zs</a>
    <a id="18204" class="Keyword">where</a>
    <a id="18214" href="#18214" class="Function">ind</a> <a id="18218" class="Symbol">:</a> <a id="18220" class="Symbol">∀</a> <a id="18222" href="#18222" class="Bound">n</a> <a id="18224" class="Symbol">→</a> <a id="18226" href="../code/binary/Prelude.html#1369" class="Datatype">Bool</a> <a id="18231" class="Symbol">→</a> <a id="18233" href="#15699" class="Function">Summary</a> <a id="18241" class="Symbol">(</a><a id="18242" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="18246" href="#18222" class="Bound">n</a><a id="18247" class="Symbol">)</a> <a id="18249" class="Symbol">→</a> <a id="18251" href="../code/binary/Prelude.html#1182" class="Field">𝑆</a> <a id="18253" href="../code/binary/Prelude.html#621" class="Function Operator">×</a> <a id="18255" href="#15699" class="Function">Summary</a> <a id="18263" href="#18222" class="Bound">n</a>
    <a id="18269" href="#18214" class="Function">ind</a> <a id="18273" href="#18273" class="Bound">n</a> <a id="18275" href="../code/binary/Prelude.html#1388" class="InductiveConstructor">false</a> <a id="18281" class="Symbol">(_</a> <a id="18284" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="18286" class="Symbol">(</a><a id="18287" href="#18287" class="Bound">xs</a> <a id="18290" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="18292" class="Symbol">_)</a> <a id="18295" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="18297" class="Symbol">_)</a> <a id="18300" class="Symbol">=</a> <a id="18302" href="../code/binary/Prelude.html#1216" class="Field">ε</a> <a id="18304" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="18306" href="#18287" class="Bound">xs</a>
    <a id="18313" href="#18214" class="Function">ind</a> <a id="18317" href="#18317" class="Bound">n</a> <a id="18319" href="../code/binary/Prelude.html#1403" class="InductiveConstructor">true</a>  <a id="18325" class="Symbol">(_</a> <a id="18328" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="18330" class="Symbol">((</a><a id="18332" href="#18332" class="Bound">x</a> <a id="18334" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="18336" class="Symbol">_)</a> <a id="18339" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="18341" class="Symbol">(</a><a id="18342" href="#18342" class="Bound">y</a> <a id="18344" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="18346" href="#18346" class="Bound">ys</a><a id="18348" class="Symbol">))</a> <a id="18351" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="18353" class="Symbol">_)</a> <a id="18356" class="Symbol">=</a> <a id="18358" href="#18332" class="Bound">x</a> <a id="18360" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="18362" class="Symbol">(</a><a id="18363" href="#18342" class="Bound">y</a> <a id="18365" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="18367" href="#18346" class="Bound">ys</a><a id="18369" class="Symbol">)</a>
</pre>
<h1 class="unnumbered" id="references">References</h1>
<div id="refs" class="references hanging-indent" role="doc-bibliography">
<div id="ref-danvyThereBackAgain2005">
<p>Danvy, Olivier, and Mayer Goldberg. 2005. “There and Back Again.” <em>BRICS Report Series</em> 12 (3). doi:<a href="https://doi.org/10.7146/brics.v12i3.21869">10.7146/brics.v12i3.21869</a>.</p>
</div>
<div id="ref-fonerThereBackAgain2016">
<p>Foner, Kenneth. 2016. “’There and Back Again’ and What Happened After.” New York.</p>
</div>
<div id="ref-okasakiPurelyFunctionalRandomaccess1995">
<p>Okasaki, Chris. 1995. “Purely Functional Random-Access Lists.” In <em>Proceedings of the Seventh International Conference on Functional Programming Languages and Computer Architecture</em>, 86–95. FPCA ’95. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/224164.224187">10.1145/224164.224187</a>.</p>
</div>
<div id="ref-swierstraHeterogeneousRandomaccessLists2019">
<p>Swierstra, Wouter. 2019. “Heterogeneous Random-Access Lists.”</p>
</div>
</div>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
