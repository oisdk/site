<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Pure and Lazy Breadth-First Traversals of Graphs in Haskell - Donnacha Oisín Kidney</title>
        <style>body{color:black;font-family:Garamond,Times New Roman,serif;font-size:14px;margin:0px auto 0px auto;padding-left:5px;padding-right:5px;max-width:600px}math{font-size:13px}img{max-width:600px}div#header{border-bottom:3px double black;margin-bottom:30px;padding:12px 0px 12px 0px}div#logo a{color:black;float:left;font-size:20px;text-decoration:none}div#header #navigation{text-align:right}div#header #navigation a{color:black;font-family:Garamond,Times New Roman,Serif;font-size:18px;margin-left:10px;text-decoration:none;text-transform:uppercase}div#footer{font-family:Garamond,Times New Roman,Serif;border-top:solid 2px black;color:#555;font-size:12px;margin-top:30px;padding:12px 0px 12px 0px;text-align:right}h1{font-family:Garamond,Times New Roman,Serif;font-size:22px;font-weight:normal}h2{font-family:Garamond,Times New Roman,Serif;font-size:20px;font-weight:normal}div.info{color:#555;font-size:15px;font-style:italic}span.quiet{color:#828282;font-style:italic}a{color:black;word-wrap:break-word}ul.post-list{margin-left:0px;padding-left:0px;list-style-type:none}.hidden_source{display:none}ol.serieslist{counter-reset:item;list-style-type:none;padding-left:20}ol li.serieslist:before{content:'Part ' counter(item,decimal) ':';counter-increment:item}table.sourceCode,tr.sourceCode,td.lineNumbers,td.sourceCode,table.sourceCode pre{margin:0;padding:0;border:0;vertical-align:baseline;border:none}td.lineNumbers{border-right:1px solid #AAAAAA;text-align:right;color:#AAAAAA;padding-right:5px;padding-left:5px}td.sourceCode{padding-left:5px}.sourceCode,code,.Agda{font-size:10px;font-family:menlo,monospace}.sourceCode span.kw{color:#262C6A}.sourceCode span.dt{color:#476A97}.sourceCode span.dv{color:#262C6A}.sourceCode span.bn{color:#262C6A}.sourceCode span.fl{color:#262C6A}.sourceCode span.ch{color:#262C6A}.sourceCode span.st{color:#702C51}.sourceCode span.co{color:#435138}.sourceCode span.ot{color:#262C6A}.sourceCode span.al{color:red}.sourceCode span.fu{color:#000000}.sourceCode span.re{color:#000000}.sourceCode span.er{color:red}li{margin-bottom:2px}li:last-child{margin-bottom:0px}.Agda .Comment{color:#B22222}.Agda .Background{}.Agda .Markup{color:#000000}.Agda .Keyword{color:#CD6600}.Agda .String{color:#B22222}.Agda .Number{color:#A020F0}.Agda .Symbol{color:#404040}.Agda .PrimitiveType{color:#0000CD}.Agda .Pragma{color:black}.Agda .Operator{}.Agda .Bound{color:black}.Agda .Generalizable{color:black}.Agda .InductiveConstructor{color:#008B00}.Agda .CoinductiveConstructor{color:#8B7500}.Agda .Datatype{color:#0000CD}.Agda .Field{color:#EE1289}.Agda .Function{color:#0000CD}.Agda .Module{color:#A020F0}.Agda .Postulate{color:#0000CD}.Agda .Primitive{color:#0000CD}.Agda .Record{color:#0000CD}.Agda .DottedPattern{}.Agda .UnsolvedMeta{color:black;background:yellow}.Agda .UnsolvedConstraint{color:black;background:yellow}.Agda .TerminationProblem{color:black;background:#FFA07A}.Agda .IncompletePattern{color:black;background:#F5DEB3}.Agda .Error{color:red;text-decoration:underline}.Agda .TypeChecks{color:black;background:#ADD8E6}.Agda a{text-decoration:none}.Agda a[href]:hover{background-color:#B4EEB4}.sourceCode{overflow-x:auto}</style>
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Donnacha Oisín Kidney</a>
            </div>
            <div id="navigation">
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../rss.xml">Feed</a>
                <a href="../snippets.html">Snippets</a>
            </div>
        </div>

        <div id="content">
            <h2>Pure and Lazy Breadth-First Traversals of Graphs in Haskell</h2>

            <div class="info">
    Posted on December 18, 2018
</div>
<div class="info">
    
        Part 5 of a <a href="../series/Breadth-First%20Traversals.html">8-part series on Breadth-First Traversals</a>
    
</div>
<div class="info">
    
        Tags: <a href="../tags/Haskell.html">Haskell</a>
    
</div>

<p>Today, I’m going to look at extending the previous breadth-first traversal algorithms to arbitrary graphs (rather than just trees). Graphs with cycles are notoriously cumbersome in functional languages, so this actually proves to be a little trickier than I thought it would be. First, a quick recap.</p>
<h1 id="ways-to-breadth-first-search">3 Ways to Breadth-First Search</h1>
<p>So far, we have three major ways to traverse a tree in breadth-first order. The first is the simplest, and the fastest:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">bfe ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">bfe r <span class="fu">=</span> f r b []</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">    f (<span class="dt">Node</span> x xs) fw bw <span class="fu">=</span> x <span class="fu">:</span> fw (xs <span class="fu">:</span> bw)</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">  </a>
<a class="sourceLine" id="cb1-6" data-line-number="6">    b [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb1-7" data-line-number="7">    b qs <span class="fu">=</span> foldl (foldr f) b qs []</a></code></pre></div>
<p>Given a tree like the following:</p>
<pre><code>   ┌4
 ┌2┤
 │ │ ┌8
 │ └5┤
 │   └9
1┤
 │   ┌10
 │ ┌6┘
 └3┤
   └7</code></pre>
<p>We get:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> bfe tree</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>]</a></code></pre></div>
<p>It also demonstrates a theme that will run through this post: lists are the only <em>visible</em> data structure (other than the tree, of course). However, we are carefully batching the operations on those lists (the <code>foldl</code> is effectively a reverse) so that they have the same complexity as if we had used a queue. In actual fact, when lists are used this way, they <em>are</em> queues: “corecursive” ones <span class="citation" data-cites="allison_circular_2006 smith_lloyd_2009">(Allison <a href="#ref-allison_circular_2006">2006</a>; Smith <a href="#ref-smith_lloyd_2009">2009</a>)</span>.</p>
<p>The next two functions perform a breadth-first traversal “level-wise”: instead of just returning all the nodes of the tree, we get them delimited by how far they are from the root.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">lwe ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">lwe r <span class="fu">=</span> f b r [] []</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">    f k (<span class="dt">Node</span> x xs) ls qs <span class="fu">=</span> k (x <span class="fu">:</span> ls) (xs <span class="fu">:</span> qs)</a>
<a class="sourceLine" id="cb4-5" data-line-number="5"></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">    b _ [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb4-7" data-line-number="7">    b k qs <span class="fu">=</span> k <span class="fu">:</span> foldl (foldl f) b qs [] []</a>
<a class="sourceLine" id="cb4-8" data-line-number="8"></a>
<a class="sourceLine" id="cb4-9" data-line-number="9"><span class="fu">&gt;&gt;&gt;</span> lwe tree</a>
<a class="sourceLine" id="cb4-10" data-line-number="10">[[<span class="dv">1</span>],[<span class="dv">2</span>,<span class="dv">3</span>],[<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>],[<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>]]</a></code></pre></div>
<p>The above function is very clearly related to the <code>bfe</code> function: we just add another queue (representing the current level), and work from there.</p>
<p>The third of these functions also does level-wise enumeration, but in a direct style (without continuations).</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">lwe ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">lwe r <span class="fu">=</span> f r []</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">    f (<span class="dt">Node</span> x xs) (q<span class="fu">:</span>qs) <span class="fu">=</span> (x<span class="fu">:</span>q) <span class="fu">:</span> foldr f qs xs</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">    f (<span class="dt">Node</span> x xs) []     <span class="fu">=</span> [x]   <span class="fu">:</span> foldr f [] xs</a></code></pre></div>
<p>There are more techniques out there than just these three (including the one in <a href="http://hackage.haskell.org/package/containers-0.6.0.1/docs/Data-Tree.html#v:levels">Data.Tree</a>), but these are my favorite, and they’re what I’ll be looking at today.</p>
<h1 id="graphs-and-purity">Graphs and Purity</h1>
<p>Functional programming in general excels at working with trees and similar data structures. Graphs, though, are trickier. There’s been a lot of recent work in improving the situation <span class="citation" data-cites="mokhov_algebraic_2017">(Mokhov <a href="#ref-mokhov_algebraic_2017">2017</a>)</span>, but I’m going to keep it simple today: a graph is just a function.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Graph</span> a <span class="fu">=</span> a <span class="ot">-&gt;</span> [a]</a></code></pre></div>
<p>So the tree from above could be represented as:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1">graph <span class="dv">1</span> <span class="fu">=</span> [<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">graph <span class="dv">2</span> <span class="fu">=</span> [<span class="dv">4</span>,<span class="dv">5</span>]</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">graph <span class="dv">3</span> <span class="fu">=</span> [<span class="dv">6</span>,<span class="dv">7</span>]</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">graph <span class="dv">5</span> <span class="fu">=</span> [<span class="dv">8</span>,<span class="dv">9</span>]</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">graph <span class="dv">6</span> <span class="fu">=</span> [<span class="dv">10</span>]</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">graph _ <span class="fu">=</span> []</a></code></pre></div>
<p>As it happens, all of the algorithms that follow will work on graphs represented as rose trees (or represented any way, really).</p>
<p>So let’s fire up our first traversal!</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">bfs ::</span> <span class="dt">Graph</span> a <span class="ot">-&gt;</span> <span class="dt">Graph</span> a</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">bfs g r <span class="fu">=</span> f r b []</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">    f x fw bw <span class="fu">=</span> x <span class="fu">:</span> fw (g x <span class="fu">:</span> bw)</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">  </a>
<a class="sourceLine" id="cb8-6" data-line-number="6">    b [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">    b qs <span class="fu">=</span> foldl (foldr f) b qs []</a>
<a class="sourceLine" id="cb8-8" data-line-number="8">    </a>
<a class="sourceLine" id="cb8-9" data-line-number="9"><span class="fu">&gt;&gt;&gt;</span> bfs graph <span class="dv">1</span></a>
<a class="sourceLine" id="cb8-10" data-line-number="10">[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>]</a></code></pre></div>
<p>Unfortunately, this won’t handle cycles properly:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1">graph <span class="dv">1</span> <span class="fu">=</span> [<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">graph <span class="dv">2</span> <span class="fu">=</span> [<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">graph <span class="dv">3</span> <span class="fu">=</span> [<span class="dv">6</span>,<span class="dv">7</span>]</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">graph <span class="dv">5</span> <span class="fu">=</span> [<span class="dv">8</span>,<span class="dv">9</span>]</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">graph <span class="dv">6</span> <span class="fu">=</span> [<span class="dv">10</span>]</a>
<a class="sourceLine" id="cb9-6" data-line-number="6">graph _ <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb9-7" data-line-number="7"></a>
<a class="sourceLine" id="cb9-8" data-line-number="8"><span class="fu">&gt;&gt;&gt;</span> bfs graph <span class="dv">1</span></a>
<a class="sourceLine" id="cb9-9" data-line-number="9">[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">1</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">10</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">1</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">10</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">1</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">10</span>,<span class="dv">4</span>,<span class="dv">5</span><span class="fu">...</span></a></code></pre></div>
<p>We need a way to mark off what we’ve already seen. The following isn’t good enough, also:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> nub (bfs graph <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span><span class="fu">...</span></a></code></pre></div>
<p>It will hang without finishing the list. The solution is to mark off nodes as we find them, with some set structure:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">bfs ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Graph</span> a <span class="ot">-&gt;</span> <span class="dt">Graph</span> a</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">bfs g ts <span class="fu">=</span> f ts b [] Set.empty</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4">    f x fw bw s</a>
<a class="sourceLine" id="cb11-5" data-line-number="5">      <span class="fu">|</span> Set.member x s <span class="fu">=</span> fw bw s</a>
<a class="sourceLine" id="cb11-6" data-line-number="6">      <span class="fu">|</span> otherwise      <span class="fu">=</span> x <span class="fu">:</span> fw (g x <span class="fu">:</span> bw) (Set.insert x s)</a>
<a class="sourceLine" id="cb11-7" data-line-number="7"></a>
<a class="sourceLine" id="cb11-8" data-line-number="8">    b [] _ <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb11-9" data-line-number="9">    b qs s <span class="fu">=</span> foldl (foldr f) b qs [] s</a>
<a class="sourceLine" id="cb11-10" data-line-number="10"></a>
<a class="sourceLine" id="cb11-11" data-line-number="11"><span class="fu">&gt;&gt;&gt;</span> bfs graph <span class="dv">1</span></a>
<a class="sourceLine" id="cb11-12" data-line-number="12">[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>]</a></code></pre></div>
<p>The levelwise algorithm is similar:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="ot">lws ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Graph</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [[a]] </a>
<a class="sourceLine" id="cb12-2" data-line-number="2">lws g r <span class="fu">=</span> f b r [] [] Set.empty</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">    f k x ls qs s</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">      <span class="fu">|</span> Set.member x s <span class="fu">=</span> k ls qs s</a>
<a class="sourceLine" id="cb12-6" data-line-number="6">      <span class="fu">|</span> otherwise <span class="fu">=</span> k (x <span class="fu">:</span> ls) (g x <span class="fu">:</span> qs) (Set.insert x s)</a>
<a class="sourceLine" id="cb12-7" data-line-number="7"></a>
<a class="sourceLine" id="cb12-8" data-line-number="8">    b _ [] _ <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb12-9" data-line-number="9">    b k qs s <span class="fu">=</span> k <span class="fu">:</span> foldl (foldl f) b qs [] [] s</a></code></pre></div>
<h1 id="tying-the-knot">Tying the Knot</h1>
<p>The other levelwise algorithm <em>doesn’t</em> translate across so easily. To see why, let’s look at the version without cycle detection:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="ot">lws ::</span> <span class="dt">Graph</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">lws g r <span class="fu">=</span> f r []</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4">    f x (q<span class="fu">:</span>qs) <span class="fu">=</span> (x<span class="fu">:</span>q) <span class="fu">:</span> foldr f qs (g x)</a>
<a class="sourceLine" id="cb13-5" data-line-number="5">    f x []     <span class="fu">=</span> [x]   <span class="fu">:</span> foldr f [] (g x)</a></code></pre></div>
<p>The recursive call is being made <em>depth</em>-first, not breadth-first. The result, of course, is breadth-first, but that’s only because the recursive call zips as it goes.</p>
<p>Just looking at the fourth line for now:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1">f x (q<span class="fu">:</span>qs) <span class="fu">=</span> (x<span class="fu">:</span>q) <span class="fu">:</span> foldr f qs (g x)</a></code></pre></div>
<p>We want whatever process built up that <code>q</code> to be denied access to <code>x</code>. The following doesn’t work:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1">f x (q<span class="fu">:</span>qs) <span class="fu">=</span> (x<span class="fu">:</span>filter (x<span class="fu">/=</span>) q) <span class="fu">:</span> foldr f qs (g x)</a></code></pre></div>
<p>As well as being terribly slow, the later computation can diverge when it finds a cycle, and filtering won’t do anything to help that.</p>
<p>The solution is to “tie the knot”. We basically do two passes over the data: one to build up the “seen so far” list, and then another to do the actual search. The trick is to do both of these passes at once, and feed the result back into the demanding computation.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1">lws g r <span class="fu">=</span> takeWhile (not<span class="fu">.</span>null) (map fst (fix (f r <span class="fu">.</span> push)))</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3">    push xs <span class="fu">=</span> ([],Set.empty) <span class="fu">:</span> [ ([],seen) <span class="fu">|</span> (_,seen) <span class="ot">&lt;-</span> xs ]</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">    f x q<span class="fu">@</span>((l,s)<span class="fu">:</span>qs)</a>
<a class="sourceLine" id="cb16-5" data-line-number="5">      <span class="fu">|</span> Set.member x s <span class="fu">=</span> q</a>
<a class="sourceLine" id="cb16-6" data-line-number="6">      <span class="fu">|</span> otherwise <span class="fu">=</span> (x<span class="fu">:</span>l, Set.insert x s) <span class="fu">:</span> foldr f qs (g x)</a></code></pre></div>
<p>And it works!</p>
<p>I got the idea for this trick from the appendix of <span class="citation" data-cites="okasaki_breadth-first_2000">Okasaki (<a href="#ref-okasaki_breadth-first_2000">2000</a>)</span>. There’s something similar in <span class="citation" data-cites="kiselyov_pure-functional_2002">Kiselyov (<a href="#ref-kiselyov_pure-functional_2002">2002</a>)</span>.</p>
<hr />
<h1 id="references" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-allison_circular_2006">
<p>Allison, Lloyd. 2006. “Circular Programs and Self-Referential Structures.” <em>Software: Practice and Experience</em> 19 (2) (October): 99–109. doi:<a href="https://doi.org/10.1002/spe.4380190202">10.1002/spe.4380190202</a>.</p>
</div>
<div id="ref-kiselyov_pure-functional_2002">
<p>Kiselyov, Oleg. 2002. “Pure-functional transformations of cyclic graphs and the Credit Card Transform.” <a href="http://okmij.org/ftp/Haskell/AlgorithmsH.html#ccard-transform" class="uri">http://okmij.org/ftp/Haskell/AlgorithmsH.html#ccard-transform</a>.</p>
</div>
<div id="ref-mokhov_algebraic_2017">
<p>Mokhov, Andrey. 2017. “Algebraic Graphs with Class (Functional Pearl).” In <em>Proceedings of the 10th ACM SIGPLAN International Symposium on Haskell</em>, 2–13. Haskell 2017. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/3122955.3122956">10.1145/3122955.3122956</a>.</p>
</div>
<div id="ref-okasaki_breadth-first_2000">
<p>Okasaki, Chris. 2000. “Breadth-first Numbering: Lessons from a Small Exercise in Algorithm Design.” In <em>Proceedings of the Fifth ACM SIGPLAN International Conference on Functional Programming</em>, 131–136. ICFP ’00. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/351240.351253">10.1145/351240.351253</a>.</p>
</div>
<div id="ref-smith_lloyd_2009">
<p>Smith, Leon P. 2009. “Lloyd Allison’s Corecursive Queues: Why Continuations Matter.” <em>The Monad.Reader</em> 14 (14) (July): 28.</p>
</div>
</div>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
