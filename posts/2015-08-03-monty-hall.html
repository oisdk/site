<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Monty Hall - Donnacha Oisín Kidney</title>
        <style>body{color:black;font-family:Garamond,Times New Roman,serif;font-size:15px;margin:0px auto 0px auto;padding-left:5px;padding-right:5px;max-width:650px}math{font-size:13px}img{max-width:600px}summary{outline:0}div#header{border-bottom:3px double black;margin-bottom:30px;padding:12px 0px 12px 0px}div#logo a{color:black;float:left;font-size:20px;text-decoration:none}div#header #navigation{text-align:right}div#header #navigation a{color:black;font-family:Garamond,Times New Roman,Serif;font-size:18px;margin-left:10px;text-decoration:none;text-transform:uppercase}div#footer{font-family:Garamond,Times New Roman,Serif;border-top:solid 2px black;color:#555;font-size:12px;margin-top:30px;padding:12px 0px 12px 0px;text-align:right}h1{font-family:Garamond,Times New Roman,Serif;font-size:22px;font-weight:normal}h2{font-family:Garamond,Times New Roman,Serif;font-size:20px;font-weight:normal}div.info{color:#555;font-size:15px;font-style:italic}span.quiet{color:#828282;font-style:italic}a{color:black;word-wrap:break-word}ul.post-list{margin-left:0px;padding-left:0px;list-style-type:none}.hidden_source{display:none}ol.serieslist{counter-reset:item;list-style-type:none;padding-left:20}ol li.serieslist:before{content:'Part ' counter(item,decimal) ':';counter-increment:item}table.sourceCode,tr.sourceCode,td.lineNumbers,td.sourceCode,table.sourceCode pre{margin:0;padding:0;border:0;vertical-align:baseline;border:none}td.lineNumbers{border-right:1px solid #AAAAAA;text-align:right;color:#AAAAAA;padding-right:5px;padding-left:5px}td.sourceCode{padding-left:5px}.sourceCode,code,pre,.Agda{font-size:10px;font-family:menlo,monospace}.sourceCode span.kw{color:#262C6A}.sourceCode span.dt{color:#476A97}.sourceCode span.dv{color:#262C6A}.sourceCode span.bn{color:#262C6A}.sourceCode span.fl{color:#262C6A}.sourceCode span.ch{color:#262C6A}.sourceCode span.st{color:#702C51}.sourceCode span.co{color:#435138}.sourceCode span.ot{color:#262C6A}.sourceCode span.al{color:red}.sourceCode span.fu{color:#000000}.sourceCode span.re{color:#000000}.sourceCode span.er{color:red}li{margin-bottom:2px}li:last-child{margin-bottom:0px}.Agda .Comment{color:#B22222}.Agda .Background{}.Agda .Markup{color:#000000}.Agda .Keyword{color:#CD6600}.Agda .String{color:#B22222}.Agda .Number{color:#A020F0}.Agda .Symbol{color:#404040}.Agda .PrimitiveType{color:#0000CD}.Agda .Pragma{color:black}.Agda .Operator{}.Agda .Bound{color:black}.Agda .Generalizable{color:black}.Agda .InductiveConstructor{color:#008B00}.Agda .CoinductiveConstructor{color:#8B7500}.Agda .Datatype{color:#0000CD}.Agda .Field{color:#EE1289}.Agda .Function{color:#0000CD}.Agda .Module{color:#A020F0}.Agda .Postulate{color:#0000CD}.Agda .Primitive{color:#0000CD}.Agda .Record{color:#0000CD}.Agda .DottedPattern{}.Agda .UnsolvedMeta{color:black;background:yellow}.Agda .UnsolvedConstraint{color:black;background:yellow}.Agda .TerminationProblem{color:black;background:#FFA07A}.Agda .IncompletePattern{color:black;background:#F5DEB3}.Agda .Error{color:red;text-decoration:underline}.Agda .TypeChecks{color:black;background:#ADD8E6}.Agda a{text-decoration:none}.Agda a[href]:hover{background-color:#B4EEB4}.sourceCode{overflow-x:auto}</style>
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Donnacha Oisín Kidney</a>
            </div>
            <div id="navigation">
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../rss.xml">Feed</a>
            </div>
        </div>

        <div id="content">
            <h2>Monty Hall</h2>

            <div class="info">
    Posted on August  3, 2015
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a title="All pages tagged 'Haskell'." href="../tags/Haskell.html" rel="tag">Haskell</a>, <a title="All pages tagged 'Swift'." href="../tags/Swift.html" rel="tag">Swift</a>, <a title="All pages tagged 'Probability'." href="../tags/Probability.html" rel="tag">Probability</a>
    
</div>

<p>The Monty Hall problem is a great example of how counter-intuitive
probability can sometimes be. It goes something like this: say you’re on
a gameshow, with the chance to win a car. You’re shown three doors, and
the car is behind one, goats behind the other two. You pick a door, say
the leftmost, but then the host of the gameshow stops you before it’s
opened. He opens one of the two doors you didn’t pick, revealing a goat.
He then asks you if you’d like to change your decision. So? Do you?</p>
<p>Perhaps surprisingly, you <em>should</em> change your decision. Your
chances of winning a car go from 1/3 to 2/3.</p>
<p>If you’ve not thought for a while about the problem, the answer above
might sound instinctively wrong. A few <a href="http://www.thomashanning.com/swift-playground-the-monty-hall-problem/">blog
posts</a> over the past few weeks have made an effort to put some
concrete numbers to the statistics, running simulations of each
possibility, and counting up the amount of wins and losses.</p>
<p>I was still a little unsatisfied, though. I mean, showing me the
actual numbers is fine, but I’d like something a little more
<em>proof</em>-y. You can get close with a diagram:</p>
<p><img src="../images/monty-hall-tree.png" /></p>
<p>Which makes it pretty clear what’s going on: since the host
<em>has</em> to show a goat when he opens a door, if you’ve picked a
goat, then the only door left after the host opens one is the car. That
means that if you switch and pick a goat, you <em>have</em> to win. So
if you decide to switch, then what you want to do is pick a
<em>goat</em> first, and the chances of that are 2/3.</p>
<p>It would be far cooler if you could get some representation of that
diagram in code, though.</p>
<p>Turns out we can! In Swift and Haskell (I’m branching out) you can
represent probability in a list-like structure, with each element of the
list being a tuple of some value and that value’s probability. All the
probabilities in the list itself should add up to one. Here’s what it
looks like in Swift:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>struct Prob<span class="op">&lt;</span><span class="ex">Element</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">private</span> let contents<span class="op">:</span> <span class="op">[(</span><span class="ex">Element</span><span class="op">,</span> <span class="ex">Double</span><span class="op">)]</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>and Haskell:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Prob</span> a <span class="ot">=</span> <span class="dt">Prob</span> {<span class="ot"> getProb ::</span> [(a,<span class="dt">Rational</span>)] } <span class="kw">deriving</span> <span class="dt">Show</span>  </span></code></pre></div>
<p>Being a list kind of thing, ideally you’d want to be able to
transform the elements, with a map kind of thing:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>extension Prob <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  func fmap<span class="op">&lt;</span>T<span class="op">&gt;(</span>f<span class="op">:</span> <span class="ex">Element</span> <span class="op">-&gt;</span> T<span class="op">)</span> <span class="op">-&gt;</span> Prob<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> Prob<span class="op">&lt;</span>T<span class="op">&gt;(</span>contents<span class="op">.</span>map <span class="op">{</span> <span class="op">(</span>v<span class="op">,</span>p<span class="op">)</span> <span class="fu">in</span> <span class="op">(</span><span class="fu">f</span><span class="op">(</span>v<span class="op">),</span> p<span class="op">)</span> <span class="op">})</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Prob</span> <span class="kw">where</span>  </span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> f (<span class="dt">Prob</span> xs) <span class="ot">=</span> <span class="dt">Prob</span> [(f x,p)<span class="op">|</span>(x,p) <span class="ot">&lt;-</span> xs]</span></code></pre></div>
<p>So far, though, the probability information is kind of superfluous.
There’s not even a decent way to generate it. How about we get it from a
list, where we assume all things in the list have equal chances of
happening:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>extension CollectionType where Index<span class="op">.</span>Distance <span class="op">==</span> <span class="bu">Int</span> <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">var</span> equalProbs<span class="op">:</span> Prob<span class="op">&lt;</span>Generator<span class="op">.</span><span class="ex">Element</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    let p <span class="op">=</span> <span class="fl">1.0</span> <span class="op">/</span> <span class="ex">Double</span><span class="op">(</span>count<span class="op">)</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> Prob<span class="op">&lt;</span>Generator<span class="op">.</span><span class="ex">Element</span><span class="op">&gt;(</span>map <span class="op">{</span> v <span class="fu">in</span> <span class="op">(</span>v<span class="op">,</span>p<span class="op">)</span> <span class="op">})</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">equalProbs ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Prob</span> a</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>equalProbs x <span class="ot">=</span> <span class="dt">Prob</span> <span class="op">$</span> <span class="fu">map</span> (<span class="fu">flip</span> (,) (<span class="dv">1</span><span class="op">%</span>n))  x</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> n <span class="ot">=</span> <span class="fu">fromIntegral</span> (<span class="fu">length</span> x)</span></code></pre></div>
<p>Which is <em>fine</em>, I suppose, but still not very interesting.
What we want is the idea of “branching” - like in the diagram. “If event
A happens, then event B has X chance of happening, and event C has Y
chance of happening”.</p>
<p>The normal rules of probability apply: the <em>overall</em>
probability of B happening is equal to the probability of A multiplied
by X. You could have several layers of branching from B and C onwards,
with this multiplication happening at each stage.</p>
<p>You could represent this in code with a function <code>f</code>,
which takes an event (A) and returns a new bunch of probabilities (B and
C). Then, to get the overall probability of each, you’d have to
<em>flatten</em> it. What you want, then, is a function that travels
over a list of events and their probabilities, applying <code>f</code>
to each, and flattening the result, by <em>multiplying</em> the
probabilities of the inner lists by the probability of the event which
generated it.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>extension Prob <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  func flatMap<span class="op">&lt;</span>T<span class="op">&gt;(</span>f<span class="op">:</span> <span class="ex">Element</span> <span class="op">-&gt;</span> Prob<span class="op">&lt;</span>T<span class="op">&gt;)</span> <span class="op">-&gt;</span> Prob<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> Prob<span class="op">&lt;</span>T<span class="op">&gt;(</span>contents<span class="op">.</span>flatMap <span class="op">{</span> <span class="op">(</span>v<span class="op">,</span>p<span class="op">)</span> in</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>      <span class="fu">f</span><span class="op">(</span>v<span class="op">).</span>contents<span class="op">.</span>map <span class="op">{</span> <span class="op">(</span>x<span class="op">,</span>ip<span class="op">)</span> <span class="fu">in</span> <span class="op">(</span>x<span class="op">,</span>p<span class="op">*</span>ip<span class="op">)</span> <span class="op">}</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">})</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Prob</span> <span class="kw">where</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="ot">=</span> <span class="fu">pure</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Prob</span> xs <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> </span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Prob</span> [(y,px<span class="op">*</span>py)<span class="op">|</span>(x,px) <span class="ot">&lt;-</span> xs, (y,py) <span class="ot">&lt;-</span> getProb(f x)]</span></code></pre></div>
<p>Hey look! The M-word. Never mind that. Anyway…</p>
<p>Now we have enough tools to stimulate some basic probabilities. Let’s
say you’re playing a game, which begins with a coin flip. If you get
heads on the coin flip, it confers some advantage, and you have a 70%
chance of winning. Otherwise, you’ve a 50% chance.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>enum Coin<span class="op">:</span> <span class="ex">String</span>   <span class="op">{</span> <span class="cf">case</span> H<span class="op">,</span> T <span class="op">}</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>enum <span class="ex">Result</span><span class="op">:</span> <span class="ex">String</span> <span class="op">{</span> <span class="cf">case</span> Win<span class="op">,</span> Lose <span class="op">}</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>func <span class="fu">play</span><span class="op">(</span>c<span class="op">:</span> Coin<span class="op">)</span> <span class="op">-&gt;</span> Prob<span class="op">&lt;</span><span class="ex">Result</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>  switch c <span class="op">{</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> <span class="op">.</span>H<span class="op">:</span> <span class="cf">return</span> <span class="fu">Prob</span><span class="op">([(.</span>Win<span class="op">,</span><span class="fl">0.7</span><span class="op">),(.</span>Lose<span class="op">,</span><span class="fl">0.3</span><span class="op">)])</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> <span class="op">.</span>T<span class="op">:</span> <span class="cf">return</span> <span class="op">[.</span>Win<span class="op">,.</span>Lose<span class="op">].</span>equalProbs</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a><span class="op">[</span>Coin<span class="op">.</span>H<span class="op">,.</span>T<span class="op">]</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span>equalProbs</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span><span class="fu">flatMap</span><span class="op">(</span>play<span class="op">)</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a><span class="co">// 0.35: Result.Win</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a><span class="co">// 0.15: Result.Lose</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a><span class="co">// 0.25: Result.Win</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a><span class="co">// 0.25: Result.Lose</span></span></code></pre></div>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Coin</span>   <span class="ot">=</span> <span class="dt">H</span> <span class="op">|</span> <span class="dt">T</span> <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Result</span> <span class="ot">=</span> <span class="dt">Win</span> <span class="op">|</span> <span class="dt">Lose</span> <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> play <span class="dt">H</span> <span class="ot">=</span> <span class="dt">Prob</span> [(<span class="dt">Win</span>,<span class="dv">7</span><span class="op">%</span><span class="dv">10</span>),(<span class="dt">Lose</span>,<span class="dv">3</span><span class="op">%</span><span class="dv">10</span>)]</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    play <span class="dt">T</span> <span class="ot">=</span> equalProbs [<span class="dt">Win</span>,<span class="dt">Lose</span>]</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>equalProbs [<span class="dt">H</span>,<span class="dt">T</span>] <span class="op">&gt;&gt;=</span> play</span></code></pre></div>
<p>There’s an obvious problem: duplicates. We need some way to
<em>combine</em> the results by adding their probabilities together. To
be honest, this was the least interesting part, so I’ll just dump the
code here:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>public enum Ordering <span class="op">{</span> <span class="cf">case</span> LT<span class="op">,</span> EQ<span class="op">,</span> GT <span class="op">}</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>extension SequenceType <span class="op">{</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">private</span> typealias A <span class="op">=</span> Generator<span class="op">.</span><span class="ex">Element</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>  public func <span class="fu">mergeBy</span><span class="op">(</span> comp<span class="op">:</span> <span class="op">(</span>A<span class="op">,</span> A<span class="op">)</span> <span class="op">-&gt;</span> Ordering</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>                     <span class="op">,</span> _ merge<span class="op">:</span> <span class="op">(</span>A<span class="op">,</span> A<span class="op">)</span> <span class="op">-&gt;</span> A<span class="op">)</span> <span class="op">-&gt;</span> <span class="op">[</span>A<span class="op">]</span> <span class="op">{</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">var</span> result<span class="op">:</span> <span class="op">[</span>A<span class="op">]</span> <span class="op">=</span> <span class="op">[]</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> h in <span class="fu">sort</span><span class="op">({</span> e in <span class="fu">comp</span><span class="op">(</span>e<span class="op">)</span> <span class="op">==</span> <span class="op">.</span>LT <span class="op">})</span> <span class="op">{</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> <span class="cf">case</span> <span class="op">.</span>EQ<span class="op">?</span> <span class="op">=</span> result<span class="op">.</span>last<span class="op">.</span><span class="fu">map</span><span class="op">({</span>e in <span class="fu">comp</span><span class="op">(</span>h<span class="op">,</span>e<span class="op">)})</span> <span class="op">{</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>        result<span class="op">.</span><span class="fu">append</span><span class="op">(</span><span class="fu">merge</span><span class="op">(</span>result<span class="op">.</span><span class="fu">removeLast</span><span class="op">(),</span>h<span class="op">))</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>        result<span class="op">.</span><span class="fu">append</span><span class="op">(</span>h<span class="op">)</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>extension Prob <span class="op">{</span></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>  public func mergeProbs</span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">(</span>comp<span class="op">:</span> <span class="op">(</span><span class="ex">Element</span><span class="op">,</span><span class="ex">Element</span><span class="op">)</span> <span class="op">-&gt;</span> Ordering<span class="op">)</span> <span class="op">-&gt;</span> Prob <span class="op">{</span></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="fu">Prob</span><span class="op">(</span>contents<span class="op">:</span></span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>        contents<span class="op">.</span><span class="fu">mergeBy</span><span class="op">(</span> <span class="op">{(</span>a<span class="op">,</span>b<span class="op">)</span> in <span class="fu">comp</span><span class="op">(</span>a<span class="fl">.0</span><span class="op">,</span>b<span class="fl">.0</span><span class="op">)}</span></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>                        <span class="op">,</span> <span class="op">{(</span>a<span class="op">,</span>b<span class="op">)</span> <span class="fu">in</span> <span class="op">(</span>a<span class="fl">.0</span><span class="op">,</span>a<span class="fl">.1</span><span class="op">+</span>b<span class="fl">.1</span><span class="op">)})</span></span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">)</span></span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ot">eqing ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Ordering</span>) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>eqing c <span class="ot">=</span> (\a b <span class="ot">-&gt;</span> <span class="kw">case</span> c a b <span class="kw">of</span> <span class="dt">EQ</span> <span class="ot">-&gt;</span> <span class="dt">True</span> </span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>                                 _  <span class="ot">-&gt;</span> <span class="dt">False</span>)</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="ot">mergeBy ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Ordering</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>mergeBy m c <span class="ot">=</span> (foldl1' m <span class="op">&lt;$&gt;</span>) <span class="op">.</span> groupBy (eqing c) <span class="op">.</span> sortBy c</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="ot">mergeProbs ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Prob</span> a <span class="ot">-&gt;</span> <span class="dt">Prob</span> a</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>mergeProbs <span class="ot">=</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Prob</span> <span class="op">.</span> mergeBy (<span class="fu">fmap</span> <span class="op">.</span> (<span class="op">+</span>) <span class="op">.</span> <span class="fu">snd</span>) (comparing <span class="fu">fst</span>) <span class="op">.</span> getProb</span></code></pre></div>
<p>Now we get some nicer probabilities, though:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>func <span class="fu">comp</span><span class="op">(</span>a<span class="op">:</span> <span class="ex">Result</span><span class="op">,</span> b<span class="op">:</span><span class="ex">Result</span><span class="op">)</span> <span class="op">-&gt;</span> Ordering <span class="op">{</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">switch</span> <span class="op">(</span>a<span class="op">,</span>b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> <span class="op">(.</span>Win<span class="op">,.</span>Win<span class="op">),(.</span>Lose<span class="op">,.</span>Lose<span class="op">):</span> <span class="cf">return</span> <span class="op">.</span>EQ</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> <span class="op">(.</span>Lose<span class="op">,.</span>Win<span class="op">):</span> <span class="cf">return</span> <span class="op">.</span>LT</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> <span class="op">(.</span>Win<span class="op">,.</span>Lose<span class="op">):</span> <span class="cf">return</span> <span class="op">.</span>GT</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="op">[</span>Coin<span class="op">.</span>H<span class="op">,.</span>T<span class="op">]</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span>equalProbs</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span><span class="fu">flatMap</span><span class="op">(</span>play<span class="op">)</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span><span class="fu">mergeProbs</span><span class="op">(</span>comp<span class="op">)</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a><span class="co">// 0.4: Result.Lose</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a><span class="co">// 0.6: Result.Win</span></span></code></pre></div>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Ord</span> <span class="dt">Result</span> <span class="kw">where</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">compare</span> <span class="dt">Win</span> <span class="dt">Lose</span> <span class="ot">=</span> <span class="dt">GT</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">compare</span> <span class="dt">Lose</span> <span class="dt">Win</span> <span class="ot">=</span> <span class="dt">LT</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">compare</span> _    _   <span class="ot">=</span> <span class="dt">EQ</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>mergeProbs ( equalProbs [<span class="dt">H</span>,<span class="dt">T</span>] <span class="op">&gt;&gt;=</span> play )</span></code></pre></div>
<p>And you can see what effect a loaded coin would have on your
chances:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="fu">Prob</span><span class="op">([(</span>Coin<span class="op">.</span>H<span class="op">,</span><span class="fl">0.7</span><span class="op">),(.</span>T<span class="op">,</span><span class="fl">0.3</span><span class="op">)])</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span><span class="fu">flatMap</span><span class="op">(</span>play<span class="op">)</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span><span class="fu">mergeProbs</span><span class="op">(</span>comp<span class="op">)</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="co">// 0.36: Result.Lose</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="co">// 0.64: Result.Win</span></span></code></pre></div>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>mergeProbs ( <span class="dt">Prob</span> [(<span class="dt">H</span>,<span class="dv">7</span><span class="op">%</span><span class="dv">10</span>),(<span class="dt">T</span>,<span class="dv">3</span><span class="op">%</span><span class="dv">10</span>)] <span class="op">&gt;&gt;=</span> play )</span></code></pre></div>
<p>So how does this apply to Monty Hall? Well, we’ve actually done most
of the work already. We’ll represent the doors as an Int, and the choice
by an enum.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>public enum <span class="ex">Choice</span> <span class="op">{</span> <span class="cf">case</span> Switch<span class="op">,</span> Stick <span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Choice</span> <span class="ot">=</span> <span class="dt">Switch</span> <span class="op">|</span> <span class="dt">Stick</span></span></code></pre></div>
<p>Then, a <code class="sourceCode scala">chances</code> function. The
logic here is a bit dense. First of all, if you’re going to stick, it
doesn’t matter how many doors the host opens: your chance of getting a
car is <code>1/n</code>, where <code>n</code> is the number of doors.
However, if you’re going to switch, two things need to happen: you need
to <em>not</em> pick the car on your first choice, <em>and</em> you need
to pick the car on your second choice. The chance of picking the car on
your second choice (if the one you picked on your first choice
<em>wasn’t</em> the car) is the one over the number of doors, minus the
number of doors the host opens, minus one.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>public func <span class="fu">chances</span><span class="op">(</span>n<span class="op">:</span> <span class="bu">Int</span><span class="op">,</span> _ p<span class="op">:</span> <span class="bu">Int</span><span class="op">,</span> _ c<span class="op">:</span> <span class="ex">Choice</span><span class="op">)(</span>_ d<span class="op">:</span> <span class="bu">Int</span><span class="op">)</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">-&gt;</span> Prob<span class="op">&lt;</span>Bool<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    switch c <span class="op">{</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="op">.</span>Stick <span class="op">:</span> <span class="cf">return</span> <span class="op">(</span><span class="dv">1</span><span class="op">...</span>n<span class="op">).</span>equalProbs<span class="op">.</span><span class="fu">fmap</span><span class="op">(==</span>d<span class="op">)</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="op">.</span>Switch<span class="op">:</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>      let notFirst <span class="op">=</span> <span class="fu">chances</span><span class="op">(</span>n<span class="op">,</span>p<span class="op">,.</span>Stick<span class="op">)(</span>d<span class="op">).</span><span class="fu">fmap</span><span class="op">(!)</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>      let second <span class="op">=</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>        <span class="fu">Repeat</span><span class="op">(</span>count<span class="op">:</span> <span class="op">(</span>n<span class="op">-</span>p<span class="op">)-</span><span class="dv">2</span><span class="op">,</span> repeatedValue<span class="op">:</span> <span class="kw">false</span><span class="op">)</span> <span class="op">+</span> <span class="op">[</span><span class="kw">true</span><span class="op">]</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> notFirst<span class="op">.</span>flatMap <span class="op">{</span> f in </span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>        second<span class="op">.</span>equalProbs<span class="op">.</span>fmap <span class="op">{</span> s in f <span class="op">&amp;&amp;</span> s <span class="op">}</span> </span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ot">chances ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Choice</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Prob</span> <span class="dt">Bool</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>chances n _ <span class="dt">Stick</span>  d <span class="ot">=</span> <span class="fu">fmap</span> (<span class="op">==</span>d) (equalProbs [<span class="dv">1</span><span class="op">..</span>n])</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>chances n p <span class="dt">Switch</span> d <span class="ot">=</span> </span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>  (<span class="op">&amp;&amp;</span>) <span class="op">.</span> <span class="fu">not</span>          <span class="op">&lt;$&gt;</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>  chances n p <span class="dt">Stick</span> d <span class="op">&lt;*&gt;</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>  (equalProbs <span class="op">$</span> <span class="dt">True</span> <span class="op">:</span> <span class="fu">replicate</span> (n<span class="op">-</span>p<span class="op">-</span><span class="dv">2</span>) <span class="dt">False</span>)</span></code></pre></div>
<p>Finally, the <code>chanceOfCar</code> function:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>public func chanceOfCar</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">(</span>n<span class="op">:</span> <span class="bu">Int</span><span class="op">,</span> _ p<span class="op">:</span> <span class="bu">Int</span><span class="op">,</span> _ s<span class="op">:</span> <span class="ex">Choice</span><span class="op">)</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">-&gt;</span> Prob<span class="op">&lt;</span>Bool<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">(</span><span class="dv">1</span><span class="op">...</span>n<span class="op">)</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span>equalProbs</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span><span class="fu">flatMap</span><span class="op">(</span><span class="fu">chances</span><span class="op">(</span>n<span class="op">,</span>p<span class="op">,</span>s<span class="op">))</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span><span class="fu">mergeProbs</span><span class="op">(</span>comp<span class="op">)</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="ot">chanceOfCar ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Choice</span> <span class="ot">-&gt;</span> <span class="dt">Prob</span> <span class="dt">Bool</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>chanceOfCar n p s <span class="ot">=</span> mergeProbs <span class="op">$</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>                    equalProbs [<span class="dv">1</span><span class="op">..</span>n] <span class="op">&gt;&gt;=</span> </span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>                    chances n p s</span></code></pre></div>
<p>Which returns, as you’d expect, 1/3 chance of car if you stick, and
2/3 if you switch.</p>
<p>One of the final cool things you can do with this is change the
number of doors, and the number of doors the host opens, and see what
happens:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="fu">chanceOfCar</span><span class="op">(</span><span class="dv">6</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="op">.</span>Switch<span class="op">)</span> </span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="co">// 0.833333333333334: false, 0.166666666666667: true</span></span></code></pre></div>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>chanceOfCar <span class="dv">8</span> <span class="dv">3</span> <span class="dt">Switch</span> <span class="op">//</span> <span class="dv">7</span> <span class="op">%</span> <span class="dv">32</span></span></code></pre></div>
<p>The advantage gets less and less, but never goes away.</p>
<p>If you check out the <a href="https://en.wikipedia.org/wiki/Monty_Hall_problem#N_doors">Wikipedia</a>
entry on the problem, the formula for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>N</mi><annotation encoding="application/x-tex">N</annotation></semantics></math>-doors
is given:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>N</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>N</mi><mo>−</mo><mi>p</mi><mo>−</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac><annotation encoding="application/x-tex">\frac{N−1}{N(N−p−1)}</annotation></semantics></math>.</p>
<p>We can plug that straight in to our versions, to see if they’re
correct:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> sample <span class="ot">=</span> [(n,p)<span class="op">|</span> n <span class="ot">&lt;-</span> [<span class="dv">3</span><span class="op">..</span><span class="dv">20</span>], p <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="op">..</span>(n<span class="op">-</span><span class="dv">2</span>)]] </span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> expect <span class="ot">=</span> <span class="fu">fmap</span> frmla sample</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>             <span class="kw">where</span><span class="ot"> frmla ::</span> (<span class="dt">Integer</span>,<span class="dt">Integer</span>) <span class="ot">-&gt;</span> <span class="dt">Rational</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>                   frmla (n,p) <span class="ot">=</span> (n <span class="op">-</span> <span class="dv">1</span>)<span class="op">%</span>(n<span class="op">*</span>(n<span class="op">-</span>p<span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> actual <span class="ot">=</span> <span class="fu">fmap</span> t sample <span class="kw">where</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>  t (n,p) <span class="ot">=</span> truePrb <span class="op">$</span> getProb <span class="op">$</span> chanceOfCar n p <span class="dt">Switch</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>  truePrb <span class="ot">=</span> fromJust <span class="op">.</span> (<span class="fu">fmap</span> <span class="fu">snd</span>) <span class="op">.</span> (find <span class="fu">fst</span>)</span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>expect <span class="op">==</span> actual</span></code></pre></div>
<p>And it works! (I didn’t try the Swift version, because of
floating-point inaccuracies)</p>
<p>You can see the code used <a href="https://github.com/oisdk/Monty-Hall">here</a>.</p>

        </div>
    </body>
</html>
