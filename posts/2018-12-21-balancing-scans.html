<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Balancing Scans - Donnacha Ois√≠n Kidney</title>
        <style>body{color:black;font-family:Garamond,Times New Roman,serif;font-size:14px;margin:0px auto 0px auto;padding-left:5px;padding-right:5px;max-width:600px}math{font-size:13px}img{max-width:600px}div#header{border-bottom:3px double black;margin-bottom:30px;padding:12px 0px 12px 0px}div#logo a{color:black;float:left;font-size:20px;text-decoration:none}div#header #navigation{text-align:right}div#header #navigation a{color:black;font-family:Garamond,Times New Roman,Serif;font-size:18px;margin-left:10px;text-decoration:none;text-transform:uppercase}div#footer{font-family:Garamond,Times New Roman,Serif;border-top:solid 2px black;color:#555;font-size:12px;margin-top:30px;padding:12px 0px 12px 0px;text-align:right}h1{font-family:Garamond,Times New Roman,Serif;font-size:22px;font-weight:normal}h2{font-family:Garamond,Times New Roman,Serif;font-size:20px;font-weight:normal}div.info{color:#555;font-size:15px;font-style:italic}span.quiet{color:#828282;font-style:italic}a{color:black;word-wrap:break-word}ul.post-list{margin-left:0px;padding-left:0px;list-style-type:none}.hidden_source{display:none}ol.serieslist{counter-reset:item;list-style-type:none;padding-left:20}ol li.serieslist:before{content:'Part ' counter(item,decimal) ':';counter-increment:item}table.sourceCode,tr.sourceCode,td.lineNumbers,td.sourceCode,table.sourceCode pre{margin:0;padding:0;border:0;vertical-align:baseline;border:none}td.lineNumbers{border-right:1px solid #AAAAAA;text-align:right;color:#AAAAAA;padding-right:5px;padding-left:5px}td.sourceCode{padding-left:5px}.sourceCode,code,.Agda{font-size:10px;font-family:menlo,monospace}.sourceCode span.kw{color:#262C6A}.sourceCode span.dt{color:#476A97}.sourceCode span.dv{color:#262C6A}.sourceCode span.bn{color:#262C6A}.sourceCode span.fl{color:#262C6A}.sourceCode span.ch{color:#262C6A}.sourceCode span.st{color:#702C51}.sourceCode span.co{color:#435138}.sourceCode span.ot{color:#262C6A}.sourceCode span.al{color:red}.sourceCode span.fu{color:#000000}.sourceCode span.re{color:#000000}.sourceCode span.er{color:red}li{margin-bottom:2px}li:last-child{margin-bottom:0px}.Agda .Comment{color:#B22222}.Agda .Background{}.Agda .Markup{color:#000000}.Agda .Keyword{color:#CD6600}.Agda .String{color:#B22222}.Agda .Number{color:#A020F0}.Agda .Symbol{color:#404040}.Agda .PrimitiveType{color:#0000CD}.Agda .Pragma{color:black}.Agda .Operator{}.Agda .Bound{color:black}.Agda .Generalizable{color:black}.Agda .InductiveConstructor{color:#008B00}.Agda .CoinductiveConstructor{color:#8B7500}.Agda .Datatype{color:#0000CD}.Agda .Field{color:#EE1289}.Agda .Function{color:#0000CD}.Agda .Module{color:#A020F0}.Agda .Postulate{color:#0000CD}.Agda .Primitive{color:#0000CD}.Agda .Record{color:#0000CD}.Agda .DottedPattern{}.Agda .UnsolvedMeta{color:black;background:yellow}.Agda .UnsolvedConstraint{color:black;background:yellow}.Agda .TerminationProblem{color:black;background:#FFA07A}.Agda .IncompletePattern{color:black;background:#F5DEB3}.Agda .Error{color:red;text-decoration:underline}.Agda .TypeChecks{color:black;background:#ADD8E6}.Agda a{text-decoration:none}.Agda a[href]:hover{background-color:#B4EEB4}.sourceCode{overflow-x:auto}</style>
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Donnacha Ois√≠n Kidney</a>
            </div>
            <div id="navigation">
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../rss.xml">Feed</a>
            </div>
        </div>

        <div id="content">
            <h2>Balancing Scans</h2>

            <div class="info">
    Posted on December 21, 2018
</div>
<div class="info">
    
        Part 2 of a <a href="../series/Balanced%20Folds.html">3-part series on Balanced Folds</a>
    
</div>
<div class="info">
    
        Tags: <a href="../tags/Haskell.html">Haskell</a>, <a href="../tags/Agda.html">Agda</a>
    
</div>

<p><a href="2017-10-30-balancing-folds.html">Previously</a> I tried to figure out a way to fold lists in a more balanced way. Usually, when folding lists, you‚Äôve got two choices for your folds, both of which are extremely unbalanced in one direction or another. Jon Fairbairn <a href="https://www.mail-archive.com/haskell@haskell.org/msg01788.html">wrote</a> a more balanced version, which looked something like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">treeFold ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">treeFold f <span class="fu">=</span> go</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">    go x [] <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">    go a (b<span class="fu">:</span>l) <span class="fu">=</span> go (f a b) (pairMap l)</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">    pairMap (x<span class="fu">:</span>y<span class="fu">:</span>rest) <span class="fu">=</span> f x y <span class="fu">:</span> pairMap rest</a>
<a class="sourceLine" id="cb1-7" data-line-number="7">    pairMap xs <span class="fu">=</span> xs</a></code></pre></div>
<h1 id="magical-speedups">Magical Speedups</h1>
<p>The fold above is kind of magical: for a huge class of algorithms, it kind of ‚Äúautomatically‚Äù improves some factor of theirs from <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n)</annotation></semantics></math> to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math>. For instance: to sum a list of floats, <code class="sourceCode haskell">foldl' (<span class="fu">+</span>) <span class="dv">0</span></code> will have an error growth of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n)</annotation></semantics></math>; <code>treeFold (+) 0</code>, though, has an error rate of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math>. Similarly, using the following function to merge two sorted lists:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">merge ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">merge [] ys <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">merge (x<span class="fu">:</span>xs) ys <span class="fu">=</span> go x xs ys</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5">    go x xs [] <span class="fu">=</span> x <span class="fu">:</span> xs</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">    go x xs (y<span class="fu">:</span>ys)</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">      <span class="fu">|</span> x <span class="fu">&lt;=</span> y    <span class="fu">=</span> x <span class="fu">:</span> go y ys xs</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">      <span class="fu">|</span> otherwise <span class="fu">=</span> y <span class="fu">:</span> go x xs ys</a></code></pre></div>
<p>We get either insertion sort (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n^2)</annotation></semantics></math>) or merge sort (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n \log n)</annotation></semantics></math>) just depending on which fold you use.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1">foldr    merge [] <span class="fu">.</span> map pure <span class="co">-- n^2</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">treeFold merge [] <span class="fu">.</span> map pure <span class="co">-- n log(n)</span></a></code></pre></div>
<p>I‚Äôll give some more examples later, but effectively it gives us a better ‚Äúdivide‚Äù step in many divide and conquer algorithms.</p>
<h1 id="termination">Termination</h1>
<p>As it was such a useful fold, and so integral to many tricky algorithms, I really wanted to have it available in Agda. Unfortunately, though, the functions (as defined above) aren‚Äôt structurally terminating, and there doesn‚Äôt <em>look</em> like there‚Äôs an obvious way to make it so. I tried to make well founded recursion work, but the proofs were ugly and slow.</p>
<p>However, we can use some structures from a <a href="2018-11-20-fast-verified-structures.html">previous post</a>: the nested binary sequence, for instance. It has some extra nice properties: instead of nesting the types, we can just apply the combining function.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">mutual</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  <span class="kw">data</span> Tree <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">    2^<span class="ot">_</span>√ó<span class="ot">_</span>+<span class="ot">_</span> <span class="ot">:</span> ‚Ñï <span class="ot">‚Üí</span> A <span class="ot">‚Üí</span> Node A <span class="ot">‚Üí</span> Tree A</a>
<a class="sourceLine" id="cb4-4" data-line-number="4"></a>
<a class="sourceLine" id="cb4-5" data-line-number="5">  <span class="kw">data</span> Node <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">    ‚ü®‚ü©  <span class="ot">:</span> Node A</a>
<a class="sourceLine" id="cb4-7" data-line-number="7">    ‚ü®<span class="ot">_</span>‚ü© <span class="ot">:</span> Tree A <span class="ot">‚Üí</span> Node A</a>
<a class="sourceLine" id="cb4-8" data-line-number="8"></a>
<a class="sourceLine" id="cb4-9" data-line-number="9"><span class="kw">module</span> TreeFold <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">(_</span>*<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">‚Üí</span> A <span class="ot">‚Üí</span> A<span class="ot">)</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-10" data-line-number="10">  <span class="kw">infixr</span> <span class="dv">5</span> <span class="ot">_</span>‚äõ<span class="ot">_</span> 2^<span class="ot">_</span>√ó<span class="ot">_</span>‚äõ<span class="ot">_</span></a>
<a class="sourceLine" id="cb4-11" data-line-number="11"></a>
<a class="sourceLine" id="cb4-12" data-line-number="12">  2^<span class="ot">_</span>√ó<span class="ot">_</span>‚äõ<span class="ot">_</span> <span class="ot">:</span> ‚Ñï <span class="ot">‚Üí</span> A <span class="ot">‚Üí</span> Tree A <span class="ot">‚Üí</span> Tree A</a>
<a class="sourceLine" id="cb4-13" data-line-number="13">  2^ n √ó x ‚äõ 2^ suc m √ó y + ys <span class="ot">=</span> 2^ n √ó x + ‚ü® 2^ m √ó y + ys ‚ü©</a>
<a class="sourceLine" id="cb4-14" data-line-number="14">  2^ n √ó x ‚äõ 2^ zero  √ó y + ‚ü®‚ü© <span class="ot">=</span> 2^ suc n √ó <span class="ot">(</span>x * y<span class="ot">)</span> + ‚ü®‚ü©</a>
<a class="sourceLine" id="cb4-15" data-line-number="15">  2^ n √ó x ‚äõ 2^ zero  √ó y + ‚ü® ys ‚ü© <span class="ot">=</span> 2^ suc n √ó <span class="ot">(</span>x * y<span class="ot">)</span> ‚äõ ys</a>
<a class="sourceLine" id="cb4-16" data-line-number="16"></a>
<a class="sourceLine" id="cb4-17" data-line-number="17">  <span class="ot">_</span>‚äõ<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">‚Üí</span> Tree A <span class="ot">‚Üí</span> Tree A</a>
<a class="sourceLine" id="cb4-18" data-line-number="18">  <span class="ot">_</span>‚äõ<span class="ot">_</span> <span class="ot">=</span> 2^ <span class="dv">0</span> √ó<span class="ot">_</span>‚äõ<span class="ot">_</span></a>
<a class="sourceLine" id="cb4-19" data-line-number="19"></a>
<a class="sourceLine" id="cb4-20" data-line-number="20">  ‚ü¶<span class="ot">_</span>‚üß‚Üì <span class="ot">:</span> Tree A <span class="ot">‚Üí</span> A</a>
<a class="sourceLine" id="cb4-21" data-line-number="21">  ‚ü¶ 2^ <span class="ot">_</span> √ó x + ‚ü®‚ü© ‚üß‚Üì <span class="ot">=</span> x</a>
<a class="sourceLine" id="cb4-22" data-line-number="22">  ‚ü¶ 2^ <span class="ot">_</span> √ó x + ‚ü® xs ‚ü© ‚üß‚Üì <span class="ot">=</span> x * ‚ü¶ xs ‚üß‚Üì</a>
<a class="sourceLine" id="cb4-23" data-line-number="23"></a>
<a class="sourceLine" id="cb4-24" data-line-number="24">  ‚ü¶<span class="ot">_</span>‚üß‚Üë <span class="ot">:</span> A <span class="ot">‚Üí</span> Tree A</a>
<a class="sourceLine" id="cb4-25" data-line-number="25">  ‚ü¶ x ‚üß‚Üë <span class="ot">=</span> 2^ <span class="dv">0</span> √ó x + ‚ü®‚ü©</a>
<a class="sourceLine" id="cb4-26" data-line-number="26"></a>
<a class="sourceLine" id="cb4-27" data-line-number="27">  ‚¶Ö<span class="ot">_</span>,<span class="ot">_</span>‚¶Ü <span class="ot">:</span> A <span class="ot">‚Üí</span> List A <span class="ot">‚Üí</span> A</a>
<a class="sourceLine" id="cb4-28" data-line-number="28">  ‚¶Ö x , xs ‚¶Ü <span class="ot">=</span> ‚ü¶ foldr <span class="ot">_</span>‚äõ<span class="ot">_</span> ‚ü¶ x ‚üß‚Üë xs ‚üß‚Üì</a></code></pre></div>
<p>Alternatively, we can get <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math> cons with the skew array:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">5</span> <span class="ot">_</span>‚äõ<span class="ot">_</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="ot">_</span>‚äõ<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">‚Üí</span> Tree A <span class="ot">‚Üí</span> Tree A</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">x ‚äõ 2^ n √ó y  + ‚ü®‚ü© <span class="ot">=</span> 2^ <span class="dv">0</span> √ó x + ‚ü® 2^ n √ó y + ‚ü®‚ü© ‚ü©</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">x ‚äõ 2^ n √ó y‚ÇÅ + ‚ü® 2^ <span class="dv">0</span>     √ó y‚ÇÇ + ys ‚ü© <span class="ot">=</span> 2^ suc n √ó <span class="ot">(</span>x * <span class="ot">(</span>y‚ÇÅ * y‚ÇÇ<span class="ot">))</span> + ys</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">x ‚äõ 2^ n √ó y‚ÇÅ + ‚ü® 2^ suc m √ó y‚ÇÇ + ys ‚ü© <span class="ot">=</span> 2^ <span class="dv">0</span> √ó x + ‚ü® 2^ n √ó y‚ÇÅ + ‚ü® 2^ m √ó y‚ÇÇ + ys ‚ü© ‚ü©</a></code></pre></div>
<p>Using this, a proper and efficient merge sort is very straightforward:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">data</span> Total <span class="ot">{</span>a r<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">(_</span>‚â§<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">‚Üí</span> A <span class="ot">‚Üí</span> <span class="dt">Set</span> r<span class="ot">)</span> <span class="ot">(</span>x y <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">(</span>a ‚äî r<span class="ot">)</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  x‚â§y <span class="ot">:</span> ‚¶É <span class="ot">_</span> <span class="ot">:</span> x ‚â§ y ‚¶Ñ <span class="ot">‚Üí</span> Total <span class="ot">_</span>‚â§<span class="ot">_</span> x y</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  y‚â§x <span class="ot">:</span> ‚¶É <span class="ot">_</span> <span class="ot">:</span> y ‚â§ x ‚¶Ñ <span class="ot">‚Üí</span> Total <span class="ot">_</span>‚â§<span class="ot">_</span> x y</a>
<a class="sourceLine" id="cb6-4" data-line-number="4"></a>
<a class="sourceLine" id="cb6-5" data-line-number="5"><span class="kw">module</span> Sorting <span class="ot">{</span>a r<span class="ot">}</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">               <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span></a>
<a class="sourceLine" id="cb6-7" data-line-number="7">               <span class="ot">{_</span>‚â§<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">‚Üí</span> A <span class="ot">‚Üí</span> <span class="dt">Set</span> r<span class="ot">}</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">               <span class="ot">(_</span>‚â§?<span class="ot">_</span> <span class="ot">:</span> <span class="ot">‚àÄ</span> x y <span class="ot">‚Üí</span> Total <span class="ot">_</span>‚â§<span class="ot">_</span> x y<span class="ot">)</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-9" data-line-number="9">  <span class="kw">data</span> [‚àô] <span class="ot">:</span> <span class="dt">Set</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-10" data-line-number="10">    ‚ä•   <span class="ot">:</span> [‚àô]</a>
<a class="sourceLine" id="cb6-11" data-line-number="11">    [<span class="ot">_</span>] <span class="ot">:</span> A <span class="ot">‚Üí</span> [‚àô]</a>
<a class="sourceLine" id="cb6-12" data-line-number="12"></a>
<a class="sourceLine" id="cb6-13" data-line-number="13">  <span class="kw">data</span> <span class="ot">_</span>‚â•<span class="ot">_</span> <span class="ot">(</span>x <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">:</span> [‚àô] <span class="ot">‚Üí</span> <span class="dt">Set</span> <span class="ot">(</span>a ‚äî r<span class="ot">)</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-14" data-line-number="14">    instance ‚åà<span class="ot">_</span>‚åâ <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>y<span class="ot">}</span> <span class="ot">‚Üí</span> y ‚â§ x <span class="ot">‚Üí</span> x ‚â• [ y ]</a>
<a class="sourceLine" id="cb6-15" data-line-number="15">    instance ‚åä‚ä•‚åã <span class="ot">:</span> x ‚â• ‚ä•</a>
<a class="sourceLine" id="cb6-16" data-line-number="16"></a>
<a class="sourceLine" id="cb6-17" data-line-number="17">  <span class="kw">infixr</span> <span class="dv">5</span> <span class="ot">_</span>‚à∑<span class="ot">_</span></a>
<a class="sourceLine" id="cb6-18" data-line-number="18">  <span class="kw">data</span> Ordered <span class="ot">(</span>b <span class="ot">:</span> [‚àô]<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">(</span>a ‚äî r<span class="ot">)</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-19" data-line-number="19">    []  <span class="ot">:</span> Ordered b</a>
<a class="sourceLine" id="cb6-20" data-line-number="20">    <span class="ot">_</span>‚à∑<span class="ot">_</span> <span class="ot">:</span> <span class="ot">‚àÄ</span> x <span class="ot">‚Üí</span> ‚¶É x‚â•b <span class="ot">:</span> x ‚â• b ‚¶Ñ <span class="ot">‚Üí</span> <span class="ot">(</span>xs <span class="ot">:</span> Ordered [ x ]<span class="ot">)</span> <span class="ot">‚Üí</span> Ordered b</a>
<a class="sourceLine" id="cb6-21" data-line-number="21"></a>
<a class="sourceLine" id="cb6-22" data-line-number="22">  <span class="ot">_</span>‚à™<span class="ot">_</span> <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>b<span class="ot">}</span> <span class="ot">‚Üí</span> Ordered b <span class="ot">‚Üí</span> Ordered b <span class="ot">‚Üí</span> Ordered b</a>
<a class="sourceLine" id="cb6-23" data-line-number="23">  [] ‚à™ ys <span class="ot">=</span> ys</a>
<a class="sourceLine" id="cb6-24" data-line-number="24">  <span class="ot">(</span>x ‚à∑ xs<span class="ot">)</span> ‚à™ ys <span class="ot">=</span> ‚üÖ x ‚àπ xs ‚à™ ys ‚üÜ</a>
<a class="sourceLine" id="cb6-25" data-line-number="25">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-26" data-line-number="26">    ‚üÖ<span class="ot">_</span>‚àπ<span class="ot">_</span>‚à™<span class="ot">_</span>‚üÜ <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>b<span class="ot">}</span> <span class="ot">‚Üí</span> <span class="ot">‚àÄ</span> x ‚¶É <span class="ot">_</span> <span class="ot">:</span> x ‚â• b ‚¶Ñ <span class="ot">‚Üí</span> Ordered [ x ] <span class="ot">‚Üí</span> Ordered b <span class="ot">‚Üí</span> Ordered b</a>
<a class="sourceLine" id="cb6-27" data-line-number="27">    ‚üÖ<span class="ot">_</span>‚à™<span class="ot">_</span>‚àπ<span class="ot">_</span>‚üÜ <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>b<span class="ot">}</span> <span class="ot">‚Üí</span> Ordered b <span class="ot">‚Üí</span> <span class="ot">‚àÄ</span> y ‚¶É <span class="ot">_</span> <span class="ot">:</span> y ‚â• b ‚¶Ñ <span class="ot">‚Üí</span> Ordered [ y ] <span class="ot">‚Üí</span> Ordered b</a>
<a class="sourceLine" id="cb6-28" data-line-number="28">    merge <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>b<span class="ot">}</span> x y ‚¶É <span class="ot">_</span> <span class="ot">:</span> x ‚â• b ‚¶Ñ ‚¶É <span class="ot">_</span> <span class="ot">:</span> y ‚â• b ‚¶Ñ</a>
<a class="sourceLine" id="cb6-29" data-line-number="29">          <span class="ot">‚Üí</span> Total <span class="ot">_</span>‚â§<span class="ot">_</span> x y</a>
<a class="sourceLine" id="cb6-30" data-line-number="30">          <span class="ot">‚Üí</span> Ordered [ x ]</a>
<a class="sourceLine" id="cb6-31" data-line-number="31">          <span class="ot">‚Üí</span> Ordered [ y ]</a>
<a class="sourceLine" id="cb6-32" data-line-number="32">          <span class="ot">‚Üí</span> Ordered b</a>
<a class="sourceLine" id="cb6-33" data-line-number="33"></a>
<a class="sourceLine" id="cb6-34" data-line-number="34">    ‚üÖ x ‚àπ xs ‚à™ [] ‚üÜ <span class="ot">=</span> x ‚à∑ xs</a>
<a class="sourceLine" id="cb6-35" data-line-number="35">    ‚üÖ x ‚àπ xs ‚à™ y ‚à∑ ys ‚üÜ <span class="ot">=</span> merge x y <span class="ot">(</span>x ‚â§? y<span class="ot">)</span> xs ys</a>
<a class="sourceLine" id="cb6-36" data-line-number="36">    ‚üÖ [] ‚à™ y ‚àπ ys ‚üÜ <span class="ot">=</span> y ‚à∑ ys</a>
<a class="sourceLine" id="cb6-37" data-line-number="37">    ‚üÖ x ‚à∑ xs ‚à™ y ‚àπ ys ‚üÜ <span class="ot">=</span> merge x y <span class="ot">(</span>x ‚â§? y<span class="ot">)</span> xs ys</a>
<a class="sourceLine" id="cb6-38" data-line-number="38"></a>
<a class="sourceLine" id="cb6-39" data-line-number="39">    merge x y x‚â§y xs ys <span class="ot">=</span> x ‚à∑ ‚üÖ xs ‚à™ y ‚àπ ys ‚üÜ</a>
<a class="sourceLine" id="cb6-40" data-line-number="40">    merge x y y‚â§x xs ys <span class="ot">=</span> y ‚à∑ ‚üÖ x ‚àπ xs ‚à™ ys ‚üÜ</a>
<a class="sourceLine" id="cb6-41" data-line-number="41"></a>
<a class="sourceLine" id="cb6-42" data-line-number="42"></a>
<a class="sourceLine" id="cb6-43" data-line-number="43">  <span class="kw">open</span> TreeFold</a>
<a class="sourceLine" id="cb6-44" data-line-number="44"></a>
<a class="sourceLine" id="cb6-45" data-line-number="45">  sort <span class="ot">:</span> List A <span class="ot">‚Üí</span> Ordered ‚ä•</a>
<a class="sourceLine" id="cb6-46" data-line-number="46">  sort <span class="ot">=</span> ‚¶Ö <span class="ot">_</span>‚à™<span class="ot">_</span> , [] ‚¶Ü ‚àò map <span class="ot">(_</span>‚à∑ []<span class="ot">)</span></a></code></pre></div>
<h1 id="validity">Validity</h1>
<p>It would be nice if we could verify these optimizated versions of folds. Luckily, by writing them using <code>foldr</code>, we‚Äôve stumbled into well-trodden ground: the <em>foldr fusion law</em>. It states that if you have some transformation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>, and two binary operators <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>‚äï</mo><annotation encoding="application/x-tex">\oplus</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>‚äó</mo><annotation encoding="application/x-tex">\otimes</annotation></semantics></math>, then:</p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right"><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>‚äï</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="left"></mtd><mtd columnalign="right"><mo>=</mo><mspace width="0.278em"></mspace></mtd><mtd columnalign="left"><mi>x</mi><mo>‚äó</mo><mi>f</mi><mi>y</mi></mtd></mtr><mtr><mtd columnalign="right"><mo>‚üπ</mo><mi>f</mi><mo>‚àò</mo><mtext mathvariant="normal">foldr</mtext><mo>‚äï</mo><mi>e</mi></mtd><mtd columnalign="left"></mtd><mtd columnalign="right"><mo>=</mo><mspace width="0.278em"></mspace></mtd><mtd columnalign="left"><mtext mathvariant="normal">foldr</mtext><mo>‚äó</mo><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mi>e</mi><mo stretchy="false" form="postfix">)</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align}
   f (x \oplus y)                         &amp;&amp;=\;&amp; x \otimes f y \\
   \implies f \circ \text{foldr} \oplus e &amp;&amp;=\;&amp; \text{foldr} \otimes (f e)
\end{align}</annotation></semantics></math>
<p>This fits right in with the function we used above. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> is <code>‚ü¶_‚üß‚Üì</code>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>‚äï</mo><annotation encoding="application/x-tex">\oplus</annotation></semantics></math> is <code>_‚äõ_</code>, and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>‚äó</mo><annotation encoding="application/x-tex">\otimes</annotation></semantics></math> is whatever combining function was passed in. Let‚Äôs prove the foldr fusion law, then, before we go any further.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">module</span> Proofs</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  <span class="ot">{</span>a r<span class="ot">}</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">  <span class="ot">{</span>R <span class="ot">:</span> Rel A r<span class="ot">}</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6"></a>
<a class="sourceLine" id="cb7-7" data-line-number="7">  <span class="kw">infix</span> <span class="dv">4</span> <span class="ot">_</span>‚âà<span class="ot">_</span></a>
<a class="sourceLine" id="cb7-8" data-line-number="8">  <span class="ot">_</span>‚âà<span class="ot">_</span> <span class="ot">=</span> R</a>
<a class="sourceLine" id="cb7-9" data-line-number="9"></a>
<a class="sourceLine" id="cb7-10" data-line-number="10">  <span class="kw">open</span> <span class="kw">import</span> Algebra<span class="ot">.</span>FunctionProperties <span class="ot">_</span>‚âà<span class="ot">_</span></a>
<a class="sourceLine" id="cb7-11" data-line-number="11"></a>
<a class="sourceLine" id="cb7-12" data-line-number="12">  foldr-universal <span class="ot">:</span> Transitive <span class="ot">_</span>‚âà<span class="ot">_</span></a>
<a class="sourceLine" id="cb7-13" data-line-number="13">                  <span class="ot">‚Üí</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>b<span class="ot">}</span> <span class="ot">{</span>B <span class="ot">:</span> <span class="dt">Set</span> b<span class="ot">}</span> <span class="ot">(</span>h <span class="ot">:</span> List B <span class="ot">‚Üí</span> A<span class="ot">)</span> f e</a>
<a class="sourceLine" id="cb7-14" data-line-number="14">                  <span class="ot">‚Üí</span> ‚àÄ[ f ‚ä¢ Congruent‚ÇÅ ]</a>
<a class="sourceLine" id="cb7-15" data-line-number="15">                  <span class="ot">‚Üí</span> <span class="ot">(</span>h [] ‚âà e<span class="ot">)</span></a>
<a class="sourceLine" id="cb7-16" data-line-number="16">                  <span class="ot">‚Üí</span> <span class="ot">(‚àÄ</span> x xs <span class="ot">‚Üí</span> h <span class="ot">(</span>x ‚à∑ xs<span class="ot">)</span> ‚âà f x <span class="ot">(</span>h xs<span class="ot">))</span></a>
<a class="sourceLine" id="cb7-17" data-line-number="17">                  <span class="ot">‚Üí</span> <span class="ot">‚àÄ</span> xs <span class="ot">‚Üí</span> h xs ‚âà foldr f e xs</a>
<a class="sourceLine" id="cb7-18" data-line-number="18">  foldr-universal <span class="ot">_</span>‚óã<span class="ot">_</span> h f e f‚ü®<span class="ot">_</span>‚ü© ‚áí[] ‚áí<span class="ot">_</span>‚à∑<span class="ot">_</span> [] <span class="ot">=</span> ‚áí[]</a>
<a class="sourceLine" id="cb7-19" data-line-number="19">  foldr-universal <span class="ot">_</span>‚óã<span class="ot">_</span> h f e f‚ü®<span class="ot">_</span>‚ü© ‚áí[] ‚áí<span class="ot">_</span>‚à∑<span class="ot">_</span> <span class="ot">(</span>x ‚à∑ xs<span class="ot">)</span> <span class="ot">=</span></a>
<a class="sourceLine" id="cb7-20" data-line-number="20">    <span class="ot">(</span>‚áí x ‚à∑ xs<span class="ot">)</span> ‚óã f‚ü® foldr-universal <span class="ot">_</span>‚óã<span class="ot">_</span> h f e f‚ü®<span class="ot">_</span>‚ü© ‚áí[] ‚áí<span class="ot">_</span>‚à∑<span class="ot">_</span> xs ‚ü©</a>
<a class="sourceLine" id="cb7-21" data-line-number="21"></a>
<a class="sourceLine" id="cb7-22" data-line-number="22">  foldr-fusion <span class="ot">:</span> Transitive <span class="ot">_</span>‚âà<span class="ot">_</span></a>
<a class="sourceLine" id="cb7-23" data-line-number="23">               <span class="ot">‚Üí</span> Reflexive <span class="ot">_</span>‚âà<span class="ot">_</span></a>
<a class="sourceLine" id="cb7-24" data-line-number="24">               <span class="ot">‚Üí</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>b c<span class="ot">}</span> <span class="ot">{</span>B <span class="ot">:</span> <span class="dt">Set</span> b<span class="ot">}</span> <span class="ot">{</span>C <span class="ot">:</span> <span class="dt">Set</span> c<span class="ot">}</span> <span class="ot">(</span>f <span class="ot">:</span> C <span class="ot">‚Üí</span> A<span class="ot">)</span> <span class="ot">{_</span>‚äï<span class="ot">_</span> <span class="ot">:</span> B <span class="ot">‚Üí</span> C <span class="ot">‚Üí</span> C<span class="ot">}</span> <span class="ot">{_</span>‚äó<span class="ot">_</span> <span class="ot">:</span> B <span class="ot">‚Üí</span> A <span class="ot">‚Üí</span> A<span class="ot">}</span> e</a>
<a class="sourceLine" id="cb7-25" data-line-number="25">               <span class="ot">‚Üí</span> ‚àÄ[ <span class="ot">_</span>‚äó<span class="ot">_</span> ‚ä¢ Congruent‚ÇÅ ]</a>
<a class="sourceLine" id="cb7-26" data-line-number="26">               <span class="ot">‚Üí</span> <span class="ot">(‚àÄ</span> x y <span class="ot">‚Üí</span> f <span class="ot">(</span>x ‚äï y<span class="ot">)</span> ‚âà x ‚äó f y<span class="ot">)</span></a>
<a class="sourceLine" id="cb7-27" data-line-number="27">               <span class="ot">‚Üí</span> <span class="ot">‚àÄ</span> xs <span class="ot">‚Üí</span> f <span class="ot">(</span>foldr <span class="ot">_</span>‚äï<span class="ot">_</span> e xs<span class="ot">)</span> ‚âà foldr <span class="ot">_</span>‚äó<span class="ot">_</span> <span class="ot">(</span>f e<span class="ot">)</span> xs</a>
<a class="sourceLine" id="cb7-28" data-line-number="28">  foldr-fusion <span class="ot">_</span>‚óã<span class="ot">_</span> ‚àé h <span class="ot">{</span>f<span class="ot">}</span> <span class="ot">{</span>g<span class="ot">}</span> e g‚ü®<span class="ot">_</span>‚ü© fuse <span class="ot">=</span></a>
<a class="sourceLine" id="cb7-29" data-line-number="29">    foldr-universal <span class="ot">_</span>‚óã<span class="ot">_</span> <span class="ot">(</span>h ‚àò foldr f e<span class="ot">)</span> g <span class="ot">(</span>h e<span class="ot">)</span> g‚ü®<span class="ot">_</span>‚ü© ‚àé <span class="ot">(Œª</span> x xs <span class="ot">‚Üí</span> fuse x <span class="ot">(</span>foldr f e xs<span class="ot">))</span></a></code></pre></div>
<p>We‚Äôre not using the proofs in Agda‚Äôs standard library because these are tied to propositional equality. In other words, instead of using an abstract binary relation, they prove things over <em>actual</em> equality. That‚Äôs all well and good, but as you can see above, we don‚Äôt need propositional equality: we don‚Äôt even need the relation to be an equivalence, we just need transitivity and reflexivity.</p>
<p>After that, we can state precisely what correspondence the tree fold has, and under what conditions it does the same things as a fold:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">module</span> <span class="ot">_</span> <span class="ot">{_</span>*<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">‚Üí</span> A <span class="ot">‚Üí</span> A<span class="ot">}</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  <span class="kw">open</span> TreeFold <span class="ot">_</span>*<span class="ot">_</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3"></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">  treeFoldHom <span class="ot">:</span> Transitive <span class="ot">_</span>‚âà<span class="ot">_</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5">              <span class="ot">‚Üí</span> Reflexive <span class="ot">_</span>‚âà<span class="ot">_</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">              <span class="ot">‚Üí</span> Associative <span class="ot">_</span>*<span class="ot">_</span></a>
<a class="sourceLine" id="cb8-7" data-line-number="7">              <span class="ot">‚Üí</span> RightCongruent <span class="ot">_</span>*<span class="ot">_</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8">              <span class="ot">‚Üí</span> <span class="ot">‚àÄ</span> x xs</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">              <span class="ot">‚Üí</span> ‚¶Ö x , xs ‚¶Ü ‚âà foldr <span class="ot">_</span>*<span class="ot">_</span> x xs</a>
<a class="sourceLine" id="cb8-10" data-line-number="10">  treeFoldHom <span class="ot">_</span>‚óã<span class="ot">_</span> ‚àé assoc *‚ü®<span class="ot">_</span>‚ü© b <span class="ot">=</span> foldr-fusion <span class="ot">_</span>‚óã<span class="ot">_</span> ‚àé ‚ü¶<span class="ot">_</span>‚üß‚Üì ‚ü¶ b ‚üß‚Üë *‚ü®<span class="ot">_</span>‚ü© <span class="ot">(</span>‚äõ-hom zero<span class="ot">)</span></a>
<a class="sourceLine" id="cb8-11" data-line-number="11">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-12" data-line-number="12">    ‚äõ-hom <span class="ot">:</span> <span class="ot">‚àÄ</span> n x xs <span class="ot">‚Üí</span> ‚ü¶ 2^ n √ó x ‚äõ xs ‚üß‚Üì ‚âà x * ‚ü¶ xs ‚üß‚Üì</a>
<a class="sourceLine" id="cb8-13" data-line-number="13">    ‚äõ-hom n x <span class="ot">(</span>2^ suc m √ó y + ‚ü®‚ü©    <span class="ot">)</span> <span class="ot">=</span> ‚àé</a>
<a class="sourceLine" id="cb8-14" data-line-number="14">    ‚äõ-hom n x <span class="ot">(</span>2^ suc m √ó y + ‚ü® ys ‚ü©<span class="ot">)</span> <span class="ot">=</span> ‚àé</a>
<a class="sourceLine" id="cb8-15" data-line-number="15">    ‚äõ-hom n x <span class="ot">(</span>2^ zero  √ó y + ‚ü®‚ü©    <span class="ot">)</span> <span class="ot">=</span> ‚àé</a>
<a class="sourceLine" id="cb8-16" data-line-number="16">    ‚äõ-hom n x <span class="ot">(</span>2^ zero  √ó y + ‚ü® ys ‚ü©<span class="ot">)</span> <span class="ot">=</span> ‚äõ-hom <span class="ot">(</span>suc n<span class="ot">)</span> <span class="ot">(</span>x * y<span class="ot">)</span> ys ‚óã assoc x y ‚ü¶ ys ‚üß‚Üì</a></code></pre></div>
<h1 id="implicit-data-structures">‚ÄúImplicit‚Äù Data Structures</h1>
<p>Consider the following implementation of the tree above in Haskell:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Tree</span> a <span class="fu">=</span> [(<span class="dt">Int</span>,a)]</a>
<a class="sourceLine" id="cb9-2" data-line-number="2"></a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="ot">cons ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">cons (<span class="fu">*</span>) <span class="fu">=</span> cons' <span class="dv">0</span> </a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6">    cons' n x [] <span class="fu">=</span> [(n,x)]</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">    cons' n x ((<span class="dv">0</span>,y)<span class="fu">:</span>ys) <span class="fu">=</span> cons' (n<span class="fu">+</span><span class="dv">1</span>) (x <span class="fu">*</span> y) ys</a>
<a class="sourceLine" id="cb9-8" data-line-number="8">    cons' n x ((m,y)<span class="fu">:</span>ys) <span class="fu">=</span> (n,x) <span class="fu">:</span> (m<span class="fu">-</span><span class="dv">1</span>,y) <span class="fu">:</span> ys</a></code></pre></div>
<p>The <code>cons</code> function ‚Äúincrements‚Äù that list as if it were the bits of a binary number. Now, consider using the <code>merge</code> function from above, in a pattern like this:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">f <span class="fu">=</span> foldr (cons merge <span class="fu">.</span> pure) []</a></code></pre></div>
<p>What does <code>f</code> build? A list of lists, right?</p>
<p>Kind of. That‚Äôs what‚Äôs built in terms of the observable, but what‚Äôs actually stored in memory us a bunch of thunks. The shape of <em>those</em> is what I‚Äôm interested in. We can try and see what they look like by using a data structure that doesn‚Äôt force on merge:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a <span class="fu">=</span> <span class="dt">Leaf</span> a <span class="fu">|</span> <span class="dt">Tree</span> a <span class="fu">:*:</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb11-2" data-line-number="2"></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">f <span class="fu">=</span> foldr (cons (<span class="fu">:*:</span>) <span class="fu">.</span> <span class="dt">Leaf</span>) []</a></code></pre></div>
<p>Using a handy tree-drawing function, we can see what <code>f [1..13]</code> looks like:</p>
<pre><code>[(0,*),(1,*),(0,*)]
    ‚îî1    ‚îÇ ‚îå2  ‚îÇ  ‚îå6
          ‚îÇ‚îå‚î§   ‚îÇ ‚îå‚î§
          ‚îÇ‚îÇ‚îî3  ‚îÇ ‚îÇ‚îî7
          ‚îî‚î§    ‚îÇ‚îå‚î§
           ‚îÇ‚îå4  ‚îÇ‚îÇ‚îÇ‚îå8
           ‚îî‚î§   ‚îÇ‚îÇ‚îî‚î§
            ‚îî5  ‚îÇ‚îÇ ‚îî9
                ‚îî‚î§
                 ‚îÇ ‚îå10
                 ‚îÇ‚îå‚î§
                 ‚îÇ‚îÇ‚îî11
                 ‚îî‚î§
                  ‚îÇ‚îå12
                  ‚îî‚î§
                   ‚îî13</code></pre>
<p>It‚Äôs a binomial heap! It‚Äôs a list of trees, each one contains <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mi>n</mi></msup><annotation encoding="application/x-tex">2^n</annotation></semantics></math> elements. But they‚Äôre not in heap order, you say? Well, as a matter of fact, they <em>are</em>. It just hasn‚Äôt been evaluated yet. Once we force‚Äîsay‚Äîthe first element, the rest will shuffle themselves into a tree of thunks.</p>
<p>This illustrates a pretty interesting similarity between binomial heaps and merge sort. Performance-wise, though, there‚Äôs another interesting property: the thunks <em>stay thunked</em>. In other words, if we do a merge sort via:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1">sort <span class="fu">=</span> foldr (merge <span class="fu">.</span> snd) [] <span class="fu">.</span> foldr (cons merge <span class="fu">.</span> pure) []</a></code></pre></div>
<p>We could instead freeze the fold, and look at it at every point:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1">sortPrefixes <span class="fu">=</span> map (foldr (merge <span class="fu">.</span> snd) []) <span class="fu">.</span> scanl (flip (cons merge <span class="fu">.</span> pure)) []</a>
<a class="sourceLine" id="cb14-2" data-line-number="2"><span class="fu">&gt;&gt;&gt;</span> [[],[<span class="dv">1</span>],[<span class="dv">1</span>,<span class="dv">4</span>],[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">4</span>],[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>],[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>]]</a></code></pre></div>
<p>And <code>sortPrefixes</code> is only <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n^2)</annotation></semantics></math> (rather than <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n^2 \log n)</annotation></semantics></math>). I confess I don‚Äôt know of a use for sorted prefixes, but it should illustrate the general idea: we get a pretty decent batching of operations, with the ability to freeze at any point in time. The other nice property (which I mentioned in the last post) is that any of the tree folds are extremely parallel.</p>
<h1 id="random-shuffles">Random Shuffles</h1>
<p><a href="http://okmij.org/ftp/Haskell/AlgorithmsH.html#perfect-shuffle">There‚Äôs a great article on shuffling in Haskell</a> which provides an <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n \log n)</annotation></semantics></math> implementation of a perfect random shuffle. Unfortunately, the <a href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle">Fisher-Yates shuffle</a> isn‚Äôt applicable in a pure functional setting, so you have to be a little cleverer.</p>
<p>The first implementation most people jump to (certainly the one I thought of) is to assign everything in the sequence a random number, and then sort according to that number. Perhaps surprisingly, this <em>isn‚Äôt</em> perfectly random! It‚Äôs a little weird, but the example in the article explains it well: basically, for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> elements, your random numbers will have <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>n</mi><mi>n</mi></msup><annotation encoding="application/x-tex">n^n</annotation></semantics></math> possible values, but the output of the sort will have <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>!</mi></mrow><annotation encoding="application/x-tex">n!</annotation></semantics></math> possible values. Since they don‚Äôt divide into each other evenly, you‚Äôre going to have some extra weight on some permutations, and less on others.</p>
<p>Instead, we can generate a random <a href="https://en.wikipedia.org/wiki/Factorial_number_system"><em>factoradic</em></a> number. A factoradic number is one where the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>th digit is in base <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>. Because of this, a factoradic number with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> digits has <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>!</mi></mrow><annotation encoding="application/x-tex">n!</annotation></semantics></math> possible values: exactly what we want.</p>
<p>In the article, the digits of the number are used to pop values from a binary tree. Because the last digit will have <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> possible values, and the second last <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>‚àí</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math>, and so on, you can keep popping without hitting an empty tree.</p>
<p>This has the correct time complexity‚Äî<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n \log n)</annotation></semantics></math>‚Äîbut there‚Äôs a lot of overhead. Building the tree, then indexing into it, the rebuilding after each pop, etc.</p>
<p>We‚Äôd <em>like</em> to just sort the list, according to the indices. The problem is that the indices are relative: if you want to <code>cons</code> something onto the list, you have to increment the rest of the indices, as they‚Äôve all shifted right by one.</p>
<p>What we‚Äôll do instead is use the indices as <em>gaps</em>. Our merge function looks like the following:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1">merge [] ys <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">merge xs [] <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">merge ((x,i)<span class="fu">:</span>xs) ((y,j)<span class="fu">:</span>ys)</a>
<a class="sourceLine" id="cb15-4" data-line-number="4">  <span class="fu">|</span> i <span class="fu">&lt;=</span> j    <span class="fu">=</span> (x,i) <span class="fu">:</span> merge xs ((y,j<span class="fu">-</span>i)<span class="fu">:</span>ys)</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">  <span class="fu">|</span> otherwise <span class="fu">=</span> (y,j) <span class="fu">:</span> merge ((x,i<span class="fu">-</span>j<span class="fu">-</span><span class="dv">1</span>)<span class="fu">:</span>xs) ys</a></code></pre></div>
<p>With that, and the same <code>cons</code> as above, we get a very simple random shuffle algorithm:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1">shuffle xs <span class="fu">=</span> map fst</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">           <span class="fu">.</span> foldr (merge <span class="fu">.</span> snd) []</a>
<a class="sourceLine" id="cb16-3" data-line-number="3">           <span class="fu">.</span> foldr f (const []) xs</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-5" data-line-number="5">    f x xs (i<span class="fu">:</span>is) <span class="fu">=</span> cons merge [(x,i)] (xs is)</a></code></pre></div>
<p>The other interesting thing about this algorithm is that it can use Peano numbers with taking too much of a performance hit:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1">merge <span class="fu">:</span> <span class="ot">‚àÄ</span> {a} {<span class="dt">A</span> <span class="fu">:</span> <span class="dt">Set</span> a} <span class="ot">‚Üí</span> <span class="dt">List</span> (<span class="dt">A</span> √ó ‚Ñï) <span class="ot">‚Üí</span> <span class="dt">List</span> (<span class="dt">A</span> √ó ‚Ñï) <span class="ot">‚Üí</span> <span class="dt">List</span> (<span class="dt">A</span> √ó ‚Ñï)</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">merge xs [] <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb17-3" data-line-number="3">merge {<span class="dt">A</span> <span class="fu">=</span> <span class="dt">A</span>} xs ((y , j) <span class="ot">‚à∑</span> ys) <span class="fu">=</span> go<span class="fu">-</span>r xs y j ys</a>
<a class="sourceLine" id="cb17-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb17-5" data-line-number="5">  go<span class="fu">-</span>l <span class="fu">:</span> <span class="dt">A</span> <span class="ot">‚Üí</span> ‚Ñï <span class="ot">‚Üí</span> <span class="dt">List</span> (<span class="dt">A</span> √ó ‚Ñï) <span class="ot">‚Üí</span> <span class="dt">List</span> (<span class="dt">A</span> √ó ‚Ñï) <span class="ot">‚Üí</span> <span class="dt">List</span> (<span class="dt">A</span> √ó ‚Ñï)</a>
<a class="sourceLine" id="cb17-6" data-line-number="6">  go<span class="fu">-</span>r <span class="fu">:</span> <span class="dt">List</span> (<span class="dt">A</span> √ó ‚Ñï) <span class="ot">‚Üí</span> <span class="dt">A</span> <span class="ot">‚Üí</span> ‚Ñï <span class="ot">‚Üí</span> <span class="dt">List</span> (<span class="dt">A</span> √ó ‚Ñï) <span class="ot">‚Üí</span> <span class="dt">List</span> (<span class="dt">A</span> √ó ‚Ñï)</a>
<a class="sourceLine" id="cb17-7" data-line-number="7">  go <span class="fu">:</span> ‚Ñï <span class="ot">‚Üí</span> ‚Ñï <span class="ot">‚Üí</span> <span class="dt">A</span> <span class="ot">‚Üí</span> ‚Ñï <span class="ot">‚Üí</span> <span class="dt">List</span> (<span class="dt">A</span> √ó ‚Ñï) <span class="ot">‚Üí</span> <span class="dt">A</span> <span class="ot">‚Üí</span> ‚Ñï <span class="ot">‚Üí</span> <span class="dt">List</span> (<span class="dt">A</span> √ó ‚Ñï) <span class="ot">‚Üí</span> <span class="dt">List</span> (<span class="dt">A</span> √ó ‚Ñï)</a>
<a class="sourceLine" id="cb17-8" data-line-number="8"></a>
<a class="sourceLine" id="cb17-9" data-line-number="9">  go i     zero   x i‚Ä≤ xs y j‚Ä≤ ys <span class="fu">=</span> (y , j‚Ä≤) <span class="ot">‚à∑</span> go<span class="fu">-</span>l x i xs ys</a>
<a class="sourceLine" id="cb17-10" data-line-number="10">  go zero (suc j) x i‚Ä≤ xs y j‚Ä≤ ys <span class="fu">=</span> (x , i‚Ä≤) <span class="ot">‚à∑</span> go<span class="fu">-</span>r xs y j ys</a>
<a class="sourceLine" id="cb17-11" data-line-number="11">  go (suc i) (suc j) <span class="fu">=</span> go i j</a>
<a class="sourceLine" id="cb17-12" data-line-number="12"></a>
<a class="sourceLine" id="cb17-13" data-line-number="13">  go<span class="fu">-</span>l x i xs [] <span class="fu">=</span> (x , i) <span class="ot">‚à∑</span> xs</a>
<a class="sourceLine" id="cb17-14" data-line-number="14">  go<span class="fu">-</span>l x i xs ((y , j) <span class="ot">‚à∑</span> ys) <span class="fu">=</span> go i j x i xs y j ys</a>
<a class="sourceLine" id="cb17-15" data-line-number="15"></a>
<a class="sourceLine" id="cb17-16" data-line-number="16">  go<span class="fu">-</span>r [] y j ys <span class="fu">=</span> (y , j) <span class="ot">‚à∑</span> ys</a>
<a class="sourceLine" id="cb17-17" data-line-number="17">  go<span class="fu">-</span>r ((x , i) <span class="ot">‚à∑</span> xs) y j ys <span class="fu">=</span> go i j x i xs y j ys</a>
<a class="sourceLine" id="cb17-18" data-line-number="18"></a>
<a class="sourceLine" id="cb17-19" data-line-number="19">shuffle <span class="fu">:</span> <span class="ot">‚àÄ</span> {a} {<span class="dt">A</span> <span class="fu">:</span> <span class="dt">Set</span> a} <span class="ot">‚Üí</span> <span class="dt">List</span> <span class="dt">A</span> <span class="ot">‚Üí</span> <span class="dt">List</span> ‚Ñï <span class="ot">‚Üí</span> <span class="dt">List</span> <span class="dt">A</span></a>
<a class="sourceLine" id="cb17-20" data-line-number="20">shuffle {a} {<span class="dt">A</span>} xs i <span class="fu">=</span> map proj‚ÇÅ (‚¶Ö [] , zip<span class="fu">-</span>inds xs i ‚¶Ü)</a>
<a class="sourceLine" id="cb17-21" data-line-number="21">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb17-22" data-line-number="22">  open <span class="dt">TreeFold</span> {a} {<span class="dt">List</span> (<span class="dt">A</span> √ó ‚Ñï)} merge</a>
<a class="sourceLine" id="cb17-23" data-line-number="23"></a>
<a class="sourceLine" id="cb17-24" data-line-number="24">  zip<span class="fu">-</span>inds <span class="fu">:</span> <span class="dt">List</span> <span class="dt">A</span> <span class="ot">‚Üí</span> <span class="dt">List</span> ‚Ñï <span class="ot">‚Üí</span> <span class="dt">List</span> (<span class="dt">List</span> (<span class="dt">A</span> √ó ‚Ñï))</a>
<a class="sourceLine" id="cb17-25" data-line-number="25">  zip<span class="fu">-</span>inds [] inds <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb17-26" data-line-number="26">  zip<span class="fu">-</span>inds (x <span class="ot">‚à∑</span> xs) [] <span class="fu">=</span> ((x , <span class="dv">0</span>) <span class="ot">‚à∑</span> []) <span class="ot">‚à∑</span> zip<span class="fu">-</span>inds xs []</a>
<a class="sourceLine" id="cb17-27" data-line-number="27">  zip<span class="fu">-</span>inds (x <span class="ot">‚à∑</span> xs) (i <span class="ot">‚à∑</span> inds) <span class="fu">=</span> ((x , i) <span class="ot">‚à∑</span> []) <span class="ot">‚à∑</span> zip<span class="fu">-</span>inds xs inds</a></code></pre></div>
<p>I don‚Äôt know exactly what the complexity of this is, but I <em>think</em> it should be better than the usual approach of popping from a vector.</p>
<h1 id="future-stuff">Future Stuff</h1>
<p>This is just a collection of random thoughts for now, but I intend to work on using these folds to see if there are any other algorithms they can be useful for. In particular, I think I can write a version of Data.List.permutations which benefits from sharing. And I‚Äôm interested in using the implicit binomial heap for some search problems.</p>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
