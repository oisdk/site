<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Balancing Scans - Donnacha Oisín Kidney</title>
        <style>body{color:black;font-family:Garamond,Times New Roman,serif;font-size:14px;margin:0px auto 0px auto;padding-left:5px;padding-right:5px;max-width:600px}math{font-size:13px}img{max-width:600px}div#header{border-bottom:3px double black;margin-bottom:30px;padding:12px 0px 12px 0px}div#logo a{color:black;float:left;font-size:20px;text-decoration:none}div#header #navigation{text-align:right}div#header #navigation a{color:black;font-family:Garamond,Times New Roman,Serif;font-size:18px;margin-left:10px;text-decoration:none;text-transform:uppercase}div#footer{font-family:Garamond,Times New Roman,Serif;border-top:solid 2px black;color:#555;font-size:12px;margin-top:30px;padding:12px 0px 12px 0px;text-align:right}h1{font-family:Garamond,Times New Roman,Serif;font-size:22px;font-weight:normal}h2{font-family:Garamond,Times New Roman,Serif;font-size:20px;font-weight:normal}div.info{color:#555;font-size:15px;font-style:italic}span.quiet{color:#828282;font-style:italic}a{color:black;word-wrap:break-word}ul{margin-left:0px;padding-left:0px;list-style-type:none}.hidden_source{display:none}ol.serieslist{counter-reset:item;list-style-type:none;padding-left:20}ol li.serieslist:before{content:'Part ' counter(item,decimal) ':';counter-increment:item}table.sourceCode,tr.sourceCode,td.lineNumbers,td.sourceCode,table.sourceCode pre{margin:0;padding:0;border:0;vertical-align:baseline;border:none}td.lineNumbers{border-right:1px solid #AAAAAA;text-align:right;color:#AAAAAA;padding-right:5px;padding-left:5px}td.sourceCode{padding-left:5px}.sourceCode,code{font-size:10px;font-family:menlo,monospace}.sourceCode span.kw{color:#262C6A}.sourceCode span.dt{color:#476A97}.sourceCode span.dv{color:#262C6A}.sourceCode span.bn{color:#262C6A}.sourceCode span.fl{color:#262C6A}.sourceCode span.ch{color:#262C6A}.sourceCode span.st{color:#702C51}.sourceCode span.co{color:#435138}.sourceCode span.ot{color:#262C6A}.sourceCode span.al{color:red}.sourceCode span.fu{color:#000000}.sourceCode span.re{color:#000000}.sourceCode span.er{color:red}</style>
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Donnacha Oisín Kidney</a>
            </div>
            <div id="navigation">
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../rss.xml">Feed</a>
                <a href="../snippets.html">Snippets</a>
            </div>
        </div>

        <div id="content">
            <h2>Balancing Scans</h2>

            <div class="info">
    Posted on December 21, 2018
</div>
<div class="info">
    
        Part 2 of a <a href="../series/Balanced%20Folds.html">3-part series on Balanced Folds</a>
    
</div>
<div class="info">
    
        Tags: <a href="../tags/Haskell.html">Haskell</a>, <a href="../tags/Agda.html">Agda</a>
    
</div>

<p><a href="2017-10-30-balancing-folds.html">Previously</a> I tried to figure out a way to fold lists in a more balanced way. Usually, when folding lists, you’ve got two choices for your folds, both of which are extremely unbalanced in one direction or another. Jon Fairbairn <a href="https://www.mail-archive.com/haskell@haskell.org/msg01788.html">wrote</a> a more balanced version, which looked something like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">treeFold ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">treeFold f <span class="fu">=</span> go</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">    go x [] <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">    go a (b<span class="fu">:</span>l) <span class="fu">=</span> go (f a b) (pairMap l)</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">    pairMap (x<span class="fu">:</span>y<span class="fu">:</span>rest) <span class="fu">=</span> f x y <span class="fu">:</span> pairMap rest</a>
<a class="sourceLine" id="cb1-7" data-line-number="7">    pairMap xs <span class="fu">=</span> xs</a></code></pre></div>
<h1 id="magical-speedups">Magical Speedups</h1>
<p>The fold above is kind of magical: for a huge class of algorithms, it kind of “automatically” improves some factor of theirs from <span class="math inline">\(\mathcal{O}(n)\)</span> to <span class="math inline">\(\mathcal{O}(\log n)\)</span>. For instance: to sum a list of floats, <code class="sourceCode haskell">foldl' (<span class="fu">+</span>) <span class="dv">0</span></code> will have an error growth of <span class="math inline">\(\mathcal{O}(n)\)</span>; <code>treeFold (+) 0</code>, though, has an error rate of <span class="math inline">\(\mathcal{O}(\log n)\)</span>. Similarly, using the following function to merge two sorted lists:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">merge ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">merge [] ys <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">merge (x<span class="fu">:</span>xs) ys <span class="fu">=</span> go x xs ys</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5">    go x xs [] <span class="fu">=</span> x <span class="fu">:</span> xs</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">    go x xs (y<span class="fu">:</span>ys)</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">      <span class="fu">|</span> x <span class="fu">&lt;=</span> y    <span class="fu">=</span> x <span class="fu">:</span> go y ys xs</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">      <span class="fu">|</span> otherwise <span class="fu">=</span> y <span class="fu">:</span> go x xs ys</a></code></pre></div>
<p>We get either insertion sort (<span class="math inline">\(\mathcal{O}(n^2)\)</span>) or merge sort (<span class="math inline">\(\mathcal{O}(n \log n)\)</span>) just depending on which fold you use.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1">foldr    merge [] <span class="fu">.</span> map pure <span class="co">-- n^2</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">treeFold merge [] <span class="fu">.</span> map pure <span class="co">-- n log(n)</span></a></code></pre></div>
<p>I’ll give some more examples later, but effectively it gives us a better “divide” step in many divide and conquer algorithms.</p>
<h1 id="termination">Termination</h1>
<p>As it was such a useful fold, and so integral to many tricky algorithms, I really wanted to have it available in Agda. Unfortunately, though, the functions (as defined above) aren’t structurally terminating, and there doesn’t <em>look</em> like there’s an obvious way to make it so. I tried to make well founded recursion work, but the proofs were ugly and slow.</p>
<p>However, we can use some structures from a <a href="2018-11-20-fast-verified-structures.html">previous post</a>: the nested binary sequence, for instance. It has some extra nice properties: instead of nesting the types, we can just apply the combining function.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">mutual</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  <span class="kw">data</span> Tree <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">    2^<span class="ot">_</span>×<span class="ot">_</span>+<span class="ot">_</span> <span class="ot">:</span> ℕ <span class="ot">→</span> A <span class="ot">→</span> Node A <span class="ot">→</span> Tree A</a>
<a class="sourceLine" id="cb4-4" data-line-number="4"></a>
<a class="sourceLine" id="cb4-5" data-line-number="5">  <span class="kw">data</span> Node <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">    ⟨⟩  <span class="ot">:</span> Node A</a>
<a class="sourceLine" id="cb4-7" data-line-number="7">    ⟨<span class="ot">_</span>⟩ <span class="ot">:</span> Tree A <span class="ot">→</span> Node A</a>
<a class="sourceLine" id="cb4-8" data-line-number="8"></a>
<a class="sourceLine" id="cb4-9" data-line-number="9"><span class="kw">module</span> TreeFold <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">(_</span>*<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">→</span> A <span class="ot">→</span> A<span class="ot">)</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-10" data-line-number="10">  <span class="kw">infixr</span> <span class="dv">5</span> <span class="ot">_</span>⊛<span class="ot">_</span> 2^<span class="ot">_</span>×<span class="ot">_</span>⊛<span class="ot">_</span></a>
<a class="sourceLine" id="cb4-11" data-line-number="11"></a>
<a class="sourceLine" id="cb4-12" data-line-number="12">  2^<span class="ot">_</span>×<span class="ot">_</span>⊛<span class="ot">_</span> <span class="ot">:</span> ℕ <span class="ot">→</span> A <span class="ot">→</span> Tree A <span class="ot">→</span> Tree A</a>
<a class="sourceLine" id="cb4-13" data-line-number="13">  2^ n × x ⊛ 2^ suc m × y + ys <span class="ot">=</span> 2^ n × x + ⟨ 2^ m × y + ys ⟩</a>
<a class="sourceLine" id="cb4-14" data-line-number="14">  2^ n × x ⊛ 2^ zero  × y + ⟨⟩ <span class="ot">=</span> 2^ suc n × <span class="ot">(</span>x * y<span class="ot">)</span> + ⟨⟩</a>
<a class="sourceLine" id="cb4-15" data-line-number="15">  2^ n × x ⊛ 2^ zero  × y + ⟨ ys ⟩ <span class="ot">=</span> 2^ suc n × <span class="ot">(</span>x * y<span class="ot">)</span> ⊛ ys</a>
<a class="sourceLine" id="cb4-16" data-line-number="16"></a>
<a class="sourceLine" id="cb4-17" data-line-number="17">  <span class="ot">_</span>⊛<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">→</span> Tree A <span class="ot">→</span> Tree A</a>
<a class="sourceLine" id="cb4-18" data-line-number="18">  <span class="ot">_</span>⊛<span class="ot">_</span> <span class="ot">=</span> 2^ <span class="dv">0</span> ×<span class="ot">_</span>⊛<span class="ot">_</span></a>
<a class="sourceLine" id="cb4-19" data-line-number="19"></a>
<a class="sourceLine" id="cb4-20" data-line-number="20">  ⟦<span class="ot">_</span>⟧↓ <span class="ot">:</span> Tree A <span class="ot">→</span> A</a>
<a class="sourceLine" id="cb4-21" data-line-number="21">  ⟦ 2^ <span class="ot">_</span> × x + ⟨⟩ ⟧↓ <span class="ot">=</span> x</a>
<a class="sourceLine" id="cb4-22" data-line-number="22">  ⟦ 2^ <span class="ot">_</span> × x + ⟨ xs ⟩ ⟧↓ <span class="ot">=</span> x * ⟦ xs ⟧↓</a>
<a class="sourceLine" id="cb4-23" data-line-number="23"></a>
<a class="sourceLine" id="cb4-24" data-line-number="24">  ⟦<span class="ot">_</span>⟧↑ <span class="ot">:</span> A <span class="ot">→</span> Tree A</a>
<a class="sourceLine" id="cb4-25" data-line-number="25">  ⟦ x ⟧↑ <span class="ot">=</span> 2^ <span class="dv">0</span> × x + ⟨⟩</a>
<a class="sourceLine" id="cb4-26" data-line-number="26"></a>
<a class="sourceLine" id="cb4-27" data-line-number="27">  ⦅<span class="ot">_</span>,<span class="ot">_</span>⦆ <span class="ot">:</span> A <span class="ot">→</span> List A <span class="ot">→</span> A</a>
<a class="sourceLine" id="cb4-28" data-line-number="28">  ⦅ x , xs ⦆ <span class="ot">=</span> ⟦ foldr <span class="ot">_</span>⊛<span class="ot">_</span> ⟦ x ⟧↑ xs ⟧↓</a></code></pre></div>
<p>Alternatively, we can get <span class="math inline">\(\mathcal{O}(1)\)</span> cons with the skew array:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">5</span> <span class="ot">_</span>⊛<span class="ot">_</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="ot">_</span>⊛<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">→</span> Tree A <span class="ot">→</span> Tree A</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">x ⊛ 2^ n × y  + ⟨⟩ <span class="ot">=</span> 2^ <span class="dv">0</span> × x + ⟨ 2^ n × y + ⟨⟩ ⟩</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">x ⊛ 2^ n × y₁ + ⟨ 2^ <span class="dv">0</span>     × y₂ + ys ⟩ <span class="ot">=</span> 2^ suc n × <span class="ot">(</span>x * <span class="ot">(</span>y₁ * y₂<span class="ot">))</span> + ys</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">x ⊛ 2^ n × y₁ + ⟨ 2^ suc m × y₂ + ys ⟩ <span class="ot">=</span> 2^ <span class="dv">0</span> × x + ⟨ 2^ n × y₁ + ⟨ 2^ m × y₂ + ys ⟩ ⟩</a></code></pre></div>
<p>Using this, a proper and efficient merge sort is very straightforward:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">data</span> Total <span class="ot">{</span>a r<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">(_</span>≤<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">→</span> A <span class="ot">→</span> <span class="dt">Set</span> r<span class="ot">)</span> <span class="ot">(</span>x y <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">(</span>a ⊔ r<span class="ot">)</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  x≤y <span class="ot">:</span> ⦃ <span class="ot">_</span> <span class="ot">:</span> x ≤ y ⦄ <span class="ot">→</span> Total <span class="ot">_</span>≤<span class="ot">_</span> x y</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  y≤x <span class="ot">:</span> ⦃ <span class="ot">_</span> <span class="ot">:</span> y ≤ x ⦄ <span class="ot">→</span> Total <span class="ot">_</span>≤<span class="ot">_</span> x y</a>
<a class="sourceLine" id="cb6-4" data-line-number="4"></a>
<a class="sourceLine" id="cb6-5" data-line-number="5"><span class="kw">module</span> Sorting <span class="ot">{</span>a r<span class="ot">}</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">               <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span></a>
<a class="sourceLine" id="cb6-7" data-line-number="7">               <span class="ot">{_</span>≤<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">→</span> A <span class="ot">→</span> <span class="dt">Set</span> r<span class="ot">}</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">               <span class="ot">(_</span>≤?<span class="ot">_</span> <span class="ot">:</span> <span class="ot">∀</span> x y <span class="ot">→</span> Total <span class="ot">_</span>≤<span class="ot">_</span> x y<span class="ot">)</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-9" data-line-number="9">  <span class="kw">data</span> [∙] <span class="ot">:</span> <span class="dt">Set</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-10" data-line-number="10">    ⊥   <span class="ot">:</span> [∙]</a>
<a class="sourceLine" id="cb6-11" data-line-number="11">    [<span class="ot">_</span>] <span class="ot">:</span> A <span class="ot">→</span> [∙]</a>
<a class="sourceLine" id="cb6-12" data-line-number="12"></a>
<a class="sourceLine" id="cb6-13" data-line-number="13">  <span class="kw">data</span> <span class="ot">_</span>≥<span class="ot">_</span> <span class="ot">(</span>x <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">:</span> [∙] <span class="ot">→</span> <span class="dt">Set</span> <span class="ot">(</span>a ⊔ r<span class="ot">)</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-14" data-line-number="14">    instance ⌈<span class="ot">_</span>⌉ <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>y<span class="ot">}</span> <span class="ot">→</span> y ≤ x <span class="ot">→</span> x ≥ [ y ]</a>
<a class="sourceLine" id="cb6-15" data-line-number="15">    instance ⌊⊥⌋ <span class="ot">:</span> x ≥ ⊥</a>
<a class="sourceLine" id="cb6-16" data-line-number="16"></a>
<a class="sourceLine" id="cb6-17" data-line-number="17">  <span class="kw">infixr</span> <span class="dv">5</span> <span class="ot">_</span>∷<span class="ot">_</span></a>
<a class="sourceLine" id="cb6-18" data-line-number="18">  <span class="kw">data</span> Ordered <span class="ot">(</span>b <span class="ot">:</span> [∙]<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">(</span>a ⊔ r<span class="ot">)</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-19" data-line-number="19">    []  <span class="ot">:</span> Ordered b</a>
<a class="sourceLine" id="cb6-20" data-line-number="20">    <span class="ot">_</span>∷<span class="ot">_</span> <span class="ot">:</span> <span class="ot">∀</span> x <span class="ot">→</span> ⦃ x≥b <span class="ot">:</span> x ≥ b ⦄ <span class="ot">→</span> <span class="ot">(</span>xs <span class="ot">:</span> Ordered [ x ]<span class="ot">)</span> <span class="ot">→</span> Ordered b</a>
<a class="sourceLine" id="cb6-21" data-line-number="21"></a>
<a class="sourceLine" id="cb6-22" data-line-number="22">  <span class="ot">_</span>∪<span class="ot">_</span> <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>b<span class="ot">}</span> <span class="ot">→</span> Ordered b <span class="ot">→</span> Ordered b <span class="ot">→</span> Ordered b</a>
<a class="sourceLine" id="cb6-23" data-line-number="23">  [] ∪ ys <span class="ot">=</span> ys</a>
<a class="sourceLine" id="cb6-24" data-line-number="24">  <span class="ot">(</span>x ∷ xs<span class="ot">)</span> ∪ ys <span class="ot">=</span> ⟅ x ∹ xs ∪ ys ⟆</a>
<a class="sourceLine" id="cb6-25" data-line-number="25">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-26" data-line-number="26">    ⟅<span class="ot">_</span>∹<span class="ot">_</span>∪<span class="ot">_</span>⟆ <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>b<span class="ot">}</span> <span class="ot">→</span> <span class="ot">∀</span> x ⦃ <span class="ot">_</span> <span class="ot">:</span> x ≥ b ⦄ <span class="ot">→</span> Ordered [ x ] <span class="ot">→</span> Ordered b <span class="ot">→</span> Ordered b</a>
<a class="sourceLine" id="cb6-27" data-line-number="27">    ⟅<span class="ot">_</span>∪<span class="ot">_</span>∹<span class="ot">_</span>⟆ <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>b<span class="ot">}</span> <span class="ot">→</span> Ordered b <span class="ot">→</span> <span class="ot">∀</span> y ⦃ <span class="ot">_</span> <span class="ot">:</span> y ≥ b ⦄ <span class="ot">→</span> Ordered [ y ] <span class="ot">→</span> Ordered b</a>
<a class="sourceLine" id="cb6-28" data-line-number="28">    merge <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>b<span class="ot">}</span> x y ⦃ <span class="ot">_</span> <span class="ot">:</span> x ≥ b ⦄ ⦃ <span class="ot">_</span> <span class="ot">:</span> y ≥ b ⦄</a>
<a class="sourceLine" id="cb6-29" data-line-number="29">          <span class="ot">→</span> Total <span class="ot">_</span>≤<span class="ot">_</span> x y</a>
<a class="sourceLine" id="cb6-30" data-line-number="30">          <span class="ot">→</span> Ordered [ x ]</a>
<a class="sourceLine" id="cb6-31" data-line-number="31">          <span class="ot">→</span> Ordered [ y ]</a>
<a class="sourceLine" id="cb6-32" data-line-number="32">          <span class="ot">→</span> Ordered b</a>
<a class="sourceLine" id="cb6-33" data-line-number="33"></a>
<a class="sourceLine" id="cb6-34" data-line-number="34">    ⟅ x ∹ xs ∪ [] ⟆ <span class="ot">=</span> x ∷ xs</a>
<a class="sourceLine" id="cb6-35" data-line-number="35">    ⟅ x ∹ xs ∪ y ∷ ys ⟆ <span class="ot">=</span> merge x y <span class="ot">(</span>x ≤? y<span class="ot">)</span> xs ys</a>
<a class="sourceLine" id="cb6-36" data-line-number="36">    ⟅ [] ∪ y ∹ ys ⟆ <span class="ot">=</span> y ∷ ys</a>
<a class="sourceLine" id="cb6-37" data-line-number="37">    ⟅ x ∷ xs ∪ y ∹ ys ⟆ <span class="ot">=</span> merge x y <span class="ot">(</span>x ≤? y<span class="ot">)</span> xs ys</a>
<a class="sourceLine" id="cb6-38" data-line-number="38"></a>
<a class="sourceLine" id="cb6-39" data-line-number="39">    merge x y x≤y xs ys <span class="ot">=</span> x ∷ ⟅ xs ∪ y ∹ ys ⟆</a>
<a class="sourceLine" id="cb6-40" data-line-number="40">    merge x y y≤x xs ys <span class="ot">=</span> y ∷ ⟅ x ∹ xs ∪ ys ⟆</a>
<a class="sourceLine" id="cb6-41" data-line-number="41"></a>
<a class="sourceLine" id="cb6-42" data-line-number="42"></a>
<a class="sourceLine" id="cb6-43" data-line-number="43">  <span class="kw">open</span> TreeFold</a>
<a class="sourceLine" id="cb6-44" data-line-number="44"></a>
<a class="sourceLine" id="cb6-45" data-line-number="45">  sort <span class="ot">:</span> List A <span class="ot">→</span> Ordered ⊥</a>
<a class="sourceLine" id="cb6-46" data-line-number="46">  sort <span class="ot">=</span> ⦅ <span class="ot">_</span>∪<span class="ot">_</span> , [] ⦆ ∘ map <span class="ot">(_</span>∷ []<span class="ot">)</span></a></code></pre></div>
<h1 id="validity">Validity</h1>
<p>It would be nice if we could verify these optimizated versions of folds. Luckily, by writing them using <code>foldr</code>, we’ve stumbled into well-trodden ground: the <em>foldr fusion law</em>. It states that if you have some transformation <span class="math inline">\(f\)</span>, and two binary operators <span class="math inline">\(\oplus\)</span> and <span class="math inline">\(\otimes\)</span>, then:</p>

<p>This fits right in with the function we used above. <span class="math inline">\(f\)</span> is <code>⟦_⟧↓</code>, <span class="math inline">\(\oplus\)</span> is <code>_⊛_</code>, and <span class="math inline">\(\otimes\)</span> is whatever combining function was passed in. Let’s prove the foldr fusion law, then, before we go any further.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">module</span> Proofs</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  <span class="ot">{</span>a r<span class="ot">}</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">  <span class="ot">{</span>R <span class="ot">:</span> Rel A r<span class="ot">}</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6"></a>
<a class="sourceLine" id="cb7-7" data-line-number="7">  <span class="kw">infix</span> <span class="dv">4</span> <span class="ot">_</span>≈<span class="ot">_</span></a>
<a class="sourceLine" id="cb7-8" data-line-number="8">  <span class="ot">_</span>≈<span class="ot">_</span> <span class="ot">=</span> R</a>
<a class="sourceLine" id="cb7-9" data-line-number="9"></a>
<a class="sourceLine" id="cb7-10" data-line-number="10">  <span class="kw">open</span> <span class="kw">import</span> Algebra<span class="ot">.</span>FunctionProperties <span class="ot">_</span>≈<span class="ot">_</span></a>
<a class="sourceLine" id="cb7-11" data-line-number="11"></a>
<a class="sourceLine" id="cb7-12" data-line-number="12">  foldr-universal <span class="ot">:</span> Transitive <span class="ot">_</span>≈<span class="ot">_</span></a>
<a class="sourceLine" id="cb7-13" data-line-number="13">                  <span class="ot">→</span> <span class="ot">∀</span> <span class="ot">{</span>b<span class="ot">}</span> <span class="ot">{</span>B <span class="ot">:</span> <span class="dt">Set</span> b<span class="ot">}</span> <span class="ot">(</span>h <span class="ot">:</span> List B <span class="ot">→</span> A<span class="ot">)</span> f e</a>
<a class="sourceLine" id="cb7-14" data-line-number="14">                  <span class="ot">→</span> ∀[ f ⊢ Congruent₁ ]</a>
<a class="sourceLine" id="cb7-15" data-line-number="15">                  <span class="ot">→</span> <span class="ot">(</span>h [] ≈ e<span class="ot">)</span></a>
<a class="sourceLine" id="cb7-16" data-line-number="16">                  <span class="ot">→</span> <span class="ot">(∀</span> x xs <span class="ot">→</span> h <span class="ot">(</span>x ∷ xs<span class="ot">)</span> ≈ f x <span class="ot">(</span>h xs<span class="ot">))</span></a>
<a class="sourceLine" id="cb7-17" data-line-number="17">                  <span class="ot">→</span> <span class="ot">∀</span> xs <span class="ot">→</span> h xs ≈ foldr f e xs</a>
<a class="sourceLine" id="cb7-18" data-line-number="18">  foldr-universal <span class="ot">_</span>○<span class="ot">_</span> h f e f⟨<span class="ot">_</span>⟩ ⇒[] ⇒<span class="ot">_</span>∷<span class="ot">_</span> [] <span class="ot">=</span> ⇒[]</a>
<a class="sourceLine" id="cb7-19" data-line-number="19">  foldr-universal <span class="ot">_</span>○<span class="ot">_</span> h f e f⟨<span class="ot">_</span>⟩ ⇒[] ⇒<span class="ot">_</span>∷<span class="ot">_</span> <span class="ot">(</span>x ∷ xs<span class="ot">)</span> <span class="ot">=</span></a>
<a class="sourceLine" id="cb7-20" data-line-number="20">    <span class="ot">(</span>⇒ x ∷ xs<span class="ot">)</span> ○ f⟨ foldr-universal <span class="ot">_</span>○<span class="ot">_</span> h f e f⟨<span class="ot">_</span>⟩ ⇒[] ⇒<span class="ot">_</span>∷<span class="ot">_</span> xs ⟩</a>
<a class="sourceLine" id="cb7-21" data-line-number="21"></a>
<a class="sourceLine" id="cb7-22" data-line-number="22">  foldr-fusion <span class="ot">:</span> Transitive <span class="ot">_</span>≈<span class="ot">_</span></a>
<a class="sourceLine" id="cb7-23" data-line-number="23">               <span class="ot">→</span> Reflexive <span class="ot">_</span>≈<span class="ot">_</span></a>
<a class="sourceLine" id="cb7-24" data-line-number="24">               <span class="ot">→</span> <span class="ot">∀</span> <span class="ot">{</span>b c<span class="ot">}</span> <span class="ot">{</span>B <span class="ot">:</span> <span class="dt">Set</span> b<span class="ot">}</span> <span class="ot">{</span>C <span class="ot">:</span> <span class="dt">Set</span> c<span class="ot">}</span> <span class="ot">(</span>f <span class="ot">:</span> C <span class="ot">→</span> A<span class="ot">)</span> <span class="ot">{_</span>⊕<span class="ot">_</span> <span class="ot">:</span> B <span class="ot">→</span> C <span class="ot">→</span> C<span class="ot">}</span> <span class="ot">{_</span>⊗<span class="ot">_</span> <span class="ot">:</span> B <span class="ot">→</span> A <span class="ot">→</span> A<span class="ot">}</span> e</a>
<a class="sourceLine" id="cb7-25" data-line-number="25">               <span class="ot">→</span> ∀[ <span class="ot">_</span>⊗<span class="ot">_</span> ⊢ Congruent₁ ]</a>
<a class="sourceLine" id="cb7-26" data-line-number="26">               <span class="ot">→</span> <span class="ot">(∀</span> x y <span class="ot">→</span> f <span class="ot">(</span>x ⊕ y<span class="ot">)</span> ≈ x ⊗ f y<span class="ot">)</span></a>
<a class="sourceLine" id="cb7-27" data-line-number="27">               <span class="ot">→</span> <span class="ot">∀</span> xs <span class="ot">→</span> f <span class="ot">(</span>foldr <span class="ot">_</span>⊕<span class="ot">_</span> e xs<span class="ot">)</span> ≈ foldr <span class="ot">_</span>⊗<span class="ot">_</span> <span class="ot">(</span>f e<span class="ot">)</span> xs</a>
<a class="sourceLine" id="cb7-28" data-line-number="28">  foldr-fusion <span class="ot">_</span>○<span class="ot">_</span> ∎ h <span class="ot">{</span>f<span class="ot">}</span> <span class="ot">{</span>g<span class="ot">}</span> e g⟨<span class="ot">_</span>⟩ fuse <span class="ot">=</span></a>
<a class="sourceLine" id="cb7-29" data-line-number="29">    foldr-universal <span class="ot">_</span>○<span class="ot">_</span> <span class="ot">(</span>h ∘ foldr f e<span class="ot">)</span> g <span class="ot">(</span>h e<span class="ot">)</span> g⟨<span class="ot">_</span>⟩ ∎ <span class="ot">(λ</span> x xs <span class="ot">→</span> fuse x <span class="ot">(</span>foldr f e xs<span class="ot">))</span></a></code></pre></div>
<p>We’re not using the proofs in Agda’s standard library because these are tied to propositional equality. In other words, instead of using an abstract binary relation, they prove things over <em>actual</em> equality. That’s all well and good, but as you can see above, we don’t need propositional equality: we don’t even need the relation to be an equivalence, we just need transitivity and reflexivity.</p>
<p>After that, we can state precisely what correspondence the tree fold has, and under what conditions it does the same things as a fold:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">module</span> <span class="ot">_</span> <span class="ot">{_</span>*<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">→</span> A <span class="ot">→</span> A<span class="ot">}</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  <span class="kw">open</span> TreeFold <span class="ot">_</span>*<span class="ot">_</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3"></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">  treeFoldHom <span class="ot">:</span> Transitive <span class="ot">_</span>≈<span class="ot">_</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5">              <span class="ot">→</span> Reflexive <span class="ot">_</span>≈<span class="ot">_</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">              <span class="ot">→</span> Associative <span class="ot">_</span>*<span class="ot">_</span></a>
<a class="sourceLine" id="cb8-7" data-line-number="7">              <span class="ot">→</span> RightCongruent <span class="ot">_</span>*<span class="ot">_</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8">              <span class="ot">→</span> <span class="ot">∀</span> x xs</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">              <span class="ot">→</span> ⦅ x , xs ⦆ ≈ foldr <span class="ot">_</span>*<span class="ot">_</span> x xs</a>
<a class="sourceLine" id="cb8-10" data-line-number="10">  treeFoldHom <span class="ot">_</span>○<span class="ot">_</span> ∎ assoc *⟨<span class="ot">_</span>⟩ b <span class="ot">=</span> foldr-fusion <span class="ot">_</span>○<span class="ot">_</span> ∎ ⟦<span class="ot">_</span>⟧↓ ⟦ b ⟧↑ *⟨<span class="ot">_</span>⟩ <span class="ot">(</span>⊛-hom zero<span class="ot">)</span></a>
<a class="sourceLine" id="cb8-11" data-line-number="11">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-12" data-line-number="12">    ⊛-hom <span class="ot">:</span> <span class="ot">∀</span> n x xs <span class="ot">→</span> ⟦ 2^ n × x ⊛ xs ⟧↓ ≈ x * ⟦ xs ⟧↓</a>
<a class="sourceLine" id="cb8-13" data-line-number="13">    ⊛-hom n x <span class="ot">(</span>2^ suc m × y + ⟨⟩    <span class="ot">)</span> <span class="ot">=</span> ∎</a>
<a class="sourceLine" id="cb8-14" data-line-number="14">    ⊛-hom n x <span class="ot">(</span>2^ suc m × y + ⟨ ys ⟩<span class="ot">)</span> <span class="ot">=</span> ∎</a>
<a class="sourceLine" id="cb8-15" data-line-number="15">    ⊛-hom n x <span class="ot">(</span>2^ zero  × y + ⟨⟩    <span class="ot">)</span> <span class="ot">=</span> ∎</a>
<a class="sourceLine" id="cb8-16" data-line-number="16">    ⊛-hom n x <span class="ot">(</span>2^ zero  × y + ⟨ ys ⟩<span class="ot">)</span> <span class="ot">=</span> ⊛-hom <span class="ot">(</span>suc n<span class="ot">)</span> <span class="ot">(</span>x * y<span class="ot">)</span> ys ○ assoc x y ⟦ ys ⟧↓</a></code></pre></div>
<h1 id="implicit-data-structures">“Implicit” Data Structures</h1>
<p>Consider the following implementation of the tree above in Haskell:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Tree</span> a <span class="fu">=</span> [(<span class="dt">Int</span>,a)]</a>
<a class="sourceLine" id="cb9-2" data-line-number="2"></a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="ot">cons ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">cons (<span class="fu">*</span>) <span class="fu">=</span> cons' <span class="dv">0</span> </a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6">    cons' n x [] <span class="fu">=</span> [(n,x)]</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">    cons' n x ((<span class="dv">0</span>,y)<span class="fu">:</span>ys) <span class="fu">=</span> cons' (n<span class="fu">+</span><span class="dv">1</span>) (x <span class="fu">*</span> y) ys</a>
<a class="sourceLine" id="cb9-8" data-line-number="8">    cons' n x ((m,y)<span class="fu">:</span>ys) <span class="fu">=</span> (n,x) <span class="fu">:</span> (m<span class="fu">-</span><span class="dv">1</span>,y) <span class="fu">:</span> ys</a></code></pre></div>
<p>The <code>cons</code> function “increments” that list as if it were the bits of a binary number. Now, consider using the <code>merge</code> function from above, in a pattern like this:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">f <span class="fu">=</span> foldr (cons merge <span class="fu">.</span> pure) []</a></code></pre></div>
<p>What does <code>f</code> build? A list of lists, right?</p>
<p>Kind of. That’s what’s built in terms of the observable, but what’s actually stored in memory us a bunch of thunks. The shape of <em>those</em> is what I’m interested in. We can try and see what they look like by using a data structure that doesn’t force on merge:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a <span class="fu">=</span> <span class="dt">Leaf</span> a <span class="fu">|</span> <span class="dt">Tree</span> a <span class="fu">:*:</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb11-2" data-line-number="2"></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">f <span class="fu">=</span> foldr (cons (<span class="fu">:*:</span>) <span class="fu">.</span> <span class="dt">Leaf</span>) []</a></code></pre></div>
<p>Using a handy tree-drawing function, we can see what <code>f [1..13]</code> looks like:</p>
<pre><code>[(0,*),(1,*),(0,*)]
    └1    │ ┌2  │  ┌6
          │┌┤   │ ┌┤
          ││└3  │ │└7
          └┤    │┌┤
           │┌4  │││┌8
           └┤   ││└┤
            └5  ││ └9
                └┤
                 │ ┌10
                 │┌┤
                 ││└11
                 └┤
                  │┌12
                  └┤
                   └13</code></pre>
<p>It’s a binomial heap! It’s a list of trees, each one contains <span class="math inline">\(2^n\)</span> elements. But they’re not in heap order, you say? Well, as a matter of fact, they <em>are</em>. It just hasn’t been evaluated yet. Once we force—say—the first element, the rest will shuffle themselves into a tree of thunks.</p>
<p>This illustrates a pretty interesting similarity between binomial heaps and merge sort. Performance-wise, though, there’s another interesting property: the thunks <em>stay thunked</em>. In other words, if we do a merge sort via:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1">sort <span class="fu">=</span> foldr (merge <span class="fu">.</span> snd) [] <span class="fu">.</span> foldr (cons merge <span class="fu">.</span> pure) []</a></code></pre></div>
<p>We could instead freeze the fold, and look at it at every point:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1">sortPrefixes <span class="fu">=</span> map (foldr (merge <span class="fu">.</span> snd) []) <span class="fu">.</span> scanl (flip (cons merge <span class="fu">.</span> pure)) []</a>
<a class="sourceLine" id="cb14-2" data-line-number="2"><span class="fu">&gt;&gt;&gt;</span> [[],[<span class="dv">1</span>],[<span class="dv">1</span>,<span class="dv">4</span>],[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">4</span>],[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>],[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>]]</a></code></pre></div>
<p>And <code>sortPrefixes</code> is only <span class="math inline">\(\mathcal{O}(n^2)\)</span> (rather than <span class="math inline">\(\mathcal{O}(n^2 \log n)\)</span>). I confess I don’t know of a use for sorted prefixes, but it should illustrate the general idea: we get a pretty decent batching of operations, with the ability to freeze at any point in time. The other nice property (which I mentioned in the last post) is that any of the tree folds are extremely parallel.</p>
<h1 id="random-shuffles">Random Shuffles</h1>
<p><a href="http://okmij.org/ftp/Haskell/AlgorithmsH.html#perfect-shuffle">There’s a great article on shuffling in Haskell</a> which provides an <span class="math inline">\(\mathcal{O}(n \log n)\)</span> implementation of a perfect random shuffle. Unfortunately, the <a href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle">Fisher-Yates shuffle</a> isn’t applicable in a pure functional setting, so you have to be a little cleverer.</p>
<p>The first implementation most people jump to (certainly the one I thought of) is to assign everything in the sequence a random number, and then sort according to that number. Perhaps surprisingly, this <em>isn’t</em> perfectly random! It’s a little weird, but the example in the article explains it well: basically, for <span class="math inline">\(n\)</span> elements, your random numbers will have <span class="math inline">\(n^n\)</span> possible values, but the output of the sort will have <span class="math inline">\(n!\)</span> possible values. Since they don’t divide into each other evenly, you’re going to have some extra weight on some permutations, and less on others.</p>
<p>Instead, we can generate a random <a href="https://en.wikipedia.org/wiki/Factorial_number_system"><em>factoradic</em></a> number. A factoradic number is one where the <span class="math inline">\(n\)</span>th digit is in base <span class="math inline">\(n\)</span>. Because of this, a factoradic number with <span class="math inline">\(n\)</span> digits has <span class="math inline">\(n!\)</span> possible values: exactly what we want.</p>
<p>In the article, the digits of the number are used to pop values from a binary tree. Because the last digit will have <span class="math inline">\(n\)</span> possible values, and the second last <span class="math inline">\(n-1\)</span>, and so on, you can keep popping without hitting an empty tree.</p>
<p>This has the correct time complexity—<span class="math inline">\(\mathcal{O}(n \log n)\)</span>—but there’s a lot of overhead. Building the tree, then indexing into it, the rebuilding after each pop, etc.</p>
<p>We’d <em>like</em> to just sort the list, according to the indices. The problem is that the indices are relative: if you want to <code>cons</code> something onto the list, you have to increment the rest of the indices, as they’ve all shifted right by one.</p>
<p>What we’ll do instead is use the indices as <em>gaps</em>. Our merge function looks like the following:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1">merge [] ys <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">merge xs [] <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">merge ((x,i)<span class="fu">:</span>xs) ((y,j)<span class="fu">:</span>ys)</a>
<a class="sourceLine" id="cb15-4" data-line-number="4">  <span class="fu">|</span> i <span class="fu">&lt;=</span> j    <span class="fu">=</span> (x,i) <span class="fu">:</span> merge xs ((y,j<span class="fu">-</span>i)<span class="fu">:</span>ys)</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">  <span class="fu">|</span> otherwise <span class="fu">=</span> (y,j) <span class="fu">:</span> merge ((x,i<span class="fu">-</span>j<span class="fu">-</span><span class="dv">1</span>)<span class="fu">:</span>xs) ys</a></code></pre></div>
<p>With that, and the same <code>cons</code> as above, we get a very simple random shuffle algorithm:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1">shuffle xs <span class="fu">=</span> map fst</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">           <span class="fu">.</span> foldr (merge <span class="fu">.</span> snd) []</a>
<a class="sourceLine" id="cb16-3" data-line-number="3">           <span class="fu">.</span> foldr f (const []) xs</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-5" data-line-number="5">    f x xs (i<span class="fu">:</span>is) <span class="fu">=</span> cons merge [(x,i)] (xs is)</a></code></pre></div>
<p>The other interesting thing about this algorithm is that it can use Peano numbers with taking too much of a performance hit:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1">merge <span class="fu">:</span> <span class="ot">∀</span> {a} {<span class="dt">A</span> <span class="fu">:</span> <span class="dt">Set</span> a} <span class="ot">→</span> <span class="dt">List</span> (<span class="dt">A</span> × ℕ) <span class="ot">→</span> <span class="dt">List</span> (<span class="dt">A</span> × ℕ) <span class="ot">→</span> <span class="dt">List</span> (<span class="dt">A</span> × ℕ)</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">merge xs [] <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb17-3" data-line-number="3">merge {<span class="dt">A</span> <span class="fu">=</span> <span class="dt">A</span>} xs ((y , j) <span class="ot">∷</span> ys) <span class="fu">=</span> go<span class="fu">-</span>r xs y j ys</a>
<a class="sourceLine" id="cb17-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb17-5" data-line-number="5">  go<span class="fu">-</span>l <span class="fu">:</span> <span class="dt">A</span> <span class="ot">→</span> ℕ <span class="ot">→</span> <span class="dt">List</span> (<span class="dt">A</span> × ℕ) <span class="ot">→</span> <span class="dt">List</span> (<span class="dt">A</span> × ℕ) <span class="ot">→</span> <span class="dt">List</span> (<span class="dt">A</span> × ℕ)</a>
<a class="sourceLine" id="cb17-6" data-line-number="6">  go<span class="fu">-</span>r <span class="fu">:</span> <span class="dt">List</span> (<span class="dt">A</span> × ℕ) <span class="ot">→</span> <span class="dt">A</span> <span class="ot">→</span> ℕ <span class="ot">→</span> <span class="dt">List</span> (<span class="dt">A</span> × ℕ) <span class="ot">→</span> <span class="dt">List</span> (<span class="dt">A</span> × ℕ)</a>
<a class="sourceLine" id="cb17-7" data-line-number="7">  go <span class="fu">:</span> ℕ <span class="ot">→</span> ℕ <span class="ot">→</span> <span class="dt">A</span> <span class="ot">→</span> ℕ <span class="ot">→</span> <span class="dt">List</span> (<span class="dt">A</span> × ℕ) <span class="ot">→</span> <span class="dt">A</span> <span class="ot">→</span> ℕ <span class="ot">→</span> <span class="dt">List</span> (<span class="dt">A</span> × ℕ) <span class="ot">→</span> <span class="dt">List</span> (<span class="dt">A</span> × ℕ)</a>
<a class="sourceLine" id="cb17-8" data-line-number="8"></a>
<a class="sourceLine" id="cb17-9" data-line-number="9">  go i     zero   x i′ xs y j′ ys <span class="fu">=</span> (y , j′) <span class="ot">∷</span> go<span class="fu">-</span>l x i xs ys</a>
<a class="sourceLine" id="cb17-10" data-line-number="10">  go zero (suc j) x i′ xs y j′ ys <span class="fu">=</span> (x , i′) <span class="ot">∷</span> go<span class="fu">-</span>r xs y j ys</a>
<a class="sourceLine" id="cb17-11" data-line-number="11">  go (suc i) (suc j) <span class="fu">=</span> go i j</a>
<a class="sourceLine" id="cb17-12" data-line-number="12"></a>
<a class="sourceLine" id="cb17-13" data-line-number="13">  go<span class="fu">-</span>l x i xs [] <span class="fu">=</span> (x , i) <span class="ot">∷</span> xs</a>
<a class="sourceLine" id="cb17-14" data-line-number="14">  go<span class="fu">-</span>l x i xs ((y , j) <span class="ot">∷</span> ys) <span class="fu">=</span> go i j x i xs y j ys</a>
<a class="sourceLine" id="cb17-15" data-line-number="15"></a>
<a class="sourceLine" id="cb17-16" data-line-number="16">  go<span class="fu">-</span>r [] y j ys <span class="fu">=</span> (y , j) <span class="ot">∷</span> ys</a>
<a class="sourceLine" id="cb17-17" data-line-number="17">  go<span class="fu">-</span>r ((x , i) <span class="ot">∷</span> xs) y j ys <span class="fu">=</span> go i j x i xs y j ys</a>
<a class="sourceLine" id="cb17-18" data-line-number="18"></a>
<a class="sourceLine" id="cb17-19" data-line-number="19">shuffle <span class="fu">:</span> <span class="ot">∀</span> {a} {<span class="dt">A</span> <span class="fu">:</span> <span class="dt">Set</span> a} <span class="ot">→</span> <span class="dt">List</span> <span class="dt">A</span> <span class="ot">→</span> <span class="dt">List</span> ℕ <span class="ot">→</span> <span class="dt">List</span> <span class="dt">A</span></a>
<a class="sourceLine" id="cb17-20" data-line-number="20">shuffle {a} {<span class="dt">A</span>} xs i <span class="fu">=</span> map proj₁ (⦅ [] , zip<span class="fu">-</span>inds xs i ⦆)</a>
<a class="sourceLine" id="cb17-21" data-line-number="21">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb17-22" data-line-number="22">  open <span class="dt">TreeFold</span> {a} {<span class="dt">List</span> (<span class="dt">A</span> × ℕ)} merge</a>
<a class="sourceLine" id="cb17-23" data-line-number="23"></a>
<a class="sourceLine" id="cb17-24" data-line-number="24">  zip<span class="fu">-</span>inds <span class="fu">:</span> <span class="dt">List</span> <span class="dt">A</span> <span class="ot">→</span> <span class="dt">List</span> ℕ <span class="ot">→</span> <span class="dt">List</span> (<span class="dt">List</span> (<span class="dt">A</span> × ℕ))</a>
<a class="sourceLine" id="cb17-25" data-line-number="25">  zip<span class="fu">-</span>inds [] inds <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb17-26" data-line-number="26">  zip<span class="fu">-</span>inds (x <span class="ot">∷</span> xs) [] <span class="fu">=</span> ((x , <span class="dv">0</span>) <span class="ot">∷</span> []) <span class="ot">∷</span> zip<span class="fu">-</span>inds xs []</a>
<a class="sourceLine" id="cb17-27" data-line-number="27">  zip<span class="fu">-</span>inds (x <span class="ot">∷</span> xs) (i <span class="ot">∷</span> inds) <span class="fu">=</span> ((x , i) <span class="ot">∷</span> []) <span class="ot">∷</span> zip<span class="fu">-</span>inds xs inds</a></code></pre></div>
<p>I don’t know exactly what the complexity of this is, but I <em>think</em> it should be better than the usual approach of popping from a vector.</p>
<h1 id="future-stuff">Future Stuff</h1>
<p>This is just a collection of random thoughts for now, but I intend to work on using these folds to see if there are any other algorithms they can be useful for. In particular, I think I can write a version of Data.List.permutations which benefits from sharing. And I’m interested in using the implicit binomial heap for some search problems.</p>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
