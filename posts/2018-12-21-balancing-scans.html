<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Balancing Scans - Donnacha OisÃ­n Kidney</title>
        <style>body{color:black;font-family:Garamond,Times New Roman,serif;font-size:14px;margin:0px auto 0px auto;padding-left:5px;padding-right:5px;max-width:600px}math{font-size:13px}img{max-width:600px}div#header{border-bottom:3px double black;margin-bottom:30px;padding:12px 0px 12px 0px}div#logo a{color:black;float:left;font-size:20px;text-decoration:none}div#header #navigation{text-align:right}div#header #navigation a{color:black;font-family:Garamond,Times New Roman,Serif;font-size:18px;margin-left:10px;text-decoration:none;text-transform:uppercase}div#footer{font-family:Garamond,Times New Roman,Serif;border-top:solid 2px black;color:#555;font-size:12px;margin-top:30px;padding:12px 0px 12px 0px;text-align:right}h1{font-family:Garamond,Times New Roman,Serif;font-size:22px;font-weight:normal}h2{font-family:Garamond,Times New Roman,Serif;font-size:20px;font-weight:normal}div.info{color:#555;font-size:15px;font-style:italic}span.quiet{color:#828282;font-style:italic}a{color:black;word-wrap:break-word}ul.post-list{margin-left:0px;padding-left:0px;list-style-type:none}.hidden_source{display:none}ol.serieslist{counter-reset:item;list-style-type:none;padding-left:20}ol li.serieslist:before{content:'Part ' counter(item,decimal) ':';counter-increment:item}table.sourceCode,tr.sourceCode,td.lineNumbers,td.sourceCode,table.sourceCode pre{margin:0;padding:0;border:0;vertical-align:baseline;border:none}td.lineNumbers{border-right:1px solid #AAAAAA;text-align:right;color:#AAAAAA;padding-right:5px;padding-left:5px}td.sourceCode{padding-left:5px}.sourceCode,code,.Agda{font-size:10px;font-family:menlo,monospace}.sourceCode span.kw{color:#262C6A}.sourceCode span.dt{color:#476A97}.sourceCode span.dv{color:#262C6A}.sourceCode span.bn{color:#262C6A}.sourceCode span.fl{color:#262C6A}.sourceCode span.ch{color:#262C6A}.sourceCode span.st{color:#702C51}.sourceCode span.co{color:#435138}.sourceCode span.ot{color:#262C6A}.sourceCode span.al{color:red}.sourceCode span.fu{color:#000000}.sourceCode span.re{color:#000000}.sourceCode span.er{color:red}li{margin-bottom:2px}li:last-child{margin-bottom:0px}.Agda .Comment{color:#B22222}.Agda .Background{}.Agda .Markup{color:#000000}.Agda .Keyword{color:#CD6600}.Agda .String{color:#B22222}.Agda .Number{color:#A020F0}.Agda .Symbol{color:#404040}.Agda .PrimitiveType{color:#0000CD}.Agda .Pragma{color:black}.Agda .Operator{}.Agda .Bound{color:black}.Agda .Generalizable{color:black}.Agda .InductiveConstructor{color:#008B00}.Agda .CoinductiveConstructor{color:#8B7500}.Agda .Datatype{color:#0000CD}.Agda .Field{color:#EE1289}.Agda .Function{color:#0000CD}.Agda .Module{color:#A020F0}.Agda .Postulate{color:#0000CD}.Agda .Primitive{color:#0000CD}.Agda .Record{color:#0000CD}.Agda .DottedPattern{}.Agda .UnsolvedMeta{color:black;background:yellow}.Agda .UnsolvedConstraint{color:black;background:yellow}.Agda .TerminationProblem{color:black;background:#FFA07A}.Agda .IncompletePattern{color:black;background:#F5DEB3}.Agda .Error{color:red;text-decoration:underline}.Agda .TypeChecks{color:black;background:#ADD8E6}.Agda a{text-decoration:none}.Agda a[href]:hover{background-color:#B4EEB4}.sourceCode{overflow-x:auto}</style>
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Donnacha OisÃ­n Kidney</a>
            </div>
            <div id="navigation">
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../rss.xml">Feed</a>
            </div>
        </div>

        <div id="content">
            <h2>Balancing Scans</h2>

            <div class="info">
    Posted on December 21, 2018
</div>
<div class="info">
    
        Part 2 of a <a href="../series/Balanced%20Folds.html">3-part series on Balanced Folds</a>
    
</div>
<div class="info">
    
        Tags: <a href="../tags/Haskell.html">Haskell</a>, <a href="../tags/Agda.html">Agda</a>
    
</div>

<p><a href="2017-10-30-balancing-folds.html">Previously</a> I tried to figure out a way to fold lists in a more balanced way. Usually, when folding lists, youâ€™ve got two choices for your folds, both of which are extremely unbalanced in one direction or another. Jon Fairbairn <a href="https://www.mail-archive.com/haskell@haskell.org/msg01788.html">wrote</a> a more balanced version, which looked something like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">treeFold ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">treeFold f <span class="fu">=</span> go</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">    go x [] <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">    go a (b<span class="fu">:</span>l) <span class="fu">=</span> go (f a b) (pairMap l)</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">    pairMap (x<span class="fu">:</span>y<span class="fu">:</span>rest) <span class="fu">=</span> f x y <span class="fu">:</span> pairMap rest</a>
<a class="sourceLine" id="cb1-7" data-line-number="7">    pairMap xs <span class="fu">=</span> xs</a></code></pre></div>
<h1 id="magical-speedups">Magical Speedups</h1>
<p>The fold above is kind of magical: for a huge class of algorithms, it kind of â€œautomaticallyâ€ improves some factor of theirs from <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n)</annotation></semantics></math> to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math>. For instance: to sum a list of floats, <code class="sourceCode haskell">foldl' (<span class="fu">+</span>) <span class="dv">0</span></code> will have an error growth of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n)</annotation></semantics></math>; <code>treeFold (+) 0</code>, though, has an error rate of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math>. Similarly, using the following function to merge two sorted lists:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">merge ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">merge [] ys <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">merge (x<span class="fu">:</span>xs) ys <span class="fu">=</span> go x xs ys</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5">    go x xs [] <span class="fu">=</span> x <span class="fu">:</span> xs</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">    go x xs (y<span class="fu">:</span>ys)</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">      <span class="fu">|</span> x <span class="fu">&lt;=</span> y    <span class="fu">=</span> x <span class="fu">:</span> go y ys xs</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">      <span class="fu">|</span> otherwise <span class="fu">=</span> y <span class="fu">:</span> go x xs ys</a></code></pre></div>
<p>We get either insertion sort (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n^2)</annotation></semantics></math>) or merge sort (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n \log n)</annotation></semantics></math>) just depending on which fold you use.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1">foldr    merge [] <span class="fu">.</span> map pure <span class="co">-- n^2</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">treeFold merge [] <span class="fu">.</span> map pure <span class="co">-- n log(n)</span></a></code></pre></div>
<p>Iâ€™ll give some more examples later, but effectively it gives us a better â€œdivideâ€ step in many divide and conquer algorithms.</p>
<h1 id="termination">Termination</h1>
<p>As it was such a useful fold, and so integral to many tricky algorithms, I really wanted to have it available in Agda. Unfortunately, though, the functions (as defined above) arenâ€™t structurally terminating, and there doesnâ€™t <em>look</em> like thereâ€™s an obvious way to make it so. I tried to make well founded recursion work, but the proofs were ugly and slow.</p>
<p>However, we can use some structures from a <a href="2018-11-20-fast-verified-structures.html">previous post</a>: the nested binary sequence, for instance. It has some extra nice properties: instead of nesting the types, we can just apply the combining function.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">mutual</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  <span class="kw">data</span> Tree <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">    2^<span class="ot">_</span>Ã—<span class="ot">_</span>+<span class="ot">_</span> <span class="ot">:</span> â„• <span class="ot">â†’</span> A <span class="ot">â†’</span> Node A <span class="ot">â†’</span> Tree A</a>
<a class="sourceLine" id="cb4-4" data-line-number="4"></a>
<a class="sourceLine" id="cb4-5" data-line-number="5">  <span class="kw">data</span> Node <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">    âŸ¨âŸ©  <span class="ot">:</span> Node A</a>
<a class="sourceLine" id="cb4-7" data-line-number="7">    âŸ¨<span class="ot">_</span>âŸ© <span class="ot">:</span> Tree A <span class="ot">â†’</span> Node A</a>
<a class="sourceLine" id="cb4-8" data-line-number="8"></a>
<a class="sourceLine" id="cb4-9" data-line-number="9"><span class="kw">module</span> TreeFold <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">(_</span>*<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">â†’</span> A <span class="ot">â†’</span> A<span class="ot">)</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-10" data-line-number="10">  <span class="kw">infixr</span> <span class="dv">5</span> <span class="ot">_</span>âŠ›<span class="ot">_</span> 2^<span class="ot">_</span>Ã—<span class="ot">_</span>âŠ›<span class="ot">_</span></a>
<a class="sourceLine" id="cb4-11" data-line-number="11"></a>
<a class="sourceLine" id="cb4-12" data-line-number="12">  2^<span class="ot">_</span>Ã—<span class="ot">_</span>âŠ›<span class="ot">_</span> <span class="ot">:</span> â„• <span class="ot">â†’</span> A <span class="ot">â†’</span> Tree A <span class="ot">â†’</span> Tree A</a>
<a class="sourceLine" id="cb4-13" data-line-number="13">  2^ n Ã— x âŠ› 2^ suc m Ã— y + ys <span class="ot">=</span> 2^ n Ã— x + âŸ¨ 2^ m Ã— y + ys âŸ©</a>
<a class="sourceLine" id="cb4-14" data-line-number="14">  2^ n Ã— x âŠ› 2^ zero  Ã— y + âŸ¨âŸ© <span class="ot">=</span> 2^ suc n Ã— <span class="ot">(</span>x * y<span class="ot">)</span> + âŸ¨âŸ©</a>
<a class="sourceLine" id="cb4-15" data-line-number="15">  2^ n Ã— x âŠ› 2^ zero  Ã— y + âŸ¨ ys âŸ© <span class="ot">=</span> 2^ suc n Ã— <span class="ot">(</span>x * y<span class="ot">)</span> âŠ› ys</a>
<a class="sourceLine" id="cb4-16" data-line-number="16"></a>
<a class="sourceLine" id="cb4-17" data-line-number="17">  <span class="ot">_</span>âŠ›<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">â†’</span> Tree A <span class="ot">â†’</span> Tree A</a>
<a class="sourceLine" id="cb4-18" data-line-number="18">  <span class="ot">_</span>âŠ›<span class="ot">_</span> <span class="ot">=</span> 2^ <span class="dv">0</span> Ã—<span class="ot">_</span>âŠ›<span class="ot">_</span></a>
<a class="sourceLine" id="cb4-19" data-line-number="19"></a>
<a class="sourceLine" id="cb4-20" data-line-number="20">  âŸ¦<span class="ot">_</span>âŸ§â†“ <span class="ot">:</span> Tree A <span class="ot">â†’</span> A</a>
<a class="sourceLine" id="cb4-21" data-line-number="21">  âŸ¦ 2^ <span class="ot">_</span> Ã— x + âŸ¨âŸ© âŸ§â†“ <span class="ot">=</span> x</a>
<a class="sourceLine" id="cb4-22" data-line-number="22">  âŸ¦ 2^ <span class="ot">_</span> Ã— x + âŸ¨ xs âŸ© âŸ§â†“ <span class="ot">=</span> x * âŸ¦ xs âŸ§â†“</a>
<a class="sourceLine" id="cb4-23" data-line-number="23"></a>
<a class="sourceLine" id="cb4-24" data-line-number="24">  âŸ¦<span class="ot">_</span>âŸ§â†‘ <span class="ot">:</span> A <span class="ot">â†’</span> Tree A</a>
<a class="sourceLine" id="cb4-25" data-line-number="25">  âŸ¦ x âŸ§â†‘ <span class="ot">=</span> 2^ <span class="dv">0</span> Ã— x + âŸ¨âŸ©</a>
<a class="sourceLine" id="cb4-26" data-line-number="26"></a>
<a class="sourceLine" id="cb4-27" data-line-number="27">  â¦…<span class="ot">_</span>,<span class="ot">_</span>â¦† <span class="ot">:</span> A <span class="ot">â†’</span> List A <span class="ot">â†’</span> A</a>
<a class="sourceLine" id="cb4-28" data-line-number="28">  â¦… x , xs â¦† <span class="ot">=</span> âŸ¦ foldr <span class="ot">_</span>âŠ›<span class="ot">_</span> âŸ¦ x âŸ§â†‘ xs âŸ§â†“</a></code></pre></div>
<p>Alternatively, we can get <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math> cons with the skew array:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">5</span> <span class="ot">_</span>âŠ›<span class="ot">_</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="ot">_</span>âŠ›<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">â†’</span> Tree A <span class="ot">â†’</span> Tree A</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">x âŠ› 2^ n Ã— y  + âŸ¨âŸ© <span class="ot">=</span> 2^ <span class="dv">0</span> Ã— x + âŸ¨ 2^ n Ã— y + âŸ¨âŸ© âŸ©</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">x âŠ› 2^ n Ã— yâ‚ + âŸ¨ 2^ <span class="dv">0</span>     Ã— yâ‚‚ + ys âŸ© <span class="ot">=</span> 2^ suc n Ã— <span class="ot">(</span>x * <span class="ot">(</span>yâ‚ * yâ‚‚<span class="ot">))</span> + ys</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">x âŠ› 2^ n Ã— yâ‚ + âŸ¨ 2^ suc m Ã— yâ‚‚ + ys âŸ© <span class="ot">=</span> 2^ <span class="dv">0</span> Ã— x + âŸ¨ 2^ n Ã— yâ‚ + âŸ¨ 2^ m Ã— yâ‚‚ + ys âŸ© âŸ©</a></code></pre></div>
<p>Using this, a proper and efficient merge sort is very straightforward:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">data</span> Total <span class="ot">{</span>a r<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">(_</span>â‰¤<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">â†’</span> A <span class="ot">â†’</span> <span class="dt">Set</span> r<span class="ot">)</span> <span class="ot">(</span>x y <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">(</span>a âŠ” r<span class="ot">)</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  xâ‰¤y <span class="ot">:</span> â¦ƒ <span class="ot">_</span> <span class="ot">:</span> x â‰¤ y â¦„ <span class="ot">â†’</span> Total <span class="ot">_</span>â‰¤<span class="ot">_</span> x y</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  yâ‰¤x <span class="ot">:</span> â¦ƒ <span class="ot">_</span> <span class="ot">:</span> y â‰¤ x â¦„ <span class="ot">â†’</span> Total <span class="ot">_</span>â‰¤<span class="ot">_</span> x y</a>
<a class="sourceLine" id="cb6-4" data-line-number="4"></a>
<a class="sourceLine" id="cb6-5" data-line-number="5"><span class="kw">module</span> Sorting <span class="ot">{</span>a r<span class="ot">}</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">               <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span></a>
<a class="sourceLine" id="cb6-7" data-line-number="7">               <span class="ot">{_</span>â‰¤<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">â†’</span> A <span class="ot">â†’</span> <span class="dt">Set</span> r<span class="ot">}</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">               <span class="ot">(_</span>â‰¤?<span class="ot">_</span> <span class="ot">:</span> <span class="ot">âˆ€</span> x y <span class="ot">â†’</span> Total <span class="ot">_</span>â‰¤<span class="ot">_</span> x y<span class="ot">)</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-9" data-line-number="9">  <span class="kw">data</span> [âˆ™] <span class="ot">:</span> <span class="dt">Set</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-10" data-line-number="10">    âŠ¥   <span class="ot">:</span> [âˆ™]</a>
<a class="sourceLine" id="cb6-11" data-line-number="11">    [<span class="ot">_</span>] <span class="ot">:</span> A <span class="ot">â†’</span> [âˆ™]</a>
<a class="sourceLine" id="cb6-12" data-line-number="12"></a>
<a class="sourceLine" id="cb6-13" data-line-number="13">  <span class="kw">data</span> <span class="ot">_</span>â‰¥<span class="ot">_</span> <span class="ot">(</span>x <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">:</span> [âˆ™] <span class="ot">â†’</span> <span class="dt">Set</span> <span class="ot">(</span>a âŠ” r<span class="ot">)</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-14" data-line-number="14">    instance âŒˆ<span class="ot">_</span>âŒ‰ <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>y<span class="ot">}</span> <span class="ot">â†’</span> y â‰¤ x <span class="ot">â†’</span> x â‰¥ [ y ]</a>
<a class="sourceLine" id="cb6-15" data-line-number="15">    instance âŒŠâŠ¥âŒ‹ <span class="ot">:</span> x â‰¥ âŠ¥</a>
<a class="sourceLine" id="cb6-16" data-line-number="16"></a>
<a class="sourceLine" id="cb6-17" data-line-number="17">  <span class="kw">infixr</span> <span class="dv">5</span> <span class="ot">_</span>âˆ·<span class="ot">_</span></a>
<a class="sourceLine" id="cb6-18" data-line-number="18">  <span class="kw">data</span> Ordered <span class="ot">(</span>b <span class="ot">:</span> [âˆ™]<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">(</span>a âŠ” r<span class="ot">)</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-19" data-line-number="19">    []  <span class="ot">:</span> Ordered b</a>
<a class="sourceLine" id="cb6-20" data-line-number="20">    <span class="ot">_</span>âˆ·<span class="ot">_</span> <span class="ot">:</span> <span class="ot">âˆ€</span> x <span class="ot">â†’</span> â¦ƒ xâ‰¥b <span class="ot">:</span> x â‰¥ b â¦„ <span class="ot">â†’</span> <span class="ot">(</span>xs <span class="ot">:</span> Ordered [ x ]<span class="ot">)</span> <span class="ot">â†’</span> Ordered b</a>
<a class="sourceLine" id="cb6-21" data-line-number="21"></a>
<a class="sourceLine" id="cb6-22" data-line-number="22">  <span class="ot">_</span>âˆª<span class="ot">_</span> <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>b<span class="ot">}</span> <span class="ot">â†’</span> Ordered b <span class="ot">â†’</span> Ordered b <span class="ot">â†’</span> Ordered b</a>
<a class="sourceLine" id="cb6-23" data-line-number="23">  [] âˆª ys <span class="ot">=</span> ys</a>
<a class="sourceLine" id="cb6-24" data-line-number="24">  <span class="ot">(</span>x âˆ· xs<span class="ot">)</span> âˆª ys <span class="ot">=</span> âŸ… x âˆ¹ xs âˆª ys âŸ†</a>
<a class="sourceLine" id="cb6-25" data-line-number="25">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-26" data-line-number="26">    âŸ…<span class="ot">_</span>âˆ¹<span class="ot">_</span>âˆª<span class="ot">_</span>âŸ† <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>b<span class="ot">}</span> <span class="ot">â†’</span> <span class="ot">âˆ€</span> x â¦ƒ <span class="ot">_</span> <span class="ot">:</span> x â‰¥ b â¦„ <span class="ot">â†’</span> Ordered [ x ] <span class="ot">â†’</span> Ordered b <span class="ot">â†’</span> Ordered b</a>
<a class="sourceLine" id="cb6-27" data-line-number="27">    âŸ…<span class="ot">_</span>âˆª<span class="ot">_</span>âˆ¹<span class="ot">_</span>âŸ† <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>b<span class="ot">}</span> <span class="ot">â†’</span> Ordered b <span class="ot">â†’</span> <span class="ot">âˆ€</span> y â¦ƒ <span class="ot">_</span> <span class="ot">:</span> y â‰¥ b â¦„ <span class="ot">â†’</span> Ordered [ y ] <span class="ot">â†’</span> Ordered b</a>
<a class="sourceLine" id="cb6-28" data-line-number="28">    merge <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>b<span class="ot">}</span> x y â¦ƒ <span class="ot">_</span> <span class="ot">:</span> x â‰¥ b â¦„ â¦ƒ <span class="ot">_</span> <span class="ot">:</span> y â‰¥ b â¦„</a>
<a class="sourceLine" id="cb6-29" data-line-number="29">          <span class="ot">â†’</span> Total <span class="ot">_</span>â‰¤<span class="ot">_</span> x y</a>
<a class="sourceLine" id="cb6-30" data-line-number="30">          <span class="ot">â†’</span> Ordered [ x ]</a>
<a class="sourceLine" id="cb6-31" data-line-number="31">          <span class="ot">â†’</span> Ordered [ y ]</a>
<a class="sourceLine" id="cb6-32" data-line-number="32">          <span class="ot">â†’</span> Ordered b</a>
<a class="sourceLine" id="cb6-33" data-line-number="33"></a>
<a class="sourceLine" id="cb6-34" data-line-number="34">    âŸ… x âˆ¹ xs âˆª [] âŸ† <span class="ot">=</span> x âˆ· xs</a>
<a class="sourceLine" id="cb6-35" data-line-number="35">    âŸ… x âˆ¹ xs âˆª y âˆ· ys âŸ† <span class="ot">=</span> merge x y <span class="ot">(</span>x â‰¤? y<span class="ot">)</span> xs ys</a>
<a class="sourceLine" id="cb6-36" data-line-number="36">    âŸ… [] âˆª y âˆ¹ ys âŸ† <span class="ot">=</span> y âˆ· ys</a>
<a class="sourceLine" id="cb6-37" data-line-number="37">    âŸ… x âˆ· xs âˆª y âˆ¹ ys âŸ† <span class="ot">=</span> merge x y <span class="ot">(</span>x â‰¤? y<span class="ot">)</span> xs ys</a>
<a class="sourceLine" id="cb6-38" data-line-number="38"></a>
<a class="sourceLine" id="cb6-39" data-line-number="39">    merge x y xâ‰¤y xs ys <span class="ot">=</span> x âˆ· âŸ… xs âˆª y âˆ¹ ys âŸ†</a>
<a class="sourceLine" id="cb6-40" data-line-number="40">    merge x y yâ‰¤x xs ys <span class="ot">=</span> y âˆ· âŸ… x âˆ¹ xs âˆª ys âŸ†</a>
<a class="sourceLine" id="cb6-41" data-line-number="41"></a>
<a class="sourceLine" id="cb6-42" data-line-number="42"></a>
<a class="sourceLine" id="cb6-43" data-line-number="43">  <span class="kw">open</span> TreeFold</a>
<a class="sourceLine" id="cb6-44" data-line-number="44"></a>
<a class="sourceLine" id="cb6-45" data-line-number="45">  sort <span class="ot">:</span> List A <span class="ot">â†’</span> Ordered âŠ¥</a>
<a class="sourceLine" id="cb6-46" data-line-number="46">  sort <span class="ot">=</span> â¦… <span class="ot">_</span>âˆª<span class="ot">_</span> , [] â¦† âˆ˜ map <span class="ot">(_</span>âˆ· []<span class="ot">)</span></a></code></pre></div>
<h1 id="validity">Validity</h1>
<p>It would be nice if we could verify these optimizated versions of folds. Luckily, by writing them using <code>foldr</code>, weâ€™ve stumbled into well-trodden ground: the <em>foldr fusion law</em>. It states that if you have some transformation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>, and two binary operators <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>âŠ•</mo><annotation encoding="application/x-tex">\oplus</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>âŠ—</mo><annotation encoding="application/x-tex">\otimes</annotation></semantics></math>, then:</p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right"><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>âŠ•</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="left"></mtd><mtd columnalign="right"><mo>=</mo><mspace width="0.278em"></mspace></mtd><mtd columnalign="left"><mi>x</mi><mo>âŠ—</mo><mi>f</mi><mi>y</mi></mtd></mtr><mtr><mtd columnalign="right"><mo>âŸ¹</mo><mi>f</mi><mo>âˆ˜</mo><mtext mathvariant="normal">foldr</mtext><mo>âŠ•</mo><mi>e</mi></mtd><mtd columnalign="left"></mtd><mtd columnalign="right"><mo>=</mo><mspace width="0.278em"></mspace></mtd><mtd columnalign="left"><mtext mathvariant="normal">foldr</mtext><mo>âŠ—</mo><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mi>e</mi><mo stretchy="false" form="postfix">)</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align}
   f (x \oplus y)                         &amp;&amp;=\;&amp; x \otimes f y \\
   \implies f \circ \text{foldr} \oplus e &amp;&amp;=\;&amp; \text{foldr} \otimes (f e)
\end{align}</annotation></semantics></math>
<p>This fits right in with the function we used above. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> is <code>âŸ¦_âŸ§â†“</code>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>âŠ•</mo><annotation encoding="application/x-tex">\oplus</annotation></semantics></math> is <code>_âŠ›_</code>, and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>âŠ—</mo><annotation encoding="application/x-tex">\otimes</annotation></semantics></math> is whatever combining function was passed in. Letâ€™s prove the foldr fusion law, then, before we go any further.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">module</span> Proofs</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  <span class="ot">{</span>a r<span class="ot">}</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">  <span class="ot">{</span>R <span class="ot">:</span> Rel A r<span class="ot">}</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6"></a>
<a class="sourceLine" id="cb7-7" data-line-number="7">  <span class="kw">infix</span> <span class="dv">4</span> <span class="ot">_</span>â‰ˆ<span class="ot">_</span></a>
<a class="sourceLine" id="cb7-8" data-line-number="8">  <span class="ot">_</span>â‰ˆ<span class="ot">_</span> <span class="ot">=</span> R</a>
<a class="sourceLine" id="cb7-9" data-line-number="9"></a>
<a class="sourceLine" id="cb7-10" data-line-number="10">  <span class="kw">open</span> <span class="kw">import</span> Algebra<span class="ot">.</span>FunctionProperties <span class="ot">_</span>â‰ˆ<span class="ot">_</span></a>
<a class="sourceLine" id="cb7-11" data-line-number="11"></a>
<a class="sourceLine" id="cb7-12" data-line-number="12">  foldr-universal <span class="ot">:</span> Transitive <span class="ot">_</span>â‰ˆ<span class="ot">_</span></a>
<a class="sourceLine" id="cb7-13" data-line-number="13">                  <span class="ot">â†’</span> <span class="ot">âˆ€</span> <span class="ot">{</span>b<span class="ot">}</span> <span class="ot">{</span>B <span class="ot">:</span> <span class="dt">Set</span> b<span class="ot">}</span> <span class="ot">(</span>h <span class="ot">:</span> List B <span class="ot">â†’</span> A<span class="ot">)</span> f e</a>
<a class="sourceLine" id="cb7-14" data-line-number="14">                  <span class="ot">â†’</span> âˆ€[ f âŠ¢ Congruentâ‚ ]</a>
<a class="sourceLine" id="cb7-15" data-line-number="15">                  <span class="ot">â†’</span> <span class="ot">(</span>h [] â‰ˆ e<span class="ot">)</span></a>
<a class="sourceLine" id="cb7-16" data-line-number="16">                  <span class="ot">â†’</span> <span class="ot">(âˆ€</span> x xs <span class="ot">â†’</span> h <span class="ot">(</span>x âˆ· xs<span class="ot">)</span> â‰ˆ f x <span class="ot">(</span>h xs<span class="ot">))</span></a>
<a class="sourceLine" id="cb7-17" data-line-number="17">                  <span class="ot">â†’</span> <span class="ot">âˆ€</span> xs <span class="ot">â†’</span> h xs â‰ˆ foldr f e xs</a>
<a class="sourceLine" id="cb7-18" data-line-number="18">  foldr-universal <span class="ot">_</span>â—‹<span class="ot">_</span> h f e fâŸ¨<span class="ot">_</span>âŸ© â‡’[] â‡’<span class="ot">_</span>âˆ·<span class="ot">_</span> [] <span class="ot">=</span> â‡’[]</a>
<a class="sourceLine" id="cb7-19" data-line-number="19">  foldr-universal <span class="ot">_</span>â—‹<span class="ot">_</span> h f e fâŸ¨<span class="ot">_</span>âŸ© â‡’[] â‡’<span class="ot">_</span>âˆ·<span class="ot">_</span> <span class="ot">(</span>x âˆ· xs<span class="ot">)</span> <span class="ot">=</span></a>
<a class="sourceLine" id="cb7-20" data-line-number="20">    <span class="ot">(</span>â‡’ x âˆ· xs<span class="ot">)</span> â—‹ fâŸ¨ foldr-universal <span class="ot">_</span>â—‹<span class="ot">_</span> h f e fâŸ¨<span class="ot">_</span>âŸ© â‡’[] â‡’<span class="ot">_</span>âˆ·<span class="ot">_</span> xs âŸ©</a>
<a class="sourceLine" id="cb7-21" data-line-number="21"></a>
<a class="sourceLine" id="cb7-22" data-line-number="22">  foldr-fusion <span class="ot">:</span> Transitive <span class="ot">_</span>â‰ˆ<span class="ot">_</span></a>
<a class="sourceLine" id="cb7-23" data-line-number="23">               <span class="ot">â†’</span> Reflexive <span class="ot">_</span>â‰ˆ<span class="ot">_</span></a>
<a class="sourceLine" id="cb7-24" data-line-number="24">               <span class="ot">â†’</span> <span class="ot">âˆ€</span> <span class="ot">{</span>b c<span class="ot">}</span> <span class="ot">{</span>B <span class="ot">:</span> <span class="dt">Set</span> b<span class="ot">}</span> <span class="ot">{</span>C <span class="ot">:</span> <span class="dt">Set</span> c<span class="ot">}</span> <span class="ot">(</span>f <span class="ot">:</span> C <span class="ot">â†’</span> A<span class="ot">)</span> <span class="ot">{_</span>âŠ•<span class="ot">_</span> <span class="ot">:</span> B <span class="ot">â†’</span> C <span class="ot">â†’</span> C<span class="ot">}</span> <span class="ot">{_</span>âŠ—<span class="ot">_</span> <span class="ot">:</span> B <span class="ot">â†’</span> A <span class="ot">â†’</span> A<span class="ot">}</span> e</a>
<a class="sourceLine" id="cb7-25" data-line-number="25">               <span class="ot">â†’</span> âˆ€[ <span class="ot">_</span>âŠ—<span class="ot">_</span> âŠ¢ Congruentâ‚ ]</a>
<a class="sourceLine" id="cb7-26" data-line-number="26">               <span class="ot">â†’</span> <span class="ot">(âˆ€</span> x y <span class="ot">â†’</span> f <span class="ot">(</span>x âŠ• y<span class="ot">)</span> â‰ˆ x âŠ— f y<span class="ot">)</span></a>
<a class="sourceLine" id="cb7-27" data-line-number="27">               <span class="ot">â†’</span> <span class="ot">âˆ€</span> xs <span class="ot">â†’</span> f <span class="ot">(</span>foldr <span class="ot">_</span>âŠ•<span class="ot">_</span> e xs<span class="ot">)</span> â‰ˆ foldr <span class="ot">_</span>âŠ—<span class="ot">_</span> <span class="ot">(</span>f e<span class="ot">)</span> xs</a>
<a class="sourceLine" id="cb7-28" data-line-number="28">  foldr-fusion <span class="ot">_</span>â—‹<span class="ot">_</span> âˆ h <span class="ot">{</span>f<span class="ot">}</span> <span class="ot">{</span>g<span class="ot">}</span> e gâŸ¨<span class="ot">_</span>âŸ© fuse <span class="ot">=</span></a>
<a class="sourceLine" id="cb7-29" data-line-number="29">    foldr-universal <span class="ot">_</span>â—‹<span class="ot">_</span> <span class="ot">(</span>h âˆ˜ foldr f e<span class="ot">)</span> g <span class="ot">(</span>h e<span class="ot">)</span> gâŸ¨<span class="ot">_</span>âŸ© âˆ <span class="ot">(Î»</span> x xs <span class="ot">â†’</span> fuse x <span class="ot">(</span>foldr f e xs<span class="ot">))</span></a></code></pre></div>
<p>Weâ€™re not using the proofs in Agdaâ€™s standard library because these are tied to propositional equality. In other words, instead of using an abstract binary relation, they prove things over <em>actual</em> equality. Thatâ€™s all well and good, but as you can see above, we donâ€™t need propositional equality: we donâ€™t even need the relation to be an equivalence, we just need transitivity and reflexivity.</p>
<p>After that, we can state precisely what correspondence the tree fold has, and under what conditions it does the same things as a fold:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">module</span> <span class="ot">_</span> <span class="ot">{_</span>*<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">â†’</span> A <span class="ot">â†’</span> A<span class="ot">}</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  <span class="kw">open</span> TreeFold <span class="ot">_</span>*<span class="ot">_</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3"></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">  treeFoldHom <span class="ot">:</span> Transitive <span class="ot">_</span>â‰ˆ<span class="ot">_</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5">              <span class="ot">â†’</span> Reflexive <span class="ot">_</span>â‰ˆ<span class="ot">_</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">              <span class="ot">â†’</span> Associative <span class="ot">_</span>*<span class="ot">_</span></a>
<a class="sourceLine" id="cb8-7" data-line-number="7">              <span class="ot">â†’</span> RightCongruent <span class="ot">_</span>*<span class="ot">_</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8">              <span class="ot">â†’</span> <span class="ot">âˆ€</span> x xs</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">              <span class="ot">â†’</span> â¦… x , xs â¦† â‰ˆ foldr <span class="ot">_</span>*<span class="ot">_</span> x xs</a>
<a class="sourceLine" id="cb8-10" data-line-number="10">  treeFoldHom <span class="ot">_</span>â—‹<span class="ot">_</span> âˆ assoc *âŸ¨<span class="ot">_</span>âŸ© b <span class="ot">=</span> foldr-fusion <span class="ot">_</span>â—‹<span class="ot">_</span> âˆ âŸ¦<span class="ot">_</span>âŸ§â†“ âŸ¦ b âŸ§â†‘ *âŸ¨<span class="ot">_</span>âŸ© <span class="ot">(</span>âŠ›-hom zero<span class="ot">)</span></a>
<a class="sourceLine" id="cb8-11" data-line-number="11">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-12" data-line-number="12">    âŠ›-hom <span class="ot">:</span> <span class="ot">âˆ€</span> n x xs <span class="ot">â†’</span> âŸ¦ 2^ n Ã— x âŠ› xs âŸ§â†“ â‰ˆ x * âŸ¦ xs âŸ§â†“</a>
<a class="sourceLine" id="cb8-13" data-line-number="13">    âŠ›-hom n x <span class="ot">(</span>2^ suc m Ã— y + âŸ¨âŸ©    <span class="ot">)</span> <span class="ot">=</span> âˆ</a>
<a class="sourceLine" id="cb8-14" data-line-number="14">    âŠ›-hom n x <span class="ot">(</span>2^ suc m Ã— y + âŸ¨ ys âŸ©<span class="ot">)</span> <span class="ot">=</span> âˆ</a>
<a class="sourceLine" id="cb8-15" data-line-number="15">    âŠ›-hom n x <span class="ot">(</span>2^ zero  Ã— y + âŸ¨âŸ©    <span class="ot">)</span> <span class="ot">=</span> âˆ</a>
<a class="sourceLine" id="cb8-16" data-line-number="16">    âŠ›-hom n x <span class="ot">(</span>2^ zero  Ã— y + âŸ¨ ys âŸ©<span class="ot">)</span> <span class="ot">=</span> âŠ›-hom <span class="ot">(</span>suc n<span class="ot">)</span> <span class="ot">(</span>x * y<span class="ot">)</span> ys â—‹ assoc x y âŸ¦ ys âŸ§â†“</a></code></pre></div>
<h1 id="implicit-data-structures">â€œImplicitâ€ Data Structures</h1>
<p>Consider the following implementation of the tree above in Haskell:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Tree</span> a <span class="fu">=</span> [(<span class="dt">Int</span>,a)]</a>
<a class="sourceLine" id="cb9-2" data-line-number="2"></a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="ot">cons ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">cons (<span class="fu">*</span>) <span class="fu">=</span> cons' <span class="dv">0</span> </a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6">    cons' n x [] <span class="fu">=</span> [(n,x)]</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">    cons' n x ((<span class="dv">0</span>,y)<span class="fu">:</span>ys) <span class="fu">=</span> cons' (n<span class="fu">+</span><span class="dv">1</span>) (x <span class="fu">*</span> y) ys</a>
<a class="sourceLine" id="cb9-8" data-line-number="8">    cons' n x ((m,y)<span class="fu">:</span>ys) <span class="fu">=</span> (n,x) <span class="fu">:</span> (m<span class="fu">-</span><span class="dv">1</span>,y) <span class="fu">:</span> ys</a></code></pre></div>
<p>The <code>cons</code> function â€œincrementsâ€ that list as if it were the bits of a binary number. Now, consider using the <code>merge</code> function from above, in a pattern like this:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">f <span class="fu">=</span> foldr (cons merge <span class="fu">.</span> pure) []</a></code></pre></div>
<p>What does <code>f</code> build? A list of lists, right?</p>
<p>Kind of. Thatâ€™s whatâ€™s built in terms of the observable, but whatâ€™s actually stored in memory us a bunch of thunks. The shape of <em>those</em> is what Iâ€™m interested in. We can try and see what they look like by using a data structure that doesnâ€™t force on merge:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a <span class="fu">=</span> <span class="dt">Leaf</span> a <span class="fu">|</span> <span class="dt">Tree</span> a <span class="fu">:*:</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb11-2" data-line-number="2"></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">f <span class="fu">=</span> foldr (cons (<span class="fu">:*:</span>) <span class="fu">.</span> <span class="dt">Leaf</span>) []</a></code></pre></div>
<p>Using a handy tree-drawing function, we can see what <code>f [1..13]</code> looks like:</p>
<pre><code>[(0,*),(1,*),(0,*)]
    â””1    â”‚ â”Œ2  â”‚  â”Œ6
          â”‚â”Œâ”¤   â”‚ â”Œâ”¤
          â”‚â”‚â””3  â”‚ â”‚â””7
          â””â”¤    â”‚â”Œâ”¤
           â”‚â”Œ4  â”‚â”‚â”‚â”Œ8
           â””â”¤   â”‚â”‚â””â”¤
            â””5  â”‚â”‚ â””9
                â””â”¤
                 â”‚ â”Œ10
                 â”‚â”Œâ”¤
                 â”‚â”‚â””11
                 â””â”¤
                  â”‚â”Œ12
                  â””â”¤
                   â””13</code></pre>
<p>Itâ€™s a binomial heap! Itâ€™s a list of trees, each one contains <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mi>n</mi></msup><annotation encoding="application/x-tex">2^n</annotation></semantics></math> elements. But theyâ€™re not in heap order, you say? Well, as a matter of fact, they <em>are</em>. It just hasnâ€™t been evaluated yet. Once we forceâ€”sayâ€”the first element, the rest will shuffle themselves into a tree of thunks.</p>
<p>This illustrates a pretty interesting similarity between binomial heaps and merge sort. Performance-wise, though, thereâ€™s another interesting property: the thunks <em>stay thunked</em>. In other words, if we do a merge sort via:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1">sort <span class="fu">=</span> foldr (merge <span class="fu">.</span> snd) [] <span class="fu">.</span> foldr (cons merge <span class="fu">.</span> pure) []</a></code></pre></div>
<p>We could instead freeze the fold, and look at it at every point:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1">sortPrefixes <span class="fu">=</span> map (foldr (merge <span class="fu">.</span> snd) []) <span class="fu">.</span> scanl (flip (cons merge <span class="fu">.</span> pure)) []</a>
<a class="sourceLine" id="cb14-2" data-line-number="2"><span class="fu">&gt;&gt;&gt;</span> [[],[<span class="dv">1</span>],[<span class="dv">1</span>,<span class="dv">4</span>],[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">4</span>],[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>],[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>]]</a></code></pre></div>
<p>And <code>sortPrefixes</code> is only <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n^2)</annotation></semantics></math> (rather than <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n^2 \log n)</annotation></semantics></math>). I confess I donâ€™t know of a use for sorted prefixes, but it should illustrate the general idea: we get a pretty decent batching of operations, with the ability to freeze at any point in time. The other nice property (which I mentioned in the last post) is that any of the tree folds are extremely parallel.</p>
<h1 id="random-shuffles">Random Shuffles</h1>
<p><a href="http://okmij.org/ftp/Haskell/AlgorithmsH.html#perfect-shuffle">Thereâ€™s a great article on shuffling in Haskell</a> which provides an <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n \log n)</annotation></semantics></math> implementation of a perfect random shuffle. Unfortunately, the <a href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle">Fisher-Yates shuffle</a> isnâ€™t applicable in a pure functional setting, so you have to be a little cleverer.</p>
<p>The first implementation most people jump to (certainly the one I thought of) is to assign everything in the sequence a random number, and then sort according to that number. Perhaps surprisingly, this <em>isnâ€™t</em> perfectly random! Itâ€™s a little weird, but the example in the article explains it well: basically, for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> elements, your random numbers will have <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>n</mi><mi>n</mi></msup><annotation encoding="application/x-tex">n^n</annotation></semantics></math> possible values, but the output of the sort will have <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>!</mi></mrow><annotation encoding="application/x-tex">n!</annotation></semantics></math> possible values. Since they donâ€™t divide into each other evenly, youâ€™re going to have some extra weight on some permutations, and less on others.</p>
<p>Instead, we can generate a random <a href="https://en.wikipedia.org/wiki/Factorial_number_system"><em>factoradic</em></a> number. A factoradic number is one where the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>th digit is in base <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>. Because of this, a factoradic number with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> digits has <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>!</mi></mrow><annotation encoding="application/x-tex">n!</annotation></semantics></math> possible values: exactly what we want.</p>
<p>In the article, the digits of the number are used to pop values from a binary tree. Because the last digit will have <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> possible values, and the second last <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>âˆ’</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math>, and so on, you can keep popping without hitting an empty tree.</p>
<p>This has the correct time complexityâ€”<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n \log n)</annotation></semantics></math>â€”but thereâ€™s a lot of overhead. Building the tree, then indexing into it, the rebuilding after each pop, etc.</p>
<p>Weâ€™d <em>like</em> to just sort the list, according to the indices. The problem is that the indices are relative: if you want to <code>cons</code> something onto the list, you have to increment the rest of the indices, as theyâ€™ve all shifted right by one.</p>
<p>What weâ€™ll do instead is use the indices as <em>gaps</em>. Our merge function looks like the following:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1">merge [] ys <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">merge xs [] <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">merge ((x,i)<span class="fu">:</span>xs) ((y,j)<span class="fu">:</span>ys)</a>
<a class="sourceLine" id="cb15-4" data-line-number="4">  <span class="fu">|</span> i <span class="fu">&lt;=</span> j    <span class="fu">=</span> (x,i) <span class="fu">:</span> merge xs ((y,j<span class="fu">-</span>i)<span class="fu">:</span>ys)</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">  <span class="fu">|</span> otherwise <span class="fu">=</span> (y,j) <span class="fu">:</span> merge ((x,i<span class="fu">-</span>j<span class="fu">-</span><span class="dv">1</span>)<span class="fu">:</span>xs) ys</a></code></pre></div>
<p>With that, and the same <code>cons</code> as above, we get a very simple random shuffle algorithm:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1">shuffle xs <span class="fu">=</span> map fst</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">           <span class="fu">.</span> foldr (merge <span class="fu">.</span> snd) []</a>
<a class="sourceLine" id="cb16-3" data-line-number="3">           <span class="fu">.</span> foldr f (const []) xs</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-5" data-line-number="5">    f x xs (i<span class="fu">:</span>is) <span class="fu">=</span> cons merge [(x,i)] (xs is)</a></code></pre></div>
<p>The other interesting thing about this algorithm is that it can use Peano numbers with taking too much of a performance hit:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1">merge <span class="fu">:</span> <span class="ot">âˆ€</span> {a} {<span class="dt">A</span> <span class="fu">:</span> <span class="dt">Set</span> a} <span class="ot">â†’</span> <span class="dt">List</span> (<span class="dt">A</span> Ã— â„•) <span class="ot">â†’</span> <span class="dt">List</span> (<span class="dt">A</span> Ã— â„•) <span class="ot">â†’</span> <span class="dt">List</span> (<span class="dt">A</span> Ã— â„•)</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">merge xs [] <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb17-3" data-line-number="3">merge {<span class="dt">A</span> <span class="fu">=</span> <span class="dt">A</span>} xs ((y , j) <span class="ot">âˆ·</span> ys) <span class="fu">=</span> go<span class="fu">-</span>r xs y j ys</a>
<a class="sourceLine" id="cb17-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb17-5" data-line-number="5">  go<span class="fu">-</span>l <span class="fu">:</span> <span class="dt">A</span> <span class="ot">â†’</span> â„• <span class="ot">â†’</span> <span class="dt">List</span> (<span class="dt">A</span> Ã— â„•) <span class="ot">â†’</span> <span class="dt">List</span> (<span class="dt">A</span> Ã— â„•) <span class="ot">â†’</span> <span class="dt">List</span> (<span class="dt">A</span> Ã— â„•)</a>
<a class="sourceLine" id="cb17-6" data-line-number="6">  go<span class="fu">-</span>r <span class="fu">:</span> <span class="dt">List</span> (<span class="dt">A</span> Ã— â„•) <span class="ot">â†’</span> <span class="dt">A</span> <span class="ot">â†’</span> â„• <span class="ot">â†’</span> <span class="dt">List</span> (<span class="dt">A</span> Ã— â„•) <span class="ot">â†’</span> <span class="dt">List</span> (<span class="dt">A</span> Ã— â„•)</a>
<a class="sourceLine" id="cb17-7" data-line-number="7">  go <span class="fu">:</span> â„• <span class="ot">â†’</span> â„• <span class="ot">â†’</span> <span class="dt">A</span> <span class="ot">â†’</span> â„• <span class="ot">â†’</span> <span class="dt">List</span> (<span class="dt">A</span> Ã— â„•) <span class="ot">â†’</span> <span class="dt">A</span> <span class="ot">â†’</span> â„• <span class="ot">â†’</span> <span class="dt">List</span> (<span class="dt">A</span> Ã— â„•) <span class="ot">â†’</span> <span class="dt">List</span> (<span class="dt">A</span> Ã— â„•)</a>
<a class="sourceLine" id="cb17-8" data-line-number="8"></a>
<a class="sourceLine" id="cb17-9" data-line-number="9">  go i     zero   x iâ€² xs y jâ€² ys <span class="fu">=</span> (y , jâ€²) <span class="ot">âˆ·</span> go<span class="fu">-</span>l x i xs ys</a>
<a class="sourceLine" id="cb17-10" data-line-number="10">  go zero (suc j) x iâ€² xs y jâ€² ys <span class="fu">=</span> (x , iâ€²) <span class="ot">âˆ·</span> go<span class="fu">-</span>r xs y j ys</a>
<a class="sourceLine" id="cb17-11" data-line-number="11">  go (suc i) (suc j) <span class="fu">=</span> go i j</a>
<a class="sourceLine" id="cb17-12" data-line-number="12"></a>
<a class="sourceLine" id="cb17-13" data-line-number="13">  go<span class="fu">-</span>l x i xs [] <span class="fu">=</span> (x , i) <span class="ot">âˆ·</span> xs</a>
<a class="sourceLine" id="cb17-14" data-line-number="14">  go<span class="fu">-</span>l x i xs ((y , j) <span class="ot">âˆ·</span> ys) <span class="fu">=</span> go i j x i xs y j ys</a>
<a class="sourceLine" id="cb17-15" data-line-number="15"></a>
<a class="sourceLine" id="cb17-16" data-line-number="16">  go<span class="fu">-</span>r [] y j ys <span class="fu">=</span> (y , j) <span class="ot">âˆ·</span> ys</a>
<a class="sourceLine" id="cb17-17" data-line-number="17">  go<span class="fu">-</span>r ((x , i) <span class="ot">âˆ·</span> xs) y j ys <span class="fu">=</span> go i j x i xs y j ys</a>
<a class="sourceLine" id="cb17-18" data-line-number="18"></a>
<a class="sourceLine" id="cb17-19" data-line-number="19">shuffle <span class="fu">:</span> <span class="ot">âˆ€</span> {a} {<span class="dt">A</span> <span class="fu">:</span> <span class="dt">Set</span> a} <span class="ot">â†’</span> <span class="dt">List</span> <span class="dt">A</span> <span class="ot">â†’</span> <span class="dt">List</span> â„• <span class="ot">â†’</span> <span class="dt">List</span> <span class="dt">A</span></a>
<a class="sourceLine" id="cb17-20" data-line-number="20">shuffle {a} {<span class="dt">A</span>} xs i <span class="fu">=</span> map projâ‚ (â¦… [] , zip<span class="fu">-</span>inds xs i â¦†)</a>
<a class="sourceLine" id="cb17-21" data-line-number="21">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb17-22" data-line-number="22">  open <span class="dt">TreeFold</span> {a} {<span class="dt">List</span> (<span class="dt">A</span> Ã— â„•)} merge</a>
<a class="sourceLine" id="cb17-23" data-line-number="23"></a>
<a class="sourceLine" id="cb17-24" data-line-number="24">  zip<span class="fu">-</span>inds <span class="fu">:</span> <span class="dt">List</span> <span class="dt">A</span> <span class="ot">â†’</span> <span class="dt">List</span> â„• <span class="ot">â†’</span> <span class="dt">List</span> (<span class="dt">List</span> (<span class="dt">A</span> Ã— â„•))</a>
<a class="sourceLine" id="cb17-25" data-line-number="25">  zip<span class="fu">-</span>inds [] inds <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb17-26" data-line-number="26">  zip<span class="fu">-</span>inds (x <span class="ot">âˆ·</span> xs) [] <span class="fu">=</span> ((x , <span class="dv">0</span>) <span class="ot">âˆ·</span> []) <span class="ot">âˆ·</span> zip<span class="fu">-</span>inds xs []</a>
<a class="sourceLine" id="cb17-27" data-line-number="27">  zip<span class="fu">-</span>inds (x <span class="ot">âˆ·</span> xs) (i <span class="ot">âˆ·</span> inds) <span class="fu">=</span> ((x , i) <span class="ot">âˆ·</span> []) <span class="ot">âˆ·</span> zip<span class="fu">-</span>inds xs inds</a></code></pre></div>
<p>I donâ€™t know exactly what the complexity of this is, but I <em>think</em> it should be better than the usual approach of popping from a vector.</p>
<h1 id="future-stuff">Future Stuff</h1>
<p>This is just a collection of random thoughts for now, but I intend to work on using these folds to see if there are any other algorithms they can be useful for. In particular, I think I can write a version of Data.List.permutations which benefits from sharing. And Iâ€™m interested in using the implicit binomial heap for some search problems.</p>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
