<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Balancing Scans - Donnacha OisÃ­n Kidney</title>
        <style>body{color:black;font-family:Garamond,Times New Roman,serif;font-size:14px;margin:0px auto 0px auto;padding-left:5px;padding-right:5px;max-width:600px}math{font-size:13px}img{max-width:600px}summary{outline:0}div#header{border-bottom:3px double black;margin-bottom:30px;padding:12px 0px 12px 0px}div#logo a{color:black;float:left;font-size:20px;text-decoration:none}div#header #navigation{text-align:right}div#header #navigation a{color:black;font-family:Garamond,Times New Roman,Serif;font-size:18px;margin-left:10px;text-decoration:none;text-transform:uppercase}div#footer{font-family:Garamond,Times New Roman,Serif;border-top:solid 2px black;color:#555;font-size:12px;margin-top:30px;padding:12px 0px 12px 0px;text-align:right}h1{font-family:Garamond,Times New Roman,Serif;font-size:22px;font-weight:normal}h2{font-family:Garamond,Times New Roman,Serif;font-size:20px;font-weight:normal}div.info{color:#555;font-size:15px;font-style:italic}span.quiet{color:#828282;font-style:italic}a{color:black;word-wrap:break-word}ul.post-list{margin-left:0px;padding-left:0px;list-style-type:none}.hidden_source{display:none}ol.serieslist{counter-reset:item;list-style-type:none;padding-left:20}ol li.serieslist:before{content:'Part ' counter(item,decimal) ':';counter-increment:item}table.sourceCode,tr.sourceCode,td.lineNumbers,td.sourceCode,table.sourceCode pre{margin:0;padding:0;border:0;vertical-align:baseline;border:none}td.lineNumbers{border-right:1px solid #AAAAAA;text-align:right;color:#AAAAAA;padding-right:5px;padding-left:5px}td.sourceCode{padding-left:5px}.sourceCode,code,pre,.Agda{font-size:11px;font-family:menlo,monospace}.sourceCode span.kw{color:#262C6A}.sourceCode span.dt{color:#476A97}.sourceCode span.dv{color:#262C6A}.sourceCode span.bn{color:#262C6A}.sourceCode span.fl{color:#262C6A}.sourceCode span.ch{color:#262C6A}.sourceCode span.st{color:#702C51}.sourceCode span.co{color:#435138}.sourceCode span.ot{color:#262C6A}.sourceCode span.al{color:red}.sourceCode span.fu{color:#000000}.sourceCode span.re{color:#000000}.sourceCode span.er{color:red}li{margin-bottom:2px}li:last-child{margin-bottom:0px}.Agda .Comment{color:#B22222}.Agda .Background{}.Agda .Markup{color:#000000}.Agda .Keyword{color:#CD6600}.Agda .String{color:#B22222}.Agda .Number{color:#A020F0}.Agda .Symbol{color:#404040}.Agda .PrimitiveType{color:#0000CD}.Agda .Pragma{color:black}.Agda .Operator{}.Agda .Bound{color:black}.Agda .Generalizable{color:black}.Agda .InductiveConstructor{color:#008B00}.Agda .CoinductiveConstructor{color:#8B7500}.Agda .Datatype{color:#0000CD}.Agda .Field{color:#EE1289}.Agda .Function{color:#0000CD}.Agda .Module{color:#A020F0}.Agda .Postulate{color:#0000CD}.Agda .Primitive{color:#0000CD}.Agda .Record{color:#0000CD}.Agda .DottedPattern{}.Agda .UnsolvedMeta{color:black;background:yellow}.Agda .UnsolvedConstraint{color:black;background:yellow}.Agda .TerminationProblem{color:black;background:#FFA07A}.Agda .IncompletePattern{color:black;background:#F5DEB3}.Agda .Error{color:red;text-decoration:underline}.Agda .TypeChecks{color:black;background:#ADD8E6}.Agda a{text-decoration:none}.Agda a[href]:hover{background-color:#B4EEB4}.sourceCode{overflow-x:auto}</style>
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Donnacha OisÃ­n Kidney</a>
            </div>
            <div id="navigation">
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../rss.xml">Feed</a>
            </div>
        </div>

        <div id="content">
            <h2>Balancing Scans</h2>

            <div class="info">
    Posted on December 21, 2018
</div>
<div class="info">
    
        Part 2 of a <a href="../series/Balanced%20Folds.html">3-part series on Balanced Folds</a>
    
</div>
<div class="info">
    
        Tags: <a title="All pages tagged 'Haskell'." href="../tags/Haskell.html">Haskell</a>, <a title="All pages tagged 'Agda'." href="../tags/Agda.html">Agda</a>
    
</div>

<p><a href="2017-10-30-balancing-folds.html">Previously</a> I tried to figure out a way to fold lists in a more balanced way. Usually, when folding lists, youâ€™ve got two choices for your folds, both of which are extremely unbalanced in one direction or another. Jon Fairbairn <a href="https://www.mail-archive.com/haskell@haskell.org/msg01788.html">wrote</a> a more balanced version, which looked something like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="ot">treeFold ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> a</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>treeFold f <span class="ot">=</span> go</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>    go x [] <span class="ot">=</span> x</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>    go a (b<span class="op">:</span>l) <span class="ot">=</span> go (f a b) (pairMap l)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>    pairMap (x<span class="op">:</span>y<span class="op">:</span>rest) <span class="ot">=</span> f x y <span class="op">:</span> pairMap rest</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>    pairMap xs <span class="ot">=</span> xs</span></code></pre></div>
<h1 id="magical-speedups">Magical Speedups</h1>
<p>The fold above is kind of magical: for a huge class of algorithms, it kind of â€œautomaticallyâ€ improves some factor of theirs from <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n)</annotation></semantics></math> to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math>. For instance: to sum a list of floats, <code class="sourceCode haskell">foldl' (<span class="op">+</span>) <span class="dv">0</span></code> will have an error growth of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n)</annotation></semantics></math>; <code>treeFold (+) 0</code>, though, has an error rate of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math>. Similarly, using the following function to merge two sorted lists:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="ot">merge ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>merge [] ys <span class="ot">=</span> ys</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>merge (x<span class="op">:</span>xs) ys <span class="ot">=</span> go x xs ys</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>    go x xs [] <span class="ot">=</span> x <span class="op">:</span> xs</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>    go x xs (y<span class="op">:</span>ys)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>      <span class="op">|</span> x <span class="op">&lt;=</span> y    <span class="ot">=</span> x <span class="op">:</span> go y ys xs</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a>      <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> y <span class="op">:</span> go x xs ys</span></code></pre></div>
<p>We get either insertion sort (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n^2)</annotation></semantics></math>) or merge sort (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n \log n)</annotation></semantics></math>) just depending on which fold you use.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="fu">foldr</span>    merge [] <span class="op">.</span> <span class="fu">map</span> <span class="fu">pure</span> <span class="co">-- n^2</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>treeFold merge [] <span class="op">.</span> <span class="fu">map</span> <span class="fu">pure</span> <span class="co">-- n log(n)</span></span></code></pre></div>
<p>Iâ€™ll give some more examples later, but effectively it gives us a better â€œdivideâ€ step in many divide and conquer algorithms.</p>
<h1 id="termination">Termination</h1>
<p>As it was such a useful fold, and so integral to many tricky algorithms, I really wanted to have it available in Agda. Unfortunately, though, the functions (as defined above) arenâ€™t structurally terminating, and there doesnâ€™t <em>look</em> like thereâ€™s an obvious way to make it so. I tried to make well founded recursion work, but the proofs were ugly and slow.</p>
<p>However, we can use some structures from a <a href="2018-11-20-fast-verified-structures.html">previous post</a>: the nested binary sequence, for instance. It has some extra nice properties: instead of nesting the types, we can just apply the combining function.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">mutual</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>  <span class="kw">data</span> Tree <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> a <span class="kw">where</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>    2^<span class="ot">_</span>Ã—<span class="ot">_</span>+<span class="ot">_</span> <span class="ot">:</span> â„• <span class="ot">â†’</span> A <span class="ot">â†’</span> Node A <span class="ot">â†’</span> Tree A</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>  <span class="kw">data</span> Node <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> a <span class="kw">where</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>    âŸ¨âŸ©  <span class="ot">:</span> Node A</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a>    âŸ¨<span class="ot">_</span>âŸ© <span class="ot">:</span> Tree A <span class="ot">â†’</span> Node A</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a><span class="kw">module</span> TreeFold <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">(_</span>*<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">â†’</span> A <span class="ot">â†’</span> A<span class="ot">)</span> <span class="kw">where</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a>  <span class="kw">infixr</span> <span class="dv">5</span> <span class="ot">_</span>âŠ›<span class="ot">_</span> 2^<span class="ot">_</span>Ã—<span class="ot">_</span>âŠ›<span class="ot">_</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true"></a>  2^<span class="ot">_</span>Ã—<span class="ot">_</span>âŠ›<span class="ot">_</span> <span class="ot">:</span> â„• <span class="ot">â†’</span> A <span class="ot">â†’</span> Tree A <span class="ot">â†’</span> Tree A</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true"></a>  2^ n Ã— x âŠ› 2^ suc m Ã— y + ys <span class="ot">=</span> 2^ n Ã— x + âŸ¨ 2^ m Ã— y + ys âŸ©</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true"></a>  2^ n Ã— x âŠ› 2^ zero  Ã— y + âŸ¨âŸ© <span class="ot">=</span> 2^ suc n Ã— <span class="ot">(</span>x * y<span class="ot">)</span> + âŸ¨âŸ©</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true"></a>  2^ n Ã— x âŠ› 2^ zero  Ã— y + âŸ¨ ys âŸ© <span class="ot">=</span> 2^ suc n Ã— <span class="ot">(</span>x * y<span class="ot">)</span> âŠ› ys</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true"></a></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true"></a>  <span class="ot">_</span>âŠ›<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">â†’</span> Tree A <span class="ot">â†’</span> Tree A</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true"></a>  <span class="ot">_</span>âŠ›<span class="ot">_</span> <span class="ot">=</span> 2^ <span class="dv">0</span> Ã—<span class="ot">_</span>âŠ›<span class="ot">_</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true"></a></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true"></a>  âŸ¦<span class="ot">_</span>âŸ§â†“ <span class="ot">:</span> Tree A <span class="ot">â†’</span> A</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true"></a>  âŸ¦ 2^ <span class="ot">_</span> Ã— x + âŸ¨âŸ© âŸ§â†“ <span class="ot">=</span> x</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true"></a>  âŸ¦ 2^ <span class="ot">_</span> Ã— x + âŸ¨ xs âŸ© âŸ§â†“ <span class="ot">=</span> x * âŸ¦ xs âŸ§â†“</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true"></a></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true"></a>  âŸ¦<span class="ot">_</span>âŸ§â†‘ <span class="ot">:</span> A <span class="ot">â†’</span> Tree A</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true"></a>  âŸ¦ x âŸ§â†‘ <span class="ot">=</span> 2^ <span class="dv">0</span> Ã— x + âŸ¨âŸ©</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true"></a></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true"></a>  â¦…<span class="ot">_</span>,<span class="ot">_</span>â¦† <span class="ot">:</span> A <span class="ot">â†’</span> List A <span class="ot">â†’</span> A</span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true"></a>  â¦… x , xs â¦† <span class="ot">=</span> âŸ¦ foldr <span class="ot">_</span>âŠ›<span class="ot">_</span> âŸ¦ x âŸ§â†‘ xs âŸ§â†“</span></code></pre></div>
<p>Alternatively, we can get <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math> cons with the skew array:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="kw">infixr</span> <span class="dv">5</span> <span class="ot">_</span>âŠ›<span class="ot">_</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a><span class="ot">_</span>âŠ›<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">â†’</span> Tree A <span class="ot">â†’</span> Tree A</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>x âŠ› 2^ n Ã— y  + âŸ¨âŸ© <span class="ot">=</span> 2^ <span class="dv">0</span> Ã— x + âŸ¨ 2^ n Ã— y + âŸ¨âŸ© âŸ©</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>x âŠ› 2^ n Ã— yâ‚ + âŸ¨ 2^ <span class="dv">0</span>     Ã— yâ‚‚ + ys âŸ© <span class="ot">=</span> 2^ suc n Ã— <span class="ot">(</span>x * <span class="ot">(</span>yâ‚ * yâ‚‚<span class="ot">))</span> + ys</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>x âŠ› 2^ n Ã— yâ‚ + âŸ¨ 2^ suc m Ã— yâ‚‚ + ys âŸ© <span class="ot">=</span> 2^ <span class="dv">0</span> Ã— x + âŸ¨ 2^ n Ã— yâ‚ + âŸ¨ 2^ m Ã— yâ‚‚ + ys âŸ© âŸ©</span></code></pre></div>
<p>Using this, a proper and efficient merge sort is very straightforward:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="kw">data</span> Total <span class="ot">{</span>a r<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">(_</span>â‰¤<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">â†’</span> A <span class="ot">â†’</span> <span class="dt">Set</span> r<span class="ot">)</span> <span class="ot">(</span>x y <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">(</span>a âŠ” r<span class="ot">)</span> <span class="kw">where</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>  xâ‰¤y <span class="ot">:</span> â¦ƒ <span class="ot">_</span> <span class="ot">:</span> x â‰¤ y â¦„ <span class="ot">â†’</span> Total <span class="ot">_</span>â‰¤<span class="ot">_</span> x y</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>  yâ‰¤x <span class="ot">:</span> â¦ƒ <span class="ot">_</span> <span class="ot">:</span> y â‰¤ x â¦„ <span class="ot">â†’</span> Total <span class="ot">_</span>â‰¤<span class="ot">_</span> x y</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a><span class="kw">module</span> Sorting <span class="ot">{</span>a r<span class="ot">}</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a>               <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a>               <span class="ot">{_</span>â‰¤<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">â†’</span> A <span class="ot">â†’</span> <span class="dt">Set</span> r<span class="ot">}</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a>               <span class="ot">(_</span>â‰¤?<span class="ot">_</span> <span class="ot">:</span> <span class="ot">âˆ€</span> x y <span class="ot">â†’</span> Total <span class="ot">_</span>â‰¤<span class="ot">_</span> x y<span class="ot">)</span> <span class="kw">where</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a>  <span class="kw">data</span> [âˆ™] <span class="ot">:</span> <span class="dt">Set</span> a <span class="kw">where</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true"></a>    âŠ¥   <span class="ot">:</span> [âˆ™]</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true"></a>    [<span class="ot">_</span>] <span class="ot">:</span> A <span class="ot">â†’</span> [âˆ™]</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true"></a></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true"></a>  <span class="kw">data</span> <span class="ot">_</span>â‰¥<span class="ot">_</span> <span class="ot">(</span>x <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">:</span> [âˆ™] <span class="ot">â†’</span> <span class="dt">Set</span> <span class="ot">(</span>a âŠ” r<span class="ot">)</span> <span class="kw">where</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true"></a>    <span class="kw">instance</span> âŒˆ<span class="ot">_</span>âŒ‰ <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>y<span class="ot">}</span> <span class="ot">â†’</span> y â‰¤ x <span class="ot">â†’</span> x â‰¥ [ y ]</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true"></a>    <span class="kw">instance</span> âŒŠâŠ¥âŒ‹ <span class="ot">:</span> x â‰¥ âŠ¥</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true"></a></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true"></a>  <span class="kw">infixr</span> <span class="dv">5</span> <span class="ot">_</span>âˆ·<span class="ot">_</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true"></a>  <span class="kw">data</span> Ordered <span class="ot">(</span>b <span class="ot">:</span> [âˆ™]<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">(</span>a âŠ” r<span class="ot">)</span> <span class="kw">where</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true"></a>    []  <span class="ot">:</span> Ordered b</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true"></a>    <span class="ot">_</span>âˆ·<span class="ot">_</span> <span class="ot">:</span> <span class="ot">âˆ€</span> x <span class="ot">â†’</span> â¦ƒ xâ‰¥b <span class="ot">:</span> x â‰¥ b â¦„ <span class="ot">â†’</span> <span class="ot">(</span>xs <span class="ot">:</span> Ordered [ x ]<span class="ot">)</span> <span class="ot">â†’</span> Ordered b</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true"></a></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true"></a>  <span class="ot">_</span>âˆª<span class="ot">_</span> <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>b<span class="ot">}</span> <span class="ot">â†’</span> Ordered b <span class="ot">â†’</span> Ordered b <span class="ot">â†’</span> Ordered b</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true"></a>  [] âˆª ys <span class="ot">=</span> ys</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true"></a>  <span class="ot">(</span>x âˆ· xs<span class="ot">)</span> âˆª ys <span class="ot">=</span> âŸ… x âˆ¹ xs âˆª ys âŸ†</span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true"></a>    <span class="kw">where</span></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true"></a>    âŸ…<span class="ot">_</span>âˆ¹<span class="ot">_</span>âˆª<span class="ot">_</span>âŸ† <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>b<span class="ot">}</span> <span class="ot">â†’</span> <span class="ot">âˆ€</span> x â¦ƒ <span class="ot">_</span> <span class="ot">:</span> x â‰¥ b â¦„ <span class="ot">â†’</span> Ordered [ x ] <span class="ot">â†’</span> Ordered b <span class="ot">â†’</span> Ordered b</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true"></a>    âŸ…<span class="ot">_</span>âˆª<span class="ot">_</span>âˆ¹<span class="ot">_</span>âŸ† <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>b<span class="ot">}</span> <span class="ot">â†’</span> Ordered b <span class="ot">â†’</span> <span class="ot">âˆ€</span> y â¦ƒ <span class="ot">_</span> <span class="ot">:</span> y â‰¥ b â¦„ <span class="ot">â†’</span> Ordered [ y ] <span class="ot">â†’</span> Ordered b</span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true"></a>    merge <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>b<span class="ot">}</span> x y â¦ƒ <span class="ot">_</span> <span class="ot">:</span> x â‰¥ b â¦„ â¦ƒ <span class="ot">_</span> <span class="ot">:</span> y â‰¥ b â¦„</span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true"></a>          <span class="ot">â†’</span> Total <span class="ot">_</span>â‰¤<span class="ot">_</span> x y</span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true"></a>          <span class="ot">â†’</span> Ordered [ x ]</span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true"></a>          <span class="ot">â†’</span> Ordered [ y ]</span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true"></a>          <span class="ot">â†’</span> Ordered b</span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true"></a></span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true"></a>    âŸ… x âˆ¹ xs âˆª [] âŸ† <span class="ot">=</span> x âˆ· xs</span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true"></a>    âŸ… x âˆ¹ xs âˆª y âˆ· ys âŸ† <span class="ot">=</span> merge x y <span class="ot">(</span>x â‰¤? y<span class="ot">)</span> xs ys</span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true"></a>    âŸ… [] âˆª y âˆ¹ ys âŸ† <span class="ot">=</span> y âˆ· ys</span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true"></a>    âŸ… x âˆ· xs âˆª y âˆ¹ ys âŸ† <span class="ot">=</span> merge x y <span class="ot">(</span>x â‰¤? y<span class="ot">)</span> xs ys</span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true"></a></span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true"></a>    merge x y xâ‰¤y xs ys <span class="ot">=</span> x âˆ· âŸ… xs âˆª y âˆ¹ ys âŸ†</span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true"></a>    merge x y yâ‰¤x xs ys <span class="ot">=</span> y âˆ· âŸ… x âˆ¹ xs âˆª ys âŸ†</span>
<span id="cb6-41"><a href="#cb6-41" aria-hidden="true"></a></span>
<span id="cb6-42"><a href="#cb6-42" aria-hidden="true"></a></span>
<span id="cb6-43"><a href="#cb6-43" aria-hidden="true"></a>  <span class="kw">open</span> TreeFold</span>
<span id="cb6-44"><a href="#cb6-44" aria-hidden="true"></a></span>
<span id="cb6-45"><a href="#cb6-45" aria-hidden="true"></a>  sort <span class="ot">:</span> List A <span class="ot">â†’</span> Ordered âŠ¥</span>
<span id="cb6-46"><a href="#cb6-46" aria-hidden="true"></a>  sort <span class="ot">=</span> â¦… <span class="ot">_</span>âˆª<span class="ot">_</span> , [] â¦† âˆ˜ map <span class="ot">(_</span>âˆ· []<span class="ot">)</span></span></code></pre></div>
<h1 id="validity">Validity</h1>
<p>It would be nice if we could verify these optimizated versions of folds. Luckily, by writing them using <code>foldr</code>, weâ€™ve stumbled into well-trodden ground: the <em>foldr fusion law</em>. It states that if you have some transformation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>, and two binary operators <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>âŠ•</mo><annotation encoding="application/x-tex">\oplus</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>âŠ—</mo><annotation encoding="application/x-tex">\otimes</annotation></semantics></math>, then:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right"><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>âŠ•</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="left"></mtd><mtd columnalign="right"><mo>=</mo><mspace width="0.278em"></mspace></mtd><mtd columnalign="left"><mi>x</mi><mo>âŠ—</mo><mi>f</mi><mi>y</mi></mtd></mtr><mtr><mtd columnalign="right"><mo>âŸ¹</mo><mi>f</mi><mo>âˆ˜</mo><mtext mathvariant="normal">foldr</mtext><mo>âŠ•</mo><mi>e</mi></mtd><mtd columnalign="left"></mtd><mtd columnalign="right"><mo>=</mo><mspace width="0.278em"></mspace></mtd><mtd columnalign="left"><mtext mathvariant="normal">foldr</mtext><mo>âŠ—</mo><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mi>e</mi><mo stretchy="false" form="postfix">)</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align}
   f (x \oplus y)                         &amp;&amp;=\;&amp; x \otimes f y \\
   \implies f \circ \text{foldr} \oplus e &amp;&amp;=\;&amp; \text{foldr} \otimes (f e)
\end{align}</annotation></semantics></math></p>
<p>This fits right in with the function we used above. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> is <code>âŸ¦_âŸ§â†“</code>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>âŠ•</mo><annotation encoding="application/x-tex">\oplus</annotation></semantics></math> is <code>_âŠ›_</code>, and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>âŠ—</mo><annotation encoding="application/x-tex">\otimes</annotation></semantics></math> is whatever combining function was passed in. Letâ€™s prove the foldr fusion law, then, before we go any further.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="kw">module</span> Proofs</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>  <span class="ot">{</span>a r<span class="ot">}</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>  <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>  <span class="ot">{</span>R <span class="ot">:</span> Rel A r<span class="ot">}</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a>  <span class="kw">infix</span> <span class="dv">4</span> <span class="ot">_</span>â‰ˆ<span class="ot">_</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a>  <span class="ot">_</span>â‰ˆ<span class="ot">_</span> <span class="ot">=</span> R</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true"></a>  <span class="kw">open</span> <span class="kw">import</span> Algebra<span class="ot">.</span>FunctionProperties <span class="ot">_</span>â‰ˆ<span class="ot">_</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true"></a></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true"></a>  foldr-universal <span class="ot">:</span> Transitive <span class="ot">_</span>â‰ˆ<span class="ot">_</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true"></a>                  <span class="ot">â†’</span> <span class="ot">âˆ€</span> <span class="ot">{</span>b<span class="ot">}</span> <span class="ot">{</span>B <span class="ot">:</span> <span class="dt">Set</span> b<span class="ot">}</span> <span class="ot">(</span>h <span class="ot">:</span> List B <span class="ot">â†’</span> A<span class="ot">)</span> f e</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true"></a>                  <span class="ot">â†’</span> âˆ€[ f âŠ¢ Congruentâ‚ ]</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true"></a>                  <span class="ot">â†’</span> <span class="ot">(</span>h [] â‰ˆ e<span class="ot">)</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true"></a>                  <span class="ot">â†’</span> <span class="ot">(âˆ€</span> x xs <span class="ot">â†’</span> h <span class="ot">(</span>x âˆ· xs<span class="ot">)</span> â‰ˆ f x <span class="ot">(</span>h xs<span class="ot">))</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true"></a>                  <span class="ot">â†’</span> <span class="ot">âˆ€</span> xs <span class="ot">â†’</span> h xs â‰ˆ foldr f e xs</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true"></a>  foldr-universal <span class="ot">_</span>â—‹<span class="ot">_</span> h f e fâŸ¨<span class="ot">_</span>âŸ© â‡’[] â‡’<span class="ot">_</span>âˆ·<span class="ot">_</span> [] <span class="ot">=</span> â‡’[]</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true"></a>  foldr-universal <span class="ot">_</span>â—‹<span class="ot">_</span> h f e fâŸ¨<span class="ot">_</span>âŸ© â‡’[] â‡’<span class="ot">_</span>âˆ·<span class="ot">_</span> <span class="ot">(</span>x âˆ· xs<span class="ot">)</span> <span class="ot">=</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true"></a>    <span class="ot">(</span>â‡’ x âˆ· xs<span class="ot">)</span> â—‹ fâŸ¨ foldr-universal <span class="ot">_</span>â—‹<span class="ot">_</span> h f e fâŸ¨<span class="ot">_</span>âŸ© â‡’[] â‡’<span class="ot">_</span>âˆ·<span class="ot">_</span> xs âŸ©</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true"></a></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true"></a>  foldr-fusion <span class="ot">:</span> Transitive <span class="ot">_</span>â‰ˆ<span class="ot">_</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true"></a>               <span class="ot">â†’</span> Reflexive <span class="ot">_</span>â‰ˆ<span class="ot">_</span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true"></a>               <span class="ot">â†’</span> <span class="ot">âˆ€</span> <span class="ot">{</span>b c<span class="ot">}</span> <span class="ot">{</span>B <span class="ot">:</span> <span class="dt">Set</span> b<span class="ot">}</span> <span class="ot">{</span>C <span class="ot">:</span> <span class="dt">Set</span> c<span class="ot">}</span> <span class="ot">(</span>f <span class="ot">:</span> C <span class="ot">â†’</span> A<span class="ot">)</span> <span class="ot">{_</span>âŠ•<span class="ot">_</span> <span class="ot">:</span> B <span class="ot">â†’</span> C <span class="ot">â†’</span> C<span class="ot">}</span> <span class="ot">{_</span>âŠ—<span class="ot">_</span> <span class="ot">:</span> B <span class="ot">â†’</span> A <span class="ot">â†’</span> A<span class="ot">}</span> e</span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true"></a>               <span class="ot">â†’</span> âˆ€[ <span class="ot">_</span>âŠ—<span class="ot">_</span> âŠ¢ Congruentâ‚ ]</span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true"></a>               <span class="ot">â†’</span> <span class="ot">(âˆ€</span> x y <span class="ot">â†’</span> f <span class="ot">(</span>x âŠ• y<span class="ot">)</span> â‰ˆ x âŠ— f y<span class="ot">)</span></span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true"></a>               <span class="ot">â†’</span> <span class="ot">âˆ€</span> xs <span class="ot">â†’</span> f <span class="ot">(</span>foldr <span class="ot">_</span>âŠ•<span class="ot">_</span> e xs<span class="ot">)</span> â‰ˆ foldr <span class="ot">_</span>âŠ—<span class="ot">_</span> <span class="ot">(</span>f e<span class="ot">)</span> xs</span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true"></a>  foldr-fusion <span class="ot">_</span>â—‹<span class="ot">_</span> âˆ h <span class="ot">{</span>f<span class="ot">}</span> <span class="ot">{</span>g<span class="ot">}</span> e gâŸ¨<span class="ot">_</span>âŸ© fuse <span class="ot">=</span></span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true"></a>    foldr-universal <span class="ot">_</span>â—‹<span class="ot">_</span> <span class="ot">(</span>h âˆ˜ foldr f e<span class="ot">)</span> g <span class="ot">(</span>h e<span class="ot">)</span> gâŸ¨<span class="ot">_</span>âŸ© âˆ <span class="ot">(Î»</span> x xs <span class="ot">â†’</span> fuse x <span class="ot">(</span>foldr f e xs<span class="ot">))</span></span></code></pre></div>
<p>Weâ€™re not using the proofs in Agdaâ€™s standard library because these are tied to propositional equality. In other words, instead of using an abstract binary relation, they prove things over <em>actual</em> equality. Thatâ€™s all well and good, but as you can see above, we donâ€™t need propositional equality: we donâ€™t even need the relation to be an equivalence, we just need transitivity and reflexivity.</p>
<p>After that, we can state precisely what correspondence the tree fold has, and under what conditions it does the same things as a fold:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="kw">module</span> <span class="ot">_</span> <span class="ot">{_</span>*<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">â†’</span> A <span class="ot">â†’</span> A<span class="ot">}</span> <span class="kw">where</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>  <span class="kw">open</span> TreeFold <span class="ot">_</span>*<span class="ot">_</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>  treeFoldHom <span class="ot">:</span> Transitive <span class="ot">_</span>â‰ˆ<span class="ot">_</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>              <span class="ot">â†’</span> Reflexive <span class="ot">_</span>â‰ˆ<span class="ot">_</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a>              <span class="ot">â†’</span> Associative <span class="ot">_</span>*<span class="ot">_</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a>              <span class="ot">â†’</span> RightCongruent <span class="ot">_</span>*<span class="ot">_</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a>              <span class="ot">â†’</span> <span class="ot">âˆ€</span> x xs</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a>              <span class="ot">â†’</span> â¦… x , xs â¦† â‰ˆ foldr <span class="ot">_</span>*<span class="ot">_</span> x xs</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true"></a>  treeFoldHom <span class="ot">_</span>â—‹<span class="ot">_</span> âˆ assoc *âŸ¨<span class="ot">_</span>âŸ© b <span class="ot">=</span> foldr-fusion <span class="ot">_</span>â—‹<span class="ot">_</span> âˆ âŸ¦<span class="ot">_</span>âŸ§â†“ âŸ¦ b âŸ§â†‘ *âŸ¨<span class="ot">_</span>âŸ© <span class="ot">(</span>âŠ›-hom zero<span class="ot">)</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true"></a>    <span class="kw">where</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true"></a>    âŠ›-hom <span class="ot">:</span> <span class="ot">âˆ€</span> n x xs <span class="ot">â†’</span> âŸ¦ 2^ n Ã— x âŠ› xs âŸ§â†“ â‰ˆ x * âŸ¦ xs âŸ§â†“</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true"></a>    âŠ›-hom n x <span class="ot">(</span>2^ suc m Ã— y + âŸ¨âŸ©    <span class="ot">)</span> <span class="ot">=</span> âˆ</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true"></a>    âŠ›-hom n x <span class="ot">(</span>2^ suc m Ã— y + âŸ¨ ys âŸ©<span class="ot">)</span> <span class="ot">=</span> âˆ</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true"></a>    âŠ›-hom n x <span class="ot">(</span>2^ zero  Ã— y + âŸ¨âŸ©    <span class="ot">)</span> <span class="ot">=</span> âˆ</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true"></a>    âŠ›-hom n x <span class="ot">(</span>2^ zero  Ã— y + âŸ¨ ys âŸ©<span class="ot">)</span> <span class="ot">=</span> âŠ›-hom <span class="ot">(</span>suc n<span class="ot">)</span> <span class="ot">(</span>x * y<span class="ot">)</span> ys â—‹ assoc x y âŸ¦ ys âŸ§â†“</span></code></pre></div>
<h1 id="implicit-data-structures">â€œImplicitâ€ Data Structures</h1>
<p>Consider the following implementation of the tree above in Haskell:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">Tree</span> a <span class="ot">=</span> [(<span class="dt">Int</span>,a)]</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a><span class="ot">cons ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a>cons (<span class="op">*</span>) <span class="ot">=</span> cons' <span class="dv">0</span> </span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a>    cons' n x [] <span class="ot">=</span> [(n,x)]</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a>    cons' n x ((<span class="dv">0</span>,y)<span class="op">:</span>ys) <span class="ot">=</span> cons' (n<span class="op">+</span><span class="dv">1</span>) (x <span class="op">*</span> y) ys</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true"></a>    cons' n x ((m,y)<span class="op">:</span>ys) <span class="ot">=</span> (n,x) <span class="op">:</span> (m<span class="op">-</span><span class="dv">1</span>,y) <span class="op">:</span> ys</span></code></pre></div>
<p>The <code>cons</code> function â€œincrementsâ€ that list as if it were the bits of a binary number. Now, consider using the <code>merge</code> function from above, in a pattern like this:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a>f <span class="ot">=</span> <span class="fu">foldr</span> (cons merge <span class="op">.</span> <span class="fu">pure</span>) []</span></code></pre></div>
<p>What does <code>f</code> build? A list of lists, right?</p>
<p>Kind of. Thatâ€™s whatâ€™s built in terms of the observable, but whatâ€™s actually stored in memory us a bunch of thunks. The shape of <em>those</em> is what Iâ€™m interested in. We can try and see what they look like by using a data structure that doesnâ€™t force on merge:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Tree</span> a <span class="ot">=</span> <span class="dt">Leaf</span> a <span class="op">|</span> <span class="dt">Tree</span> a <span class="op">:*:</span> <span class="dt">Tree</span> a</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a>f <span class="ot">=</span> <span class="fu">foldr</span> (cons (<span class="op">:*:</span>) <span class="op">.</span> <span class="dt">Leaf</span>) []</span></code></pre></div>
<p>Using a handy tree-drawing function, we can see what <code>f [1..13]</code> looks like:</p>
<pre><code>[(0,*),(1,*),(0,*)]
    â””1    â”‚ â”Œ2  â”‚  â”Œ6
          â”‚â”Œâ”¤   â”‚ â”Œâ”¤
          â”‚â”‚â””3  â”‚ â”‚â””7
          â””â”¤    â”‚â”Œâ”¤
           â”‚â”Œ4  â”‚â”‚â”‚â”Œ8
           â””â”¤   â”‚â”‚â””â”¤
            â””5  â”‚â”‚ â””9
                â””â”¤
                 â”‚ â”Œ10
                 â”‚â”Œâ”¤
                 â”‚â”‚â””11
                 â””â”¤
                  â”‚â”Œ12
                  â””â”¤
                   â””13</code></pre>
<p>Itâ€™s a binomial heap! Itâ€™s a list of trees, each one contains <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mi>n</mi></msup><annotation encoding="application/x-tex">2^n</annotation></semantics></math> elements. But theyâ€™re not in heap order, you say? Well, as a matter of fact, they <em>are</em>. It just hasnâ€™t been evaluated yet. Once we forceâ€”sayâ€”the first element, the rest will shuffle themselves into a tree of thunks.</p>
<p>This illustrates a pretty interesting similarity between binomial heaps and merge sort. Performance-wise, though, thereâ€™s another interesting property: the thunks <em>stay thunked</em>. In other words, if we do a merge sort via:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="fu">sort</span> <span class="ot">=</span> <span class="fu">foldr</span> (merge <span class="op">.</span> <span class="fu">snd</span>) [] <span class="op">.</span> <span class="fu">foldr</span> (cons merge <span class="op">.</span> <span class="fu">pure</span>) []</span></code></pre></div>
<p>We could instead freeze the fold, and look at it at every point:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a>sortPrefixes <span class="ot">=</span> <span class="fu">map</span> (<span class="fu">foldr</span> (merge <span class="op">.</span> <span class="fu">snd</span>) []) <span class="op">.</span> <span class="fu">scanl</span> (<span class="fu">flip</span> (cons merge <span class="op">.</span> <span class="fu">pure</span>)) []</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a><span class="op">&gt;&gt;&gt;</span> [[],[<span class="dv">1</span>],[<span class="dv">1</span>,<span class="dv">4</span>],[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">4</span>],[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>],[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>]]</span></code></pre></div>
<p>And <code>sortPrefixes</code> is only <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n^2)</annotation></semantics></math> (rather than <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n^2 \log n)</annotation></semantics></math>). I confess I donâ€™t know of a use for sorted prefixes, but it should illustrate the general idea: we get a pretty decent batching of operations, with the ability to freeze at any point in time. The other nice property (which I mentioned in the last post) is that any of the tree folds are extremely parallel.</p>
<h1 id="random-shuffles">Random Shuffles</h1>
<p><a href="http://okmij.org/ftp/Haskell/AlgorithmsH.html#perfect-shuffle">Thereâ€™s a great article on shuffling in Haskell</a> which provides an <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n \log n)</annotation></semantics></math> implementation of a perfect random shuffle. Unfortunately, the <a href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle">Fisher-Yates shuffle</a> isnâ€™t applicable in a pure functional setting, so you have to be a little cleverer.</p>
<p>The first implementation most people jump to (certainly the one I thought of) is to assign everything in the sequence a random number, and then sort according to that number. Perhaps surprisingly, this <em>isnâ€™t</em> perfectly random! Itâ€™s a little weird, but the example in the article explains it well: basically, for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> elements, your random numbers will have <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>n</mi><mi>n</mi></msup><annotation encoding="application/x-tex">n^n</annotation></semantics></math> possible values, but the output of the sort will have <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>!</mi></mrow><annotation encoding="application/x-tex">n!</annotation></semantics></math> possible values. Since they donâ€™t divide into each other evenly, youâ€™re going to have some extra weight on some permutations, and less on others.</p>
<p>Instead, we can generate a random <a href="https://en.wikipedia.org/wiki/Factorial_number_system"><em>factoradic</em></a> number. A factoradic number is one where the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>th digit is in base <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>. Because of this, a factoradic number with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> digits has <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>!</mi></mrow><annotation encoding="application/x-tex">n!</annotation></semantics></math> possible values: exactly what we want.</p>
<p>In the article, the digits of the number are used to pop values from a binary tree. Because the last digit will have <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> possible values, and the second last <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>âˆ’</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math>, and so on, you can keep popping without hitting an empty tree.</p>
<p>This has the correct time complexityâ€”<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n \log n)</annotation></semantics></math>â€”but thereâ€™s a lot of overhead. Building the tree, then indexing into it, the rebuilding after each pop, etc.</p>
<p>Weâ€™d <em>like</em> to just sort the list, according to the indices. The problem is that the indices are relative: if you want to <code>cons</code> something onto the list, you have to increment the rest of the indices, as theyâ€™ve all shifted right by one.</p>
<p>What weâ€™ll do instead is use the indices as <em>gaps</em>. Our merge function looks like the following:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a>merge [] ys <span class="ot">=</span> ys</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a>merge xs [] <span class="ot">=</span> xs</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a>merge ((x,i)<span class="op">:</span>xs) ((y,j)<span class="op">:</span>ys)</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a>  <span class="op">|</span> i <span class="op">&lt;=</span> j    <span class="ot">=</span> (x,i) <span class="op">:</span> merge xs ((y,j<span class="op">-</span>i)<span class="op">:</span>ys)</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> (y,j) <span class="op">:</span> merge ((x,i<span class="op">-</span>j<span class="op">-</span><span class="dv">1</span>)<span class="op">:</span>xs) ys</span></code></pre></div>
<p>With that, and the same <code>cons</code> as above, we get a very simple random shuffle algorithm:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a>shuffle xs <span class="ot">=</span> <span class="fu">map</span> <span class="fu">fst</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a>           <span class="op">.</span> <span class="fu">foldr</span> (merge <span class="op">.</span> <span class="fu">snd</span>) []</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a>           <span class="op">.</span> <span class="fu">foldr</span> f (<span class="fu">const</span> []) xs</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true"></a>    f x xs (i<span class="op">:</span>is) <span class="ot">=</span> cons merge [(x,i)] (xs is)</span></code></pre></div>
<p>The other interesting thing about this algorithm is that it can use Peano numbers with taking too much of a performance hit:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a>merge <span class="op">:</span> <span class="ot">âˆ€</span> {a} {<span class="dt">A</span> <span class="op">:</span> <span class="dt">Set</span> a} <span class="ot">â†’</span> <span class="dt">List</span> (<span class="dt">A</span> Ã— â„•) <span class="ot">â†’</span> <span class="dt">List</span> (<span class="dt">A</span> Ã— â„•) <span class="ot">â†’</span> <span class="dt">List</span> (<span class="dt">A</span> Ã— â„•)</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a>merge xs [] <span class="ot">=</span> xs</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a>merge {<span class="dt">A</span> <span class="ot">=</span> <span class="dt">A</span>} xs ((y , j) <span class="ot">âˆ·</span> ys) <span class="ot">=</span> go<span class="op">-</span>r xs y j ys</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a>  go<span class="op">-</span>l <span class="op">:</span> <span class="dt">A</span> <span class="ot">â†’</span> â„• <span class="ot">â†’</span> <span class="dt">List</span> (<span class="dt">A</span> Ã— â„•) <span class="ot">â†’</span> <span class="dt">List</span> (<span class="dt">A</span> Ã— â„•) <span class="ot">â†’</span> <span class="dt">List</span> (<span class="dt">A</span> Ã— â„•)</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true"></a>  go<span class="op">-</span>r <span class="op">:</span> <span class="dt">List</span> (<span class="dt">A</span> Ã— â„•) <span class="ot">â†’</span> <span class="dt">A</span> <span class="ot">â†’</span> â„• <span class="ot">â†’</span> <span class="dt">List</span> (<span class="dt">A</span> Ã— â„•) <span class="ot">â†’</span> <span class="dt">List</span> (<span class="dt">A</span> Ã— â„•)</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true"></a>  go <span class="op">:</span> â„• <span class="ot">â†’</span> â„• <span class="ot">â†’</span> <span class="dt">A</span> <span class="ot">â†’</span> â„• <span class="ot">â†’</span> <span class="dt">List</span> (<span class="dt">A</span> Ã— â„•) <span class="ot">â†’</span> <span class="dt">A</span> <span class="ot">â†’</span> â„• <span class="ot">â†’</span> <span class="dt">List</span> (<span class="dt">A</span> Ã— â„•) <span class="ot">â†’</span> <span class="dt">List</span> (<span class="dt">A</span> Ã— â„•)</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true"></a></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true"></a>  go i     zero   x iâ€² xs y jâ€² ys <span class="ot">=</span> (y , jâ€²) <span class="ot">âˆ·</span> go<span class="op">-</span>l x i xs ys</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true"></a>  go zero (suc j) x iâ€² xs y jâ€² ys <span class="ot">=</span> (x , iâ€²) <span class="ot">âˆ·</span> go<span class="op">-</span>r xs y j ys</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true"></a>  go (suc i) (suc j) <span class="ot">=</span> go i j</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true"></a></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true"></a>  go<span class="op">-</span>l x i xs [] <span class="ot">=</span> (x , i) <span class="ot">âˆ·</span> xs</span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true"></a>  go<span class="op">-</span>l x i xs ((y , j) <span class="ot">âˆ·</span> ys) <span class="ot">=</span> go i j x i xs y j ys</span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true"></a></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true"></a>  go<span class="op">-</span>r [] y j ys <span class="ot">=</span> (y , j) <span class="ot">âˆ·</span> ys</span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true"></a>  go<span class="op">-</span>r ((x , i) <span class="ot">âˆ·</span> xs) y j ys <span class="ot">=</span> go i j x i xs y j ys</span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true"></a></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true"></a>shuffle <span class="op">:</span> <span class="ot">âˆ€</span> {a} {<span class="dt">A</span> <span class="op">:</span> <span class="dt">Set</span> a} <span class="ot">â†’</span> <span class="dt">List</span> <span class="dt">A</span> <span class="ot">â†’</span> <span class="dt">List</span> â„• <span class="ot">â†’</span> <span class="dt">List</span> <span class="dt">A</span></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true"></a>shuffle {a} {<span class="dt">A</span>} xs i <span class="ot">=</span> <span class="fu">map</span> projâ‚ (â¦… [] , <span class="fu">zip</span><span class="op">-</span>inds xs i â¦†)</span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true"></a>  open <span class="dt">TreeFold</span> {a} {<span class="dt">List</span> (<span class="dt">A</span> Ã— â„•)} merge</span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true"></a></span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true"></a>  <span class="fu">zip</span><span class="op">-</span>inds <span class="op">:</span> <span class="dt">List</span> <span class="dt">A</span> <span class="ot">â†’</span> <span class="dt">List</span> â„• <span class="ot">â†’</span> <span class="dt">List</span> (<span class="dt">List</span> (<span class="dt">A</span> Ã— â„•))</span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true"></a>  <span class="fu">zip</span><span class="op">-</span>inds [] inds <span class="ot">=</span> []</span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true"></a>  <span class="fu">zip</span><span class="op">-</span>inds (x <span class="ot">âˆ·</span> xs) [] <span class="ot">=</span> ((x , <span class="dv">0</span>) <span class="ot">âˆ·</span> []) <span class="ot">âˆ·</span> <span class="fu">zip</span><span class="op">-</span>inds xs []</span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true"></a>  <span class="fu">zip</span><span class="op">-</span>inds (x <span class="ot">âˆ·</span> xs) (i <span class="ot">âˆ·</span> inds) <span class="ot">=</span> ((x , i) <span class="ot">âˆ·</span> []) <span class="ot">âˆ·</span> <span class="fu">zip</span><span class="op">-</span>inds xs inds</span></code></pre></div>
<p>I donâ€™t know exactly what the complexity of this is, but I <em>think</em> it should be better than the usual approach of popping from a vector.</p>
<h1 id="future-stuff">Future Stuff</h1>
<p>This is just a collection of random thoughts for now, but I intend to work on using these folds to see if there are any other algorithms they can be useful for. In particular, I think I can write a version of Data.List.permutations which benefits from sharing. And Iâ€™m interested in using the implicit binomial heap for some search problems.</p>

        </div>
    </body>
</html>
