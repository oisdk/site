<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Balancing Scans - Donnacha Ois√≠n Kidney</title>
        <style>body{color:black;font-family:Garamond,Times New Roman,serif;font-size:14px;margin:0px auto 0px auto;padding-left:5px;padding-right:5px;max-width:600px}math{font-size:13px}img{max-width:600px}summary{outline:0}div#header{border-bottom:3px double black;margin-bottom:30px;padding:12px 0px 12px 0px}div#logo a{color:black;float:left;font-size:20px;text-decoration:none}div#header #navigation{text-align:right}div#header #navigation a{color:black;font-family:Garamond,Times New Roman,Serif;font-size:18px;margin-left:10px;text-decoration:none;text-transform:uppercase}div#footer{font-family:Garamond,Times New Roman,Serif;border-top:solid 2px black;color:#555;font-size:12px;margin-top:30px;padding:12px 0px 12px 0px;text-align:right}h1{font-family:Garamond,Times New Roman,Serif;font-size:22px;font-weight:normal}h2{font-family:Garamond,Times New Roman,Serif;font-size:20px;font-weight:normal}div.info{color:#555;font-size:15px;font-style:italic}span.quiet{color:#828282;font-style:italic}a{color:black;word-wrap:break-word}ul.post-list{margin-left:0px;padding-left:0px;list-style-type:none}.hidden_source{display:none}ol.serieslist{counter-reset:item;list-style-type:none;padding-left:20}ol li.serieslist:before{content:'Part ' counter(item,decimal) ':';counter-increment:item}table.sourceCode,tr.sourceCode,td.lineNumbers,td.sourceCode,table.sourceCode pre{margin:0;padding:0;border:0;vertical-align:baseline;border:none}td.lineNumbers{border-right:1px solid #AAAAAA;text-align:right;color:#AAAAAA;padding-right:5px;padding-left:5px}td.sourceCode{padding-left:5px}.sourceCode,code,pre,.Agda{font-size:11px;font-family:menlo,monospace}.sourceCode span.kw{color:#262C6A}.sourceCode span.dt{color:#476A97}.sourceCode span.dv{color:#262C6A}.sourceCode span.bn{color:#262C6A}.sourceCode span.fl{color:#262C6A}.sourceCode span.ch{color:#262C6A}.sourceCode span.st{color:#702C51}.sourceCode span.co{color:#435138}.sourceCode span.ot{color:#262C6A}.sourceCode span.al{color:red}.sourceCode span.fu{color:#000000}.sourceCode span.re{color:#000000}.sourceCode span.er{color:red}li{margin-bottom:2px}li:last-child{margin-bottom:0px}.Agda .Comment{color:#B22222}.Agda .Background{}.Agda .Markup{color:#000000}.Agda .Keyword{color:#CD6600}.Agda .String{color:#B22222}.Agda .Number{color:#A020F0}.Agda .Symbol{color:#404040}.Agda .PrimitiveType{color:#0000CD}.Agda .Pragma{color:black}.Agda .Operator{}.Agda .Bound{color:black}.Agda .Generalizable{color:black}.Agda .InductiveConstructor{color:#008B00}.Agda .CoinductiveConstructor{color:#8B7500}.Agda .Datatype{color:#0000CD}.Agda .Field{color:#EE1289}.Agda .Function{color:#0000CD}.Agda .Module{color:#A020F0}.Agda .Postulate{color:#0000CD}.Agda .Primitive{color:#0000CD}.Agda .Record{color:#0000CD}.Agda .DottedPattern{}.Agda .UnsolvedMeta{color:black;background:yellow}.Agda .UnsolvedConstraint{color:black;background:yellow}.Agda .TerminationProblem{color:black;background:#FFA07A}.Agda .IncompletePattern{color:black;background:#F5DEB3}.Agda .Error{color:red;text-decoration:underline}.Agda .TypeChecks{color:black;background:#ADD8E6}.Agda a{text-decoration:none}.Agda a[href]:hover{background-color:#B4EEB4}.sourceCode{overflow-x:auto}</style>
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Donnacha Ois√≠n Kidney</a>
            </div>
            <div id="navigation">
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../rss.xml">Feed</a>
            </div>
        </div>

        <div id="content">
            <h2>Balancing Scans</h2>

            <div class="info">
    Posted on December 21, 2018
</div>
<div class="info">
    
        Part 2 of a <a href="../series/Balanced%20Folds.html">3-part series on Balanced Folds</a>
    
</div>
<div class="info">
    
        Tags: <a title="All pages tagged 'Haskell'." href="../tags/Haskell.html">Haskell</a>, <a title="All pages tagged 'Agda'." href="../tags/Agda.html">Agda</a>
    
</div>

<p><a href="2017-10-30-balancing-folds.html">Previously</a> I tried to figure out a way to fold lists in a more balanced way. Usually, when folding lists, you‚Äôve got two choices for your folds, both of which are extremely unbalanced in one direction or another. Jon Fairbairn <a href="https://www.mail-archive.com/haskell@haskell.org/msg01788.html">wrote</a> a more balanced version, which looked something like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="ot">treeFold ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> a</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>treeFold f <span class="ot">=</span> go</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>    go x [] <span class="ot">=</span> x</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>    go a (b<span class="op">:</span>l) <span class="ot">=</span> go (f a b) (pairMap l)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>    pairMap (x<span class="op">:</span>y<span class="op">:</span>rest) <span class="ot">=</span> f x y <span class="op">:</span> pairMap rest</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>    pairMap xs <span class="ot">=</span> xs</span></code></pre></div>
<h1 id="magical-speedups">Magical Speedups</h1>
<p>The fold above is kind of magical: for a huge class of algorithms, it kind of ‚Äúautomatically‚Äù improves some factor of theirs from <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n)</annotation></semantics></math> to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math>. For instance: to sum a list of floats, <code class="sourceCode haskell">foldl' (<span class="op">+</span>) <span class="dv">0</span></code> will have an error growth of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n)</annotation></semantics></math>; <code>treeFold (+) 0</code>, though, has an error rate of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math>. Similarly, using the following function to merge two sorted lists:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="ot">merge ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>merge [] ys <span class="ot">=</span> ys</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>merge (x<span class="op">:</span>xs) ys <span class="ot">=</span> go x xs ys</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>    go x xs [] <span class="ot">=</span> x <span class="op">:</span> xs</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>    go x xs (y<span class="op">:</span>ys)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>      <span class="op">|</span> x <span class="op">&lt;=</span> y    <span class="ot">=</span> x <span class="op">:</span> go y ys xs</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a>      <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> y <span class="op">:</span> go x xs ys</span></code></pre></div>
<p>We get either insertion sort (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n^2)</annotation></semantics></math>) or merge sort (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n \log n)</annotation></semantics></math>) just depending on which fold you use.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="fu">foldr</span>    merge [] <span class="op">.</span> <span class="fu">map</span> <span class="fu">pure</span> <span class="co">-- n^2</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>treeFold merge [] <span class="op">.</span> <span class="fu">map</span> <span class="fu">pure</span> <span class="co">-- n log(n)</span></span></code></pre></div>
<p>I‚Äôll give some more examples later, but effectively it gives us a better ‚Äúdivide‚Äù step in many divide and conquer algorithms.</p>
<h1 id="termination">Termination</h1>
<p>As it was such a useful fold, and so integral to many tricky algorithms, I really wanted to have it available in Agda. Unfortunately, though, the functions (as defined above) aren‚Äôt structurally terminating, and there doesn‚Äôt <em>look</em> like there‚Äôs an obvious way to make it so. I tried to make well founded recursion work, but the proofs were ugly and slow.</p>
<p>However, we can use some structures from a <a href="2018-11-20-fast-verified-structures.html">previous post</a>: the nested binary sequence, for instance. It has some extra nice properties: instead of nesting the types, we can just apply the combining function.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">mutual</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>  <span class="kw">data</span> Tree <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> a <span class="kw">where</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>    2^<span class="ot">_</span>√ó<span class="ot">_</span>+<span class="ot">_</span> <span class="ot">:</span> ‚Ñï <span class="ot">‚Üí</span> A <span class="ot">‚Üí</span> Node A <span class="ot">‚Üí</span> Tree A</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>  <span class="kw">data</span> Node <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> a <span class="kw">where</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>    ‚ü®‚ü©  <span class="ot">:</span> Node A</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a>    ‚ü®<span class="ot">_</span>‚ü© <span class="ot">:</span> Tree A <span class="ot">‚Üí</span> Node A</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a><span class="kw">module</span> TreeFold <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">(_</span>*<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">‚Üí</span> A <span class="ot">‚Üí</span> A<span class="ot">)</span> <span class="kw">where</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a>  <span class="kw">infixr</span> <span class="dv">5</span> <span class="ot">_</span>‚äõ<span class="ot">_</span> 2^<span class="ot">_</span>√ó<span class="ot">_</span>‚äõ<span class="ot">_</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true"></a>  2^<span class="ot">_</span>√ó<span class="ot">_</span>‚äõ<span class="ot">_</span> <span class="ot">:</span> ‚Ñï <span class="ot">‚Üí</span> A <span class="ot">‚Üí</span> Tree A <span class="ot">‚Üí</span> Tree A</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true"></a>  2^ n √ó x ‚äõ 2^ suc m √ó y + ys <span class="ot">=</span> 2^ n √ó x + ‚ü® 2^ m √ó y + ys ‚ü©</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true"></a>  2^ n √ó x ‚äõ 2^ zero  √ó y + ‚ü®‚ü© <span class="ot">=</span> 2^ suc n √ó <span class="ot">(</span>x * y<span class="ot">)</span> + ‚ü®‚ü©</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true"></a>  2^ n √ó x ‚äõ 2^ zero  √ó y + ‚ü® ys ‚ü© <span class="ot">=</span> 2^ suc n √ó <span class="ot">(</span>x * y<span class="ot">)</span> ‚äõ ys</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true"></a></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true"></a>  <span class="ot">_</span>‚äõ<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">‚Üí</span> Tree A <span class="ot">‚Üí</span> Tree A</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true"></a>  <span class="ot">_</span>‚äõ<span class="ot">_</span> <span class="ot">=</span> 2^ <span class="dv">0</span> √ó<span class="ot">_</span>‚äõ<span class="ot">_</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true"></a></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true"></a>  ‚ü¶<span class="ot">_</span>‚üß‚Üì <span class="ot">:</span> Tree A <span class="ot">‚Üí</span> A</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true"></a>  ‚ü¶ 2^ <span class="ot">_</span> √ó x + ‚ü®‚ü© ‚üß‚Üì <span class="ot">=</span> x</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true"></a>  ‚ü¶ 2^ <span class="ot">_</span> √ó x + ‚ü® xs ‚ü© ‚üß‚Üì <span class="ot">=</span> x * ‚ü¶ xs ‚üß‚Üì</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true"></a></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true"></a>  ‚ü¶<span class="ot">_</span>‚üß‚Üë <span class="ot">:</span> A <span class="ot">‚Üí</span> Tree A</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true"></a>  ‚ü¶ x ‚üß‚Üë <span class="ot">=</span> 2^ <span class="dv">0</span> √ó x + ‚ü®‚ü©</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true"></a></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true"></a>  ‚¶Ö<span class="ot">_</span>,<span class="ot">_</span>‚¶Ü <span class="ot">:</span> A <span class="ot">‚Üí</span> List A <span class="ot">‚Üí</span> A</span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true"></a>  ‚¶Ö x , xs ‚¶Ü <span class="ot">=</span> ‚ü¶ foldr <span class="ot">_</span>‚äõ<span class="ot">_</span> ‚ü¶ x ‚üß‚Üë xs ‚üß‚Üì</span></code></pre></div>
<p>Alternatively, we can get <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math> cons with the skew array:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="kw">infixr</span> <span class="dv">5</span> <span class="ot">_</span>‚äõ<span class="ot">_</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a><span class="ot">_</span>‚äõ<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">‚Üí</span> Tree A <span class="ot">‚Üí</span> Tree A</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>x ‚äõ 2^ n √ó y  + ‚ü®‚ü© <span class="ot">=</span> 2^ <span class="dv">0</span> √ó x + ‚ü® 2^ n √ó y + ‚ü®‚ü© ‚ü©</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>x ‚äõ 2^ n √ó y‚ÇÅ + ‚ü® 2^ <span class="dv">0</span>     √ó y‚ÇÇ + ys ‚ü© <span class="ot">=</span> 2^ suc n √ó <span class="ot">(</span>x * <span class="ot">(</span>y‚ÇÅ * y‚ÇÇ<span class="ot">))</span> + ys</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>x ‚äõ 2^ n √ó y‚ÇÅ + ‚ü® 2^ suc m √ó y‚ÇÇ + ys ‚ü© <span class="ot">=</span> 2^ <span class="dv">0</span> √ó x + ‚ü® 2^ n √ó y‚ÇÅ + ‚ü® 2^ m √ó y‚ÇÇ + ys ‚ü© ‚ü©</span></code></pre></div>
<p>Using this, a proper and efficient merge sort is very straightforward:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="kw">data</span> Total <span class="ot">{</span>a r<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">(_</span>‚â§<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">‚Üí</span> A <span class="ot">‚Üí</span> <span class="dt">Set</span> r<span class="ot">)</span> <span class="ot">(</span>x y <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">(</span>a ‚äî r<span class="ot">)</span> <span class="kw">where</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>  x‚â§y <span class="ot">:</span> ‚¶É <span class="ot">_</span> <span class="ot">:</span> x ‚â§ y ‚¶Ñ <span class="ot">‚Üí</span> Total <span class="ot">_</span>‚â§<span class="ot">_</span> x y</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>  y‚â§x <span class="ot">:</span> ‚¶É <span class="ot">_</span> <span class="ot">:</span> y ‚â§ x ‚¶Ñ <span class="ot">‚Üí</span> Total <span class="ot">_</span>‚â§<span class="ot">_</span> x y</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a><span class="kw">module</span> Sorting <span class="ot">{</span>a r<span class="ot">}</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a>               <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a>               <span class="ot">{_</span>‚â§<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">‚Üí</span> A <span class="ot">‚Üí</span> <span class="dt">Set</span> r<span class="ot">}</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a>               <span class="ot">(_</span>‚â§?<span class="ot">_</span> <span class="ot">:</span> <span class="ot">‚àÄ</span> x y <span class="ot">‚Üí</span> Total <span class="ot">_</span>‚â§<span class="ot">_</span> x y<span class="ot">)</span> <span class="kw">where</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a>  <span class="kw">data</span> [‚àô] <span class="ot">:</span> <span class="dt">Set</span> a <span class="kw">where</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true"></a>    ‚ä•   <span class="ot">:</span> [‚àô]</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true"></a>    [<span class="ot">_</span>] <span class="ot">:</span> A <span class="ot">‚Üí</span> [‚àô]</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true"></a></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true"></a>  <span class="kw">data</span> <span class="ot">_</span>‚â•<span class="ot">_</span> <span class="ot">(</span>x <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">:</span> [‚àô] <span class="ot">‚Üí</span> <span class="dt">Set</span> <span class="ot">(</span>a ‚äî r<span class="ot">)</span> <span class="kw">where</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true"></a>    <span class="kw">instance</span> ‚åà<span class="ot">_</span>‚åâ <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>y<span class="ot">}</span> <span class="ot">‚Üí</span> y ‚â§ x <span class="ot">‚Üí</span> x ‚â• [ y ]</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true"></a>    <span class="kw">instance</span> ‚åä‚ä•‚åã <span class="ot">:</span> x ‚â• ‚ä•</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true"></a></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true"></a>  <span class="kw">infixr</span> <span class="dv">5</span> <span class="ot">_</span>‚à∑<span class="ot">_</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true"></a>  <span class="kw">data</span> Ordered <span class="ot">(</span>b <span class="ot">:</span> [‚àô]<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">(</span>a ‚äî r<span class="ot">)</span> <span class="kw">where</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true"></a>    []  <span class="ot">:</span> Ordered b</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true"></a>    <span class="ot">_</span>‚à∑<span class="ot">_</span> <span class="ot">:</span> <span class="ot">‚àÄ</span> x <span class="ot">‚Üí</span> ‚¶É x‚â•b <span class="ot">:</span> x ‚â• b ‚¶Ñ <span class="ot">‚Üí</span> <span class="ot">(</span>xs <span class="ot">:</span> Ordered [ x ]<span class="ot">)</span> <span class="ot">‚Üí</span> Ordered b</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true"></a></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true"></a>  <span class="ot">_</span>‚à™<span class="ot">_</span> <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>b<span class="ot">}</span> <span class="ot">‚Üí</span> Ordered b <span class="ot">‚Üí</span> Ordered b <span class="ot">‚Üí</span> Ordered b</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true"></a>  [] ‚à™ ys <span class="ot">=</span> ys</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true"></a>  <span class="ot">(</span>x ‚à∑ xs<span class="ot">)</span> ‚à™ ys <span class="ot">=</span> ‚üÖ x ‚àπ xs ‚à™ ys ‚üÜ</span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true"></a>    <span class="kw">where</span></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true"></a>    ‚üÖ<span class="ot">_</span>‚àπ<span class="ot">_</span>‚à™<span class="ot">_</span>‚üÜ <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>b<span class="ot">}</span> <span class="ot">‚Üí</span> <span class="ot">‚àÄ</span> x ‚¶É <span class="ot">_</span> <span class="ot">:</span> x ‚â• b ‚¶Ñ <span class="ot">‚Üí</span> Ordered [ x ] <span class="ot">‚Üí</span> Ordered b <span class="ot">‚Üí</span> Ordered b</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true"></a>    ‚üÖ<span class="ot">_</span>‚à™<span class="ot">_</span>‚àπ<span class="ot">_</span>‚üÜ <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>b<span class="ot">}</span> <span class="ot">‚Üí</span> Ordered b <span class="ot">‚Üí</span> <span class="ot">‚àÄ</span> y ‚¶É <span class="ot">_</span> <span class="ot">:</span> y ‚â• b ‚¶Ñ <span class="ot">‚Üí</span> Ordered [ y ] <span class="ot">‚Üí</span> Ordered b</span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true"></a>    merge <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>b<span class="ot">}</span> x y ‚¶É <span class="ot">_</span> <span class="ot">:</span> x ‚â• b ‚¶Ñ ‚¶É <span class="ot">_</span> <span class="ot">:</span> y ‚â• b ‚¶Ñ</span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true"></a>          <span class="ot">‚Üí</span> Total <span class="ot">_</span>‚â§<span class="ot">_</span> x y</span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true"></a>          <span class="ot">‚Üí</span> Ordered [ x ]</span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true"></a>          <span class="ot">‚Üí</span> Ordered [ y ]</span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true"></a>          <span class="ot">‚Üí</span> Ordered b</span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true"></a></span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true"></a>    ‚üÖ x ‚àπ xs ‚à™ [] ‚üÜ <span class="ot">=</span> x ‚à∑ xs</span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true"></a>    ‚üÖ x ‚àπ xs ‚à™ y ‚à∑ ys ‚üÜ <span class="ot">=</span> merge x y <span class="ot">(</span>x ‚â§? y<span class="ot">)</span> xs ys</span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true"></a>    ‚üÖ [] ‚à™ y ‚àπ ys ‚üÜ <span class="ot">=</span> y ‚à∑ ys</span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true"></a>    ‚üÖ x ‚à∑ xs ‚à™ y ‚àπ ys ‚üÜ <span class="ot">=</span> merge x y <span class="ot">(</span>x ‚â§? y<span class="ot">)</span> xs ys</span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true"></a></span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true"></a>    merge x y x‚â§y xs ys <span class="ot">=</span> x ‚à∑ ‚üÖ xs ‚à™ y ‚àπ ys ‚üÜ</span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true"></a>    merge x y y‚â§x xs ys <span class="ot">=</span> y ‚à∑ ‚üÖ x ‚àπ xs ‚à™ ys ‚üÜ</span>
<span id="cb6-41"><a href="#cb6-41" aria-hidden="true"></a></span>
<span id="cb6-42"><a href="#cb6-42" aria-hidden="true"></a></span>
<span id="cb6-43"><a href="#cb6-43" aria-hidden="true"></a>  <span class="kw">open</span> TreeFold</span>
<span id="cb6-44"><a href="#cb6-44" aria-hidden="true"></a></span>
<span id="cb6-45"><a href="#cb6-45" aria-hidden="true"></a>  sort <span class="ot">:</span> List A <span class="ot">‚Üí</span> Ordered ‚ä•</span>
<span id="cb6-46"><a href="#cb6-46" aria-hidden="true"></a>  sort <span class="ot">=</span> ‚¶Ö <span class="ot">_</span>‚à™<span class="ot">_</span> , [] ‚¶Ü ‚àò map <span class="ot">(_</span>‚à∑ []<span class="ot">)</span></span></code></pre></div>
<h1 id="validity">Validity</h1>
<p>It would be nice if we could verify these optimizated versions of folds. Luckily, by writing them using <code>foldr</code>, we‚Äôve stumbled into well-trodden ground: the <em>foldr fusion law</em>. It states that if you have some transformation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>, and two binary operators <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>‚äï</mo><annotation encoding="application/x-tex">\oplus</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>‚äó</mo><annotation encoding="application/x-tex">\otimes</annotation></semantics></math>, then:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right"><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>‚äï</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="left"></mtd><mtd columnalign="right"><mo>=</mo><mspace width="0.278em"></mspace></mtd><mtd columnalign="left"><mi>x</mi><mo>‚äó</mo><mi>f</mi><mi>y</mi></mtd></mtr><mtr><mtd columnalign="right"><mo>‚üπ</mo><mi>f</mi><mo>‚àò</mo><mtext mathvariant="normal">foldr</mtext><mo>‚äï</mo><mi>e</mi></mtd><mtd columnalign="left"></mtd><mtd columnalign="right"><mo>=</mo><mspace width="0.278em"></mspace></mtd><mtd columnalign="left"><mtext mathvariant="normal">foldr</mtext><mo>‚äó</mo><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mi>e</mi><mo stretchy="false" form="postfix">)</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align}
   f (x \oplus y)                         &amp;&amp;=\;&amp; x \otimes f y \\
   \implies f \circ \text{foldr} \oplus e &amp;&amp;=\;&amp; \text{foldr} \otimes (f e)
\end{align}</annotation></semantics></math></p>
<p>This fits right in with the function we used above. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> is <code>‚ü¶_‚üß‚Üì</code>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>‚äï</mo><annotation encoding="application/x-tex">\oplus</annotation></semantics></math> is <code>_‚äõ_</code>, and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>‚äó</mo><annotation encoding="application/x-tex">\otimes</annotation></semantics></math> is whatever combining function was passed in. Let‚Äôs prove the foldr fusion law, then, before we go any further.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="kw">module</span> Proofs</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>  <span class="ot">{</span>a r<span class="ot">}</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>  <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>  <span class="ot">{</span>R <span class="ot">:</span> Rel A r<span class="ot">}</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a>  <span class="kw">infix</span> <span class="dv">4</span> <span class="ot">_</span>‚âà<span class="ot">_</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a>  <span class="ot">_</span>‚âà<span class="ot">_</span> <span class="ot">=</span> R</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true"></a>  <span class="kw">open</span> <span class="kw">import</span> Algebra<span class="ot">.</span>FunctionProperties <span class="ot">_</span>‚âà<span class="ot">_</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true"></a></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true"></a>  foldr-universal <span class="ot">:</span> Transitive <span class="ot">_</span>‚âà<span class="ot">_</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true"></a>                  <span class="ot">‚Üí</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>b<span class="ot">}</span> <span class="ot">{</span>B <span class="ot">:</span> <span class="dt">Set</span> b<span class="ot">}</span> <span class="ot">(</span>h <span class="ot">:</span> List B <span class="ot">‚Üí</span> A<span class="ot">)</span> f e</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true"></a>                  <span class="ot">‚Üí</span> ‚àÄ[ f ‚ä¢ Congruent‚ÇÅ ]</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true"></a>                  <span class="ot">‚Üí</span> <span class="ot">(</span>h [] ‚âà e<span class="ot">)</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true"></a>                  <span class="ot">‚Üí</span> <span class="ot">(‚àÄ</span> x xs <span class="ot">‚Üí</span> h <span class="ot">(</span>x ‚à∑ xs<span class="ot">)</span> ‚âà f x <span class="ot">(</span>h xs<span class="ot">))</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true"></a>                  <span class="ot">‚Üí</span> <span class="ot">‚àÄ</span> xs <span class="ot">‚Üí</span> h xs ‚âà foldr f e xs</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true"></a>  foldr-universal <span class="ot">_</span>‚óã<span class="ot">_</span> h f e f‚ü®<span class="ot">_</span>‚ü© ‚áí[] ‚áí<span class="ot">_</span>‚à∑<span class="ot">_</span> [] <span class="ot">=</span> ‚áí[]</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true"></a>  foldr-universal <span class="ot">_</span>‚óã<span class="ot">_</span> h f e f‚ü®<span class="ot">_</span>‚ü© ‚áí[] ‚áí<span class="ot">_</span>‚à∑<span class="ot">_</span> <span class="ot">(</span>x ‚à∑ xs<span class="ot">)</span> <span class="ot">=</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true"></a>    <span class="ot">(</span>‚áí x ‚à∑ xs<span class="ot">)</span> ‚óã f‚ü® foldr-universal <span class="ot">_</span>‚óã<span class="ot">_</span> h f e f‚ü®<span class="ot">_</span>‚ü© ‚áí[] ‚áí<span class="ot">_</span>‚à∑<span class="ot">_</span> xs ‚ü©</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true"></a></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true"></a>  foldr-fusion <span class="ot">:</span> Transitive <span class="ot">_</span>‚âà<span class="ot">_</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true"></a>               <span class="ot">‚Üí</span> Reflexive <span class="ot">_</span>‚âà<span class="ot">_</span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true"></a>               <span class="ot">‚Üí</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>b c<span class="ot">}</span> <span class="ot">{</span>B <span class="ot">:</span> <span class="dt">Set</span> b<span class="ot">}</span> <span class="ot">{</span>C <span class="ot">:</span> <span class="dt">Set</span> c<span class="ot">}</span> <span class="ot">(</span>f <span class="ot">:</span> C <span class="ot">‚Üí</span> A<span class="ot">)</span> <span class="ot">{_</span>‚äï<span class="ot">_</span> <span class="ot">:</span> B <span class="ot">‚Üí</span> C <span class="ot">‚Üí</span> C<span class="ot">}</span> <span class="ot">{_</span>‚äó<span class="ot">_</span> <span class="ot">:</span> B <span class="ot">‚Üí</span> A <span class="ot">‚Üí</span> A<span class="ot">}</span> e</span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true"></a>               <span class="ot">‚Üí</span> ‚àÄ[ <span class="ot">_</span>‚äó<span class="ot">_</span> ‚ä¢ Congruent‚ÇÅ ]</span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true"></a>               <span class="ot">‚Üí</span> <span class="ot">(‚àÄ</span> x y <span class="ot">‚Üí</span> f <span class="ot">(</span>x ‚äï y<span class="ot">)</span> ‚âà x ‚äó f y<span class="ot">)</span></span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true"></a>               <span class="ot">‚Üí</span> <span class="ot">‚àÄ</span> xs <span class="ot">‚Üí</span> f <span class="ot">(</span>foldr <span class="ot">_</span>‚äï<span class="ot">_</span> e xs<span class="ot">)</span> ‚âà foldr <span class="ot">_</span>‚äó<span class="ot">_</span> <span class="ot">(</span>f e<span class="ot">)</span> xs</span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true"></a>  foldr-fusion <span class="ot">_</span>‚óã<span class="ot">_</span> ‚àé h <span class="ot">{</span>f<span class="ot">}</span> <span class="ot">{</span>g<span class="ot">}</span> e g‚ü®<span class="ot">_</span>‚ü© fuse <span class="ot">=</span></span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true"></a>    foldr-universal <span class="ot">_</span>‚óã<span class="ot">_</span> <span class="ot">(</span>h ‚àò foldr f e<span class="ot">)</span> g <span class="ot">(</span>h e<span class="ot">)</span> g‚ü®<span class="ot">_</span>‚ü© ‚àé <span class="ot">(Œª</span> x xs <span class="ot">‚Üí</span> fuse x <span class="ot">(</span>foldr f e xs<span class="ot">))</span></span></code></pre></div>
<p>We‚Äôre not using the proofs in Agda‚Äôs standard library because these are tied to propositional equality. In other words, instead of using an abstract binary relation, they prove things over <em>actual</em> equality. That‚Äôs all well and good, but as you can see above, we don‚Äôt need propositional equality: we don‚Äôt even need the relation to be an equivalence, we just need transitivity and reflexivity.</p>
<p>After that, we can state precisely what correspondence the tree fold has, and under what conditions it does the same things as a fold:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="kw">module</span> <span class="ot">_</span> <span class="ot">{_</span>*<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">‚Üí</span> A <span class="ot">‚Üí</span> A<span class="ot">}</span> <span class="kw">where</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>  <span class="kw">open</span> TreeFold <span class="ot">_</span>*<span class="ot">_</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>  treeFoldHom <span class="ot">:</span> Transitive <span class="ot">_</span>‚âà<span class="ot">_</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>              <span class="ot">‚Üí</span> Reflexive <span class="ot">_</span>‚âà<span class="ot">_</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a>              <span class="ot">‚Üí</span> Associative <span class="ot">_</span>*<span class="ot">_</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a>              <span class="ot">‚Üí</span> RightCongruent <span class="ot">_</span>*<span class="ot">_</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a>              <span class="ot">‚Üí</span> <span class="ot">‚àÄ</span> x xs</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a>              <span class="ot">‚Üí</span> ‚¶Ö x , xs ‚¶Ü ‚âà foldr <span class="ot">_</span>*<span class="ot">_</span> x xs</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true"></a>  treeFoldHom <span class="ot">_</span>‚óã<span class="ot">_</span> ‚àé assoc *‚ü®<span class="ot">_</span>‚ü© b <span class="ot">=</span> foldr-fusion <span class="ot">_</span>‚óã<span class="ot">_</span> ‚àé ‚ü¶<span class="ot">_</span>‚üß‚Üì ‚ü¶ b ‚üß‚Üë *‚ü®<span class="ot">_</span>‚ü© <span class="ot">(</span>‚äõ-hom zero<span class="ot">)</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true"></a>    <span class="kw">where</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true"></a>    ‚äõ-hom <span class="ot">:</span> <span class="ot">‚àÄ</span> n x xs <span class="ot">‚Üí</span> ‚ü¶ 2^ n √ó x ‚äõ xs ‚üß‚Üì ‚âà x * ‚ü¶ xs ‚üß‚Üì</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true"></a>    ‚äõ-hom n x <span class="ot">(</span>2^ suc m √ó y + ‚ü®‚ü©    <span class="ot">)</span> <span class="ot">=</span> ‚àé</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true"></a>    ‚äõ-hom n x <span class="ot">(</span>2^ suc m √ó y + ‚ü® ys ‚ü©<span class="ot">)</span> <span class="ot">=</span> ‚àé</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true"></a>    ‚äõ-hom n x <span class="ot">(</span>2^ zero  √ó y + ‚ü®‚ü©    <span class="ot">)</span> <span class="ot">=</span> ‚àé</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true"></a>    ‚äõ-hom n x <span class="ot">(</span>2^ zero  √ó y + ‚ü® ys ‚ü©<span class="ot">)</span> <span class="ot">=</span> ‚äõ-hom <span class="ot">(</span>suc n<span class="ot">)</span> <span class="ot">(</span>x * y<span class="ot">)</span> ys ‚óã assoc x y ‚ü¶ ys ‚üß‚Üì</span></code></pre></div>
<h1 id="implicit-data-structures">‚ÄúImplicit‚Äù Data Structures</h1>
<p>Consider the following implementation of the tree above in Haskell:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">Tree</span> a <span class="ot">=</span> [(<span class="dt">Int</span>,a)]</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a><span class="ot">cons ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a>cons (<span class="op">*</span>) <span class="ot">=</span> cons' <span class="dv">0</span> </span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a>    cons' n x [] <span class="ot">=</span> [(n,x)]</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a>    cons' n x ((<span class="dv">0</span>,y)<span class="op">:</span>ys) <span class="ot">=</span> cons' (n<span class="op">+</span><span class="dv">1</span>) (x <span class="op">*</span> y) ys</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true"></a>    cons' n x ((m,y)<span class="op">:</span>ys) <span class="ot">=</span> (n,x) <span class="op">:</span> (m<span class="op">-</span><span class="dv">1</span>,y) <span class="op">:</span> ys</span></code></pre></div>
<p>The <code>cons</code> function ‚Äúincrements‚Äù that list as if it were the bits of a binary number. Now, consider using the <code>merge</code> function from above, in a pattern like this:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a>f <span class="ot">=</span> <span class="fu">foldr</span> (cons merge <span class="op">.</span> <span class="fu">pure</span>) []</span></code></pre></div>
<p>What does <code>f</code> build? A list of lists, right?</p>
<p>Kind of. That‚Äôs what‚Äôs built in terms of the observable, but what‚Äôs actually stored in memory us a bunch of thunks. The shape of <em>those</em> is what I‚Äôm interested in. We can try and see what they look like by using a data structure that doesn‚Äôt force on merge:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Tree</span> a <span class="ot">=</span> <span class="dt">Leaf</span> a <span class="op">|</span> <span class="dt">Tree</span> a <span class="op">:*:</span> <span class="dt">Tree</span> a</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a>f <span class="ot">=</span> <span class="fu">foldr</span> (cons (<span class="op">:*:</span>) <span class="op">.</span> <span class="dt">Leaf</span>) []</span></code></pre></div>
<p>Using a handy tree-drawing function, we can see what <code>f [1..13]</code> looks like:</p>
<pre><code>[(0,*),(1,*),(0,*)]
    ‚îî1    ‚îÇ ‚îå2  ‚îÇ  ‚îå6
          ‚îÇ‚îå‚î§   ‚îÇ ‚îå‚î§
          ‚îÇ‚îÇ‚îî3  ‚îÇ ‚îÇ‚îî7
          ‚îî‚î§    ‚îÇ‚îå‚î§
           ‚îÇ‚îå4  ‚îÇ‚îÇ‚îÇ‚îå8
           ‚îî‚î§   ‚îÇ‚îÇ‚îî‚î§
            ‚îî5  ‚îÇ‚îÇ ‚îî9
                ‚îî‚î§
                 ‚îÇ ‚îå10
                 ‚îÇ‚îå‚î§
                 ‚îÇ‚îÇ‚îî11
                 ‚îî‚î§
                  ‚îÇ‚îå12
                  ‚îî‚î§
                   ‚îî13</code></pre>
<p>It‚Äôs a binomial heap! It‚Äôs a list of trees, each one contains <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mi>n</mi></msup><annotation encoding="application/x-tex">2^n</annotation></semantics></math> elements. But they‚Äôre not in heap order, you say? Well, as a matter of fact, they <em>are</em>. It just hasn‚Äôt been evaluated yet. Once we force‚Äîsay‚Äîthe first element, the rest will shuffle themselves into a tree of thunks.</p>
<p>This illustrates a pretty interesting similarity between binomial heaps and merge sort. Performance-wise, though, there‚Äôs another interesting property: the thunks <em>stay thunked</em>. In other words, if we do a merge sort via:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="fu">sort</span> <span class="ot">=</span> <span class="fu">foldr</span> (merge <span class="op">.</span> <span class="fu">snd</span>) [] <span class="op">.</span> <span class="fu">foldr</span> (cons merge <span class="op">.</span> <span class="fu">pure</span>) []</span></code></pre></div>
<p>We could instead freeze the fold, and look at it at every point:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a>sortPrefixes <span class="ot">=</span> <span class="fu">map</span> (<span class="fu">foldr</span> (merge <span class="op">.</span> <span class="fu">snd</span>) []) <span class="op">.</span> <span class="fu">scanl</span> (<span class="fu">flip</span> (cons merge <span class="op">.</span> <span class="fu">pure</span>)) []</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a><span class="op">&gt;&gt;&gt;</span> [[],[<span class="dv">1</span>],[<span class="dv">1</span>,<span class="dv">4</span>],[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">4</span>],[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>],[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>]]</span></code></pre></div>
<p>And <code>sortPrefixes</code> is only <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n^2)</annotation></semantics></math> (rather than <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n^2 \log n)</annotation></semantics></math>). I confess I don‚Äôt know of a use for sorted prefixes, but it should illustrate the general idea: we get a pretty decent batching of operations, with the ability to freeze at any point in time. The other nice property (which I mentioned in the last post) is that any of the tree folds are extremely parallel.</p>
<h1 id="random-shuffles">Random Shuffles</h1>
<p><a href="http://okmij.org/ftp/Haskell/AlgorithmsH.html#perfect-shuffle">There‚Äôs a great article on shuffling in Haskell</a> which provides an <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n \log n)</annotation></semantics></math> implementation of a perfect random shuffle. Unfortunately, the <a href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle">Fisher-Yates shuffle</a> isn‚Äôt applicable in a pure functional setting, so you have to be a little cleverer.</p>
<p>The first implementation most people jump to (certainly the one I thought of) is to assign everything in the sequence a random number, and then sort according to that number. Perhaps surprisingly, this <em>isn‚Äôt</em> perfectly random! It‚Äôs a little weird, but the example in the article explains it well: basically, for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> elements, your random numbers will have <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>n</mi><mi>n</mi></msup><annotation encoding="application/x-tex">n^n</annotation></semantics></math> possible values, but the output of the sort will have <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>!</mi></mrow><annotation encoding="application/x-tex">n!</annotation></semantics></math> possible values. Since they don‚Äôt divide into each other evenly, you‚Äôre going to have some extra weight on some permutations, and less on others.</p>
<p>Instead, we can generate a random <a href="https://en.wikipedia.org/wiki/Factorial_number_system"><em>factoradic</em></a> number. A factoradic number is one where the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>th digit is in base <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>. Because of this, a factoradic number with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> digits has <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>!</mi></mrow><annotation encoding="application/x-tex">n!</annotation></semantics></math> possible values: exactly what we want.</p>
<p>In the article, the digits of the number are used to pop values from a binary tree. Because the last digit will have <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> possible values, and the second last <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>‚àí</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math>, and so on, you can keep popping without hitting an empty tree.</p>
<p>This has the correct time complexity‚Äî<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n \log n)</annotation></semantics></math>‚Äîbut there‚Äôs a lot of overhead. Building the tree, then indexing into it, the rebuilding after each pop, etc.</p>
<p>We‚Äôd <em>like</em> to just sort the list, according to the indices. The problem is that the indices are relative: if you want to <code>cons</code> something onto the list, you have to increment the rest of the indices, as they‚Äôve all shifted right by one.</p>
<p>What we‚Äôll do instead is use the indices as <em>gaps</em>. Our merge function looks like the following:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a>merge [] ys <span class="ot">=</span> ys</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a>merge xs [] <span class="ot">=</span> xs</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a>merge ((x,i)<span class="op">:</span>xs) ((y,j)<span class="op">:</span>ys)</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a>  <span class="op">|</span> i <span class="op">&lt;=</span> j    <span class="ot">=</span> (x,i) <span class="op">:</span> merge xs ((y,j<span class="op">-</span>i)<span class="op">:</span>ys)</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> (y,j) <span class="op">:</span> merge ((x,i<span class="op">-</span>j<span class="op">-</span><span class="dv">1</span>)<span class="op">:</span>xs) ys</span></code></pre></div>
<p>With that, and the same <code>cons</code> as above, we get a very simple random shuffle algorithm:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a>shuffle xs <span class="ot">=</span> <span class="fu">map</span> <span class="fu">fst</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a>           <span class="op">.</span> <span class="fu">foldr</span> (merge <span class="op">.</span> <span class="fu">snd</span>) []</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a>           <span class="op">.</span> <span class="fu">foldr</span> f (<span class="fu">const</span> []) xs</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true"></a>    f x xs (i<span class="op">:</span>is) <span class="ot">=</span> cons merge [(x,i)] (xs is)</span></code></pre></div>
<p>The other interesting thing about this algorithm is that it can use Peano numbers with taking too much of a performance hit:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a>merge <span class="op">:</span> <span class="ot">‚àÄ</span> {a} {<span class="dt">A</span> <span class="op">:</span> <span class="dt">Set</span> a} <span class="ot">‚Üí</span> <span class="dt">List</span> (<span class="dt">A</span> √ó ‚Ñï) <span class="ot">‚Üí</span> <span class="dt">List</span> (<span class="dt">A</span> √ó ‚Ñï) <span class="ot">‚Üí</span> <span class="dt">List</span> (<span class="dt">A</span> √ó ‚Ñï)</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a>merge xs [] <span class="ot">=</span> xs</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a>merge {<span class="dt">A</span> <span class="ot">=</span> <span class="dt">A</span>} xs ((y , j) <span class="ot">‚à∑</span> ys) <span class="ot">=</span> go<span class="op">-</span>r xs y j ys</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a>  go<span class="op">-</span>l <span class="op">:</span> <span class="dt">A</span> <span class="ot">‚Üí</span> ‚Ñï <span class="ot">‚Üí</span> <span class="dt">List</span> (<span class="dt">A</span> √ó ‚Ñï) <span class="ot">‚Üí</span> <span class="dt">List</span> (<span class="dt">A</span> √ó ‚Ñï) <span class="ot">‚Üí</span> <span class="dt">List</span> (<span class="dt">A</span> √ó ‚Ñï)</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true"></a>  go<span class="op">-</span>r <span class="op">:</span> <span class="dt">List</span> (<span class="dt">A</span> √ó ‚Ñï) <span class="ot">‚Üí</span> <span class="dt">A</span> <span class="ot">‚Üí</span> ‚Ñï <span class="ot">‚Üí</span> <span class="dt">List</span> (<span class="dt">A</span> √ó ‚Ñï) <span class="ot">‚Üí</span> <span class="dt">List</span> (<span class="dt">A</span> √ó ‚Ñï)</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true"></a>  go <span class="op">:</span> ‚Ñï <span class="ot">‚Üí</span> ‚Ñï <span class="ot">‚Üí</span> <span class="dt">A</span> <span class="ot">‚Üí</span> ‚Ñï <span class="ot">‚Üí</span> <span class="dt">List</span> (<span class="dt">A</span> √ó ‚Ñï) <span class="ot">‚Üí</span> <span class="dt">A</span> <span class="ot">‚Üí</span> ‚Ñï <span class="ot">‚Üí</span> <span class="dt">List</span> (<span class="dt">A</span> √ó ‚Ñï) <span class="ot">‚Üí</span> <span class="dt">List</span> (<span class="dt">A</span> √ó ‚Ñï)</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true"></a></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true"></a>  go i     zero   x i‚Ä≤ xs y j‚Ä≤ ys <span class="ot">=</span> (y , j‚Ä≤) <span class="ot">‚à∑</span> go<span class="op">-</span>l x i xs ys</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true"></a>  go zero (suc j) x i‚Ä≤ xs y j‚Ä≤ ys <span class="ot">=</span> (x , i‚Ä≤) <span class="ot">‚à∑</span> go<span class="op">-</span>r xs y j ys</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true"></a>  go (suc i) (suc j) <span class="ot">=</span> go i j</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true"></a></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true"></a>  go<span class="op">-</span>l x i xs [] <span class="ot">=</span> (x , i) <span class="ot">‚à∑</span> xs</span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true"></a>  go<span class="op">-</span>l x i xs ((y , j) <span class="ot">‚à∑</span> ys) <span class="ot">=</span> go i j x i xs y j ys</span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true"></a></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true"></a>  go<span class="op">-</span>r [] y j ys <span class="ot">=</span> (y , j) <span class="ot">‚à∑</span> ys</span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true"></a>  go<span class="op">-</span>r ((x , i) <span class="ot">‚à∑</span> xs) y j ys <span class="ot">=</span> go i j x i xs y j ys</span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true"></a></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true"></a>shuffle <span class="op">:</span> <span class="ot">‚àÄ</span> {a} {<span class="dt">A</span> <span class="op">:</span> <span class="dt">Set</span> a} <span class="ot">‚Üí</span> <span class="dt">List</span> <span class="dt">A</span> <span class="ot">‚Üí</span> <span class="dt">List</span> ‚Ñï <span class="ot">‚Üí</span> <span class="dt">List</span> <span class="dt">A</span></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true"></a>shuffle {a} {<span class="dt">A</span>} xs i <span class="ot">=</span> <span class="fu">map</span> proj‚ÇÅ (‚¶Ö [] , <span class="fu">zip</span><span class="op">-</span>inds xs i ‚¶Ü)</span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true"></a>  open <span class="dt">TreeFold</span> {a} {<span class="dt">List</span> (<span class="dt">A</span> √ó ‚Ñï)} merge</span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true"></a></span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true"></a>  <span class="fu">zip</span><span class="op">-</span>inds <span class="op">:</span> <span class="dt">List</span> <span class="dt">A</span> <span class="ot">‚Üí</span> <span class="dt">List</span> ‚Ñï <span class="ot">‚Üí</span> <span class="dt">List</span> (<span class="dt">List</span> (<span class="dt">A</span> √ó ‚Ñï))</span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true"></a>  <span class="fu">zip</span><span class="op">-</span>inds [] inds <span class="ot">=</span> []</span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true"></a>  <span class="fu">zip</span><span class="op">-</span>inds (x <span class="ot">‚à∑</span> xs) [] <span class="ot">=</span> ((x , <span class="dv">0</span>) <span class="ot">‚à∑</span> []) <span class="ot">‚à∑</span> <span class="fu">zip</span><span class="op">-</span>inds xs []</span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true"></a>  <span class="fu">zip</span><span class="op">-</span>inds (x <span class="ot">‚à∑</span> xs) (i <span class="ot">‚à∑</span> inds) <span class="ot">=</span> ((x , i) <span class="ot">‚à∑</span> []) <span class="ot">‚à∑</span> <span class="fu">zip</span><span class="op">-</span>inds xs inds</span></code></pre></div>
<p>I don‚Äôt know exactly what the complexity of this is, but I <em>think</em> it should be better than the usual approach of popping from a vector.</p>
<h1 id="future-stuff">Future Stuff</h1>
<p>This is just a collection of random thoughts for now, but I intend to work on using these folds to see if there are any other algorithms they can be useful for. In particular, I think I can write a version of Data.List.permutations which benefits from sharing. And I‚Äôm interested in using the implicit binomial heap for some search problems.</p>

        </div>
    </body>
</html>
