<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Concatenative Programming; The Free Monoid of Programming Languages - Donnacha Oisín Kidney</title>
        <style>body{color:black;font-family:Garamond,Times New Roman,serif;font-size:14px;margin:0px auto 0px auto;padding-left:5px;padding-right:5px;max-width:600px}math{font-size:13px}img{max-width:600px}div#header{border-bottom:3px double black;margin-bottom:30px;padding:12px 0px 12px 0px}div#logo a{color:black;float:left;font-size:20px;text-decoration:none}div#header #navigation{text-align:right}div#header #navigation a{color:black;font-family:Garamond,Times New Roman,Serif;font-size:18px;margin-left:10px;text-decoration:none;text-transform:uppercase}div#footer{font-family:Garamond,Times New Roman,Serif;border-top:solid 2px black;color:#555;font-size:12px;margin-top:30px;padding:12px 0px 12px 0px;text-align:right}h1{font-family:Garamond,Times New Roman,Serif;font-size:22px;font-weight:normal}h2{font-family:Garamond,Times New Roman,Serif;font-size:20px;font-weight:normal}div.info{color:#555;font-size:15px;font-style:italic}span.quiet{color:#828282;font-style:italic}a{color:black;word-wrap:break-word}ul.post-list{margin-left:0px;padding-left:0px;list-style-type:none}.hidden_source{display:none}ol.serieslist{counter-reset:item;list-style-type:none;padding-left:20}ol li.serieslist:before{content:'Part ' counter(item,decimal) ':';counter-increment:item}table.sourceCode,tr.sourceCode,td.lineNumbers,td.sourceCode,table.sourceCode pre{margin:0;padding:0;border:0;vertical-align:baseline;border:none}td.lineNumbers{border-right:1px solid #AAAAAA;text-align:right;color:#AAAAAA;padding-right:5px;padding-left:5px}td.sourceCode{padding-left:5px}.sourceCode,code,.Agda{font-size:10px;font-family:menlo,monospace}.sourceCode span.kw{color:#262C6A}.sourceCode span.dt{color:#476A97}.sourceCode span.dv{color:#262C6A}.sourceCode span.bn{color:#262C6A}.sourceCode span.fl{color:#262C6A}.sourceCode span.ch{color:#262C6A}.sourceCode span.st{color:#702C51}.sourceCode span.co{color:#435138}.sourceCode span.ot{color:#262C6A}.sourceCode span.al{color:red}.sourceCode span.fu{color:#000000}.sourceCode span.re{color:#000000}.sourceCode span.er{color:red}li{margin-bottom:2px}li:last-child{margin-bottom:0px}.Agda .Comment{color:#B22222}.Agda .Background{}.Agda .Markup{color:#000000}.Agda .Keyword{color:#CD6600}.Agda .String{color:#B22222}.Agda .Number{color:#A020F0}.Agda .Symbol{color:#404040}.Agda .PrimitiveType{color:#0000CD}.Agda .Pragma{color:black}.Agda .Operator{}.Agda .Bound{color:black}.Agda .Generalizable{color:black}.Agda .InductiveConstructor{color:#008B00}.Agda .CoinductiveConstructor{color:#8B7500}.Agda .Datatype{color:#0000CD}.Agda .Field{color:#EE1289}.Agda .Function{color:#0000CD}.Agda .Module{color:#A020F0}.Agda .Postulate{color:#0000CD}.Agda .Primitive{color:#0000CD}.Agda .Record{color:#0000CD}.Agda .DottedPattern{}.Agda .UnsolvedMeta{color:black;background:yellow}.Agda .UnsolvedConstraint{color:black;background:yellow}.Agda .TerminationProblem{color:black;background:#FFA07A}.Agda .IncompletePattern{color:black;background:#F5DEB3}.Agda .Error{color:red;text-decoration:underline}.Agda .TypeChecks{color:black;background:#ADD8E6}.Agda a{text-decoration:none}.Agda a[href]:hover{background-color:#B4EEB4}.sourceCode{overflow-x:auto}</style>
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Donnacha Oisín Kidney</a>
            </div>
            <div id="navigation">
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../rss.xml">Feed</a>
            </div>
        </div>

        <div id="content">
            <h2>Concatenative Programming; The Free Monoid of Programming Languages</h2>

            <div class="info">
    Posted on May 11, 2019
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="../tags/Concatenative.html">Concatenative</a>, <a href="../tags/Haskell.html">Haskell</a>
    
</div>

<p>This post demonstrates a simple encoding of a (typed) concatenative language in Haskell.</p>
<p>Point-free style is one of the distinctive markers of functional programming languages. Want to sum a list? That’s as easy as:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1">sum <span class="fu">=</span> foldr (<span class="fu">+</span>) <span class="dv">0</span></a></code></pre></div>
<p>Now I want to sum every number after adding one to it.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1">sumSuccs <span class="fu">=</span> foldr (<span class="fu">+</span>) <span class="dv">0</span> <span class="fu">.</span> map ((<span class="fu">+</span>) <span class="dv">1</span>)</a></code></pre></div>
<p>One more step to make this function truly abstract™ and general™: we’ll allow the user to supply their own number to add</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1">sumAdded <span class="fu">=</span> foldr (<span class="fu">+</span>) <span class="dv">0</span> <span class="fu">.</span> map <span class="fu">.</span> (<span class="fu">+</span>)</a></code></pre></div>
<p>And here the trouble begins. The above expression won’t actually type check. In fact, it’ll give a pretty terrible error message:</p>
<pre><code>• Non type-variable argument in the constraint: Num [a]
  (Use FlexibleContexts to permit this)
• When checking the inferred type
    sumThoseThat :: forall a.
                    (Num [a], Foldable ((-&gt;) [a])) =&gt;
                    a -&gt; [a]</code></pre>
<p>I remember as a beginner being confused by similar messages. What’s <code>FlexibleContexts</code>? I had thought that the “point-free style” just meant removing the last variable from an expression if it’s also the last argument:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1">sum xs <span class="fu">=</span> foldr (<span class="fu">+</span>) <span class="dv">0</span> xs</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">sum <span class="fu">=</span> foldr (<span class="fu">+</span>) <span class="dv">0</span></a></code></pre></div>
<p>Why doesn’t it work here?</p>
<p>Well, it doesn’t work because the types don’t line up, but I’m going to try and explain a slightly different perspective on the problem, which is <em>associativity</em>.</p>
<p>To make it a little clearer, let’s see what happens when we point-fill the expression:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1">sumAdded n xs <span class="fu">=</span> (foldr(<span class="fu">+</span>) <span class="dv">0</span> <span class="fu">.</span> (map <span class="fu">.</span> (<span class="fu">+</span>))) n xs</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">             <span class="ot">=&gt;</span> foldr(<span class="fu">+</span>) <span class="dv">0</span> ((map <span class="fu">.</span> (<span class="fu">+</span>)) n) xs</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">             <span class="ot">=&gt;</span> foldr(<span class="fu">+</span>) <span class="dv">0</span> (map ((<span class="fu">+</span>) n)) xs</a></code></pre></div>
<p>Indeed, the problem is the placement of the parentheses. What we want at the end is:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1">             <span class="ot">=&gt;</span> foldr(<span class="fu">+</span>) <span class="dv">0</span> (map ((<span class="fu">+</span>) n) xs)</a></code></pre></div>
<p>But, no matter. We have to jiggle the arguments around, or we could use something terrible like this:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">9</span> <span class="fu">.:</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">(<span class="fu">.:</span>) <span class="fu">=</span> (<span class="fu">.</span>)<span class="fu">.</span>(<span class="fu">.</span>)</a>
<a class="sourceLine" id="cb8-3" data-line-number="3"></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">sumAdded <span class="fu">=</span> foldr (<span class="fu">+</span>) <span class="dv">0</span> <span class="fu">.:</span> map <span class="fu">.</span> (<span class="fu">+</span>)</a></code></pre></div>
<p>Is there something, though, that could do this automatically?</p>
<h1 id="associativity">Associativity</h1>
<p>We run into a similar problem in Agda. We’re forever having to prove statements like:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">(</span>x + y<span class="ot">)</span> + z ≡ x + <span class="ot">(</span>y + z<span class="ot">)</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">x ≡ x + <span class="dv">0</span></a></code></pre></div>
<p>There are a couple of ways to get around the issue, and for monoids there’s a rich theory of techniques. I’ll just show one for now, which relies on the <em>endomorphism</em> monoid. This monoid is created by partially applying the monoid’s binary operator:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb10-1" data-line-number="1">Endo <span class="ot">:</span> <span class="dt">Set</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">Endo <span class="ot">=</span> ℕ <span class="ot">→</span> ℕ</a>
<a class="sourceLine" id="cb10-3" data-line-number="3"></a>
<a class="sourceLine" id="cb10-4" data-line-number="4">⟦<span class="ot">_</span>⇑⟧ <span class="ot">:</span> ℕ <span class="ot">→</span> Endo</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">⟦ n ⇑⟧ m <span class="ot">=</span> n + m</a></code></pre></div>
<p>And you can get back to the underlying monoid by applying it to the neutral element:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb11-1" data-line-number="1">⟦<span class="ot">_</span>⇓⟧ <span class="ot">:</span> Endo <span class="ot">→</span> ℕ</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">⟦ n ⇓⟧ <span class="ot">=</span> n <span class="dv">0</span></a></code></pre></div>
<p>Here’s the important parts: first, we can lift the underlying operation into the endomorphism:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="ot">_</span>⊕<span class="ot">_</span> <span class="ot">:</span> Endo <span class="ot">→</span> Endo <span class="ot">→</span> Endo</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">xs ⊕ ys <span class="ot">=</span> <span class="ot">λ</span> x <span class="ot">→</span> xs <span class="ot">(</span>ys x<span class="ot">)</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3"></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">⊕-homo <span class="ot">:</span> <span class="ot">∀</span> n m <span class="ot">→</span> ⟦ ⟦ n ⇑⟧ ⊕ ⟦ m ⇑⟧ ⇓⟧ ≡ n + m</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">⊕-homo n m <span class="ot">=</span> cong <span class="ot">(</span>n +<span class="ot">_)</span> <span class="ot">(</span>+-identityʳ m<span class="ot">)</span></a></code></pre></div>
<p>And second, it’s <em>definitionally</em> associative.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb13-1" data-line-number="1">⊕-assoc <span class="ot">:</span> <span class="ot">∀</span> x y z <span class="ot">→</span> <span class="ot">(</span>x ⊕ y<span class="ot">)</span> ⊕ z ≡ x ⊕ <span class="ot">(</span>y ⊕ z<span class="ot">)</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">⊕-assoc <span class="ot">_</span> <span class="ot">_</span> <span class="ot">_</span> <span class="ot">=</span> refl</a></code></pre></div>
<p>These are all clues as to how to solve the composition problem in the Haskell code above. We need definitional associativity, somehow. Maybe we can get it from the endomorphism monoid?</p>
<h1 id="state">State</h1>
<p>You’re probably familiar with Haskell’s state monad:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">State</span> s a <span class="fu">=</span> <span class="dt">State</span> {<span class="ot"> runState ::</span> s <span class="ot">-&gt;</span> (a, s) }</a></code></pre></div>
<p>It can help a lot when you’re threading around fiddly accumulators and so on.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="ot">nub ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">nub <span class="fu">=</span> go Set.empty</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-4" data-line-number="4">    go seen [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">    go seen (x<span class="fu">:</span>xs)</a>
<a class="sourceLine" id="cb15-6" data-line-number="6">      <span class="fu">|</span> x <span class="ot">`Set.member`</span> seen <span class="fu">=</span> go seen xs</a>
<a class="sourceLine" id="cb15-7" data-line-number="7">      <span class="fu">|</span> otherwise <span class="fu">=</span> x <span class="fu">:</span> go (Set.insert x seen) xs</a></code></pre></div>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="ot">nub ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">nub <span class="fu">=</span> flip evalState Set.empty <span class="fu">.</span> go</a>
<a class="sourceLine" id="cb16-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-4" data-line-number="4">    go [] <span class="fu">=</span> pure []</a>
<a class="sourceLine" id="cb16-5" data-line-number="5">    go (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb16-6" data-line-number="6">        seen <span class="ot">&lt;-</span> gets (Set.member x)</a>
<a class="sourceLine" id="cb16-7" data-line-number="7">        <span class="kw">if</span> seen</a>
<a class="sourceLine" id="cb16-8" data-line-number="8">          <span class="kw">then</span> go xs</a>
<a class="sourceLine" id="cb16-9" data-line-number="9">          <span class="kw">else</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb16-10" data-line-number="10">              modify (Set.insert x)</a>
<a class="sourceLine" id="cb16-11" data-line-number="11">              (x<span class="fu">:</span>) <span class="fu">&lt;$&gt;</span> go xs</a></code></pre></div>
<p>Of course, these days state is a transformer:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">StateT</span> s m a <span class="fu">=</span> <span class="dt">StateT</span> {<span class="ot"> runStateT ::</span> s <span class="ot">-&gt;</span> m (a, s) }</a></code></pre></div>
<p>This lets us stack multiple effects on top of each other: error handling, IO, randomness, even another state monad. In fact, if you <em>do</em> stack another state monad on top, you might be surprised by the efficiency of the code it generates:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="kw">type</span> <span class="dt">DoubleState</span> s1 s2 a <span class="fu">=</span> <span class="dt">StateT</span> s1 (<span class="dt">State</span> s2) a</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">                        <span class="ot">=&gt;</span> s1 <span class="ot">-&gt;</span> <span class="dt">State</span> s2 (a, s1)</a>
<a class="sourceLine" id="cb18-3" data-line-number="3">                        <span class="ot">=&gt;</span> s1 <span class="ot">-&gt;</span> s2 <span class="ot">-&gt;</span> ((a, s1), s2)</a></code></pre></div>
<p>It’s nothing earth shattering, but it inlines and optimises well. That output is effectively a left-nested list, also.</p>
<h1 id="multi-state">Multi-State</h1>
<p>If we can do one, and we can do two, why not more? Can we generalise the state pattern to an arbitrary number of variables? First we’ll need a generic tuple:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:-</span></a>
<a class="sourceLine" id="cb19-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Stack</span> (<span class="ot">xs ::</span> [<span class="dt">Type</span>])<span class="ot"> ::</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-3" data-line-number="3">    <span class="dt">Nil</span><span class="ot">  ::</span> <span class="dt">Stack</span> <span class="ch">'[]</span></a>
<a class="sourceLine" id="cb19-4" data-line-number="4"><span class="ot">    (:-) ::</span> x <span class="ot">-&gt;</span> <span class="dt">Stack</span> xs <span class="ot">-&gt;</span> <span class="dt">Stack</span> (x <span class="fu">:</span> xs)</a></code></pre></div>
<p>Then, the state type.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">State</span> xs a <span class="fu">=</span> <span class="dt">State</span> {<span class="ot"> runState ::</span> <span class="dt">Stack</span> xs <span class="ot">-&gt;</span> (a, <span class="dt">Stack</span> xs) }</a></code></pre></div>
<p>We can actually clean the definition up a little: instead of a tuple at the other end, why not push it onto the stack.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">State</span> xs a <span class="fu">=</span> <span class="dt">State</span> {<span class="ot"> runState ::</span> <span class="dt">Stack</span> xs <span class="ot">-&gt;</span> <span class="dt">Stack</span> (a <span class="fu">:</span> xs) }</a></code></pre></div>
<p>In fact, let’s make this as polymorphic as possible. We should be able to change the state is we so desire.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">0</span> <span class="fu">:-&gt;</span></a>
<a class="sourceLine" id="cb22-2" data-line-number="2"><span class="kw">type</span> (<span class="fu">:-&gt;</span>) xs ys <span class="fu">=</span> <span class="dt">Stack</span> xs <span class="ot">-&gt;</span> <span class="dt">Stack</span> ys</a></code></pre></div>
<p>And suddenly, our endomorphism type from above shows up again.</p>
<p>We can, of course, get back our original types.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">State</span> xs a <span class="fu">=</span> <span class="dt">State</span> {<span class="ot"> runState ::</span> xs <span class="fu">:-&gt;</span> a <span class="fu">:</span> xs }</a></code></pre></div>
<p>And it comes with all of the instances you might expect:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">State</span> xs) <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-2" data-line-number="2">    fmap f xs <span class="fu">=</span> <span class="dt">State</span> (\s <span class="ot">-&gt;</span> <span class="kw">case</span> runState xs s <span class="kw">of</span></a>
<a class="sourceLine" id="cb24-3" data-line-number="3">        (x <span class="fu">:-</span> ys) <span class="ot">-&gt;</span> f x <span class="fu">:-</span> ys)</a>
<a class="sourceLine" id="cb24-4" data-line-number="4">        </a>
<a class="sourceLine" id="cb24-5" data-line-number="5"><span class="kw">instance</span> <span class="dt">Applicative</span> (<span class="dt">State</span> xs) <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-6" data-line-number="6">    pure x <span class="fu">=</span> <span class="dt">State</span> (x <span class="fu">:-</span>)</a>
<a class="sourceLine" id="cb24-7" data-line-number="7">    fs <span class="fu">&lt;*&gt;</span> xs <span class="fu">=</span> <span class="dt">State</span> (\s <span class="ot">-&gt;</span> <span class="kw">case</span> runState fs s <span class="kw">of</span></a>
<a class="sourceLine" id="cb24-8" data-line-number="8">        (f <span class="fu">:-</span> s') <span class="ot">-&gt;</span> <span class="kw">case</span> runState xs s' <span class="kw">of</span></a>
<a class="sourceLine" id="cb24-9" data-line-number="9">            (x <span class="fu">:-</span> s'') <span class="ot">-&gt;</span> f x <span class="fu">:-</span> s'')</a>
<a class="sourceLine" id="cb24-10" data-line-number="10">            </a>
<a class="sourceLine" id="cb24-11" data-line-number="11"><span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">State</span> xs) <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-12" data-line-number="12">    xs <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">State</span> (\s <span class="ot">-&gt;</span> <span class="kw">case</span> runState xs s <span class="kw">of</span></a>
<a class="sourceLine" id="cb24-13" data-line-number="13">        y <span class="fu">:-</span> ys <span class="ot">-&gt;</span> runState (f y) ys)</a></code></pre></div>
<h1 id="polymorphism">Polymorphism</h1>
<p>But what’s the point? So far we’ve basically just encoded an unnecessarily complicated state transformer. Think back to the stacking of states. Written in the <a href="https://hackage.haskell.org/package/mtl">mtl</a> style, the main advantage of stacking monads like that is you can write code like the following:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="ot">pop ::</span> (<span class="dt">MonadState</span> [a] m, <span class="dt">MonadError</span> <span class="dt">String</span> m) <span class="ot">=&gt;</span> m a</a>
<a class="sourceLine" id="cb25-2" data-line-number="2">pop <span class="fu">=</span> get <span class="fu">&gt;&gt;=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb25-3" data-line-number="3">    [] <span class="ot">-&gt;</span> throwError <span class="st">&quot;pop: empty list&quot;</span></a>
<a class="sourceLine" id="cb25-4" data-line-number="4">    x<span class="fu">:</span>xs <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb25-5" data-line-number="5">        put xs </a>
<a class="sourceLine" id="cb25-6" data-line-number="6">        pure x</a></code></pre></div>
<p>In other words, we don’t care about the rest of <code>m</code>, we just care that it has, somewhere, state for an <code>[a]</code>.</p>
<p>This logic should apply to our stack transformer, as well. If it only cares about the top two variables, it shouldn’t care what the rest of the list is. In types:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">0</span> <span class="fu">:-&gt;</span></a>
<a class="sourceLine" id="cb26-2" data-line-number="2"><span class="kw">type</span> (<span class="fu">:-&gt;</span>) xs ys <span class="fu">=</span> forall zs<span class="fu">.</span> <span class="dt">Stack</span> (xs <span class="fu">++</span> zs) <span class="ot">-&gt;</span> <span class="dt">Stack</span> (ys <span class="fu">++</span> zs)</a></code></pre></div>
<p>And straight away we can write some of the standard combinators:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="ot">dup ::</span> <span class="ch">'[a] :-&gt; '</span>[a,a]</a>
<a class="sourceLine" id="cb27-2" data-line-number="2">dup (x <span class="fu">:-</span> xs) <span class="fu">=</span> (x <span class="fu">:-</span> x <span class="fu">:-</span> xs)</a>
<a class="sourceLine" id="cb27-3" data-line-number="3"></a>
<a class="sourceLine" id="cb27-4" data-line-number="4"><span class="ot">swap ::</span> <span class="ch">'[x,y] :-&gt; '</span>[y,x]</a>
<a class="sourceLine" id="cb27-5" data-line-number="5">swap (x <span class="fu">:-</span> y <span class="fu">:-</span> xs) <span class="fu">=</span> y <span class="fu">:-</span> x <span class="fu">:-</span> xs</a>
<a class="sourceLine" id="cb27-6" data-line-number="6"></a>
<a class="sourceLine" id="cb27-7" data-line-number="7">drop<span class="ot"> ::</span> <span class="ch">'[x,y] :-&gt; '</span>[y]</a>
<a class="sourceLine" id="cb27-8" data-line-number="8">drop (_ <span class="fu">:-</span> xs) <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb27-9" data-line-number="9"></a>
<a class="sourceLine" id="cb27-10" data-line-number="10"><span class="kw">infixl</span> <span class="dv">9</span> <span class="fu">!</span></a>
<a class="sourceLine" id="cb27-11" data-line-number="11">(f <span class="fu">!</span> g) x <span class="fu">=</span> g (f x)</a></code></pre></div>
<p>You’ll immediately run into trouble if you try to work with some of the more involved combinators, though. Quote should have the following type, for instance:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1"><span class="ot">quote ::</span> (xs <span class="fu">:-&gt;</span> ys) <span class="ot">-&gt;</span> <span class="ch">'[] :-&gt; '</span>[ xs <span class="fu">:-&gt;</span> ys ]</a></code></pre></div>
<p>But GHC complains again:</p>
<pre><code>• Illegal polymorphic type: xs :-&gt; ys
  GHC doesn't yet support impredicative polymorphism
• In the type signature:
    quote :: (xs :-&gt; ys) -&gt; '[] :-&gt; '[xs :-&gt; ys]</code></pre>
<p>I won’t go into the detail of this particular error: if you’ve been around the block with Haskell you know that it means “wrap it in a newtype”. If we do <em>that</em>, though, we get yet more errors:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="kw">newtype</span> (<span class="fu">:~&gt;</span>) xs ys <span class="fu">=</span> <span class="dt">Q</span> {<span class="ot"> d ::</span> xs <span class="fu">:-&gt;</span> ys }</a></code></pre></div>
<pre><code>• Couldn't match type ‘ys ++ zs0’ with ‘ys ++ zs’
  Expected type: Stack (xs ++ zs) -&gt; Stack (ys ++ zs)
    Actual type: Stack (xs ++ zs0) -&gt; Stack (ys ++ zs0)
  NB: ‘++’ is a type function, and may not be injective</code></pre>
<p>This injectivity error comes up often. It means that GHC needs to prove that the input to two functions is equal, but it only knows that their outputs are. This is a doubly serious problem for us, as we can’t do type family injectivity on two type variables (in current Haskell). To solve the problem, we need to rely on a weird mishmash of type families and functional dependencies:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" data-line-number="1"><span class="kw">type</span> family (<span class="fu">++</span>) xs ys <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-2" data-line-number="2">    <span class="ch">'[] ++ ys = ys</span></a>
<a class="sourceLine" id="cb32-3" data-line-number="3">    (x <span class="fu">:</span> xs) <span class="fu">++</span> ys <span class="fu">=</span> x <span class="fu">:</span> (xs <span class="fu">++</span> ys)</a>
<a class="sourceLine" id="cb32-4" data-line-number="4">    </a>
<a class="sourceLine" id="cb32-5" data-line-number="5"><span class="kw">class</span> (xs <span class="fu">++</span> ys <span class="fu">~</span> zs) <span class="ot">=&gt;</span> <span class="dt">Conc</span> xs ys zs <span class="fu">|</span> xs zs <span class="ot">-&gt;</span> ys <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-6" data-line-number="6"><span class="ot">    conc ::</span> <span class="dt">Stack</span> xs <span class="ot">-&gt;</span> <span class="dt">Stack</span> ys <span class="ot">-&gt;</span> <span class="dt">Stack</span> zs</a>
<a class="sourceLine" id="cb32-7" data-line-number="7">    </a>
<a class="sourceLine" id="cb32-8" data-line-number="8"><span class="kw">instance</span> <span class="dt">Conc</span> <span class="ch">'[] ys ys where</span></a>
<a class="sourceLine" id="cb32-9" data-line-number="9">    conc _ ys <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb32-10" data-line-number="10">    </a>
<a class="sourceLine" id="cb32-11" data-line-number="11"><span class="kw">instance</span> <span class="dt">Conc</span> xs ys zs <span class="ot">=&gt;</span> <span class="dt">Conc</span> (x <span class="fu">:</span> xs) ys (x <span class="fu">:</span> zs) <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-12" data-line-number="12">    conc (x <span class="fu">:-</span> xs) ys <span class="fu">=</span> x <span class="fu">:-</span> conc xs ys</a>
<a class="sourceLine" id="cb32-13" data-line-number="13"></a>
<a class="sourceLine" id="cb32-14" data-line-number="14"><span class="kw">infixr</span> <span class="dv">0</span> <span class="fu">:-&gt;</span></a>
<a class="sourceLine" id="cb32-15" data-line-number="15"><span class="kw">type</span> (<span class="fu">:-&gt;</span>) xs ys <span class="fu">=</span> forall zs yszs<span class="fu">.</span> <span class="dt">Conc</span> ys zs yszs <span class="ot">=&gt;</span> <span class="dt">Stack</span> (xs <span class="fu">++</span> zs) <span class="ot">-&gt;</span> <span class="dt">Stack</span> yszs</a></code></pre></div>
<p>And it does indeed work:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" data-line-number="1">pure<span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="ch">'[] :-&gt; '</span>[a]</a>
<a class="sourceLine" id="cb33-2" data-line-number="2">pure <span class="fu">=</span> (<span class="fu">:-</span>)</a>
<a class="sourceLine" id="cb33-3" data-line-number="3"></a>
<a class="sourceLine" id="cb33-4" data-line-number="4"><span class="kw">newtype</span> (<span class="fu">:~&gt;</span>) xs ys <span class="fu">=</span> <span class="dt">Q</span> {<span class="ot"> d ::</span> xs <span class="fu">:-&gt;</span> ys }</a>
<a class="sourceLine" id="cb33-5" data-line-number="5"></a>
<a class="sourceLine" id="cb33-6" data-line-number="6"><span class="ot">quote ::</span> (xs <span class="fu">:-&gt;</span> ys) <span class="ot">-&gt;</span> <span class="ch">'[] :-&gt; '</span>[ xs <span class="fu">:~&gt;</span> ys ]</a>
<a class="sourceLine" id="cb33-7" data-line-number="7">quote x <span class="fu">=</span> pure (<span class="dt">Q</span> x)</a>
<a class="sourceLine" id="cb33-8" data-line-number="8"></a>
<a class="sourceLine" id="cb33-9" data-line-number="9"><span class="ot">dot ::</span> forall xs ys<span class="fu">.</span> ((xs <span class="fu">:~&gt;</span> ys) <span class="fu">:</span> xs) <span class="fu">:-&gt;</span> ys</a>
<a class="sourceLine" id="cb33-10" data-line-number="10">dot (x <span class="fu">:-</span> xs) <span class="fu">=</span> d x xs</a>
<a class="sourceLine" id="cb33-11" data-line-number="11"></a>
<a class="sourceLine" id="cb33-12" data-line-number="12"><span class="ot">true ::</span> (xs <span class="fu">:~&gt;</span> ys) <span class="fu">:</span> (xs <span class="fu">:~&gt;</span> ys) <span class="fu">:</span> xs <span class="fu">:-&gt;</span> ys</a>
<a class="sourceLine" id="cb33-13" data-line-number="13">true <span class="fu">=</span> swap <span class="fu">!</span> drop <span class="fu">!</span> dot</a>
<a class="sourceLine" id="cb33-14" data-line-number="14"></a>
<a class="sourceLine" id="cb33-15" data-line-number="15"><span class="ot">false ::</span> (xs <span class="fu">:~&gt;</span> ys) <span class="fu">:</span> (xs <span class="fu">:~&gt;</span> ys) <span class="fu">:</span> xs <span class="fu">:-&gt;</span> ys</a>
<a class="sourceLine" id="cb33-16" data-line-number="16">false <span class="fu">=</span> drop <span class="fu">!</span> dot</a>
<a class="sourceLine" id="cb33-17" data-line-number="17"></a>
<a class="sourceLine" id="cb33-18" data-line-number="18"><span class="ot">test ::</span> <span class="ch">'[] :-&gt; '</span>[ <span class="ch">'[a] :~&gt; '</span>[a,a] ]</a>
<a class="sourceLine" id="cb33-19" data-line-number="19">test <span class="fu">=</span> quote dup</a></code></pre></div>
<p>Interestingly, these combinators represent the monadic operations on state (<code>dot</code> = <code>join</code>, <code>pure</code> = <code>pure</code>, etc.)</p>
<p>And can we get the nicer composition of the function from the intro? Kind of:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" data-line-number="1">sumAdded <span class="fu">=</span> quote add <span class="fu">!</span> curry <span class="fu">!</span> dot <span class="fu">!</span> map <span class="fu">!</span> sum</a></code></pre></div>
<p>Here are some references for concatenative languages: <span class="citation" data-cites="okasaki_techniques_2002">Okasaki (<a href="#ref-okasaki_techniques_2002">2002</a>)</span>, <span class="citation" data-cites="purdy_big_2012">Purdy (<a href="#ref-purdy_big_2012">2012</a>)</span>, <span class="citation" data-cites="kerby_theory_2007">Kerby (<a href="#ref-kerby_theory_2007">2007</a>)</span>, <span class="citation" data-cites="okasaki_theoretical_2003">Okasaki (<a href="#ref-okasaki_theoretical_2003">2003</a>)</span>.</p>
<div id="refs" class="references">
<div id="ref-kerby_theory_2007">
<p>Kerby, Brent. 2007. “The Theory of Concatenative Combinators.” <a href="http://tunes.org/\%7Eiepos/joy.html">http://tunes.org/\%7Eiepos/joy.html</a>.</p>
</div>
<div id="ref-okasaki_techniques_2002">
<p>Okasaki, Chris. 2002. “Techniques for embedding postfix languages in Haskell.” In <em>Proceedings of the ACM SIGPLAN workshop on Haskell - Haskell ’02</em>, 105–113. Pittsburgh, Pennsylvania: ACM Press. doi:<a href="https://doi.org/10.1145/581690.581699">10.1145/581690.581699</a>. <a href="http://portal.acm.org/citation.cfm?doid=581690.581699" class="uri">http://portal.acm.org/citation.cfm?doid=581690.581699</a>.</p>
</div>
<div id="ref-okasaki_theoretical_2003">
<p>———. 2003. “THEORETICAL PEARLS: Flattening combinators: Surviving without parentheses.” <em>Journal of Functional Programming</em> 13 (4) (July): 815–822. doi:<a href="https://doi.org/10.1017/S0956796802004483">10.1017/S0956796802004483</a>. <a href="https://www.cambridge.org/core/journals/journal-of-functional-programming/article/theoretical-pearls/3E99993FE5464986AD94D292FF5EA275" class="uri">https://www.cambridge.org/core/journals/journal-of-functional-programming/article/theoretical-pearls/3E99993FE5464986AD94D292FF5EA275</a>.</p>
</div>
<div id="ref-purdy_big_2012">
<p>Purdy, Jon. 2012. “The Big Mud Puddle: Why Concatenative Programming Matters.” <em>The Big Mud Puddle</em>. <a href="https://evincarofautumn.blogspot.com/2012/02/why-concatenative-programming-matters.html" class="uri">https://evincarofautumn.blogspot.com/2012/02/why-concatenative-programming-matters.html</a>.</p>
</div>
</div>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
