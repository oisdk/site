<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Terminating Tricky Traversals - Donnacha Oisín Kidney</title>
        <style>body{color:black;font-family:Garamond,Times New Roman,serif;font-size:14px;margin:0px auto 0px auto;padding-left:5px;padding-right:5px;max-width:600px}math{font-size:13px}img{max-width:600px}div#header{border-bottom:3px double black;margin-bottom:30px;padding:12px 0px 12px 0px}div#logo a{color:black;float:left;font-size:20px;text-decoration:none}div#header #navigation{text-align:right}div#header #navigation a{color:black;font-family:Garamond,Times New Roman,Serif;font-size:18px;margin-left:10px;text-decoration:none;text-transform:uppercase}div#footer{font-family:Garamond,Times New Roman,Serif;border-top:solid 2px black;color:#555;font-size:12px;margin-top:30px;padding:12px 0px 12px 0px;text-align:right}h1{font-family:Garamond,Times New Roman,Serif;font-size:22px;font-weight:normal}h2{font-family:Garamond,Times New Roman,Serif;font-size:20px;font-weight:normal}div.info{color:#555;font-size:15px;font-style:italic}span.quiet{color:#828282;font-style:italic}a{color:black;word-wrap:break-word}ul.post-list{margin-left:0px;padding-left:0px;list-style-type:none}.hidden_source{display:none}ol.serieslist{counter-reset:item;list-style-type:none;padding-left:20}ol li.serieslist:before{content:'Part ' counter(item,decimal) ':';counter-increment:item}table.sourceCode,tr.sourceCode,td.lineNumbers,td.sourceCode,table.sourceCode pre{margin:0;padding:0;border:0;vertical-align:baseline;border:none}td.lineNumbers{border-right:1px solid #AAAAAA;text-align:right;color:#AAAAAA;padding-right:5px;padding-left:5px}td.sourceCode{padding-left:5px}.sourceCode,code,.Agda{font-size:10px;font-family:menlo,monospace}.sourceCode span.kw{color:#262C6A}.sourceCode span.dt{color:#476A97}.sourceCode span.dv{color:#262C6A}.sourceCode span.bn{color:#262C6A}.sourceCode span.fl{color:#262C6A}.sourceCode span.ch{color:#262C6A}.sourceCode span.st{color:#702C51}.sourceCode span.co{color:#435138}.sourceCode span.ot{color:#262C6A}.sourceCode span.al{color:red}.sourceCode span.fu{color:#000000}.sourceCode span.re{color:#000000}.sourceCode span.er{color:red}li{margin-bottom:2px}li:last-child{margin-bottom:0px}.Agda .Comment{color:#B22222}.Agda .Background{}.Agda .Markup{color:#000000}.Agda .Keyword{color:#CD6600}.Agda .String{color:#B22222}.Agda .Number{color:#A020F0}.Agda .Symbol{color:#404040}.Agda .PrimitiveType{color:#0000CD}.Agda .Pragma{color:black}.Agda .Operator{}.Agda .Bound{color:black}.Agda .Generalizable{color:black}.Agda .InductiveConstructor{color:#008B00}.Agda .CoinductiveConstructor{color:#8B7500}.Agda .Datatype{color:#0000CD}.Agda .Field{color:#EE1289}.Agda .Function{color:#0000CD}.Agda .Module{color:#A020F0}.Agda .Postulate{color:#0000CD}.Agda .Primitive{color:#0000CD}.Agda .Record{color:#0000CD}.Agda .DottedPattern{}.Agda .UnsolvedMeta{color:black;background:yellow}.Agda .UnsolvedConstraint{color:black;background:yellow}.Agda .TerminationProblem{color:black;background:#FFA07A}.Agda .IncompletePattern{color:black;background:#F5DEB3}.Agda .Error{color:red;text-decoration:underline}.Agda .TypeChecks{color:black;background:#ADD8E6}.Agda a{text-decoration:none}.Agda a[href]:hover{background-color:#B4EEB4}.sourceCode{overflow-x:auto}</style>
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Donnacha Oisín Kidney</a>
            </div>
            <div id="navigation">
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../rss.xml">Feed</a>
                <a href="../snippets.html">Snippets</a>
            </div>
        </div>

        <div id="content">
            <h2>Terminating Tricky Traversals</h2>

            <div class="info">
    Posted on January 29, 2020
</div>
<div class="info">
    
        Part 8 of a <a href="../series/Breadth-First%20Traversals.html">9-part series on Breadth-First Traversals</a>
    
</div>
<div class="info">
    
        Tags: <a href="../tags/Agda.html">Agda</a>, <a href="../tags/Haskell.html">Haskell</a>
    
</div>

<details>
<p><summary> Imports </summary></p>
<pre class="Agda"><a id="192" class="Symbol">{-#</a> <a id="196" class="Keyword">OPTIONS</a> <a id="204" class="Pragma">--cubical</a> <a id="214" class="Pragma">--sized-types</a> <a id="228" class="Symbol">#-}</a>

<a id="233" class="Keyword">module</a> <a id="240" href class="Module">Post</a> <a id="245" class="Keyword">where</a>

<a id="252" class="Keyword">open</a> <a id="257" class="Keyword">import</a> <a id="264" href="../code/terminating-tricky-traversals/Post.Prelude.html" class="Module">../code/terminating-tricky-traversals/Post.Prelude</a>
</pre>
</details>
<p>Just a short one today. I’m going to look at a couple of algorithms for breadth-first traversals with complex termination proofs.</p>
<h1 id="breadth-first-graph-traversal">Breadth-First Graph Traversal</h1>
<p>In a previous post I talked about breadth-first traversals over graphs, and the difficulties that cycles cause. Graphs are especially tricky to work with in a purely functional language, because so many of the basic algorithms are described in explicitly mututing terms (i.e. “mark off a node as you see it”), with no obvious immutable translation. The following is the last algoirthm I came up with:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">bfs ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> [a]) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">bfs g r <span class="fu">=</span> takeWhile (not<span class="fu">.</span>null) (map fst (fix (f r <span class="fu">.</span> push)))</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">    push xs <span class="fu">=</span> ([],Set.empty) <span class="fu">:</span> [ ([],seen) <span class="fu">|</span> (_,seen) <span class="ot">&lt;-</span> xs ]</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">    f x q<span class="fu">@</span>((l,s)<span class="fu">:</span>qs)</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">      <span class="fu">|</span> Set.member x s <span class="fu">=</span> q</a>
<a class="sourceLine" id="cb1-7" data-line-number="7">      <span class="fu">|</span> otherwise <span class="fu">=</span> (x<span class="fu">:</span>l, Set.insert x s) <span class="fu">:</span> foldr f qs (g x)</a></code></pre></div>
<p>As difficult as it is to work with graphs in a pure functional language, it’s even <em>more</em> difficult to work in a <em>total</em> language, like Agda. Looking at the above function, there are several bits that we can see right off the bat won’t translate over easily. Let’s start with <code>fix</code>.</p>
<p>We shouldn’t expect to be able to write <code>fix</code> in Agda as-is. Just look at its Haskell implementation:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">fix ::</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">fix f <span class="fu">=</span> f (fix f)</a></code></pre></div>
<p>It’s obviously non total!</p>
<p>(this is actually a non-memoizing version of <code>fix</code>, which is different from the <a href="https://stackoverflow.com/questions/37366222/why-is-this-version-of-fix-more-efficient-in-haskell/37366374">usual one</a>)</p>
<p>We can write a function <em>like</em> <code>fix</code>, though, using coinduction and sized types.</p>
<pre class="Agda"><a id="1890" class="Keyword">record</a> <a id="Thunk"></a><a id="1897" href="#1897" class="Record">Thunk</a> <a id="1903" class="Symbol">(</a><a id="1904" href="#1904" class="Bound">A</a> <a id="1906" class="Symbol">:</a> <a id="1908" href="../code/terminating-tricky-traversals/Agda.Builtin.Size.html#179" class="Postulate">Size</a> <a id="1913" class="Symbol">→</a> <a id="1915" href="../code/terminating-tricky-traversals/Cubical.Core.Primitives.html#957" class="Function">Type</a> <a id="1920" href="../code/terminating-tricky-traversals/Post.Prelude.html#221" class="Generalizable">a</a><a id="1921" class="Symbol">)</a> <a id="1923" class="Symbol">(</a><a id="1924" href="#1924" class="Bound">i</a> <a id="1926" class="Symbol">:</a> <a id="1928" href="../code/terminating-tricky-traversals/Agda.Builtin.Size.html#179" class="Postulate">Size</a><a id="1932" class="Symbol">)</a> <a id="1934" class="Symbol">:</a> <a id="1936" href="../code/terminating-tricky-traversals/Cubical.Core.Primitives.html#957" class="Function">Type</a> <a id="1941" href="#1920" class="Bound">a</a> <a id="1943" class="Keyword">where</a>
  <a id="1951" class="Keyword">coinductive</a>
  <a id="1965" class="Keyword">field</a> <a id="Thunk.force"></a><a id="1971" href="#1971" class="Field">force</a> <a id="1977" class="Symbol">:</a> <a id="1979" class="Symbol">∀</a> <a id="1981" class="Symbol">{</a><a id="1982" href="#1982" class="Bound">j</a> <a id="1984" class="Symbol">:</a> <a id="1986" href="../code/terminating-tricky-traversals/Agda.Builtin.Size.html#211" class="Postulate Operator">Size&lt;</a> <a id="1992" href="#1924" class="Bound">i</a><a id="1993" class="Symbol">}</a> <a id="1995" class="Symbol">→</a> <a id="1997" href="#1904" class="Bound">A</a> <a id="1999" href="#1982" class="Bound">j</a>
<a id="2001" class="Keyword">open</a> <a id="2006" href="#1897" class="Module">Thunk</a> <a id="2012" class="Keyword">public</a>

<a id="fix"></a><a id="2020" href="#2020" class="Function">fix</a> <a id="2024" class="Symbol">:</a> <a id="2026" class="Symbol">(</a><a id="2027" href="#2027" class="Bound">A</a> <a id="2029" class="Symbol">:</a> <a id="2031" href="../code/terminating-tricky-traversals/Agda.Builtin.Size.html#179" class="Postulate">Size</a> <a id="2036" class="Symbol">→</a> <a id="2038" href="../code/terminating-tricky-traversals/Cubical.Core.Primitives.html#957" class="Function">Type</a> <a id="2043" href="../code/terminating-tricky-traversals/Post.Prelude.html#221" class="Generalizable">a</a><a id="2044" class="Symbol">)</a> <a id="2046" class="Symbol">→</a> <a id="2048" class="Symbol">(∀</a> <a id="2051" class="Symbol">{</a><a id="2052" href="#2052" class="Bound">i</a><a id="2053" class="Symbol">}</a> <a id="2055" class="Symbol">→</a> <a id="2057" href="#1897" class="Record">Thunk</a> <a id="2063" href="#2027" class="Bound">A</a> <a id="2065" href="#2052" class="Bound">i</a> <a id="2067" class="Symbol">→</a> <a id="2069" href="#2027" class="Bound">A</a> <a id="2071" href="#2052" class="Bound">i</a><a id="2072" class="Symbol">)</a> <a id="2074" class="Symbol">→</a> <a id="2076" class="Symbol">∀</a> <a id="2078" class="Symbol">{</a><a id="2079" href="#2079" class="Bound">j</a><a id="2080" class="Symbol">}</a> <a id="2082" class="Symbol">→</a> <a id="2084" href="#2027" class="Bound">A</a> <a id="2086" href="#2079" class="Bound">j</a>
<a id="2088" href="#2020" class="Function">fix</a> <a id="2092" href="#2092" class="Bound">A</a> <a id="2094" href="#2094" class="Bound">f</a> <a id="2096" class="Symbol">=</a> <a id="2098" href="#2094" class="Bound">f</a> <a id="2100" class="Symbol">λ</a> <a id="2102" class="Keyword">where</a> <a id="2108" class="Symbol">.</a><a id="2109" href="#1971" class="Field">force</a> <a id="2115" class="Symbol">→</a> <a id="2117" href="#2020" class="Function">fix</a> <a id="2121" href="#2092" class="Bound">A</a> <a id="2123" href="#2094" class="Bound">f</a>
</pre>
<p>Coinductive types are the dual to inductive types. Totality-wise, a coinductive type must be “productive”; i.e. a coinductive list can be infinitely long, but it must be provably able to evaluate to a constructor (cons or nil) in finite time.</p>
<p>Sized types also help us out here: they’re quite subtle, and a little finicky to use occasionally, but they are invaluable when it comes to proving termination or productivity of complex (especially higher-order) functions. The canonical example is mapping over the following tree type:</p>
<pre class="Agda"><a id="2670" class="Keyword">module</a> <a id="NonTerminating"></a><a id="2677" href="#2677" class="Module">NonTerminating</a> <a id="2692" class="Keyword">where</a>
  <a id="2700" class="Keyword">data</a> <a id="NonTerminating.Tree"></a><a id="2705" href="#2705" class="Datatype">Tree</a> <a id="2710" class="Symbol">(</a><a id="2711" href="#2711" class="Bound">A</a> <a id="2713" class="Symbol">:</a> <a id="2715" href="../code/terminating-tricky-traversals/Cubical.Core.Primitives.html#957" class="Function">Type</a> <a id="2720" href="../code/terminating-tricky-traversals/Post.Prelude.html#221" class="Generalizable">a</a><a id="2721" class="Symbol">)</a> <a id="2723" class="Symbol">:</a> <a id="2725" href="../code/terminating-tricky-traversals/Cubical.Core.Primitives.html#957" class="Function">Type</a> <a id="2730" href="#2720" class="Bound">a</a> <a id="2732" class="Keyword">where</a>
    <a id="NonTerminating.Tree._&amp;_"></a><a id="2742" href="#2742" class="InductiveConstructor Operator">_&amp;_</a> <a id="2746" class="Symbol">:</a> <a id="2748" href="#2711" class="Bound">A</a> <a id="2750" class="Symbol">→</a> <a id="2752" href="../code/terminating-tricky-traversals/Post.Prelude.html#507" class="Datatype">List</a> <a id="2757" class="Symbol">(</a><a id="2758" href="#2705" class="Datatype">Tree</a> <a id="2763" href="#2711" class="Bound">A</a><a id="2764" class="Symbol">)</a> <a id="2766" class="Symbol">→</a> <a id="2768" href="#2705" class="Datatype">Tree</a> <a id="2773" href="#2711" class="Bound">A</a>

  <a id="2778" class="Symbol">{-#</a> <a id="2782" class="Keyword">TERMINATING</a> <a id="2794" class="Symbol">#-}</a>
  <a id="NonTerminating.mapTree"></a><a id="2800" href="#2800" class="Function">mapTree</a> <a id="2808" class="Symbol">:</a> <a id="2810" class="Symbol">(</a><a id="2811" href="../code/terminating-tricky-traversals/Post.Prelude.html#237" class="Generalizable">A</a> <a id="2813" class="Symbol">→</a> <a id="2815" href="../code/terminating-tricky-traversals/Post.Prelude.html#250" class="Generalizable">B</a><a id="2816" class="Symbol">)</a> <a id="2818" class="Symbol">→</a> <a id="2820" href="#2705" class="Datatype">Tree</a> <a id="2825" href="../code/terminating-tricky-traversals/Post.Prelude.html#237" class="Generalizable">A</a> <a id="2827" class="Symbol">→</a> <a id="2829" href="#2705" class="Datatype">Tree</a> <a id="2834" href="../code/terminating-tricky-traversals/Post.Prelude.html#250" class="Generalizable">B</a>
  <a id="2838" href="#2800" class="Function">mapTree</a> <a id="2846" href="#2846" class="Bound">f</a> <a id="2848" class="Symbol">(</a><a id="2849" href="#2849" class="Bound">x</a> <a id="2851" href="#2742" class="InductiveConstructor Operator">&amp;</a> <a id="2853" href="#2853" class="Bound">xs</a><a id="2855" class="Symbol">)</a> <a id="2857" class="Symbol">=</a> <a id="2859" href="#2846" class="Bound">f</a> <a id="2861" href="#2849" class="Bound">x</a> <a id="2863" href="#2742" class="InductiveConstructor Operator">&amp;</a> <a id="2865" href="../code/terminating-tricky-traversals/Post.Prelude.html#678" class="Function">map</a> <a id="2869" class="Symbol">(</a><a id="2870" href="#2800" class="Function">mapTree</a> <a id="2878" href="#2846" class="Bound">f</a><a id="2879" class="Symbol">)</a> <a id="2881" href="#2853" class="Bound">xs</a>
</pre>
<p>The compiler can’t tell that the recursive call in the <code>mapTree</code> function will only be called on subnodes of the argument: it can’t tell that it’s structurally recursive, in other words. Annoyingly, we can fix the problem by inlining <code>map</code>.</p>
<pre class="Agda">  <a id="3141" class="Keyword">mutual</a>
    <a id="NonTerminating.mapTree′"></a><a id="3152" href="#3152" class="Function">mapTree′</a> <a id="3161" class="Symbol">:</a> <a id="3163" class="Symbol">(</a><a id="3164" href="../code/terminating-tricky-traversals/Post.Prelude.html#237" class="Generalizable">A</a> <a id="3166" class="Symbol">→</a> <a id="3168" href="../code/terminating-tricky-traversals/Post.Prelude.html#250" class="Generalizable">B</a><a id="3169" class="Symbol">)</a> <a id="3171" class="Symbol">→</a> <a id="3173" href="#2705" class="Datatype">Tree</a> <a id="3178" href="../code/terminating-tricky-traversals/Post.Prelude.html#237" class="Generalizable">A</a> <a id="3180" class="Symbol">→</a> <a id="3182" href="#2705" class="Datatype">Tree</a> <a id="3187" href="../code/terminating-tricky-traversals/Post.Prelude.html#250" class="Generalizable">B</a>
    <a id="3193" href="#3152" class="Function">mapTree′</a> <a id="3202" href="#3202" class="Bound">f</a> <a id="3204" class="Symbol">(</a><a id="3205" href="#3205" class="Bound">x</a> <a id="3207" href="#2742" class="InductiveConstructor Operator">&amp;</a> <a id="3209" href="#3209" class="Bound">xs</a><a id="3211" class="Symbol">)</a> <a id="3213" class="Symbol">=</a> <a id="3215" href="#3202" class="Bound">f</a> <a id="3217" href="#3205" class="Bound">x</a> <a id="3219" href="#2742" class="InductiveConstructor Operator">&amp;</a> <a id="3221" href="#3241" class="Function">mapForest</a> <a id="3231" href="#3202" class="Bound">f</a> <a id="3233" href="#3209" class="Bound">xs</a>

    <a id="NonTerminating.mapForest"></a><a id="3241" href="#3241" class="Function">mapForest</a> <a id="3251" class="Symbol">:</a> <a id="3253" class="Symbol">(</a><a id="3254" href="../code/terminating-tricky-traversals/Post.Prelude.html#237" class="Generalizable">A</a> <a id="3256" class="Symbol">→</a> <a id="3258" href="../code/terminating-tricky-traversals/Post.Prelude.html#250" class="Generalizable">B</a><a id="3259" class="Symbol">)</a> <a id="3261" class="Symbol">→</a> <a id="3263" href="../code/terminating-tricky-traversals/Post.Prelude.html#507" class="Datatype">List</a> <a id="3268" class="Symbol">(</a><a id="3269" href="#2705" class="Datatype">Tree</a> <a id="3274" href="../code/terminating-tricky-traversals/Post.Prelude.html#237" class="Generalizable">A</a><a id="3275" class="Symbol">)</a> <a id="3277" class="Symbol">→</a> <a id="3279" href="../code/terminating-tricky-traversals/Post.Prelude.html#507" class="Datatype">List</a> <a id="3284" class="Symbol">(</a><a id="3285" href="#2705" class="Datatype">Tree</a> <a id="3290" href="../code/terminating-tricky-traversals/Post.Prelude.html#250" class="Generalizable">B</a><a id="3291" class="Symbol">)</a>
    <a id="3297" href="#3241" class="Function">mapForest</a> <a id="3307" href="#3307" class="Bound">f</a> <a id="3309" href="../code/terminating-tricky-traversals/Post.Prelude.html#542" class="InductiveConstructor">[]</a> <a id="3312" class="Symbol">=</a> <a id="3314" href="../code/terminating-tricky-traversals/Post.Prelude.html#542" class="InductiveConstructor">[]</a>
    <a id="3321" href="#3241" class="Function">mapForest</a> <a id="3331" href="#3331" class="Bound">f</a> <a id="3333" class="Symbol">(</a><a id="3334" href="#3334" class="Bound">x</a> <a id="3336" href="../code/terminating-tricky-traversals/Post.Prelude.html#556" class="InductiveConstructor Operator">∷</a> <a id="3338" href="#3338" class="Bound">xs</a><a id="3340" class="Symbol">)</a> <a id="3342" class="Symbol">=</a> <a id="3344" href="#3152" class="Function">mapTree′</a> <a id="3353" href="#3331" class="Bound">f</a> <a id="3355" href="#3334" class="Bound">x</a> <a id="3357" href="../code/terminating-tricky-traversals/Post.Prelude.html#556" class="InductiveConstructor Operator">∷</a> <a id="3359" href="#3241" class="Function">mapForest</a> <a id="3369" href="#3331" class="Bound">f</a> <a id="3371" href="#3338" class="Bound">xs</a>
</pre>
<p>The other solution is to give the tree a size parameter. This way, all submodes of a given tree will have smaller sizes, which will give the compiler a finite descending chain condition it can use to prove termination.</p>
<pre class="Agda"><a id="3606" class="Keyword">data</a> <a id="Tree"></a><a id="3611" href="#3611" class="Datatype">Tree</a> <a id="3616" class="Symbol">(</a><a id="3617" href="#3617" class="Bound">A</a> <a id="3619" class="Symbol">:</a> <a id="3621" href="../code/terminating-tricky-traversals/Cubical.Core.Primitives.html#957" class="Function">Type</a> <a id="3626" href="../code/terminating-tricky-traversals/Post.Prelude.html#221" class="Generalizable">a</a><a id="3627" class="Symbol">)</a> <a id="3629" class="Symbol">(</a><a id="3630" href="#3630" class="Bound">i</a> <a id="3632" class="Symbol">:</a> <a id="3634" href="../code/terminating-tricky-traversals/Agda.Builtin.Size.html#179" class="Postulate">Size</a><a id="3638" class="Symbol">)</a> <a id="3640" class="Symbol">:</a> <a id="3642" href="../code/terminating-tricky-traversals/Cubical.Core.Primitives.html#957" class="Function">Type</a> <a id="3647" href="#3626" class="Bound">a</a> <a id="3649" class="Keyword">where</a>
  <a id="Tree._&amp;_"></a><a id="3657" href="#3657" class="InductiveConstructor Operator">_&amp;_</a> <a id="3661" class="Symbol">:</a> <a id="3663" href="#3617" class="Bound">A</a> <a id="3665" class="Symbol">→</a> <a id="3667" class="Symbol">∀</a> <a id="3669" class="Symbol">{</a><a id="3670" href="#3670" class="Bound">j</a> <a id="3672" class="Symbol">:</a> <a id="3674" href="../code/terminating-tricky-traversals/Agda.Builtin.Size.html#211" class="Postulate Operator">Size&lt;</a> <a id="3680" href="#3630" class="Bound">i</a><a id="3681" class="Symbol">}</a> <a id="3683" class="Symbol">→</a> <a id="3685" href="../code/terminating-tricky-traversals/Post.Prelude.html#507" class="Datatype">List</a> <a id="3690" class="Symbol">(</a><a id="3691" href="#3611" class="Datatype">Tree</a> <a id="3696" href="#3617" class="Bound">A</a> <a id="3698" href="#3670" class="Bound">j</a><a id="3699" class="Symbol">)</a> <a id="3701" class="Symbol">→</a> <a id="3703" href="#3611" class="Datatype">Tree</a> <a id="3708" href="#3617" class="Bound">A</a> <a id="3710" href="#3630" class="Bound">i</a>

<a id="mapTree"></a><a id="3713" href="#3713" class="Function">mapTree</a> <a id="3721" class="Symbol">:</a> <a id="3723" class="Symbol">(</a><a id="3724" href="../code/terminating-tricky-traversals/Post.Prelude.html#237" class="Generalizable">A</a> <a id="3726" class="Symbol">→</a> <a id="3728" href="../code/terminating-tricky-traversals/Post.Prelude.html#250" class="Generalizable">B</a><a id="3729" class="Symbol">)</a> <a id="3731" class="Symbol">→</a> <a id="3733" href="#3611" class="Datatype">Tree</a> <a id="3738" href="../code/terminating-tricky-traversals/Post.Prelude.html#237" class="Generalizable">A</a> <a id="3740" href="../code/terminating-tricky-traversals/Post.Prelude.html#276" class="Generalizable">i</a> <a id="3742" class="Symbol">→</a> <a id="3744" href="#3611" class="Datatype">Tree</a> <a id="3749" href="../code/terminating-tricky-traversals/Post.Prelude.html#250" class="Generalizable">B</a> <a id="3751" href="../code/terminating-tricky-traversals/Post.Prelude.html#276" class="Generalizable">i</a>
<a id="3753" href="#3713" class="Function">mapTree</a> <a id="3761" href="#3761" class="Bound">f</a> <a id="3763" class="Symbol">(</a><a id="3764" href="#3764" class="Bound">x</a> <a id="3766" href="#3657" class="InductiveConstructor Operator">&amp;</a> <a id="3768" href="#3768" class="Bound">xs</a><a id="3770" class="Symbol">)</a> <a id="3772" class="Symbol">=</a> <a id="3774" href="#3761" class="Bound">f</a> <a id="3776" href="#3764" class="Bound">x</a> <a id="3778" href="#3657" class="InductiveConstructor Operator">&amp;</a> <a id="3780" href="../code/terminating-tricky-traversals/Post.Prelude.html#678" class="Function">map</a> <a id="3784" class="Symbol">(</a><a id="3785" href="#3713" class="Function">mapTree</a> <a id="3793" href="#3761" class="Bound">f</a><a id="3794" class="Symbol">)</a> <a id="3796" href="#3768" class="Bound">xs</a>
</pre>
<p>So how do we use this stuff in our graph traversal? Well first we’ll need a coinductive Stream type:</p>
<pre class="Agda"><a id="3914" class="Keyword">record</a> <a id="Stream"></a><a id="3921" href="#3921" class="Record">Stream</a> <a id="3928" class="Symbol">(</a><a id="3929" href="#3929" class="Bound">A</a> <a id="3931" class="Symbol">:</a> <a id="3933" href="../code/terminating-tricky-traversals/Cubical.Core.Primitives.html#957" class="Function">Type</a> <a id="3938" href="../code/terminating-tricky-traversals/Post.Prelude.html#221" class="Generalizable">a</a><a id="3939" class="Symbol">)</a> <a id="3941" class="Symbol">(</a><a id="3942" href="#3942" class="Bound">i</a> <a id="3944" class="Symbol">:</a> <a id="3946" href="../code/terminating-tricky-traversals/Agda.Builtin.Size.html#179" class="Postulate">Size</a><a id="3950" class="Symbol">)</a> <a id="3952" class="Symbol">:</a> <a id="3954" href="../code/terminating-tricky-traversals/Cubical.Core.Primitives.html#957" class="Function">Type</a> <a id="3959" href="#3938" class="Bound">a</a> <a id="3961" class="Keyword">where</a>
  <a id="3969" class="Keyword">coinductive</a>
  <a id="3983" class="Keyword">field</a>
    <a id="Stream.head"></a><a id="3993" href="#3993" class="Field">head</a> <a id="3998" class="Symbol">:</a> <a id="4000" href="#3929" class="Bound">A</a>
    <a id="Stream.tail"></a><a id="4006" href="#4006" class="Field">tail</a> <a id="4011" class="Symbol">:</a> <a id="4013" class="Symbol">∀</a> <a id="4015" class="Symbol">{</a><a id="4016" href="#4016" class="Bound">j</a> <a id="4018" class="Symbol">:</a> <a id="4020" href="../code/terminating-tricky-traversals/Agda.Builtin.Size.html#211" class="Postulate Operator">Size&lt;</a> <a id="4026" href="#3942" class="Bound">i</a><a id="4027" class="Symbol">}</a> <a id="4029" class="Symbol">→</a> <a id="4031" href="#3921" class="Record">Stream</a> <a id="4038" href="#3929" class="Bound">A</a> <a id="4040" href="#4016" class="Bound">j</a>
<a id="4042" class="Keyword">open</a> <a id="4047" href="#3921" class="Module">Stream</a> <a id="4054" class="Keyword">public</a>

<a id="smap"></a><a id="4062" href="#4062" class="Function">smap</a> <a id="4067" class="Symbol">:</a> <a id="4069" class="Symbol">(</a><a id="4070" href="../code/terminating-tricky-traversals/Post.Prelude.html#237" class="Generalizable">A</a> <a id="4072" class="Symbol">→</a> <a id="4074" href="../code/terminating-tricky-traversals/Post.Prelude.html#250" class="Generalizable">B</a><a id="4075" class="Symbol">)</a> <a id="4077" class="Symbol">→</a> <a id="4079" href="#3921" class="Record">Stream</a> <a id="4086" href="../code/terminating-tricky-traversals/Post.Prelude.html#237" class="Generalizable">A</a> <a id="4088" href="../code/terminating-tricky-traversals/Post.Prelude.html#276" class="Generalizable">i</a> <a id="4090" class="Symbol">→</a> <a id="4092" href="#3921" class="Record">Stream</a> <a id="4099" href="../code/terminating-tricky-traversals/Post.Prelude.html#250" class="Generalizable">B</a> <a id="4101" href="../code/terminating-tricky-traversals/Post.Prelude.html#276" class="Generalizable">i</a>
<a id="4103" href="#4062" class="Function">smap</a> <a id="4108" href="#4108" class="Bound">f</a> <a id="4110" href="#4110" class="Bound">xs</a> <a id="4113" class="Symbol">.</a><a id="4114" href="#3993" class="Field">head</a> <a id="4119" class="Symbol">=</a> <a id="4121" href="#4108" class="Bound">f</a> <a id="4123" class="Symbol">(</a><a id="4124" href="#4110" class="Bound">xs</a> <a id="4127" class="Symbol">.</a><a id="4128" href="#3993" class="Field">head</a><a id="4132" class="Symbol">)</a>
<a id="4134" href="#4062" class="Function">smap</a> <a id="4139" href="#4139" class="Bound">f</a> <a id="4141" href="#4141" class="Bound">xs</a> <a id="4144" class="Symbol">.</a><a id="4145" href="#4006" class="Field">tail</a> <a id="4150" class="Symbol">=</a> <a id="4152" href="#4062" class="Function">smap</a> <a id="4157" href="#4139" class="Bound">f</a> <a id="4159" class="Symbol">(</a><a id="4160" href="#4141" class="Bound">xs</a> <a id="4163" class="Symbol">.</a><a id="4164" href="#4006" class="Field">tail</a><a id="4168" class="Symbol">)</a>
</pre>
<p>And then we can use it to write our breadth-first traversal.</p>
<pre class="Agda"><a id="bfs"></a><a id="4245" href="#4245" class="Function">bfs</a> <a id="4249" class="Symbol">:</a> <a id="4251" class="Symbol">⦃</a> <a id="4253" href="#4253" class="Bound">_</a> <a id="4255" class="Symbol">:</a> <a id="4257" href="../code/terminating-tricky-traversals/Post.Prelude.html#2916" class="Record">IsDiscrete</a> <a id="4268" href="../code/terminating-tricky-traversals/Post.Prelude.html#237" class="Generalizable">A</a> <a id="4270" class="Symbol">⦄</a> <a id="4272" class="Symbol">→</a> <a id="4274" class="Symbol">(</a><a id="4275" href="../code/terminating-tricky-traversals/Post.Prelude.html#237" class="Generalizable">A</a> <a id="4277" class="Symbol">→</a> <a id="4279" href="../code/terminating-tricky-traversals/Post.Prelude.html#507" class="Datatype">List</a> <a id="4284" href="../code/terminating-tricky-traversals/Post.Prelude.html#237" class="Generalizable">A</a><a id="4285" class="Symbol">)</a> <a id="4287" class="Symbol">→</a> <a id="4289" href="../code/terminating-tricky-traversals/Post.Prelude.html#237" class="Generalizable">A</a> <a id="4291" class="Symbol">→</a> <a id="4293" href="#3921" class="Record">Stream</a> <a id="4300" class="Symbol">(</a><a id="4301" href="../code/terminating-tricky-traversals/Post.Prelude.html#507" class="Datatype">List</a> <a id="4306" href="../code/terminating-tricky-traversals/Post.Prelude.html#237" class="Generalizable">A</a><a id="4307" class="Symbol">)</a> <a id="4309" href="../code/terminating-tricky-traversals/Post.Prelude.html#276" class="Generalizable">i</a>
<a id="4311" href="#4245" class="Function">bfs</a> <a id="4315" href="#4315" class="Bound">g</a> <a id="4317" href="#4317" class="Bound">r</a> <a id="4319" class="Symbol">=</a> <a id="4321" href="#4062" class="Function">smap</a> <a id="4326" href="../code/terminating-tricky-traversals/Agda.Builtin.Sigma.html#225" class="Field">fst</a> <a id="4330" class="Symbol">(</a><a id="4331" href="#2020" class="Function">fix</a> <a id="4335" class="Symbol">(</a><a id="4336" href="#3921" class="Record">Stream</a> <a id="4343" class="Symbol">_)</a> <a id="4346" class="Symbol">(</a><a id="4347" href="#4490" class="Function">f</a> <a id="4349" href="#4317" class="Bound">r</a> <a id="4351" href="../code/terminating-tricky-traversals/Post.Prelude.html#434" class="Function Operator">∘</a> <a id="4353" href="#4370" class="Function">push</a><a id="4357" class="Symbol">))</a>
  <a id="4362" class="Keyword">where</a>
  <a id="4370" href="#4370" class="Function">push</a> <a id="4375" class="Symbol">:</a> <a id="4377" href="#1897" class="Record">Thunk</a> <a id="4383" class="Symbol">(</a><a id="4384" href="#3921" class="Record">Stream</a> <a id="4391" class="Symbol">_)</a> <a id="4394" href="../code/terminating-tricky-traversals/Post.Prelude.html#276" class="Generalizable">i</a> <a id="4396" class="Symbol">→</a> <a id="4398" href="#3921" class="Record">Stream</a> <a id="4405" class="Symbol">_</a> <a id="4407" href="../code/terminating-tricky-traversals/Post.Prelude.html#276" class="Generalizable">i</a>
  <a id="4411" href="#4370" class="Function">push</a> <a id="4416" href="#4416" class="Bound">xs</a> <a id="4419" class="Symbol">.</a><a id="4420" href="#3993" class="Field">head</a> <a id="4425" class="Symbol">=</a> <a id="4427" class="Symbol">(</a><a id="4428" href="../code/terminating-tricky-traversals/Post.Prelude.html#542" class="InductiveConstructor">[]</a> <a id="4431" href="../code/terminating-tricky-traversals/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="4433" href="../code/terminating-tricky-traversals/Post.Prelude.html#542" class="InductiveConstructor">[]</a><a id="4435" class="Symbol">)</a>
  <a id="4439" href="#4370" class="Function">push</a> <a id="4444" href="#4444" class="Bound">xs</a> <a id="4447" class="Symbol">.</a><a id="4448" href="#4006" class="Field">tail</a> <a id="4453" class="Symbol">=</a> <a id="4455" href="#4062" class="Function">smap</a> <a id="4460" class="Symbol">(</a><a id="4461" href="../code/terminating-tricky-traversals/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">_,_</a> <a id="4465" href="../code/terminating-tricky-traversals/Post.Prelude.html#542" class="InductiveConstructor">[]</a> <a id="4468" href="../code/terminating-tricky-traversals/Post.Prelude.html#434" class="Function Operator">∘</a> <a id="4470" href="../code/terminating-tricky-traversals/Agda.Builtin.Sigma.html#237" class="Field">snd</a><a id="4473" class="Symbol">)</a> <a id="4475" class="Symbol">(</a><a id="4476" href="#4444" class="Bound">xs</a> <a id="4479" class="Symbol">.</a><a id="4480" href="#1971" class="Field">force</a><a id="4485" class="Symbol">)</a>

  <a id="4490" href="#4490" class="Function">f</a> <a id="4492" class="Symbol">:</a> <a id="4494" class="Symbol">_</a> <a id="4496" class="Symbol">→</a> <a id="4498" href="#3921" class="Record">Stream</a> <a id="4505" class="Symbol">_</a> <a id="4507" href="../code/terminating-tricky-traversals/Post.Prelude.html#276" class="Generalizable">i</a> <a id="4509" class="Symbol">→</a> <a id="4511" href="#3921" class="Record">Stream</a> <a id="4518" class="Symbol">_</a> <a id="4520" href="../code/terminating-tricky-traversals/Post.Prelude.html#276" class="Generalizable">i</a>
  <a id="4524" href="#4490" class="Function">f</a> <a id="4526" href="#4526" class="Bound">x</a> <a id="4528" href="#4528" class="Bound">qs</a> <a id="4531" class="Keyword">with</a> <a id="4536" class="Symbol">(</a><a id="4537" href="#4526" class="Bound">x</a> <a id="4539" href="../code/terminating-tricky-traversals/Post.Prelude.html#3012" class="Function Operator">∈?</a> <a id="4542" href="#4528" class="Bound">qs</a> <a id="4545" class="Symbol">.</a><a id="4546" href="#3993" class="Field">head</a> <a id="4551" class="Symbol">.</a><a id="4552" href="../code/terminating-tricky-traversals/Agda.Builtin.Sigma.html#237" class="Field">snd</a><a id="4555" class="Symbol">)</a> <a id="4557" class="Symbol">.</a><a id="4558" href="../code/terminating-tricky-traversals/Post.Prelude.html#1059" class="Field">does</a>
  <a id="4565" class="Symbol">...</a> <a id="4569" class="Symbol">|</a> <a id="4571" href="../code/terminating-tricky-traversals/Agda.Builtin.Bool.html#160" class="InductiveConstructor">true</a> <a id="4576" class="Symbol">=</a> <a id="4578" class="Bound">qs</a>
  <a id="4583" class="Symbol">...</a> <a id="4587" class="Symbol">|</a> <a id="4589" href="../code/terminating-tricky-traversals/Agda.Builtin.Bool.html#154" class="InductiveConstructor">false</a> <a id="4595" class="Symbol">=</a> <a id="4597" class="Symbol">λ</a> <a id="4599" class="Keyword">where</a> <a id="4605" class="Symbol">.</a><a id="4606" href="#3993" class="Field">head</a> <a id="4611" class="Symbol">→</a> <a id="4613" class="Symbol">(</a><a id="4614" class="Bound">x</a> <a id="4616" href="../code/terminating-tricky-traversals/Post.Prelude.html#556" class="InductiveConstructor Operator">∷</a> <a id="4618" class="Bound">qs</a> <a id="4621" class="Symbol">.</a><a id="4622" href="#3993" class="Field">head</a> <a id="4627" class="Symbol">.</a><a id="4628" href="../code/terminating-tricky-traversals/Agda.Builtin.Sigma.html#225" class="Field">fst</a> <a id="4632" href="../code/terminating-tricky-traversals/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="4634" class="Bound">x</a> <a id="4636" href="../code/terminating-tricky-traversals/Post.Prelude.html#556" class="InductiveConstructor Operator">∷</a> <a id="4638" class="Bound">qs</a> <a id="4641" class="Symbol">.</a><a id="4642" href="#3993" class="Field">head</a> <a id="4647" class="Symbol">.</a><a id="4648" href="../code/terminating-tricky-traversals/Agda.Builtin.Sigma.html#237" class="Field">snd</a><a id="4651" class="Symbol">)</a>
                        <a id="4677" class="Symbol">.</a><a id="4678" href="#4006" class="Field">tail</a> <a id="4683" class="Symbol">→</a> <a id="4685" href="../code/terminating-tricky-traversals/Post.Prelude.html#583" class="Function">foldr</a> <a id="4691" href="#4490" class="Function">f</a> <a id="4693" class="Symbol">(</a><a id="4694" class="Bound">qs</a> <a id="4697" class="Symbol">.</a><a id="4698" href="#4006" class="Field">tail</a><a id="4702" class="Symbol">)</a> <a id="4704" class="Symbol">(</a><a id="4705" href="#4315" class="Bound">g</a> <a id="4707" class="Bound">x</a><a id="4708" class="Symbol">)</a>
</pre>
<p>How do we convert this to a list of lists? Well, for this condition we would actually need to prove that there are only finitely many elements in the graph. We could actually use <a href="https://arxiv.org/abs/1604.01186">Noetherian finiteness</a> for this: though I have a working implementation, I’m still figuring out how to clean this up, so I will leave it for another post.</p>
<h1 id="traversing-a-braun-tree">Traversing a Braun Tree</h1>
<p>A recent paper <span class="citation" data-cites="NipkowS-CPP20">(Nipkow and Sewell <a href="#ref-NipkowS-CPP20">2020</a>)</span> provided Coq proofs for some algorithms on Braun trees <span class="citation" data-cites="okasakiThreeAlgorithmsBraun1997">(Okasaki <a href="#ref-okasakiThreeAlgorithmsBraun1997">1997</a>)</span>, which prompted me to take a look at them again. This time, I came up with an interesting linear-time <code>toList</code> function, which relies on the following peculiar type:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Q2</span> a</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">Q2</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">  {<span class="ot"> unQ2 ::</span> (<span class="dt">Q2</span> a <span class="ot">-&gt;</span> <span class="dt">Q2</span> a) <span class="ot">-&gt;</span> (<span class="dt">Q2</span> a <span class="ot">-&gt;</span> <span class="dt">Q2</span> a) <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">  }</a></code></pre></div>
<p>Even after coming up with the type myself, I still can’t really make heads nor tails of it. If I squint, it starts to look like some bizarre church-encoded binary number (but I have to <em>really</em> squint). It certainly seems related to corecursive queues <span class="citation" data-cites="smith_lloyd_2009">(Smith <a href="#ref-smith_lloyd_2009">2009</a>)</span>.</p>
<p>Anyway, we can use the type to write the following lovely <code>toList</code> function on a Braun tree.</p>
<p><span id="toListImpl"></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">toList ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">toList t <span class="fu">=</span> unQ2 (f t b) id id</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">    f (<span class="dt">Node</span> x l r) xs <span class="fu">=</span> <span class="dt">Q2</span> (\ls rs <span class="ot">-&gt;</span> x <span class="fu">:</span> unQ2 xs (ls <span class="fu">.</span> f l) (rs <span class="fu">.</span> f r))</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">    f <span class="dt">Leaf</span>         xs <span class="fu">=</span> <span class="dt">Q2</span> (\_  _  <span class="ot">-&gt;</span> [])</a>
<a class="sourceLine" id="cb4-6" data-line-number="6"></a>
<a class="sourceLine" id="cb4-7" data-line-number="7">    b <span class="fu">=</span> <span class="dt">Q2</span> (\ls rs <span class="ot">-&gt;</span> unQ2 (ls (rs b)) id id)</a></code></pre></div>
<p></span></p>
<p>So can we convert it to Agda?</p>
<p>Not really! As it turns out, this function is even more difficult to implement than one might expect. We can’t even <em>write</em> the <code>Q2</code> type in Agda without getting in trouble.</p>
<pre class="Agda"><a id="6242" class="Symbol">{-#</a> <a id="6246" class="Keyword">NO_POSITIVITY_CHECK</a> <a id="6266" class="Symbol">#-}</a>
<a id="6270" class="Keyword">record</a> <a id="Q2"></a><a id="6277" href="#6277" class="Record">Q2</a> <a id="6280" class="Symbol">(</a><a id="6281" href="#6281" class="Bound">A</a> <a id="6283" class="Symbol">:</a> <a id="6285" href="../code/terminating-tricky-traversals/Cubical.Core.Primitives.html#957" class="Function">Type</a> <a id="6290" href="../code/terminating-tricky-traversals/Post.Prelude.html#221" class="Generalizable">a</a><a id="6291" class="Symbol">)</a> <a id="6293" class="Symbol">:</a> <a id="6295" href="../code/terminating-tricky-traversals/Cubical.Core.Primitives.html#957" class="Function">Type</a> <a id="6300" href="#6290" class="Bound">a</a> <a id="6302" class="Keyword">where</a>
  <a id="6310" class="Keyword">inductive</a>
  <a id="6322" class="Keyword">field</a>
    <a id="Q2.q2"></a><a id="6332" href="#6332" class="Field">q2</a> <a id="6335" class="Symbol">:</a> <a id="6337" class="Symbol">(</a><a id="6338" href="#6277" class="Record">Q2</a> <a id="6341" href="#6281" class="Bound">A</a> <a id="6343" class="Symbol">→</a> <a id="6345" href="#6277" class="Record">Q2</a> <a id="6348" href="#6281" class="Bound">A</a><a id="6349" class="Symbol">)</a> <a id="6351" class="Symbol">→</a>
         <a id="6362" class="Symbol">(</a><a id="6363" href="#6277" class="Record">Q2</a> <a id="6366" href="#6281" class="Bound">A</a> <a id="6368" class="Symbol">→</a> <a id="6370" href="#6277" class="Record">Q2</a> <a id="6373" href="#6281" class="Bound">A</a><a id="6374" class="Symbol">)</a> <a id="6376" class="Symbol">→</a>
         <a id="6387" href="#6281" class="Bound">A</a>
<a id="6389" class="Keyword">open</a> <a id="6394" href="#6277" class="Module">Q2</a>
</pre>
<p><code>Q2</code> isn’t strictly positive, unfortunately.</p>
<pre class="Agda"><a id="6456" class="Symbol">{-#</a> <a id="6460" class="Keyword">TERMINATING</a> <a id="6472" class="Symbol">#-}</a>
<a id="toList"></a><a id="6476" href="#6476" class="Function">toList</a> <a id="6483" class="Symbol">:</a> <a id="6485" href="../code/terminating-tricky-traversals/Post.Prelude.html#4077" class="Datatype">Braun</a> <a id="6491" href="../code/terminating-tricky-traversals/Post.Prelude.html#237" class="Generalizable">A</a> <a id="6493" class="Symbol">→</a> <a id="6495" href="../code/terminating-tricky-traversals/Post.Prelude.html#507" class="Datatype">List</a> <a id="6500" href="../code/terminating-tricky-traversals/Post.Prelude.html#237" class="Generalizable">A</a>
<a id="6502" href="#6476" class="Function">toList</a> <a id="6509" href="#6509" class="Bound">t</a> <a id="6511" class="Symbol">=</a> <a id="6513" href="#6587" class="Function">f</a> <a id="6515" href="#6509" class="Bound">t</a> <a id="6517" href="#6539" class="Function">n</a> <a id="6519" class="Symbol">.</a><a id="6520" href="#6332" class="Field">q2</a> <a id="6523" href="../code/terminating-tricky-traversals/Post.Prelude.html#3105" class="Function">id</a> <a id="6526" href="../code/terminating-tricky-traversals/Post.Prelude.html#3105" class="Function">id</a>
  <a id="6531" class="Keyword">where</a>
  <a id="6539" href="#6539" class="Function">n</a> <a id="6541" class="Symbol">:</a> <a id="6543" href="#6277" class="Record">Q2</a> <a id="6546" href="../code/terminating-tricky-traversals/Post.Prelude.html#237" class="Generalizable">A</a>
  <a id="6550" href="#6539" class="Function">n</a> <a id="6552" class="Symbol">.</a><a id="6553" href="#6332" class="Field">q2</a> <a id="6556" href="#6556" class="Bound">ls</a> <a id="6559" href="#6559" class="Bound">rs</a> <a id="6562" class="Symbol">=</a> <a id="6564" href="#6556" class="Bound">ls</a> <a id="6567" class="Symbol">(</a><a id="6568" href="#6559" class="Bound">rs</a> <a id="6571" href="#6539" class="Function">n</a><a id="6572" class="Symbol">)</a> <a id="6574" class="Symbol">.</a><a id="6575" href="#6332" class="Field">q2</a> <a id="6578" href="../code/terminating-tricky-traversals/Post.Prelude.html#3105" class="Function">id</a> <a id="6581" href="../code/terminating-tricky-traversals/Post.Prelude.html#3105" class="Function">id</a>

  <a id="6587" href="#6587" class="Function">f</a> <a id="6589" class="Symbol">:</a> <a id="6591" href="../code/terminating-tricky-traversals/Post.Prelude.html#4077" class="Datatype">Braun</a> <a id="6597" href="../code/terminating-tricky-traversals/Post.Prelude.html#237" class="Generalizable">A</a> <a id="6599" class="Symbol">→</a> <a id="6601" href="#6277" class="Record">Q2</a> <a id="6604" class="Symbol">(</a><a id="6605" href="../code/terminating-tricky-traversals/Post.Prelude.html#507" class="Datatype">List</a> <a id="6610" href="../code/terminating-tricky-traversals/Post.Prelude.html#237" class="Generalizable">A</a><a id="6611" class="Symbol">)</a> <a id="6613" class="Symbol">→</a> <a id="6615" href="#6277" class="Record">Q2</a> <a id="6618" class="Symbol">(</a><a id="6619" href="../code/terminating-tricky-traversals/Post.Prelude.html#507" class="Datatype">List</a> <a id="6624" href="../code/terminating-tricky-traversals/Post.Prelude.html#237" class="Generalizable">A</a><a id="6625" class="Symbol">)</a>
  <a id="6629" href="#6587" class="Function">f</a> <a id="6631" href="../code/terminating-tricky-traversals/Post.Prelude.html#4113" class="InductiveConstructor">leaf</a>         <a id="6644" href="#6644" class="Bound">xs</a> <a id="6647" class="Symbol">.</a><a id="6648" href="#6332" class="Field">q2</a> <a id="6651" href="#6651" class="Bound">ls</a> <a id="6654" href="#6654" class="Bound">rs</a> <a id="6657" class="Symbol">=</a> <a id="6659" href="../code/terminating-tricky-traversals/Post.Prelude.html#542" class="InductiveConstructor">[]</a>
  <a id="6664" href="#6587" class="Function">f</a> <a id="6666" class="Symbol">(</a><a id="6667" href="../code/terminating-tricky-traversals/Post.Prelude.html#4130" class="InductiveConstructor">node</a> <a id="6672" href="#6672" class="Bound">x</a> <a id="6674" href="#6674" class="Bound">l</a> <a id="6676" href="#6676" class="Bound">r</a><a id="6677" class="Symbol">)</a> <a id="6679" href="#6679" class="Bound">xs</a> <a id="6682" class="Symbol">.</a><a id="6683" href="#6332" class="Field">q2</a> <a id="6686" href="#6686" class="Bound">ls</a> <a id="6689" href="#6689" class="Bound">rs</a> <a id="6692" class="Symbol">=</a> <a id="6694" href="#6672" class="Bound">x</a> <a id="6696" href="../code/terminating-tricky-traversals/Post.Prelude.html#556" class="InductiveConstructor Operator">∷</a> <a id="6698" href="#6679" class="Bound">xs</a> <a id="6701" class="Symbol">.</a><a id="6702" href="#6332" class="Field">q2</a> <a id="6705" class="Symbol">(</a><a id="6706" href="#6686" class="Bound">ls</a> <a id="6709" href="../code/terminating-tricky-traversals/Post.Prelude.html#434" class="Function Operator">∘</a> <a id="6711" href="#6587" class="Function">f</a> <a id="6713" href="#6674" class="Bound">l</a><a id="6714" class="Symbol">)</a> <a id="6716" class="Symbol">(</a><a id="6717" href="#6689" class="Bound">rs</a> <a id="6720" href="../code/terminating-tricky-traversals/Post.Prelude.html#434" class="Function Operator">∘</a> <a id="6722" href="#6587" class="Function">f</a> <a id="6724" href="#6676" class="Bound">r</a><a id="6725" class="Symbol">)</a>
</pre>
<p>Apparently this problem of strict positivity for breadth-first traversals has come up before: <span class="citation" data-cites="bergerMartinHofmannCase2019">Berger, Matthes, and Setzer (<a href="#ref-bergerMartinHofmannCase2019">2019</a>)</span>; <span class="citation" data-cites="hofmannNonStrictlyPositive1993">Hofmann (<a href="#ref-hofmannNonStrictlyPositive1993">1993</a>)</span>.</p>
<h1 id="waitwhere-did-q2-come-from">Wait—Where did Q2 Come From?</h1>
<p>Update 31/01/2020</p>
<p>Daniel Peebles (<a href="https://twitter.com/copumpkin">@copumpkin</a> on twitter) replied to my tweet about this post with the following:</p>
<blockquote>
<p>Interesting! Curious <em>how</em> you came up with that weird type at the end. It doesn’t exactly feel like the first thing one might reach for and it would be interesting to see some writing on the thought process that led to it</p>
<p><a href="https://twitter.com/copumpkin/status/1222681927854936065">Dan P (@copumpkin), Jan 30, 2020.</a></p>
</blockquote>
<p>So that’s what I’m going to add here!</p>
<p>Let’s take the Braun tree of the numbers 1 to 15:</p>
<pre><code>     ┌8
   ┌4┤
   │ └12
 ┌2┤
 │ │ ┌10
 │ └6┤
 │   └14
1┤
 │   ┌9
 │ ┌5┤
 │ │ └13
 └3┤
   │ ┌11
   └7┤
     └15</code></pre>
<p>Doing a normal breadth-first traversal for the first two levels is fine (1, 2, 3): it starts to fall apart at the third level (4, 6, 5, 7). Here’s the way we should traverse it: “all of the left branches, and then all of the right branches”. So, we will have a queue of trees. We take the root element of each tree in the queue, and emit it, and then we add all of the <em>left</em> children of the trees in the queue to one queue, and then all the <em>right</em> children to another, and then concatenate them into a new queue and we start again. We can stop whenever we hit an empty tree because of the structure of the Braun tree. Here’s an ascii diagram to show what’s going on:</p>
<pre><code>     ┌8   |     ┌8    |     ┌8     |       8
   ┌4┤    |   ┌4┤     |    4┤      |
   │ └12  |   │ └12   |     └12    |       9
 ┌2┤      |  2┤       |            |
 │ │ ┌10  |   │ ┌10   |     ┌9     |       10
 │ └6┤    |   └6┤     |    5┤      |
 │   └14  |     └14   |     └13    |       11
1┤       --&gt;        -----&gt;      --------&gt;
 │   ┌9   |     ┌9    |     ┌10    |       12
 │ ┌5┤    |   ┌5┤     |    6┤      |
 │ │ └13  |   │ └13   |     └14    |       13
 └3┤      |  3┤       |            |
   │ ┌11  |   │ ┌11   |     ┌11    |       14
   └7┤    |   └7┤     |    7┤      |
     └15  |     └15   |     └15    |       15

         1,         2, 3,       4, 5, 6, 7,   8, 9, 10, 11, 12, 13, 14, 15</code></pre>
<p>If we want to do this in Haskell, we have a number of options for how we would represent queues: as ever, though, I much prefer to use vanilla lists and time the reversals so that they stay linear. Here’s what that looks like:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">toList ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">toList t <span class="fu">=</span> f t b [] []</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">    f (<span class="dt">Node</span> x l r) xs ls rs <span class="fu">=</span> x <span class="fu">:</span> xs (l <span class="fu">:</span> ls) (r <span class="fu">:</span> rs)</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">    f <span class="dt">Leaf</span>         _ _  _  <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb7-6" data-line-number="6"></a>
<a class="sourceLine" id="cb7-7" data-line-number="7">    b ls rs <span class="fu">=</span> foldr f b (reverse ls <span class="fu">++</span> reverse rs) [] []</a></code></pre></div>
<p>Any place we see a <code>foldr</code> being run after a reverse or a concatenation, we know that we can remove a pass (in actual fact rewrite rules will likely do this automatically for us).</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">toList ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">toList t <span class="fu">=</span> f b t [] []</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">    f (<span class="dt">Node</span> x l r) xs ls rs <span class="fu">=</span> x <span class="fu">:</span> xs (l <span class="fu">:</span> ls) (r <span class="fu">:</span> rs)</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">    f <span class="dt">Leaf</span>         _  _  _  <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb8-6" data-line-number="6"></a>
<a class="sourceLine" id="cb8-7" data-line-number="7">    b ls rs <span class="fu">=</span> foldl (flip f) (foldl (flip f) b rs) ls [] []</a></code></pre></div>
<p>Finally, since we’re building up the lists with <code>:</code> (in a linear way, i.e. we will not use the intermediate queues more than once), and we’re immediately consuming them with a fold, we can deforest the intermediate list, replacing every <code>:</code> with <code>f</code> (actually, it’s a little more tricky than that, since we replace the <code>:</code> with the <em>reversed</em> version of <code>f</code>, i.e. the one you would pass to <code>foldr</code> if you wanted it to act like <code>foldl</code>. This trick is explained in more detail in <a href="2019-05-08-list-manipulation-tricks.html">this post</a>).</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">toList ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">toList t <span class="fu">=</span> f t b id id</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4">    f (<span class="dt">Node</span> x l r) xs ls rs <span class="fu">=</span> x <span class="fu">:</span> xs (ls <span class="fu">.</span> f l) (rs <span class="fu">.</span> f r)</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">    f <span class="dt">Leaf</span>         _ _ _ <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb9-6" data-line-number="6"></a>
<a class="sourceLine" id="cb9-7" data-line-number="7">    b ls rs <span class="fu">=</span> ls (rs b) id id</a></code></pre></div>
<p>Once you do that, however, you run into the “cannot construct the infinite type” error. To be precise:</p>
<blockquote>
<pre><code>• Occurs check: cannot construct the infinite type:
    a3 ~ (a3 -&gt; c0) -&gt; (a3 -&gt; c1) -&gt; [a2]</code></pre>
</blockquote>
<p>And this gives us the template for our newtype! It requires some trial and error, but you can see where some of the recursive calls are, and what you eventually get is the following:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Q2</span> a</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">Q2</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  {<span class="ot"> unQ2 ::</span> (<span class="dt">Q2</span> a <span class="ot">-&gt;</span> <span class="dt">Q2</span> a) <span class="ot">-&gt;</span> (<span class="dt">Q2</span> a <span class="ot">-&gt;</span> <span class="dt">Q2</span> a) <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">  }</a></code></pre></div>
<p>(You can remove the list type constructor at the end, I did as I thought it made it slightly more general). And from there we get back to <a href="#toListImpl">the <code>toList</code> function</a>.</p>
<h1 id="references" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-bergerMartinHofmannCase2019">
<p>Berger, Ulrich, Ralph Matthes, and Anton Setzer. 2019. “Martin Hofmann’s Case for Non-Strictly Positive Data Types.” In <em>24th international conference on types for proofs and programs (TYPES 2018)</em>, ed by. Peter Dybjer, José Espírito Santo, and Luís Pinto, 130:22. Leibniz international proceedings in informatics (LIPIcs). Dagstuhl, Germany: Schloss DagstuhlLeibniz-Zentrum fuer Informatik. doi:<a href="https://doi.org/10.4230/LIPIcs.TYPES.2018.1">10.4230/LIPIcs.TYPES.2018.1</a>. <a href="http://drops.dagstuhl.de/opus/volltexte/2019/11405" class="uri">http://drops.dagstuhl.de/opus/volltexte/2019/11405</a>.</p>
</div>
<div id="ref-hofmannNonStrictlyPositive1993">
<p>Hofmann, Martin. 1993. “Non Strictly Positive Datatypes in System F.” <a href="https://www.seas.upenn.edu/~sweirich/types/archive/1993/msg00027.html" class="uri">https://www.seas.upenn.edu/~sweirich/types/archive/1993/msg00027.html</a>.</p>
</div>
<div id="ref-NipkowS-CPP20">
<p>Nipkow, Tobias, and Thomas Sewell. 2020. “Proof pearl: Braun trees.” In <em>Certified programs and proofs, CPP 2020</em>, ed by. J. Blanchette and C. Hritcu, –. ACM. <a href="http://www21.in.tum.de/~nipkow/pubs/cpp20.html" class="uri">http://www21.in.tum.de/~nipkow/pubs/cpp20.html</a>.</p>
</div>
<div id="ref-okasakiThreeAlgorithmsBraun1997">
<p>Okasaki, Chris. 1997. “Three Algorithms on Braun Trees.” <em>Journal of Functional Programming</em> 7 (6) (November): 661–666. doi:<a href="https://doi.org/10.1017/S0956796897002876">10.1017/S0956796897002876</a>. <a href="https://www.eecs.northwestern.edu/~robby/courses/395-495-2013-fall/three-algorithms-on-braun-trees.pdf" class="uri">https://www.eecs.northwestern.edu/~robby/courses/395-495-2013-fall/three-algorithms-on-braun-trees.pdf</a>.</p>
</div>
<div id="ref-smith_lloyd_2009">
<p>Smith, Leon P. 2009. “Lloyd Allison’s Corecursive Queues: Why Continuations Matter.” <em>The Monad.Reader</em> 14 (14) (July): 28. <a href="https://meldingmonads.files.wordpress.com/2009/06/corecqueues.pdf" class="uri">https://meldingmonads.files.wordpress.com/2009/06/corecqueues.pdf</a>.</p>
</div>
</div>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
