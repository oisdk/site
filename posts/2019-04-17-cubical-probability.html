<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Cubical Agda and Probability Monads - Donnacha OisÃ­n Kidney</title>
        <style>body{color:black;font-family:Garamond,Times New Roman,serif;font-size:14px;margin:0px auto 0px auto;padding-left:5px;padding-right:5px;max-width:600px}math{font-size:13px}img{max-width:600px}div#header{border-bottom:3px double black;margin-bottom:30px;padding:12px 0px 12px 0px}div#logo a{color:black;float:left;font-size:20px;text-decoration:none}div#header #navigation{text-align:right}div#header #navigation a{color:black;font-family:Garamond,Times New Roman,Serif;font-size:18px;margin-left:10px;text-decoration:none;text-transform:uppercase}div#footer{font-family:Garamond,Times New Roman,Serif;border-top:solid 2px black;color:#555;font-size:12px;margin-top:30px;padding:12px 0px 12px 0px;text-align:right}h1{font-family:Garamond,Times New Roman,Serif;font-size:22px;font-weight:normal}h2{font-family:Garamond,Times New Roman,Serif;font-size:20px;font-weight:normal}div.info{color:#555;font-size:15px;font-style:italic}span.quiet{color:#828282;font-style:italic}a{color:black;word-wrap:break-word}ul{margin-left:0px;padding-left:0px;list-style-type:none}.hidden_source{display:none}ol.serieslist{counter-reset:item;list-style-type:none;padding-left:20}ol li.serieslist:before{content:'Part ' counter(item,decimal) ':';counter-increment:item}table.sourceCode,tr.sourceCode,td.lineNumbers,td.sourceCode,table.sourceCode pre{margin:0;padding:0;border:0;vertical-align:baseline;border:none}td.lineNumbers{border-right:1px solid #AAAAAA;text-align:right;color:#AAAAAA;padding-right:5px;padding-left:5px}td.sourceCode{padding-left:5px}.sourceCode,code{font-size:10px;font-family:menlo,monospace}.sourceCode span.kw{color:#262C6A}.sourceCode span.dt{color:#476A97}.sourceCode span.dv{color:#262C6A}.sourceCode span.bn{color:#262C6A}.sourceCode span.fl{color:#262C6A}.sourceCode span.ch{color:#262C6A}.sourceCode span.st{color:#702C51}.sourceCode span.co{color:#435138}.sourceCode span.ot{color:#262C6A}.sourceCode span.al{color:red}.sourceCode span.fu{color:#000000}.sourceCode span.re{color:#000000}.sourceCode span.er{color:red}li{margin-bottom:2px}li:last-child{margin-bottom:0px}</style>
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Donnacha OisÃ­n Kidney</a>
            </div>
            <div id="navigation">
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../rss.xml">Feed</a>
                <a href="../snippets.html">Snippets</a>
            </div>
        </div>

        <div id="content">
            <h2>Cubical Agda and Probability Monads</h2>

            <div class="info">
    Posted on April 17, 2019
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="../tags/Agda.html">Agda</a>, <a href="../tags/Probability.html">Probability</a>
    
</div>

<p><a href="https://agda.readthedocs.io/en/latest/language/cubical.html">Cubical Agda</a> has just come out, and Iâ€™ve been playing around with it for a bit. Thereâ€™s a bunch of info out there on the theory of cubical types, and Homotopy Type Theory more generally (cubical type theory is kind of like an â€œimplementationâ€ of Homotopy type theory), but I wanted to make a post demonstrating cubical Agda in practice, and one of its cool uses from a programming perspective.</p>
<h1 id="so-what-is-cubical-agda">So What is Cubical Agda?</h1>
<p>I donâ€™t really know! Cubical type theory is quite complex (even for a type theory), and Iâ€™m not nearly qualified to properly explain it. In lieu of a proper first-principles explanation, then, Iâ€™ll try and give a few examples of how it differs from normal Agda, before moving on to the main example of this post.</p>
<dl>
<dt>Extensionality</dt>
<dd><p>One of the big annoyances in standard Agda is that we canâ€™t prove the following:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb1-1" data-line-number="1">extensionality <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>f g <span class="ot">:</span> A <span class="ot">â†’</span> B<span class="ot">}</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">              <span class="ot">â†’</span> <span class="ot">(âˆ€</span> <span class="ot">{</span>x<span class="ot">}</span> <span class="ot">â†’</span> f x â‰¡ g x<span class="ot">)</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">              <span class="ot">â†’</span> f â‰¡ g</a></code></pre></div>
<p>Itâ€™s emblematic of a wider problem in Agda: we canâ€™t say â€œtwo things are equal if they always behave the sameâ€. Infinite types, for instance (like streams) are often only equal via bisimulation: we canâ€™t translate this into normal equality in standard Agda. Cubical type theory, though, has a different notion of â€œequalityâ€, which allow a wide variety of things (including bisimulations and extensional proofs) to be translated into a proper equality</p>
</dd>
<dt>Isomorphisms</dt>
<dd><p>One of these such things we can promote to a â€œproper equalityâ€ is an isomorphism. In the <a href="https://github.com/agda/cubical">cubical repo</a> this is used to <a href="https://github.com/agda/cubical/blob/8391a4835b3d2478e9394c6c3ec7e6fff42ede62/Cubical/Data/BinNat/BinNat.agda">prove things about binary numbers</a>: by proving that thereâ€™s an isomorphism between the Peano numbers and binary numbers, they can lift any properties on the Peano numbers to the binary numbers.</p>
</dd>
</dl>
<p>So those are two useful examples, but the <em>most</em> interesting use Iâ€™ve seen so far is the following:</p>
<h1 id="higher-inductive-types">Higher Inductive Types</h1>
<p>Higher Inductive Types are an extension of normal inductive types, like the list:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> List <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  [] <span class="ot">:</span> List A</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  <span class="ot">_</span>âˆ·<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">â†’</span> List A <span class="ot">â†’</span> List A</a></code></pre></div>
<p>They allow us to add new equations to a type, as well as constructors. To demonstrate what this means, as well as why youâ€™d want it, Iâ€™m going to talk about free objects.</p>
<p>Very informally, a free object on some algebra is the <em>minimal</em> type which satisfies the laws of the algebra. Lists, for instance, are the free monoid. They satisfy all of the monoid laws (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>â€¢</mo><annotation encoding="application/x-tex">\bullet</annotation></semantics></math> is <code>++</code> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Ïµ</mi><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math> is <code>[]</code>):</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>â€¢</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo><mo>â€¢</mo><mi>z</mi><mo>=</mo><mi>x</mi><mo>â€¢</mo><mo stretchy="false" form="prefix">(</mo><mi>y</mi><mo>â€¢</mo><mi>z</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(x \bullet y) \bullet z = x \bullet (y \bullet z)</annotation></semantics></math> <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>â€¢</mo><mi>Ïµ</mi><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">x \bullet \epsilon = x</annotation></semantics></math> <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Ïµ</mi><mo>â€¢</mo><mi>x</mi><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">\epsilon \bullet x = x</annotation></semantics></math></p>
<p>But <em>nothing else</em>. That means they donâ€™t satisfy any extra laws (like, for example, commutativity), and they donâ€™t have any extra structure they donâ€™t need.</p>
<p>How did we get to the definition of lists from the monoid laws, though? It doesnâ€™t look anything like them. It would be nice if there was some systematic way to construct the corresponding free object given the laws of an algebra. Unfortunately, in normal Agda, this isnâ€™t possible. Consider, for instance, if we added the commutativity law to the algebra: <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>â€¢</mo><mi>y</mi><mo>=</mo><mi>y</mi><mo>â€¢</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">x \bullet y = y \bullet x</annotation></semantics></math> Not only is it not obvious how weâ€™d write the corresponding free object, itâ€™s actually <em>not possible</em> in normal Agda!</p>
<p>This kind of problem comes up a lot: we have a type, and we want it to obey just <em>one more</em> equation, but there is no inductive type which does so. Higher Inductive Types solve the problem in quite a straightforward way. So we want lists to satisfy another equation? Well, just add it to the definition!</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">data</span> List <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  [] <span class="ot">:</span> List A</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">  <span class="ot">_</span>âˆ·<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">â†’</span> List A <span class="ot">â†’</span> List A</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">  comm <span class="ot">:</span> <span class="ot">âˆ€</span> xs ys <span class="ot">â†’</span> xs ++ ys â‰¡ ys ++ xs</a></code></pre></div>
<p>Now, when we write a function that processes lists, Agda will check that the function behaves the same on <code>xs ++ ys</code> and <code>ys ++ xs</code>. As an example, hereâ€™s how you might define the free monoid as a HIT:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">data</span> FreeMonoid <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  [<span class="ot">_</span>] <span class="ot">:</span> A <span class="ot">â†’</span> FreeMonoid A</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  <span class="ot">_</span>âˆ™<span class="ot">_</span> <span class="ot">:</span> FreeMonoid A <span class="ot">â†’</span> FreeMonoid A <span class="ot">â†’</span> FreeMonoid A</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">  Îµ <span class="ot">:</span> FreeMonoid A</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">  âˆ™Îµ <span class="ot">:</span> <span class="ot">âˆ€</span> x <span class="ot">â†’</span> x âˆ™ Îµ â‰¡ x</a>
<a class="sourceLine" id="cb4-6" data-line-number="6">  Îµâˆ™ <span class="ot">:</span> <span class="ot">âˆ€</span> x <span class="ot">â†’</span> Îµ âˆ™ x â‰¡ x</a>
<a class="sourceLine" id="cb4-7" data-line-number="7">  assoc <span class="ot">:</span> <span class="ot">âˆ€</span> x y z <span class="ot">â†’</span> <span class="ot">(</span>x âˆ™ y<span class="ot">)</span> âˆ™ z â‰¡ x âˆ™ <span class="ot">(</span>y âˆ™ z<span class="ot">)</span></a></code></pre></div>
<p>Itâ€™s quite a satisfying definition, and very easy to see how we got to it from the monoid laws.</p>
<p>Now, when we write functions, we have to prove that those functions themselves also obey the monoid laws. For instance, hereâ€™s how we would take the length:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb5-1" data-line-number="1">length <span class="ot">:</span> FreeMonoid A <span class="ot">â†’</span> â„•</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">length [ x ] <span class="ot">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">length <span class="ot">(</span>xs âˆ™ ys<span class="ot">)</span> <span class="ot">=</span> length xs + length ys</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">length Îµ <span class="ot">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">length <span class="ot">(</span>âˆ™Îµ xs i<span class="ot">)</span> <span class="ot">=</span> +-identityÊ³ <span class="ot">(</span>length xs<span class="ot">)</span> i</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">length <span class="ot">(</span>Îµâˆ™ xs i<span class="ot">)</span> <span class="ot">=</span> +-identityË¡ <span class="ot">(</span>length xs<span class="ot">)</span> i</a>
<a class="sourceLine" id="cb5-7" data-line-number="7">length <span class="ot">(</span>assoc xs ys zs i<span class="ot">)</span> <span class="ot">=</span> +-assoc <span class="ot">(</span>length xs<span class="ot">)</span> <span class="ot">(</span>length ys<span class="ot">)</span> <span class="ot">(</span>length zs<span class="ot">)</span> i</a></code></pre></div>
<p>The first three clauses are the actual function: they deal with the three normal constructors of the type. The next three clauses prove that those previous clauses obey the equalities defined on the type.</p>
<p>With the preliminary stuff out of the way, letâ€™s get on to the type I wanted to talk about:</p>
<h1 id="probability">Probability</h1>
<p>First things first, letâ€™s remember the classic definition of the probability monad:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Prob</span> a <span class="fu">=</span> <span class="dt">Prob</span> {<span class="ot"> runProb ::</span> [(a, <span class="dt">Rational</span>)] }</a></code></pre></div>
<p>Definitionally speaking, this doesnâ€™t really represent what weâ€™re talking about. For instance, the following two things express the same distribution, but have different representations:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="dt">Prob</span> [(<span class="dt">True</span>, <span class="dv">1</span> <span class="fu">/</span> <span class="dv">4</span>), (<span class="dt">True</span>, <span class="dv">1</span> <span class="fu">/</span> <span class="dv">4</span>), (<span class="dt">False</span>, <span class="dv">1</span> <span class="fu">/</span> <span class="dv">2</span>)]</a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="dt">Prob</span> [(<span class="dt">True</span> , <span class="dv">1</span> <span class="fu">/</span> <span class="dv">2</span>), (<span class="dt">False</span>, <span class="dv">1</span> <span class="fu">/</span> <span class="dv">2</span>)]</a></code></pre></div>
<p>So itâ€™s the perfect candidate for an extra equality clause like we had above.</p>
<p>Second, in an effort to generalise, we wonâ€™t deal specifically with <code>Rational</code>, and instead weâ€™ll use any semiring. After all of that, we get the following definition:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">5</span> <span class="ot">_</span>&amp;<span class="ot">_</span>âˆ·<span class="ot">_</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="kw">data</span> ğ’« <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">(</span>a âŠ” s<span class="ot">)</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  []  <span class="ot">:</span> ğ’« A</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">  <span class="ot">_</span>&amp;<span class="ot">_</span>âˆ·<span class="ot">_</span> <span class="ot">:</span> <span class="ot">(</span>p <span class="ot">:</span> Carrier<span class="ot">)</span> <span class="ot">â†’</span> <span class="ot">(</span>x <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">â†’</span> ğ’« A <span class="ot">â†’</span> ğ’« A</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">  dup <span class="ot">:</span> <span class="ot">âˆ€</span> p q x xs <span class="ot">â†’</span> p &amp; x âˆ· q &amp; x âˆ· xs â‰¡ p + q &amp; x âˆ· xs</a>
<a class="sourceLine" id="cb8-6" data-line-number="6">  com <span class="ot">:</span> <span class="ot">âˆ€</span> p x q y xs <span class="ot">â†’</span> p &amp; x âˆ· q &amp; y âˆ· xs â‰¡ q &amp; y âˆ· p &amp; x âˆ· xs</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">  del <span class="ot">:</span> <span class="ot">âˆ€</span> x xs <span class="ot">â†’</span> 0# &amp; x âˆ· xs â‰¡ xs</a></code></pre></div>
<p>The three extra conditions are pretty sensible: the first removes duplicates, the second makes things commutative, and the third removes impossible events.</p>
<p>Letâ€™s get to writing some functions, then:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb9-1" data-line-number="1">sample <span class="ot">:</span> <span class="ot">(</span>A <span class="ot">â†’</span> Carrier<span class="ot">)</span> <span class="ot">â†’</span> ğ’« A <span class="ot">â†’</span> Carrier</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">sample f [] <span class="ot">=</span> 0#</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">sample f <span class="ot">(</span>p &amp; x âˆ· xs<span class="ot">)</span> <span class="ot">=</span> p * f x + sample f xs</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">sample f <span class="ot">(</span>dup p q x xs i<span class="ot">)</span> <span class="ot">=</span> begin[ i ]</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  p * f x + <span class="ot">(</span>q * f x + sample f xs<span class="ot">)</span> â‰¡Ë˜âŸ¨ +-assoc <span class="ot">(</span>p * f x<span class="ot">)</span> <span class="ot">(</span>q * f x<span class="ot">)</span> <span class="ot">(</span>sample f xs<span class="ot">)</span> âŸ©</a>
<a class="sourceLine" id="cb9-6" data-line-number="6">  <span class="ot">(</span>p * f x + q * f x<span class="ot">)</span> + sample f xs â‰¡Ë˜âŸ¨ cong <span class="ot">(_</span>+ sample f xs<span class="ot">)</span> <span class="ot">(</span>âŸ¨+âŸ©* p q <span class="ot">(</span>f x<span class="ot">))</span>  âŸ©</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">  <span class="ot">(</span>p + q<span class="ot">)</span> * f x + sample f xs âˆ</a>
<a class="sourceLine" id="cb9-8" data-line-number="8">sample f <span class="ot">(</span>swap p x q y xs i<span class="ot">)</span> <span class="ot">=</span> begin[ i ]</a>
<a class="sourceLine" id="cb9-9" data-line-number="9">  p * f x + <span class="ot">(</span>q * f y + sample f xs<span class="ot">)</span> â‰¡Ë˜âŸ¨ +-assoc <span class="ot">(</span>p * f x<span class="ot">)</span> <span class="ot">(</span>q * f y<span class="ot">)</span> <span class="ot">(</span>sample f xs<span class="ot">)</span> âŸ©</a>
<a class="sourceLine" id="cb9-10" data-line-number="10">  p * f x + q * f y + sample f xs   â‰¡âŸ¨ cong <span class="ot">(_</span>+ sample f xs<span class="ot">)</span> <span class="ot">(</span>+-comm <span class="ot">(</span>p * f x<span class="ot">)</span> <span class="ot">(</span>q * f y<span class="ot">))</span> âŸ©</a>
<a class="sourceLine" id="cb9-11" data-line-number="11">  q * f y + p * f x + sample f xs   â‰¡âŸ¨ +-assoc <span class="ot">(</span>q * f y<span class="ot">)</span> <span class="ot">(</span>p * f x<span class="ot">)</span> <span class="ot">(</span>sample f xs<span class="ot">)</span> âŸ©</a>
<a class="sourceLine" id="cb9-12" data-line-number="12">  q * f y + <span class="ot">(</span>p * f x + sample f xs<span class="ot">)</span> âˆ</a>
<a class="sourceLine" id="cb9-13" data-line-number="13">sample f <span class="ot">(</span>del x xs i<span class="ot">)</span> <span class="ot">=</span> begin[ i ]</a>
<a class="sourceLine" id="cb9-14" data-line-number="14">  0# * f x + sample f xs â‰¡âŸ¨ cong <span class="ot">(_</span>+ sample f xs<span class="ot">)</span> <span class="ot">(</span>0* <span class="ot">(</span>f x<span class="ot">))</span> âŸ©</a>
<a class="sourceLine" id="cb9-15" data-line-number="15">  0# + sample f xs       â‰¡âŸ¨ 0+ <span class="ot">(</span>sample f xs<span class="ot">)</span> âŸ©</a>
<a class="sourceLine" id="cb9-16" data-line-number="16">  sample f xs âˆ</a></code></pre></div>
<p>This is much more involved than the free monoid function, but the principle is the same: we first write the actual function (on the first three lines), and then we show that the function doesnâ€™t care about the â€œrewrite rulesâ€ we have in the next three clauses.</p>
<p>Before going any further, we will have to amend the definition a little. The problem is that if we tried to prove something about any function on our <code>ğ’«</code> type, weâ€™d have to prove equalities <em>between equalities</em> as well. Iâ€™m sure that this is possible, but itâ€™s very annoying, so Iâ€™m going to use a technique I saw in <a href="https://github.com/L-TChen/FiniteSets">this repository</a>. We add another rule to our type, stating that all equalities on the type are themselves equal. The clause itself looks like this:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb10-1" data-line-number="1">trunc <span class="ot">:</span> isSet <span class="ot">(</span>ğ’« A<span class="ot">)</span></a></code></pre></div>
<h1 id="eliminators">Eliminators</h1>
<p>Unfortunately, after adding that case we have to deal with it explicitly in every pattern-match on <code>ğ’«</code>. We can get around it by writing an eliminator for the type which deals with it itself. Eliminators are often irritating to work with, though: we give up the nice pattern-matching syntax we get when we program directly. Itâ€™s a bit like having to rely on church encoding everywhere.</p>
<p>However, we can get back some pattern-like syntax if we use <em>copatterns</em>. Hereâ€™s an example of what I mean, for folds on lists:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">record</span> [<span class="ot">_</span>â†¦<span class="ot">_</span>] <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">)</span> <span class="ot">(</span>B <span class="ot">:</span> <span class="dt">Set</span> b<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">(</span>a âŠ” b<span class="ot">)</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2">  <span class="kw">field</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">    [<span class="ot">_</span>][] <span class="ot">:</span> B</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">    [<span class="ot">_</span>]<span class="ot">_</span>âˆ·<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">â†’</span> B <span class="ot">â†’</span> B</a>
<a class="sourceLine" id="cb11-5" data-line-number="5">  [<span class="ot">_</span>]â†“ <span class="ot">:</span> List A <span class="ot">â†’</span> B</a>
<a class="sourceLine" id="cb11-6" data-line-number="6">  [ [] ]â†“ <span class="ot">=</span> [<span class="ot">_</span>][]</a>
<a class="sourceLine" id="cb11-7" data-line-number="7">  [ x âˆ· xs ]â†“ <span class="ot">=</span> [<span class="ot">_</span>]<span class="ot">_</span>âˆ·<span class="ot">_</span> x [ xs ]â†“</a>
<a class="sourceLine" id="cb11-8" data-line-number="8"><span class="kw">open</span> [<span class="ot">_</span>â†¦<span class="ot">_</span>]</a>
<a class="sourceLine" id="cb11-9" data-line-number="9"></a>
<a class="sourceLine" id="cb11-10" data-line-number="10">sum-alg <span class="ot">:</span> [ â„• â†¦ â„• ]</a>
<a class="sourceLine" id="cb11-11" data-line-number="11">[ sum-alg ][] <span class="ot">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb11-12" data-line-number="12">[ sum-alg ] x âˆ· xs <span class="ot">=</span> x + xs</a>
<a class="sourceLine" id="cb11-13" data-line-number="13"></a>
<a class="sourceLine" id="cb11-14" data-line-number="14">sum <span class="ot">:</span> List â„• <span class="ot">â†’</span> â„•</a>
<a class="sourceLine" id="cb11-15" data-line-number="15">sum <span class="ot">=</span> [ sum-alg ]â†“</a></code></pre></div>
<p>For the probability monad, thereâ€™s an eliminator for the whole thing, and eliminator for propositional proofs, and a normal eliminator for folding. Hereâ€™s one in action, to define <code>map</code>:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb12-1" data-line-number="1">map <span class="ot">:</span> <span class="ot">(</span>A <span class="ot">â†’</span> B<span class="ot">)</span> <span class="ot">â†’</span> [ A â†¦ ğ’« B ]</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">[ map f ] p &amp; x âˆ· xs <span class="ot">=</span> p &amp; f x âˆ· xs</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">[ map f ][] <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb12-4" data-line-number="4">[ map f ]-set <span class="ot">=</span> trunc</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">[ map f ]-dup p q x xs <span class="ot">=</span> dup p q <span class="ot">(</span>f x<span class="ot">)</span> xs</a>
<a class="sourceLine" id="cb12-6" data-line-number="6">[ map f ]-com p x q y xs <span class="ot">=</span> com p <span class="ot">(</span>f x<span class="ot">)</span> q <span class="ot">(</span>f y<span class="ot">)</span> xs</a>
<a class="sourceLine" id="cb12-7" data-line-number="7">[ map f ]-del x xs <span class="ot">=</span> del <span class="ot">(</span>f x<span class="ot">)</span> xs</a></code></pre></div>
<p>And hereâ€™s one proving that union is associative:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb13-1" data-line-number="1">âˆª-assoc <span class="ot">:</span> <span class="ot">âˆ€</span> ys zs <span class="ot">â†’</span> âŸ¦ xs âˆˆğ’« A â‡’ xs âˆª <span class="ot">(</span>ys âˆª zs<span class="ot">)</span> â‰¡ <span class="ot">(</span>xs âˆª ys<span class="ot">)</span> âˆª zs âŸ§</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">âŸ¦ âˆª-assoc ys zs âŸ§-prop <span class="ot">=</span> trunc <span class="ot">_</span> <span class="ot">_</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">âŸ¦ âˆª-assoc ys zs âŸ§[] <span class="ot">=</span> refl</a>
<a class="sourceLine" id="cb13-4" data-line-number="4">âŸ¦ âˆª-assoc ys zs âŸ§ p &amp; x âˆ· xs âŸ¨ P âŸ© <span class="ot">=</span> cong <span class="ot">(</span>p &amp; x âˆ·<span class="ot">_)</span> P</a></code></pre></div>
<p>Finally, the main event: monadic bind.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="ot">_</span>=&lt;&lt; <span class="ot">:</span> <span class="ot">(</span>A <span class="ot">â†’</span> ğ’« B<span class="ot">)</span> <span class="ot">â†’</span> [ A â†¦ ğ’« B ]</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">[ f =&lt;&lt; ] p &amp; x âˆ· xs <span class="ot">=</span> [ cond p ]â†“ <span class="ot">(</span>f x<span class="ot">)</span> âˆª xs</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">[ f =&lt;&lt; ][] <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb14-4" data-line-number="4">[ f =&lt;&lt; ]-set <span class="ot">=</span> trunc</a>
<a class="sourceLine" id="cb14-5" data-line-number="5">[ f =&lt;&lt; ]-del x xs <span class="ot">=</span> cong <span class="ot">(_</span>âˆª xs<span class="ot">)</span> <span class="ot">(</span>âŸ¦ cond-0 âŸ§â‡“ <span class="ot">(</span>f x<span class="ot">))</span></a>
<a class="sourceLine" id="cb14-6" data-line-number="6">[ f =&lt;&lt; ]-dup p q x xs <span class="ot">=</span></a>
<a class="sourceLine" id="cb14-7" data-line-number="7">  [ cond p ]â†“ <span class="ot">(</span>f x<span class="ot">)</span> âˆª [ cond q ]â†“ <span class="ot">(</span>f x<span class="ot">)</span> âˆª xs   â‰¡âŸ¨ âŸ¦ âˆª-assoc <span class="ot">(</span>[ cond q ]â†“ <span class="ot">(</span>f x<span class="ot">))</span> xs âŸ§â‡“ <span class="ot">(</span>[ cond p ]â†“ <span class="ot">(</span>f x<span class="ot">))</span>âŸ©</a>
<a class="sourceLine" id="cb14-8" data-line-number="8">  <span class="ot">(</span>[ cond p ]â†“ <span class="ot">(</span>f x<span class="ot">)</span> âˆª [ cond q ]â†“ <span class="ot">(</span>f x<span class="ot">))</span> âˆª xs â‰¡âŸ¨ cong <span class="ot">(_</span>âˆª xs<span class="ot">)</span> <span class="ot">(</span>âŸ¦ cond-distrib p q âŸ§â‡“ <span class="ot">(</span>f x<span class="ot">)</span> <span class="ot">)</span> âŸ©</a>
<a class="sourceLine" id="cb14-9" data-line-number="9">  [ cond <span class="ot">(</span>p + q<span class="ot">)</span> ]â†“ <span class="ot">(</span>f x<span class="ot">)</span> âˆª xs âˆ</a>
<a class="sourceLine" id="cb14-10" data-line-number="10">[ f =&lt;&lt; ]-com p x q y xs <span class="ot">=</span></a>
<a class="sourceLine" id="cb14-11" data-line-number="11">  [ cond p ]â†“ <span class="ot">(</span>f x<span class="ot">)</span> âˆª [ cond q ]â†“ <span class="ot">(</span>f y<span class="ot">)</span> âˆª xs   â‰¡âŸ¨ âŸ¦ âˆª-assoc <span class="ot">(</span>[ cond q ]â†“ <span class="ot">(</span>f y<span class="ot">))</span> xs âŸ§â‡“ <span class="ot">(</span>[ cond p ]â†“ <span class="ot">(</span>f x<span class="ot">))</span> âŸ©</a>
<a class="sourceLine" id="cb14-12" data-line-number="12">  <span class="ot">(</span>[ cond p ]â†“ <span class="ot">(</span>f x<span class="ot">)</span> âˆª [ cond q ]â†“ <span class="ot">(</span>f y<span class="ot">))</span> âˆª xs â‰¡âŸ¨ cong <span class="ot">(_</span>âˆª xs<span class="ot">)</span> <span class="ot">(</span>âŸ¦ âˆª-comm <span class="ot">(</span>[ cond q ]â†“ <span class="ot">(</span>f y<span class="ot">))</span> âŸ§â‡“ <span class="ot">(</span>[ cond p ]â†“ <span class="ot">(</span>f x<span class="ot">)))</span> âŸ©</a>
<a class="sourceLine" id="cb14-13" data-line-number="13">  <span class="ot">(</span>[ cond q ]â†“ <span class="ot">(</span>f y<span class="ot">)</span> âˆª [ cond p ]â†“ <span class="ot">(</span>f x<span class="ot">))</span> âˆª xs â‰¡Ë˜âŸ¨ âŸ¦ âˆª-assoc <span class="ot">(</span>[ cond p ]â†“ <span class="ot">(</span>f x<span class="ot">))</span> xs âŸ§â‡“ <span class="ot">(</span>[ cond q ]â†“ <span class="ot">(</span>f y<span class="ot">))</span> âŸ©</a>
<a class="sourceLine" id="cb14-14" data-line-number="14">  [ cond q ]â†“ <span class="ot">(</span>f y<span class="ot">)</span> âˆª [ cond p ]â†“ <span class="ot">(</span>f x<span class="ot">)</span> âˆª xs âˆ</a>
<a class="sourceLine" id="cb14-15" data-line-number="15"></a>
<a class="sourceLine" id="cb14-16" data-line-number="16"><span class="ot">_</span>&gt;&gt;=<span class="ot">_</span> <span class="ot">:</span> ğ’« A <span class="ot">â†’</span> <span class="ot">(</span>A <span class="ot">â†’</span> ğ’« B<span class="ot">)</span> <span class="ot">â†’</span> ğ’« B</a>
<a class="sourceLine" id="cb14-17" data-line-number="17">xs &gt;&gt;= f <span class="ot">=</span> [ f =&lt;&lt; ]â†“ xs</a></code></pre></div>
<h1 id="conclusion">Conclusion</h1>
<p>Iâ€™ve really enjoyed working with cubical Agda so far, and the proofs above were a pleasure to write. I think I can use the above definition to get a workable differential privacy monad, also.</p>
<p>Anyway, all the code is available <a href="https://oisdk.github.io/agda-cubical-probability/Probability.html">here</a>.</p>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
