<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Implicit Corecursive Queues - Donnacha Oisín Kidney</title>
        <style>body{color:black;font-family:Garamond,Times New Roman,serif;font-size:14px;margin:0px auto 0px auto;padding-left:5px;padding-right:5px;max-width:600px}math{font-size:13px}img{max-width:600px}div#header{border-bottom:3px double black;margin-bottom:30px;padding:12px 0px 12px 0px}div#logo a{color:black;float:left;font-size:20px;text-decoration:none}div#header #navigation{text-align:right}div#header #navigation a{color:black;font-family:Garamond,Times New Roman,Serif;font-size:18px;margin-left:10px;text-decoration:none;text-transform:uppercase}div#footer{font-family:Garamond,Times New Roman,Serif;border-top:solid 2px black;color:#555;font-size:12px;margin-top:30px;padding:12px 0px 12px 0px;text-align:right}h1{font-family:Garamond,Times New Roman,Serif;font-size:22px;font-weight:normal}h2{font-family:Garamond,Times New Roman,Serif;font-size:20px;font-weight:normal}div.info{color:#555;font-size:15px;font-style:italic}span.quiet{color:#828282;font-style:italic}a{color:black;word-wrap:break-word}ul.post-list{margin-left:0px;padding-left:0px;list-style-type:none}.hidden_source{display:none}ol.serieslist{counter-reset:item;list-style-type:none;padding-left:20}ol li.serieslist:before{content:'Part ' counter(item,decimal) ':';counter-increment:item}table.sourceCode,tr.sourceCode,td.lineNumbers,td.sourceCode,table.sourceCode pre{margin:0;padding:0;border:0;vertical-align:baseline;border:none}td.lineNumbers{border-right:1px solid #AAAAAA;text-align:right;color:#AAAAAA;padding-right:5px;padding-left:5px}td.sourceCode{padding-left:5px}.sourceCode,code,.Agda{font-size:10px;font-family:menlo,monospace}.sourceCode span.kw{color:#262C6A}.sourceCode span.dt{color:#476A97}.sourceCode span.dv{color:#262C6A}.sourceCode span.bn{color:#262C6A}.sourceCode span.fl{color:#262C6A}.sourceCode span.ch{color:#262C6A}.sourceCode span.st{color:#702C51}.sourceCode span.co{color:#435138}.sourceCode span.ot{color:#262C6A}.sourceCode span.al{color:red}.sourceCode span.fu{color:#000000}.sourceCode span.re{color:#000000}.sourceCode span.er{color:red}li{margin-bottom:2px}li:last-child{margin-bottom:0px}.Agda .Comment{color:#B22222}.Agda .Background{}.Agda .Markup{color:#000000}.Agda .Keyword{color:#CD6600}.Agda .String{color:#B22222}.Agda .Number{color:#A020F0}.Agda .Symbol{color:#404040}.Agda .PrimitiveType{color:#0000CD}.Agda .Pragma{color:black}.Agda .Operator{}.Agda .Bound{color:black}.Agda .Generalizable{color:black}.Agda .InductiveConstructor{color:#008B00}.Agda .CoinductiveConstructor{color:#8B7500}.Agda .Datatype{color:#0000CD}.Agda .Field{color:#EE1289}.Agda .Function{color:#0000CD}.Agda .Module{color:#A020F0}.Agda .Postulate{color:#0000CD}.Agda .Primitive{color:#0000CD}.Agda .Record{color:#0000CD}.Agda .DottedPattern{}.Agda .UnsolvedMeta{color:black;background:yellow}.Agda .UnsolvedConstraint{color:black;background:yellow}.Agda .TerminationProblem{color:black;background:#FFA07A}.Agda .IncompletePattern{color:black;background:#F5DEB3}.Agda .Error{color:red;text-decoration:underline}.Agda .TypeChecks{color:black;background:#ADD8E6}.Agda a{text-decoration:none}.Agda a[href]:hover{background-color:#B4EEB4}.sourceCode{overflow-x:auto}</style>
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Donnacha Oisín Kidney</a>
            </div>
            <div id="navigation">
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../rss.xml">Feed</a>
                <a href="../snippets.html">Snippets</a>
            </div>
        </div>

        <div id="content">
            <h2>Implicit Corecursive Queues</h2>

            <div class="info">
    Posted on May 14, 2019
</div>
<div class="info">
    
        Part 6 of a <a href="../series/Breadth-First%20Traversals.html">8-part series on Breadth-First Traversals</a>
    
</div>
<div class="info">
    
        Tags: <a href="../tags/Haskell.html">Haskell</a>
    
</div>

<h1 id="fusion">Fusion</h1>
<p>I was looking again at one of my implementations of breadth-first traversals:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">bfe ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">bfe r <span class="fu">=</span> f r b []</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">    f (<span class="dt">Node</span> x xs) fw bw <span class="fu">=</span> x <span class="fu">:</span> fw (xs <span class="fu">:</span> bw)</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">  </a>
<a class="sourceLine" id="cb1-6" data-line-number="6">    b [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb1-7" data-line-number="7">    b qs <span class="fu">=</span> foldl (foldr f) b qs []</a></code></pre></div>
<p>And I was wondering if I could <em>fuse</em> away the intermediate list. On the following line:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1">f (<span class="dt">Node</span> x xs) fw bw <span class="fu">=</span> x <span class="fu">:</span> fw (xs <span class="fu">:</span> bw)</a></code></pre></div>
<p>The <code>xs : bw</code> is a little annoying, because we <em>know</em> it’s going to be consumed eventually by a fold. When that happens, it’s often a good idea to remove the list, and just inline the fold. In other words, if you see the following:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1">foldr f b (x <span class="fu">:</span> y <span class="fu">:</span> [])</a></code></pre></div>
<p>You should replace it with this:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">f x (f y b)</a></code></pre></div>
<p>If you try and do that with the above definition, you get something like the following:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">bfenum ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">bfenum t <span class="fu">=</span> f t b b</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">    f (<span class="dt">Node</span> x xs) fw bw <span class="fu">=</span> x <span class="fu">:</span> fw (bw <span class="fu">.</span> flip (foldr f) xs)</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">    b x <span class="fu">=</span> x b</a></code></pre></div>
<h1 id="infinite-types">Infinite Types</h1>
<p>The trouble is that the above comes with type errors:</p>
<pre><code>Cannot construct the infinite type: b ~ (b -&gt; c) -&gt; [a]</code></pre>
<p>This error shows up occasionally when you try and do heavy church-encoding in Haskell. You get a similar error when trying to encode the Y combinator:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1">y <span class="fu">=</span> \f <span class="ot">-&gt;</span> (\x <span class="ot">-&gt;</span> f (x x)) (\x <span class="ot">-&gt;</span> f (x x))</a></code></pre></div>
<pre><code>• Occurs check: cannot construct the infinite type: t0 ~ t0 -&gt; t</code></pre>
<p>The solution for the y combinator is to use a newtype, where we can catch the recursion at a certain point to help the typechecker.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Mu</span> a <span class="fu">=</span> <span class="dt">Mu</span> (<span class="dt">Mu</span> a <span class="ot">-&gt;</span> a)</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">y f <span class="fu">=</span> (\h <span class="ot">-&gt;</span> h <span class="fu">$</span> <span class="dt">Mu</span> h) (\x <span class="ot">-&gt;</span> f <span class="fu">.</span> (\(<span class="dt">Mu</span> g) <span class="ot">-&gt;</span> g) x <span class="fu">$</span> x)</a></code></pre></div>
<p>The trick for our queue is similar:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Q</span> a <span class="fu">=</span> <span class="dt">Q</span> {<span class="ot"> q ::</span> (<span class="dt">Q</span> a <span class="ot">-&gt;</span> [a]) <span class="ot">-&gt;</span> [a] }</a>
<a class="sourceLine" id="cb10-2" data-line-number="2"></a>
<a class="sourceLine" id="cb10-3" data-line-number="3"><span class="ot">bfenum ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">bfenum t <span class="fu">=</span> q (f t b) e</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-6" data-line-number="6">    f (<span class="dt">Node</span> x xs) fw <span class="fu">=</span> <span class="dt">Q</span> (\bw <span class="ot">-&gt;</span> x <span class="fu">:</span> q fw (bw <span class="fu">.</span> flip (foldr f) xs))</a>
<a class="sourceLine" id="cb10-7" data-line-number="7">    b <span class="fu">=</span> fix (<span class="dt">Q</span> <span class="fu">.</span> flip id)</a>
<a class="sourceLine" id="cb10-8" data-line-number="8">    e <span class="fu">=</span> fix (flip q)</a></code></pre></div>
<p>This is actually equivalent to the continuation monad:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Fix</span> f <span class="fu">=</span> <span class="dt">Fix</span> {<span class="ot"> unFix ::</span> f (<span class="dt">Fix</span> f) }</a>
<a class="sourceLine" id="cb11-2" data-line-number="2"></a>
<a class="sourceLine" id="cb11-3" data-line-number="3"><span class="kw">type</span> <span class="dt">Q</span> a <span class="fu">=</span> <span class="dt">Fix</span> (<span class="dt">ContT</span> a [])</a>
<a class="sourceLine" id="cb11-4" data-line-number="4"></a>
<a class="sourceLine" id="cb11-5" data-line-number="5">q <span class="fu">=</span> runContT <span class="fu">.</span> unFix</a>
<a class="sourceLine" id="cb11-6" data-line-number="6"></a>
<a class="sourceLine" id="cb11-7" data-line-number="7"><span class="ot">bfenum ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb11-8" data-line-number="8">bfenum t <span class="fu">=</span> q (f t b) e</a>
<a class="sourceLine" id="cb11-9" data-line-number="9">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-10" data-line-number="10">    f (<span class="dt">Node</span> x xs) fw <span class="fu">=</span> <span class="dt">Fix</span> (mapContT (x<span class="fu">:</span>) (flip (foldr f) xs <span class="fu">&lt;$&gt;</span> unFix fw))</a>
<a class="sourceLine" id="cb11-11" data-line-number="11">    b <span class="fu">=</span> fix (<span class="dt">Fix</span> <span class="fu">.</span> pure)</a>
<a class="sourceLine" id="cb11-12" data-line-number="12">    e <span class="fu">=</span> fix (flip q)</a></code></pre></div>
<h1 id="terminating">Terminating</h1>
<p>There’s a problem though: this algorithm never checks for an end. That’s ok if there isn’t one, mind you. For instance, with the following “unfold” function:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">9</span> <span class="fu">#.</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="ot">(#.) ::</span> <span class="dt">Coercible</span> b c <span class="ot">=&gt;</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> c</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">(<span class="fu">#.</span>) _ <span class="fu">=</span> coerce</a>
<a class="sourceLine" id="cb12-4" data-line-number="4"><span class="ot">{-# INLINE (#.) #-}</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5"></a>
<a class="sourceLine" id="cb12-6" data-line-number="6"><span class="ot">bfUnfold ::</span> (a <span class="ot">-&gt;</span> (b,[a])) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [b]</a>
<a class="sourceLine" id="cb12-7" data-line-number="7">bfUnfold f t <span class="fu">=</span> g t (fix (<span class="dt">Q</span> <span class="fu">#.</span> flip id)) (fix (flip q))</a>
<a class="sourceLine" id="cb12-8" data-line-number="8">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-9" data-line-number="9">    g b fw bw <span class="fu">=</span> x <span class="fu">:</span> q fw (bw <span class="fu">.</span> flip (foldr ((<span class="dt">Q</span> <span class="fu">.</span>) <span class="fu">#.</span> g)) xs)</a>
<a class="sourceLine" id="cb12-10" data-line-number="10">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-11" data-line-number="11">        (x,xs) <span class="fu">=</span> f b</a></code></pre></div>
<p>We can write a decent enumeration of the rationals.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="co">-- Stern-Brocot</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2"><span class="ot">rats1 ::</span> [<span class="dt">Rational</span>]</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">rats1 <span class="fu">=</span> bfUnfold step ((<span class="dv">0</span>,<span class="dv">1</span>),(<span class="dv">1</span>,<span class="dv">0</span>))</a>
<a class="sourceLine" id="cb13-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5">    step (lb,rb) <span class="fu">=</span> (n <span class="fu">%</span> d,[(lb , m),(m , rb)])</a>
<a class="sourceLine" id="cb13-6" data-line-number="6">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-7" data-line-number="7">        m<span class="fu">@</span>(n,d) <span class="fu">=</span> adj lb rb</a>
<a class="sourceLine" id="cb13-8" data-line-number="8">    adj (w,x) (y,z) <span class="fu">=</span> (w<span class="fu">+</span>y,x<span class="fu">+</span>z)</a>
<a class="sourceLine" id="cb13-9" data-line-number="9">    </a>
<a class="sourceLine" id="cb13-10" data-line-number="10"><span class="co">-- Calkin-Wilf</span></a>
<a class="sourceLine" id="cb13-11" data-line-number="11"><span class="ot">rats2 ::</span> [<span class="dt">Rational</span>]</a>
<a class="sourceLine" id="cb13-12" data-line-number="12">rats2 <span class="fu">=</span> bfUnfold step (<span class="dv">1</span>,<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb13-13" data-line-number="13">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-14" data-line-number="14">    step (m,n) <span class="fu">=</span> (m <span class="fu">%</span> n,[(m,m<span class="fu">+</span>n),(n<span class="fu">+</span>m,n)])</a></code></pre></div>
<p>However, if we <em>do</em> want to stop at some point, we need a slight change to the queue type.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Q</span> a <span class="fu">=</span> <span class="dt">Q</span> {<span class="ot"> q ::</span> <span class="dt">Maybe</span> (<span class="dt">Q</span> a <span class="ot">-&gt;</span> [a]) <span class="ot">-&gt;</span> [a] }</a>
<a class="sourceLine" id="cb14-2" data-line-number="2"></a>
<a class="sourceLine" id="cb14-3" data-line-number="3"><span class="ot">bfenum ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb14-4" data-line-number="4">bfenum t <span class="fu">=</span> q (f t b) e</a>
<a class="sourceLine" id="cb14-5" data-line-number="5">  <span class="kw">where</span> </a>
<a class="sourceLine" id="cb14-6" data-line-number="6">    f (<span class="dt">Node</span> x xs) fw <span class="fu">=</span> <span class="dt">Q</span> (\bw <span class="ot">-&gt;</span> x <span class="fu">:</span> q fw (<span class="dt">Just</span> (m bw <span class="fu">.</span> flip (foldr f) xs)))</a>
<a class="sourceLine" id="cb14-7" data-line-number="7">    b <span class="fu">=</span> fix (<span class="dt">Q</span> <span class="fu">.</span> maybe [] <span class="fu">.</span> flip (<span class="fu">$</span>))</a>
<a class="sourceLine" id="cb14-8" data-line-number="8">    e <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb14-9" data-line-number="9">    m <span class="fu">=</span> fromMaybe (flip q e)</a></code></pre></div>
<h1 id="monadic">Monadic</h1>
<p>We can actually add in a monad to the above unfold without much difficulty.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Q</span> m a <span class="fu">=</span> <span class="dt">Q</span> {<span class="ot"> q ::</span> <span class="dt">Maybe</span> (<span class="dt">Q</span> m a <span class="ot">-&gt;</span> m [a]) <span class="ot">-&gt;</span> m [a] }</a>
<a class="sourceLine" id="cb15-2" data-line-number="2"></a>
<a class="sourceLine" id="cb15-3" data-line-number="3"><span class="ot">bfUnfold ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m (b,[a])) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> m [b]</a>
<a class="sourceLine" id="cb15-4" data-line-number="4">bfUnfold f t <span class="fu">=</span> g t b e</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-6" data-line-number="6">    g s fw bw <span class="fu">=</span> f s <span class="fu">&gt;&gt;=</span> </a>
<a class="sourceLine" id="cb15-7" data-line-number="7">       \ <span class="fu">~</span>(x,xs) <span class="ot">-&gt;</span> (x <span class="fu">:</span>) <span class="fu">&lt;$&gt;</span>  q fw (<span class="dt">Just</span> (m bw <span class="fu">.</span> flip (foldr ((<span class="dt">Q</span> <span class="fu">.</span>) <span class="fu">#.</span> g)) xs))</a>
<a class="sourceLine" id="cb15-8" data-line-number="8">        </a>
<a class="sourceLine" id="cb15-9" data-line-number="9">    b <span class="fu">=</span> fix (<span class="dt">Q</span> <span class="fu">#.</span> maybe (pure []) <span class="fu">.</span> flip (<span class="fu">$</span>))</a>
<a class="sourceLine" id="cb15-10" data-line-number="10">    e <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb15-11" data-line-number="11">    m <span class="fu">=</span> fromMaybe (flip q e)</a></code></pre></div>
<p>And it passes the torture tests for a linear-time breadth-first unfold from <span class="citation" data-cites="feuer_is_2015">Feuer (<a href="#ref-feuer_is_2015">2015</a>)</span>. It breaks when you try and use it to build a tree, though.</p>
<h1 id="phases">Phases</h1>
<p>Finally, we can try and make the above code a little more modular, by actually packaging up the queue type as a queue.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Q</span> a <span class="fu">=</span> <span class="dt">Q</span> {<span class="ot"> q ::</span> <span class="dt">Maybe</span> (<span class="dt">Q</span> a <span class="ot">-&gt;</span> [a]) <span class="ot">-&gt;</span> [a] }</a>
<a class="sourceLine" id="cb16-2" data-line-number="2"><span class="kw">newtype</span> <span class="dt">Queue</span> a <span class="fu">=</span> <span class="dt">Queue</span> {<span class="ot"> runQueue ::</span> <span class="dt">Q</span> a <span class="ot">-&gt;</span> <span class="dt">Q</span> a }</a>
<a class="sourceLine" id="cb16-3" data-line-number="3"></a>
<a class="sourceLine" id="cb16-4" data-line-number="4"><span class="ot">now ::</span> a <span class="ot">-&gt;</span> <span class="dt">Queue</span> a</a>
<a class="sourceLine" id="cb16-5" data-line-number="5">now x <span class="fu">=</span> <span class="dt">Queue</span> (\fw <span class="ot">-&gt;</span> <span class="dt">Q</span> (\bw <span class="ot">-&gt;</span> x <span class="fu">:</span> q fw bw))</a>
<a class="sourceLine" id="cb16-6" data-line-number="6">    </a>
<a class="sourceLine" id="cb16-7" data-line-number="7"><span class="ot">delay ::</span> <span class="dt">Queue</span> a <span class="ot">-&gt;</span> <span class="dt">Queue</span> a</a>
<a class="sourceLine" id="cb16-8" data-line-number="8">delay xs <span class="fu">=</span> <span class="dt">Queue</span> (\fw <span class="ot">-&gt;</span> <span class="dt">Q</span> (\bw <span class="ot">-&gt;</span> q fw (<span class="dt">Just</span> (m bw <span class="fu">.</span> runQueue xs))))</a>
<a class="sourceLine" id="cb16-9" data-line-number="9">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-10" data-line-number="10">    m <span class="fu">=</span> fromMaybe (flip q <span class="dt">Nothing</span>)</a>
<a class="sourceLine" id="cb16-11" data-line-number="11">    </a>
<a class="sourceLine" id="cb16-12" data-line-number="12"><span class="kw">instance</span> <span class="dt">Monoid</span> (<span class="dt">Queue</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-13" data-line-number="13">    mempty <span class="fu">=</span> <span class="dt">Queue</span> id</a>
<a class="sourceLine" id="cb16-14" data-line-number="14">    mappend (<span class="dt">Queue</span> xs) (<span class="dt">Queue</span> ys) <span class="fu">=</span> <span class="dt">Queue</span> (xs <span class="fu">.</span> ys)</a>
<a class="sourceLine" id="cb16-15" data-line-number="15">    </a>
<a class="sourceLine" id="cb16-16" data-line-number="16"><span class="ot">run ::</span> <span class="dt">Queue</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb16-17" data-line-number="17">run (<span class="dt">Queue</span> xs) <span class="fu">=</span> q (xs b) <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb16-18" data-line-number="18">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-19" data-line-number="19">    b <span class="fu">=</span> fix (<span class="dt">Q</span> <span class="fu">.</span> maybe [] <span class="fu">.</span> flip (<span class="fu">$</span>))</a>
<a class="sourceLine" id="cb16-20" data-line-number="20"></a>
<a class="sourceLine" id="cb16-21" data-line-number="21"><span class="ot">bfenum ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb16-22" data-line-number="22">bfenum t <span class="fu">=</span> run (f t)</a>
<a class="sourceLine" id="cb16-23" data-line-number="23">  <span class="kw">where</span> </a>
<a class="sourceLine" id="cb16-24" data-line-number="24">    f (<span class="dt">Node</span> x xs) <span class="fu">=</span> now x <span class="fu">&lt;&gt;</span> delay (foldMap f xs)</a></code></pre></div>
<p>At this point, our type is starting to look a lot like the <a href="https://hackage.haskell.org/package/tree-traversals-0.1.0.0/docs/Control-Applicative-Phases.html#t:Phases"><code>Phases</code></a> type from Noah Easterly’s tree-traversals package. This is exciting: the <code>Phases</code> type has the ideal interface for level-wise traversals. Unfortunately, it has the wrong time complexity for <code>&lt;*&gt;</code> and so on: my suspicion is that the queue type above here is to <code>Phases</code> as the continuation monad is to the free monad. In other words, we’ll get efficient construction at the expense of no inspection. Unfortunately, I can’t figure out how to turn the above type into an applicative. Maybe in a future post!</p>
<p>Finally, a lot of this is working towards finally understanding <span class="citation" data-cites="smith_lloyd_2009">Smith (<a href="#ref-smith_lloyd_2009">2009</a>)</span> and <span class="citation" data-cites="allison_circular_2006">Allison (<a href="#ref-allison_circular_2006">2006</a>)</span>.</p>
<div id="refs" class="references">
<div id="ref-allison_circular_2006">
<p>Allison, Lloyd. 2006. “Circular Programs and Self-Referential Structures.” <em>Software: Practice and Experience</em> 19 (2) (October): 99–109. doi:<a href="https://doi.org/10.1002/spe.4380190202">10.1002/spe.4380190202</a>. <a href="http://users.monash.edu/~lloyd/tildeFP/1989SPE/" class="uri">http://users.monash.edu/~lloyd/tildeFP/1989SPE/</a>.</p>
</div>
<div id="ref-feuer_is_2015">
<p>Feuer, David. 2015. “Is a lazy, breadth-first monadic rose tree unfold possible?” Question. <em>Stack Overflow</em>. <a href="https://stackoverflow.com/q/27748526" class="uri">https://stackoverflow.com/q/27748526</a>.</p>
</div>
<div id="ref-smith_lloyd_2009">
<p>Smith, Leon P. 2009. “Lloyd Allison’s Corecursive Queues: Why Continuations Matter.” <em>The Monad.Reader</em> 14 (14) (July): 28. <a href="https://meldingmonads.files.wordpress.com/2009/06/corecqueues.pdf" class="uri">https://meldingmonads.files.wordpress.com/2009/06/corecqueues.pdf</a>.</p>
</div>
</div>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
