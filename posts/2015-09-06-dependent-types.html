<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Faking dependent types in Swift - Donnacha Oisín Kidney</title>
        <style>body{color:black;font-family:Garamond,Times New Roman,serif;font-size:15px;margin:0px auto 0px auto;padding-left:5px;padding-right:5px;max-width:650px}math{font-size:13px}img{max-width:600px}summary{outline:0}div#header{border-bottom:3px double black;margin-bottom:30px;padding:12px 0px 12px 0px}div#logo a{color:black;float:left;font-size:20px;text-decoration:none}div#header #navigation{text-align:right}div#header #navigation a{color:black;font-family:Garamond,Times New Roman,Serif;font-size:18px;margin-left:10px;text-decoration:none;text-transform:uppercase}div#footer{font-family:Garamond,Times New Roman,Serif;border-top:solid 2px black;color:#555;font-size:12px;margin-top:30px;padding:12px 0px 12px 0px;text-align:right}h1{font-family:Garamond,Times New Roman,Serif;font-size:22px;font-weight:normal}h2{font-family:Garamond,Times New Roman,Serif;font-size:20px;font-weight:normal}div.info{color:#555;font-size:15px;font-style:italic}span.quiet{color:#828282;font-style:italic}a{color:black;word-wrap:break-word}ul.post-list{margin-left:0px;padding-left:0px;list-style-type:none}.hidden_source{display:none}ol.serieslist{counter-reset:item;list-style-type:none;padding-left:20}ol li.serieslist:before{content:'Part ' counter(item,decimal) ':';counter-increment:item}table.sourceCode,tr.sourceCode,td.lineNumbers,td.sourceCode,table.sourceCode pre{margin:0;padding:0;border:0;vertical-align:baseline;border:none}td.lineNumbers{border-right:1px solid #AAAAAA;text-align:right;color:#AAAAAA;padding-right:5px;padding-left:5px}td.sourceCode{padding-left:5px}.sourceCode,code,pre,.Agda{font-size:10px;font-family:menlo,monospace}.sourceCode span.kw{color:#262C6A}.sourceCode span.dt{color:#476A97}.sourceCode span.dv{color:#262C6A}.sourceCode span.bn{color:#262C6A}.sourceCode span.fl{color:#262C6A}.sourceCode span.ch{color:#262C6A}.sourceCode span.st{color:#702C51}.sourceCode span.co{color:#435138}.sourceCode span.ot{color:#262C6A}.sourceCode span.al{color:red}.sourceCode span.fu{color:#000000}.sourceCode span.re{color:#000000}.sourceCode span.er{color:red}li{margin-bottom:2px}li:last-child{margin-bottom:0px}.Agda .Comment{color:#B22222}.Agda .Background{}.Agda .Markup{color:#000000}.Agda .Keyword{color:#CD6600}.Agda .String{color:#B22222}.Agda .Number{color:#A020F0}.Agda .Symbol{color:#404040}.Agda .PrimitiveType{color:#0000CD}.Agda .Pragma{color:black}.Agda .Operator{}.Agda .Bound{color:black}.Agda .Generalizable{color:black}.Agda .InductiveConstructor{color:#008B00}.Agda .CoinductiveConstructor{color:#8B7500}.Agda .Datatype{color:#0000CD}.Agda .Field{color:#EE1289}.Agda .Function{color:#0000CD}.Agda .Module{color:#A020F0}.Agda .Postulate{color:#0000CD}.Agda .Primitive{color:#0000CD}.Agda .Record{color:#0000CD}.Agda .DottedPattern{}.Agda .UnsolvedMeta{color:black;background:yellow}.Agda .UnsolvedConstraint{color:black;background:yellow}.Agda .TerminationProblem{color:black;background:#FFA07A}.Agda .IncompletePattern{color:black;background:#F5DEB3}.Agda .Error{color:red;text-decoration:underline}.Agda .TypeChecks{color:black;background:#ADD8E6}.Agda a{text-decoration:none}.Agda a[href]:hover{background-color:#B4EEB4}.sourceCode{overflow-x:auto}</style>
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Donnacha Oisín Kidney</a>
            </div>
            <div id="navigation">
                <a href="../publications.html">Publications</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../rss.xml">Feed</a>
            </div>
        </div>

        <div id="content">
            <h2>Faking dependent types in Swift</h2>

            <div class="info">
    Posted on September  6, 2015
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a title="All pages tagged 'Swift'." href="../tags/Swift.html" rel="tag">Swift</a>, <a title="All pages tagged 'Dependent Types'." href="../tags/Dependent%20Types.html" rel="tag">Dependent Types</a>
    
</div>

<p><a href="https://en.wikipedia.org/wiki/Dependent_type">Dependent
types</a> are types “that depend on values”. Say you had a function
<code class="sourceCode scala">f</code> that took an integer. If you can
write that function whereby it returns a value of type <code class="sourceCode scala">A</code> when that integer is even, or a type
<code class="sourceCode scala">B</code> if the integer is odd, then
you’re working with dependent types. (I think. I’m not sure: if I’ve got
it wrong <a href="https://twitter.com/oisdk">tweet me</a>.)</p>
<h2 id="dependent-pretendance">Dependent Pretendance</h2>
<p>As far as I can tell, this is not possible in Swift. All variables
are statically typed, and those types must be found at compile-time. As
long as you’re not messing around with casting:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>struct A <span class="op">{}</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>struct B <span class="op">{}</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>func <span class="fu">f</span><span class="op">(</span>i<span class="op">:</span> <span class="bu">Int</span><span class="op">)</span> <span class="op">-&gt;</span> AnyObject <span class="op">{</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> i <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">?</span> <span class="fu">A</span><span class="op">()</span> as<span class="op">!</span> AnyObject <span class="op">:</span> <span class="fu">B</span><span class="op">()</span> as<span class="op">!</span> AnyObject</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>You won’t be able to manage it.</p>
<p>Now, sum types can give you something that <em>looks</em> like
dependent types:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>struct A <span class="op">{}</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>struct B <span class="op">{}</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>enum SumType <span class="op">{</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> <span class="fu">Even</span><span class="op">(</span>A<span class="op">),</span> <span class="fu">Odd</span><span class="op">(</span>B<span class="op">)</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>func <span class="fu">f</span><span class="op">(</span>i<span class="op">:</span> <span class="bu">Int</span><span class="op">)</span> <span class="op">-&gt;</span> SumType <span class="op">{</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> i <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">?</span> <span class="op">.</span><span class="fu">Even</span><span class="op">(</span><span class="fu">A</span><span class="op">())</span> <span class="op">:</span> <span class="op">.</span><span class="fu">Odd</span><span class="op">(</span><span class="fu">B</span><span class="op">())</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>But that doesn’t fit the description: the thing returned is of type
<code class="sourceCode scala">SumType</code>, <em>not</em> <code class="sourceCode scala">A</code> or <code class="sourceCode scala">B</code>.</p>
<p>That’s fine, though. As with all of these highfalutin mathematical
concepts in programming, you can steal some of the cool and fun
<em>patterns</em> from your Haskells and Lisps and Idrises and implement
them in whatever language you want.</p>
<p>As it happens, implementing this stuff in Swift gets you even
<em>further</em> away from the formal definition of dependent types.
Instead of allowing types to be decided at runtime, you end up forcing
even <em>more</em> resolution and computation to happen at compile-time.
Take “numbers-as-types”, for instance:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>protocol Nat <span class="op">{</span> <span class="fu">init</span><span class="op">()</span> <span class="op">}</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>struct Zero <span class="op">:</span> Nat <span class="op">{}</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>protocol NonZero<span class="op">:</span> Nat <span class="op">{</span> typealias Pred<span class="op">:</span> Nat <span class="op">}</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>struct Succ<span class="op">&lt;</span>N <span class="op">:</span> Nat<span class="op">&gt;</span> <span class="op">:</span> NonZero <span class="op">{</span> typealias Pred <span class="op">=</span> N <span class="op">}</span></span></code></pre></div>
<p>Once you encode some numbers by hand:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>typealias One   <span class="op">=</span> Succ<span class="op">&lt;</span>Zero<span class="op">&gt;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>typealias Two   <span class="op">=</span> Succ<span class="op">&lt;</span>One<span class="op">&gt;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>typealias Three <span class="op">=</span> Succ<span class="op">&lt;</span>Two<span class="op">&gt;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>typealias Four  <span class="op">=</span> Succ<span class="op">&lt;</span>Three<span class="op">&gt;</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>typealias Five  <span class="op">=</span> Succ<span class="op">&lt;</span>Four<span class="op">&gt;</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>typealias Six   <span class="op">=</span> Succ<span class="op">&lt;</span>Five<span class="op">&gt;</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>typealias Seven <span class="op">=</span> Succ<span class="op">&lt;</span>Six<span class="op">&gt;</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>typealias Eight <span class="op">=</span> Succ<span class="op">&lt;</span>Seven<span class="op">&gt;</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>typealias Nine  <span class="op">=</span> Succ<span class="op">&lt;</span>Eight<span class="op">&gt;</span></span></code></pre></div>
<p>You get thinking about exactly <em>how much</em> computation you can
achieve at compile time:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>Sum<span class="op">&lt;</span>One<span class="op">,</span> Two<span class="op">&gt;.</span><span class="ex">Result</span>    <span class="co">// Three</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>Comp<span class="op">&lt;</span>Five<span class="op">,</span> Nine<span class="op">&gt;.</span><span class="ex">Result</span> <span class="co">// LT</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>Comp<span class="op">&lt;</span>Four<span class="op">,</span> Four<span class="op">&gt;.</span><span class="ex">Result</span> <span class="co">// EQ</span></span></code></pre></div>
<h2 id="sum-types-divide-types-multiply-types">Sum types, divide types,
multiply types</h2>
<p>What I wanted, ideally, was some basic “Algebraic data types”.
(Today. Today was the day I made the worst pun.) I wanted to be able to
add the type <code class="sourceCode scala">One</code> to the type <code class="sourceCode scala">Two</code> and get the type <code class="sourceCode scala">Three</code>. Once you can manage those,
multiplication, division and all kinds of silliness are possible. I set
myself some rules: all calculations must be performed at compile-time,
and all calculations must work with arbitrary values.</p>
<p>I’ve not been able to manage, unfortunately. If someone could figure
out how to do it, I would <a href="https://twitter.com/oisdk">love to
hear it</a>. I’ve been stealing ideas from <a href="http://strictlypositive.org/faking.ps.gz">Faking It: Simulating
Dependent Types in Haskell</a> mainly.</p>
<p>Here’s the kind of code that made me think it was possible:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>let ar <span class="op">=</span> <span class="op">[</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">].</span><span class="fu">reverse</span><span class="op">()</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>let se <span class="op">=</span> <span class="fu">AnySequence</span><span class="op">([</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">]).</span><span class="fu">reverse</span><span class="op">()</span></span></code></pre></div>
<p>The types returned by those two methods are different. This is all to
do with that protocol-oriented-programming business: the compiler will
try to select the most specialised version of a method to use. So in the
example above, since an array can just be indexed backwards, the
compiler uses a method that returns a lazy <code class="sourceCode scala">ReverseRandomAccessCollection</code>. However,
for the <code class="sourceCode scala">AnySequence</code>, the <code class="sourceCode scala">reverse</code> method has to create a whole new
array.</p>
<p>With that in mind, we can make a protocol:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>protocol BinaryOp <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  typealias A<span class="op">:</span> Nat</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  typealias B<span class="op">:</span> Nat</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Then, we can extend it, like this:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>struct EQ <span class="op">{}</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>extension BinaryOp where A <span class="op">==</span> B <span class="op">{</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  typealias <span class="ex">Result</span> <span class="op">=</span> EQ</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>So far, so good! The compiler will add that method to all types that
conform to the <code class="sourceCode scala">where</code> clause. So if
there is a concrete type that conforms to <code>BinaryOp</code>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>struct Comp<span class="op">&lt;</span>E0<span class="op">:</span> Nat<span class="op">,</span> E1<span class="op">:</span> Nat<span class="op">&gt;</span> <span class="op">:</span> BinaryOp <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  typealias A <span class="op">=</span> E0</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  typealias B <span class="op">=</span> E1</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Only instances where <code class="sourceCode scala">A</code> and
<code class="sourceCode scala">B</code> are equal will get the type
alias:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>Comp<span class="op">&lt;</span>One<span class="op">,</span> One<span class="op">&gt;.</span><span class="ex">Result</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>Comp<span class="op">&lt;</span>One<span class="op">,</span> Two<span class="op">&gt;.</span><span class="ex">Result</span> <span class="co">// Error</span></span></code></pre></div>
<p>But that’s not ideal. We want something that returns <code class="sourceCode scala">NEQ</code> when the types are not the same.
Easy enough, right?</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>struct NEQ <span class="op">{}</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>extension BinaryOp <span class="op">{</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  typealias <span class="ex">Result</span> <span class="op">=</span> NEQ</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>But there’s an error: <code class="sourceCode scala">invalid redeclaration of <span class="er">'</span>Result<span class="er">'</span></code>.
The compiler won’t allow polymorphism with typealiases. It <em>does</em>
allow polymorphism with properties, though:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>extension BinaryOp <span class="op">{</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">var</span> r<span class="op">:</span> EQ <span class="op">{</span> <span class="cf">return</span> <span class="fu">EQ</span><span class="op">()</span> <span class="op">}</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>extension BinaryOp where A <span class="op">==</span> B <span class="op">{</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">var</span> r<span class="op">:</span> NEQ <span class="op">{</span> <span class="cf">return</span> <span class="fu">NEQ</span><span class="op">()</span> <span class="op">}</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This is already a less elegant solution than the typealiases, since
we’re going to have to initialise things. All of the type information is
available at compile-time, though, so I’ve not broken any of my
rules.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>Comp<span class="op">&lt;</span>One<span class="op">,</span> One<span class="op">&gt;().</span>r <span class="co">// EQ</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>Comp<span class="op">&lt;</span>One<span class="op">,</span> Two<span class="op">&gt;().</span>r <span class="co">// NEQ</span></span></code></pre></div>
<p>How about something more complex? Instead of <code class="sourceCode scala">EQ</code> and <code class="sourceCode scala">NEQ</code>, maybe <code class="sourceCode scala">LT</code>, <code class="sourceCode scala">GT</code>, and <code>EQ</code>?</p>
<p>It’s hard to see how it would work. Well, here’s the base case:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>extension BinaryOp where A <span class="op">==</span> B <span class="op">{</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">var</span> r<span class="op">:</span> EQ <span class="op">{</span> <span class="cf">return</span> <span class="fu">EQ</span><span class="op">()</span> <span class="op">}</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Then, any non-zero is bigger than zero:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>struct LT <span class="op">{}</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>extension BinaryOp where A <span class="op">==</span> Zero<span class="op">,</span> B <span class="op">:</span> NonZero <span class="op">{</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">var</span> r<span class="op">:</span> LT <span class="op">{</span> <span class="cf">return</span> <span class="fu">LT</span><span class="op">()</span> <span class="op">}</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>struct GT <span class="op">{}</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>extension BinaryOp where A <span class="op">:</span> NonZero<span class="op">,</span> B <span class="op">==</span> Zero <span class="op">{</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">var</span> r<span class="op">:</span> GT <span class="op">{</span> <span class="cf">return</span> <span class="fu">GT</span><span class="op">()</span> <span class="op">}</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>If both <code class="sourceCode scala">A</code> and <code class="sourceCode scala">B</code> are nonzero, they should have a <code class="sourceCode scala">Pred</code> typealias, which we can use,
recursively:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>extension BinaryOp where A <span class="op">:</span> NonZero<span class="op">,</span> B <span class="op">:</span> NonZero <span class="op">{</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">var</span> r<span class="op">:</span> <span class="op">??</span> <span class="op">{</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> Comp<span class="op">&lt;</span>A<span class="op">.</span>Pred<span class="op">,</span> B<span class="op">.</span>Pred<span class="op">&gt;().</span>r</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This doesn’t work. I’m fairly sure this is a definitive dead end.
Here’s the error: <code class="sourceCode scala">ambiguous reference to member <span class="ch">'r'</span></code>.
The problem is that that error encapsulates exactly what I’m trying to
achieve: I <em>want</em> the reference to be ambiguous, so it
<em>depends</em> on the types of <code class="sourceCode scala">A</code>
and <code class="sourceCode scala">B</code>. Most other routes I went
down hit similar roadblocks:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>protocol BinaryOp <span class="op">{</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>  typealias A<span class="op">:</span> Nat</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  typealias B<span class="op">:</span> Nat</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>  typealias <span class="ex">Result</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">var</span> r<span class="op">:</span> <span class="ex">Result</span> <span class="op">{</span> get <span class="op">}</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The idea here was that you could have various implementations of
<code class="sourceCode scala">r</code>, so that the <code class="sourceCode scala"><span class="ex">Result</span></code> typealias
would be inferred. The problem is the compiler wants to figure out what
<code class="sourceCode scala"><span class="ex">Result</span></code> is
when you make a type that conforms to the protocol, so every type will
get the default implementation.</p>
<p>Yet more versions I tried all hit the <code class="sourceCode scala">ambiguous</code> error, which makes me think
this kind of thing is fundamentally impossible in Swift’s current
form.</p>
<p>So I’ve got to break one of the rules: no more arbitrary numbers.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>struct AddOne<span class="op">&lt;</span>N <span class="op">:</span> Nat<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>  typealias <span class="ex">Result</span> <span class="op">=</span> Succ<span class="op">&lt;</span>N<span class="op">&gt;</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>struct AddTwo<span class="op">&lt;</span>N <span class="op">:</span> Nat<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>  typealias <span class="ex">Result</span> <span class="op">=</span> Succ<span class="op">&lt;</span>AddOne<span class="op">&lt;</span>N<span class="op">&gt;.</span><span class="ex">Result</span><span class="op">&gt;</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>And so on. Or:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>extension Binary where A <span class="op">==</span> B <span class="op">{</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">var</span> sub<span class="op">:</span> Zero <span class="op">{</span> <span class="cf">return</span> <span class="fu">Zero</span><span class="op">()</span> <span class="op">}</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">var</span> com<span class="op">:</span> EQ <span class="op">{</span> <span class="cf">return</span> <span class="fu">EQ</span><span class="op">()</span> <span class="op">}</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>extension Binary where A <span class="op">==</span> Succ<span class="op">&lt;</span>B<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">var</span> sub<span class="op">:</span> One <span class="op">{</span> <span class="cf">return</span> <span class="fu">One</span><span class="op">()</span> <span class="op">}</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">var</span> com<span class="op">:</span> GT <span class="op">{</span> <span class="cf">return</span> <span class="fu">GT</span><span class="op">()</span> <span class="op">}</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Which can give you subtraction.</p>
<h2 id="lets-pretend-to-be-useful">Let’s Pretend to be Useful</h2>
<p>All of that stuff is interesting, but very <em>very</em> far from
being useful.</p>
<p>The <a href="https://bigonotetaking.wordpress.com/2015/09/04/in-which-i-misunderstand-dependent-types/">length-indexed
list from the other day</a> probably is useful, though. As well as being
kind of cool and safe, there are some (minor) optimisations it can
do.</p>
<p>The other dependent type staple is the heterogenous list.</p>
<p>Now, this isn’t just any heterogenous list: we’re not writing Python
here. This is a <em>statically typed</em> heterogenous list. Swift has a
construct very similar to this already: a tuple!</p>
<p>But tuples aren’t very extensible:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>extension Tuple where First <span class="op">:</span> <span class="ex">Comparable</span> <span class="op">{...</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>extension Tuple where Count <span class="op">==</span> Two <span class="op">{...</span></span></code></pre></div>
<p>And you can’t work with them in terms that most lists can:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="st">&quot;a&quot;</span><span class="op">,</span> <span class="fl">2.0</span><span class="op">)</span> <span class="op">+</span> <span class="op">(</span><span class="st">&quot;b&quot;</span><span class="op">,</span> <span class="op">-</span><span class="dv">3</span><span class="op">)</span></span></code></pre></div>
<p>So that’s where another tuple type can come in. A la <a href="https://twitter.com/rob_rix/status/633262294336729088">Rob
Rix</a>, we could make a right-recursive tuple, terminated by <code class="sourceCode scala"><span class="op">()</span></code>. There’ll be
one overarching protocol:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>protocol _AnyTuple <span class="op">:</span> CustomStringConvertible <span class="op">{</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">var</span> tDesc<span class="op">:</span> <span class="ex">String</span> <span class="op">{</span> get <span class="op">}</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">var</span> count<span class="op">:</span> <span class="bu">Int</span> <span class="op">{</span> get <span class="op">}</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>  typealias Arity <span class="op">:</span> Nat</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>And the empty tuple:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>struct EmptyTuple <span class="op">{}</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>extension EmptyTuple <span class="op">:</span> _AnyTuple <span class="op">{</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">var</span> description<span class="op">:</span> <span class="ex">String</span> <span class="op">{</span> <span class="cf">return</span> <span class="st">&quot;()&quot;</span> <span class="op">}</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">var</span> tDesc<span class="op">:</span> <span class="ex">String</span> <span class="op">{</span> <span class="cf">return</span>  <span class="st">&quot;)&quot;</span> <span class="op">}</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">var</span> count<span class="op">:</span> <span class="bu">Int</span> <span class="op">{</span> <span class="cf">return</span> <span class="dv">0</span> <span class="op">}</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>  typealias Arity <span class="op">=</span> Zero</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The descriptions are just there to give us a pretty printout. Here’s
the tuple struct:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>struct NonEmptyTuple<span class="op">&lt;</span><span class="ex">Element</span><span class="op">,</span> Tail <span class="op">:</span> _AnyTuple<span class="op">&gt;</span> <span class="op">{</span> <span class="kw">var</span> <span class="op">(</span>head<span class="op">,</span> tail<span class="op">):</span> <span class="op">(</span><span class="ex">Element</span><span class="op">,</span> Tail<span class="op">)</span> <span class="op">}</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>extension NonEmptyTuple <span class="op">:</span> _AnyTuple <span class="op">{</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">var</span> count<span class="op">:</span> <span class="bu">Int</span> <span class="op">{</span> <span class="cf">return</span> tail<span class="op">.</span>count <span class="op">+</span> <span class="dv">1</span> <span class="op">}</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">var</span> description<span class="op">:</span> <span class="ex">String</span> <span class="op">{</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="st">&quot;(&quot;</span> <span class="op">+</span> <span class="ex">String</span><span class="op">(</span>reflecting<span class="op">:</span> head<span class="op">)</span> <span class="op">+</span> tail<span class="op">.</span>tDesc</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">var</span> tDesc<span class="op">:</span> <span class="ex">String</span> <span class="op">{</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="st">&quot;, &quot;</span> <span class="op">+</span> <span class="ex">String</span><span class="op">(</span>reflecting<span class="op">:</span> head<span class="op">)</span> <span class="op">+</span> tail<span class="op">.</span>tDesc</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>  typealias Arity <span class="op">=</span> Succ<span class="op">&lt;</span>Tail<span class="op">.</span>Arity<span class="op">&gt;</span></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Now, to build a tuple. Since it’s right-recursive, it might look like
this:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> <span class="op">,</span> <span class="st">&quot;a&quot;</span> <span class="op">,</span> <span class="fl">4.0</span> <span class="op">,</span> <span class="op">()</span></span></code></pre></div>
<p>But there are two problems with that: first, the comma is not
overloadable. That’s probably a good thing. Second, it doesn’t really
look like a tuple.</p>
<p><a href="https://twitter.com/jckarter/status/639953308401057793">Joe
Groff</a> solved the first problem (albeit by committing a mortal sin).
Just use a unicode comma! The only one I could find that works has the
delightful name of Hypodiastole.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>infix operator ⸒ <span class="op">{</span> associativity right precedence <span class="dv">90</span> <span class="op">}</span></span></code></pre></div>
<p>Trying to find it in the character viewer each time was a pain,
though. So I went with the boring vertical bar.</p>
<p>The second problem can be solved with some sneaky overloading. Here’s
what these functions look like:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>infix operator <span class="op">|</span> <span class="op">{</span> associativity right precedence <span class="dv">90</span> <span class="op">}</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>func <span class="op">|&lt;</span>E<span class="op">,</span> T<span class="op">:</span>_AnyTuple<span class="op">&gt;(</span>lhs<span class="op">:</span> E<span class="op">,</span> rhs<span class="op">:</span> T<span class="op">)</span> <span class="op">-&gt;</span> NonEmptyTuple<span class="op">&lt;</span>E<span class="op">,</span> T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="fu">NonEmptyTuple</span><span class="op">(</span>head<span class="op">:</span> lhs<span class="op">,</span> tail<span class="op">:</span> rhs<span class="op">)</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>func <span class="op">|&lt;</span>E<span class="op">,</span> T<span class="op">&gt;(</span>lhs<span class="op">:</span> E<span class="op">,</span> rhs<span class="op">:</span> T<span class="op">)</span> <span class="op">-&gt;</span> NonEmptyTuple<span class="op">&lt;</span>E<span class="op">,</span> NonEmptyTuple<span class="op">&lt;</span>T<span class="op">,</span> EmptyTuple<span class="op">&gt;&gt;</span> <span class="op">{</span></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="fu">NonEmptyTuple</span><span class="op">(</span>head<span class="op">:</span> lhs<span class="op">,</span> tail<span class="op">:</span> <span class="fu">NonEmptyTuple</span><span class="op">(</span>head<span class="op">:</span> rhs<span class="op">,</span> tail<span class="op">:</span> <span class="fu">EmptyTuple</span><span class="op">()))</span></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>We can now, finally, build a Tuple:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="op">(</span><span class="dv">1</span> <span class="op">|</span> <span class="fl">2.0</span> <span class="op">|</span> <span class="st">&quot;a&quot;</span> <span class="op">)</span> <span class="co">// (1, 2.0, &quot;a&quot;)</span></span></code></pre></div>
<p>One little wrinkle with protocols, though. If you try this:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>extension NonEmptyTuple where Arity <span class="op">==</span> Two <span class="op">{...</span></span></code></pre></div>
<p>There’s an error: <code class="sourceCode scala">neither <span class="kw">type</span> in same<span class="op">-</span><span class="kw">type</span> refers to a generic parameter or associated <span class="kw">type</span></code>.
Generally speaking, <code class="sourceCode scala"><span class="op">==</span></code> requirements
in struct extensions don’t work. However, they do work on protocols. So
a wrapper protocol is needed:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>protocol Tuple <span class="op">:</span> _AnyTuple <span class="op">{</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>  typealias Head</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>  typealias Tail <span class="op">:</span> _AnyTuple</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>  typealias Arity <span class="op">:</span> NonZero</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">var</span> head <span class="op">:</span> Head <span class="op">{</span> get <span class="op">}</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">var</span> tail <span class="op">:</span> Tail <span class="op">{</span> get <span class="op">}</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>extension NonEmptyTuple <span class="op">:</span> Tuple <span class="op">{}</span></span></code></pre></div>
<p>Alright. Time to work with it.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>extension Tuple where</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>  Head <span class="op">:</span> IntegerArithmeticType<span class="op">,</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>  Tail <span class="op">:</span> Tuple<span class="op">,</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>  Tail<span class="op">.</span>Head <span class="op">:</span> IntegerArithmeticType<span class="op">,</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>  Arity <span class="op">==</span> Two <span class="op">{</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>  func <span class="fu">matSum</span><span class="op">(</span><span class="kw">with</span><span class="op">:</span> Self<span class="op">)</span> <span class="op">-&gt;</span> NonEmptyTuple<span class="op">&lt;</span>Head<span class="op">,</span> NonEmptyTuple<span class="op">&lt;</span>Tail<span class="op">.</span>Head<span class="op">,</span> EmptyTuple<span class="op">&gt;&gt;</span> <span class="op">{</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>    let a <span class="op">=</span> head <span class="op">+</span> <span class="kw">with</span><span class="op">.</span>head</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>    let b <span class="op">=</span> tail<span class="op">.</span>head <span class="op">+</span> <span class="kw">with</span><span class="op">.</span>tail<span class="op">.</span>head</span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">(</span>a <span class="op">|</span> b<span class="op">)</span></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a><span class="op">(</span><span class="dv">1</span> <span class="op">|</span> <span class="dv">4</span><span class="op">).</span><span class="fu">matSum</span><span class="op">(</span><span class="dv">3</span> <span class="op">|</span> <span class="dv">2</span><span class="op">)</span> <span class="co">// (4, 6)</span></span></code></pre></div>
<p>The basic advantage of this heterogenous list in Swift is its
extensibility: you can treat tuples of length 2 as a type, or tuples
where the third element is comparable as a type, and so on.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>extension Tuple where Tail <span class="op">:</span> Tuple<span class="op">,</span> Tail<span class="op">.</span>Head <span class="op">:</span> <span class="ex">Comparable</span> <span class="op">{</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>  func isSecondLessThan</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;</span>T <span class="op">:</span> Tuple where T<span class="op">.</span>Tail <span class="op">:</span> Tuple<span class="op">,</span> T<span class="op">.</span>Tail<span class="op">.</span>Head <span class="op">==</span> Tail<span class="op">.</span>Head<span class="op">&gt;</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">(</span><span class="kw">with</span><span class="op">:</span> T<span class="op">)</span> <span class="op">-&gt;</span> Bool <span class="op">{</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> tail<span class="op">.</span>head <span class="op">&lt;</span> <span class="kw">with</span><span class="op">.</span>tail<span class="op">.</span>head</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>let a <span class="op">=</span> <span class="op">(</span><span class="dv">1</span> <span class="op">|</span> <span class="fl">3.0</span> <span class="op">|</span> <span class="st">&quot;a&quot;</span> <span class="op">|</span> <span class="dv">43</span><span class="op">)</span></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>let b <span class="op">=</span> <span class="op">(</span><span class="st">&quot;c&quot;</span> <span class="op">|</span> <span class="fl">4.0</span> <span class="op">|</span> <span class="dv">1</span><span class="op">)</span></span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a>a<span class="op">.</span><span class="fu">isSecondLessThan</span><span class="op">(</span>b<span class="op">)</span></span></code></pre></div>
<p>Most of this stuff is madness. The custom infix unicode operator
should have tipped you off to that: but it’s not to say that
<em>nothing</em> here is useful. Compile-time warnings are great. I
think the fixed-length array works. But this tuple stuff is too hacky:
it only becomes useful if there are some low-level changes to the
language.</p>
<p>What’s really useful, though, is <em>thinking</em> about types with
dependency in mind. Getting familiar with what is and isn’t possible to
write between the <code class="sourceCode scala">where</code> and the
<code class="sourceCode scala"><span class="op">{</span></code> in an
extension gives you a good idea of how powerful protocols and their
specialisations are.</p>
<p>For some extra reading, check out <a href="https://ghc.haskell.org/trac/ghc/wiki/DependentHaskell">DependentHaskell</a>,
<a href="https://wiki.haskell.org/Heterogenous_collections">Heterogenous
Collections in Haskell</a>, and <a href="http://programmers.stackexchange.com/questions/132835/is-there-a-specific-purpose-for-heterogeneous-lists">Strongly
Typed Heterogenous Collections</a>. I’m muddling my way through seeing
what’s possible with length-indexed lists, heterogenous lists, and
numeral types <a href="https://github.com/oisdk/PretendDependSwift">over
here</a>, if you’re interested.</p>

        </div>
    </body>
</html>
