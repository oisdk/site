<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Faking dependent types in Swift - Donnacha Oisín Kidney</title>
        <style>body{color:black;font-family:Garamond,Times New Roman,serif;font-size:14px;margin:0px auto 0px auto;padding-left:5px;padding-right:5px;max-width:600px}math{font-size:13px}img{max-width:600px}summary{outline:0}div#header{border-bottom:3px double black;margin-bottom:30px;padding:12px 0px 12px 0px}div#logo a{color:black;float:left;font-size:20px;text-decoration:none}div#header #navigation{text-align:right}div#header #navigation a{color:black;font-family:Garamond,Times New Roman,Serif;font-size:18px;margin-left:10px;text-decoration:none;text-transform:uppercase}div#footer{font-family:Garamond,Times New Roman,Serif;border-top:solid 2px black;color:#555;font-size:12px;margin-top:30px;padding:12px 0px 12px 0px;text-align:right}h1{font-family:Garamond,Times New Roman,Serif;font-size:22px;font-weight:normal}h2{font-family:Garamond,Times New Roman,Serif;font-size:20px;font-weight:normal}div.info{color:#555;font-size:15px;font-style:italic}span.quiet{color:#828282;font-style:italic}a{color:black;word-wrap:break-word}ul.post-list{margin-left:0px;padding-left:0px;list-style-type:none}.hidden_source{display:none}ol.serieslist{counter-reset:item;list-style-type:none;padding-left:20}ol li.serieslist:before{content:'Part ' counter(item,decimal) ':';counter-increment:item}table.sourceCode,tr.sourceCode,td.lineNumbers,td.sourceCode,table.sourceCode pre{margin:0;padding:0;border:0;vertical-align:baseline;border:none}td.lineNumbers{border-right:1px solid #AAAAAA;text-align:right;color:#AAAAAA;padding-right:5px;padding-left:5px}td.sourceCode{padding-left:5px}.sourceCode,code,pre,.Agda{font-size:11px;font-family:menlo,monospace}.sourceCode span.kw{color:#262C6A}.sourceCode span.dt{color:#476A97}.sourceCode span.dv{color:#262C6A}.sourceCode span.bn{color:#262C6A}.sourceCode span.fl{color:#262C6A}.sourceCode span.ch{color:#262C6A}.sourceCode span.st{color:#702C51}.sourceCode span.co{color:#435138}.sourceCode span.ot{color:#262C6A}.sourceCode span.al{color:red}.sourceCode span.fu{color:#000000}.sourceCode span.re{color:#000000}.sourceCode span.er{color:red}li{margin-bottom:2px}li:last-child{margin-bottom:0px}.Agda .Comment{color:#B22222}.Agda .Background{}.Agda .Markup{color:#000000}.Agda .Keyword{color:#CD6600}.Agda .String{color:#B22222}.Agda .Number{color:#A020F0}.Agda .Symbol{color:#404040}.Agda .PrimitiveType{color:#0000CD}.Agda .Pragma{color:black}.Agda .Operator{}.Agda .Bound{color:black}.Agda .Generalizable{color:black}.Agda .InductiveConstructor{color:#008B00}.Agda .CoinductiveConstructor{color:#8B7500}.Agda .Datatype{color:#0000CD}.Agda .Field{color:#EE1289}.Agda .Function{color:#0000CD}.Agda .Module{color:#A020F0}.Agda .Postulate{color:#0000CD}.Agda .Primitive{color:#0000CD}.Agda .Record{color:#0000CD}.Agda .DottedPattern{}.Agda .UnsolvedMeta{color:black;background:yellow}.Agda .UnsolvedConstraint{color:black;background:yellow}.Agda .TerminationProblem{color:black;background:#FFA07A}.Agda .IncompletePattern{color:black;background:#F5DEB3}.Agda .Error{color:red;text-decoration:underline}.Agda .TypeChecks{color:black;background:#ADD8E6}.Agda a{text-decoration:none}.Agda a[href]:hover{background-color:#B4EEB4}.sourceCode{overflow-x:auto}</style>
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Donnacha Oisín Kidney</a>
            </div>
            <div id="navigation">
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../rss.xml">Feed</a>
            </div>
        </div>

        <div id="content">
            <h2>Faking dependent types in Swift</h2>

            <div class="info">
    Posted on September  6, 2015
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a title="All pages tagged 'Swift'." href="../tags/Swift.html">Swift</a>, <a title="All pages tagged 'Dependent Types'." href="../tags/Dependent%20Types.html">Dependent Types</a>
    
</div>

<p><a href="https://en.wikipedia.org/wiki/Dependent_type">Dependent types</a> are types “that depend on values”. Say you had a function <code class="sourceCode scala">f</code> that took an integer. If you can write that function whereby it returns a value of type <code class="sourceCode scala">A</code> when that integer is even, or a type <code class="sourceCode scala">B</code> if the integer is odd, then you’re working with dependent types. (I think. I’m not sure: if I’ve got it wrong <a href="https://twitter.com/oisdk">tweet me</a>.)</p>
<h2 id="dependent-pretendance">Dependent Pretendance</h2>
<p>As far as I can tell, this is not possible in Swift. All variables are statically typed, and those types must be found at compile-time. As long as you’re not messing around with casting:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a>struct A {}</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>struct B {}</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>func <span class="fu">f</span>(i: Int) -&gt; AnyObject {</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>  <span class="kw">return</span> i % <span class="dv">2</span> == <span class="dv">0</span> ? <span class="fu">A</span>() as! AnyObject : <span class="fu">B</span>() as! AnyObject</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>}</span></code></pre></div>
<p>You won’t be able to manage it.</p>
<p>Now, sum types can give you something that <em>looks</em> like dependent types:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a>struct A {}</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>struct B {}</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>enum SumType {</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>  <span class="kw">case</span> <span class="fu">Even</span>(A), <span class="fu">Odd</span>(B)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>}</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a>func <span class="fu">f</span>(i: Int) -&gt; SumType {</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a>  <span class="kw">return</span> i % <span class="dv">2</span> == <span class="dv">0</span> ? .<span class="fu">Even</span>(<span class="fu">A</span>()) : .<span class="fu">Odd</span>(<span class="fu">B</span>())</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a>}</span></code></pre></div>
<p>But that doesn’t fit the description: the thing returned is of type <code class="sourceCode scala">SumType</code>, <em>not</em> <code class="sourceCode scala">A</code> or <code class="sourceCode scala">B</code>.</p>
<p>That’s fine, though. As with all of these highfalutin mathematical concepts in programming, you can steal some of the cool and fun <em>patterns</em> from your Haskells and Lisps and Idrises and implement them in whatever language you want.</p>
<p>As it happens, implementing this stuff in Swift gets you even <em>further</em> away from the formal definition of dependent types. Instead of allowing types to be decided at runtime, you end up forcing even <em>more</em> resolution and computation to happen at compile-time. Take “numbers-as-types”, for instance:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a>protocol Nat { <span class="fu">init</span>() }</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>struct Zero : Nat {}</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>protocol NonZero: Nat { typealias Pred: Nat }</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>struct Succ&lt;N : Nat&gt; : NonZero { typealias Pred = N }</span></code></pre></div>
<p>Once you encode some numbers by hand:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a>typealias One   = Succ&lt;Zero&gt;</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>typealias Two   = Succ&lt;One&gt;</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>typealias Three = Succ&lt;Two&gt;</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>typealias Four  = Succ&lt;Three&gt;</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>typealias Five  = Succ&lt;Four&gt;</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>typealias Six   = Succ&lt;Five&gt;</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a>typealias Seven = Succ&lt;Six&gt;</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a>typealias Eight = Succ&lt;Seven&gt;</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a>typealias Nine  = Succ&lt;Eight&gt;</span></code></pre></div>
<p>You get thinking about exactly <em>how much</em> computation you can achieve at compile time:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a>Sum&lt;One, Two&gt;.<span class="fu">Result</span>    <span class="co">// Three</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>Comp&lt;Five, Nine&gt;.<span class="fu">Result</span> <span class="co">// LT</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>Comp&lt;Four, Four&gt;.<span class="fu">Result</span> <span class="co">// EQ</span></span></code></pre></div>
<h2 id="sum-types-divide-types-multiply-types">Sum types, divide types, multiply types</h2>
<p>What I wanted, ideally, was some basic “Algebraic data types”. (Today. Today was the day I made the worst pun.) I wanted to be able to add the type <code class="sourceCode scala">One</code> to the type <code class="sourceCode scala">Two</code> and get the type <code class="sourceCode scala">Three</code>. Once you can manage those, multiplication, division and all kinds of silliness are possible. I set myself some rules: all calculations must be performed at compile-time, and all calculations must work with arbitrary values.</p>
<p>I’ve not been able to manage, unfortunately. If someone could figure out how to do it, I would <a href="https://twitter.com/oisdk">love to hear it</a>. I’ve been stealing ideas from <a href="http://strictlypositive.org/faking.ps.gz">Faking It: Simulating Dependent Types in Haskell</a> mainly.</p>
<p>Here’s the kind of code that made me think it was possible:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a>let ar = [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>].<span class="fu">reverse</span>()</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>let se = <span class="fu">AnySequence</span>([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>]).<span class="fu">reverse</span>()</span></code></pre></div>
<p>The types returned by those two methods are different. This is all to do with that protocol-oriented-programming business: the compiler will try to select the most specialised version of a method to use. So in the example above, since an array can just be indexed backwards, the compiler uses a method that returns a lazy <code class="sourceCode scala">ReverseRandomAccessCollection</code>. However, for the <code class="sourceCode scala">AnySequence</code>, the <code class="sourceCode scala">reverse</code> method has to create a whole new array.</p>
<p>With that in mind, we can make a protocol:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a>protocol BinaryOp {</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>  typealias A: Nat</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>  typealias B: Nat</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>}</span></code></pre></div>
<p>Then, we can extend it, like this:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a>struct EQ {}</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>extension BinaryOp where A == B {</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>  typealias Result = EQ</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>}</span></code></pre></div>
<p>So far, so good! The compiler will add that method to all types that conform to the <code class="sourceCode scala">where</code> clause. So if there is a concrete type that conforms to <code>BinaryOp</code>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a>struct Comp&lt;E0: Nat, E1: Nat&gt; : BinaryOp {</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>  typealias A = E0</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>  typealias B = E1</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a>}</span></code></pre></div>
<p>Only instances where <code class="sourceCode scala">A</code> and <code class="sourceCode scala">B</code> are equal will get the type alias:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a>Comp&lt;One, One&gt;.<span class="fu">Result</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>Comp&lt;One, Two&gt;.<span class="fu">Result</span> <span class="co">// Error</span></span></code></pre></div>
<p>But that’s not ideal. We want something that returns <code class="sourceCode scala">NEQ</code> when the types are not the same. Easy enough, right?</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a>struct NEQ {}</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a>extension BinaryOp {</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a>  typealias Result = NEQ</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a>}</span></code></pre></div>
<p>But there’s an error: <code class="sourceCode scala">invalid redeclaration of 'Result'</code>. The compiler won’t allow polymorphism with typealiases. It <em>does</em> allow polymorphism with properties, though:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a>extension BinaryOp {</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a>  <span class="kw">var</span> r: EQ { <span class="kw">return</span> <span class="fu">EQ</span>() }</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a>}</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a>extension BinaryOp where A == B {</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a>  <span class="kw">var</span> r: NEQ { <span class="kw">return</span> <span class="fu">NEQ</span>() }</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true"></a>}</span></code></pre></div>
<p>This is already a less elegant solution than the typealiases, since we’re going to have to initialise things. All of the type information is available at compile-time, though, so I’ve not broken any of my rules.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a>Comp&lt;One, One&gt;().<span class="fu">r</span> <span class="co">// EQ</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a>Comp&lt;One, Two&gt;().<span class="fu">r</span> <span class="co">// NEQ</span></span></code></pre></div>
<p>How about something more complex? Instead of <code class="sourceCode scala">EQ</code> and <code class="sourceCode scala">NEQ</code>, maybe <code class="sourceCode scala">LT</code>, <code class="sourceCode scala">GT</code>, and <code>EQ</code>?</p>
<p>It’s hard to see how it would work. Well, here’s the base case:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a>extension BinaryOp where A == B {</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a>  <span class="kw">var</span> r: EQ { <span class="kw">return</span> <span class="fu">EQ</span>() }</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a>}</span></code></pre></div>
<p>Then, any non-zero is bigger than zero:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a>struct LT {}</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a>extension BinaryOp where A == Zero, B : NonZero {</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a>  <span class="kw">var</span> r: LT { <span class="kw">return</span> <span class="fu">LT</span>() }</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a>}</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true"></a>struct GT {}</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true"></a>extension BinaryOp where A : NonZero, B == Zero {</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true"></a>  <span class="kw">var</span> r: GT { <span class="kw">return</span> <span class="fu">GT</span>() }</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true"></a>}</span></code></pre></div>
<p>If both <code class="sourceCode scala">A</code> and <code class="sourceCode scala">B</code> are nonzero, they should have a <code class="sourceCode scala">Pred</code> typealias, which we can use, recursively:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a>extension BinaryOp where A : NonZero, B : NonZero {</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a>  <span class="kw">var</span> r: ?? {</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a>    <span class="kw">return</span> Comp&lt;A.<span class="fu">Pred</span>, B.<span class="fu">Pred</span>&gt;().<span class="fu">r</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a>  }</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true"></a>}</span></code></pre></div>
<p>This doesn’t work. I’m fairly sure this is a definitive dead end. Here’s the error: <code class="sourceCode scala">ambiguous reference to member <span class="ch">'r'</span></code>. The problem is that that error encapsulates exactly what I’m trying to achieve: I <em>want</em> the reference to be ambiguous, so it <em>depends</em> on the types of <code class="sourceCode scala">A</code> and <code class="sourceCode scala">B</code>. Most other routes I went down hit similar roadblocks:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a>protocol BinaryOp {</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a>  typealias A: Nat</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a>  typealias B: Nat</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a>  typealias Result</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a>  <span class="kw">var</span> r: Result { get }</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true"></a>}</span></code></pre></div>
<p>The idea here was that you could have various implementations of <code class="sourceCode scala">r</code>, so that the <code class="sourceCode scala">Result</code> typealias would be inferred. The problem is the compiler wants to figure out what <code class="sourceCode scala">Result</code> is when you make a type that conforms to the protocol, so every type will get the default implementation.</p>
<p>Yet more versions I tried all hit the <code class="sourceCode scala">ambiguous</code> error, which makes me think this kind of thing is fundamentally impossible in Swift’s current form.</p>
<p>So I’ve got to break one of the rules: no more arbitrary numbers.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a>struct AddOne&lt;N : Nat&gt; {</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a>  typealias Result = Succ&lt;N&gt;</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a>}</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true"></a>struct AddTwo&lt;N : Nat&gt; {</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true"></a>  typealias Result = Succ&lt;AddOne&lt;N&gt;.<span class="fu">Result</span>&gt;</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true"></a>}</span></code></pre></div>
<p>And so on. Or:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a>extension Binary where A == B {</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a>  <span class="kw">var</span> sub: Zero { <span class="kw">return</span> <span class="fu">Zero</span>() }</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true"></a>  <span class="kw">var</span> com: EQ { <span class="kw">return</span> <span class="fu">EQ</span>() }</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true"></a>}</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true"></a>extension Binary where A == Succ&lt;B&gt; {</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true"></a>  <span class="kw">var</span> sub: One { <span class="kw">return</span> <span class="fu">One</span>() }</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true"></a>  <span class="kw">var</span> com: GT { <span class="kw">return</span> <span class="fu">GT</span>() }</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true"></a>}</span></code></pre></div>
<p>Which can give you subtraction.</p>
<h2 id="lets-pretend-to-be-useful">Let’s Pretend to be Useful</h2>
<p>All of that stuff is interesting, but very <em>very</em> far from being useful.</p>
<p>The <a href="https://bigonotetaking.wordpress.com/2015/09/04/in-which-i-misunderstand-dependent-types/">length-indexed list from the other day</a> probably is useful, though. As well as being kind of cool and safe, there are some (minor) optimisations it can do.</p>
<p>The other dependent type staple is the heterogenous list.</p>
<p>Now, this isn’t just any heterogenous list: we’re not writing Python here. This is a <em>statically typed</em> heterogenous list. Swift has a construct very similar to this already: a tuple!</p>
<p>But tuples aren’t very extensible:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a>extension Tuple where First : Comparable {...</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a>extension Tuple where Count == Two {...</span></code></pre></div>
<p>And you can’t work with them in terms that most lists can:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a>(<span class="dv">1</span>, <span class="st">&quot;a&quot;</span>, <span class="fl">2.0</span>) + (<span class="st">&quot;b&quot;</span>, <span class="dv">-3</span>)</span></code></pre></div>
<p>So that’s where another tuple type can come in. A la <a href="https://twitter.com/rob_rix/status/633262294336729088">Rob Rix</a>, we could make a right-recursive tuple, terminated by <code class="sourceCode scala">()</code>. There’ll be one overarching protocol:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a>protocol _AnyTuple : CustomStringConvertible {</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a>  <span class="kw">var</span> tDesc: String { get }</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true"></a>  <span class="kw">var</span> count: Int { get }</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true"></a>  typealias Arity : Nat</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true"></a>}</span></code></pre></div>
<p>And the empty tuple:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a>struct EmptyTuple {}</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true"></a>extension EmptyTuple : _AnyTuple {</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true"></a>  <span class="kw">var</span> description: String { <span class="kw">return</span> <span class="st">&quot;()&quot;</span> }</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true"></a>  <span class="kw">var</span> tDesc: String { <span class="kw">return</span>  <span class="st">&quot;)&quot;</span> }</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true"></a>  <span class="kw">var</span> count: Int { <span class="kw">return</span> <span class="dv">0</span> }</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true"></a>  typealias Arity = Zero</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true"></a>}</span></code></pre></div>
<p>The descriptions are just there to give us a pretty printout. Here’s the tuple struct:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a>struct NonEmptyTuple&lt;Element, Tail : _AnyTuple&gt; { <span class="kw">var</span> (head, tail): (Element, Tail) }</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true"></a></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true"></a>extension NonEmptyTuple : _AnyTuple {</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true"></a>  <span class="kw">var</span> count: Int { <span class="kw">return</span> tail.<span class="fu">count</span> + <span class="dv">1</span> }</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true"></a>  <span class="kw">var</span> description: String {</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true"></a>    <span class="kw">return</span> <span class="st">&quot;(&quot;</span> + String(reflecting: head) + tail.<span class="fu">tDesc</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true"></a>  }</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true"></a>  <span class="kw">var</span> tDesc: String {</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true"></a>    <span class="kw">return</span> <span class="st">&quot;, &quot;</span> + String(reflecting: head) + tail.<span class="fu">tDesc</span></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true"></a>  }</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true"></a>  typealias Arity = Succ&lt;Tail.<span class="fu">Arity</span>&gt;</span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true"></a>}</span></code></pre></div>
<p>Now, to build a tuple. Since it’s right-recursive, it might look like this:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a><span class="dv">1</span> , <span class="st">&quot;a&quot;</span> , <span class="fl">4.0</span> , ()</span></code></pre></div>
<p>But there are two problems with that: first, the comma is not overloadable. That’s probably a good thing. Second, it doesn’t really look like a tuple.</p>
<p><a href="https://twitter.com/jckarter/status/639953308401057793">Joe Groff</a> solved the first problem (albeit by committing a mortal sin). Just use a unicode comma! The only one I could find that works has the delightful name of Hypodiastole.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true"></a>infix operator ⸒ { associativity right precedence <span class="dv">90</span> }</span></code></pre></div>
<p>Trying to find it in the character viewer each time was a pain, though. So I went with the boring vertical bar.</p>
<p>The second problem can be solved with some sneaky overloading. Here’s what these functions look like:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true"></a>infix operator | { associativity right precedence <span class="dv">90</span> }</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true"></a></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true"></a>func |&lt;E, T:_AnyTuple&gt;(lhs: E, rhs: T) -&gt; NonEmptyTuple&lt;E, T&gt; {</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true"></a>  <span class="kw">return</span> <span class="fu">NonEmptyTuple</span>(head: lhs, tail: rhs)</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true"></a>}</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true"></a></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true"></a>func |&lt;E, T&gt;(lhs: E, rhs: T) -&gt; NonEmptyTuple&lt;E, NonEmptyTuple&lt;T, EmptyTuple&gt;&gt; {</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true"></a>  <span class="kw">return</span> <span class="fu">NonEmptyTuple</span>(head: lhs, tail: <span class="fu">NonEmptyTuple</span>(head: rhs, tail: <span class="fu">EmptyTuple</span>()))</span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true"></a>}</span></code></pre></div>
<p>We can now, finally, build a Tuple:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true"></a>(<span class="dv">1</span> | <span class="fl">2.0</span> | <span class="st">&quot;a&quot;</span> ) <span class="co">// (1, 2.0, &quot;a&quot;)</span></span></code></pre></div>
<p>One little wrinkle with protocols, though. If you try this:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true"></a>extension NonEmptyTuple where Arity == Two {...</span></code></pre></div>
<p>There’s an error: <code class="sourceCode scala">neither <span class="kw">type</span> in same-<span class="kw">type</span> refers to a generic parameter or associated <span class="kw">type</span></code>. Generally speaking, <code class="sourceCode scala">==</code> requirements in struct extensions don’t work. However, they do work on protocols. So a wrapper protocol is needed:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true"></a>protocol Tuple : _AnyTuple {</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true"></a>  typealias Head</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true"></a>  typealias Tail : _AnyTuple</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true"></a>  typealias Arity : NonZero</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true"></a>  <span class="kw">var</span> head : Head { get }</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true"></a>  <span class="kw">var</span> tail : Tail { get }</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true"></a>}</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true"></a></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true"></a>extension NonEmptyTuple : Tuple {}</span></code></pre></div>
<p>Alright. Time to work with it.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true"></a>extension Tuple where</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true"></a>  Head : IntegerArithmeticType,</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true"></a>  Tail : Tuple,</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true"></a>  Tail.<span class="fu">Head</span> : IntegerArithmeticType,</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true"></a>  Arity == Two {</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true"></a>  func <span class="fu">matSum</span>(<span class="kw">with</span>: Self) -&gt; NonEmptyTuple&lt;Head, NonEmptyTuple&lt;Tail.<span class="fu">Head</span>, EmptyTuple&gt;&gt; {</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true"></a>    let a = head + <span class="kw">with</span>.<span class="fu">head</span></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true"></a>    let b = tail.<span class="fu">head</span> + <span class="kw">with</span>.<span class="fu">tail</span>.<span class="fu">head</span></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true"></a>    <span class="kw">return</span> (a | b)</span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true"></a>  }</span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true"></a>}</span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true"></a></span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true"></a>(<span class="dv">1</span> | <span class="dv">4</span>).<span class="fu">matSum</span>(<span class="dv">3</span> | <span class="dv">2</span>) <span class="co">// (4, 6)</span></span></code></pre></div>
<p>The basic advantage of this heterogenous list in Swift is its extensibility: you can treat tuples of length 2 as a type, or tuples where the third element is comparable as a type, and so on.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true"></a>extension Tuple where Tail : Tuple, Tail.<span class="fu">Head</span> : Comparable {</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true"></a>  func isSecondLessThan</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true"></a>    &lt;T : Tuple where T.<span class="fu">Tail</span> : Tuple, T.<span class="fu">Tail</span>.<span class="fu">Head</span> == Tail.<span class="fu">Head</span>&gt;</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true"></a>    (<span class="kw">with</span>: T) -&gt; Bool {</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true"></a>    <span class="kw">return</span> tail.<span class="fu">head</span> &lt; <span class="kw">with</span>.<span class="fu">tail</span>.<span class="fu">head</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true"></a>  }</span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true"></a>}</span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true"></a></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true"></a>let a = (<span class="dv">1</span> | <span class="fl">3.0</span> | <span class="st">&quot;a&quot;</span> | <span class="dv">43</span>)</span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true"></a>let b = (<span class="st">&quot;c&quot;</span> | <span class="fl">4.0</span> | <span class="dv">1</span>)</span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true"></a></span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true"></a>a.<span class="fu">isSecondLessThan</span>(b)</span></code></pre></div>
<p>Most of this stuff is madness. The custom infix unicode operator should have tipped you off to that: but it’s not to say that <em>nothing</em> here is useful. Compile-time warnings are great. I think the fixed-length array works. But this tuple stuff is too hacky: it only becomes useful if there are some low-level changes to the language.</p>
<p>What’s really useful, though, is <em>thinking</em> about types with dependency in mind. Getting familiar with what is and isn’t possible to write between the <code class="sourceCode scala">where</code> and the <code class="sourceCode scala">{</code> in an extension gives you a good idea of how powerful protocols and their specialisations are.</p>
<p>For some extra reading, check out <a href="https://ghc.haskell.org/trac/ghc/wiki/DependentHaskell">DependentHaskell</a>, <a href="https://wiki.haskell.org/Heterogenous_collections">Heterogenous Collections in Haskell</a>, and <a href="http://programmers.stackexchange.com/questions/132835/is-there-a-specific-purpose-for-heterogeneous-lists">Strongly Typed Heterogenous Collections</a>. I’m muddling my way through seeing what’s possible with length-indexed lists, heterogenous lists, and numeral types <a href="https://github.com/oisdk/PretendDependSwift">over here</a>, if you’re interested.</p>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
