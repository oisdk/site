<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>A Trie in Swift - Donnacha Oisín Kidney</title>
        <style>body{color:black;font-family:Garamond,Times New Roman,serif;font-size:14px;margin:0px auto 0px auto;padding-left:5px;padding-right:5px;max-width:600px}math{font-size:13px}img{max-width:600px}div#header{border-bottom:3px double black;margin-bottom:30px;padding:12px 0px 12px 0px}div#logo a{color:black;float:left;font-size:20px;text-decoration:none}div#header #navigation{text-align:right}div#header #navigation a{color:black;font-family:Garamond,Times New Roman,Serif;font-size:18px;margin-left:10px;text-decoration:none;text-transform:uppercase}div#footer{font-family:Garamond,Times New Roman,Serif;border-top:solid 2px black;color:#555;font-size:12px;margin-top:30px;padding:12px 0px 12px 0px;text-align:right}h1{font-family:Garamond,Times New Roman,Serif;font-size:22px;font-weight:normal}h2{font-family:Garamond,Times New Roman,Serif;font-size:20px;font-weight:normal}div.info{color:#555;font-size:15px;font-style:italic}span.quiet{color:#828282;font-style:italic}a{color:black;word-wrap:break-word}ul.post-list{margin-left:0px;padding-left:0px;list-style-type:none}.hidden_source{display:none}ol.serieslist{counter-reset:item;list-style-type:none;padding-left:20}ol li.serieslist:before{content:'Part ' counter(item,decimal) ':';counter-increment:item}table.sourceCode,tr.sourceCode,td.lineNumbers,td.sourceCode,table.sourceCode pre{margin:0;padding:0;border:0;vertical-align:baseline;border:none}td.lineNumbers{border-right:1px solid #AAAAAA;text-align:right;color:#AAAAAA;padding-right:5px;padding-left:5px}td.sourceCode{padding-left:5px}.sourceCode,code,.Agda{font-size:10px;font-family:menlo,monospace}.sourceCode span.kw{color:#262C6A}.sourceCode span.dt{color:#476A97}.sourceCode span.dv{color:#262C6A}.sourceCode span.bn{color:#262C6A}.sourceCode span.fl{color:#262C6A}.sourceCode span.ch{color:#262C6A}.sourceCode span.st{color:#702C51}.sourceCode span.co{color:#435138}.sourceCode span.ot{color:#262C6A}.sourceCode span.al{color:red}.sourceCode span.fu{color:#000000}.sourceCode span.re{color:#000000}.sourceCode span.er{color:red}li{margin-bottom:2px}li:last-child{margin-bottom:0px}.Agda .Comment{color:#B22222}.Agda .Background{}.Agda .Markup{color:#000000}.Agda .Keyword{color:#CD6600}.Agda .String{color:#B22222}.Agda .Number{color:#A020F0}.Agda .Symbol{color:#404040}.Agda .PrimitiveType{color:#0000CD}.Agda .Pragma{color:black}.Agda .Operator{}.Agda .Bound{color:black}.Agda .Generalizable{color:black}.Agda .InductiveConstructor{color:#008B00}.Agda .CoinductiveConstructor{color:#8B7500}.Agda .Datatype{color:#0000CD}.Agda .Field{color:#EE1289}.Agda .Function{color:#0000CD}.Agda .Module{color:#A020F0}.Agda .Postulate{color:#0000CD}.Agda .Primitive{color:#0000CD}.Agda .Record{color:#0000CD}.Agda .DottedPattern{}.Agda .UnsolvedMeta{color:black;background:yellow}.Agda .UnsolvedConstraint{color:black;background:yellow}.Agda .TerminationProblem{color:black;background:#FFA07A}.Agda .IncompletePattern{color:black;background:#F5DEB3}.Agda .Error{color:red;text-decoration:underline}.Agda .TypeChecks{color:black;background:#ADD8E6}.Agda a{text-decoration:none}.Agda a[href]:hover{background-color:#B4EEB4}.sourceCode{overflow-x:auto}</style>
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Donnacha Oisín Kidney</a>
            </div>
            <div id="navigation">
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../rss.xml">Feed</a>
            </div>
        </div>

        <div id="content">
            <h2>A Trie in Swift</h2>

            <div class="info">
    Posted on August 11, 2015
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="../tags/Swift.html">Swift</a>, <a href="../tags/Data%20Structures.html">Data Structures</a>
    
</div>

<p>If you google “cool data structures” you’ll get <a href="http://stackoverflow.com/questions/500607/what-are-the-lesser-known-but-useful-data-structures">this</a> as your first result. It’s a stackoverflow question: “What are the lesser known but useful data structures?”. And the top answer is a Trie. I read up on them, and found out a lot of cool things about their use (as well as finding out that I’m now the kind of person who googles “cool data structures”). So I rocked on up to my playground, and got writing.</p>
<p>A Trie is a prefix tree. It’s another recursive data structure: each Trie contains other children Tries, identifiable by their prefixes.</p>
<p>It’s a bit of a hipster data structure, not very widely used, but it’s got some useful applications. It’s got set-like operations, with insertion and searching each at <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math>, where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> is the length of the sequence being searched for. A Set is the only way to go for hashable, unordered elements. But, if you’ve got <em>sequences</em> of hashable elements, a Trie might be for you. (one thing to note is that Sets are hashable themselves, so if the sequences you want to store are unordered, a Set of Sets is more applicable)</p>
<figure>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/be/Trie_example.svg/1092px-Trie_example.svg.png" alt="A trie for keys" /><figcaption>A trie for keys</figcaption>
</figure>
<p>In Swift, we can do this by having every Trie contain a dictionary of prefixes and Tries. Something like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb1-1" data-line-number="1">public struct Trie&lt;Element : Hashable&gt; {</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  <span class="kw">private</span> <span class="kw">var</span> children: [Element:Trie&lt;Element&gt;]</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">}</a></code></pre></div>
<p>We don’t run into the problem of structs not being allowed to be recursive here, because we don’t directly store a Trie within a Trie - we store a <em>dictionary</em>, and therefore a reference to the child Tries. In this dictionary, the keys correspond to the prefixes. So how do we fill it up? Like lists, we can use the decomposition properties of generators:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb2-1" data-line-number="1">extension Trie {</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  <span class="kw">private</span> init&lt;G : GeneratorType where G.<span class="fu">Element</span> == Element&gt;(<span class="kw">var</span> gen: G) {</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">    <span class="kw">if</span> let head = gen.<span class="fu">next</span>() {</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">      children = [head:<span class="fu">Trie</span>(gen:gen)]</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">    } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">      children = [:]</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">    }</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">  }</a>
<a class="sourceLine" id="cb2-9" data-line-number="9">  public init</a>
<a class="sourceLine" id="cb2-10" data-line-number="10">    &lt;S : SequenceType where S.<span class="fu">Generator</span>.<span class="fu">Element</span> == Element&gt;</a>
<a class="sourceLine" id="cb2-11" data-line-number="11">    (_ seq: S) {</a>
<a class="sourceLine" id="cb2-12" data-line-number="12">      self.<span class="fu">init</span>(gen: seq.<span class="fu">generate</span>())</a>
<a class="sourceLine" id="cb2-13" data-line-number="13">  }</a>
<a class="sourceLine" id="cb2-14" data-line-number="14">}</a></code></pre></div>
<p>That’s not really enough. That can store one sequence, but we need an <code class="sourceCode scala">insert</code> function. Here ya go:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb3-1" data-line-number="1">extension Trie {</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  <span class="kw">private</span> mutating func insert</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">    &lt;G : GeneratorType where G.<span class="fu">Element</span> == Element&gt;</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">    (<span class="kw">var</span> gen: G) {</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">      <span class="kw">if</span> let head = gen.<span class="fu">next</span>() {</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">        children[head]?.<span class="fu">insert</span>(gen) ?? {children[head] = <span class="fu">Trie</span>(gen: gen)}()</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">      }</a>
<a class="sourceLine" id="cb3-8" data-line-number="8">  }</a>
<a class="sourceLine" id="cb3-9" data-line-number="9">  public mutating func insert</a>
<a class="sourceLine" id="cb3-10" data-line-number="10">    &lt;S : SequenceType where S.<span class="fu">Generator</span>.<span class="fu">Element</span> == Element&gt;</a>
<a class="sourceLine" id="cb3-11" data-line-number="11">    (seq: S) {</a>
<a class="sourceLine" id="cb3-12" data-line-number="12">      <span class="fu">insert</span>(seq.<span class="fu">generate</span>())</a>
<a class="sourceLine" id="cb3-13" data-line-number="13">  }</a>
<a class="sourceLine" id="cb3-14" data-line-number="14">}</a></code></pre></div>
<p>There’s a line in there that some may find offensive:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb4-1" data-line-number="1">children[head]?.<span class="fu">insert</span>(gen) ?? {children[head] = <span class="fu">Trie</span>(gen: gen)}()</a></code></pre></div>
<p>And, to be honest, I’m not a huge fan of it myself. It’s making use of the fact that you can call mutating methods on optionals with chaining. When you do it in this example, the optional is returned by the dictionary lookup: we then want to mutate that value, if it’s there, with an insertion.</p>
<p>If it’s <em>not</em> there, though, we want to add it in, so we’ve got to have some way of understanding and dealing with that. We could try and extract the child Trie, like this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">if</span> let head = gen.<span class="fu">next</span>() {</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">  <span class="kw">if</span> <span class="kw">var</span> child = children[head] {</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">    child.<span class="fu">insert</span>(gen)</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">  } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">    children[head] = <span class="fu">Trie</span>(gen: gen)</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">  }</a>
<a class="sourceLine" id="cb5-7" data-line-number="7">}</a></code></pre></div>
<p>But the child there is just a copy of the actual child in the Trie we want to mutate. We could then set it back to the dictionary entry - but at this stage it feels like a lot of extra, inefficient work.</p>
<p>So, you can make use of the fact the functions which don’t return anything actually <em>do</em> return something: a special value called <code class="sourceCode scala">Void</code>, or <code class="sourceCode scala">()</code>. Except that, in this case, it’s <code class="sourceCode scala">()?</code> (or <code class="sourceCode scala">Optional&amp;lt;Void&amp;gt;</code>). We’re not interested in the void itself, obviously, just whether or not it’s <code class="sourceCode scala">nil</code>. So, one way you could use it would be like this:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">if</span> let _ = children[head]?.<span class="fu">insert</span>(gen) { <span class="kw">return</span> }</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">children[head] = <span class="fu">Trie</span>(gen: gen)</a></code></pre></div>
<p>Or, to use <code class="sourceCode scala">guard</code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb7-1" data-line-number="1">guard let _ = children[head]?.<span class="fu">insert</span>(gen) <span class="kw">else</span> { children[head] = <span class="fu">Trie</span>(gen: gen) }</a></code></pre></div>
<p>But I think the nil coalescing operator is a little clearer, without the distraction of <code class="sourceCode scala">let</code> or <code class="sourceCode scala">_</code>.</p>
<p>This data structure, as you can see, has a very different feel to the list. For a start, it’s much more mutable, with in-place mutating methods being a little easier than methods that return a new Trie. Also, laziness is pretty much out of the question: almost every imaginable useful method would involve evaluation of the entire Trie. (if anyone <em>does</em> have a useful way of thinking about Tries lazily, I’d love to hear it)</p>
<p>The contains function, the most important of them all, is here:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb8-1" data-line-number="1">extension Trie {</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  <span class="kw">private</span> func contains</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">    &lt;G : GeneratorType where G.<span class="fu">Element</span> == Element&gt;</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">    (<span class="kw">var</span> gen: G) -&gt; Bool {</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">      <span class="kw">return</span> gen.<span class="fu">next</span>().<span class="fu">map</span>{self.<span class="fu">children</span>[$<span class="dv">0</span>]?.<span class="fu">contains</span>(gen) ?? <span class="kw">false</span>} ?? <span class="kw">true</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">  }</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">  public func contains</a>
<a class="sourceLine" id="cb8-8" data-line-number="8">    &lt;S : SequenceType where S.<span class="fu">Generator</span>.<span class="fu">Element</span> == Element&gt;</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">    (seq: S) -&gt; Bool {</a>
<a class="sourceLine" id="cb8-10" data-line-number="10">      <span class="kw">return</span> <span class="fu">contains</span>(seq.<span class="fu">generate</span>())</a>
<a class="sourceLine" id="cb8-11" data-line-number="11">  }</a>
<a class="sourceLine" id="cb8-12" data-line-number="12">}</a></code></pre></div>
<p>So this uses more generators. If the generator is empty (<code class="sourceCode scala">gen.<span class="fu">next</span>()</code> returns <code class="sourceCode scala">nil</code>), then the Trie contains that sequence, as we have not yet found a dictionary without that element. Within the <code class="sourceCode scala"><span class="fu">map</span>()</code> we search for the next element from the generator. If <em>that</em> returns <code class="sourceCode scala">nil</code>, then the Trie doesn’t contain that sequence. Finally, if none of that works, return whether or not the child Trie contains the rest of the generator. Let’s try it out:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">var</span> jo = <span class="fu">Trie</span>([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>])</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">jo.<span class="fu">insert</span>([<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>])</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">jo.<span class="fu">insert</span>([<span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>])</a>
<a class="sourceLine" id="cb9-4" data-line-number="4"></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">jo.<span class="fu">contains</span>([<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>]) <span class="co">// true</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6">jo.<span class="fu">contains</span>([<span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">3</span>]) <span class="co">// false</span></a></code></pre></div>
<p>There’s a catch. The <code class="sourceCode scala">contains</code> method doesn’t work as we’d like it to:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb10-1" data-line-number="1">jo.<span class="fu">contains</span>([<span class="dv">1</span>, <span class="dv">2</span>]) <span class="co">// true</span></a></code></pre></div>
<p>Because we return <code class="sourceCode scala"><span class="kw">true</span></code> <em>whenever</em> the generator runs out, our Trie “contains” every prefix of the sequences that have been inserted. This is not what we want. One way to solve this may be to return <code class="sourceCode scala"><span class="kw">true</span></code> only if the last Trie found has no children. Something like this:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb11-1" data-line-number="1">extension Trie {</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">  <span class="kw">private</span> func contains</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">    &lt;G : GeneratorType where G.<span class="fu">Element</span> == Element&gt;</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">    (<span class="kw">var</span> gen: G) -&gt; Bool {</a>
<a class="sourceLine" id="cb11-5" data-line-number="5">      <span class="kw">return</span> gen.<span class="fu">next</span>().<span class="fu">map</span>{self.<span class="fu">children</span>[$<span class="dv">0</span>]?.<span class="fu">contains</span>(gen) ?? <span class="kw">false</span>} ?? children.<span class="fu">isEmpty</span></a>
<a class="sourceLine" id="cb11-6" data-line-number="6">  }</a>
<a class="sourceLine" id="cb11-7" data-line-number="7">}</a></code></pre></div>
<p>But this doesn’t really work either. what if we did <code class="sourceCode scala">jo.<span class="fu">insert</span>([<span class="dv">1</span>, <span class="dv">2</span>])</code>? Now, if we check if the Trie contains <code class="sourceCode scala">[<span class="dv">1</span>, <span class="dv">2</span>]</code>, we’ll get back <code class="sourceCode scala"><span class="kw">false</span></code>.</p>
<p>It’s time for flags. We need to add an extra variable to our Trie: a Boolean, which describes whether or not that Trie represents the end of a sequence.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb12-1" data-line-number="1">public struct Trie&lt;Element : Hashable&gt; {</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">  <span class="kw">private</span> <span class="kw">var</span> children: [Element:Trie&lt;Element&gt;]</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">  <span class="kw">private</span> <span class="kw">var</span> endHere : Bool</a>
<a class="sourceLine" id="cb12-4" data-line-number="4">}</a></code></pre></div>
<p>We’ll also need to change our <code class="sourceCode scala">insert</code> and <code class="sourceCode scala">init</code> functions, so that when the generator returns <code class="sourceCode scala">nil</code>, <code class="sourceCode scala">endHere</code> gets initialised to <code class="sourceCode scala"><span class="kw">true</span></code>.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb13-1" data-line-number="1">extension Trie {</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">  <span class="kw">private</span> init&lt;G : GeneratorType where G.<span class="fu">Element</span> == Element&gt;(<span class="kw">var</span> gen: G) {</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">    <span class="kw">if</span> let head = gen.<span class="fu">next</span>() {</a>
<a class="sourceLine" id="cb13-4" data-line-number="4">      (children, endHere) = ([head:<span class="fu">Trie</span>(gen:gen)], <span class="kw">false</span>)</a>
<a class="sourceLine" id="cb13-5" data-line-number="5">    } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb13-6" data-line-number="6">      (children, endHere) = ([:], <span class="kw">true</span>)</a>
<a class="sourceLine" id="cb13-7" data-line-number="7">    }</a>
<a class="sourceLine" id="cb13-8" data-line-number="8">  }</a>
<a class="sourceLine" id="cb13-9" data-line-number="9">}</a>
<a class="sourceLine" id="cb13-10" data-line-number="10"></a>
<a class="sourceLine" id="cb13-11" data-line-number="11">extension Trie {</a>
<a class="sourceLine" id="cb13-12" data-line-number="12">  <span class="kw">private</span> mutating func insert</a>
<a class="sourceLine" id="cb13-13" data-line-number="13">    &lt;G : GeneratorType where G.<span class="fu">Element</span> == Element&gt;</a>
<a class="sourceLine" id="cb13-14" data-line-number="14">    (<span class="kw">var</span> gen: G) {</a>
<a class="sourceLine" id="cb13-15" data-line-number="15">      <span class="kw">if</span> let head = gen.<span class="fu">next</span>() {</a>
<a class="sourceLine" id="cb13-16" data-line-number="16">        children[head]?.<span class="fu">insert</span>(gen) ?? {children[head] = <span class="fu">Trie</span>(gen: gen)}()</a>
<a class="sourceLine" id="cb13-17" data-line-number="17">      } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb13-18" data-line-number="18">        endHere = <span class="kw">true</span></a>
<a class="sourceLine" id="cb13-19" data-line-number="19">      }</a>
<a class="sourceLine" id="cb13-20" data-line-number="20">  }</a>
<a class="sourceLine" id="cb13-21" data-line-number="21">}</a></code></pre></div>
<p>And the contains function now returns <code class="sourceCode scala">endHere</code>, instead of true:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb14-1" data-line-number="1">public extension Trie {</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">  <span class="kw">private</span> func contains</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">    &lt;G : GeneratorType where G.<span class="fu">Element</span> == Element&gt;</a>
<a class="sourceLine" id="cb14-4" data-line-number="4">    (<span class="kw">var</span> gen: G) -&gt; Bool {</a>
<a class="sourceLine" id="cb14-5" data-line-number="5">      <span class="kw">return</span> gen.<span class="fu">next</span>().<span class="fu">map</span>{self.<span class="fu">children</span>[$<span class="dv">0</span>]?.<span class="fu">contains</span>(gen) ?? <span class="kw">false</span>} ?? endHere</a>
<a class="sourceLine" id="cb14-6" data-line-number="6">  }</a>
<a class="sourceLine" id="cb14-7" data-line-number="7">}</a></code></pre></div>
<p>While we’re improving the <code class="sourceCode scala">contains</code> function, we could use <code class="sourceCode scala">guard</code> to make it much more readable:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb15-1" data-line-number="1">public extension Trie {</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">  <span class="kw">private</span> func contains&lt;</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">    G : GeneratorType where G.<span class="fu">Element</span> == Element</a>
<a class="sourceLine" id="cb15-4" data-line-number="4">    &gt;(<span class="kw">var</span> gen: G) -&gt; Bool {</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">      guard let head = gen.<span class="fu">next</span>() <span class="kw">else</span> { <span class="kw">return</span> endHere }</a>
<a class="sourceLine" id="cb15-6" data-line-number="6">      <span class="kw">return</span> children[head]?.<span class="fu">contains</span>(gen) ?? <span class="kw">false</span></a>
<a class="sourceLine" id="cb15-7" data-line-number="7">  }</a>
<a class="sourceLine" id="cb15-8" data-line-number="8">}</a></code></pre></div>
<p><a href="https://twitter.com/chriseidhof/status/629215881843884032">Chris Eidhof gave me this idea.</a> (Apparently there’s a Trie implementation in <a href="http://www.objc.io/books/fpinswift/">Functional Programming in Swift</a>, his book. I’ve not read it, but it’s on my list. If <a href="http://www.objc.io/books/advanced-swift/">Advanced Swift</a>is anything to go by, it should be fantastic.)</p>
<p>The objective of this Trie is to replicate all of the Set methods: Union, Intersect, etc. Most of those are manageable to build from just <code class="sourceCode scala">insert</code>, <code class="sourceCode scala">init</code>, and <code class="sourceCode scala">contains</code>, but there’s one other function that comes in handy: <code class="sourceCode scala">remove</code>.</p>
<p>Remove is deceptively difficult. You could just walk to the end of your given sequence to remove, and switch <code class="sourceCode scala">endHere</code> from <code class="sourceCode scala"><span class="kw">true</span></code> to <code class="sourceCode scala"><span class="kw">false</span></code>, but that’s kind of cheating. I mean, you’ll be storing the same amount of information that way after a removal. No, what you need is something that deletes branches of a tree that aren’t being used any more.</p>
<p>Again, this is a little complicated. You can’t just find the head of the sequence you want to remove, and then delete all children: you may be deleting other entries along with that. You <em>also</em> can’t just delete when a given Trie only contains one child: that child may branch off subsequently, or it may contain prefixes for the sequence you want to remove.</p>
<p>Crucially, all of the information telling you whether or not you can delete a given entry in a given Trie will come from the <em>children</em> of that Trie. What I decided to go with was this: I’ll have some mutating method that does the work recursively. However, this method also <em>returns</em> a value, representing some important information for whatever called it. In this case, the <code class="sourceCode scala">remove</code> method would remove, as you’d imagine, but it will also return a Boolean, signifying whether the Trie it was called on can be removed. Since I used the normal structure of having a private method take a generator, and then a public wrapper method take a sequence, I could have the public method just discard the Boolean.</p>
<p>Let’s go through it. Here’s the signature:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="kw">private</span> mutating func remove&lt;</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">  G : GeneratorType where G.<span class="fu">Element</span> == Element</a>
<a class="sourceLine" id="cb16-3" data-line-number="3">  &gt;(<span class="kw">var</span> g: G) -&gt; Bool {</a></code></pre></div>
<p>No surprises there. Similar to the other methods. Then, get the head from the generator:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw">if</span> let head = g.<span class="fu">next</span>() {</a></code></pre></div>
<p>Within that if block is the meat of the logic, so I might skip to what happens if <code class="sourceCode scala">g.<span class="fu">next</span>()</code> returns <code class="sourceCode scala">nil</code> for the start:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="kw">private</span> mutating func remove&lt;</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">  G : GeneratorType where G.<span class="fu">Element</span> == Element</a>
<a class="sourceLine" id="cb18-3" data-line-number="3">  &gt;(<span class="kw">var</span> g: G) -&gt; Bool {</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">    <span class="kw">if</span> let head = g.<span class="fu">next</span>() {...}</a>
<a class="sourceLine" id="cb18-5" data-line-number="5">    endHere = <span class="kw">false</span></a>
<a class="sourceLine" id="cb18-6" data-line-number="6">    <span class="kw">return</span> children.<span class="fu">isEmpty</span></a>
<a class="sourceLine" id="cb18-7" data-line-number="7">}</a></code></pre></div>
<p>So the sequence being removed has ended. That means that whatever Trie you’re on should have its <code class="sourceCode scala">endHere</code> set to <code class="sourceCode scala"><span class="kw">false</span></code>. To the user of the Trie, that’s all that matters: from now on, if the contains method on that Trie is used with that sequence, it will return false.</p>
<p>However, to find out if you can delete the data itself, it returns <code class="sourceCode scala">children.<span class="fu">isEmpty</span></code>. If it has no children, it does not hold any other sequences or information, so it can be deleted.</p>
<p>Now for inside the if block:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb19-1" data-line-number="1">guard children[head]?.<span class="fu">remove</span>(g) == <span class="kw">true</span> <span class="kw">else</span> { <span class="kw">return</span> <span class="kw">false</span> }</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">children.<span class="fu">removeValueForKey</span>(head)</a>
<a class="sourceLine" id="cb19-3" data-line-number="3"><span class="kw">return</span> !endHere &amp;&amp; children.<span class="fu">isEmpty</span></a></code></pre></div>
<p>So it calls <code class="sourceCode scala">remove</code> on the child Trie corresponding to <code class="sourceCode scala">head</code>. That guard statement will fail for two distinct reasons: if <code class="sourceCode scala">children</code> doesn’t contain <code class="sourceCode scala">head</code>, then the sequence being removed wasn’t in the Trie in the first place. The method will then return false, so that no removal or mutation is done.</p>
<p>If it <em>does</em> contain <code class="sourceCode scala">head</code>, but the Bool returned from the remove method is <code class="sourceCode scala"><span class="kw">false</span></code>, that means that its <em>child</em> is not removable, so it is also not removable, so it should return <code class="sourceCode scala"><span class="kw">false</span></code>.</p>
<p>Otherwise, it will remove that member (<code class="sourceCode scala">children.<span class="fu">removeValueForKey</span>(head)</code>). Then, the Trie can decide whether or not it itself is removable: <code class="sourceCode scala"><span class="kw">return</span> !endHere &amp;amp;&amp;amp; children.<span class="fu">isEmpty</span></code>. If the <code class="sourceCode scala">endHere</code> is set to true, then it is the end of some sequence: it is not removable. Otherwise, it’s removable if it has no children. Here’s the whole thing, with its public version:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb20-1" data-line-number="1">extension Trie {</a>
<a class="sourceLine" id="cb20-2" data-line-number="2">  <span class="kw">private</span> mutating func remove&lt;</a>
<a class="sourceLine" id="cb20-3" data-line-number="3">    G : GeneratorType where G.<span class="fu">Element</span> == Element</a>
<a class="sourceLine" id="cb20-4" data-line-number="4">    &gt;(<span class="kw">var</span> g: G) -&gt; Bool { <span class="co">// Return value signifies whether or not it can be removed</span></a>
<a class="sourceLine" id="cb20-5" data-line-number="5">      <span class="kw">if</span> let head = g.<span class="fu">next</span>() {</a>
<a class="sourceLine" id="cb20-6" data-line-number="6">        guard children[head]?.<span class="fu">remove</span>(g) == <span class="kw">true</span> <span class="kw">else</span> { <span class="kw">return</span> <span class="kw">false</span> }</a>
<a class="sourceLine" id="cb20-7" data-line-number="7">        children.<span class="fu">removeValueForKey</span>(head)</a>
<a class="sourceLine" id="cb20-8" data-line-number="8">        <span class="kw">return</span> !endHere &amp;&amp; children.<span class="fu">isEmpty</span></a>
<a class="sourceLine" id="cb20-9" data-line-number="9">      }</a>
<a class="sourceLine" id="cb20-10" data-line-number="10">      endHere = <span class="kw">false</span></a>
<a class="sourceLine" id="cb20-11" data-line-number="11">      <span class="kw">return</span> children.<span class="fu">isEmpty</span></a>
<a class="sourceLine" id="cb20-12" data-line-number="12">  }</a>
<a class="sourceLine" id="cb20-13" data-line-number="13">  public mutating func remove&lt;</a>
<a class="sourceLine" id="cb20-14" data-line-number="14">    S : SequenceType where S.<span class="fu">Generator</span>.<span class="fu">Element</span> == Element</a>
<a class="sourceLine" id="cb20-15" data-line-number="15">    &gt;(seq: S) {</a>
<a class="sourceLine" id="cb20-16" data-line-number="16">      <span class="fu">remove</span>(seq.<span class="fu">generate</span>())</a>
<a class="sourceLine" id="cb20-17" data-line-number="17">  }</a>
<a class="sourceLine" id="cb20-18" data-line-number="18">}</a></code></pre></div>
<p>That was a little heavy. And kind of ugly. Let’s lighten things up for a second, with one of the loveliest <code class="sourceCode scala">count</code> properties I’ve seen:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb21-1" data-line-number="1">extension Trie {</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">  public <span class="kw">var</span> count: Int {</a>
<a class="sourceLine" id="cb21-3" data-line-number="3">    <span class="kw">return</span> children.<span class="fu">values</span>.<span class="fu">reduce</span>(endHere ? <span class="dv">1</span> : <span class="dv">0</span>) { $<span class="dv">0</span> + $<span class="fl">1.</span>count }</a>
<a class="sourceLine" id="cb21-4" data-line-number="4">  }</a>
<a class="sourceLine" id="cb21-5" data-line-number="5">}</a></code></pre></div>
<p>All it’s really doing is counting the instances of a <code class="sourceCode scala"><span class="kw">true</span></code> <code class="sourceCode scala">endHere</code>. If the current Trie is an end, then it knows that it adds one to the count (<code class="sourceCode scala">endHere ? <span class="dv">1</span> : <span class="dv">0</span></code>), and it adds that to the sum of the counts of its children.</p>
<p>Now then. <code class="sourceCode scala">SequenceType</code>. <a href="http://airspeedvelocity.net/2015/07/22/a-persistent-tree-using-indirect-enums-in-swift/">Getting tree-like structures to conform to <code class="sourceCode scala">SequenceType</code> is a bit of a pain</a>, mainly because of their recursiveness. Getting a linear representation is easy enough:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb22-1" data-line-number="1">extension Trie {</a>
<a class="sourceLine" id="cb22-2" data-line-number="2">  public <span class="kw">var</span> contents: [[Element]] {</a>
<a class="sourceLine" id="cb22-3" data-line-number="3">    <span class="kw">return</span> children.<span class="fu">flatMap</span> {</a>
<a class="sourceLine" id="cb22-4" data-line-number="4">      (head: Element, child: Trie&lt;Element&gt;) -&gt; [[Element]] in</a>
<a class="sourceLine" id="cb22-5" data-line-number="5">      child.<span class="fu">contents</span>.<span class="fu">map</span> { [head] + $<span class="dv">0</span> } + (child.<span class="fu">endHere</span> ? [[head]] : [])</a>
<a class="sourceLine" id="cb22-6" data-line-number="6">    }</a>
<a class="sourceLine" id="cb22-7" data-line-number="7">  }</a>
<a class="sourceLine" id="cb22-8" data-line-number="8">}</a></code></pre></div>
<p>And then you could just return the generate method from that for your Trie’s generate method.</p>
<p>The problem is that it’s not very proper: you’re translating your data structure into another data structure just to iterate through it. What you really want is something that generates each element on demand.</p>
<p>But it gets ugly quick. You’ve got to do a lot of stuff by hand which it isn’t nice to do by hand, and you’ve got to employ some dirty tricks (like using closures as a kind of homemade <code class="sourceCode scala">indirect</code>). At any rate, here it is:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb23-1" data-line-number="1">public struct TrieGenerator&lt;Element : Hashable&gt; : GeneratorType {</a>
<a class="sourceLine" id="cb23-2" data-line-number="2">  <span class="kw">private</span> <span class="kw">var</span> children: DictionaryGenerator&lt;Element, Trie&lt;Element&gt;&gt;</a>
<a class="sourceLine" id="cb23-3" data-line-number="3">  <span class="kw">private</span> <span class="kw">var</span> curHead : Element?</a>
<a class="sourceLine" id="cb23-4" data-line-number="4">  <span class="kw">private</span> <span class="kw">var</span> curEnd  : Bool = <span class="kw">false</span></a>
<a class="sourceLine" id="cb23-5" data-line-number="5">  <span class="kw">private</span> <span class="kw">var</span> innerGen: (() -&gt; [Element]?)?</a>
<a class="sourceLine" id="cb23-6" data-line-number="6">  <span class="kw">private</span> mutating func <span class="fu">update</span>() {</a>
<a class="sourceLine" id="cb23-7" data-line-number="7">    guard <span class="fu">let</span> (head, child) = children.<span class="fu">next</span>() <span class="kw">else</span> { innerGen = nil; <span class="kw">return</span> }</a>
<a class="sourceLine" id="cb23-8" data-line-number="8">    curHead = head</a>
<a class="sourceLine" id="cb23-9" data-line-number="9">    <span class="kw">var</span> g = child.<span class="fu">generate</span>()</a>
<a class="sourceLine" id="cb23-10" data-line-number="10">    innerGen = {g.<span class="fu">next</span>()}</a>
<a class="sourceLine" id="cb23-11" data-line-number="11">    curEnd = child.<span class="fu">endHere</span></a>
<a class="sourceLine" id="cb23-12" data-line-number="12">  }</a>
<a class="sourceLine" id="cb23-13" data-line-number="13">  public mutating func <span class="fu">next</span>() -&gt; [Element]? {</a>
<a class="sourceLine" id="cb23-14" data-line-number="14">    <span class="kw">for</span> ; innerGen != nil; <span class="fu">update</span>() {</a>
<a class="sourceLine" id="cb23-15" data-line-number="15">      <span class="kw">if</span> let next = innerGen!() {</a>
<a class="sourceLine" id="cb23-16" data-line-number="16">        <span class="kw">return</span> [curHead!] + next</a>
<a class="sourceLine" id="cb23-17" data-line-number="17">      } <span class="kw">else</span> <span class="kw">if</span> curEnd {</a>
<a class="sourceLine" id="cb23-18" data-line-number="18">        curEnd = <span class="kw">false</span></a>
<a class="sourceLine" id="cb23-19" data-line-number="19">        <span class="kw">return</span> [curHead!]</a>
<a class="sourceLine" id="cb23-20" data-line-number="20">      }</a>
<a class="sourceLine" id="cb23-21" data-line-number="21">    }</a>
<a class="sourceLine" id="cb23-22" data-line-number="22">    <span class="kw">return</span> nil</a>
<a class="sourceLine" id="cb23-23" data-line-number="23">  }</a>
<a class="sourceLine" id="cb23-24" data-line-number="24">  <span class="kw">private</span> <span class="fu">init</span>(_ from: Trie&lt;Element&gt;) {</a>
<a class="sourceLine" id="cb23-25" data-line-number="25">    children = from.<span class="fu">children</span>.<span class="fu">generate</span>()</a>
<a class="sourceLine" id="cb23-26" data-line-number="26">    <span class="fu">update</span>()</a>
<a class="sourceLine" id="cb23-27" data-line-number="27">  }</a>
<a class="sourceLine" id="cb23-28" data-line-number="28">}</a></code></pre></div>
<p>It’s got a similar logic to the lazy flatMap I did from a while ago.</p>
<p>The code is all available <a href="https://github.com/oisdk/SwiftTrie">here</a>, as a playground, or <a href="https://github.com/oisdk/SwiftSequence">here</a>, in SwiftSequence, where it’s accompanied by some tests.</p>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
