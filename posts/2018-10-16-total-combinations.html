<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Total Combinations - Donnacha Oisín Kidney</title>
        <style>body{color:black;font-family:Garamond,Times New Roman,serif;font-size:14px;margin:0px auto 0px auto;padding-left:5px;padding-right:5px;max-width:600px}math{font-size:13px}img{max-width:600px}div#header{border-bottom:3px double black;margin-bottom:30px;padding:12px 0px 12px 0px}div#logo a{color:black;float:left;font-size:20px;text-decoration:none}div#header #navigation{text-align:right}div#header #navigation a{color:black;font-family:Garamond,Times New Roman,Serif;font-size:18px;margin-left:10px;text-decoration:none;text-transform:uppercase}div#footer{font-family:Garamond,Times New Roman,Serif;border-top:solid 2px black;color:#555;font-size:12px;margin-top:30px;padding:12px 0px 12px 0px;text-align:right}h1{font-family:Garamond,Times New Roman,Serif;font-size:22px;font-weight:normal}h2{font-family:Garamond,Times New Roman,Serif;font-size:20px;font-weight:normal}div.info{color:#555;font-size:15px;font-style:italic}span.quiet{color:#828282;font-style:italic}a{color:black;word-wrap:break-word}ul.post-list{margin-left:0px;padding-left:0px;list-style-type:none}.hidden_source{display:none}ol.serieslist{counter-reset:item;list-style-type:none;padding-left:20}ol li.serieslist:before{content:'Part ' counter(item,decimal) ':';counter-increment:item}table.sourceCode,tr.sourceCode,td.lineNumbers,td.sourceCode,table.sourceCode pre{margin:0;padding:0;border:0;vertical-align:baseline;border:none}td.lineNumbers{border-right:1px solid #AAAAAA;text-align:right;color:#AAAAAA;padding-right:5px;padding-left:5px}td.sourceCode{padding-left:5px}.sourceCode,code,.Agda{font-size:10px;font-family:menlo,monospace}.sourceCode span.kw{color:#262C6A}.sourceCode span.dt{color:#476A97}.sourceCode span.dv{color:#262C6A}.sourceCode span.bn{color:#262C6A}.sourceCode span.fl{color:#262C6A}.sourceCode span.ch{color:#262C6A}.sourceCode span.st{color:#702C51}.sourceCode span.co{color:#435138}.sourceCode span.ot{color:#262C6A}.sourceCode span.al{color:red}.sourceCode span.fu{color:#000000}.sourceCode span.re{color:#000000}.sourceCode span.er{color:red}li{margin-bottom:2px}li:last-child{margin-bottom:0px}.Agda .Comment{color:#B22222}.Agda .Background{}.Agda .Markup{color:#000000}.Agda .Keyword{color:#CD6600}.Agda .String{color:#B22222}.Agda .Number{color:#A020F0}.Agda .Symbol{color:#404040}.Agda .PrimitiveType{color:#0000CD}.Agda .Pragma{color:black}.Agda .Operator{}.Agda .Bound{color:black}.Agda .Generalizable{color:black}.Agda .InductiveConstructor{color:#008B00}.Agda .CoinductiveConstructor{color:#8B7500}.Agda .Datatype{color:#0000CD}.Agda .Field{color:#EE1289}.Agda .Function{color:#0000CD}.Agda .Module{color:#A020F0}.Agda .Postulate{color:#0000CD}.Agda .Primitive{color:#0000CD}.Agda .Record{color:#0000CD}.Agda .DottedPattern{}.Agda .UnsolvedMeta{color:black;background:yellow}.Agda .UnsolvedConstraint{color:black;background:yellow}.Agda .TerminationProblem{color:black;background:#FFA07A}.Agda .IncompletePattern{color:black;background:#F5DEB3}.Agda .Error{color:red;text-decoration:underline}.Agda .TypeChecks{color:black;background:#ADD8E6}.Agda a{text-decoration:none}.Agda a[href]:hover{background-color:#B4EEB4}.sourceCode{overflow-x:auto}</style>
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Donnacha Oisín Kidney</a>
            </div>
            <div id="navigation">
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../rss.xml">Feed</a>
                <a href="../snippets.html">Snippets</a>
            </div>
        </div>

        <div id="content">
            <h2>Total Combinations</h2>

            <div class="info">
    Posted on October 16, 2018
</div>
<div class="info">
    
        Part 1 of a <a href="../series/Total%20Combinatorics.html">1-part series on Total Combinatorics</a>
    
</div>
<div class="info">
    
        Tags: <a href="../tags/Agda.html">Agda</a>, <a href="../tags/Haskell.html">Haskell</a>
    
</div>

<p>Here’s a quick puzzle: from a finite alphabet, produce an infinite list of infinite strings, each of them unique.</p>
<p>It’s not a super hard problem, but here are some examples of what you might get. Given the alphabet of <code>0</code> and <code>1</code>, for instance, you could produce the following:</p>
<pre><code>0000000...
1000000...
0100000...
1100000...
0010000...
1010000...
0110000...
1110000...
0001000...</code></pre>
<p>In other words, the enumeration of the binary numbers (least-significant-digit first). We’ll just deal with bits first:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Bit</span> <span class="fu">=</span> <span class="dt">O</span> <span class="fu">|</span> <span class="dt">I</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Bit</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">    showsPrec _ <span class="dt">O</span> <span class="fu">=</span> (<span class="fu">:</span>) <span class="ch">'0'</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5">    showsPrec _ <span class="dt">I</span> <span class="fu">=</span> (<span class="fu">:</span>) <span class="ch">'1'</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6">    showList xs s <span class="fu">=</span> foldr f s xs</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8">        f <span class="dt">O</span> a <span class="fu">=</span> <span class="ch">'0'</span> <span class="fu">:</span> a</a>
<a class="sourceLine" id="cb2-9" data-line-number="9">        f <span class="dt">I</span> a <span class="fu">=</span> <span class="ch">'1'</span> <span class="fu">:</span> a</a></code></pre></div>
<p>Thinking recursively, we can see that the tail of each list is actually the original sequence, doubled-up:</p>
<p><code class="sourceCode"> 0<span class="er">000000</span>... <br /> 1<span class="er">000000</span>... <br /> 0<span class="er">100000</span>... <br /> 1<span class="er">100000</span>... <br /> 0<span class="er">010000</span>... <br /> 1<span class="er">010000</span>... <br /> 0<span class="er">110000</span>... <br /> 1<span class="er">110000</span>... <br /> 0<span class="er">001000</span>... <br /> </code></p>
<p>As it happens, we get something like this pattern with the monad instance for lists <em>anyway</em>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> (,) <span class="fu">&lt;$&gt;</span> [<span class="dt">O</span>,<span class="dt">I</span>] <span class="fu">&lt;*&gt;</span> <span class="st">&quot;abc&quot;</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">[(<span class="dv">0</span>,<span class="ch">'a'</span>),(<span class="dv">0</span>,<span class="ch">'b'</span>),(<span class="dv">0</span>,<span class="ch">'c'</span>),(<span class="dv">1</span>,<span class="ch">'a'</span>),(<span class="dv">1</span>,<span class="ch">'b'</span>),(<span class="dv">1</span>,<span class="ch">'c'</span>)]</a></code></pre></div>
<p>Well, actually it’s the wrong way around. We want to loop through the <em>first</em> list the quickest, incrementing the second slower. No worries, we can just use a flipped version of <code>&lt;*&gt;</code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">infixl</span> <span class="dv">4</span> <span class="fu">&lt;&lt;&gt;</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="ot">(&lt;&lt;&gt;) ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">fs <span class="fu">&lt;&lt;&gt;</span> xs <span class="fu">=</span> flip (<span class="fu">$</span>) <span class="fu">&lt;$&gt;</span> xs <span class="fu">&lt;*&gt;</span> fs</a>
<a class="sourceLine" id="cb4-4" data-line-number="4"></a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="fu">&gt;&gt;&gt;</span> (,) <span class="fu">&lt;$&gt;</span> [<span class="dt">O</span>,<span class="dt">I</span>] <span class="fu">&lt;&lt;&gt;</span> <span class="st">&quot;abc&quot;</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">[(<span class="dv">0</span>,<span class="ch">'a'</span>),(<span class="dv">1</span>,<span class="ch">'a'</span>),(<span class="dv">0</span>,<span class="ch">'b'</span>),(<span class="dv">1</span>,<span class="ch">'b'</span>),(<span class="dv">0</span>,<span class="ch">'c'</span>),(<span class="dv">1</span>,<span class="ch">'c'</span>)]</a></code></pre></div>
<p>Brilliant! So we can write our function now, yes?</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1">bins <span class="fu">=</span> (<span class="fu">:</span>) <span class="fu">&lt;$&gt;</span> [<span class="dt">O</span>,<span class="dt">I</span>] <span class="fu">&lt;&lt;&gt;</span> bins</a></code></pre></div>
<p>Nope! That won’t ever produce an answer, unfortunately.</p>
<h1 id="productivity">Productivity</h1>
<p>The issue with our definition above is that it’s not lazy enough: it demands information that it hasn’t produced yet, so it gets caught in an infinite loop before it can do anything!</p>
<p>We need to kick-start it a little, so it can produce output <em>before</em> it asks itself for more. Because we know what the first line is going to be, we can just tell it that:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1">bins <span class="fu">=</span> (<span class="fu">:</span>) <span class="fu">&lt;$&gt;</span> [<span class="dt">O</span>,<span class="dt">I</span>] <span class="fu">&lt;&lt;&gt;</span> (repeat <span class="dt">O</span> <span class="fu">:</span> tail bins)</a>
<a class="sourceLine" id="cb6-2" data-line-number="2"></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="fu">&gt;&gt;&gt;</span> mapM_ print (take <span class="dv">8</span> (map (take <span class="dv">3</span>) bins))</a>
<a class="sourceLine" id="cb6-4" data-line-number="4"><span class="dv">000</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5"><span class="dv">100</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6"><span class="dv">010</span></a>
<a class="sourceLine" id="cb6-7" data-line-number="7"><span class="dv">110</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8"><span class="dv">001</span></a>
<a class="sourceLine" id="cb6-9" data-line-number="9"><span class="dv">101</span></a>
<a class="sourceLine" id="cb6-10" data-line-number="10"><span class="dv">011</span></a>
<a class="sourceLine" id="cb6-11" data-line-number="11"><span class="dv">111</span></a></code></pre></div>
<p>The property that this function has that the previous didn’t is <em>productivity</em>: the dual of termination. See, we want to avoid a <em>kind</em> of infinite loops in <code>bins</code>, but we don’t want to avoid infinite things altogether: the list it produces is meant to be infinite, for goodness’ sake. Instead, what it needs to do is produce every new value in <em>finite</em> time.</p>
<h1 id="checking-productivity">Checking Productivity</h1>
<p>In total languages, like Agda, termination checking is a must. To express computation like that above, though, you often also want a <em>productivity</em> checker. Agda can do that, too.</p>
<p>Let’s get started then. First, a stream:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">5</span> <span class="ot">_</span>◂<span class="ot">_</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="kw">record</span> Stream <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  <span class="kw">coinductive</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">  <span class="kw">constructor</span> <span class="ot">_</span>◂<span class="ot">_</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5">  <span class="kw">field</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6">    head <span class="ot">:</span> A</a>
<a class="sourceLine" id="cb7-7" data-line-number="7">    tail <span class="ot">:</span> Stream A</a>
<a class="sourceLine" id="cb7-8" data-line-number="8"><span class="kw">open</span> Stream</a></code></pre></div>
<p>In Haskell, there was no need to define a separate stream type: the type of lists contains both finite and infinite lists.</p>
<p>Agda can get a little more specific: here, we’ve used the <code>coinductive</code> keyword, which means we’re free to create infinite <code>Stream</code>s. Rather than the usual termination checking (which would kick in when we consume a recursive, inductive type), we now get productivity checking: when creating a <code>Stream</code>, the <code>tail</code> must always be available in finite time. For a finite type, we’d have used the <code>inductive</code> keyword instead; this wouldn’t be much use, though, since there’s no way to create a finite <code>Stream</code> without a nil constructor!<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a></p>
<p>One of the interesting things about working with infinite data (when you’re forced to notice that it’s infinite, as you are in Agda) is that <em>everything</em> gets flipped. So you have to prove productivity, not totality; you use product types, rather than sums; and to define functions, you use <em>co</em>patterns, rather than patterns.</p>
<h1 id="copatterns">Copatterns</h1>
<p>Copatterns are a handy syntactic construct for writing functions about record types. Let’s start with an example, and then I’ll try explain a little:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb8-1" data-line-number="1">pure <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">→</span> A <span class="ot">→</span> Stream A</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">head <span class="ot">(</span>pure x<span class="ot">)</span> <span class="ot">=</span> x</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">tail <span class="ot">(</span>pure x<span class="ot">)</span> <span class="ot">=</span> pure x</a></code></pre></div>
<p>Here, we’re defining <code>pure</code> on streams: <code>pure x</code> produces an infinite stream of <code>x</code>. Its equivalent would be repeat in Haskell:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1">repeat<span class="ot"> ::</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">repeat x <span class="fu">=</span> x <span class="fu">:</span> repeat x</a></code></pre></div>
<p>Except instead of describing what it <em>is</em>, you describe how it <em>acts</em> (it’s kind of an intensional vs. extensional thing). In other words, if you want to make a stream <code>xs</code>, you have to answer the questions “what’s the head of <code>xs</code>?” and “what’s the tail of <code>xs</code>?”</p>
<p>Contrast this with pattern-matching: we’re producing (rather than consuming) a value, and in pattern matching, you have to answer a question for each <em>case</em>. If you want to consume a list <code>xs</code>, you have to answer the questions “what do you do when it’s nil?” and “what do you do when it’s cons?”</p>
<p>Anyway, I think the symmetry is kind of cool. Let’s get back to writing our functions.</p>
<h1 id="sized-types">Sized Types</h1>
<p>Unfortunately, we don’t have enough to prove productivity yet. As an explanation why, let’s first try produce the famous <code>fibs</code> list. Written here in Haskell:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">fibs <span class="fu">=</span> <span class="dv">0</span> <span class="fu">:</span> <span class="dv">1</span> <span class="fu">:</span> zipWith (<span class="fu">+</span>) fibs (tail fibs)</a></code></pre></div>
<p>Instead of <code>zipWith</code>, let’s define <code>&lt;*&gt;</code>. That will let us use <a href="https://agda.readthedocs.io/en/v2.5.4.1/language/syntactic-sugar.html#idiom-brackets">idiom brackets</a>.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">_</span>&lt;*&gt;<span class="ot">_</span> <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>a b<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">{</span>B <span class="ot">:</span> <span class="dt">Set</span> b<span class="ot">}</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2">      <span class="ot">→</span> Stream <span class="ot">(</span>A <span class="ot">→</span> B<span class="ot">)</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">      <span class="ot">→</span> Stream A</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">      <span class="ot">→</span> Stream B</a>
<a class="sourceLine" id="cb11-5" data-line-number="5">head <span class="ot">(</span>fs &lt;*&gt; xs<span class="ot">)</span> <span class="ot">=</span> head fs <span class="ot">(</span>head xs<span class="ot">)</span></a>
<a class="sourceLine" id="cb11-6" data-line-number="6">tail <span class="ot">(</span>fs &lt;*&gt; xs<span class="ot">)</span> <span class="ot">=</span> tail fs &lt;*&gt; tail xs</a></code></pre></div>
<p>And here’s <code>fibs</code>:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb12-1" data-line-number="1">fibs <span class="ot">:</span> Stream ℕ</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">head fibs <span class="ot">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">head <span class="ot">(</span>tail fibs<span class="ot">)</span> <span class="ot">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">tail <span class="ot">(</span>tail fibs<span class="ot">)</span> <span class="ot">=</span> ⦇ fibs + tail fibs ⦈</a></code></pre></div>
<p>But it doesn’t pass the productivity checker! Because we use a higher-order function (<code>&lt;*&gt;</code>), Agda won’t look at how much it dips into the infinite supply of values. This is a problem: we need it to know that <code>&lt;*&gt;</code> only needs the heads of its arguments to produce a head, and so on. The solution? Encode this information in the types.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">5</span> <span class="ot">_</span>◂<span class="ot">_</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2"><span class="kw">record</span> Stream <span class="ot">{</span>i <span class="ot">:</span> Size<span class="ot">}</span> <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">  <span class="kw">coinductive</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4">  <span class="kw">constructor</span> <span class="ot">_</span>◂<span class="ot">_</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5">  <span class="kw">field</span></a>
<a class="sourceLine" id="cb13-6" data-line-number="6">    head <span class="ot">:</span> A</a>
<a class="sourceLine" id="cb13-7" data-line-number="7">    tail <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>j <span class="ot">:</span> Size&lt; i<span class="ot">}</span> <span class="ot">→</span> Stream <span class="ot">{</span>j<span class="ot">}</span> A</a>
<a class="sourceLine" id="cb13-8" data-line-number="8"><span class="kw">open</span> Stream</a></code></pre></div>
<p>Now, <code>Stream</code> has an implicit <em>size</em> parameter. Basically, <code>Stream {i} A</code> can produce <code>i</code> more values. So <code>cons</code>, then, gives a stream one extra value to produce:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb14-1" data-line-number="1">cons <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>i a<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">→</span> A <span class="ot">→</span> Stream <span class="ot">{</span>i<span class="ot">}</span> A <span class="ot">→</span> Stream <span class="ot">{</span>↑ i<span class="ot">}</span> A</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">head <span class="ot">(</span>cons x xs<span class="ot">)</span> <span class="ot">=</span> x</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">tail <span class="ot">(</span>cons x xs<span class="ot">)</span> <span class="ot">=</span> xs</a></code></pre></div>
<p>Conversely, we can write a different definition of <code>tail</code> that consumes one value<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb15-1" data-line-number="1">tail′ <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>i a<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">→</span> Stream <span class="ot">{</span>↑ i<span class="ot">}</span> A <span class="ot">→</span> Stream <span class="ot">{</span>i<span class="ot">}</span> A</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">tail′ <span class="ot">{</span>i<span class="ot">}</span> xs <span class="ot">=</span> tail xs <span class="ot">{</span>i<span class="ot">}</span></a></code></pre></div>
<p>For <code>&lt;*&gt;</code>, we want to show that its result can produce just as much values as its inputs can:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="ot">_</span>&lt;*&gt;<span class="ot">_</span> <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>i a b<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">{</span>B <span class="ot">:</span> <span class="dt">Set</span> b<span class="ot">}</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2">      <span class="ot">→</span> Stream <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">(</span>A <span class="ot">→</span> B<span class="ot">)</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3">      <span class="ot">→</span> Stream <span class="ot">{</span>i<span class="ot">}</span> A</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">      <span class="ot">→</span> Stream <span class="ot">{</span>i<span class="ot">}</span> B</a>
<a class="sourceLine" id="cb16-5" data-line-number="5">head <span class="ot">(</span>fs &lt;*&gt; xs<span class="ot">)</span> <span class="ot">=</span> head fs <span class="ot">(</span>head xs<span class="ot">)</span></a>
<a class="sourceLine" id="cb16-6" data-line-number="6">tail <span class="ot">(</span>fs &lt;*&gt; xs<span class="ot">)</span> <span class="ot">=</span> tail fs &lt;*&gt; tail xs</a></code></pre></div>
<p>How does this help the termination/productivity checker? Well, for terminating functions, we have to keep giving the <code>tail</code> field smaller and smaller sizes, meaning that we’ll eventually hit zero (and terminate). For productivity, we now have a way to talk about “definedness” in types, so we can make sure that a recursive call doesn’t dip into a supply it hasn’t produced yet.</p>
<p>One more thing: <code>Size</code> types have strange typing rules, mainly for ergonomic purposes (this is why we’re not just using an <code>ℕ</code> parameter). One of them is that if you don’t specify the size, it’s defaulted to <code>∞</code>, so functions written without size annotations don’t have to be changed with this new definition:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb17-1" data-line-number="1">pure <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">→</span> A <span class="ot">→</span> Stream A</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">head <span class="ot">(</span>pure x<span class="ot">)</span> <span class="ot">=</span> x</a>
<a class="sourceLine" id="cb17-3" data-line-number="3">tail <span class="ot">(</span>pure x<span class="ot">)</span> <span class="ot">=</span> pure x</a></code></pre></div>
<p>Finally <code>fibs</code>:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb18-1" data-line-number="1">fibs <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">→</span> Stream <span class="ot">{</span>i<span class="ot">}</span> ℕ</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">head fibs <span class="ot">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3">head <span class="ot">(</span>tail fibs<span class="ot">)</span> <span class="ot">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb18-4" data-line-number="4">tail <span class="ot">(</span>tail fibs<span class="ot">)</span> <span class="ot">=</span> ⦇ fibs + tail fibs ⦈</a></code></pre></div>
<h1 id="bugs">Bugs!</h1>
<p>Before I show the Agda solution, I’d like to point out some bugs that were revealed in the Haskell version by trying to implement it totally. First of all, the function signature. “Takes an alphabet and produces unique strings” seems like this:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="ot">strings ::</span> [a] <span class="ot">-&gt;</span> [[a]]</a></code></pre></div>
<p>But what should you produce in this case:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1">strings []</a></code></pre></div>
<p>So it must be a non-empty list, giving us the following type and definition:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="ot">strings ::</span> <span class="dt">NonEmpty</span> a <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">strings (x <span class="fu">:|</span> xs) <span class="fu">=</span> (<span class="fu">:</span>) <span class="fu">&lt;$&gt;</span> (x<span class="fu">:</span>xs) <span class="fu">&lt;&lt;&gt;</span> (repeat x <span class="fu">:</span> tail (strings (x <span class="fu">:|</span> xs)))</a></code></pre></div>
<p>But this has a bug too! What happens if we pass in the following:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1">strings (x <span class="fu">:|</span> [])</a></code></pre></div>
<p>So this fails the specification: there is only one unique infinite string from that alphabet (<code>pure x</code>). Interestingly, though, our implementation above also won’t produce any output beyond the first element. I suppose, in a way, these things cancel each other out: our function does indeed produce all of the unique strings, it’s just a pity that it goes into an infinite loop to do so!</p>
<h1 id="bringing-it-all-together">Bringing it all Together</h1>
<p>Finally, we have our function:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb23-1" data-line-number="1">strings <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>i a<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">→</span> A × A × List A <span class="ot">→</span> Stream <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">(</span>Stream A<span class="ot">)</span></a>
<a class="sourceLine" id="cb23-2" data-line-number="2">head <span class="ot">(</span>strings <span class="ot">(</span>x , <span class="ot">_</span> , <span class="ot">_))</span> <span class="ot">=</span> pure x</a>
<a class="sourceLine" id="cb23-3" data-line-number="3">tail <span class="ot">(</span>strings <span class="ot">{</span>A <span class="ot">=</span> A<span class="ot">}</span> xs<span class="ot">@(</span>x₁ , x₂ , xt<span class="ot">))</span> <span class="ot">=</span> go x₂ xt <span class="ot">(</span>strings xs<span class="ot">)</span></a>
<a class="sourceLine" id="cb23-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-5" data-line-number="5">  go <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">→</span> A <span class="ot">→</span> List A <span class="ot">→</span> Stream <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">(</span>Stream A<span class="ot">)</span> <span class="ot">→</span> Stream <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">(</span>Stream A<span class="ot">)</span></a>
<a class="sourceLine" id="cb23-6" data-line-number="6">  head <span class="ot">(</span>head <span class="ot">(</span>go y ys zs<span class="ot">))</span> <span class="ot">=</span> y</a>
<a class="sourceLine" id="cb23-7" data-line-number="7">  tail <span class="ot">(</span>head <span class="ot">(</span>go y ys zs<span class="ot">))</span> <span class="ot">=</span> head zs</a>
<a class="sourceLine" id="cb23-8" data-line-number="8">  tail <span class="ot">(</span>go <span class="ot">_</span> [] zs<span class="ot">)</span> <span class="ot">=</span> go x₁ <span class="ot">(</span>x₂ ∷ xt<span class="ot">)</span> <span class="ot">(</span>tail zs<span class="ot">)</span></a>
<a class="sourceLine" id="cb23-9" data-line-number="9">  tail <span class="ot">(</span>go <span class="ot">_</span> <span class="ot">(</span>y ∷ ys<span class="ot">)</span> zs<span class="ot">)</span> <span class="ot">=</span> go y ys zs</a></code></pre></div>
<p>As you can see, we do need to kick-start it without a recursive call (the first line is <code>pure x</code>). Then, <code>go</code> takes as a third argument the “tails” argument, and does the kind of backwards Cartesian product we want. However, since we’re into the second element of the stream now, we want to avoid repeating what we already said, which is why we have to give <code>go</code> <code>x₂</code>, rather than <code>x₁</code>. This is what forces us to take at least two elements, rather than at least one, also: we can’t just take the tail of the call to <code>go</code> (this is what we did in the Haskell version of <code>strings</code> with the <code>NonEmpty</code> list), as the recursive call to strings then doesn’t decrease in size:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb24-1" data-line-number="1">strings <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>i a<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">→</span> A × List A <span class="ot">→</span> Stream <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">(</span>Stream A<span class="ot">)</span></a>
<a class="sourceLine" id="cb24-2" data-line-number="2">head <span class="ot">(</span>strings <span class="ot">(</span>x , <span class="ot">_))</span> <span class="ot">=</span> pure x</a>
<a class="sourceLine" id="cb24-3" data-line-number="3">tail <span class="ot">(</span>strings <span class="ot">{</span>A <span class="ot">=</span> A<span class="ot">}</span> xs<span class="ot">@(</span>x , xt<span class="ot">))</span> <span class="ot">=</span> tail <span class="ot">(</span>go x xt <span class="ot">(</span>strings xs<span class="ot">))</span></a>
<a class="sourceLine" id="cb24-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-5" data-line-number="5">  go <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">→</span> A <span class="ot">→</span> List A <span class="ot">→</span> Stream <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">(</span>Stream A<span class="ot">)</span> <span class="ot">→</span> Stream <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">(</span>Stream A<span class="ot">)</span></a>
<a class="sourceLine" id="cb24-6" data-line-number="6">  head <span class="ot">(</span>head <span class="ot">(</span>go y ys zs<span class="ot">))</span> <span class="ot">=</span> y</a>
<a class="sourceLine" id="cb24-7" data-line-number="7">  tail <span class="ot">(</span>head <span class="ot">(</span>go y ys zs<span class="ot">))</span> <span class="ot">=</span> head zs</a>
<a class="sourceLine" id="cb24-8" data-line-number="8">  tail <span class="ot">(</span>go <span class="ot">_</span> [] zs<span class="ot">)</span> <span class="ot">=</span> go x xt <span class="ot">(</span>tail zs<span class="ot">)</span></a>
<a class="sourceLine" id="cb24-9" data-line-number="9">  tail <span class="ot">(</span>go <span class="ot">_</span> <span class="ot">(</span>y ∷ ys<span class="ot">)</span> zs<span class="ot">)</span> <span class="ot">=</span> go y ys zs</a></code></pre></div>
<p>Agda will warn about termination on this function. Now, if you slap a pragma on it, it <em>will</em> produce the correct results for enough arguments, but give it one and you’ll get an infinite loop, just as you were warned!</p>
<h1 id="further-work">Further Work</h1>
<p>I’m having a lot of fun with copatterns for various algorithms (especially combinatorics). I’m planning on working on two particular tasks with them for the next posts in this series:</p>
<dl>
<dt>Proving <code>strings</code></dt>
<dd><p>I’d like to prove that <code>strings</code> does indeed produce a stream of unique values. Following from that, it would be cool to do a Cantor diagonalisation on its output.</p>
</dd>
<dt>Permutations</dt>
<dd><p>Haskell’s <a href="http://hackage.haskell.org/package/base-4.12.0.0/docs/src/Data.OldList.html#permutations">permutations implementation in Data.List</a> does some interesting tricks to make it as lazy as possible. It would be great to write an implementation that is verified to be as lazy as possible: the pattern of “definedness” is complex, though, so I don’t know if it’s possible with Agda’s current sized types.</p>
</dd>
</dl>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Thanks to <a href="http://gelisam.blogspot.com/">gelisam</a> for pointing out the poor phrasing here. Updated on 2018/10/16<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>You might wonder why the definition of <code>tail</code> doesn’t have this signature to begin with. The reason is that our record type must be <em>parameterized</em> (not indexed) over its size (as it’s a record type), so we use a less-than proof instead.<a href="#fnref2" class="footnote-back">↩</a></p></li>
</ol>
</section>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
