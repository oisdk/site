<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Enumerating Trees - Donnacha Oisín Kidney</title>
        <style>body{color:black;font-family:Garamond,Times New Roman,serif;font-size:15px;margin:0px auto 0px auto;padding-left:5px;padding-right:5px;max-width:650px}math{font-size:13px}img{max-width:600px}summary{outline:0}div#header{border-bottom:3px double black;margin-bottom:30px;padding:12px 0px 12px 0px}div#logo a{color:black;float:left;font-size:20px;text-decoration:none}div#header #navigation{text-align:right}div#header #navigation a{color:black;font-family:Garamond,Times New Roman,Serif;font-size:18px;margin-left:10px;text-decoration:none;text-transform:uppercase}div#footer{font-family:Garamond,Times New Roman,Serif;border-top:solid 2px black;color:#555;font-size:12px;margin-top:30px;padding:12px 0px 12px 0px;text-align:right}h1{font-family:Garamond,Times New Roman,Serif;font-size:22px;font-weight:normal}h2{font-family:Garamond,Times New Roman,Serif;font-size:20px;font-weight:normal}div.info{color:#555;font-size:15px;font-style:italic}span.quiet{color:#828282;font-style:italic}a{color:black;word-wrap:break-word}ul.post-list{margin-left:0px;padding-left:0px;list-style-type:none}.hidden_source{display:none}ol.serieslist{counter-reset:item;list-style-type:none;padding-left:20}ol li.serieslist:before{content:'Part ' counter(item,decimal) ':';counter-increment:item}table.sourceCode,tr.sourceCode,td.lineNumbers,td.sourceCode,table.sourceCode pre{margin:0;padding:0;border:0;vertical-align:baseline;border:none}td.lineNumbers{border-right:1px solid #AAAAAA;text-align:right;color:#AAAAAA;padding-right:5px;padding-left:5px}td.sourceCode{padding-left:5px}.sourceCode,code,pre,.Agda{font-size:10px;font-family:menlo,monospace}.sourceCode span.kw{color:#262C6A}.sourceCode span.dt{color:#476A97}.sourceCode span.dv{color:#262C6A}.sourceCode span.bn{color:#262C6A}.sourceCode span.fl{color:#262C6A}.sourceCode span.ch{color:#262C6A}.sourceCode span.st{color:#702C51}.sourceCode span.co{color:#435138}.sourceCode span.ot{color:#262C6A}.sourceCode span.al{color:red}.sourceCode span.fu{color:#000000}.sourceCode span.re{color:#000000}.sourceCode span.er{color:red}li{margin-bottom:2px}li:last-child{margin-bottom:0px}.Agda .Comment{color:#B22222}.Agda .Background{}.Agda .Markup{color:#000000}.Agda .Keyword{color:#CD6600}.Agda .String{color:#B22222}.Agda .Number{color:#A020F0}.Agda .Symbol{color:#404040}.Agda .PrimitiveType{color:#0000CD}.Agda .Pragma{color:black}.Agda .Operator{}.Agda .Bound{color:black}.Agda .Generalizable{color:black}.Agda .InductiveConstructor{color:#008B00}.Agda .CoinductiveConstructor{color:#8B7500}.Agda .Datatype{color:#0000CD}.Agda .Field{color:#EE1289}.Agda .Function{color:#0000CD}.Agda .Module{color:#A020F0}.Agda .Postulate{color:#0000CD}.Agda .Primitive{color:#0000CD}.Agda .Record{color:#0000CD}.Agda .DottedPattern{}.Agda .UnsolvedMeta{color:black;background:yellow}.Agda .UnsolvedConstraint{color:black;background:yellow}.Agda .TerminationProblem{color:black;background:#FFA07A}.Agda .IncompletePattern{color:black;background:#F5DEB3}.Agda .Error{color:red;text-decoration:underline}.Agda .TypeChecks{color:black;background:#ADD8E6}.Agda a{text-decoration:none}.Agda a[href]:hover{background-color:#B4EEB4}.sourceCode{overflow-x:auto}</style>
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Donnacha Oisín Kidney</a>
            </div>
            <div id="navigation">
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../rss.xml">Feed</a>
            </div>
        </div>

        <div id="content">
            <h2>Enumerating Trees</h2>

            <div class="info">
    Posted on December 14, 2020
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a title="All pages tagged 'Agda'." href="../tags/Agda.html">Agda</a>, <a title="All pages tagged 'Haskell'." href="../tags/Haskell.html">Haskell</a>
    
</div>

<p>Consider the following puzzle:</p>
<blockquote>
<p>Given a list of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> labels, list all the trees with those labels in order.</p>
</blockquote>
<p>For instance, given the labels [1,2,3,4], the answer (for binary trees) is the following:</p>
<pre><code>┌1     ┌1      ┌1     ┌1     ┌1
┤      ┤      ┌┤     ┌┤     ┌┤
│┌2    │ ┌2   ││┌2   │└2    │└2
└┤     │┌┤    │└┤    ┤     ┌┤
 │┌3   ││└3   │ └3   │┌3   │└3
 └┤    └┤     ┤      └┤    ┤
  └4    └4    └4      └4   └4</code></pre>
<p>This problem (the “enumeration” problem) turns out to be quite fascinating and deep, with connections to parsing and monoids. It’s also just a classic algorithmic problem which is fun to try and solve.</p>
<p>It’s worth having a go at attempting it yourself, but if you’d just like to see the slick solutions the following is one I’m especially proud of:</p>
<details>
<p><summary>Solution to the Enumeration Problem on Forests of Rose Trees</summary></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="ot">enumForests ::</span> [a] <span class="ot">-&gt;</span> [<span class="dt">Forest</span> a]</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>enumForests <span class="ot">=</span> foldrM f []</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>    f x xs <span class="ot">=</span> <span class="fu">zipWith</span> ((<span class="op">:</span>) <span class="op">.</span> (<span class="op">:&amp;</span>) x) (inits xs) (tails xs)</span></code></pre></div>
</details>
<p>In the rest of this post I’ll go through the intuition behind solutions like the one above and I’ll try to elucidate some of the connections to other areas of computer science.</p>
<h1 id="a-first-approach-trying-to-enumerate-directly">A First Approach: Trying to Enumerate Directly</h1>
<p>I first came across the enumeration problem when I was writing my master’s thesis: I needed to prove (in Agda) that there were finitely many binary trees of a given size, and that I could list them (this proof was part of a larger verified solver for the countdown problem). My first few attempts were unsuccessful: the algorithm presented in the countdown paper <span class="citation" data-cites="hutton_countdown_2002">(Hutton <a href="#ref-hutton_countdown_2002" role="doc-biblioref">2002</a>)</span> was not structurally recursive, and did not seem amenable to Agda-style proofs.</p>
<p>Instead, I looked for a type which was isomorphic to binary trees, and which might be easier to reason about. One such type is Dyck words.</p>
<h1 id="dyck-words">Dyck Words</h1>
<p>A “Dyck word” is a string of balanced parentheses.</p>
<pre><code>()()
(()())()
(())()</code></pre>
<p>It’s (apparently) well-known that these strings are isomorphic to binary trees (although the imperative descriptions of algorithms which actually computed this isomorphism addled my brain), but what made them interesting for me was that they are a <em>flat</em> type, structured like a linked list, and as such should be reasonably straightforward to prove to be finite.</p>
<p>Our first task, then, is to write down a type for Dyck words. Te following is a first possibility:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Paren</span> <span class="ot">=</span> <span class="dt">LParen</span> <span class="op">|</span> <span class="dt">RParen</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">Dyck</span> <span class="ot">=</span> [<span class="dt">Paren</span>]</span></code></pre></div>
<p>But this type isn’t correct. It includes many values which <em>don’t</em> represent balanced parentheses, i.e. the expressions <code>[LParen,RParen] :: Dyck</code> are well-typed. To describe dyck words properly we’ll need to reach for the GADTs:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">DyckSuff</span> (<span class="ot">n ::</span> <span class="dt">Nat</span>)<span class="ot"> ::</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>  <span class="dt">Done</span><span class="ot"> ::</span> <span class="dt">DyckSuff</span> <span class="dt">Z</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>  <span class="dt">Open</span><span class="ot"> ::</span> <span class="dt">DyckSuff</span> (<span class="dt">S</span> n) <span class="ot">-&gt;</span> <span class="dt">DyckSuff</span> n</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>  <span class="dt">Clos</span><span class="ot"> ::</span> <span class="dt">DyckSuff</span> n     <span class="ot">-&gt;</span> <span class="dt">DyckSuff</span> (<span class="dt">S</span> n)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">Dyck</span> <span class="ot">=</span> <span class="dt">DyckSuff</span> <span class="dt">Z</span></span></code></pre></div>
<p>The first type here represents suffixes of Dyck words; a value of type <code>DyckSuff n</code> represents a string of parentheses which is balanced except for <code>n</code> extraneous closing parentheses. <code>DyckSuff Z</code>, then, has no extraneous closing parens, and as such is a proper Dyck word.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="op">&gt;&gt;&gt;</span> <span class="dt">Open</span> <span class="op">$</span> <span class="dt">Clos</span> <span class="op">$</span> <span class="dt">Open</span> <span class="op">$</span> <span class="dt">Clos</span> <span class="op">$</span> <span class="dt">Done</span><span class="ot"> ::</span> <span class="dt">Dyck</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>()()</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a><span class="op">&gt;&gt;&gt;</span> <span class="dt">Clos</span> <span class="op">$</span> <span class="dt">Open</span> <span class="op">$</span> <span class="dt">Clos</span> <span class="op">$</span> <span class="dt">Done</span><span class="ot"> ::</span> <span class="dt">DyckSuff</span> (<span class="dt">S</span> <span class="dt">Z</span>)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>)()</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a><span class="op">&gt;&gt;&gt;</span> <span class="dt">Open</span> <span class="op">$</span> <span class="dt">Open</span> <span class="op">$</span> <span class="dt">Clos</span> <span class="op">$</span> <span class="dt">Open</span> <span class="op">$</span> <span class="dt">Clos</span> <span class="op">$</span> <span class="dt">Clos</span> <span class="op">$</span> <span class="dt">Open</span> <span class="op">$</span> <span class="dt">Clos</span> <span class="op">$</span> <span class="dt">Done</span><span class="ot"> ::</span> <span class="dt">Dyck</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a>(()())()</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true"></a><span class="op">&gt;&gt;&gt;</span> <span class="dt">Open</span> <span class="op">$</span> <span class="dt">Open</span> <span class="op">$</span> <span class="dt">Clos</span> <span class="op">$</span> <span class="dt">Clos</span> <span class="op">$</span> <span class="dt">Open</span> <span class="op">$</span> <span class="dt">Clos</span> <span class="op">$</span> <span class="dt">Done</span><span class="ot"> ::</span> <span class="dt">Dyck</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true"></a>(())()</span></code></pre></div>
<p>The next task is to actually enumerate these words. Here’s an <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math> algorithm which does just that:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="ot">enumDyck ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Dyck</span>]</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>enumDyck sz <span class="ot">=</span> go <span class="dt">Zy</span> sz <span class="dt">Done</span> []</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>    go, zero, left,<span class="ot"> right ::</span> <span class="dt">Natty</span> n <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">DyckSuff</span> n <span class="ot">-&gt;</span> [<span class="dt">Dyck</span>] <span class="ot">-&gt;</span> [<span class="dt">Dyck</span>]</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>    </span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a>    go n m k <span class="ot">=</span> zero n m k <span class="op">.</span> left n m k <span class="op">.</span> right n m k</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a>    zero <span class="dt">Zy</span> <span class="dv">0</span> k <span class="ot">=</span> (k<span class="op">:</span>)</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a>    zero _  _ _ <span class="ot">=</span> <span class="fu">id</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true"></a>    </span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true"></a>    left (<span class="dt">Sy</span> n) m k <span class="ot">=</span> go n m (<span class="dt">Open</span> k)</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true"></a>    left <span class="dt">Zy</span>     _ _ <span class="ot">=</span> <span class="fu">id</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true"></a>    </span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true"></a>    right _ <span class="dv">0</span> _ <span class="ot">=</span> <span class="fu">id</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true"></a>    right n m k <span class="ot">=</span> go (<span class="dt">Sy</span> n) (m<span class="op">-</span><span class="dv">1</span>) (<span class="dt">Clos</span> k) </span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true"></a></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true"></a><span class="op">&gt;&gt;&gt;</span> <span class="fu">mapM_</span> <span class="fu">print</span> (enumDyck <span class="dv">3</span>)</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true"></a><span class="st">&quot;()()()&quot;</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true"></a><span class="st">&quot;(())()&quot;</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true"></a><span class="st">&quot;()(())&quot;</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true"></a><span class="st">&quot;(()())&quot;</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true"></a><span class="st">&quot;((()))&quot;</span></span></code></pre></div>
<p>A variant of this function was what I needed in my thesis: I also needed to prove that it produced every possible value of the type <code>Dyck</code>, which was not too difficult.</p>
<p>The difficult part is still ahead, though: now we need to convert between this type and a binary tree.</p>
<h1 id="conversion">Conversion</h1>
<p>First, for the conversion algorithms we’ll actually need another GADT:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="kw">infixr</span> <span class="dv">5</span> <span class="op">:-</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Stack</span> (<span class="ot">a ::</span> <span class="dt">Type</span>) (<span class="ot">n ::</span> <span class="dt">Nat</span>)<span class="ot"> ::</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>  <span class="dt">Nil</span><span class="ot">  ::</span> <span class="dt">Stack</span> a <span class="dt">Z</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a><span class="ot">  (:-) ::</span> a <span class="ot">-&gt;</span> <span class="dt">Stack</span> a n <span class="ot">-&gt;</span> <span class="dt">Stack</span> a (<span class="dt">S</span> n)</span></code></pre></div>
<p>The familiar length-indexed vector will be extremely useful for the next few bits of code: it will act as a stack in our stack-based algorithms. Here’s one of those algorithms now:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="ot">dyckToTree ::</span> <span class="dt">Dyck</span> <span class="ot">-&gt;</span> <span class="dt">Tree</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>dyckToTree dy <span class="ot">=</span> go dy (<span class="dt">Leaf</span> <span class="op">:-</span> <span class="dt">Nil</span>)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a><span class="ot">    go ::</span> <span class="dt">DyckSuff</span> n <span class="ot">-&gt;</span> <span class="dt">Stack</span> <span class="dt">Tree</span> (<span class="dt">S</span> n) <span class="ot">-&gt;</span> <span class="dt">Tree</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a>    go (<span class="dt">Open</span> d) ts               <span class="ot">=</span> go d (<span class="dt">Leaf</span> <span class="op">:-</span> ts)</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a>    go (<span class="dt">Clos</span> d) (t1 <span class="op">:-</span> t2 <span class="op">:-</span> ts) <span class="ot">=</span> go d (t2 <span class="op">:*:</span> t1 <span class="op">:-</span> ts)</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a>    go <span class="dt">Done</span>     (t  <span class="op">:-</span> <span class="dt">Nil</span>)      <span class="ot">=</span> t</span></code></pre></div>
<p>This might be familiar: it’s actually shift-reduce parsing dressed up with some types. The nice thing about it is that it’s completely total: all pattern-matches are accounted for here, and when written in Agda it’s clearly structurally terminating.</p>
<p>The function in the other direction is similarly simple:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="ot">treeToDyck ::</span> <span class="dt">Tree</span> <span class="ot">-&gt;</span> <span class="dt">Dyck</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>treeToDyck t <span class="ot">=</span> go t <span class="dt">Done</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a><span class="ot">    go ::</span> <span class="dt">Tree</span> <span class="ot">-&gt;</span> <span class="dt">DyckSuff</span> n <span class="ot">-&gt;</span> <span class="dt">DyckSuff</span> n</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a>    go <span class="dt">Leaf</span>        <span class="ot">=</span> <span class="fu">id</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a>    go (xs <span class="op">:*:</span> ys) <span class="ot">=</span> go xs <span class="op">.</span> <span class="dt">Open</span> <span class="op">.</span> go ys <span class="op">.</span> <span class="dt">Clos</span></span></code></pre></div>
<h1 id="a-compiler">A Compiler</h1>
<p>Much of this stuff has been on my mind recently because of <a href="https://www.youtube.com/watch?v=T_IINWzQhow">this</a> <span class="citation" data-cites="riley_program_2020">(<a href="#ref-riley_program_2020" role="doc-biblioref">2020</a>)</span> video on the computerphile channel, in which Graham Hutton goes through using QuickCheck to test an interesting compiler. The compiler itself is explored more in depth in <span class="citation" data-cites="bahr_calculating_2015">Bahr and Hutton (<a href="#ref-bahr_calculating_2015" role="doc-biblioref">2015</a>)</span>, where the algorithms developed are really quite similar to those that we have here.</p>
<p>The advantage of the code above is that it’s all <em>total</em>: we will never pop items off the stack that aren’t there. This is a nice addition, and it’s surprisingly simple to add: let’s see if we can add it to the compiler presented in the paper.</p>
<p>The first thing we need to change is we need to add a payload to our tree type: the one above is just the <em>shape</em> of a binary tree, but the language presented in the paper contains values.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Expr</span> (<span class="ot">a ::</span> <span class="dt">Type</span>) <span class="kw">where</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a>  <span class="dt">Val</span><span class="ot">   ::</span> a <span class="ot">-&gt;</span> <span class="dt">Expr</span> a</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a><span class="ot">  (:+:) ::</span> <span class="dt">Expr</span> a <span class="ot">-&gt;</span> <span class="dt">Expr</span> a <span class="ot">-&gt;</span> <span class="dt">Expr</span> a</span></code></pre></div>
<p>We’ll need to change the definition of <code>Dyck</code> similarly:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Code</span> (<span class="ot">n ::</span> <span class="dt">Nat</span>) (<span class="ot">a ::</span> <span class="dt">Type</span>)<span class="ot"> ::</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a>  <span class="dt">HALT</span><span class="ot"> ::</span> <span class="dt">Code</span> (<span class="dt">S</span> <span class="dt">Z</span>) a</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a>  <span class="dt">PUSH</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Code</span> (<span class="dt">S</span> n) a <span class="ot">-&gt;</span> <span class="dt">Code</span> n a</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a>  <span class="dt">ADD</span><span class="ot">  ::</span> <span class="dt">Code</span> (<span class="dt">S</span> n) a <span class="ot">-&gt;</span> <span class="dt">Code</span> (<span class="dt">S</span> (<span class="dt">S</span> n)) a</span></code></pre></div>
<p>After making it so that these data structures can now store contents, there are two other changes worth pointing out:</p>
<ul>
<li>The names have been changed, to match those in the paper. It’s a little clearer now that the Dyck word is a bit like code for a simple stack machine.</li>
<li>The numbering on <code>Code</code> has changed. Now, the <code>HALT</code> constructor has a parameter of <code>1</code> (well, <code>S Z</code>), where its corresponding constructor in <code>Dyck</code> (<code>Done</code>) had <code>0</code>. Why is this? I am not entirely sure! To get this stuff to all work out nicely took a huge amount of trial and error, I would love to see a more principled reason why the numbering changed here.</li>
</ul>
<p>With these definitions we can actually transcribe the <code>exec</code> and <code>comp</code> functions almost verbatim <span class="citation" data-cites="bahr_calculating_2015">(from page 11 and 12 of <a href="#ref-bahr_calculating_2015" role="doc-biblioref">2015</a>)</span>.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="ot">exec ::</span> <span class="dt">Code</span> n <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Stack</span> <span class="dt">Int</span> (n <span class="op">+</span> m) <span class="ot">-&gt;</span> <span class="dt">Stack</span> <span class="dt">Int</span> (<span class="dt">S</span> m)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a>exec <span class="dt">HALT</span>         st              <span class="ot">=</span> st</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a>exec (<span class="dt">PUSH</span> v is)  st              <span class="ot">=</span> exec is (v <span class="op">:-</span> st)</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a>exec (<span class="dt">ADD</span>    is) (t1 <span class="op">:-</span> t2 <span class="op">:-</span> st) <span class="ot">=</span> exec is (t2 <span class="op">+</span> t1 <span class="op">:-</span> st)</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a><span class="ot">comp ::</span> <span class="dt">Expr</span> a <span class="ot">-&gt;</span> <span class="dt">Code</span> <span class="dt">Z</span> a</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a>comp e <span class="ot">=</span> comp' e <span class="dt">HALT</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true"></a><span class="ot">    comp' ::</span> <span class="dt">Expr</span> a <span class="ot">-&gt;</span> <span class="dt">Code</span> (<span class="dt">S</span> n) a <span class="ot">-&gt;</span> <span class="dt">Code</span> n a</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true"></a>    comp' (<span class="dt">Val</span>     x) <span class="ot">=</span> <span class="dt">PUSH</span> x</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true"></a>    comp' (xs <span class="op">:+:</span> ys) <span class="ot">=</span> comp' xs <span class="op">.</span> comp' ys <span class="op">.</span> <span class="dt">ADD</span></span></code></pre></div>
<h1 id="proving-the-isomorphism">Proving the Isomorphism</h1>
<p>As I have mentioned, a big benefit of all of this stuff is that it can be translated into Agda readily. The real benefit of <em>that</em> is that we can show the two representations of programs are fully isomorphic. I have proven this <a href="https://github.com/oisdk/agda-playground/blob/d7234c276f063dbb4a2d2cbcedb86dd48501a908/Data/Dyck/Payload.agda">here</a>: the proof is surprisingly short (about 20 lines), and the rest of the code follows the Haskell stuff quite closely. I got the idea for much of the proof from <a href="https://gist.github.com/Boarders/9d83f9cbcfaffb04cf2464588fc46df9">this</a> bit of code by <a href="https://boarders.github.io/">Callan McGill</a> <span class="citation" data-cites="mcgill_compiler_2020">(<a href="#ref-mcgill_compiler_2020" role="doc-biblioref">2020</a>)</span>.</p>
<p>I’ll include it here as a reference.</p>
<details>
<p><summary>Agda Code</summary></p>
<div class="sourceCode" id="cb14"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="kw">open</span> <span class="kw">import</span> Prelude</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a><span class="kw">open</span> <span class="kw">import</span> Data<span class="ot">.</span>Nat <span class="kw">using</span> <span class="ot">(_</span>+<span class="ot">_)</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a><span class="kw">open</span> <span class="kw">import</span> Data<span class="ot">.</span>Vec<span class="ot">.</span>Iterated <span class="kw">using</span> <span class="ot">(</span>Vec<span class="ot">;</span> <span class="ot">_</span>∷<span class="ot">_;</span> []<span class="ot">;</span> foldlN<span class="ot">;</span> head<span class="ot">)</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a><span class="kw">private</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true"></a>  <span class="kw">variable</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true"></a>    n <span class="ot">:</span> ℕ</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true"></a></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true"></a><span class="co">--------------------------------------------------------------------------------</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true"></a><span class="co">-- Binary trees: definition and associated functions</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true"></a><span class="co">--------------------------------------------------------------------------------</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true"></a></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true"></a><span class="kw">data</span> Tree <span class="ot">(</span>A <span class="ot">:</span> Type a<span class="ot">)</span> <span class="ot">:</span> Type a <span class="kw">where</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true"></a>  [<span class="ot">_</span>] <span class="ot">:</span> A <span class="ot">→</span> Tree A</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true"></a>  <span class="ot">_</span>*<span class="ot">_</span> <span class="ot">:</span> Tree A <span class="ot">→</span> Tree A <span class="ot">→</span> Tree A</span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true"></a></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true"></a><span class="co">--------------------------------------------------------------------------------</span></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true"></a><span class="co">-- Programs: definition and associated functions</span></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true"></a><span class="co">--------------------------------------------------------------------------------</span></span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true"></a></span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true"></a><span class="kw">data</span> Prog <span class="ot">(</span>A <span class="ot">:</span> Type a<span class="ot">)</span> <span class="ot">:</span> ℕ <span class="ot">→</span> Type a <span class="kw">where</span></span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true"></a>  halt <span class="ot">:</span> Prog A <span class="dv">1</span></span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true"></a>  push <span class="ot">:</span> A <span class="ot">→</span> Prog A <span class="ot">(</span><span class="dv">1</span> + n<span class="ot">)</span> <span class="ot">→</span> Prog A n</span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true"></a>  pull <span class="ot">:</span> Prog A <span class="ot">(</span><span class="dv">1</span> + n<span class="ot">)</span> <span class="ot">→</span> Prog A <span class="ot">(</span><span class="dv">2</span> + n<span class="ot">)</span></span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true"></a></span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true"></a><span class="co">--------------------------------------------------------------------------------</span></span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true"></a><span class="co">-- Conversion from a Prog to a Tree</span></span>
<span id="cb14-28"><a href="#cb14-28" aria-hidden="true"></a><span class="co">--------------------------------------------------------------------------------</span></span>
<span id="cb14-29"><a href="#cb14-29" aria-hidden="true"></a></span>
<span id="cb14-30"><a href="#cb14-30" aria-hidden="true"></a>prog→tree⊙ <span class="ot">:</span> Prog A n <span class="ot">→</span> Vec <span class="ot">(</span>Tree A<span class="ot">)</span> n <span class="ot">→</span> Tree A</span>
<span id="cb14-31"><a href="#cb14-31" aria-hidden="true"></a>prog→tree⊙ halt        <span class="ot">(</span>v ∷ []<span class="ot">)</span>       <span class="ot">=</span> v</span>
<span id="cb14-32"><a href="#cb14-32" aria-hidden="true"></a>prog→tree⊙ <span class="ot">(</span>push v is<span class="ot">)</span> st             <span class="ot">=</span> prog→tree⊙ is <span class="ot">(</span>[ v ] ∷ st<span class="ot">)</span></span>
<span id="cb14-33"><a href="#cb14-33" aria-hidden="true"></a>prog→tree⊙ <span class="ot">(</span>pull   is<span class="ot">)</span> <span class="ot">(</span>t₁ ∷ t₂ ∷ st<span class="ot">)</span> <span class="ot">=</span> prog→tree⊙ is <span class="ot">(</span>t₂ * t₁ ∷ st<span class="ot">)</span></span>
<span id="cb14-34"><a href="#cb14-34" aria-hidden="true"></a></span>
<span id="cb14-35"><a href="#cb14-35" aria-hidden="true"></a>prog→tree <span class="ot">:</span> Prog A zero <span class="ot">→</span> Tree A</span>
<span id="cb14-36"><a href="#cb14-36" aria-hidden="true"></a>prog→tree ds <span class="ot">=</span> prog→tree⊙ ds []</span>
<span id="cb14-37"><a href="#cb14-37" aria-hidden="true"></a></span>
<span id="cb14-38"><a href="#cb14-38" aria-hidden="true"></a><span class="co">--------------------------------------------------------------------------------</span></span>
<span id="cb14-39"><a href="#cb14-39" aria-hidden="true"></a><span class="co">-- Conversion from a Tree to a Prog</span></span>
<span id="cb14-40"><a href="#cb14-40" aria-hidden="true"></a><span class="co">--------------------------------------------------------------------------------</span></span>
<span id="cb14-41"><a href="#cb14-41" aria-hidden="true"></a></span>
<span id="cb14-42"><a href="#cb14-42" aria-hidden="true"></a>tree→prog⊙ <span class="ot">:</span> Tree A <span class="ot">→</span> Prog A <span class="ot">(</span>suc n<span class="ot">)</span> <span class="ot">→</span> Prog A n</span>
<span id="cb14-43"><a href="#cb14-43" aria-hidden="true"></a>tree→prog⊙ [ x ]     <span class="ot">=</span> push x</span>
<span id="cb14-44"><a href="#cb14-44" aria-hidden="true"></a>tree→prog⊙ <span class="ot">(</span>xs * ys<span class="ot">)</span> <span class="ot">=</span> tree→prog⊙ xs ∘ tree→prog⊙ ys ∘ pull</span>
<span id="cb14-45"><a href="#cb14-45" aria-hidden="true"></a></span>
<span id="cb14-46"><a href="#cb14-46" aria-hidden="true"></a>tree→prog <span class="ot">:</span> Tree A <span class="ot">→</span> Prog A zero</span>
<span id="cb14-47"><a href="#cb14-47" aria-hidden="true"></a>tree→prog tr <span class="ot">=</span> tree→prog⊙ tr halt</span>
<span id="cb14-48"><a href="#cb14-48" aria-hidden="true"></a></span>
<span id="cb14-49"><a href="#cb14-49" aria-hidden="true"></a><span class="co">--------------------------------------------------------------------------------</span></span>
<span id="cb14-50"><a href="#cb14-50" aria-hidden="true"></a><span class="co">-- Proof of isomorphism</span></span>
<span id="cb14-51"><a href="#cb14-51" aria-hidden="true"></a><span class="co">--------------------------------------------------------------------------------</span></span>
<span id="cb14-52"><a href="#cb14-52" aria-hidden="true"></a></span>
<span id="cb14-53"><a href="#cb14-53" aria-hidden="true"></a>tree→prog→tree⊙ <span class="ot">:</span> <span class="ot">(</span>e <span class="ot">:</span> Tree A<span class="ot">)</span> <span class="ot">(</span>is <span class="ot">:</span> Prog A <span class="ot">(</span><span class="dv">1</span> + n<span class="ot">))</span> <span class="ot">(</span>st <span class="ot">:</span> Vec <span class="ot">(</span>Tree A<span class="ot">)</span> n<span class="ot">)</span> <span class="ot">→</span></span>
<span id="cb14-54"><a href="#cb14-54" aria-hidden="true"></a>  prog→tree⊙ <span class="ot">(</span>tree→prog⊙ e is<span class="ot">)</span> st ≡ prog→tree⊙ is <span class="ot">(</span>e ∷ st<span class="ot">)</span></span>
<span id="cb14-55"><a href="#cb14-55" aria-hidden="true"></a>tree→prog→tree⊙ [ x ]     is st <span class="ot">=</span> refl</span>
<span id="cb14-56"><a href="#cb14-56" aria-hidden="true"></a>tree→prog→tree⊙ <span class="ot">(</span>xs * ys<span class="ot">)</span> is st <span class="ot">=</span> tree→prog→tree⊙ xs <span class="ot">_</span> st <span class="ot">;</span></span>
<span id="cb14-57"><a href="#cb14-57" aria-hidden="true"></a>                                  tree→prog→tree⊙ ys <span class="ot">(</span>pull is<span class="ot">)</span> <span class="ot">(</span>xs ∷ st<span class="ot">)</span></span>
<span id="cb14-58"><a href="#cb14-58" aria-hidden="true"></a></span>
<span id="cb14-59"><a href="#cb14-59" aria-hidden="true"></a>tree→prog→tree <span class="ot">:</span> <span class="ot">(</span>e <span class="ot">:</span> Tree A<span class="ot">)</span> <span class="ot">→</span> prog→tree <span class="ot">(</span>tree→prog e<span class="ot">)</span> ≡ e</span>
<span id="cb14-60"><a href="#cb14-60" aria-hidden="true"></a>tree→prog→tree e <span class="ot">=</span> tree→prog→tree⊙ e halt []</span>
<span id="cb14-61"><a href="#cb14-61" aria-hidden="true"></a></span>
<span id="cb14-62"><a href="#cb14-62" aria-hidden="true"></a>prog→tree→prog⊙ <span class="ot">:</span> <span class="ot">(</span>is <span class="ot">:</span> Prog A n<span class="ot">)</span> <span class="ot">(</span>st <span class="ot">:</span> Vec <span class="ot">(</span>Tree A<span class="ot">)</span> n<span class="ot">)</span> <span class="ot">→</span></span>
<span id="cb14-63"><a href="#cb14-63" aria-hidden="true"></a> tree→prog <span class="ot">(</span>prog→tree⊙ is st<span class="ot">)</span> ≡ foldlN <span class="ot">(</span>Prog A<span class="ot">)</span> tree→prog⊙ is st</span>
<span id="cb14-64"><a href="#cb14-64" aria-hidden="true"></a>prog→tree→prog⊙  halt       st <span class="ot">=</span> refl</span>
<span id="cb14-65"><a href="#cb14-65" aria-hidden="true"></a>prog→tree→prog⊙ <span class="ot">(</span>push i is<span class="ot">)</span> st <span class="ot">=</span> prog→tree→prog⊙ is <span class="ot">(</span>[ i ] ∷ st<span class="ot">)</span></span>
<span id="cb14-66"><a href="#cb14-66" aria-hidden="true"></a>prog→tree→prog⊙ <span class="ot">(</span>pull is<span class="ot">)</span> <span class="ot">(</span>t₁ ∷ t₂ ∷ ts<span class="ot">)</span> <span class="ot">=</span> prog→tree→prog⊙ is <span class="ot">((</span>t₂ * t₁<span class="ot">)</span> ∷ ts<span class="ot">)</span></span>
<span id="cb14-67"><a href="#cb14-67" aria-hidden="true"></a></span>
<span id="cb14-68"><a href="#cb14-68" aria-hidden="true"></a>prog→tree→prog <span class="ot">:</span> <span class="ot">(</span>is <span class="ot">:</span> Prog A <span class="dv">0</span><span class="ot">)</span> <span class="ot">→</span> tree→prog <span class="ot">(</span>prog→tree is<span class="ot">)</span> ≡ is</span>
<span id="cb14-69"><a href="#cb14-69" aria-hidden="true"></a>prog→tree→prog is <span class="ot">=</span> prog→tree→prog⊙ is []</span>
<span id="cb14-70"><a href="#cb14-70" aria-hidden="true"></a></span>
<span id="cb14-71"><a href="#cb14-71" aria-hidden="true"></a>prog-iso <span class="ot">:</span> Prog A zero ⇔ Tree A</span>
<span id="cb14-72"><a href="#cb14-72" aria-hidden="true"></a>prog-iso <span class="ot">.</span>fun <span class="ot">=</span> prog→tree</span>
<span id="cb14-73"><a href="#cb14-73" aria-hidden="true"></a>prog-iso <span class="ot">.</span>inv <span class="ot">=</span> tree→prog</span>
<span id="cb14-74"><a href="#cb14-74" aria-hidden="true"></a>prog-iso <span class="ot">.</span>rightInv <span class="ot">=</span> tree→prog→tree</span>
<span id="cb14-75"><a href="#cb14-75" aria-hidden="true"></a>prog-iso <span class="ot">.</span>leftInv  <span class="ot">=</span> prog→tree→prog</span></code></pre></div>
</details>
<h1 id="folds-and-whatnot">Folds and Whatnot</h1>
<p>Another thing I’ll mention is that all of the <code>exec</code> functions presented are <em>folds</em>. In particular, they’re <em>left</em> folds. Here’s how we’d rewrite <code>exec</code> to make that fact clear:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="ot">foldlCode ::</span> (<span class="ot">∀</span> n<span class="op">.</span> a <span class="ot">-&gt;</span> b n <span class="ot">-&gt;</span> b (<span class="dt">S</span> n))</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a>          <span class="ot">-&gt;</span> (<span class="ot">∀</span> n<span class="op">.</span> b (<span class="dt">S</span> (<span class="dt">S</span> n)) <span class="ot">-&gt;</span> b (<span class="dt">S</span> n))</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a>          <span class="ot">-&gt;</span> b m</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a>          <span class="ot">-&gt;</span> <span class="dt">Code</span> m a <span class="ot">-&gt;</span> b (<span class="dt">S</span> <span class="dt">Z</span>)</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true"></a>foldlCode _ _ h  <span class="dt">HALT</span>       <span class="ot">=</span> h</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true"></a>foldlCode p a h (<span class="dt">PUSH</span> x xs) <span class="ot">=</span> foldlCode p a (p x h) xs</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true"></a>foldlCode p a h (<span class="dt">ADD</span>    xs) <span class="ot">=</span> foldlCode p a (a   h) xs</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true"></a></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true"></a><span class="ot">shift ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Stack</span> <span class="dt">Int</span> n <span class="ot">-&gt;</span> <span class="dt">Stack</span> <span class="dt">Int</span> (<span class="dt">S</span> n)</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true"></a>shift x xs <span class="ot">=</span> x <span class="op">:-</span> xs</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true"></a></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true"></a><span class="ot">reduce ::</span> <span class="dt">Stack</span> <span class="dt">Int</span> (<span class="dt">S</span> (<span class="dt">S</span> n)) <span class="ot">-&gt;</span> <span class="dt">Stack</span> <span class="dt">Int</span> (<span class="dt">S</span> n)</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true"></a>reduce (t1 <span class="op">:-</span> t2 <span class="op">:-</span> st) <span class="ot">=</span> t2 <span class="op">+</span> t1 <span class="op">:-</span> st</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true"></a></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true"></a><span class="ot">execFold ::</span> <span class="dt">Code</span> <span class="dt">Z</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true"></a>execFold <span class="ot">=</span> pop <span class="op">.</span> foldlCode shift reduce <span class="dt">Nil</span></span></code></pre></div>
<p>I think the “foldl-from-foldr” trick could be a nice way to explain the introduction of continuations in <span class="citation" data-cites="bahr_calculating_2015">Bahr and Hutton (<a href="#ref-bahr_calculating_2015" role="doc-biblioref">2015</a>)</span>.</p>
<h1 id="direct-enumeration">Direct Enumeration</h1>
<p>It turns out that you can follow relatively straightforward rewriting steps from the Dyck-based enumeration algorithm to get to one which avoids Dyck words entirely:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span class="ot">enumTrees ::</span> [a] <span class="ot">-&gt;</span> [<span class="dt">Expr</span> a]</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a>enumTrees <span class="ot">=</span> <span class="fu">fmap</span> (<span class="fu">foldl1</span> (<span class="fu">flip</span> (<span class="op">:+:</span>))) <span class="op">.</span> foldlM f []</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a>  <span class="kw">where</span>    </span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a>    f []         v <span class="ot">=</span> [[<span class="dt">Val</span> v]]</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true"></a>    f [t1]       v <span class="ot">=</span> [[<span class="dt">Val</span> v, t1]]</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true"></a>    f (t1<span class="op">:</span>t2<span class="op">:</span>st) v <span class="ot">=</span> (<span class="dt">Val</span> v <span class="op">:</span> t1 <span class="op">:</span> t2 <span class="op">:</span> st) <span class="op">:</span> f ((t2 <span class="op">:+:</span> t1) <span class="op">:</span> st) v</span></code></pre></div>
<p>Maybe in a future post I’ll go through the derivation of this algorithm.</p>
<p>It turns out that the Dyck-based enumeration can be applied without much difficulty to rose trees as well:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Rose</span> a <span class="ot">=</span> a <span class="op">:&amp;</span> <span class="dt">Forest</span> a</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">Forest</span> a <span class="ot">=</span> [<span class="dt">Rose</span> a]</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a><span class="ot">dyckToForest ::</span> <span class="dt">Dyck</span> <span class="ot">-&gt;</span> <span class="dt">Forest</span> ()</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a>dyckToForest dy <span class="ot">=</span> go dy ([] <span class="op">:-</span> <span class="dt">Nil</span>)</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true"></a><span class="ot">    go ::</span> <span class="dt">DyckSuff</span> n <span class="ot">-&gt;</span> <span class="dt">Stack</span> (<span class="dt">Forest</span> ()) (<span class="dt">S</span> n) <span class="ot">-&gt;</span> <span class="dt">Forest</span> ()</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true"></a>    go (<span class="dt">Open</span> d) ts               <span class="ot">=</span> go d ([] <span class="op">:-</span> ts)</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true"></a>    go (<span class="dt">Clos</span> d) (t1 <span class="op">:-</span> t2 <span class="op">:-</span> ts) <span class="ot">=</span> go d ((() <span class="op">:&amp;</span> t2 <span class="op">:</span> t1) <span class="op">:-</span> ts)</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true"></a>    go <span class="dt">Done</span>     (t  <span class="op">:-</span> <span class="dt">Nil</span>)      <span class="ot">=</span> t</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true"></a></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true"></a><span class="ot">forestToDyck ::</span> <span class="dt">Forest</span> () <span class="ot">-&gt;</span> <span class="dt">Dyck</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true"></a>forestToDyck t <span class="ot">=</span> go t <span class="dt">Done</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true"></a><span class="ot">    go ::</span> <span class="dt">Forest</span> () <span class="ot">-&gt;</span> <span class="dt">DyckSuff</span> n <span class="ot">-&gt;</span> <span class="dt">DyckSuff</span> n</span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true"></a>    go []          <span class="ot">=</span> <span class="fu">id</span></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true"></a>    go ((() <span class="op">:&amp;</span> x)<span class="op">:</span>xs) <span class="ot">=</span> go x <span class="op">.</span> <span class="dt">Open</span> <span class="op">.</span> go xs <span class="op">.</span> <span class="dt">Clos</span></span></code></pre></div>
<p>And again, following relatively mechanical derivations, we arrive at an elegant algorithm:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a><span class="ot">enumForests ::</span> [a] <span class="ot">-&gt;</span> [<span class="dt">Forest</span> a]</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a>enumForests <span class="ot">=</span> foldrM f []</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true"></a>    f x xs <span class="ot">=</span> <span class="fu">zipWith</span> ((<span class="op">:</span>) <span class="op">.</span> (<span class="op">:&amp;</span>) x) (inits xs) (tails xs)</span></code></pre></div>
<h1 id="related-work">Related Work</h1>
<p>While researching this post I found that enumeration of trees has been studied <em>extensively</em> elsewhere: see <span class="citation" data-cites="knuth_art_2006">Knuth (<a href="#ref-knuth_art_2006" role="doc-biblioref">2006</a>)</span>, for example, or the excellent blog post by <span class="citation" data-cites="tychonievich_enumerating_2013">Tychonievich (<a href="#ref-tychonievich_enumerating_2013" role="doc-biblioref">2013</a>)</span>, or the entire field of <a href="https://en.wikipedia.org/wiki/Boltzmann_sampler">Boltzmann sampling</a>. This post has only scratched the surface of all of that: I hope to write much more on the topic in the future.</p>
<h1 id="code">Code</h1>
<p>As I mentioned, the Agda code for this stuff can be found <a href="https://github.com/oisdk/agda-playground/blob/d7234c276f063dbb4a2d2cbcedb86dd48501a908/Data/Dyck/Payload.agda">here</a>, I have also put all of the Haskell code in one place <a href="https://gist.github.com/oisdk/438b6e790481c908d9460ffb1196a759">here</a>.</p>
<h1 class="unnumbered" id="references">References</h1>
<div id="refs" class="references hanging-indent" role="doc-bibliography">
<div id="ref-bahr_calculating_2015">
<p>Bahr, Patrick, and Graham Hutton. 2015. “Calculating Correct Compilers.” <em>Journal of Functional Programming</em> 25 (e14) (September). doi:<a href="https://doi.org/10.1017/S0956796815000180">10.1017/S0956796815000180</a>. <a href="https://nottingham-repository.worktribe.com/output/761112">https://nottingham-repository.worktribe.com/output/761112</a>.</p>
</div>
<div id="ref-hutton_countdown_2002">
<p>Hutton, Graham. 2002. “The Countdown Problem.” <em>J. Funct. Program.</em> 12 (6) (November): 609–616. doi:<a href="https://doi.org/10.1017/S0956796801004300">10.1017/S0956796801004300</a>. <a href="http://www.cs.nott.ac.uk/~pszgmh/countdown.pdf">http://www.cs.nott.ac.uk/~pszgmh/countdown.pdf</a>.</p>
</div>
<div id="ref-knuth_art_2006">
<p>Knuth, Donald E. 2006. <em>The Art of Computer Programming, Volume 4, Fascicle 4: Generating All Trees–History of Combinatorial Generation (Art of Computer Programming)</em>. Addison-Wesley Professional. <a href="http://www.cs.utsa.edu/~wagner/knuth/fasc4a.pdf">http://www.cs.utsa.edu/~wagner/knuth/fasc4a.pdf</a>.</p>
</div>
<div id="ref-mcgill_compiler_2020">
<p>McGill, Callan. 2020. “Compiler Correctness for Addition Language.” <a href="https://gist.github.com/Boarders/9d83f9cbcfaffb04cf2464588fc46df9">https://gist.github.com/Boarders/9d83f9cbcfaffb04cf2464588fc46df9</a>.</p>
</div>
<div id="ref-riley_program_2020">
<p>Riley, Sean. 2020. “Program Correctness - Computerphile.” University of Nottingham. <a href="https://www.youtube.com/watch?v=T_IINWzQhow">https://www.youtube.com/watch?v=T_IINWzQhow</a>.</p>
</div>
<div id="ref-tychonievich_enumerating_2013">
<p>Tychonievich, Luther. 2013. “Enumerating Trees.” <em>Luther’s Meanderings</em>. <a href="https://www.cs.virginia.edu/~lat7h/blog/posts/434.html">https://www.cs.virginia.edu/~lat7h/blog/posts/434.html</a>.</p>
</div>
</div>

        </div>
    </body>
</html>
