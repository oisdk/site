<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>A Binomial Urn - Donnacha Ois√≠n Kidney</title>
        <style>body{color:black;font-family:Garamond,Times New Roman,serif;font-size:15px;margin:0px auto 0px auto;padding-left:5px;padding-right:5px;max-width:650px}math{font-size:13px}img{max-width:600px}summary{outline:0}div#header{border-bottom:3px double black;margin-bottom:30px;padding:12px 0px 12px 0px}div#logo a{color:black;float:left;font-size:20px;text-decoration:none}div#header #navigation{text-align:right}div#header #navigation a{color:black;font-family:Garamond,Times New Roman,Serif;font-size:18px;margin-left:10px;text-decoration:none;text-transform:uppercase}div#footer{font-family:Garamond,Times New Roman,Serif;border-top:solid 2px black;color:#555;font-size:12px;margin-top:30px;padding:12px 0px 12px 0px;text-align:right}h1{font-family:Garamond,Times New Roman,Serif;font-size:22px;font-weight:normal}h2{font-family:Garamond,Times New Roman,Serif;font-size:20px;font-weight:normal}div.info{color:#555;font-size:15px;font-style:italic}span.quiet{color:#828282;font-style:italic}a{color:black;word-wrap:break-word}ul.post-list{margin-left:0px;padding-left:0px;list-style-type:none}.hidden_source{display:none}ol.serieslist{counter-reset:item;list-style-type:none;padding-left:20}ol li.serieslist:before{content:'Part ' counter(item,decimal) ':';counter-increment:item}table.sourceCode,tr.sourceCode,td.lineNumbers,td.sourceCode,table.sourceCode pre{margin:0;padding:0;border:0;vertical-align:baseline;border:none}td.lineNumbers{border-right:1px solid #AAAAAA;text-align:right;color:#AAAAAA;padding-right:5px;padding-left:5px}td.sourceCode{padding-left:5px}.sourceCode,code,pre,.Agda{font-size:10px;font-family:menlo,monospace}.sourceCode span.kw{color:#262C6A}.sourceCode span.dt{color:#476A97}.sourceCode span.dv{color:#262C6A}.sourceCode span.bn{color:#262C6A}.sourceCode span.fl{color:#262C6A}.sourceCode span.ch{color:#262C6A}.sourceCode span.st{color:#702C51}.sourceCode span.co{color:#435138}.sourceCode span.ot{color:#262C6A}.sourceCode span.al{color:red}.sourceCode span.fu{color:#000000}.sourceCode span.re{color:#000000}.sourceCode span.er{color:red}li{margin-bottom:2px}li:last-child{margin-bottom:0px}.Agda .Comment{color:#B22222}.Agda .Background{}.Agda .Markup{color:#000000}.Agda .Keyword{color:#CD6600}.Agda .String{color:#B22222}.Agda .Number{color:#A020F0}.Agda .Symbol{color:#404040}.Agda .PrimitiveType{color:#0000CD}.Agda .Pragma{color:black}.Agda .Operator{}.Agda .Bound{color:black}.Agda .Generalizable{color:black}.Agda .InductiveConstructor{color:#008B00}.Agda .CoinductiveConstructor{color:#8B7500}.Agda .Datatype{color:#0000CD}.Agda .Field{color:#EE1289}.Agda .Function{color:#0000CD}.Agda .Module{color:#A020F0}.Agda .Postulate{color:#0000CD}.Agda .Primitive{color:#0000CD}.Agda .Record{color:#0000CD}.Agda .DottedPattern{}.Agda .UnsolvedMeta{color:black;background:yellow}.Agda .UnsolvedConstraint{color:black;background:yellow}.Agda .TerminationProblem{color:black;background:#FFA07A}.Agda .IncompletePattern{color:black;background:#F5DEB3}.Agda .Error{color:red;text-decoration:underline}.Agda .TypeChecks{color:black;background:#ADD8E6}.Agda a{text-decoration:none}.Agda a[href]:hover{background-color:#B4EEB4}.sourceCode{overflow-x:auto}</style>
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Donnacha Ois√≠n Kidney</a>
            </div>
            <div id="navigation">
                <a href="../publications.html">Publications</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../rss.xml">Feed</a>
            </div>
        </div>

        <div id="content">
            <h2>A Binomial Urn</h2>

            <div class="info">
    Posted on January 15, 2019
</div>
<div class="info">
    
        Part 3 of a <a href="../series/Balanced%20Folds.html">3-part series on Balanced Folds</a>
    
</div>
<div class="info">
    
        Tags: <a title="All pages tagged 'Haskell'." href="../tags/Haskell.html" rel="tag">Haskell</a>
    
</div>

<p>When we started the series, we wanted to find a ‚Äúbetter‚Äù fold: one
that was more balanced than either <code>foldl</code> or
<code>foldr</code> (in its placement of parentheses). Both of these are
about as unbalanced as you can get:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="fu">foldr</span> (<span class="op">+</span>) <span class="dv">0</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> <span class="op">+</span> (<span class="dv">2</span> <span class="op">+</span> (<span class="dv">3</span> <span class="op">+</span> <span class="dv">0</span>))</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="fu">foldl</span> (<span class="op">+</span>) <span class="dv">0</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>((<span class="dv">0</span> <span class="op">+</span> <span class="dv">1</span>) <span class="op">+</span> <span class="dv">2</span>) <span class="op">+</span> <span class="dv">3</span></span></code></pre></div>
<p>The first better fold I found was Jon Fairbairn‚Äôs simple
<code>treeFold</code>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">treeFold ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> a</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>treeFold f <span class="ot">=</span> go</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    go x [] <span class="ot">=</span> x</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    go a  (b<span class="op">:</span>l) <span class="ot">=</span> go (f a b) (pairMap l)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    pairMap (x<span class="op">:</span>y<span class="op">:</span>rest) <span class="ot">=</span> f x y <span class="op">:</span> pairMap rest</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    pairMap xs <span class="ot">=</span> xs</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> treeFold (<span class="op">+</span>) <span class="dv">0</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>(<span class="dv">0</span> <span class="op">+</span> <span class="dv">1</span>) <span class="op">+</span> (<span class="dv">2</span> <span class="op">+</span> <span class="dv">3</span>)</span></code></pre></div>
<p>Already this function was kind of magical: if your binary operator
merges two sorted lists, <code>foldr</code> will give you insertion
sort, whereas <code>treeFold</code> will give you merge sort; for
summing floats, <code>treeFold</code> has a lower error growth than
<code>sum</code>. By dividing up the work better, we were able to
improve the characteristics of many algorithms automatically. We also
saw that it could easily be made parallel:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">parseq ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>parseq a b <span class="ot">=</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    runST</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>        (bool (par a b) (<span class="fu">seq</span> a b) <span class="op">&lt;$&gt;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>         unsafeIOToST (liftA2 (<span class="op">&gt;</span>) numSparks getNumCapabilities))</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="ot">treeFoldParallel ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> a</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>treeFoldParallel f <span class="ot">=</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    treeFold</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>        (\l r <span class="ot">-&gt;</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>              r <span class="ot">`parseq`</span> (l <span class="ot">`parseq`</span> f l r))</span></code></pre></div>
<p>In the next post, we saw how we could make the fold incremental, by
using binary number representations for data structures. This let us do
2 things: it meant the fold was structurally terminating, so it would
pass the termination checker (efficiently) in languages like Agda or
Idris, and it meant we could write <code>scanl</code> using the fold.
The <code>scanl</code> was also efficient: you could run the fold at any
point in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ùí™</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math>
time, and work would be shared between subsequent runs. Effectively,
this let us use it to solve greedy optimization problems. We also saw
how it was effectively constructing an implicit binomial priority queue
under the hood, and how it exploited laziness to get sharing.</p>
<p>I‚Äôve gotten huge mileage out of this fold and the general ideas about
it, and today I‚Äôm going to show one more use of it. We‚Äôre going to
improve some of the asymptotics of the data structure presented in <span class="citation" data-cites="lampropoulos_ode_2017">Lampropoulos,
Spector-Zabusky, and Foner (2017)</span>.</p>
<h1 id="a-random-urn">A Random Urn</h1>
<p>The paper opens with the problem:</p>
<blockquote>
<p>Suppose you have an urn containing two red balls, four green balls,
and three blue balls. If you take three balls out of the urn, what is
the probability that two of them are green?</p>
</blockquote>
<p>If you were to take just <em>one</em> ball out of the earn,
calculating the associated probabilities would be easy. Once you get to
the second, though, you have to update the previous probability
<em>based on what ball was removed</em>. In other words, we need to be
able to dynamically update the distribution.</p>
<p>Using lists, this would obviously become an
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ùí™</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathcal{O}(n)</annotation></semantics></math>
operation. In the paper, an almost-perfect binary tree is used. This
turns the operation into one that‚Äôs
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ùí™</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math>.
The rest of the operations have the following complexities:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Operation</th>
<th>Complexity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>insert</code></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ùí™</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>remove</code></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ùí™</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>fromList</code></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ùí™</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathcal{O}(n)</annotation></semantics></math></td>
</tr>
</tbody>
</table>
<p>As a quick spoiler, the improved version presented here has these
complexities:</p>
<table>
<thead>
<tr class="header">
<th>Operation</th>
<th>Complexity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>insert</code></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ùí™</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math></td>
</tr>
<tr class="even">
<td><code>remove</code></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ùí™</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math></td>
</tr>
<tr class="odd">
<td><code>merge</code></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ùí™</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math></td>
</tr>
<tr class="even">
<td><code>fromList</code></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ùí™</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathcal{O}(n)</annotation></semantics></math></td>
</tr>
</tbody>
</table>
<p>We add another operation (<code>merge</code>), which means that the
new structure is viable as an instance of <code>Alternative</code>,
<code>Monad</code>, and so on, making it an efficient monad for weighted
backtracking search.</p>
<h1 id="priority-queues">Priority Queues</h1>
<p>The key thing to notice in the paper which will let us improve the
structure is that what they‚Äôre designing is actually a <em>priority
queue</em>. Well, a weird looking priority queue, but a priority queue
nonetheless.</p>
<p>Think about it like a max-priority queue (pop returns the largest
element first), with a degree of ‚Äúrandomization‚Äù. In other words, when
you go to do a pop, all of the comparisons between the ordering keys
(the weights in this case) sprinkles some randomness into the equation,
meaning that instead of <code>1 &lt; 2</code> returning
<code>True</code>, it returns <code>True</code>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mn>2</mn><mn>3</mn></mfrac><annotation encoding="application/x-tex">\frac{2}{3}</annotation></semantics></math>
of the time, and <code>False</code> the other
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mn>1</mn><mn>3</mn></mfrac><annotation encoding="application/x-tex">\frac{1}{3}</annotation></semantics></math>.</p>
<p>This way of doing things means that not every priority queue is
suitable: we want to run comparisons at <code>pop</code> time (not
<code>insert</code>), so a binary heap (for instance) won‚Äôt do. At
branches (non-leaves), the queue will only be allowed store
<em>summaries</em> of the data, not the ‚Äúmax element‚Äù.</p>
<p>The one presented in the paper is something like a Braun priority
queue: the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ùí™</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathcal{O}(n)</annotation></semantics></math>
<code>fromList</code> implementation is reminiscent of the one in <span class="citation" data-cites="okasaki_three_1997">Okasaki
(1997)</span>.</p>
<p>So what priority queue can we choose to get us the desired
efficiency? Why, a binomial one of course!</p>
<h1 id="the-data-structure">The Data Structure</h1>
<p>The urn structure itself looks a lot like a binomial heap:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Tree</span> a</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Tree</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> weight ::</span> <span class="ot">{-# UNPACK #-}</span> <span class="op">!</span><span class="dt">Word</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> branch ::</span> <span class="dt">Node</span> a</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Node</span> a</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Leaf</span> a</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Branch</span> (<span class="dt">Tree</span> a) (<span class="dt">Node</span> a)</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Heap</span> a</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Nil</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Cons</span> <span class="ot">{-# UNPACK #-}</span> <span class="op">!</span><span class="dt">Word</span> (<span class="dt">Tree</span> a) (<span class="dt">Heap</span> a)</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Urn</span> a <span class="ot">=</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Urn</span> <span class="ot">{-# UNPACK #-}</span> <span class="op">!</span><span class="dt">Word</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">!</span>(<span class="dt">Heap</span> a)</span></code></pre></div>
<p>By avoiding the usual <code>Skip</code> constructors you often see in
a binomial heap we save a huge amount of space. Instead, we store the
‚Äúnumber of zeroes before this bit‚Äù. Another thing to point out is that
only left branches in the trees store their weight: the same
optimization is made in the paper.</p>
<p>Insertion is not much different from insertion for a usual binomial
priority queue, although we don‚Äôt need to do anything to merge the
trees:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">insertHeap ::</span> <span class="dt">Word</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Heap</span> a <span class="ot">-&gt;</span> <span class="dt">Heap</span> a</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>insertHeap i' x' <span class="ot">=</span> go <span class="dv">0</span> (<span class="dt">Tree</span> i' (<span class="dt">Leaf</span> x'))</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    go <span class="op">!</span>i x <span class="dt">Nil</span> <span class="ot">=</span> <span class="dt">Cons</span> i x <span class="dt">Nil</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    go <span class="op">!</span>i x (<span class="dt">Cons</span> <span class="dv">0</span> y ys) <span class="ot">=</span> go (i<span class="op">+</span><span class="dv">1</span>) (mergeTree x y) ys</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    go <span class="op">!</span>i x (<span class="dt">Cons</span> j y ys) <span class="ot">=</span> <span class="dt">Cons</span> i x (<span class="dt">Cons</span> (j<span class="op">-</span><span class="dv">1</span>) y ys)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="ot">mergeTree ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>mergeTree xs ys <span class="ot">=</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Tree</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    (weight xs <span class="op">+</span> weight ys)</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">Branch</span> xs (branch ys))</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a><span class="ot">insert ::</span> <span class="dt">Word</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Urn</span> a <span class="ot">-&gt;</span> <span class="dt">Urn</span> a</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>insert i x (<span class="dt">Urn</span> w xs) <span class="ot">=</span> <span class="dt">Urn</span> (w<span class="op">+</span>i) (insertHeap i x xs)</span></code></pre></div>
<p>We <em>could</em> potentially get insertion from amortized
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ùí™</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math>
to worst-case
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ùí™</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math>
by using skew binary instead of binary (in fact I am almost sure it‚Äôs
possible), but then I think we‚Äôd lose the efficient merge. I‚Äôll leave
exploring that for another day.</p>
<p>To get randomness, we‚Äôll write a very simple class that encapsulates
only what we need:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Sample</span> m <span class="kw">where</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- | Inclusive range</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    inRange ::</span> <span class="dt">Word</span> <span class="ot">-&gt;</span> <span class="dt">Word</span> <span class="ot">-&gt;</span> m <span class="dt">Word</span></span></code></pre></div>
<p>You can later instantiate this to whatever random monad you end up
using. (The same approach was taken in the paper, although we only
require <code>Functor</code> here, not <code>Monad</code>).</p>
<p>Sampling (with replacement) first randomly chooses a tree from the
top-level list, and then we drill down into that tree with binary
search.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">sample ::</span> (<span class="dt">Functor</span> m, <span class="dt">Sample</span> m) <span class="ot">=&gt;</span> <span class="dt">Urn</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (m a)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>sample (<span class="dt">Urn</span> _ <span class="dt">Nil</span>) <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>sample (<span class="dt">Urn</span> w' (<span class="dt">Cons</span> _ x' xs')) <span class="ot">=</span> <span class="dt">Just</span> (<span class="fu">fmap</span> (go x' xs') (<span class="fu">inRange</span> <span class="dv">0</span> (w' <span class="op">-</span> <span class="dv">1</span>)))</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    go x <span class="dt">Nil</span> <span class="op">!</span>w <span class="ot">=</span> go' w (branch x)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    go x (<span class="dt">Cons</span> _ y ys) <span class="op">!</span>w</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>      <span class="op">|</span> w <span class="op">&lt;</span> weight x <span class="ot">=</span> go' w (branch x)</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>      <span class="op">|</span> <span class="fu">otherwise</span>    <span class="ot">=</span> go y ys (w <span class="op">-</span> weight x)</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    go' <span class="op">!</span>_ (<span class="dt">Leaf</span> x) <span class="ot">=</span> x</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    go' <span class="op">!</span>i (<span class="dt">Branch</span> xs ys)</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>      <span class="op">|</span> i <span class="op">&lt;</span> weight xs <span class="ot">=</span> go' i (branch xs)</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>      <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> go' (i <span class="op">-</span> weight xs) ys</span></code></pre></div>
<p>So we‚Äôre off to a good start, but <code>remove</code> is a complex
operation. We take the same route taken in the paper: first, we perform
an ‚Äúuncons‚Äù-like operation, which pops out the last inserted element.
Then, we randomly choose a point in the tree (using the same logic as in
<code>sample</code>), and replace it with the popped element<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">remove ::</span> (<span class="dt">Functor</span> m, <span class="dt">Sample</span> m) <span class="ot">=&gt;</span> <span class="dt">Urn</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (m ((a, <span class="dt">Word</span>), <span class="dt">Urn</span> a))</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>remove (<span class="dt">Urn</span> w hp) <span class="ot">=</span> <span class="fu">fmap</span> go' (Heap.uninsert hp)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    go' (vw,v,hp') <span class="ot">=</span> <span class="fu">fmap</span> (<span class="ot">`go`</span> hp') (<span class="fu">inRange</span> <span class="dv">0</span> (w<span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>      <span class="kw">where</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>        go <span class="op">!</span>_  <span class="dt">Nil</span> <span class="ot">=</span> ((v, vw), <span class="dt">Urn</span> <span class="dv">0</span> <span class="dt">Nil</span>)</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>        go <span class="op">!</span>rw vs<span class="op">@</span>(<span class="dt">Cons</span> i' x' xs')</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> rw <span class="op">&lt;</span> vw <span class="ot">=</span> ((v, vw), <span class="dt">Urn</span> (w <span class="op">-</span> vw) vs)</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> replace (rw <span class="op">-</span> vw) i' x' xs'</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>            (\ys yw y <span class="ot">-&gt;</span> ((y, yw), <span class="dt">Urn</span> (w <span class="op">-</span> yw) ys))</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>        replace <span class="op">!</span>rw i x <span class="dt">Nil</span> k <span class="ot">=</span> replaceTree rw x (\t <span class="ot">-&gt;</span> k (<span class="dt">Cons</span> i t <span class="dt">Nil</span>))</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>        replace <span class="op">!</span>rw i x xs<span class="op">@</span>(<span class="dt">Cons</span> j y ys) k</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> rw <span class="op">&lt;</span> weight x <span class="ot">=</span> replaceTree rw x (\t <span class="ot">-&gt;</span> k (<span class="dt">Cons</span> i t xs))</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> replace (rw <span class="op">-</span> weight x) j y ys (k <span class="op">.</span> <span class="dt">Cons</span> i x)</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>        replaceTree <span class="op">!</span>_  (<span class="dt">Tree</span> tw (<span class="dt">Leaf</span> x)) k <span class="ot">=</span> k (<span class="dt">Tree</span> vw (<span class="dt">Leaf</span> v)) tw x</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>        replaceTree <span class="op">!</span>rw (<span class="dt">Tree</span> tw (<span class="dt">Branch</span> xs ys)) k</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> rw <span class="op">&lt;</span> weight xs <span class="ot">=</span> replaceTree rw xs</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>            (\t <span class="ot">-&gt;</span> k (<span class="dt">Tree</span> (tw <span class="op">+</span> (weight t <span class="op">-</span> weight xs)) (<span class="dt">Branch</span> t ys)))</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> replaceTree (rw <span class="op">-</span> weight xs)</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>            (<span class="dt">Tree</span> (tw <span class="op">-</span> weight xs) ys)</span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>            (\t <span class="ot">-&gt;</span> k (<span class="dt">Tree</span> (weight xs <span class="op">+</span> weight t) (<span class="dt">Branch</span> xs (branch t))))</span></code></pre></div>
<p>Merge is the same as on binomial heaps:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mergeHeap ::</span> <span class="dt">Heap</span> a <span class="ot">-&gt;</span> <span class="dt">Heap</span> a <span class="ot">-&gt;</span> <span class="dt">Heap</span> a</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>mergeHeap <span class="dt">Nil</span> <span class="ot">=</span> <span class="fu">id</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>mergeHeap (<span class="dt">Cons</span> i' x' xs') <span class="ot">=</span> merger i' x' xs'</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    merger <span class="op">!</span>i x xs <span class="dt">Nil</span> <span class="ot">=</span> <span class="dt">Cons</span> i x xs</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    merger <span class="op">!</span>i x xs (<span class="dt">Cons</span> j y ys) <span class="ot">=</span> merge' i x xs j y ys</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    merge' <span class="op">!</span>i x xs <span class="op">!</span>j y ys <span class="ot">=</span> <span class="kw">case</span> <span class="fu">compare</span> i j <span class="kw">of</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>        <span class="dt">LT</span> <span class="ot">-&gt;</span> <span class="dt">Cons</span> i x (merger (j<span class="op">-</span>i<span class="op">-</span><span class="dv">1</span>) y ys xs)</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>        <span class="dt">GT</span> <span class="ot">-&gt;</span> <span class="dt">Cons</span> j y (merger (i<span class="op">-</span>j<span class="op">-</span><span class="dv">1</span>) x xs ys)</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>        <span class="dt">EQ</span> <span class="ot">-&gt;</span> mergec (<span class="fu">succ</span> i) (mergeTree x y) xs ys</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    mergec <span class="op">!</span>p <span class="op">!</span>t <span class="dt">Nil</span> <span class="ot">=</span> carryLonger p t</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>    mergec <span class="op">!</span>p <span class="op">!</span>t (<span class="dt">Cons</span> i x xs) <span class="ot">=</span> mergecr p t i x xs</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>    mergecr <span class="op">!</span>p <span class="op">!</span>t <span class="op">!</span>i x xs <span class="dt">Nil</span> <span class="ot">=</span> carryLonger' p t i x xs</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>    mergecr <span class="op">!</span>p <span class="op">!</span>t <span class="op">!</span>i x xs (<span class="dt">Cons</span> j y ys) <span class="ot">=</span> mergec' p t i x xs j y ys</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>    mergec' <span class="op">!</span>p t <span class="op">!</span>i x xs <span class="op">!</span>j y ys <span class="ot">=</span> <span class="kw">case</span> <span class="fu">compare</span> i j <span class="kw">of</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>      <span class="dt">LT</span> <span class="ot">-&gt;</span> mergecr'' p t i x xs (j<span class="op">-</span>i<span class="op">-</span><span class="dv">1</span>) y ys</span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>      <span class="dt">GT</span> <span class="ot">-&gt;</span> mergecr'' p t j y ys (i<span class="op">-</span>j<span class="op">-</span><span class="dv">1</span>) x xs</span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>      <span class="dt">EQ</span> <span class="ot">-&gt;</span> <span class="dt">Cons</span> p t (mergec i (mergeTree x y) xs ys)</span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>    mergecr'' <span class="op">!</span>p <span class="op">!</span>t  <span class="dv">0</span> x xs <span class="op">!</span>j y ys <span class="ot">=</span> mergecr (p<span class="op">+</span><span class="dv">1</span>) (mergeTree t x) j y ys xs</span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>    mergecr'' <span class="op">!</span>p <span class="op">!</span>t <span class="op">!</span>i x xs <span class="op">!</span>j y ys <span class="ot">=</span> <span class="dt">Cons</span> p t (<span class="dt">Cons</span> (i<span class="op">-</span><span class="dv">1</span>) x (merger j y ys xs))</span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a>    carryLonger <span class="op">!</span>i <span class="op">!</span>t <span class="dt">Nil</span> <span class="ot">=</span> <span class="dt">Cons</span> i t <span class="dt">Nil</span></span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a>    carryLonger <span class="op">!</span>i <span class="op">!</span>t (<span class="dt">Cons</span> j y ys) <span class="ot">=</span> carryLonger' i t j y ys</span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a>    carryLonger' <span class="op">!</span>i <span class="op">!</span>t  <span class="dv">0</span> y ys <span class="ot">=</span> carryLonger (<span class="fu">succ</span> i) (mergeTree t y) ys</span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a>    carryLonger' <span class="op">!</span>i <span class="op">!</span>t <span class="op">!</span>j y ys <span class="ot">=</span> <span class="dt">Cons</span> i t (<span class="dt">Cons</span> (j<span class="op">-</span><span class="dv">1</span>) y ys)</span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true" tabindex="-1"></a><span class="ot">merge ::</span> <span class="dt">Urn</span> a <span class="ot">-&gt;</span> <span class="dt">Urn</span> a <span class="ot">-&gt;</span> <span class="dt">Urn</span> a</span>
<span id="cb9-34"><a href="#cb9-34" aria-hidden="true" tabindex="-1"></a>merge (<span class="dt">Urn</span> i xs) (<span class="dt">Urn</span> j ys) <span class="ot">=</span> <span class="dt">Urn</span> (i<span class="op">+</span>j) (mergeHeap xs ys)   </span></code></pre></div>
<h1 id="finger-trees">Finger Trees</h1>
<p>Again, the cleverness of all the tree folds is that they
intelligently batch summarizing operations, allowing you to efficiently
so prefix-scan-like operations that exploit sharing.</p>
<p>The bare-bones version just uses binary numbers: you can upgrade the
<code>cons</code> operation to worst-case constant-time if you use
<em>skew</em> binary. Are there other optimizations? Yes! What if we
wanted to stick something on to the <em>other</em> end, for instance?
What if we wanted to reverse?</p>
<p>If you figure out a way to do <em>all</em> these optimizations, and
put them into one big data structure, you get the mother-of-all
‚Äúbatching‚Äù data structures: the finger tree. This is the basis for
Haskell‚Äôs Data.Sequence, but it can also implement priority queues, urns
(I‚Äôd imagine), fenwick-tree-like structures, and more.</p>
<h1 id="uses-and-further-work">Uses and Further Work</h1>
<p>First and foremost, I should test the above implementations! I‚Äôm
pretty confident the asymptotics are correct, but I‚Äôm certain the
implementations have bugs.</p>
<p>The efficient <code>merge</code> is intriguing: it means that
<code>Urn</code> could conceivably be <code>Alternative</code>,
<code>MonadPlus</code>, etc. I have yet to see a use for that, but it‚Äôs
interesting nonetheless! I‚Äôm constantly looking for a way to express
something like Dijkstra‚Äôs algorithm algebraicly, using the usual
<code>Alternative</code> combinators; I don‚Äôt know if this is
related.</p>
<p>The other interesting point is that, for this to be an instance of
<code>Applicative</code>, it would need some analogue for multiplication
for the weights. I‚Äôm not sure what that should be.</p>
<p>This is inherently <em>max</em>-priority. It‚Äôs not obvious how to
translate what we have into a min-priority queue version.</p>
<p>Finally, it might be worth trying out different priority queues (a
pairing heap is very similar in structure to this). Also, we could
rearrange the weights so that larger ones are higher in each tree: this
might give a performance boost.</p>
<div id="refs" class="references csl-bib-body hanging-indent" role="list">
<div id="ref-lampropoulos_ode_2017" class="csl-entry" role="listitem">
Lampropoulos, Leonidas, Antal Spector-Zabusky, and Kenneth Foner. 2017.
<span>‚ÄúOde on a random urn (functional pearl).‚Äù</span> In, 26‚Äì37.
<span>ACM Press</span>. doi:<a href="https://doi.org/10.1145/3122955.3122959">10.1145/3122955.3122959</a>.
</div>
<div id="ref-okasaki_three_1997" class="csl-entry" role="listitem">
Okasaki, Chris. 1997. <span>‚ÄúThree <span>Algorithms</span> on
<span>Braun Trees</span>.‚Äù</span> <em>Journal of Functional
Programming</em> 7 (6) (November): 661‚Äì666. doi:<a href="https://doi.org/10.1017/S0956796897002876">10.1017/S0956796897002876</a>.
</div>
</div>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>There‚Äôs one extra step I haven‚Äôt mentioned: we also must
allow the first element (the last inserted) to be chosen, so we run the
random-number generator once to check if that‚Äôs the element we want to
choose.<a href="#fnref1" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
</ol>
</section>

        </div>
    </body>
</html>
