<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>A Very Simple Prime Sieve in Haskell - Donnacha Oisín Kidney</title>
        <style>body{color:black;font-family:Garamond,Times New Roman,serif;font-size:14px;margin:0px auto 0px auto;padding-left:5px;padding-right:5px;max-width:600px}math{font-size:13px}img{max-width:600px}div#header{border-bottom:3px double black;margin-bottom:30px;padding:12px 0px 12px 0px}div#logo a{color:black;float:left;font-size:20px;text-decoration:none}div#header #navigation{text-align:right}div#header #navigation a{color:black;font-family:Garamond,Times New Roman,Serif;font-size:18px;margin-left:10px;text-decoration:none;text-transform:uppercase}div#footer{font-family:Garamond,Times New Roman,Serif;border-top:solid 2px black;color:#555;font-size:12px;margin-top:30px;padding:12px 0px 12px 0px;text-align:right}h1{font-family:Garamond,Times New Roman,Serif;font-size:22px;font-weight:normal}h2{font-family:Garamond,Times New Roman,Serif;font-size:20px;font-weight:normal}div.info{color:#555;font-size:15px;font-style:italic}span.quiet{color:#828282;font-style:italic}a{color:black;word-wrap:break-word}ul.post-list{margin-left:0px;padding-left:0px;list-style-type:none}.hidden_source{display:none}ol.serieslist{counter-reset:item;list-style-type:none;padding-left:20}ol li.serieslist:before{content:'Part ' counter(item,decimal) ':';counter-increment:item}table.sourceCode,tr.sourceCode,td.lineNumbers,td.sourceCode,table.sourceCode pre{margin:0;padding:0;border:0;vertical-align:baseline;border:none}td.lineNumbers{border-right:1px solid #AAAAAA;text-align:right;color:#AAAAAA;padding-right:5px;padding-left:5px}td.sourceCode{padding-left:5px}.sourceCode,code,.Agda{font-size:10px;font-family:menlo,monospace}.sourceCode span.kw{color:#262C6A}.sourceCode span.dt{color:#476A97}.sourceCode span.dv{color:#262C6A}.sourceCode span.bn{color:#262C6A}.sourceCode span.fl{color:#262C6A}.sourceCode span.ch{color:#262C6A}.sourceCode span.st{color:#702C51}.sourceCode span.co{color:#435138}.sourceCode span.ot{color:#262C6A}.sourceCode span.al{color:red}.sourceCode span.fu{color:#000000}.sourceCode span.re{color:#000000}.sourceCode span.er{color:red}li{margin-bottom:2px}li:last-child{margin-bottom:0px}.Agda .Comment{color:#B22222}.Agda .Background{}.Agda .Markup{color:#000000}.Agda .Keyword{color:#CD6600}.Agda .String{color:#B22222}.Agda .Number{color:#A020F0}.Agda .Symbol{color:#404040}.Agda .PrimitiveType{color:#0000CD}.Agda .Pragma{color:black}.Agda .Operator{}.Agda .Bound{color:black}.Agda .Generalizable{color:black}.Agda .InductiveConstructor{color:#008B00}.Agda .CoinductiveConstructor{color:#8B7500}.Agda .Datatype{color:#0000CD}.Agda .Field{color:#EE1289}.Agda .Function{color:#0000CD}.Agda .Module{color:#A020F0}.Agda .Postulate{color:#0000CD}.Agda .Primitive{color:#0000CD}.Agda .Record{color:#0000CD}.Agda .DottedPattern{}.Agda .UnsolvedMeta{color:black;background:yellow}.Agda .UnsolvedConstraint{color:black;background:yellow}.Agda .TerminationProblem{color:black;background:#FFA07A}.Agda .IncompletePattern{color:black;background:#F5DEB3}.Agda .Error{color:red;text-decoration:underline}.Agda .TypeChecks{color:black;background:#ADD8E6}.Agda a{text-decoration:none}.Agda a[href]:hover{background-color:#B4EEB4}.sourceCode{overflow-x:auto}</style>
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Donnacha Oisín Kidney</a>
            </div>
            <div id="navigation">
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../rss.xml">Feed</a>
            </div>
        </div>

        <div id="content">
            <h2>A Very Simple Prime Sieve in Haskell</h2>

            <div class="info">
    Posted on November 10, 2018
</div>
<div class="info">
    
        Part 1 of a <a href="../series/Prime%20Sieves.html">2-part series on Prime Sieves</a>
    
</div>
<div class="info">
    
        Tags: <a href="../tags/Haskell.html">Haskell</a>
    
</div>

<p>A few days ago, the <a href="https://www.youtube.com/user/Computerphile">Computerphile YouTube channel</a> put up a video about infinite lists in Haskell <span class="citation" data-cites="haran_infinity_2018">(Haran <a href="#ref-haran_infinity_2018">2018</a>)</span>. It’s pretty basic, but finishes up with a definition of an infinite list of prime numbers. The definition was something like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1">primes <span class="fu">=</span> sieve [<span class="dv">2</span><span class="fu">..</span>]</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">sieve (p<span class="fu">:</span>ps) <span class="fu">=</span> p <span class="fu">:</span> sieve [ x <span class="fu">|</span> x <span class="ot">&lt;-</span> ps, mod x p <span class="fu">/=</span> <span class="dv">0</span> ]</a></code></pre></div>
<p>This really demonstrates the elegance of list comprehensions coupled with lazy evaluation. If we’re being totally pedantic, however, this <em>isn’t</em> a genuine <a href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes">sieve of Eratosthenes</a>. And this makes sense: the “true” sieve of Eratosthenes <span class="citation" data-cites="oneill_genuine_2009">(O’Neill <a href="#ref-oneill_genuine_2009">2009</a>)</span> is probably too complex to demonstrate in a video meant to be an introduction to Haskell. This isn’t because Haskell is bad at this particular problem, mind you: it’s because a lazy, infinite sieve is something very hard to implement indeed.</p>
<p>Anyway, I’m going to try today to show a very simple prime sieve that (hopefully) rivals the simplicity of the definition above.</p>
<h1 id="a-first-attempt">A First Attempt</h1>
<p>Visualizations of the sieve of Eratosthenes often rely on metaphors of “crossing out” on some large table. Once you hit a prime, you cross off all of its multiples in the rest of the table, and then you move to the next crossed-off number.</p>
<figure>
<img src="https://upload.wikimedia.org/wikipedia/commons/0/0b/Sieve_of_Eratosthenes_animation.svg" alt="Sieve of Eratosthenes Animation. By Ricordisamoa, CC BY-SA 3.0, from Wikimedia Commons" /><figcaption>Sieve of Eratosthenes Animation. By Ricordisamoa, CC BY-SA 3.0, from Wikimedia Commons</figcaption>
</figure>
<p>Working with a finite array, it should be easy to see that this is extremely efficient. You’re crossing off every non-prime exactly once, only using addition and squaring.</p>
<p>To extend it to infinite lists, we will use the following function:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1">[] \\ ys <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">xs \\ [] <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">(x<span class="fu">:</span>xs) \\ (y<span class="fu">:</span>ys) <span class="fu">=</span> <span class="kw">case</span> compare x y <span class="kw">of</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">    <span class="dt">LT</span> <span class="ot">-&gt;</span> x <span class="fu">:</span> xs \\ (y<span class="fu">:</span>ys)</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">    <span class="dt">EQ</span> <span class="ot">-&gt;</span> xs \\ ys</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">    <span class="dt">GT</span> <span class="ot">-&gt;</span> (x<span class="fu">:</span>xs) \\ ys</a></code></pre></div>
<p>We’re “subtracting” the right list from the left. Crucially, it works with infinite lists:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> take <span class="dv">10</span> ([<span class="dv">1</span><span class="fu">..</span>] \\ [<span class="dv">2</span>,<span class="dv">4</span><span class="fu">..</span>])</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">[<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">7</span>,<span class="dv">9</span>,<span class="dv">11</span>,<span class="dv">13</span>,<span class="dv">15</span>,<span class="dv">17</span>,<span class="dv">19</span>]</a></code></pre></div>
<p>Finally, it only works if both lists are ordered and don’t contain duplicates, but our sieve does indeed satisfy that requirement. Using this, we’ve already got a sieve:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">sieve (p<span class="fu">:</span>ps) <span class="fu">=</span> p <span class="fu">:</span> sieve (ps \\ [p<span class="fu">*</span>p, p<span class="fu">*</span>p<span class="fu">+</span>p<span class="fu">..</span>])</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">primes <span class="fu">=</span> <span class="dv">2</span> <span class="fu">:</span> sieve [<span class="dv">3</span>,<span class="dv">5</span><span class="fu">..</span>]</a></code></pre></div>
<p>No division, just addition and squaring, as promised. Unfortunately, though, this doesn’t have the time complexity we want. See, in the <code>(\\)</code> operation, we have to test every entry in the sieve against the prime factor: when we’re crossing off from an array, we just jump to the next composite number.</p>
<h1 id="using-a-queue">Using a Queue</h1>
<p>The way we speed up the “crossing-off” section of the algorithms is by using a priority queue: this was the optimization provided in <span class="citation" data-cites="oneill_genuine_2009">O’Neill (<a href="#ref-oneill_genuine_2009">2009</a>)</span>. Before we go any further, then, let’s put one together:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:-</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Queue</span> a b <span class="fu">=</span> <span class="dt">Queue</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">    {<span class="ot"> minKey ::</span> <span class="fu">!</span>a</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">    ,<span class="ot"> minVal ::</span> b</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">    ,<span class="ot"> rest   ::</span> <span class="dt">List</span> a b</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">    }</a>
<a class="sourceLine" id="cb5-7" data-line-number="7"></a>
<a class="sourceLine" id="cb5-8" data-line-number="8"><span class="kw">data</span> <span class="dt">List</span> a b</a>
<a class="sourceLine" id="cb5-9" data-line-number="9">    <span class="fu">=</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb5-10" data-line-number="10">    <span class="fu">|</span> (<span class="fu">:-</span>) <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span>(<span class="dt">Queue</span> a b)</a>
<a class="sourceLine" id="cb5-11" data-line-number="11">           (<span class="dt">List</span> a b)</a>
<a class="sourceLine" id="cb5-12" data-line-number="12"></a>
<a class="sourceLine" id="cb5-13" data-line-number="13"></a>
<a class="sourceLine" id="cb5-14" data-line-number="14"><span class="ot">(&lt;+&gt;) ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Queue</span> a b <span class="ot">-&gt;</span> <span class="dt">Queue</span> a b <span class="ot">-&gt;</span> <span class="dt">Queue</span> a b</a>
<a class="sourceLine" id="cb5-15" data-line-number="15">(<span class="fu">&lt;+&gt;</span>) q1<span class="fu">@</span>(<span class="dt">Queue</span> x1 y1 ts1) q2<span class="fu">@</span>(<span class="dt">Queue</span> x2 y2 ts2)</a>
<a class="sourceLine" id="cb5-16" data-line-number="16">  <span class="fu">|</span> x1 <span class="fu">&lt;=</span> x2 <span class="fu">=</span> <span class="dt">Queue</span> x1 y1 (q2 <span class="fu">:-</span> ts1)</a>
<a class="sourceLine" id="cb5-17" data-line-number="17">  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Queue</span> x2 y2 (q1 <span class="fu">:-</span> ts2)</a>
<a class="sourceLine" id="cb5-18" data-line-number="18"></a>
<a class="sourceLine" id="cb5-19" data-line-number="19"><span class="ot">mergeQs ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">List</span> a b <span class="ot">-&gt;</span> <span class="dt">Queue</span> a b</a>
<a class="sourceLine" id="cb5-20" data-line-number="20">mergeQs (t <span class="fu">:-</span> ts) <span class="fu">=</span> mergeQs1 t ts</a>
<a class="sourceLine" id="cb5-21" data-line-number="21">mergeQs <span class="dt">Nil</span>       <span class="fu">=</span> errorWithoutStackTrace <span class="st">&quot;tried to merge empty list&quot;</span></a>
<a class="sourceLine" id="cb5-22" data-line-number="22"></a>
<a class="sourceLine" id="cb5-23" data-line-number="23"><span class="ot">mergeQs1 ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Queue</span> a b <span class="ot">-&gt;</span> <span class="dt">List</span> a b <span class="ot">-&gt;</span> <span class="dt">Queue</span> a b</a>
<a class="sourceLine" id="cb5-24" data-line-number="24">mergeQs1 t1 <span class="dt">Nil</span>              <span class="fu">=</span> t1</a>
<a class="sourceLine" id="cb5-25" data-line-number="25">mergeQs1 t1 (t2 <span class="fu">:-</span> <span class="dt">Nil</span>)      <span class="fu">=</span> t1 <span class="fu">&lt;+&gt;</span> t2</a>
<a class="sourceLine" id="cb5-26" data-line-number="26">mergeQs1 t1 (t2 <span class="fu">:-</span> t3 <span class="fu">:-</span> ts) <span class="fu">=</span> (t1 <span class="fu">&lt;+&gt;</span> t2) <span class="fu">&lt;+&gt;</span> mergeQs1 t3 ts</a>
<a class="sourceLine" id="cb5-27" data-line-number="27"></a>
<a class="sourceLine" id="cb5-28" data-line-number="28"><span class="ot">insert ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Queue</span> a b <span class="ot">-&gt;</span> <span class="dt">Queue</span> a b</a>
<a class="sourceLine" id="cb5-29" data-line-number="29">insert <span class="fu">!</span>k <span class="fu">!</span>v <span class="fu">=</span> (<span class="fu">&lt;+&gt;</span>) (singleton k v)</a>
<a class="sourceLine" id="cb5-30" data-line-number="30"></a>
<a class="sourceLine" id="cb5-31" data-line-number="31"><span class="ot">singleton ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Queue</span> a b</a>
<a class="sourceLine" id="cb5-32" data-line-number="32">singleton <span class="fu">!</span>k <span class="fu">!</span>v <span class="fu">=</span> <span class="dt">Queue</span> k v <span class="dt">Nil</span></a></code></pre></div>
<p>These are pairing heaps: I’m using them here because they’re relatively simple and very fast. A lot of their speed comes from the fact that the top-level constructor (<code>Queue</code>) is <em>non-empty</em>. Since, in this algorithm, we’re only actually going to be working with non-empty queues, this saves us a pattern match on pretty much every function. They’re also what’s used in <a href="https://github.com/haskell/containers/blob/30ccbaa201043109bf1ee905c66ccd0dbe24422f/containers/src/Data/Sequence/Internal/sorting.md">Data.Sequence for sorting</a>.</p>
<p>With that, we can write our proper sieve:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1">insertPrime x xs <span class="fu">=</span> insert (x<span class="fu">*</span>x) (map (<span class="fu">*</span>x) xs)</a>
<a class="sourceLine" id="cb6-2" data-line-number="2"></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">adjust x q<span class="fu">@</span>(<span class="dt">Queue</span> y (z<span class="fu">:</span>zs) qs)</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">  <span class="fu">|</span> y <span class="fu">&lt;=</span> x <span class="fu">=</span> adjust x (insert z zs (mergeQs qs))</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">  <span class="fu">|</span> otherwise <span class="fu">=</span> q</a>
<a class="sourceLine" id="cb6-6" data-line-number="6"></a>
<a class="sourceLine" id="cb6-7" data-line-number="7">sieve (x<span class="fu">:</span>xs) <span class="fu">=</span> x <span class="fu">:</span> sieve' xs (singleton (x<span class="fu">*</span>x) (map (<span class="fu">*</span>x) xs))</a>
<a class="sourceLine" id="cb6-8" data-line-number="8">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-9" data-line-number="9">    sieve' (x<span class="fu">:</span>xs) table</a>
<a class="sourceLine" id="cb6-10" data-line-number="10">      <span class="fu">|</span> minKey table <span class="fu">&lt;=</span> x <span class="fu">=</span> sieve' xs (adjust x table)</a>
<a class="sourceLine" id="cb6-11" data-line-number="11">      <span class="fu">|</span> otherwise <span class="fu">=</span> x <span class="fu">:</span> sieve' xs (insertPrime x xs table)</a>
<a class="sourceLine" id="cb6-12" data-line-number="12">      </a>
<a class="sourceLine" id="cb6-13" data-line-number="13">primes <span class="fu">=</span> <span class="dv">2</span> <span class="fu">:</span> sieve [<span class="dv">3</span>,<span class="dv">5</span><span class="fu">..</span>]</a></code></pre></div>
<h1 id="simplifying">Simplifying</h1>
<p>The priority queue stores lists alongside their keys: what you might notice is that those lists are simply sequences of the type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mi>x</mi><mo>,</mo><mn>2</mn><mi>x</mi><mo>,</mo><mn>3</mn><mi>x</mi><mo>,</mo><mn>4</mn><mi>x</mi><mi>.</mi><mi>.</mi><mi>.</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[x, 2x, 3x, 4x...]</annotation></semantics></math> and so on. Rather than storing the whole list, we can instead store just the head and the step. This also simplifies (and greatly speeds up) the expensive <code>map (*x)</code> operation to just <em>two</em> multiplications. If you wanted, you could just sub in this representation of streams for all the lists above:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Stepper</span> a <span class="fu">=</span> <span class="dt">Stepper</span> {<span class="ot"> start ::</span> a,<span class="ot"> step ::</span> a }</a>
<a class="sourceLine" id="cb7-2" data-line-number="2"></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="ot">nextStep ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Stepper</span> a <span class="ot">-&gt;</span> (a, <span class="dt">Stepper</span> a)</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">nextStep (<span class="dt">Stepper</span> x y) <span class="fu">=</span> (x, <span class="dt">Stepper</span> (x<span class="fu">+</span>y) y)</a>
<a class="sourceLine" id="cb7-5" data-line-number="5"></a>
<a class="sourceLine" id="cb7-6" data-line-number="6">pattern x <span class="fu">:-</span> xs <span class="ot">&lt;-</span> (nextStep <span class="ot">-&gt;</span> (x,xs))</a>
<a class="sourceLine" id="cb7-7" data-line-number="7"></a>
<a class="sourceLine" id="cb7-8" data-line-number="8"><span class="ot">(^*) ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Stepper</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Stepper</span> a</a>
<a class="sourceLine" id="cb7-9" data-line-number="9"><span class="dt">Stepper</span> x y <span class="fu">^*</span> f <span class="fu">=</span> <span class="dt">Stepper</span> (x <span class="fu">*</span> f) (y <span class="fu">*</span> f)</a></code></pre></div>
<p>If you were so inclined, you could even make it conform to <code>Foldable</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Stepper</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">    <span class="dt">Stepper</span><span class="ot"> ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Stepper</span> a</a>
<a class="sourceLine" id="cb8-3" data-line-number="3"></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">nextStep (<span class="dt">Stepper</span> x y) <span class="fu">=</span> (x, <span class="dt">Stepper</span> (x<span class="fu">+</span>y) y)</a>
<a class="sourceLine" id="cb8-5" data-line-number="5"></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">pattern x <span class="fu">:-</span> xs <span class="ot">&lt;-</span> (nextStep <span class="ot">-&gt;</span> (x,xs))</a>
<a class="sourceLine" id="cb8-7" data-line-number="7"></a>
<a class="sourceLine" id="cb8-8" data-line-number="8"><span class="kw">instance</span> <span class="dt">Foldable</span> <span class="dt">Stepper</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-9" data-line-number="9">    foldr f b (x <span class="fu">:-</span> xs) <span class="fu">=</span> f x (foldr f b xs)</a></code></pre></div>
<p>But that’s overkill for what we need here.</p>
<p>Second observation is that if we remove the wheel (from 2), the “start” is simply the <em>key</em> in the priority queue, again cutting down on space.</p>
<p>Finally, we get the implementation:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1">primes <span class="fu">=</span> <span class="dv">2</span> <span class="fu">:</span> sieve <span class="dv">3</span> (singleton <span class="dv">4</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">    adjust <span class="fu">!</span>x q<span class="fu">@</span>(<span class="dt">Queue</span> y z qs)</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">        <span class="fu">|</span> x <span class="fu">&lt;</span> y <span class="fu">=</span> q</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">        <span class="fu">|</span> otherwise <span class="fu">=</span> adjust x (mergeQs1 (singleton (y <span class="fu">+</span> z) z) qs)</a>
<a class="sourceLine" id="cb9-6" data-line-number="6">    sieve <span class="fu">!</span>x q</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">        <span class="fu">|</span> x <span class="fu">&lt;</span> minKey q <span class="fu">=</span> x <span class="fu">:</span> sieve (x <span class="fu">+</span> <span class="dv">1</span>) (insert (x <span class="fu">*</span> x) x q)</a>
<a class="sourceLine" id="cb9-8" data-line-number="8">        <span class="fu">|</span> otherwise <span class="fu">=</span> sieve (x <span class="fu">+</span> <span class="dv">1</span>) (adjust x q)</a></code></pre></div>
<p>8 lines for a lazy prime sieve isn’t bad!</p>
<p>I haven’t tried a huge amount to optimize the function, but it might be worth looking in to how to add back the wheels. I noticed that for no wheels, the queue contains only two elements per key; for one (the 2 wheel), we needed 3. I wonder if this pattern continues: possibly we could represent wheels as finite lists at each key in the queue. Maybe in a later post.</p>
<div id="refs" class="references">
<div id="ref-haran_infinity_2018">
<p>Haran, Brady. 2018. “To Infinity &amp; Beyond - Computerphile.” <a href="https://www.youtube.com/watch?v=bnRNiE_OVWA&amp;feature=youtu.be" class="uri">https://www.youtube.com/watch?v=bnRNiE_OVWA&amp;feature=youtu.be</a>.</p>
</div>
<div id="ref-oneill_genuine_2009">
<p>O’Neill, Melissa E. 2009. “The Genuine Sieve of Eratosthenes.” <em>Journal of Functional Programming</em> 19 (01) (January): 95. doi:<a href="https://doi.org/10.1017/S0956796808007004">10.1017/S0956796808007004</a>.</p>
</div>
</div>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
