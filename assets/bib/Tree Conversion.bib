
@article{bahr_calculating_2015,
  title = {Calculating Correct Compilers},
  author = {Bahr, Patrick and Hutton, Graham},
  year = {2015},
  month = sep,
  volume = {25},
  publisher = {{Cambridge University Press (CUP)}},
  issn = {0956-7968, 1469-7653},
  doi = {10.1017/S0956796815000180},
  url = {https://nottingham-repository.worktribe.com/output/761112},
  urldate = {2020-11-25},
  abstract = {In this article we present a new approach to the problem of calculating compilers. In particular, we develop a simple but general technique that allows us to derive correct compilers from high- level semantics by systematic calculation, with all details of the implementation of the compilers falling naturally out of the calculation process. Our approach is based upon the use of standard equational reasoning techniques, and has been applied to calculate compilers for a wide range of language features and their combination, including arithmetic expressions, exceptions, state, various forms of lambda calculi, bounded and unbounded loops, non-determinism, and interrupts. All the calculations in the article have been formalised using the Coq proof assistant, which serves as a convenient interactive tool for developing and verifying the calculations.},
  journal = {Journal of Functional Programming},
  language = {en},
  number = {e14}
}

@article{hutton_countdown_2002,
  title = {The {{Countdown Problem}}},
  author = {Hutton, Graham},
  year = {2002},
  month = nov,
  volume = {12},
  pages = {609--616},
  issn = {0956-7968},
  doi = {10.1017/S0956796801004300},
  url = {http://www.cs.nott.ac.uk/~pszgmh/countdown.pdf},
  urldate = {2018-03-08},
  abstract = {We systematically develop a functional program that solves the countdown problem, a numbers game in which the aim is to construct arithmetic expressions satisfying certain constraints. Starting from a formal specification of the problem, we present a simple but inefficient program that solves the problem, and prove that this program is correct. We then use program fusion to calculate an equivalent but more efficient program, which is then further improved by exploiting arithmetic properties.},
  journal = {J. Funct. Program.},
  number = {6}
}

@book{knuth_art_2006,
  title = {The {{Art}} of {{Computer Programming}}, {{Volume}} 4, {{Fascicle}} 4: {{Generating All Trees}}--{{History}} of {{Combinatorial Generation}} ({{Art}} of {{Computer Programming}})},
  shorttitle = {The {{Art}} of {{Computer Programming}}, {{Volume}} 4, {{Fascicle}} 4},
  author = {Knuth, Donald E.},
  year = {2006},
  publisher = {{Addison-Wesley Professional}},
  url = {http://www.cs.utsa.edu/~wagner/knuth/fasc4a.pdf},
  abstract = {This multivolume work on the analysis of algorithms has long been recognized as the definitive description of classical computer science.The three complete volumes published to date already comprise a unique and invaluable resource in programming theory and practice. Countless readers have spoken about the profound personal influence of Knuth's writings. Scientists have marveled at the beauty and elegance of his analysis, while practicing programmers have successfully applied his ``cookbook'' solutions to their day-to-day problems. All have admired Knuth for the breadth, clarity, accuracy, and good humor found in his books.To begin the fourth and later volumes of the set, and to update parts of the existing three, Knuth has created a series of small books called fascicles, which will be published at regular intervals. Each fascicle will encompass a section or more of wholly new or revised material. Ultimately, the content of these fascicles will be rolled up into the comprehensive, final versions of each volume, and the enormous undertaking that began in 1962 will be complete.Volume 4, Fascicle 4This latest fascicle covers the generation of all trees, a basic topic that has surprisingly rich ties to the first three volumes of The Art of Computer Programming. In thoroughly discussing this well-known subject, while providing 124 new exercises, Knuth continues to build a firm foundation for programming. To that same end, this fascicle also covers the history of combinatorial generation. Spanning many centuries, across many parts of the world, Knuth tells a fascinating story of interest and relevance to every artful programmer, much of it never before told. The story even includes a touch of suspense: two problems that no one has yet been able to solve.},
  isbn = {978-0-321-33570-8}
}

@misc{mcgill_compiler_2020,
  title = {Compiler Correctness for Addition Language},
  author = {McGill, Callan},
  year = {2020},
  month = nov,
  url = {https://gist.github.com/Boarders/9d83f9cbcfaffb04cf2464588fc46df9},
  urldate = {2020-12-13},
  abstract = {compiler correctness for addition language.}
}

@misc{riley_program_2020,
  title = {Program {{Correctness}} - {{Computerphile}}},
  author = {Riley, Sean},
  year = {2020},
  month = nov,
  address = {{University of Nottingham}},
  url = {https://www.youtube.com/watch?v=T_IINWzQhow},
  urldate = {2020-12-13},
  abstract = {Program Correctness is incredibly important in computing - particularly in hardware design. Professor Graham Hutton takes us through a simple example using arithmetic.  EXTRA BITS: https://youtu.be/TByzerWLKg8  https://www.facebook.com/computerphile https://twitter.com/computer\_phile This video was filmed and edited by Sean Riley. Computer Science at the University of Nottingham: https://bit.ly/nottscomputer Computerphile is a sister project to Brady Haran's Numberphile. More at http://www.bradyharan.com},
  collaborator = {Hutton, Graham},
  language = {en}
}

@misc{tychonievich_enumerating_2013,
  title = {Enumerating {{Trees}}},
  author = {Tychonievich, Luther},
  year = {2013},
  month = aug,
  url = {https://www.cs.virginia.edu/~lat7h/blog/posts/434.html},
  urldate = {2020-12-14},
  abstract = {A one-to-one mapping between binary trees and nat\-ural numbers.},
  journal = {Luther's Meanderings}
}


