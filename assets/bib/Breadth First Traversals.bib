
@article{allison_circular_2006,
  title = {Circular {{Programs}} and {{Self}}-{{Referential Structures}}},
  author = {Allison, Lloyd},
  year = {2006},
  month = oct,
  volume = {19},
  pages = {99--109},
  issn = {1097-024X},
  doi = {10.1002/spe.4380190202},
  url = {http://users.monash.edu/~lloyd/tildeFP/1989SPE/},
  urldate = {2018-06-01},
  abstract = {A circular program creates a data structure whose computation depends upon itself or refers to itself. The technique is used to implement the classic data structures circular and doubly-linked lists, threaded trees and queues, in a functional programming language. These structures are normally thought to require updatable variables found in imperative languages. For example, a functional program to perform the breadth-first traversal of a tree is given. Some of the examples result in circular data structures when evaluated. Some examples are particularly space-efficient by avoiding the creation of intermediate temporary structures which would otherwise later become garbage. Lastly, the technique can be applied in an imperative language to give an elegant program.},
  file = {/Users/doisinkidney/Zotero/storage/Y4N267KR/Allison - 2006 - Circular Programs and Self-Referential Structures.pdf;/Users/doisinkidney/Zotero/storage/K3Q9X4Z8/1989SPE.html;/Users/doisinkidney/Zotero/storage/TDDEAG4F/PP.html;/Users/doisinkidney/Zotero/storage/TGUU9DZL/spe.html},
  journal = {Software: Practice and Experience},
  language = {en},
  number = {2}
}

@inproceedings{bergerMartinHofmannCase2019,
  ids = {bergerMartinHofmannCase2018},
  title = {Martin {{Hofmann}}'s {{Case}} for {{Non}}-{{Strictly Positive Data Types}}},
  booktitle = {24th International Conference on Types for Proofs and Programs ({{TYPES}} 2018)},
  author = {Berger, Ulrich and Matthes, Ralph and Setzer, Anton},
  editor = {Dybjer, Peter and Santo, Jos{\'e} Esp{\'i}rito and Pinto, Lu{\'i}s},
  year = {2019},
  volume = {130},
  pages = {22},
  publisher = {{Schloss Dagstuhl\textendash{}Leibniz-Zentrum fuer Informatik}},
  address = {{Dagstuhl, Germany}},
  issn = {1868-8969},
  doi = {10.4230/LIPIcs.TYPES.2018.1},
  url = {http://drops.dagstuhl.de/opus/volltexte/2019/11405},
  abstract = {We describe the breadth-first traversal algorithm by Martin Hofmann that uses a non-strictly positive data type and carry out a simple verification in an extensional setting. Termination is shown by implementing the algorithm in the strongly normalising extension of system F by Mendler-style recursion. We then analyze the same algorithm by alternative verifications first in an intensional setting using a non-strictly positive inductive definition (not just a non-strictly positive data type), and subsequently by two different algebraic reductions. The verification approaches are compared in terms of notions of simulation and should elucidate the somewhat mysterious algorithm and thus make a case for other uses of non-strictly positive data types. Except for the termination proof, which cannot be formalised in Coq, all proofs were formalised in Coq and some of the algorithms were implemented in Agda and Haskell.},
  file = {/Users/doisinkidney/Zotero/storage/FEQS9Z6U/Berger et al. - 2018 - Martin Hofmann’s Case for Non-Strictly Positive Da.pdf},
  isbn = {978-3-95977-106-1},
  language = {en},
  series = {Leibniz International Proceedings in Informatics ({{LIPIcs}})},
  urn = {urn:nbn:de:0030-drops-114052}
}

@inproceedings{bird_understanding_2013,
  title = {Understanding {{Idiomatic Traversals Backwards}} and {{Forwards}}},
  booktitle = {{{ACM SIGPLAN Notices}}},
  author = {Bird, Richard and Gibbons, Jeremy and Mehner, Stefan and Schrijvers, Tom and Voigtlaender, Janis},
  year = {2013},
  volume = {48},
  pages = {25--36},
  publisher = {{ACM}},
  url = {http://www.cs.ox.ac.uk/jeremy.gibbons/publications/uitbaf.pdf},
  urldate = {2016-10-31},
  file = {/Users/doisinkidney/Zotero/storage/QJ6BH96Z/Bird et al. - Understanding Idiomatic Traversals Backwards and F.pdf}
}

@misc{chatav_what_2015,
  title = {What Is the Correct Way to Write Breadth First {{Traversal}} of a [{{Tree}}]?},
  author = {Chatav, Etian},
  year = {2015},
  month = mar,
  url = {https://www.facebook.com/groups/programming.haskell/permalink/985981691412832/},
  urldate = {2018-06-01},
  abstract = {What is the correct way to write breadth first Traversal of a [Tree]? I tried this:

{$>$} data Tree a = Tree \{ label :: a, children :: [Tree a] \} deriving (Show)

{$>$} type Traversal s t a b = forall f....},
  file = {/Users/doisinkidney/Zotero/storage/RVDS5VYY/985981691412832.html},
  journal = {Facebook},
  language = {en}
}

@misc{cirdec_answer_2015,
  title = {Answer to: {{Is}} a Lazy, Breadth-First Monadic Rose Tree Unfold Possible?},
  author = {Cirdec},
  year = {2015},
  month = jan,
  url = {https://stackoverflow.com/a/27752984/4892417},
  abstract = {Data.Tree includes unfoldTreeM\_BF and unfoldForestM\_BF functions to construct trees breadth-first using the results of monadic actions. The tree unfolder can be written easily using the forest unfolder, so I'll focus on the latter:

unfoldForestM\_BF :: Monad m ={$>$}
             (b -{$>$} m (a, [b])) -{$>$} [b] -{$>$} m [Tree a]
Starting with a list of seeds, it applies a function to each, generating actions that will produce the tree roots and the seeds for the next level of unfolding. The algorithm used is somewhat strict, so using unfoldForestM\_BF with the Identity monad is not exactly the same as using the pure unfoldForest. I've been trying to figure out if there's a way to make it lazy without sacrificing its O(n) time bound. If (as Edward Kmett suggested to me) this is impossible, I wonder if it would be possible to do it with a more constrained type, specifically requiring MonadFix rather than Monad. The concept there would be to (somehow) set up the pointers to the results of future computations while adding those computations to the to-do list, so if they are lazy in the effects of earlier computations they will be available immediately.},
  file = {/Users/doisinkidney/Zotero/storage/B6FN5XFB/27752984.html},
  journal = {Stack Overflow},
  language = {en},
  type = {Answer}
}

@misc{cirdec_answer_2015-1,
  title = {Answer to: {{Breadth}}-{{First Search}} Using {{State}} Monad in {{Haskell}}},
  author = {Cirdec},
  year = {2015},
  month = feb,
  url = {https://stackoverflow.com/a/28574768/4892417},
  urldate = {2018-06-01},
  file = {/Users/doisinkidney/Zotero/storage/E2FBJLNI/28574768.html},
  journal = {Stack Overflow},
  type = {Answer}
}

@misc{feuer_is_2015,
  title = {Is a Lazy, Breadth-First Monadic Rose Tree Unfold Possible?},
  author = {Feuer, David},
  year = {2015},
  month = jan,
  url = {https://stackoverflow.com/q/27748526},
  urldate = {2018-06-01},
  abstract = {Data.Tree includes unfoldTreeM\_BF and unfoldForestM\_BF functions to construct trees breadth-first using the results of monadic actions. The tree unfolder can be written easily using the forest unfolder, so I'll focus on the latter:

unfoldForestM\_BF :: Monad m ={$>$}
             (b -{$>$} m (a, [b])) -{$>$} [b] -{$>$} m [Tree a]
Starting with a list of seeds, it applies a function to each, generating actions that will produce the tree roots and the seeds for the next level of unfolding. The algorithm used is somewhat strict, so using unfoldForestM\_BF with the Identity monad is not exactly the same as using the pure unfoldForest. I've been trying to figure out if there's a way to make it lazy without sacrificing its O(n) time bound. If (as Edward Kmett suggested to me) this is impossible, I wonder if it would be possible to do it with a more constrained type, specifically requiring MonadFix rather than Monad. The concept there would be to (somehow) set up the pointers to the results of future computations while adding those computations to the to-do list, so if they are lazy in the effects of earlier computations they will be available immediately.},
  file = {/Users/doisinkidney/Zotero/storage/ZU2V6RFN/27752984.html},
  journal = {Stack Overflow},
  type = {Question}
}

@misc{gibbons_breadth-first_2015,
  title = {Breadth-{{First Traversal}}},
  author = {Gibbons, Jeremy},
  year = {2015},
  month = mar,
  url = {https://patternsinfp.wordpress.com/2015/03/05/breadth-first-traversal/},
  urldate = {2018-03-16},
  abstract = {Recently Eitan Chatav asked in the Programming Haskell group on Facebook What is the correct way to write breadth first traversal of a \$latex \{[\textbackslash{}mathsf\{Tree\}]\}\&fg=000000\$? He's thinking o\ldots{}},
  file = {/Users/doisinkidney/Zotero/storage/CE34KLP3/breadth-first-traversal.html},
  journal = {Patterns in Functional Programming},
  language = {en}
}

@misc{hofmannNonStrictlyPositive1993,
  title = {Non {{Strictly Positive Datatypes}} in {{System F}}},
  author = {Hofmann, Martin},
  year = {1993},
  month = feb,
  url = {https://www.seas.upenn.edu/~sweirich/types/archive/1993/msg00027.html},
  urldate = {2020-01-27},
  collaborator = {{types@uk.ac.gla.dcs}},
  file = {/Users/doisinkidney/Zotero/storage/ZWVMMVB8/msg00027.html}
}

@techreport{jones_linear-time_1993,
  title = {Linear-Time {{Breadth}}-First {{Tree Algorithms}}: {{An Exercise}} in the {{Arithmetic}} of {{Folds}} and {{Zips}}},
  shorttitle = {Linear-Time Breadth-First Tree Algorithms},
  author = {Jones, Geraint and Gibbons, Jeremy},
  year = {1993},
  month = may,
  institution = {{Dept of Computer Science, University of Auckland}},
  url = {http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/linear.ps.gz},
  abstract = {This paper is about an application of the mathematics of the zip, reduce (fold) and accumulate (scan) operations on lists. It gives an account of the derivation of a linear-time breadth-first tree traversal algorithm, and of a subtle and efficient breadth-first tree labelling algorithm.},
  file = {/Users/doisinkidney/Zotero/storage/DWNSFLCU/Jones and Gibbons - 1993 - Linear-time Breadth-first Tree Algorithms An Exer.pdf;/Users/doisinkidney/Zotero/storage/L3FJW23Y/Jones and Gibbons - 1993 - Linear-time breadth-first tree algorithms An exer.pdf;/Users/doisinkidney/Zotero/storage/FBMN8FSQ/summary.html;/Users/doisinkidney/Zotero/storage/MN84D7XS/summary.html},
  number = {71}
}

@misc{mazayong_breadth-first_2015,
  title = {Breadth-{{First Search}} Using {{State}} Monad in {{Haskell}}},
  author = {MazaYong},
  year = {2015},
  month = feb,
  url = {https://stackoverflow.com/questions/28573287/breadth-first-search-using-state-monad-in-haskell?noredirect=1\&lq=1},
  urldate = {2018-06-01},
  file = {/Users/doisinkidney/Zotero/storage/MEX8PD6G/breadth-first-search-using-state-monad-in-haskell.html},
  journal = {Stack Overflow},
  type = {Question}
}

@inproceedings{NipkowS-CPP20,
  ids = {nipkowProofPearlBraun2020},
  title = {Proof Pearl: {{Braun}} Trees},
  booktitle = {Certified Programs and Proofs, {{CPP}} 2020},
  author = {Nipkow, Tobias and Sewell, Thomas},
  editor = {Blanchette, J. and Hritcu, C.},
  year = {2020},
  pages = {-},
  publisher = {{ACM}},
  url = {http://www21.in.tum.de/~nipkow/pubs/cpp20.html},
  abstract = {Braun trees are functional data structures for implementing extensible arrays and priority queues (and sorting functions based on the latter) efficiently. Some well-known functions on Braun trees have not yet been verified, including especially Okasaki's linear time conversion from lists to Braun trees. We supply the missing proofs and verify all of these algorithms in Isabelle, including non-obvious time complexity claims. In particular we provide the first linear-time conversion from Braun trees to lists. We also state and verify a new characterization of Braun trees as the trees t whose index set is the interval \{1, . . . , size of t \}.},
  file = {/Users/doisinkidney/Zotero/storage/8E48WKC6/Nipkow and Sewell - 2020 - Proof Pearl Braun Trees.pdf;/Users/doisinkidney/Zotero/storage/RKKAJYSF/Nipkow and Sewell - 2020 - Proof pearl Braun trees.pdf},
  language = {en}
}

@inproceedings{okasaki_breadth-first_2000,
  title = {Breadth-First {{Numbering}}: {{Lessons}} from a {{Small Exercise}} in {{Algorithm Design}}},
  shorttitle = {Breadth-First {{Numbering}}},
  booktitle = {Proceedings of the {{Fifth ACM SIGPLAN International Conference}} on {{Functional Programming}}},
  author = {Okasaki, Chris},
  year = {2000},
  pages = {131--136},
  publisher = {{ACM}},
  address = {{New York, NY, USA}},
  doi = {10.1145/351240.351253},
  url = {https://www.cs.tufts.edu/~nr/cs257/archive/chris-okasaki/breadth-first.pdf},
  urldate = {2018-02-17},
  abstract = {Every programmer has blind spots. Breadth-first numbering is an interesting toy problem that exposes a blind spot common to many---perhaps most---functional programmers.},
  file = {/Users/doisinkidney/Zotero/storage/BC5QQV8B/Okasaki - 2000 - Breadth-first Numbering Lessons from a Small Exer.pdf},
  isbn = {978-1-58113-202-1},
  keywords = {Breadth-first numbering,breadth-first traversal,views},
  series = {{{ICFP}} '00}
}

@article{okasakiThreeAlgorithmsBraun1997,
  title = {Three {{Algorithms}} on {{Braun Trees}}},
  author = {Okasaki, Chris},
  year = {1997},
  month = nov,
  volume = {7},
  pages = {661--666},
  issn = {0956-7968},
  doi = {10.1017/S0956796897002876},
  url = {https://www.eecs.northwestern.edu/~robby/courses/395-495-2013-fall/three-algorithms-on-braun-trees.pdf},
  urldate = {2017-04-11},
  abstract = {Among the many flavours of balanced binary trees, Braun trees (Braun and Rem, 1983) are perhaps the most circumscribed. For any given node of a Braun tree, the left subtree is either exactly the same size as the right subtree, or one element larger. Braun trees always have minimum height, and the shape of each Braun tree is completely determined by its size. In return for this rigor, algorithms that manipulate Braun trees are often exceptionally simple and elegant, and need not maintain any explicit balance information.Braun trees have been used to implement both flexible arrays (Braun and Rem, 1983; Hoogerwoord, 1992; Paulson, 1996) and priority queues (Paulson, 1996; Bird, 1996). Most operations involving a single element (e.g. adding, removing, inspecting or updating an element) take O(log n) time, since the trees are balanced. We consider three algorithmically interesting operations that manipulate entire trees. First, we give an O(log2 n) algorithm for calculating the size of a tree. Second, we show how to create a tree containing n copies of some element x in O(log n) time. Finally, we describe an order-preserving algorithm for converting a list to a tree in O(n) time. This last operation is not nearly as straightforward as it sounds!},
  file = {/Users/doisinkidney/Zotero/storage/BZAMGNE6/three-algorithms-on-braun-trees.pdf;/Users/doisinkidney/Zotero/storage/7C5PEIN4/59CF6B17F75EC216EBCA8A08E8780DFF.html},
  journal = {Journal of Functional Programming},
  number = {6}
}

@article{smith_lloyd_2009,
  title = {Lloyd {{Allison}}'s {{Corecursive Queues}}: {{Why Continuations Matter}}},
  author = {Smith, Leon P},
  year = {2009},
  month = jul,
  volume = {14},
  pages = {28},
  url = {https://meldingmonads.files.wordpress.com/2009/06/corecqueues.pdf},
  abstract = {In a purely functional setting, real-time queues are traditionally thought to be much harder to implement than either real-time stacks or amortized O(1) queues. In ``Circular Programs and Self-Referential Structures,'' [1] Lloyd Allison uses corecursion to implement a queue by defining a lazy list in terms of itself. This provides a simple, efficient, and attractive implementation of real-time queues.},
  file = {/Users/doisinkidney/Zotero/storage/G7FLCPUX/leon - Lloyd Allison’s Corecursive Queues Why Continuati.pdf},
  journal = {The Monad.Reader},
  language = {en},
  number = {14}
}


