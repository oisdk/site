
@article{brown_building_2014,
  archivePrefix = {arXiv},
  eprinttype = {arxiv},
  eprint = {1410.5420},
  primaryClass = {cs},
  title = {Building a {{Balanced}} K-d {{Tree}} in {{O}}(Kn Log n) {{Time}}},
  volume = {4},
  abstract = {The original description of the k-d tree recognized that rebalancing techniques, such as are used to build an AVL tree or a red-black tree, are not applicable to a k-d tree. Hence, in order to build a balanced k-d tree, it is necessary to find the median of the data for each recursive subdivision of those data. The sort or selection that is used to find the median for each subdivision strongly influences the computational complexity of building a k-d tree. This paper discusses an alternative algorithm that builds a balanced k-d tree by presorting the data in each of k dimensions prior to building the tree. It then preserves the order of these k sorts during tree construction and thereby avoids the requirement for any further sorting. Moreover, this algorithm is amenable to parallel execution via multiple threads. Compared to an algorithm that finds the median for each recursive subdivision, this presorting algorithm has equivalent performance for four dimensions and better performance for three or fewer dimensions.},
  language = {en},
  number = {1},
  journal = {arXiv:1410.5420 [cs]},
  note = {\url{http://arxiv.org/abs/1410.5420}},
  author = {Brown, Russell A.},
  month = oct,
  year = {2014},
  keywords = {Computer Science - Data Structures and Algorithms},
  pages = {19},
  file = {/Users/doisinkidney/Zotero/storage/8DUXYIUX/Brown - 2014 - Building a Balanced k-d Tree in O(kn log n) Time.pdf;/Users/doisinkidney/Zotero/storage/SPSN744B/Brown - 2015 - Building a Balanced k-d Tree in O(kn log n) Time.pdf;/Users/doisinkidney/Zotero/storage/LYJ89Z5V/1410.html}
}

@incollection{hinze_duality_2013,
  address = {Berlin, Heidelberg},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  title = {A {{Duality}} of {{Sorts}}},
  isbn = {978-3-642-40355-2},
  abstract = {Sorting algorithms are one of the key pedagogical foundations of computer science, and their properties have been studied heavily. Perhaps less well known, however, is the fact that many of the basic sorting algorithms exist as a pair, and that these pairs arise naturally out of the duality between folds and unfolds. In this paper, we make this duality explicit, by showing how to define common sorting algorithms as folds of unfolds, or, dually, as unfolds of folds. This duality is preserved even when considering optimised sorting algorithms that require more exotic variations of folds and unfolds, and intermediary data structures. While all this material arises naturally from a categorical modelling of these recursion schemes, we endeavour to keep this presentation accessible to those not versed in abstract nonsense.},
  language = {en},
  booktitle = {The {{Beauty}} of {{Functional Code}}: {{Essays Dedicated}} to {{Rinus Plasmeijer}} on the {{Occasion}} of {{His}} 61st {{Birthday}}},
  publisher = {{Springer Berlin Heidelberg}},
  note = {\url{https://doi.org/10.1007/978-3-642-40355-2_11}},
  author = {Hinze, Ralf and Magalh\~aes, Jos\'e Pedro and Wu, Nicolas},
  editor = {Achten, Peter and Koopman, Pieter},
  year = {2013},
  keywords = {Functional Programming,Recursion Scheme,Empty List,Input List,Sorting Algorithm},
  pages = {151-167},
  file = {/Users/doisinkidney/Zotero/storage/3UL5VLKK/Hinze et al. - 2013 - A Duality of Sorts.pdf},
  doi = {10.1007/978-3-642-40355-2_11}
}

@misc{kiselyov_provably_2002,
  title = {Provably Perfect Random Shuffling and Its Pure Functional Implementations},
  abstract = {We show two purely functional programs that perfectly, randomly and uniformly shuffle a sequence of arbitrary elements. We prove that the algorithms are correct. We also show why a commonly used sort-based shuffling algorithm is not perfect.

The article first formally defines the perfect random shuffle, outlines the algorithm, and discusses the well-known imperative shuffler that swaps elements in the array. We present and analyze two purely functional implementations. The naive one runs in O(n\^2) time. A more sophisticated code has the O(n*logn) time complexity. The article contains the full code to arrange a sequence in a complete binary tree and to extract an arbitrary element from the tree maintaining the completeness of the remaining tree.},
  journal = {http://okmij.org},
  howpublished = {\url{http://okmij.org/ftp/Haskell/AlgorithmsH.html\#perfect-shuffle}},
  author = {Kiselyov, Oleg},
  month = jul,
  year = {2002},
  file = {/Users/doisinkidney/Zotero/storage/IRVM2D46/AlgorithmsH.html}
}

@misc{haran_sorting_2016,
  title = {Sorting {{Secret}}},
  abstract = {Two different sorting algorithms are actually the same. Professor Graham Hutton explains. Note from Professor Hutton: It's great to see all the discussions here! To clarify a point raised in some of the comments, the video shows that if you consider the essential underlying idea of selection sort and insertion sort, in terms of how they decompose the problem of sorting, then they perform the same operations but in different orders. Using the picture in the video, selection sort proceeds column at a time and insertion sort proceeds row at a time, but they both perform the same 'triangle' of operations in the end. A particular implementation of these sorting methods may optimise the process in some way, e.g. in a sequential implementation each row can stop comparing numbers once the point of insertion is found. But this is an implementation detail that is dependent on the computational model used, such as sequential versus parallel, or imperative versus functional, rather than part of the essential means by which the sorting methods work.},
  howpublished = {\url{https://www.youtube.com/watch?v=pcJHkWwjNl4}},
  author = {Haran, Brady},
  collaborator = {Hutton, Graham},
  month = nov,
  year = {2016}
}

@inproceedings{hinze_sorting_2012,
  address = {Copenhagen, Denmark},
  title = {Sorting with Bialgebras and Distributive Laws},
  isbn = {978-1-4503-1576-0},
  abstract = {Sorting algorithms are an intrinsic part of functional programming folklore as they exemplify algorithm design using folds and unfolds. This has given rise to an informal notion of duality among sorting algorithms: insertion sorts are dual to selection sorts. Using bialgebras and distributive laws, we formalise this notion within a categorical setting. We use types as a guiding force in exposing the recursive structure of bubble, insertion, selection, quick, tree, and heap sorts. Moreover, we show how to distill the computational essence of these algorithms down to one-step operations that are expressed as natural transformations. From this vantage point, the duality is clear, and one side of the algorithmic coin will neatly lead us to the other ``for free''. As an optimisation, the approach is also extended to paramorphisms and apomorphisms, which allow for more efficient implementations of these algorithms than the corresponding folds and unfolds.},
  language = {en},
  booktitle = {Proceedings of the 8th {{ACM SIGPLAN}} Workshop on {{Generic}} Programming - {{WGP}} '12},
  publisher = {{ACM Press}},
  doi = {10.1145/2364394.2364405},
  note = {\url{http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.366.1640\&rep=rep1\&type=pdf}},
  author = {Hinze, Ralf and James, Daniel W.H. and Harper, Thomas and Wu, Nicolas and Magalh\~aes, Jos\'e Pedro},
  year = {2012},
  pages = {69},
  file = {/Users/doisinkidney/Zotero/storage/JLIPZWZZ/Hinze et al. - 2012 - Sorting with bialgebras and distributive laws.pdf}
}


