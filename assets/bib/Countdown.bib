
@article{bird_countdown:_2005,
	title = {Countdown: {A} case study in origami programming},
	volume = {15},
	issn = {0956-7968, 1469-7653},
	shorttitle = {Countdown},
	url = {http://www.journals.cambridge.org/abstract_S0956796805005642},
	doi = {10.1017/S0956796805005642},
	language = {en},
	number = {05},
	urldate = {2018-02-16},
	journal = {Journal of Functional Programming},
	author = {Bird, Richard and Mu, Shin-Cheng},
	month = aug,
	year = {2005},
	pages = {679},
	file = {Bird and Mu - 2005 - Countdown A case study in origami programming.pdf:files/3286/Bird and Mu - 2005 - Countdown A case study in origami programming.pdf:application/pdf}
}

@article{danvy_there_2005,
	title = {There and {Back} {Again}},
	volume = {12},
	issn = {1601-5355},
	url = {https://tidsskrift.dk/brics/article/view/21869},
	doi = {10.7146/brics.v12i3.21869},
	abstract = {We present a programming pattern where a recursive function defined over a data structure traverses another data structure at return time. The idea is that the recursive calls get us `there' by traversing the first data structure and the returns get us `back again' while traversing the second data structure. We name this programming pattern of traversing a data structure at call time and another data structure at return time “There And Back Again” (TABA). The TABA pattern directly applies to computing symbolic convolutions and to multiplying polynomials. It also blends well with other programming patterns such as dynamic programming and traversing a list at double speed. We illustrate TABA and dynamic programming with Catalan numbers. We illustrate TABA and traversing a list at double speed with palindromes and we obtain a novel solution to this traditional exercise. Finally, through a variety of tree traversals, we show how to apply TABA to other data structures than lists. A TABA-based function written in direct style makes full use of an ALGOL-like control stack and needs no heap allocation. Conversely, in a TABA-based function written in continuation-passing style and recursively defined over a data structure (traversed at call time), the continuation acts as an iterator over a second data structure (traversed at return time). In general, the TABA pattern saves one from accumulating intermediate data structures at call time.},
	number = {3},
	journal = {BRICS Report Series},
	author = {Danvy, Olivier and Goldberg, Mayer},
	year = {2005},
	file = {[PDF] brics.dk:files/2358/Danvy and Goldberg - 2005 - There and Back Again.pdf:application/pdf}
}

@phdthesis{mu_calculational_2003,
	type = {{PhD} {Thesis}},
	title = {A {Calculational} {Approach} to {Program} {Inversion}},
	school = {University of Oxford},
	author = {Mu, Shin-Cheng},
	year = {2003},
	file = {Fulltext:files/3391/Mu - 2003 - A Calculational Approach to Program Inversion.pdf:application/pdf;Fulltext:files/3393/Mu - A CALCULATIONAL APPROACH TO PROGRAM INVERSION.pdf:application/pdf;Fulltext:files/3395/Mu - 2003 - A Calculational Approach to Program Inversion.pdf:application/pdf;Fulltext:files/3398/Mu - 2003 - A Calculational Approach to Program Inversion.pdf:application/pdf;Fulltext:files/3400/Mu - A CALCULATIONAL APPROACH TO PROGRAM INVERSION.pdf:application/pdf;Fulltext:files/3402/Mu - 2003 - A calculational approach to program inversion.pdf:application/pdf;Snapshot:files/3390/Mu - 2003 - A Calculational Approach to Program Inversion.pdf:application/pdf;Snapshot:files/3392/Mu - A CALCULATIONAL APPROACH TO PROGRAM INVERSION.pdf:application/pdf;Snapshot:files/3394/Mu - 2003 - A Calculational Approach to Program Inversion.pdf:application/pdf;Snapshot:files/3396/OrderDetails.html:text/html;Snapshot:files/3397/Mu - 2003 - A Calculational Approach to Program Inversion.pdf:application/pdf;Snapshot:files/3399/Mu - A CALCULATIONAL APPROACH TO PROGRAM INVERSION.pdf:application/pdf;Snapshot:files/3401/Mu - 2003 - A calculational approach to program inversion.pdf:application/pdf}
}

@book{bird_pearls_2010,
	address = {New York, NY, USA},
	edition = {1st},
	title = {Pearls of {Functional} {Algorithm} {Design}},
	isbn = {978-0-521-51338-8},
	abstract = {Richard Bird takes a radically new approach to algorithm design, namely, design by calculation. These 30 short chapters each deal with a particular programming problem drawn from sources as diverse as games and puzzles, intriguing combinatorial tasks, and more familiar areas such as data compression and string matching. Each pearl starts with the statement of the problem expressed using the functional programming language Haskell, a powerful yet succinct language for capturing algorithmic ideas clearly and simply. The novel aspect of the book is that each solution is calculated from an initial formulation of the problem in Haskell by appealing to the laws of functional programming. Pearls of Functional Algorithm Design will appeal to the aspiring functional programmer, students and teachers interested in the principles of algorithm design, and anyone seeking to master the techniques of reasoning about programs in an equational style.},
	publisher = {Cambridge University Press},
	author = {Bird, Richard},
	year = {2010},
	note = {OCLC: ocn643322214},
	keywords = {Computer algorithms, Functional programming (Computer science)},
	file = {Bird - 2010 - Pearls of Functional Algorithm Design.pdf:files/3406/Bird - 2010 - Pearls of Functional Algorithm Design.pdf:application/pdf}
}

@inproceedings{bird_functional_2003,
	address = {New York, NY, USA},
	series = {Haskell '03},
	title = {Functional {Pearl} {Trouble} {Shared} is {Trouble} {Halved}},
	isbn = {978-1-58113-758-3},
	url = {http://doi.acm.org/10.1145/871895.871896},
	doi = {10.1145/871895.871896},
	abstract = {A nexus is a tree that contains shared nodes, nodes that have more than one incoming arc. Shared nodes are created in almost every functional program---for instance, when updating a purely functional data structure---though programmers are seldom aware of this. In fact, there are only a few algorithms that exploit sharing of nodes consciously. One example is constructing a tree in sublinear time. In this pearl we discuss an intriguing application of nexuses; we show that they serve admirably as memo structures featuring constant time access to memoized function calls. Along the way we encounter Boolean lattices and binomial trees.},
	urldate = {2018-02-22},
	booktitle = {Proceedings of the 2003 {ACM} {SIGPLAN} {Workshop} on {Haskell}},
	publisher = {ACM},
	author = {Bird, Richard and Hinze, Ralf},
	year = {2003},
	keywords = {Haskell, binomial trees, boolean lattices, memoization, purely functional data structures, sharing},
	pages = {1--6},
	file = {ACM Full Text PDF:files/3405/Bird and Hinze - 2003 - Functional Pearl Trouble Shared is Trouble Halved.pdf:application/pdf;Bird and Hinze - 2003 - Functional Pearl trouble shared is trouble halved.pdf:files/3319/Bird and Hinze - 2003 - Functional Pearl trouble shared is trouble halved.pdf:application/pdf}
}

@incollection{bird_hylomorphisms_2010,
	address = {New York, NY, USA},
	edition = {1st},
	title = {Hylomorphisms and nexuses},
	isbn = {978-0-521-51338-8},
	url = {http://www.cambridge.org/gb/academic/subjects/computer-science/programming-languages-and-applied-logic/pearls-functional-algorithm-design?format=HB&isbn=9780521513388},
	abstract = {Richard Bird takes a radically new approach to algorithm design, namely, design by calculation. These 30 short chapters each deal with a particular programming problem drawn from sources as diverse as games and puzzles, intriguing combinatorial tasks, and more familiar areas such as data compression and string matching. Each pearl starts with the statement of the problem expressed using the functional programming language Haskell, a powerful yet succinct language for capturing algorithmic ideas clearly and simply. The novel aspect of the book is that each solution is calculated from an initial formulation of the problem in Haskell by appealing to the laws of functional programming. Pearls of Functional Algorithm Design will appeal to the aspiring functional programmer, students and teachers interested in the principles of algorithm design, and anyone seeking to master the techniques of reasoning about programs in an equational style.},
	language = {English},
	booktitle = {Pearls of {Functional} {Algorithm} {Design}},
	publisher = {Cambridge University Press},
	author = {Bird, Richard},
	year = {2010},
	note = {OCLC: ocn643322214},
	keywords = {Computer algorithms, Functional programming (Computer science)},
	pages = {168--179}
}

@article{hutton_countdown_2002,
	title = {The {Countdown} {Problem}},
	volume = {12},
	issn = {0956-7968},
	url = {http://www.cs.nott.ac.uk/~pszgmh/countdown.pdf},
	doi = {10.1017/S0956796801004300},
	abstract = {We systematically develop a functional program that solves the countdown problem, a numbers game in which the aim is to construct arithmetic expressions satisfying certain constraints. Starting from a formal specification of the problem, we present a simple but inefficient program that solves the problem, and prove that this program is correct. We then use program fusion to calculate an equivalent but more efficient program, which is then further improved by exploiting arithmetic properties.},
	number = {6},
	urldate = {2018-03-08},
	journal = {J. Funct. Program.},
	author = {Hutton, Graham},
	month = nov,
	year = {2002},
	pages = {609--616},
	file = {Fulltext:files/3492/HUTTON - FUNCTIONAL PEARL The countdown problem.pdf:application/pdf}
}

@misc{tobin_sorting_2015,
	title = {Sorting with {Style}},
	url = {https://jtobin.io/sorting-with-style},
	language = {English},
	urldate = {2018-03-09},
	journal = {jtobin.io},
	author = {Tobin, Jared},
	month = dec,
	year = {2015},
	file = {Sorting with Style · jtobin.io:files/3495/sorting-with-style.html:text/html}
}

@misc{tobin_practical_2015,
	title = {Practical {Recursion} {Schemes}},
	url = {https://jtobin.io/practical-recursion-schemes},
	language = {English},
	urldate = {2018-03-09},
	journal = {jtobin.io},
	author = {Tobin, Jared},
	month = sep,
	year = {2015},
	file = {Practical Recursion Schemes · jtobin.io:files/3497/practical-recursion-schemes.html:text/html}
}

@misc{tobin_tour_2015,
	title = {A {Tour} of {Some} {Useful} {Recursive} {Types}},
	url = {https://jtobin.io/tour-of-some-recursive-types},
	language = {English},
	urldate = {2018-03-09},
	journal = {jtobin.io},
	author = {Tobin, Jared},
	month = dec,
	year = {2015},
	file = {A Tour of Some Useful Recursive Types · jtobin.io:files/3499/tour-of-some-recursive-types.html:text/html}
}

@article{steffen_table_2006,
	title = {Table {Design} in {Dynamic} {Programming}},
	volume = {204},
	issn = {0890-5401},
	url = {http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.85.601&rep=rep1&type=pdf},
	doi = {10.1016/j.ic.2006.02.006},
	abstract = {Dynamic Programming solves combinatorial optimization problems by recursive decomposition and tabulation of intermediate results. The first step in the design of a dynamic programming algorithm is to decide on the set of tables that will hold optimal solutions to subproblems. This step predetermines the shape of the dynamic programming recurrences as well as the asymptotic efficiency of the algorithm in time and space. We study dynamic programming in a formal framework where design of tables and problem decomposition can be done independently. Our main result shows that choosing a good table design for a given decomposition is an NP-complete problem. A heuristic or approximate approach is therefore needed to automate good table design. We report on a strategy that combines user annotation and a brute force algorithm, which is shown to perform well in a large application.},
	language = {en},
	number = {9},
	urldate = {2018-03-09},
	journal = {Information and Computation},
	author = {Steffen, Peter and Giegerich, Robert},
	month = sep,
	year = {2006},
	keywords = {dynamic programming, NP completeness, programming methodology, space-time trade-off},
	pages = {1325--1345},
	file = {Citeseer - Full Text PDF:files/3511/Steffen and Giegerich - 2006 - Table design in dynamic programming.pdf:application/pdf;Citeseer - Snapshot:files/3510/summary.html:text/html;Snapshot:files/3507/S0890540106000745.html:text/html}
}

@article{jones_linear-_1993,
	title = {Linear- time {Breadth}- first {Tree} {Algorithms}: {An} {Exercise} in the {Arithmetic} of {Folds} and {Zips}},
	shorttitle = {Linear- time {Breadth}- first {Tree} {Algorithms}},
	author = {Jones, Geraint and Gibbons, Jeremy},
	year = {1993}
}

@techreport{jones_linear-time_1993,
	title = {Linear-time breadth-first tree algorithms: {An} exercise in the arithmetic of folds and zips},
	shorttitle = {Linear-time breadth-first tree algorithms},
	abstract = {. This paper is about an application of the mathematics of the zip, reduce (fold) and accumulate (scan) operations on lists. It gives an account of the derivation of a linear-time breadth-first tree traversal algorithm, and of a subtle and efficient breadth-first tree labelling algorithm. Keywords. Derivation, functional programming, breadth-first, traversal, labelling. 1 Introduction  The algorithms which are developed in this paper relate trees to sequences in a way that respects the breadth-first ordering of the nodes of the tree: nodes nearer the root are earlier in the ordering, and nodes on the same level are ordered from left to right. We distinguish between finite and infinite sequences, which we call lists and  streams respectively. Lists of elements of type ff are modelled as the least solution  list.ff of the equation  list.ff = [ ] j ff :: list.ff  That is, the empty list [ ] has type list.ff , and if x has type ff and xs has type list.ff  then x :: xs has type list.ff . We...},
	institution = {Dept of Computer Science, University of Auckland},
	author = {Jones, Geraint and Gibbons, Jeremy},
	year = {1993},
	file = {Citeseer - Full Text PDF:files/3528/Jones and Gibbons - 1993 - Linear-time breadth-first tree algorithms An exer.pdf:application/pdf;Citeseer - Snapshot:files/3527/summary.html:text/html}
}

@misc{tobin_time_2016,
	title = {Time {Traveling} {Recursion} {Schemes}},
	url = {https://jtobin.io/time-traveling-recursion},
	language = {en},
	urldate = {2018-03-12},
	journal = {jtobin.io},
	author = {Tobin, Jared},
	month = feb,
	year = {2016},
	file = {Time Traveling Recursion Schemes · jtobin.io:files/3554/time-traveling-recursion.html:text/html}
}