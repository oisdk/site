
@article{kennedy_functional_1996,
	title = {Functional {Pearl}: {Drawing} {Trees}},
	volume = {6},
	shorttitle = {Functional {Pearl}},
	url = {https://www.microsoft.com/en-us/research/publication/functional-pearl-drawing-trees/},
	abstract = {This article describes the application of functional programming techniques to a problem previously studied by imperative programmers, that of drawing general trees automatically. We first consider the nature of the problem and the ideas behind its solution (due to Radack), independent of programming language implementation. We then describe a Standard ML program which reflects the …},
	urldate = {2016-09-24},
	journal = {Journal of Functional Programming},
	author = {Kennedy, Andrew},
	month = jan,
	year = {1996},
	keywords = {Diagrams, Haskell, Pretty Printing, Tree Drawing},
	file = {Full Text PDF:files/1359/Kennedy - 1996 - Functional Pearl Drawing Trees.pdf:application/pdf;Snapshot:files/950/functional-pearl-drawing-trees.html:text/html}
}

@inproceedings{ford_packrat_2002,
	title = {Packrat {Parsing}: {Simple}, {Powerful}, {Lazy}, {Linear} {Time}},
	volume = {37},
	shorttitle = {Packrat {Parsing}},
	url = {https://pdos.csail.mit.edu/papers/packrat-parsing:icfp02.pdf},
	urldate = {2016-10-04},
	publisher = {ACM},
	author = {Ford, Bryan},
	year = {2002},
	keywords = {Haskell, Parsing},
	pages = {36--47},
	file = {packrat-parsing-icfp02.pdf:files/1246/packrat-parsing-icfp02.pdf:application/pdf}
}

@article{baars_parsing_2004,
	title = {Parsing permutation phrases},
	volume = {14},
	url = {http://www.cs.ox.ac.uk/people/jeremy.gibbons/wg21/meeting56/loeh-paper.pdf},
	number = {6},
	urldate = {2016-10-04},
	journal = {Journal of Functional Programming},
	author = {Baars, Arthur I. and Löh, Andres and Swierstra, S. Doaitse},
	year = {2004},
	keywords = {Haskell, Parsing},
	pages = {635--646},
	file = {loeh-paper.pdf:files/965/loeh-paper.pdf:application/pdf}
}

@inproceedings{jansson_polytypic_1999,
	title = {Polytypic {Compact} {Printing} and {Parsing}},
	url = {http://www.cse.chalmers.se/~patrikj/poly/dc/},
	abstract = {A generic compact printer and a corresponding parser are constructed. These programs transform values of any regular datatype to and from a bit stream. The algorithms are constructed along with a proof that printing followed by parsing is the identity. Since the binary representation is very compact, the printer can be used for compressing data — possibly supplemented with some standard algorithm for compressing bit streams. The compact printer and the parser are described in the polytypic Haskell extension PolyP.},
	urldate = {2016-10-04},
	booktitle = {Proceedings of the 8th {European} {Symposium} on {Programming} {Languages} and {Systems}},
	publisher = {Springer-Verlag},
	author = {Jansson, Patrik and Jeuring, Johan},
	year = {1999},
	keywords = {Arrows, Haskell, Parsing, Pretty Printing},
	file = {[PDF] diku.dk:files/972/Jansson and Jeuring - Polytypic Compact Printing and Parsing.pdf:application/pdf}
}

@article{ramsey_unparsing_1998,
	title = {Unparsing {Expressions} {With} {Prefix} and {Postfix} {Operators}},
	volume = {28},
	url = {http://www.cs.tufts.edu/%7Enr/pubs/unparse-abstract.html},
	abstract = {Automatic generation of computer programs from high-level specifications is a well-known technique, which has been used to create scanners, parsers, code generators, tree rewriters, packet filters, dialogue handlers, machine-code recognizers, and other tools. To make it easier to debug an application generator, and to help convince prospective users that the generated code can be trusted, the generated code should be as idiomatic and readable as possible. It is therefore desirable, and sometimes essential, that the generated code use infix, prefix, and postfix operators, and that they be presented without unnecessary parentheses. This paper presents a method of automatically parenthesizing expressions that use prefix, postfix, and implicit operators; the method is compatible with automatic prettyprinting. The paper also shows how to parse expressions that use such operators. The parsing algorithm can be used even if operator precedences are not known at compile time, which means that it can be used with an arbitrary number of user-defined precedences.},
	number = {12},
	urldate = {2017-03-30},
	journal = {Software—Practice \& Experience},
	author = {Ramsey, Norman},
	year = {1998},
	pages = {1327--1356},
	file = {Citeseer - Full Text PDF:files/2257/Ramsey - 1998 - Unparsing Expressions With Prefix and Postfix Oper.pdf:application/pdf;Citeseer - Snapshot:files/2258/summary.html:text/html;[PDF] psu.edu:files/2241/Ramsey - 1998 - Unparsing expressions with prefix and postfix oper.pdf:application/pdf;[PDF] semanticscholar.org:files/2246/Ramsey - 1998 - Unparsing Expressions With Prefix and Postfix Oper.pdf:application/pdf;[PDF] semanticscholar.org:files/2249/Ramsey - 1997 - Unparsing Expressions With Pre x and Postfix Opera.pdf:application/pdf;Snapshot:files/2252/citation.html:text/html;Snapshot:files/2253/citation.html:text/html;Snapshot:files/2254/full.html:text/html}
}