
@article{allison_circular_2006,
  title = {Circular {{Programs}} and {{Self}}-{{Referential Structures}}},
  author = {Allison, Lloyd},
  year = {2006},
  month = oct,
  volume = {19},
  pages = {99--109},
  issn = {1097-024X},
  doi = {10.1002/spe.4380190202},
  url = {http://users.monash.edu/~lloyd/tildeFP/1989SPE/},
  urldate = {2018-06-01},
  abstract = {A circular program creates a data structure whose computation depends upon itself or refers to itself. The technique is used to implement the classic data structures circular and doubly-linked lists, threaded trees and queues, in a functional programming language. These structures are normally thought to require updatable variables found in imperative languages. For example, a functional program to perform the breadth-first traversal of a tree is given. Some of the examples result in circular data structures when evaluated. Some examples are particularly space-efficient by avoiding the creation of intermediate temporary structures which would otherwise later become garbage. Lastly, the technique can be applied in an imperative language to give an elegant program.},
  journal = {Software: Practice and Experience},
  language = {en},
  number = {2}
}

@inproceedings{berger_martin_2019,
  ids = {bergerMartinHofmannCase2018},
  title = {Martin {{Hofmann}}'s {{Case}} for {{Non}}-{{Strictly Positive Data Types}}},
  booktitle = {24th International Conference on Types for Proofs and Programs ({{TYPES}} 2018)},
  author = {Berger, Ulrich and Matthes, Ralph and Setzer, Anton},
  editor = {Dybjer, Peter and Santo, Jos{\'e} Esp{\'i}rito and Pinto, Lu{\'i}s},
  year = {2019},
  volume = {130},
  pages = {22},
  publisher = {{Schloss Dagstuhl\textendash Leibniz-Zentrum fuer Informatik}},
  address = {{Dagstuhl, Germany}},
  issn = {1868-8969},
  doi = {10.4230/LIPIcs.TYPES.2018.1},
  url = {http://drops.dagstuhl.de/opus/volltexte/2019/11405},
  abstract = {We describe the breadth-first traversal algorithm by Martin Hofmann that uses a non-strictly positive data type and carry out a simple verification in an extensional setting. Termination is shown by implementing the algorithm in the strongly normalising extension of system F by Mendler-style recursion. We then analyze the same algorithm by alternative verifications first in an intensional setting using a non-strictly positive inductive definition (not just a non-strictly positive data type), and subsequently by two different algebraic reductions. The verification approaches are compared in terms of notions of simulation and should elucidate the somewhat mysterious algorithm and thus make a case for other uses of non-strictly positive data types. Except for the termination proof, which cannot be formalised in Coq, all proofs were formalised in Coq and some of the algorithms were implemented in Agda and Haskell.},
  isbn = {978-3-95977-106-1},
  language = {en},
  series = {Leibniz International Proceedings in Informatics ({{LIPIcs}})},
  urn = {urn:nbn:de:0030-drops-114052}
}

@misc{coquand_agda_2013,
  title = {[{{Agda}}] Defining Coinductive Types},
  author = {Coquand, Thierry},
  year = {2013},
  month = dec,
  url = {https://lists.chalmers.se/pipermail/agda/2013/006189.html},
  urldate = {2021-03-13}
}

@inproceedings{coquand_inductively_1990,
  title = {Inductively Defined Types},
  booktitle = {{{COLOG}}-88},
  author = {Coquand, Thierry and Paulin, Christine},
  editor = {{Martin-L{\"o}f}, Per and Mints, Grigori},
  year = {1990},
  pages = {50--66},
  publisher = {{Springer}},
  address = {{Berlin, Heidelberg}},
  doi = {10.1007/3-540-52335-9_47},
  isbn = {978-3-540-46963-6},
  keywords = {Computation Rule,Elimination Rule,Inductive Type,Positive Operator,Type Theory},
  language = {en},
  series = {Lecture {{Notes}} in {{Computer Science}}}
}

@inproceedings{ghani_monadic_2005,
  ids = {ghani_monadic_2005a,ghani_monadic_2005b},
  title = {Monadic Augment and Generalised Short Cut Fusion},
  booktitle = {Proceedings of the Tenth {{ACM SIGPLAN}} International Conference on {{Functional}} Programming},
  author = {Ghani, Neil and Johann, Patricia and Uustalu, Tarmo and Vene, Varmo},
  year = {2005},
  month = sep,
  pages = {294--305},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/1086365.1086403},
  url = {https://doi.org/10.1145/1086365.1086403},
  urldate = {2020-12-31},
  abstract = {Monads are commonplace programming devices that are used to uniformly structure computations with effects such as state, exceptions, and I/O. This paper further develops the monadic programming paradigm by investigating the extent to which monadic computations can be optimised by using generalisations of short cut fusion to eliminate monadic structures whose sole purpose is to "glue together" monadic program components.We make several contributions. First, we show that every inductive type has an associated build combinator and an associated short cut fusion rule. Second, we introduce the notion of an inductive monad to describe those monads that give rise to inductive types, and we give examples of such monads which are widely used in functional programming. Third, we generalise the standard augment combinators and cata/augment fusion rules for algebraic data types to types induced by inductive monads. This allows us to give the first cata/augment rules for some common data types, such as rose trees. Fourth, we demonstrate the practical applicability of our generalisations by providing Haskell implementations for all concepts and examples in the paper. Finally, we offer deep theoretical insights by showing that the augment combinators are monadic in nature, and thus that our cata/build and cata/augment rules are arguably the best generally applicable fusion rules obtainable.},
  isbn = {978-1-59593-064-4},
  keywords = {augment,bind,build,monads,short cut fusion},
  series = {{{ICFP}} '05}
}

@article{hedges_selection_2015,
  title = {The Selection Monad as a {{CPS}} Transformation},
  author = {Hedges, Jules},
  year = {2015},
  month = mar,
  url = {http://arxiv.org/abs/1503.06061},
  urldate = {2020-02-07},
  abstract = {A computation in the continuation monad returns a final result given a continuation, ie. it is a function with type \$(X \textbackslash to R) \textbackslash to R\$. If we instead return the intermediate result at \$X\$ then our computation is called a selection function. Selection functions appear in diverse areas of mathematics and computer science (especially game theory, proof theory and topology) but the existing literature does not heavily emphasise the fact that the selection monad is a CPS translation. In particular it has so far gone unnoticed that the selection monad has a call/cc-like operator with interesting similarities and differences to the usual call/cc, which we explore experimentally using Haskell. Selection functions can be used whenever we find the intermediate result more interesting than the final result. For example a SAT solver computes an assignment to a boolean function, and then its continuation decides whether it is a satisfying assignment, and we find the assignment itself more interesting than the fact that it is or is not satisfying. In game theory we find the move chosen by a player more interesting than the outcome that results from that move. The author and collaborators are developing a theory of games in which selection functions are viewed as generalised notions of rationality, used to model players. By realising that strategic contexts in game theory are examples of continuations we can see that classical game theory narrowly misses being in CPS, and that a small change of viewpoint yields a theory of games that is better behaved, and especially more compositional.},
  archiveprefix = {arXiv},
  eprint = {1503.06061},
  journal = {arXiv:1503.06061 [cs]},
  keywords = {Computer Science - Programming Languages},
  primaryclass = {cs}
}

@misc{hofmann_non_1993,
  title = {Non {{Strictly Positive Datatypes}} in {{System F}}},
  author = {Hofmann, Martin},
  year = {1993},
  month = feb,
  url = {https://www.seas.upenn.edu/~sweirich/types/archive/1993/msg00027.html},
  urldate = {2020-01-27},
  collaborator = {{types@uk.ac.gla.dcs}}
}

@misc{kmett_hyperfunctions_2015,
  title = {Hyperfunctions: {{Hyperfunctions}}},
  shorttitle = {Hyperfunctions},
  author = {Kmett, Edward},
  year = {2015},
  month = jun,
  url = {https://hackage.haskell.org/package/hyperfunctions},
  urldate = {2021-03-13}
}

@unpublished{krstic_category_2000,
  title = {A {{Category}} of {{Hyperfunctions}}},
  author = {Krstic, Sava and Launchbury, John},
  year = {2000},
  url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.36.2421},
  abstract = {Introduction  In the usual mathematical practice, functions whose arguments are functions are commonplace. Functions whose arguments are functions whose arguments are functions are rarer, and everything beyond the third level is exotic. Innitely nested function spaces like  H(A;B) = ((((   ! A) ! B) ! A) ! B)  cannot exist for cardinality reasons. In domain theory, however, such innite expressions can be given a precise meaning. For suitable categories D, including all reasonable cartesian closed categories of pointed domains, the theory provides canonical solutions in D to recursive domain equations, and our H(A;B) can be dened as the canonical solution of the equation X    = (X ! A) ! B. Textbook expos}
}

@article{launchbury_coroutining_2013,
  title = {Coroutining {{Folds}} with {{Hyperfunctions}}},
  author = {Launchbury, J. and Krstic, S. and Sauerwein, T. E.},
  year = {2013},
  month = sep,
  volume = {129},
  pages = {121--135},
  issn = {2075-2180},
  doi = {10.4204/EPTCS.129.9},
  url = {http://arxiv.org/abs/1309.5135},
  urldate = {2020-12-30},
  abstract = {Fold functions are a general mechanism for computing over recursive data structures. First-order folds compute results bottom-up. With higher-order folds, computations that inherit attributes from above can also be expressed. In this paper, we explore folds over a form of recursive higher-order function, called hyperfunctions, and show that hyperfunctions allow fold computations to coroutine across data structures, as well as compute bottom up and top down. We use the compiler technique of foldr-build as an exemplar to show how hyperfunctions can be used.},
  archiveprefix = {arXiv},
  eprint = {1309.5135},
  journal = {Electron. Proc. Theor. Comput. Sci.},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages,D.1.1}
}

@techreport{launchbury_zip_2000,
  ids = {launchbury_zip_2000a},
  title = {Zip {{Fusion}} with {{Hyperfunctions}}},
  author = {Launchbury, John and Krstic, Sava and Sauerwein, Timothy E.},
  year = {2000},
  url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.36.4961},
  abstract = {Automatic removal of intermediate structures has been...}
}

@techreport{pieters_faster_2018,
  title = {Faster Coroutine Pipelines: A Reconstruction (Extended Version)},
  shorttitle = {Faster Coroutine Pipelines},
  author = {Pieters, Ruben and Schrijvers, Tom},
  year = {2018},
  month = nov,
  institution = {{Department of Computer Science, KU Leuven; Leuven. Belgium}},
  url = {http://www.cs.kuleuven.be/publicaties/rapporten/cw/CW715.pdf},
  urldate = {2021-02-23},
  abstract = {Spivey has recently presented a novel functional representation that supports the efficient composition, or merging, of coroutine pipelines for processing streams of data. This representation was inspired by Shivers and Might's three-continuation approach and is shown to be equivalent to a simple yet inefficient executable specification. Unfortunately, neither Shivers and Might's original work nor the equivalence proof sheds much light on the underlying principles allowing the derivation of this efficient representation from its specification. This paper gives the missing insight by reconstructing a systematic derivation in terms of known transformation steps from the simple specification to the efficient representation. This derivation sheds light on the limitations of the representation and on its applicability to other settings. In particular, it has enabled us to obtain a similar representation for pipes featuring two-way communication, similar to the Haskell pipes library. Our benchmarks confirm that this two-way representation retains the same improved performance characteristics.},
  language = {en}
}

@inproceedings{pieters_faster_2019,
  title = {Faster {{Coroutine Pipelines}}: {{A Reconstruction}}},
  shorttitle = {Faster {{Coroutine Pipelines}}},
  booktitle = {Practical {{Aspects}} of {{Declarative Languages}}},
  author = {Pieters, Ruben P. and Schrijvers, Tom},
  editor = {Alferes, Jos{\'e} J{\'u}lio and Johansson, Moa},
  year = {2019},
  pages = {133--149},
  publisher = {{Springer International Publishing}},
  address = {{Cham}},
  doi = {10.1007/978-3-030-05998-9_9},
  url = {https://people.cs.kuleuven.be/~tom.schrijvers/portfolio/padl2019.html},
  abstract = {Spivey has recently presented a novel functional representation that supports the efficient composition, or merging, of coroutine pipelines for processing streams of data. This representation was inspired by Shivers and Might's three-continuation approach and is shown to be equivalent to a simple yet inefficient executable specification. Unfortunately, neither Shivers and Might's original work nor the equivalence proof sheds much light on the underlying principles allowing the derivation of this efficient representation from its specification.This paper gives the missing insight by reconstructing a systematic derivation in terms of known transformation steps from the simple specification to the efficient representation. This derivation sheds light on the limitations of the representation and on its applicability to other settings. In particular, it has enabled us to obtain a similar representation for pipes featuring two-way communication, similar to the Haskell pipes library. Our benchmarks confirm that this two-way representation retains the same improved performance characteristics.},
  isbn = {978-3-030-05998-9},
  keywords = {Algebra,Stream processing,Structured recursion},
  language = {en},
  series = {Lecture {{Notes}} in {{Computer Science}}}
}

@misc{piponi_profunctors_2011,
  title = {Profunctors in {{Haskell}}},
  shorttitle = {A {{Neighborhood}} of {{Infinity}}},
  author = {Piponi, Dan},
  year = {2011},
  month = jul,
  url = {http://blog.sigfpe.com/2011/07/profunctors-in-haskell.html},
  urldate = {2021-03-13},
  journal = {A Neighborhood of Infinity},
  language = {en}
}

@misc{sjoberg_why_2015,
  title = {Why Must Inductive Types Be Strictly Positive?},
  author = {Sj{\"o}berg, Vilhelm},
  year = {2015},
  month = apr,
  url = {https://vilhelms.github.io/posts/why-must-inductive-types-be-strictly-positive/},
  urldate = {2021-03-13},
  journal = {Code and stuff},
  language = {en}
}

@article{smith_lloyd_2009,
  title = {Lloyd {{Allison}}'s {{Corecursive Queues}}: {{Why Continuations Matter}}},
  author = {Smith, Leon P},
  year = {2009},
  month = jul,
  volume = {14},
  pages = {28},
  url = {https://meldingmonads.files.wordpress.com/2009/06/corecqueues.pdf},
  abstract = {In a purely functional setting, real-time queues are traditionally thought to be much harder to implement than either real-time stacks or amortized O(1) queues. In ``Circular Programs and Self-Referential Structures,'' [1] Lloyd Allison uses corecursion to implement a queue by defining a lazy list in terms of itself. This provides a simple, efficient, and attractive implementation of real-time queues.},
  journal = {The Monad.Reader},
  language = {en},
  number = {14}
}

@article{spivey_faster_2017,
  title = {Faster Coroutine Pipelines},
  author = {Spivey, Michael},
  year = {2017},
  month = aug,
  volume = {1},
  pages = {5:1--5:23},
  doi = {10.1145/3110249},
  url = {https://doi.org/10.1145/3110249},
  urldate = {2020-01-31},
  abstract = {Coroutine pipelines provide an attractive structuring mechanism for complex programs that process streams of data, with the advantage over lazy streams that both ends of a pipeline may interact with the I/O system, as may processes in the middle. Two popular Haskell libraries, Pipes and Conduit, support such pipelines. In both libraries, pipelines are implemented in a direct style by combining a free monad of communication events with an interpreter for (pseudo-)parallel composition that interleaves the events of its argument processes. These implementations both suffer from a slow-down when processes are deeply nested in sequence or in parallel. We propose an alternative implementation of pipelines based on continuations that does not suffer from this slow-down. What is more, the implementation is significantly faster on small, communication-intensive examples even where they do not suffer from the slow-down, and comparable in speed with similar programs based on lazy streams. We also show that the continuation-based implementation may be derived from the direct-style implementation by algebraic reasoning.},
  journal = {Proc. ACM Program. Lang.},
  keywords = {Pipelines},
  number = {ICFP}
}


