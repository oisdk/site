
@inproceedings{persson_generic_2011,
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Generic {Monadic} {Constructs} for {Embedded} {Languages}},
	copyright = {Â©2012 Springer-Verlag Berlin Heidelberg},
	isbn = {978-3-642-34406-0 978-3-642-34407-7},
	url = {http://www.cse.chalmers.se/~emax/documents/persson2011generic.pdf},
	doi = {10.1007/978-3-642-34407-7_6},
	abstract = {We present a library of generic monadic constructs for embedded languages. It is an extension of Syntactic, a Haskell library for defining and processing generic abstract syntax. Until now, Syntactic has been mostly suited to implement languages based on pure, side effect free, expressions. The presented extension allows the pure expressions to also contain controlled side effects, enabling the representation of expressions that rely on destructive updates for efficiency. We demonstrate the usefulness of the extension by giving examples from the embedded language Feldspar which is implemented using Syntactic.},
	language = {en},
	urldate = {2017-03-03},
	booktitle = {Implementation and {Application} of {Functional} {Languages}},
	publisher = {Springer Berlin Heidelberg},
	author = {Persson, Anders and Axelsson, Emil and Svenningsson, Josef},
	editor = {Gill, Andy and Hage, Jurriaan},
	month = oct,
	year = {2011},
	keywords = {Logics and Meanings of Programs, Mathematical Logic and Formal Languages, Programming Languages, Compilers, Interpreters, Programming Techniques, Software Engineering},
	pages = {85--99},
	file = {[PDF] chalmers.se:files/1698/Persson et al. - 2011 - Generic monadic constructs for embedded languages.pdf:application/pdf;Snapshot:files/1699/978-3-642-34407-7_6.html:text/html;Snapshot:files/1702/978-3-642-34407-7_6.html:text/html}
}

@article{jones_deconstraining_2012,
	title = {Deconstraining {DSLs}},
	volume = {47},
	url = {http://dl.acm.org/citation.cfm?id=2364571},
	number = {9},
	urldate = {2017-03-08},
	journal = {ACM SIGPLAN Notices},
	author = {Jones, Will and Field, Tony and Allwood, Tristan},
	year = {2012},
	pages = {299--310},
	file = {[PDF] ic.ac.uk:files/1729/Field and Allwood - 2012 - Deconstraining DSLs.pdf:application/pdf;Snapshot:files/1727/citation.html:text/html}
}

@phdthesis{jones_generic_2013,
	title = {Generic constraints for type-safe embedded programming},
	url = {https://pdfs.semanticscholar.org/7647/e066e391fc24a9bf1fb1673409291e5b3539.pdf},
	urldate = {2017-03-08},
	school = {Imperial College London},
	author = {Jones, Will},
	year = {2013},
	file = {[PDF] semanticscholar.org:files/1735/Jones - Generic Constraints for Type-Safe Embedded Program.pdf:application/pdf;Snapshot:files/1738/OrderDetails.html:text/html;Snapshot:files/1739/summary.html:text/html}
}

@inproceedings{sculthorpe_constrained-monad_2013,
	address = {New York, NY, USA},
	series = {{ICFP} '13},
	title = {The {Constrained}-monad {Problem}},
	isbn = {978-1-4503-2326-0},
	url = {http://ku-fpg.github.io/files/Sculthorpe-13-ConstrainedMonad.pdf},
	doi = {10.1145/2500365.2500602},
	abstract = {In Haskell, there are many data types that would form monads were it not for the presence of type-class constraints on the operations on that data type. This is a frustrating problem in practice, because there is a considerable amount of support and infrastructure for monads that these data types cannot use. Using several examples, we show that a monadic computation can be restructured into a normal form such that the standard monad class can be used. The technique is not specific to monads, and we show how it can also be applied to other structures, such as applicative functors. One significant use case for this technique is domain-specific languages, where it is often desirable to compile a deep embedding of a computation to some other language, which requires restricting the types that can appear in that computation.},
	urldate = {2017-03-08},
	booktitle = {Proceedings of the 18th {ACM} {SIGPLAN} {International} {Conference} on {Functional} {Programming}},
	publisher = {ACM},
	author = {Sculthorpe, Neil and Bracker, Jan and Giorgidze, George and Gill, Andy},
	year = {2013},
	keywords = {class constraints, class constraints, deep embeddings, deep embeddings, HASKELL, Haskell, monads, monads},
	pages = {287--298},
	file = {Sculthorpe-13-ConstrainedMonad.pdf:files/1706/Sculthorpe-13-ConstrainedMonad.pdf:application/pdf}
}