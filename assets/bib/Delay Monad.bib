
@article{spivey_algebras_2009,
  title = {Algebras for Combinatorial Search},
  volume = {19},
  issn = {1469-7653, 0956-7968},
  doi = {10.1017/S0956796809007321},
  abstract = {AbstractCombinatorial search strategies including depth-first, breadth-first and depth-bounded search are shown to be different implementations of a common algebraic specification that emphasizes the compositionality of the strategies. This specification is placed in a categorical setting that combines algebraic specifications and monads.},
  number = {3-4},
  urldate = {2017-10-13},
  url = {https://pdfs.semanticscholar.org/db3e/373bb6e7e7837ebc524da0a25903958554ed.pdf},
  journal = {Journal of Functional Programming},
  author = {Spivey, J. Michael},
  month = jul,
  year = {2009},
  pages = {469-487},
  file = {/Users/doisinkidney/Zotero/storage/RJBV6ADB/373bb6e7e7837ebc524da0a25903958554ed.pdf;/Users/doisinkidney/Zotero/storage/HVBMPBM2/AB57FF99CEA76C1C31A336B560D6FD3C.html}
}

@techreport{jones_linear-time_1993,
  title = {Linear-Time {{Breadth}}-First {{Tree Algorithms}}: {{An Exercise}} in the {{Arithmetic}} of {{Folds}} and {{Zips}}},
  shorttitle = {Linear-Time Breadth-First Tree Algorithms},
  abstract = {This paper is about an application of the mathematics of the zip, reduce (fold) and accumulate (scan) operations on lists. It gives an account of the derivation of a linear-time breadth-first tree traversal algorithm, and of a subtle and efficient breadth-first tree labelling algorithm.},
  number = {71},
  url = {http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/linear.ps.gz},
  institution = {{Dept of Computer Science, University of Auckland}},
  author = {Jones, Geraint and Gibbons, Jeremy},
  month = may,
  year = {1993},
  file = {/Users/doisinkidney/Zotero/storage/DWNSFLCU/Jones and Gibbons - 1993 - Linear-time Breadth-first Tree Algorithms An Exer.pdf;/Users/doisinkidney/Zotero/storage/L3FJW23Y/Jones and Gibbons - 1993 - Linear-time breadth-first tree algorithms An exer.pdf;/Users/doisinkidney/Zotero/storage/FBMN8FSQ/summary.html;/Users/doisinkidney/Zotero/storage/MN84D7XS/summary.html}
}

@article{spivey_faster_2017,
  title = {Faster Coroutine Pipelines},
  volume = {1},
  issn = {24751421},
  doi = {10.1145/3110249},
  language = {en},
  number = {ICFP},
  urldate = {2018-06-10},
  url = {http://dl.acm.org/citation.cfm?doid=3136534.3110249},
  journal = {Proceedings of the ACM on Programming Languages},
  author = {Spivey, Michael},
  month = aug,
  year = {2017},
  pages = {1-23},
  file = {/Users/doisinkidney/Zotero/storage/86UE6L7N/Spivey - 2017 - Faster coroutine pipelines.pdf}
}

@misc{mcbride_time_2009,
  title = {Time Flies like an Applicative Functor},
  language = {en-US},
  urldate = {2018-06-18},
  url = {https://mazzo.li/epilogue/index.html\%3Fp=186.html},
  journal = {Epilogue for Epigram},
  author = {McBride, Conor},
  month = jun,
  year = {2009},
  file = {/Users/doisinkidney/Zotero/storage/GSU4XAFN/index.htmlp=186.html}
}

@article{bizjak_step-indexed_2015,
  archivePrefix = {arXiv},
  eprinttype = {arxiv},
  eprint = {1501.02623},
  primaryClass = {cs},
  title = {Step-{{Indexed Logical Relations}} for {{Probability}} (Long Version)},
  volume = {9034},
  doi = {10.1007/978-3-662-46678-0_18},
  abstract = {It is well-known that constructing models of higher-order probabilistic programming languages is challenging. We show how to construct step-indexed logical relations for a probabilistic extension of a higher-order programming language with impredicative polymorphism and recursive types. We show that the resulting logical relation is sound and complete with respect to the contextual preorder and, moreover, that it is convenient for reasoning about concrete program equivalences. Finally, we extend the language with dynamically allocated first-order references and show how to extend the logical relation to this language. We show that the resulting relation remains useful for reasoning about examples involving both state and probabilistic choice.},
  urldate = {2018-06-18},
  url = {http://arxiv.org/abs/1501.02623},
  journal = {arXiv:1501.02623 [cs]},
  author = {Bizjak, Ale{\v s} and Birkedal, Lars},
  year = {2015},
  keywords = {Computer Science - Logic in Computer Science},
  pages = {279-294},
  file = {/Users/doisinkidney/Zotero/storage/8GIKCFEI/Bizjak and Birkedal - 2015 - Step-Indexed Logical Relations for Probability (lo.pdf;/Users/doisinkidney/Zotero/storage/QPDV794N/1501.html}
}

@article{atkey_interleaving_2015,
  title = {Interleaving Data and Effects},
  volume = {25},
  issn = {0956-7968, 1469-7653},
  doi = {10.1017/S0956796815000209},
  abstract = {The study of programming with and reasoning about inductive datatypes such as lists and trees has benefited from the simple categorical principle of initial algebras. In initial algebra semantics, each inductive datatype is represented by an initial f -algebra for an appropriate functor f . The initial algebra principle then supports the straightforward derivation of definitional principles and proof principles for these datatypes. This technique has been expanded to a whole methodology of structured functional programming, often called origami programming.},
  language = {en},
  urldate = {2018-06-19},
  url = {https://bentnib.org/interleaving.html},
  journal = {Journal of Functional Programming},
  author = {Atkey, Robert and Johann, Patricia},
  year = {2015},
  file = {/Users/doisinkidney/Zotero/storage/GAGZ4AAX/Atkey and Johann - 2015 - Interleaving data and effects.pdf}
}

@article{blazevic_coroutine_2011,
  title = {Coroutine {{Pipelines}}},
  volume = {19},
  abstract = {The basic idea of trampoline-style execution is well known and has already been explored multiple times, every time leading in a different direction. The recent popularity of iteratees leads me to believe that the time has come for yet another expedition. If you're not inclined to explore this territory on your own, the monad- coroutine and SCC packages [1, 2] provide a trodden path.},
  language = {en},
  number = {19},
  url = {https://themonadreader.files.wordpress.com/2011/10/issue19.pdf},
  journal = {The Monad.Reader},
  author = {Bla{\v z}evi\'c, Mario},
  month = aug,
  year = {2011},
  pages = {29-50},
  file = {/Users/doisinkidney/Zotero/storage/RI7EZJ4J/Blažević - 2018 - Coroutine Pipelines.pdf}
}

@inproceedings{harrison_essence_2006,
  address = {Berlin, Heidelberg},
  series = {AMAST'06},
  title = {The {{Essence}} of {{Multitasking}}},
  isbn = {978-3-540-35633-2},
  doi = {10.1007/11784180_14},
  abstract = {This article demonstrates how a powerful and expressive abstraction from concurrency theory\textemdash{}monads of resumptions\textemdash{}plays a dual r\^ole as a programming tool for concurrent applications. The article demonstrates how a wide variety of typical OS behaviors may be specified in terms of resumption monads known heretofore exclusively in the literature of programming language semantics. We illustrate the expressiveness of the resumption monad with the construction of an exemplary multitasking kernel in the pure functional language Haskell.},
  urldate = {2018-06-19},
  url = {http://dx.doi.org/10.1007/11784180_14},
  booktitle = {Proceedings of the 11th {{International Conference}} on {{Algebraic Methodology}} and {{Software Technology}}},
  publisher = {{Springer-Verlag}},
  author = {Harrison, William L.},
  year = {2006},
  pages = {158--172}
}

@incollection{hutchison_essence_2006,
  address = {Berlin, Heidelberg},
  title = {The {{Essence}} of {{Multitasking}}},
  volume = {4019},
  isbn = {978-3-540-35633-2 978-3-540-35636-3},
  abstract = {This article demonstrates how a powerful and expressive abstraction from concurrency theory\textemdash{}monads of resumptions\textemdash{}plays a dual r\textasciicircum{}ole as a programming tool for concurrent applications. The article demonstrates how a wide variety of typical OS behaviors may be specified in terms of resumption monads known heretofore exclusively in the literature of programming language semantics. We illustrate the expressiveness of the resumption monad with the construction of an exemplary multitasking kernel in the pure functional language Haskell.},
  language = {en},
  urldate = {2018-06-19},
  url = {http://link.springer.com/10.1007/11784180_14},
  booktitle = {Algebraic {{Methodology}} and {{Software Technology}}},
  publisher = {{Springer Berlin Heidelberg}},
  author = {Harrison, William L.},
  editor = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Dough and Vardi, Moshe Y. and Weikum, Gerhard and Johnson, Michael and Vene, Varmo},
  year = {2006},
  pages = {158-172},
  file = {/Users/doisinkidney/Zotero/storage/F5R7QPXQ/Harrison - 2006 - The Essence of Multitasking.pdf},
  doi = {10.1007/11784180_14}
}

@inproceedings{severi_light_2017,
  archivePrefix = {arXiv},
  eprinttype = {arxiv},
  eprint = {1801.00285},
  series = {Lecture Notes in Computer Science},
  title = {A {{Light Modality}} for {{Recursion}}},
  isbn = {978-3-662-54457-0 978-3-662-54458-7},
  doi = {10.1007/978-3-662-54458-7_29},
  abstract = {We investigate a modality for controlling the behaviour of recursive functional programs on infinite structures which is completely silent in the syntax. The latter means that programs do not contain ``marks'' showing the application of the introduction and elimination rules for the modality. This shifts the burden of controlling recursion from the programmer to the compiler.To do this, we introduce a typed lambda calculus \`a la Curry with a silent modality and guarded recursive types. The typing discipline guarantees normalisation and can be transformed into an algorithm which infers the type of a program.},
  language = {en},
  urldate = {2018-06-19},
  url = {http://arxiv.org/abs/1801.00285},
  booktitle = {Foundations of {{Software Science}} and {{Computation Structures}}},
  publisher = {{Springer, Berlin, Heidelberg}},
  author = {Severi, Paula},
  month = apr,
  year = {2017},
  keywords = {Computer Science - Programming Languages,Computer Science - Logic in Computer Science},
  pages = {499-516},
  file = {/Users/doisinkidney/Zotero/storage/AMMU23V2/Severi - 2017 - A Light Modality for Recursion.pdf;/Users/doisinkidney/Zotero/storage/BNLTX6LG/Severi - 2017 - A Light Modality for Recursion.pdf;/Users/doisinkidney/Zotero/storage/2YKTA3KU/1801.html;/Users/doisinkidney/Zotero/storage/LXIKF3P8/1801.html;/Users/doisinkidney/Zotero/storage/V4RLXQ9M/978-3-662-54458-7_29.html}
}

@inproceedings{altenkirch_partiality_2017,
  series = {Lecture Notes in Computer Science},
  title = {Partiality, {{Revisited}}},
  isbn = {978-3-662-54457-0 978-3-662-54458-7},
  doi = {10.1007/978-3-662-54458-7_31},
  abstract = {Capretta's delay monad can be used to model partial computations, but it has the ``wrong'' notion of built-in equality, strong bisimilarity. An alternative is to quotient the delay monad by the ``right'' notion of equality, weak bisimilarity. However, recent work by Chapman et al. suggests that it is impossible to define a monad structure on the resulting construction in common forms of type theory without assuming (instances of) the axiom of countable choice.Using an idea from homotopy type theory\textemdash{}a higher inductive-inductive type\textemdash{}we construct a partiality monad without relying on countable choice. We prove that, in the presence of countable choice, our partiality monad is equivalent to the delay monad quotiented by weak bisimilarity. Furthermore we outline several applications.},
  language = {en},
  urldate = {2018-06-19},
  url = {https://link.springer.com/chapter/10.1007/978-3-662-54458-7_31},
  booktitle = {Foundations of {{Software Science}} and {{Computation Structures}}},
  publisher = {{Springer, Berlin, Heidelberg}},
  author = {Altenkirch, Thorsten and Danielsson, Nils Anders and Kraus, Nicolai},
  month = apr,
  year = {2017},
  pages = {534-549},
  file = {/Users/doisinkidney/Zotero/storage/5NKZK8MQ/978-3-662-54458-7_31.html}
}

@incollection{esparza_partiality_2017-1,
  address = {Berlin, Heidelberg},
  title = {Partiality, {{Revisited}}},
  volume = {10203},
  isbn = {978-3-662-54457-0 978-3-662-54458-7},
  abstract = {Capretta's delay monad can be used to model partial computations, but it has the ``wrong'' notion of built-in equality, strong bisimilarity. An alternative is to quotient the delay monad by the ``right'' notion of equality, weak bisimilarity. However, recent work by Chapman et al. suggests that it is impossible to define a monad structure on the resulting construction in common forms of type theory without assuming (instances of) the axiom of countable choice.},
  language = {en},
  urldate = {2018-06-19},
  url = {http://link.springer.com/10.1007/978-3-662-54458-7_31},
  booktitle = {Foundations of {{Software Science}} and {{Computation Structures}}},
  publisher = {{Springer Berlin Heidelberg}},
  author = {Altenkirch, Thorsten and Danielsson, Nils Anders and Kraus, Nicolai},
  editor = {Esparza, Javier and Murawski, Andrzej S.},
  year = {2017},
  pages = {534-549},
  file = {/Users/doisinkidney/Zotero/storage/CTLM5XDQ/Altenkirch et al. - 2017 - Partiality, Revisited.pdf;/Users/doisinkidney/Zotero/storage/L8F98IQM/Altenkirch et al. - 2017 - Partiality, Revisited.pdf;/Users/doisinkidney/Zotero/storage/XGDP694U/Altenkirch et al. - 2017 - Partiality, Revisited.pdf},
  doi = {10.1007/978-3-662-54458-7_31}
}

@article{porter_monad.reader_2011,
  title = {The {{Monad}}.{{Reader Issue}} 18},
  volume = {18},
  language = {en},
  number = {18},
  urldate = {2018-06-19},
  url = {https://themonadreader.files.wordpress.com/2011/07/issue18.pdf},
  journal = {The Monad.Reader},
  author = {Porter, Julian and Petricek, Tomas and Auclair, Douglas M.},
  month = jul,
  year = {2011},
  pages = {51},
  file = {/Users/doisinkidney/Zotero/storage/VYXGI2J4/issue18.pdf}
}

@inproceedings{kiselyov_iteratees_2012,
  address = {Berlin, Heidelberg},
  series = {Lecture Notes in Computer Science},
  title = {Iteratees},
  isbn = {978-3-642-29821-9 978-3-642-29822-6},
  doi = {10.1007/978-3-642-29822-6_15},
  abstract = {Iteratee IO is a style of incremental input processing with precise resource control. The style encourages building input processors from a user-extensible set of primitives by chaining, layering, pairing and other modes of compositions. The programmer is still able, where needed, to precisely control look-ahead, the allocation of buffers, file descriptors and other resources. The style is especially suitable for processing of communication streams, large amount of data, and data undergone several levels of encoding such as pickling, compression, chunking, framing. It has been used for programming high-performance (HTTP) servers and web frameworks, in computational linguistics and financial trading.We exposit programming with iteratees, contrasting them with Lazy IO and the Handle-based, |stdio|-like IO. We relate them to online parser combinators. We introduce a simple implementation as free monads, which lets us formally reason with iteratees. As an example, we validate several equational laws and use them to optimize iteratee programs. The simple implementation helps understand existing implementations of iteratees and derive new ones.},
  language = {en},
  urldate = {2018-06-20},
  url = {http://okmij.org/ftp/Haskell/Iteratee/describe.pdf},
  booktitle = {Proceedings of the 11th {{International Conference}} on {{Functional}} and {{Logic Programming}}},
  publisher = {{Springer, Berlin, Heidelberg}},
  author = {Kiselyov, Oleg},
  month = may,
  year = {2012},
  pages = {166-181},
  file = {/Users/doisinkidney/Zotero/storage/GICHJUA3/describe.pdf;/Users/doisinkidney/Zotero/storage/ATVQF2VL/978-3-642-29822-6_15.html}
}

@unpublished{freeman_stack_2015,
  title = {Stack {{Safety}} for {{Free}}},
  abstract = {Free monads are a useful tool for abstraction, separating specification from interpretation. However, a na\"ive free monad implementation can lead to stack overflow depending on the evaluation model of the host language. This paper develops a stack-safe free monad transformer in PureScript, a strict Haskell-like language compiling to Javascript, and demonstrates certain applications - a safe implementation of coroutines, a safe list monad transformer, and a generic mechanism for building stack-safe control operators.},
  language = {en},
  urldate = {2018-06-19},
  url = {http://functorial.com/stack-safety-for-free/index.pdf},
  author = {Freeman, Phil},
  month = aug,
  year = {2015},
  file = {/Users/doisinkidney/Zotero/storage/YLS48PF3/Freeman - Stack Safety for Free.pdf}
}

@inproceedings{capretta_partiality_2004,
  address = {Dagstuhl, Germany},
  series = {Dagstuhl Seminar Proceedings},
  title = {Partiality Is an Effect},
  volume = {04381},
  language = {en},
  url = {https://www.ioc.ee/~tarmo/tday-veskisilla/uustalu-slides.pdf},
  booktitle = {Dependently {{Typed Programming}}},
  publisher = {{Internationales Begegnungs- und Forschungszentrum f\"ur Informatik (IBFI), Schloss Dagstuhl, Germany}},
  author = {Capretta, Venanzio and Altenkirch, Thorsten and Uustalu, Tarmo},
  month = sep,
  year = {2004},
  pages = {20},
  file = {/Users/doisinkidney/Zotero/storage/6GHJ35BU/Capretta et al. - 2005 - Partiality is an effect.pdf;/Users/doisinkidney/Zotero/storage/WHH6R3QU/Uustalu - Partiality is an effect.pdf}
}

@misc{atkey_how_2011,
  address = {Heriot-Watt University},
  title = {How to Be a {{Productive Programmer}} - by Putting Things off until Tomorrow},
  shorttitle = {How to Be a {{Productive Programmer}}},
  language = {en},
  url = {https://bentnib.org/posts/2011-11-14-productive-programmer.html},
  author = {Atkey, Robert},
  month = nov,
  year = {2011},
  file = {/Users/doisinkidney/Zotero/storage/Z69BHASU/University - How to be a Productive Programmer - by putting thi.pdf}
}

@misc{gonzalez_pipes_2018,
  title = {Pipes: {{Compositional}} Pipelines},
  shorttitle = {Pipes},
  abstract = {pipes is a clean and powerful stream processing library that lets you build and connect reusable streaming components},
  url = {http://hackage.haskell.org/package/pipes},
  author = {Gonzalez, Gabriel},
  month = mar,
  year = {2018}
}

@inproceedings{atkey_productive_2013,
  title = {Productive Coprogramming with Guarded Recursion},
  isbn = {978-1-4503-2326-0},
  doi = {10.1145/2500365.2500597},
  language = {en},
  urldate = {2018-06-21},
  url = {https://bentnib.org/productive.html},
  publisher = {{ACM Press}},
  author = {Atkey, Robert and McBride, Conor},
  year = {2013},
  pages = {197},
  file = {/Users/doisinkidney/Zotero/storage/SXKIJ6DE/Atkey and McBride - 2013 - Productive coprogramming with guarded recursion.pdf}
}

@book{noauthor_modality_2001,
  title = {A {{Modality}} for {{Recursion}}?},
  shorttitle = {A {{Modality}} for {{Recursion}}?},
  abstract = {Abstract. We propose a modal logic that enables us to handle self-referential formulae, including ones withnegative self-references, which on one hand, would introduce a logical contradiction, namely Russell's paradox, in the conventional setting, while on the other hand, are necessary to capture a certain class of programs suchas fixed point combinators and objects with so-called binary methods in object-oriented programming. Our logic provides a basis for axiomatic semantics of such a wider range of programs and a new framework for naturalconstruction of recursive programs in the proofs-as-programs paradigm. We give the logic as a modal typing system with recursive types for the purpose of presentation, and show its soundness with respect to a realizabilityinterpretation which implies the convergence of well-typed programs according to their types.},
  year = {2001},
  file = {/Users/doisinkidney/Zotero/storage/USQV3YJ9/2001 - A Modality for Recursion (Technical Report).pdf;/Users/doisinkidney/Zotero/storage/FVN4VBIQ/summary.html}
}

@inproceedings{nakano_modality_2000-1,
  address = {Washington, DC, USA},
  series = {LICS '00},
  title = {A {{Modality}} for {{Recursion}}},
  isbn = {978-0-7695-0725-5},
  doi = {10.1109/LICS.2000.855774},
  abstract = {We propose a modal logic that enables us to handle self-referential formulae, including ones with negative self-references, which on one hand, would introduce a logical contradiction, namely Russell's paradox, in the conventional setting, while on the other hand, are necessary to capture a certain class of programs such as fixed point combinators and objects with so-called binary methods in object-oriented programming. Our logic provides a basis for axiomatic semantics of such a wider range of programs and a new framework for natural construction of recursive programs in the proofs-as-programs paradigm.},
  language = {en},
  urldate = {2018-06-23},
  url = {http://dl.acm.org/citation.cfm?id=788022.789002},
  booktitle = {Proceedings of the 15th {{Annual IEEE Symposium}} on {{Logic}} in {{Computer Science}}},
  publisher = {{IEEE Computer Society}},
  author = {Nakano, Hiroshi},
  year = {2000},
  keywords = {theorem proving,Data structures,modal logic,axiomatic semantics,binary methods,Convergence,Electronic mail,fixed point combinators,formal logic,Logic programming,logical contradiction,natural construction,negative self-references,Network address translation,object oriented programming,programming language semantics,proofs-as-programs paradigm,recursion,recursive programs,self-referential formulae,type theory,Lambda and Combinatory Caluculi,Logics of Programs,Modal and Temporal Logics,Specifications,Type Systems and Type Theory},
  pages = {255-266},
  file = {/Users/doisinkidney/Zotero/storage/L66IKQ5N/Nakano - 2000 - A modality for recursion.pdf;/Users/doisinkidney/Zotero/storage/8ZTXDK8A/855774.html}
}

@article{guatto_generalized_2018-1,
  archivePrefix = {arXiv},
  eprinttype = {arxiv},
  eprint = {1805.11021},
  primaryClass = {cs},
  title = {A {{Generalized Modality}} for {{Recursion}}},
  doi = {10.1145/3209108.3209148},
  abstract = {Nakano's later modality allows types to express that the output of a function does not immediately depend on its input, and thus that computing its fixpoint is safe. This idea, guarded recursion, has proved useful in various contexts, from functional programming with infinite data structures to formulations of step-indexing internal to type theory. Categorical models have revealed that the later modality corresponds in essence to a simple reindexing of the discrete time scale. Unfortunately, existing guarded type theories suffer from significant limitations for programming purposes. These limitations stem from the fact that the later modality is not expressive enough to capture precise input-output dependencies of functions. As a consequence, guarded type theories reject many productive definitions. Combining insights from guarded type theories and synchronous programming languages, we propose a new modality for guarded recursion. This modality can apply any well-behaved reindexing of the time scale to a type. We call such reindexings time warps. Several modalities from the literature, including later, correspond to fixed time warps, and thus arise as special cases of ours.},
  urldate = {2018-06-23},
  url = {http://arxiv.org/abs/1805.11021},
  journal = {arXiv:1805.11021 [cs]},
  author = {Guatto, Adrien},
  month = may,
  year = {2018},
  keywords = {Computer Science - Programming Languages,Computer Science - Logic in Computer Science},
  file = {/Users/doisinkidney/Zotero/storage/2YXPHUWU/Guatto - 2018 - A Generalized Modality for Recursion.pdf;/Users/doisinkidney/Zotero/storage/XFPFBNXA/Guatto - 2018 - A Generalized Modality for Recursion.pdf;/Users/doisinkidney/Zotero/storage/UN8MLZGG/1805.html;/Users/doisinkidney/Zotero/storage/YERCCS8H/1805.html}
}

@article{capretta_general_2005,
  archivePrefix = {arXiv},
  eprinttype = {arxiv},
  eprint = {cs/0505037},
  title = {General {{Recursion}} via {{Coinductive Types}}},
  volume = {1},
  issn = {18605974},
  doi = {10.2168/LMCS-1(2:1)2005},
  abstract = {A fertile field of research in theoretical computer science investigates the representation of general recursive functions in intensional type theories. Among the most successful approaches are: the use of wellfounded relations, implementation of operational semantics, formalization of domain theory, and inductive definition of domain predicates. Here, a different solution is proposed: exploiting coinductive types to model infinite computations. To every type A we associate a type of partial elements Partial(A), coinductively generated by two constructors: the first, return(a) just returns an element a:A; the second, step(x), adds a computation step to a recursive element x:Partial(A). We show how this simple device is sufficient to formalize all recursive functions between two given types. It allows the definition of fixed points of finitary, that is, continuous, operators. We will compare this approach to different ones from the literature. Finally, we mention that the formalization, with appropriate structural maps, defines a strong monad.},
  number = {2},
  urldate = {2018-06-23},
  url = {http://arxiv.org/abs/cs/0505037},
  journal = {Logical Methods in Computer Science},
  author = {Capretta, Venanzio},
  month = jul,
  year = {2005},
  keywords = {Computer Science - Logic in Computer Science,F.3.1},
  file = {/Users/doisinkidney/Zotero/storage/S59XQIXI/Capretta - 2005 - General Recursion via Coinductive Types.pdf;/Users/doisinkidney/Zotero/storage/ET8UGRZI/0505037.html}
}

@inproceedings{cave_fair_2014,
  address = {New York, NY, USA},
  series = {POPL '14},
  title = {Fair {{Reactive Programming}}},
  isbn = {978-1-4503-2544-8},
  doi = {10.1145/2535838.2535881},
  abstract = {Functional Reactive Programming (FRP) models reactive systems with events and signals, which have previously been observed to correspond to the "eventually" and "always" modalities of linear temporal logic (LTL). In this paper, we define a constructive variant of LTL with least fixed point and greatest fixed point operators in the spirit of the modal mu-calculus, and give it a proofs-as-programs interpretation as a foundational calculus for reactive programs. Previous work emphasized the propositions-as-types part of the correspondence between LTL and FRP; here we emphasize the proofs-as-programs part by employing structural proof theory. We show that the type system is expressive enough to enforce liveness properties such as the fairness of schedulers and the eventual delivery of results. We illustrate programming in this calculus using (co)iteration operators. We prove type preservation of our operational semantics, which guarantees that our programs are causal. We give also a proof of strong normalization which provides justification that our programs are productive and that they satisfy liveness properties derived from their types.},
  urldate = {2018-06-23},
  url = {http://doi.acm.org/10.1145/2535838.2535881},
  booktitle = {Proceedings of the 41st {{ACM SIGPLAN}}-{{SIGACT Symposium}} on {{Principles}} of {{Programming Languages}}},
  publisher = {{ACM}},
  author = {Cave, Andrew and Ferreira, Francisco and Panangaden, Prakash and Pientka, Brigitte},
  year = {2014},
  keywords = {functional reactive programming,liveness,propositions-as-types,temporal logic},
  pages = {361--372},
  file = {/Users/doisinkidney/Zotero/storage/J6D5UYIE/Cave et al. - 2014 - Fair Reactive Programming.pdf;/Users/doisinkidney/Zotero/storage/NQNCKP5N/Cave et al. - 2014 - Fair Reactive Programming.pdf}
}

@article{hinze_concrete_2010,
  title = {Concrete Stream Calculus: {{An}} Extended Study},
  volume = {20},
  issn = {1469-7653, 0956-7968},
  shorttitle = {Concrete Stream Calculus},
  doi = {10.1017/S0956796810000213},
  abstract = {This paper shows how to reason about streams concisely and precisely. Streams, infinite sequences of elements, live in a coworld: they are given by a coinductive datatype, operations on streams are implemented by corecursive programs, and proofs are typically concocted using coinduction. This paper offers an alternative to coinduction. Suitably restricted, stream equations possess unique solutions. This property gives rise to a simple and attractive proof technique, essentially bringing equational reasoning to the coworld. We redevelop the theory of recurrences, finite calculus and generating functions using streams and stream operators, building on the cornerstone of unique solutions. The paper contains a sm\"org\aa{}sbord of examples: we study recursion elimination, investigate the binary carry sequence, explore Sprague-Grundy numbers and present two proofs of Moessner's Theorem. The calculations benefit from the rich structure of streams. As the type of streams is an applicative functor we can effortlessly lift operations and their properties to streams. In combination with Haskell's facilities for overloading, this greatly contributes to conciseness of notation. The development is indeed constructive: streams and stream operators are implemented in Haskell, usually by one-liners. The resulting calculus or library, if you wish, is elegant and fun to use.},
  language = {en},
  number = {5-6},
  urldate = {2018-06-23},
  url = {https://www.cambridge.org/core/journals/journal-of-functional-programming/article/concrete-stream-calculus-an-extended-study/F5DADE7E7819BB96D9091F3404AFB323},
  journal = {Journal of Functional Programming},
  author = {Hinze, Ralf},
  month = nov,
  year = {2010},
  pages = {463-535},
  file = {/Users/doisinkidney/Zotero/storage/LE7UCKFI/Hinze - 2010 - Concrete stream calculus An extended study.pdf;/Users/doisinkidney/Zotero/storage/SISIB8JN/F5DADE7E7819BB96D9091F3404AFB323.html}
}

@article{rutten_behavioural_2003,
  title = {Behavioural Differential Equations: A Coinductive Calculus of Streams, Automata, and Power Series},
  volume = {308},
  issn = {0304-3975},
  shorttitle = {Behavioural Differential Equations},
  doi = {10.1016/S0304-3975(02)00895-2},
  abstract = {We present a theory of streams (infinite sequences), automata and languages, and formal power series, in terms of the notions of homomorphism and bisimulation, which are the cornerstones of the theory of (universal) coalgebra. This coalgebraic perspective leads to a unified theory, in which the observation that each of the aforementioned sets carries a so-called final automaton structure, plays a central role. Finality forms the basis for both definitions and proofs by coinduction, the coalgebraic counterpart of induction. Coinductive definitions take the shape of what we have called behavioural differential equations, after Brzozowski's notion of input derivative. A calculus is developed for coinductive reasoning about all of the aforementioned structures, closely resembling calculus from classical analysis.},
  number = {1},
  urldate = {2018-06-23},
  url = {http://www.sciencedirect.com/science/article/pii/S0304397502008952},
  journal = {Theoretical Computer Science},
  author = {Rutten, J. J. M. M.},
  month = nov,
  year = {2003},
  keywords = {Automaton,Bisimulation,Coalgebra,Coinduction,Differential equation,Finality,Formal language,Formal power series,Homomorphism,Input derivative,Stream},
  pages = {1-53},
  file = {/Users/doisinkidney/Zotero/storage/LFCFQ27W/Rutten - 2003 - Behavioural differential equations a coinductive .pdf;/Users/doisinkidney/Zotero/storage/U8H88FXJ/S0304397502008952.html}
}

@article{hansen_stream_2016,
  archivePrefix = {arXiv},
  eprinttype = {arxiv},
  eprint = {1609.08367},
  primaryClass = {cs},
  title = {Stream {{Differential Equations}}: {{Specification Formats}} and {{Solution Methods}}},
  shorttitle = {Stream {{Differential Equations}}},
  abstract = {Streams, or infinite sequences, are infinite objects of a very simple type, yet they have a rich theory partly due to their ubiquity in mathematics and computer science. Stream differential equations are a coinductive method for specifying streams and stream operations, and their theory has been developed in many papers over the past two decades. In this paper we present a survey of the many results in this area. Our focus is on the classification of different formats of stream differential equations, their solution methods, and the classes of streams they can define. Moreover, we describe in detail the connection between the so-called syntactic solution method and abstract GSOS.},
  urldate = {2018-06-23},
  url = {http://arxiv.org/abs/1609.08367},
  journal = {arXiv:1609.08367 [cs]},
  author = {Hansen, Helle Hvid and Kupke, Clemens and Rutten, Jan},
  month = sep,
  year = {2016},
  keywords = {F.3.2,Computer Science - Logic in Computer Science,Computer Science - Formal Languages and Automata Theory,F.1.1,F.4.3},
  file = {/Users/doisinkidney/Zotero/storage/LY8IA4BP/Hansen et al. - 2016 - Stream Differential Equations Specification Forma.pdf;/Users/doisinkidney/Zotero/storage/MLSISFT6/1609.html}
}

@article{mannaa_clocks_2018,
  archivePrefix = {arXiv},
  eprinttype = {arxiv},
  eprint = {1804.06687},
  primaryClass = {cs},
  title = {The Clocks They Are Adjunctions:{{Denotational}} Semantics for {{Clocked Type Theory}}},
  shorttitle = {The Clocks They Are Adjunctions},
  abstract = {Clocked Type Theory (CloTT) is a type theory for guarded recursion useful for programming with coinductive types, allowing productivity to be encoded in types, and for reasoning about advanced programming language features using an abstract form of step-indexing. CloTT has previously been shown to enjoy a number of syntactic properties including strong normalisation, canonicity and decidability of type checking. In this paper we present a denotational semantics for CloTT useful, e.g., for studying future extensions of CloTT with constructions such as path types. The main challenge for constructing this model is to model the notion of ticks used in CloTT for coinductive reasoning about coinductive types. We build on a category previously used to model guarded recursion, but in this category there is no object of ticks, so tick-assumptions in a context can not be modelled using standard tools. Instead we show how ticks can be modelled using adjoint functors, and how to model the tick constant using a semantic substitution.},
  urldate = {2018-06-23},
  url = {http://arxiv.org/abs/1804.06687},
  journal = {arXiv:1804.06687 [cs]},
  author = {Mannaa, Bassel and M\o{}gelberg, Rasmus Ejlers},
  month = apr,
  year = {2018},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/Users/doisinkidney/Zotero/storage/E5KMY2W2/Mannaa and Møgelberg - 2018 - The clocks they are adjunctionsDenotational seman.pdf;/Users/doisinkidney/Zotero/storage/BQF2WLWH/1804.html}
}

@article{capretta_continuity_nodate,
  title = {The {{Continuity}} of {{Monadic Stream Functions}}},
  abstract = {Brouwer's continuity principle states that all functions from infinite sequences of naturals to naturals are continuous, that is, for every sequence the result depends only on a finite initial segment. It is an intuitionistic axiom that is incompatible with classical mathematics. Recently Mart\textasciiacute\i{}n Escardo\textasciiacute{} proved that it is also inconsistent in type theory.},
  language = {en},
  author = {Capretta, Venanzio and Fowler, Jonathan},
  pages = {12},
  file = {/Users/doisinkidney/Zotero/storage/XE7464ZY/Capretta and Fowler - The Continuity of Monadic Stream Functions.pdf}
}


