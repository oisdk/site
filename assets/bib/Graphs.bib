
@inproceedings{oliveira_functional_2012,
  title = {Functional {{Programming}} with {{Structured Graphs}}},
  volume = {47},
  booktitle = {{{ACM SIGPLAN Notices}}},
  publisher = {{ACM}},
  note = {\url{https://www.cs.utexas.edu/~wcook/Drafts/2012/graphs.pdf}},
  author = {Oliveira, Bruno C. d S. and Cook, William R.},
  year = {2012},
  pages = {77--88},
  file = {/Users/doisinkidney/Zotero/storage/JTU7M3EH/Oliveira and Cook - 2012 - Functional Programming with Structured Graphs.pdf;/Users/doisinkidney/Zotero/storage/ED8F9AWU/citation.html}
}

@inproceedings{wang_towards_2013,
  address = {New York, NY, USA},
  series = {{{FHPC}} '13},
  title = {Towards {{Systematic Parallel Programming}} of {{Graph Problems}} via {{Tree Decomposition}} and {{Tree Parallelism}}},
  isbn = {978-1-4503-2381-9},
  abstract = {Many graph optimization problems, such as the Maximum Weighted Independent Set problem, are NP-hard. For large scale graphs that have billions of edges or vertices, these problems are hard to be computed directly even using popular data-intensive frameworks like MapReduce or Pregel that are deployed on large computer-clusters, because of the extremely high computational complexity. On the other hand, many studies have shown the existence of polynomial time algorithms on graphs with bounded treewidth, which makes it possible to solve these problems on large graphs. However, the algorithms are usually difficult to be understood or parallelized. In this paper, we propose a novel programming framework which provides a user-friendly programming interface and automatic in-black-box parallelization. The programming interface, which is a simple and straightforward abstraction called Generate-Test-Aggregate (GTA for short), is used to describe a set of graph problems. We propose to derive bottom-up dynamic programming algorithms on tree decompositions from the user-specified GTA algorithms, and further transform the bottom-up algorithms to parallel ones which run in a divide-and-conquer manner on a list of subtrees. Besides, balanced tree partition strategies are discussed for efficient parallel computing. Our preliminary experimental results on the Maximum Weighted Independent Set problem demonstrate the practical viability of our approaches.},
  booktitle = {Proceedings of the {{2Nd ACM SIGPLAN Workshop}} on {{Functional High}}-Performance {{Computing}}},
  publisher = {{ACM}},
  doi = {10.1145/2502323.2502331},
  note = {\url{http://www.people.usi.ch/chenm/paper/tree.pdf}},
  author = {Wang, Qi and Chen, Meixian and Liu, Yu and Hu, Zhenjiang},
  year = {2013},
  keywords = {graph problems,gta,parallelization,transformation,tree decomposition,treewidth},
  pages = {25--36},
  file = {/Users/doisinkidney/Zotero/storage/GG4QUCKW/Wang et al. - 2013 - Towards Systematic Parallel Programming of Graph P.pdf;/Users/doisinkidney/Zotero/storage/TCB85H4X/citation.html}
}

@inproceedings{okasaki_breadth-first_2000,
  address = {New York, NY, USA},
  series = {{{ICFP}} '00},
  title = {Breadth-First {{Numbering}}: {{Lessons}} from a {{Small Exercise}} in {{Algorithm Design}}},
  isbn = {978-1-58113-202-1},
  shorttitle = {Breadth-First {{Numbering}}},
  abstract = {Every programmer has blind spots. Breadth-first numbering is an interesting toy problem that exposes a blind spot common to many---perhaps most---functional programmers.},
  booktitle = {Proceedings of the {{Fifth ACM SIGPLAN International Conference}} on {{Functional Programming}}},
  publisher = {{ACM}},
  doi = {10.1145/351240.351253},
  note = {\url{https://www.cs.tufts.edu/~nr/cs257/archive/chris-okasaki/breadth-first.pdf}},
  author = {Okasaki, Chris},
  year = {2000},
  keywords = {Breadth-first numbering,breadth-first traversal,views},
  pages = {131--136},
  file = {/Users/doisinkidney/Zotero/storage/BC5QQV8B/Okasaki - 2000 - Breadth-first Numbering Lessons from a Small Exer.pdf}
}

@techreport{jones_linear-time_1993,
  title = {Linear-Time {{Breadth}}-First {{Tree Algorithms}}: {{An Exercise}} in the {{Arithmetic}} of {{Folds}} and {{Zips}}},
  shorttitle = {Linear-Time Breadth-First Tree Algorithms},
  abstract = {This paper is about an application of the mathematics of the zip, reduce (fold) and accumulate (scan) operations on lists. It gives an account of the derivation of a linear-time breadth-first tree traversal algorithm, and of a subtle and efficient breadth-first tree labelling algorithm.},
  number = {71},
  institution = {{Dept of Computer Science, University of Auckland}},
  note = {\url{http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/linear.ps.gz}},
  author = {Jones, Geraint and Gibbons, Jeremy},
  month = may,
  year = {1993},
  file = {/Users/doisinkidney/Zotero/storage/DWNSFLCU/Jones and Gibbons - 1993 - Linear-time Breadth-first Tree Algorithms An Exer.pdf;/Users/doisinkidney/Zotero/storage/L3FJW23Y/Jones and Gibbons - 1993 - Linear-time breadth-first tree algorithms An exer.pdf;/Users/doisinkidney/Zotero/storage/FBMN8FSQ/summary.html;/Users/doisinkidney/Zotero/storage/MN84D7XS/summary.html}
}

@article{smith_lloyd_2009,
  title = {Lloyd {{Allison}}'s {{Corecursive Queues}}: {{Why Continuations Matter}}},
  volume = {14},
  abstract = {In a purely functional setting, real-time queues are traditionally thought to be much harder to implement than either real-time stacks or amortized O(1) queues. In ``Circular Programs and Self-Referential Structures,'' [1] Lloyd Allison uses corecursion to implement a queue by defining a lazy list in terms of itself. This provides a simple, efficient, and attractive implementation of real-time queues.},
  language = {en},
  number = {14},
  journal = {The Monad.Reader},
  note = {\url{https://meldingmonads.files.wordpress.com/2009/06/corecqueues.pdf}},
  author = {Smith, Leon P},
  month = jul,
  year = {2009},
  pages = {28},
  file = {/Users/doisinkidney/Zotero/storage/G7FLCPUX/leon - Lloyd Allisonâ€™s Corecursive Queues Why Continuati.pdf}
}

@article{allison_circular_2006,
  title = {Circular {{Programs}} and {{Self}}-{{Referential Structures}}},
  volume = {19},
  issn = {1097-024X},
  abstract = {A circular program creates a data structure whose computation depends upon itself or refers to itself. The technique is used to implement the classic data structures circular and doubly-linked lists, threaded trees and queues, in a functional programming language. These structures are normally thought to require updatable variables found in imperative languages. For example, a functional program to perform the breadth-first traversal of a tree is given. Some of the examples result in circular data structures when evaluated. Some examples are particularly space-efficient by avoiding the creation of intermediate temporary structures which would otherwise later become garbage. Lastly, the technique can be applied in an imperative language to give an elegant program.},
  language = {en},
  number = {2},
  journal = {Software: Practice and Experience},
  doi = {10.1002/spe.4380190202},
  note = {\url{http://users.monash.edu/~lloyd/tildeFP/1989SPE/}},
  author = {Allison, Lloyd},
  month = oct,
  year = {2006},
  pages = {99-109},
  file = {/Users/doisinkidney/Zotero/storage/Y4N267KR/Allison - 2006 - Circular Programs and Self-Referential Structures.pdf;/Users/doisinkidney/Zotero/storage/K3Q9X4Z8/1989SPE.html;/Users/doisinkidney/Zotero/storage/TDDEAG4F/PP.html;/Users/doisinkidney/Zotero/storage/TGUU9DZL/spe.html}
}

@article{hamana_initial_2010,
  archivePrefix = {arXiv},
  eprinttype = {arxiv},
  eprint = {1007.4266},
  title = {Initial {{Algebra Semantics}} for {{Cyclic Sharing Tree Structures}}},
  volume = {6},
  issn = {18605974},
  abstract = {Terms are a concise representation of tree structures. Since they can be naturally defined by an inductive type, they offer data structures in functional programming and mechanised reasoning with useful principles such as structural induction and structural recursion. However, for graphs or "tree-like" structures - trees involving cycles and sharing - it remains unclear what kind of inductive structures exists and how we can faithfully assign a term representation of them. In this paper we propose a simple term syntax for cyclic sharing structures that admits structural induction and recursion principles. We show that the obtained syntax is directly usable in the functional language Haskell and the proof assistant Agda, as well as ordinary data structures such as lists and trees. To achieve this goal, we use a categorical approach to initial algebra semantics in a presheaf category. That approach follows the line of Fiore, Plotkin and Turi's models of abstract syntax with variable binding.},
  number = {3},
  journal = {Logical Methods in Computer Science},
  doi = {10.2168/LMCS-6(3:15)2010},
  note = {\url{http://arxiv.org/abs/1007.4266}},
  author = {Hamana, Makoto},
  month = sep,
  year = {2010},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/Users/doisinkidney/Zotero/storage/PNYK6ASC/Hamana - 2010 - Initial Algebra Semantics for Cyclic Sharing Tree .pdf;/Users/doisinkidney/Zotero/storage/WSXGXHYP/1007.html}
}

@article{fernandes_design_nodate,
  title = {Design, {{Implementation}} and {{Calculation}} of {{Circular Programs}}},
  language = {en},
  author = {Fernandes, Joao Paulo},
  pages = {176},
  file = {/Users/doisinkidney/Zotero/storage/UFF9J99I/Fernandes - Design, Implementation and Calculation of Circular.pdf;/Users/doisinkidney/Zotero/storage/YEJQDCNB/Fernandes - Design, Implementation and Calculation of Circular.pdf}
}

@misc{erwig_functional_2008,
  title = {Functional {{Graph Library}}/{{Haskell}}},
  howpublished = {\url{http://web.engr.oregonstate.edu/~erwig/fgl/haskell/}},
  author = {Erwig, Martin},
  month = nov,
  year = {2008},
  file = {/Users/doisinkidney/Zotero/storage/876KYD5S/haskell.html}
}

@article{erwig_inductive_2001,
  title = {Inductive Graphs and Functional Graph Algorithms},
  volume = {11},
  issn = {1469-7653, 0956-7968},
  abstract = {We propose a new style of writing graph algorithms in functional languages which is based
on an alternative view of graphs as inductively defined data types. We show how this graph
model can be implemented efficiently, and then we demonstrate how graph algorithms can be
succinctly given by recursive function definitions based on the inductive graph view. We also
regard this as a contribution to the teaching of algorithms and data structures in functional
languages since we can use the functional-style graph algorithms instead of the imperative
algorithms that are dominant today.},
  language = {en},
  number = {5},
  journal = {Journal of Functional Programming},
  doi = {10.1017/S0956796801004075},
  note = {\url{http://web.engr.oregonstate.edu/~erwig/papers/InductiveGraphs_JFP01.pdf}},
  author = {Erwig, Martin},
  month = sep,
  year = {2001},
  pages = {467-492},
  file = {/Users/doisinkidney/Zotero/storage/FL9EENLE/Erwig - 2001 - Inductive graphs and functional graph algorithms.pdf;/Users/doisinkidney/Zotero/storage/HXTPDQIV/2210F7C31A34EA4CF5008ED9E7B4EF62.html}
}

@inproceedings{mokhov_algebraic_2017,
  address = {New York, NY, USA},
  series = {Haskell 2017},
  title = {Algebraic {{Graphs}} with {{Class}} ({{Functional Pearl}})},
  isbn = {978-1-4503-5182-9},
  abstract = {The paper presents a minimalistic and elegant approach to working with graphs in Haskell. It is built on a rigorous mathematical foundation --- an algebra of graphs --- that allows us to apply equational reasoning for proving the correctness of graph transformation algorithms. Algebraic graphs let us avoid partial functions typically caused by `malformed graphs' that contain an edge referring to a non-existent vertex. This helps to liberate APIs of existing graph libraries from partial functions.   The algebra of graphs can represent directed, undirected, reflexive and transitive graphs, as well as hypergraphs, by appropriately choosing the set of underlying axioms. The flexibility of the approach is demonstrated by developing a library for constructing and transforming polymorphic graphs.},
  booktitle = {Proceedings of the 10th {{ACM SIGPLAN International Symposium}} on {{Haskell}}},
  publisher = {{ACM}},
  doi = {10.1145/3122955.3122956},
  note = {\url{http://doi.acm.org/10.1145/3122955.3122956}},
  author = {Mokhov, Andrey},
  year = {2017},
  keywords = {Haskell,algebra,graph theory},
  pages = {2--13},
  file = {/Users/doisinkidney/Zotero/storage/7TDCB7J6/Mokhov - 2017 - Algebraic Graphs with Class (Functional Pearl).pdf}
}

@misc{kiselyov_pure-functional_2002,
  title = {Pure-Functional Transformations of Cyclic Graphs and the {{Credit Card Transform}}},
  abstract = {Cycles certainly make it difficult to transform graphs in a pure non-strict language. Cycles in a source graph require us to devise a way to mark traversed nodes -- however we cannot mutate nodes and cannot even compare nodes with a generic ('derived') equality operator. Cycles in a destination graph call for keeping track of already constructed nodes so we can make back-references. An obvious solution is to resort to the state monad or IORefs. There is also a monad-less solution, which maintains a dictionary of already constructed nodes. The latter is less obvious: seemingly we cannot add a node to the dictionary until we have built the node. Therefore, we cannot use the updated dictionary when building the descendants of the node -- which need the updated dictionary to link back. The problem can be overcome however with a credit card transform (a.k.a. "buy now, pay later" transform). To avoid hitting the bottom, we just have to "pay" by the "due date".

For illustration, the article below considers the problem of printing out a non-deterministic finite automaton (NFA) and transforming it into a deterministic finite automaton (DFA). Both NFA and DFA are represented as cyclic graphs.},
  howpublished = {\url{http://okmij.org/ftp/Haskell/AlgorithmsH.html\#ccard-transform}},
  author = {Kiselyov, Oleg},
  month = aug,
  year = {2002},
  file = {/Users/doisinkidney/Zotero/storage/XJ325NG8/AlgorithmsH.html}
}

@inproceedings{king_lazy_1994,
  title = {Lazy Depth-First Search and Linear Graph Algorithms in Haskell},
  booktitle = {Glasgow {{Workshop}} on {{Functional Programming}}},
  publisher = {{Citeseer}},
  author = {King, David J. and Launchbury, John},
  year = {1994},
  pages = {145--155},
  file = {/Users/doisinkidney/Zotero/storage/2FSDL8Q7/King and Launchbury - Lazy Depth-First Search and Linear Graph Algorithm.pdf;/Users/doisinkidney/Zotero/storage/36EDWDPU/King and Launchbury - Lazy Depth-First Search and Linear Graph Algorithm.pdf;/Users/doisinkidney/Zotero/storage/9WXAEFMY/King and Launchbury - 1994 - Lazy depth-first search and linear graph algorithm.pdf;/Users/doisinkidney/Zotero/storage/EFMAXEUT/King and Launchbury - Lazy Depth-First Search and Linear Graph Algorithm.pdf;/Users/doisinkidney/Zotero/storage/MVN3VHLH/King and Launchbury - Lazy Depth-First Search and Linear Graph Algorithm.pdf;/Users/doisinkidney/Zotero/storage/PNCHYA22/King and Launchbury - Lazy Depth-First Search and Linear Graph Algorithm.pdf;/Users/doisinkidney/Zotero/storage/Q9A2DMGB/King and Launchbury - Lazy Depth-First Search and Linear Graph Algorithm.pdf}
}


