
@article{hughes_novel_1986,
	title = {A {Novel} {Representation} of {Lists} and {Its} {Application} to the {Function} "{Reverse}"},
	volume = {22},
	issn = {0020-0190},
	url = {http://www.sciencedirect.com/science/article/pii/0020019086900591},
	doi = {10.1016/0020-0190(86)90059-1},
	abstract = {A representation of lists as first-class functions is proposed. Lists represented in this way can be appended together in constant time, and can be converted back into ordinary lists in time proportional to their length. Programs which construct lists using append can often be improved by using this representation. For example, naive reverse can be made to run in linear time, and the conventional ‘fast reverse’ can then be derived easily. Examples are given in KRC (Turner, 1982), the notation being explained as it is introduced. The method can be compared to Sleep and Holmström's proposal (1982) to achieve a similar effect by a change to the interpreter.},
	number = {3},
	urldate = {2017-03-29},
	journal = {Information Processing Letters},
	author = {Hughes, R. John Muir},
	month = mar,
	year = {1986},
	keywords = {data representation, Functional programming, list processing, program transformation},
	pages = {141--144},
	file = {[PDF] tufts.edu:files/2225/HUGHES - 1986 - A NOVEL REPRESENTATION OF LISTS AND ITS APPLICATIO.pdf:application/pdf;ScienceDirect Snapshot:files/2235/0020019086900591.html:text/html;Snapshot:files/2229/0020019086900591.html:text/html;Snapshot:files/2230/80002852960.html:text/html;Snapshot:files/2231/12ab75d7ff381f78527f8856b21c8e08.html:text/html;Snapshot:files/2232/citation.html:text/html;Snapshot:files/2233/cat.inist.fr.html:text/html;Snapshot:files/2237/12ab75d7ff381f78527f8856b21c8e08.html:text/html}
}

@article{danvy_there_2005,
	title = {There and {Back} {Again}},
	url = {http://brics.dk/RS/05/3/BRICS-RS-05-3.pdf},
	urldate = {2017-04-06},
	author = {Danvy, Olivier and Goldberg, Mayer},
	year = {2005},
	file = {[PDF] brics.dk:files/2358/Danvy and Goldberg - 2005 - There and Back Again.pdf:application/pdf}
}

@article{bird_using_1984,
	title = {Using {Circular} {Programs} to {Eliminate} {Multiple} {Traversals} of {Data}},
	volume = {21},
	issn = {0001-5903},
	url = {http://dx.doi.org/10.1007/BF00264249},
	doi = {10.1007/BF00264249},
	abstract = {This paper describes a technique for transforming functional programs that repeatedly traverse a data structure into more efficient alternatives that do not. The transformation makes essential use of lazy evaluation and local recursion (such as provided by letrec, or its equivalent) to build a circular program that, on one pass over the structure, determines the effects of the individual traversals and then combines them.},
	language = {en},
	number = {3},
	urldate = {2018-02-16},
	journal = {Acta Inf.},
	author = {Bird, R. S.},
	month = oct,
	year = {1984},
	pages = {239--250},
}

@inproceedings{voigtlander_using_2002,
	address = {New York, NY, USA},
	series = {{ASIA}-{PEPM} '02},
	title = {Using {Circular} {Programs} to {Deforest} in {Accumulating} {Parameters}},
	isbn = {978-1-58113-458-2},
	url = {http://doi.acm.org/10.1145/568173.568187},
	doi = {10.1145/568173.568187},
	abstract = {Functional languages allow a modular programming style by function composition, which however can lead to inefficient runtime behavior due to production and consumption of intermediate results.We present a new mechanizable transformation technique for removing intermediate data structures in the composition of two functions from a class of recursive functions with accumulating parameters, for which classical deforestation techniques fail.In order to avoid multiple traversals of the input data structure, the composition algorithm produces circular programs that make essential use of lazy evaluation and local recursion.The resulting programs are simplified using a post-processing phase presented in the paper.},
	urldate = {2018-02-16},
	booktitle = {Proceedings of the {ASIAN} {Symposium} on {Partial} {Evaluation} and {Semantics}-based {Program} {Manipulation}},
	publisher = {ACM},
	author = {Voigtländer, Janis},
	year = {2002},
	keywords = {program transformation, accumulating parameters, circular programs, deforestation, intermediate data structures, lazy composition, lazy evaluation, multiple traversals, tupling},
	pages = {126--137},
	file = {ACM Full Text PDF:files/3242/Voigtländer - 2002 - Using Circular Programs to Deforest in Accumulatin.pdf:application/pdf}
}

@article{van_gilst_new_1995,
	title = {A new programming technique for lazy functional languages},
	volume = {24},
	issn = {0167-6423},
	url = {http://www.sciencedirect.com/science/article/pii/0167642394000249},
	doi = {10.1016/0167-6423(94)00024-9},
	abstract = {In this paper we present a new programming technique for lazy functional programming languages. The technique is embedded in a programming methodology which is based on divide and conquer: the division of problems into subproblems. Such a division will be represented by a call graph. A class of program schemes, which implement call graphs, is derived based on Johnsson's approach to attribute evaluation in attribute grammars. The key idea is to consider the passing of arguments to functions and the return of results by functions in a call graph as the propagation of inherited and synthesized attributes, respectively, in an attribute grammar. The new technique is illustrated by several small examples and a case study: the design and implementation of a compiler generator.},
	number = {1},
	urldate = {2018-02-16},
	journal = {Science of Computer Programming},
	author = {van Gilst, F. A. and van den Broek, P. M.},
	month = feb,
	year = {1995},
	pages = {63--81},
	file = {ScienceDirect Full Text PDF:files/3245/van Gilst and van den Broek - 1995 - A new programming technique for lazy functional la.pdf:application/pdf;ScienceDirect Snapshot:files/3244/0167642394000249.html:text/html}
}

@inproceedings{fernandes_shortcut_2007,
	address = {New York, NY, USA},
	series = {Haskell '07},
	title = {A {Shortcut} {Fusion} {Rule} for {Circular} {Program} {Calculation}},
	isbn = {978-1-59593-674-5},
	url = {http://doi.acm.org/10.1145/1291201.1291216},
	doi = {10.1145/1291201.1291216},
	abstract = {Circular programs are a powerful technique to express multiple traversal algorithms as a single traversal function in a lazy setting. In this paper, we present a shortcut deforestation technique to calculate circular programs. The technique we propose takes as input the composition of two functions, such that the first builds an intermediate structure and some additional context information which are then processed by the second one, to produce the final result. Our transformation into circular programs achieves intermediate structure deforestation and multiple traversal elimination. Furthermore, the calculated programs preserve the termination properties of the original ones.},
	urldate = {2018-02-16},
	booktitle = {Proceedings of the {ACM} {SIGPLAN} {Workshop} on {Haskell} {Workshop}},
	publisher = {ACM},
	author = {Fernandes, João Paulo and Pardo, Alberto and Saraiva, João},
	year = {2007},
	keywords = {deforestation, circular programming, program calculation, shortcut fusion},
	pages = {95--106},
	file = {ACM Full Text PDF:files/3283/Fernandes et al. - 2007 - A Shortcut Fusion Rule for Circular Program Calcul.pdf:application/pdf}
}

@inproceedings{hu_tupling_1997,
	address = {New York, NY, USA},
	series = {{ICFP} '97},
	title = {Tupling {Calculation} {Eliminates} {Multiple} {Data} {Traversals}},
	isbn = {978-0-89791-918-0},
	url = {http://doi.acm.org/10.1145/258948.258964},
	doi = {10.1145/258948.258964},
	abstract = {Tupling is a well-known transformation tactic to obtain new efficient recursive functions by grouping some recursive functions into a tuple. It may be applied to eliminate multiple traversals over the common data structure. The major difficulty in tupling transformation is to find what functions are to be tupled and how to transform the tupled function into an efficient one. Previous approaches to tupling transformation are essentially based on fold/unfold transformation. Though general, they suffer from the high cost of keeping track of function calls to avoid infinite unfolding, which prevents them from being used in a compiler.To remedy this situation, we propose a new method to expose recursive structures in recursive definitions and show how this structural information can be explored for calculating out efficient programs by means of tupling. Our new tupling calculation algorithm can eliminate most of multiple data traversals and is easy to be implemented.},
	urldate = {2018-02-16},
	booktitle = {Proceedings of the {Second} {ACM} {SIGPLAN} {International} {Conference} on {Functional} {Programming}},
	publisher = {ACM},
	author = {Hu, Zhenjiang and Iwasaki, Hideya and Takeichi, Masato and Takano, Akihiko},
	year = {1997},
	pages = {164--175},
	file = {ACM Full Text PDF:files/3285/Hu et al. - 1997 - Tupling Calculation Eliminates Multiple Data Trave.pdf:application/pdf}
}

@article{rivas_notions_2014,
	title = {Notions of {Computation} as {Monoids}},
	url = {http://arxiv.org/abs/1406.4823},
	abstract = {There are different notions of computation, the most popular being monads, applicative functors, and arrows. In this article we show that these three notions can be seen as monoids in a monoidal category. We demonstrate that at this level of abstraction one can obtain useful results which can be instantiated to the different notions of computation. In particular, we show how free constructions and Cayley representations for monoids translate into useful constructions for monads, applicative functors, and arrows. Moreover, the uniform presentation of all three notions helps in the analysis of the relation between them.},
	urldate = {2018-02-17},
	journal = {arXiv:1406.4823 [cs, math]},
	author = {Rivas, Exequiel and Jaskelioff, Mauro},
	month = may,
	year = {2014},
	note = {arXiv: 1406.4823},
	keywords = {Computer Science - Logic in Computer Science, Computer Science - Programming Languages, Mathematics - Category Theory},
	file = {arXiv\:1406.4823 PDF:files/3307/Rivas and Jaskelioff - 2014 - Notions of Computation as Monoids.pdf:application/pdf;arXiv.org Snapshot:files/3308/1406.html:text/html}
}

@article{hutton_factorising_2010,
	title = {Factorising folds for faster functions},
	volume = {20},
	issn = {1469-7653, 0956-7968},
	url = {http://www.fceia.unr.edu.ar/~mauro/pubs/f5-ext.pdf},
	doi = {10.1017/S0956796810000122},
	abstract = {AbstractThe worker/wrapper transformation is a general technique for improving the performance of recursive programs by changing their types. The previous formalisation (A. Gill \& G. Hutton, J. Funct. Program., vol. 19, 2009, pp. 227–251) was based upon a simple fixed-point semantics of recursion. In this paper, we develop a more structured approach, based upon initial-algebra semantics. In particular, we show how the worker/wrapper transformation can be applied to programs defined using the structured pattern of recursion captured by fold operators, and illustrate our new technique with a number of examples.},
	language = {en},
	number = {3-4},
	urldate = {2018-02-17},
	journal = {Journal of Functional Programming},
	author = {Hutton, Graham and Jaskelioff, Mauro and Gill, Andy},
	month = jul,
	year = {2010},
	pages = {353--373},
	file = {f5-ext.pdf:files/3311/f5-ext.pdf:application/pdf;Snapshot:files/3310/1AC94646C45744F2474475CE5B3C7F90.html:text/html}
}

@inproceedings{hinze_kan_2012,
	address = {Berlin, Heidelberg},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Kan {Extensions} for {Program} {Optimisation} or: {Art} and {Dan} {Explain} an {Old} {Trick}},
	isbn = {978-3-642-31112-3 978-3-642-31113-0},
	shorttitle = {Kan {Extensions} for {Program} {Optimisation}},
	url = {https://www.cs.ox.ac.uk/ralf.hinze/Kan.pdf},
	doi = {10.1007/978-3-642-31113-0_16},
	abstract = {Many program optimisations involve transforming a program in direct style to an equivalent program in continuation-passing style. This paper investigates the theoretical underpinnings of this transformation in the categorical setting of monads. We argue that so-called absolute Kan Extensions underlie this program optimisation. It is known that every Kan extension gives rise to a monad, the codensity monad, and furthermore that every monad is isomorphic to a codensity monad. The end formula for Kan extensions then induces an implementation of the monad, which can be seen as the categorical counterpart of continuation-passing style. We show that several optimisations are instances of this scheme: Church representations and implementation of backtracking using success and failure continuations, among others. Furthermore, we develop the calculational properties of Kan extensions, powers and ends. In particular, we propose a two-dimensional notation based on string diagrams that aims to support effective reasoning with Kan extensions.},
	language = {en},
	urldate = {2018-02-17},
	booktitle = {Mathematics of {Program} {Construction}},
	publisher = {Springer, Berlin, Heidelberg},
	author = {Hinze, Ralf},
	month = jun,
	year = {2012},
	keywords = {adjunction, backtracking, Church representation, codensity monad, CPS, end, Haskell, Kan extension, power, string diagram},
	pages = {324--362},
	file = {Hinze - 2012 - Kan Extensions for Program Optimisation or Art an.pdf:files/3315/Hinze - 2012 - Kan Extensions for Program Optimisation or Art an.pdf:application/pdf;Snapshot:files/3313/978-3-642-31113-0_16.html:text/html}
}

@inproceedings{voigtlander_asymptotic_2008,
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Asymptotic {Improvement} of {Computations} over {Free} {Monads}},
	isbn = {978-3-540-70593-2 978-3-540-70594-9},
	url = {http://www.janis-voigtlaender.eu/papers/AsymptoticImprovementOfComputationsOverFreeMonads.pdf},
	doi = {10.1007/978-3-540-70594-9_20},
	abstract = {We present a low-effort program transformation to improve the efficiency of computations over free monads in Haskell. The development is calculational and carried out in a generic setting, thus applying to a variety of datatypes. An important aspect of our approach is the utilisation of type class mechanisms to make the transformation as transparent as possible, requiring no restructuring of code at all. There is also no extra support necessary from the compiler (apart from an up-to-date type checker). Despite this simplicity of use, our technique is able to achieve true asymptotic runtime improvements. We demonstrate this by examples for which the complexity is reduced from quadratic to linear.},
	language = {en},
	urldate = {2018-02-17},
	booktitle = {Mathematics of {Program} {Construction}},
	publisher = {Springer, Berlin, Heidelberg},
	author = {Voigtländer, Janis},
	month = jul,
	year = {2008},
	pages = {388--403},
	file = {AsymptoticImprovementOfComputationsOverFreeMonads.pdf:files/3318/AsymptoticImprovementOfComputationsOverFreeMonads.pdf:application/pdf;Snapshot:files/3317/978-3-540-70594-9_20.html:text/html}
}

@article{pippenger_pure_1997,
	title = {Pure {Versus} {Impure} {Lisp}},
	volume = {19},
	issn = {0164-0925},
	url = {http://doi.acm.org/10.1145/244795.244798},
	doi = {10.1145/244795.244798},
	number = {2},
	urldate = {2018-02-17},
	journal = {ACM Trans. Program. Lang. Syst.},
	author = {Pippenger, Nicholas},
	month = mar,
	year = {1997},
	keywords = {online computation, schematology},
	pages = {223--238},
	file = {ACM Full Text PDF:files/3321/Pippenger - 1997 - Pure Versus Impure Lisp.pdf:application/pdf}
}

@article{bird_more_1997,
	title = {More haste‚ less speed: lazy versus eager evaluation},
	volume = {7},
	issn = {1469-7653, 0956-7968},
	shorttitle = {More {Haste} ‚{Less} {Speed}},
	url = {https://ora.ox.ac.uk/objects/uuid:761a4646-60a2-4622-a1e0-ddea11507d57/datastreams/ATTACHMENT01},
	doi = {10.1017/S0956796897002827},
	abstract = {Nicholas Pippenger has recently given a problem that,
under two simple restrictions, can be
solved in linear time by an impure Lisp program, but requires
Ω(n log n) steps to be solved
by any eager pure Lisp program. By showing how to solve the
problem in linear time with a
lazy functional program, we demonstrate that – for
some problems at least – lazy evaluators
are strictly more powerful than eager ones.},
	language = {en},
	number = {5},
	urldate = {2018-02-17},
	journal = {Journal of Functional Programming},
	author = {Bird, Richard and Jones, Geraint and Moor, Oege De},
	month = sep,
	year = {1997},
	pages = {541--547},
	file = {Fulltext:files/3326/Bird et al. - 1997 - More Haste ‚Less Speed Lazy Versus Eager Evaluati.pdf:application/pdf;Snapshot:files/3323/162B391CBCD864794C766CA2A2EC7CBE.html:text/html;Snapshot:files/3325/Bird et al. - 1997 - More Haste ‚Less Speed Lazy Versus Eager Evaluati.pdf:application/pdf}
}
