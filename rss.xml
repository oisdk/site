<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>Donnacha OisÃ­n Kidney's Blog</title>
        <link>https://doisinkidney.com</link>
        <description><![CDATA[Mainly writing about programming]]></description>
        <atom:link href="https://doisinkidney.com/rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Mon, 25 Feb 2019 00:00:00 UT</lastBuildDate>
        <item>
    <title>Finger Trees in Agda</title>
    <link>https://doisinkidney.com/posts/2019-02-25-agda-fingertrees.html</link>
    <description><![CDATA[<div class="info">
    Posted on February 25, 2019
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Agda.html">Agda</a>
    
</div>

<hr />
<h2 id="this-post-is-available-with-clickable-code-here"><a href="https://oisdk.github.io/agda-indexed-fingertree/Data.FingerTree.html">This Post is Available With Clickable Code Here</a></h2>
<p>This whole post is written with clickable identifiers and ascii art at the above link. I also provide the normal version below in case there are any problems rendering.</p>
<hr />
<p>As I have talked about <a href="/posts/2019-01-15-binomial-urn.html">previously</a>, a large class of divide-and conquer algorithms rely on â€œgoodâ€ partitioning for the divide step. If you then want to make the algorithms incremental, you keep all of those partitions (with their summaries) in some â€œgoodâ€ arrangement <span class="citation" data-cites="mu_queueing_2016">(Mu, Chiang, and Lyu <a href="#ref-mu_queueing_2016">2016</a>)</span>. Several common data structures are designed around this principle: binomial heaps, for instance, store partitions of size <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mi>n</mi></msup><annotation encoding="application/x-tex">2^n</annotation></semantics></math>. Different ways of storing partitions favours different use cases: switch from a binomial heap to a skew binomial, for instance, and you get constant-time <code>cons</code>.</p>
<p>The standout data structure in this area is Hinze and Patersonâ€™s finger tree <span class="citation" data-cites="Hinze-Paterson:FingerTree">(Hinze and Paterson <a href="#ref-Hinze-Paterson:FingerTree">2006</a>)</span>. It caches summaries in a pretty amazing way, allowing for (amortised) <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math> <code>cons</code> and <code>snoc</code> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math> <code>split</code> and <code>append</code>. These features allow it to be used for a huge variety of things: <a href="http://hackage.haskell.org/package/containers-0.6.0.1/docs/Data-Sequence.html">Data.Sequence</a> uses it as a random-access sequence, but it can also work as a priority queue, a search tree, a priority search tree <span class="citation" data-cites="hinze_simple_2001">(Hinze <a href="#ref-hinze_simple_2001">2001</a>)</span>, an interval tree, an order statistic treeâ€¦</p>
<p>All of these applications solely rely on an underlying monoid. As a result, I thought it would be a great data structure to implement in Agda, so that youâ€™d get all of the other data structures with minimal effort <span class="citation" data-cites="sozeau_program-ing_2007">(similar thinking motivated a Coq implementation; Sozeau <a href="#ref-sozeau_program-ing_2007">2007</a>)</span>.</p>
<h1 id="scope-of-the-verification">Scope of the Verification</h1>
<p>There would be no real point to implementing a finger tree in Agda if we didnâ€™t also prove some things about it. The scope of the proofs Iâ€™ve done so far are intrinsic proofs of the summaries in the tree. In other words, the type of <code>cons</code> is as follows:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb1-1" data-line-number="1">cons <span class="ot">:</span> <span class="ot">âˆ€</span> x <span class="ot">{</span>xs<span class="ot">}</span> <span class="ot">â†’</span> Tree xs <span class="ot">â†’</span> Tree <span class="ot">(</span>Î¼ x âˆ™ xs<span class="ot">)</span></a></code></pre></div>
<p>This is enough to prove things about the derived data structures (like the correctness of sorting if itâ€™s used as a priority queue), but itâ€™s worth pointing out what I <em>havenâ€™t</em> proved (yet):</p>
<ol>
<li>Invariants on the structure (â€œsafeâ€ and â€œunsafeâ€ digits and so on).</li>
<li>The time complexity or performance of any operations.</li>
</ol>
<p>To be honest, Iâ€™m not even sure that my current implementation is correct in these regards! Iâ€™ll probably have a go at proving them in the future <span class="citation" data-cites="danielsson_lightweight_2008">(possibly using Danielsson <a href="#ref-danielsson_lightweight_2008">2008</a>)</span>.</p>
<h1 id="monoids-and-proofs">Monoids and Proofs</h1>
<p>The bad news is that finger trees are a relatively complex data structure, and weâ€™re going to need a <em>lot</em> of proofs to write a verified version. The good news is that monoids (in contrast to rings) are extremely easy to prove automatically. In this project, I used reflection to do so, but I think it should be possible to do with instance resolution also.</p>
<h1 id="measures">Measures</h1>
<p>First things first, we need a way to talk about the summaries of elements weâ€™re interested in. This is captured by the following record type:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">record</span> Ïƒ <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">(</span>Î£ <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">(</span>a âŠ” r<span class="ot">)</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  <span class="kw">field</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">    Î¼ <span class="ot">:</span> Î£ <span class="ot">â†’</span> ğ“¡</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">    </a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="kw">open</span> Ïƒ â¦ƒ <span class="ot">...</span> â¦„</a></code></pre></div>
<p><code>ğ“¡</code> is the type of the summaries, and <code>Î¼</code> means â€œsummariseâ€. The silly symbols are used for brevity: weâ€™re going to be using this thing everywhere, so itâ€™s important to keep it short. Hereâ€™s an example instance for lists:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb3-1" data-line-number="1">instance</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  Ïƒ-List <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">{</span>Î£ <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">â†’</span> â¦ƒ <span class="ot">_</span> <span class="ot">:</span> Ïƒ Î£ â¦„ <span class="ot">â†’</span> Ïƒ <span class="ot">(</span>List Î£<span class="ot">)</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">  Î¼ â¦ƒ Ïƒ-List â¦„ <span class="ot">=</span> List<span class="ot">.</span>foldr <span class="ot">(_</span>âˆ™<span class="ot">_</span> âˆ˜ Î¼<span class="ot">)</span> Îµ</a></code></pre></div>
<h1 id="working-with-setoids">Working With Setoids</h1>
<p>As I mentioned, the tree is going to be verified intrinsically. In other word its type will look something like this:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb4-1" data-line-number="1">Tree <span class="ot">:</span> ğ“¡ <span class="ot">â†’</span> <span class="dt">Set</span></a></code></pre></div>
<p>But before running off to define that the obvious way, I should mention that I made the annoying decision to use a setoid (rather than propositional equality) based monoid. This means that we donâ€™t get substitution, making the obvious definition untenable.</p>
<p>I figured out a solution to the problem, but Iâ€™m not sure if Iâ€™m happy with it. Thatâ€™s actually the main motivation for writing this post: Iâ€™m curious if other people have better techniques for this kind of thing.</p>
<p>To clarify: â€œthis kind of thingâ€ is writing intrinsic (correct-by-construction) proofs when a setoid is involved. Intrinsic proofs usually lend themselves to elegance: to prove that <code>map</code> preserves a vectorâ€™s length, for instance, basically requires no proof at all:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb5-1" data-line-number="1">map <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>a b n<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">{</span>B <span class="ot">:</span> <span class="dt">Set</span> b<span class="ot">}</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">    <span class="ot">â†’</span> <span class="ot">(</span>A <span class="ot">â†’</span> B<span class="ot">)</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">    <span class="ot">â†’</span> Vec A n</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">    <span class="ot">â†’</span> Vec B n</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">map f [] <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">map f <span class="ot">(</span>x âˆ· xs<span class="ot">)</span> <span class="ot">=</span> f x âˆ· map f xs</a></code></pre></div>
<p>But thatâ€™s because pattern matching works well with propositional equality: in the first clause, <code>n</code> is set to <code>0</code> automatically. If we were working with setoid equality, weâ€™d instead maybe get a proof that <code>n â‰ˆ 0</code>, and weâ€™d have to figure a way to work that into the types.</p>
<h1 id="fibres">Fibres</h1>
<p>The first part of the solution is to define a wrapper type which stores information about the size of the thing it contains:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">record</span> Î¼âŸ¨<span class="ot">_</span>âŸ©â‰ˆ<span class="ot">_</span> <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">(</span>Î£ <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">)</span> â¦ƒ <span class="ot">_</span> <span class="ot">:</span> Ïƒ Î£ â¦„ <span class="ot">(</span>ğ“‚ <span class="ot">:</span> ğ“¡<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">(</span>a âŠ” r âŠ” m<span class="ot">)</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  <span class="kw">constructor</span> <span class="ot">_</span>â‡‘[<span class="ot">_</span>]</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  <span class="kw">field</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">    ğ“¢ <span class="ot">:</span> Î£</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">    ğ’» <span class="ot">:</span> Î¼ ğ“¢ â‰ˆ ğ“‚</a></code></pre></div>
<p>Technically speaking, I think this is known as a â€œfibreâ€. <code>Î¼âŸ¨ Î£ âŸ©â‰ˆ ğ“‚</code> means â€œThere exists a <code>Î£</code> such that <code>Î¼ Î£ â‰ˆ ğ“‚</code>â€. Next, weâ€™ll need some combinators to work with:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">infixl</span> <span class="dv">2</span> <span class="ot">_</span>â‰ˆ[<span class="ot">_</span>]</a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="ot">_</span>â‰ˆ[<span class="ot">_</span>] <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">{</span>Î£ <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> â¦ƒ <span class="ot">_</span> <span class="ot">:</span> Ïƒ Î£ â¦„ <span class="ot">{</span>x <span class="ot">:</span> ğ“¡<span class="ot">}</span> <span class="ot">â†’</span> Î¼âŸ¨ Î£ âŸ©â‰ˆ x <span class="ot">â†’</span> <span class="ot">âˆ€</span> <span class="ot">{</span>y<span class="ot">}</span> <span class="ot">â†’</span> x â‰ˆ y <span class="ot">â†’</span> Î¼âŸ¨ Î£ âŸ©â‰ˆ y</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">ğ“¢ <span class="ot">(</span>xs â‰ˆ[ yâ‰ˆz ]<span class="ot">)</span> <span class="ot">=</span> ğ“¢ xs</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">ğ’» <span class="ot">(</span>xs â‰ˆ[ yâ‰ˆz ]<span class="ot">)</span> <span class="ot">=</span> trans <span class="ot">(</span>ğ’» xs<span class="ot">)</span> yâ‰ˆz</a></code></pre></div>
<p>This makes it possible to â€œrewriteâ€ the summary, given a proof of equivalence.</p>
<h1 id="do-notation">Do Notation</h1>
<p>The wrapper on its own isnâ€™t enough to save us from hundreds of lines of proofs. Once you do computation on its contents, you still need to join it up with its original proof of equivalence. In other words, youâ€™ll need to drill into the return type of a function, find the place you used the relevant type variable, and apply the relevant proof from the type above. This can really clutter proofs. Instead, we can use Agdaâ€™s new support for do notation to try and get a cleaner notation for everything. Hereâ€™s a big block of code:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">infixl</span> <span class="dv">2</span> arg-syntax</a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="kw">record</span> Arg <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">(</span>Î£ <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">)</span> â¦ƒ <span class="ot">_</span> <span class="ot">:</span> Ïƒ Î£ â¦„ <span class="ot">(</span>ğ“‚ <span class="ot">:</span> ğ“¡<span class="ot">)</span> <span class="ot">(</span>f <span class="ot">:</span> ğ“¡ <span class="ot">â†’</span> ğ“¡<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">(</span>m âŠ” r âŠ” a<span class="ot">)</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  <span class="kw">constructor</span> arg-syntax</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">  <span class="kw">field</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5">    âŸ¨fâŸ© <span class="ot">:</span> Congruentâ‚ f</a>
<a class="sourceLine" id="cb8-6" data-line-number="6">    arg <span class="ot">:</span> Î¼âŸ¨ Î£ âŸ©â‰ˆ ğ“‚</a>
<a class="sourceLine" id="cb8-7" data-line-number="7"><span class="kw">open</span> Arg</a>
<a class="sourceLine" id="cb8-8" data-line-number="8"></a>
<a class="sourceLine" id="cb8-9" data-line-number="9"><span class="kw">syntax</span> arg-syntax <span class="ot">(Î»</span> sz <span class="ot">â†’</span> eâ‚<span class="ot">)</span> xs <span class="ot">=</span> xs [ eâ‚ âŸ¿ sz ]</a>
<a class="sourceLine" id="cb8-10" data-line-number="10"></a>
<a class="sourceLine" id="cb8-11" data-line-number="11"><span class="kw">infixl</span> <span class="dv">1</span> <span class="ot">_</span>&gt;&gt;=<span class="ot">_</span></a>
<a class="sourceLine" id="cb8-12" data-line-number="12"><span class="ot">_</span>&gt;&gt;=<span class="ot">_</span> <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>a b<span class="ot">}</span> <span class="ot">{</span>Î£â‚ <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">{</span>Î£â‚‚ <span class="ot">:</span> <span class="dt">Set</span> b<span class="ot">}</span> â¦ƒ <span class="ot">_</span> <span class="ot">:</span> Ïƒ Î£â‚ â¦„ â¦ƒ <span class="ot">_</span> <span class="ot">:</span> Ïƒ Î£â‚‚ â¦„ <span class="ot">{</span>ğ“‚ f<span class="ot">}</span></a>
<a class="sourceLine" id="cb8-13" data-line-number="13">      <span class="ot">â†’</span> Arg Î£â‚ ğ“‚ f</a>
<a class="sourceLine" id="cb8-14" data-line-number="14">      <span class="ot">â†’</span> <span class="ot">((</span>x <span class="ot">:</span> Î£â‚<span class="ot">)</span> <span class="ot">â†’</span> â¦ƒ xâ‰ˆ <span class="ot">:</span> Î¼ x â‰ˆ ğ“‚ â¦„ <span class="ot">â†’</span> Î¼âŸ¨ Î£â‚‚ âŸ©â‰ˆ f <span class="ot">(</span>Î¼ x<span class="ot">))</span></a>
<a class="sourceLine" id="cb8-15" data-line-number="15">      <span class="ot">â†’</span> Î¼âŸ¨ Î£â‚‚ âŸ©â‰ˆ f ğ“‚</a>
<a class="sourceLine" id="cb8-16" data-line-number="16">arg-syntax cng xs &gt;&gt;= k <span class="ot">=</span> k <span class="ot">(</span>ğ“¢ xs<span class="ot">)</span> â¦ƒ ğ’» xs â¦„ â‰ˆ[ cng <span class="ot">(</span>ğ’» xs<span class="ot">)</span> ]</a></code></pre></div>
<p>First, we define a wrapper for types parameterised by their summary, with a way to lift an underlying equality up into some expression <code>f</code>. The <code>&gt;&gt;=</code> operator just connects up all of the relevant bits. An example is whatâ€™s needed:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb9-1" data-line-number="1">listToTree <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">{</span>Î£ <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> â¦ƒ <span class="ot">_</span> <span class="ot">:</span> Ïƒ Î£ â¦„ <span class="ot">â†’</span> <span class="ot">(</span>xs <span class="ot">:</span> List Î£<span class="ot">)</span> <span class="ot">â†’</span> Î¼âŸ¨ Tree Î£ âŸ©â‰ˆ Î¼ xs</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">listToTree [] <span class="ot">=</span> empty â‡‘</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">listToTree <span class="ot">(</span>x âˆ· xs<span class="ot">)</span> <span class="ot">=</span> [ â„³ â†¯ ]â‰ˆ do</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">  ys â† listToTree xs [ Î¼ x âˆ™&gt; s âŸ¿ s ]</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  x â—‚ ys</a></code></pre></div>
<p>The first line is the base case, nothing interesting going on there. The second line begins the do-notation, but first applies <code>[ â„³ â†¯ ]â‰ˆ</code>: this calls the automated solver. The second line makes the recursive call, and with the syntax:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb10-1" data-line-number="1">[ Î¼ x âˆ™&gt; s âŸ¿ s ]</a></code></pre></div>
<p>It tells us where the size of the bound variable will end up in the outer expression.</p>
<div id="refs" class="references">
<div id="ref-danielsson_lightweight_2008">
<p>Danielsson, Nils Anders. 2008. â€œLightweight Semiformal Time Complexity Analysis for Purely Functional Data Structures.â€ In <em>Proceedings of the 35th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</em>, 133â€“144. POPL â€™08. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/1328438.1328457">10.1145/1328438.1328457</a>. <a href="http://www.cse.chalmers.se/~nad/publications/danielsson-popl2008.pdf" class="uri">http://www.cse.chalmers.se/~nad/publications/danielsson-popl2008.pdf</a>.</p>
</div>
<div id="ref-hinze_simple_2001">
<p>Hinze, Ralf. 2001. â€œA Simple Implementation Technique for Priority Search Queues.â€ In <em>Proceedings of the 2001 International Conference on Functional Programming</em>, 110â€“121. ACM Press. doi:<a href="https://doi.org/10.1145/507635.507650">10.1145/507635.507650</a>. <a href="https://www.cs.ox.ac.uk/people/ralf.hinze/publications/\#P14" class="uri">https://www.cs.ox.ac.uk/people/ralf.hinze/publications/\#P14</a>.</p>
</div>
<div id="ref-Hinze-Paterson:FingerTree">
<p>Hinze, Ralf, and Ross Paterson. 2006. â€œFinger Trees: A Simple General-purpose Data Structure.â€ <em>Journal of Functional Programming</em> 16 (2): 197â€“217. <a href="http://www.staff.city.ac.uk/~ross/papers/FingerTree.html" class="uri">http://www.staff.city.ac.uk/~ross/papers/FingerTree.html</a>.</p>
</div>
<div id="ref-mu_queueing_2016">
<p>Mu, Shin-Cheng, Yu-Hsi Chiang, and Yu-Han Lyu. 2016. â€œQueueing and Glueing for Optimal Partitioning (Functional Pearl).â€ In <em>Proceedings of the 21st ACM SIGPLAN International Conference on Functional Programming</em>, 158â€“167. ICFP 2016. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/2951913.2951923">10.1145/2951913.2951923</a>. <a href="https://www.iis.sinica.edu.tw/~scm/pub/queueing-glueing.pdf" class="uri">https://www.iis.sinica.edu.tw/~scm/pub/queueing-glueing.pdf</a>.</p>
</div>
<div id="ref-sozeau_program-ing_2007">
<p>Sozeau, Matthieu. 2007. â€œProgram-ing Finger Trees in Coq.â€ In <em>Proceedings of the 12th ACM SIGPLAN International Conference on Functional Programming</em>, 13â€“24. ICFP â€™07. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/1291151.1291156">10.1145/1291151.1291156</a>. <a href="https://www.irif.fr/~sozeau/research/publications/Program-ing_Finger_Trees_in_Coq.pdf" class="uri">https://www.irif.fr/~sozeau/research/publications/Program-ing_Finger_Trees_in_Coq.pdf</a>.</p>
</div>
</div>
]]></description>
    <pubDate>Mon, 25 Feb 2019 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2019-02-25-agda-fingertrees.html</guid>
    <dc:creator>Donnacha OisÃ­n Kidney</dc:creator>
</item>
<item>
    <title>A New Ring Solver for Agda</title>
    <link>https://doisinkidney.com/posts/2019-01-25-agda-ring-solver.html</link>
    <description><![CDATA[<div class="info">
    Posted on January 25, 2019
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Agda.html">Agda</a>
    
</div>

<p>Iâ€™m finally a the point where I feel like I can make the project Iâ€™ve been working on for the past few months public: <a href="https://oisdk.github.io/agda-ring-solver/README.html">A Ring Solver for Agda</a>. The focus of the project is ergonomics and ease-of-use: hopefully the interface to the solver is simpler and more friendly than the one thatâ€™s already there. It can do step-by-step solutions (like Wolfram Alpha). Itâ€™s also asymptotically faster than the old solver (and actually faster! The usual optimizations you might apply donâ€™t actually work here, so this bit definitely took the most work).</p>
<p>Anyway, this work is all for my undergrad final year project, but Iâ€™m hoping to submit it to a conference or something in the next few weeks.</p>
]]></description>
    <pubDate>Fri, 25 Jan 2019 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2019-01-25-agda-ring-solver.html</guid>
    <dc:creator>Donnacha OisÃ­n Kidney</dc:creator>
</item>
<item>
    <title>A Binomial Urn</title>
    <link>https://doisinkidney.com/posts/2019-01-15-binomial-urn.html</link>
    <description><![CDATA[<div class="info">
    Posted on January 15, 2019
</div>
<div class="info">
    
        Part 3 of a <a href="/series/Balanced%20Folds.html">3-part series on Balanced Folds</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<p>When we started the series, we wanted to find a â€œbetterâ€ fold: one that was more balanced than either <code>foldl</code> or <code>foldr</code> (in its placement of parentheses). Both of these are about as unbalanced as you can get:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> foldr (<span class="fu">+</span>) <span class="dv">0</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="dv">1</span> <span class="fu">+</span> (<span class="dv">2</span> <span class="fu">+</span> (<span class="dv">3</span> <span class="fu">+</span> <span class="dv">0</span>))</a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="fu">&gt;&gt;&gt;</span> foldl (<span class="fu">+</span>) <span class="dv">0</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">((<span class="dv">0</span> <span class="fu">+</span> <span class="dv">1</span>) <span class="fu">+</span> <span class="dv">2</span>) <span class="fu">+</span> <span class="dv">3</span></a></code></pre></div>
<p>The first better fold I found was Jon Fairbairnâ€™s simple <code>treeFold</code>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">treeFold ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">treeFold f <span class="fu">=</span> go</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">    go x [] <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">    go a  (b<span class="fu">:</span>l) <span class="fu">=</span> go (f a b) (pairMap l)</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">    pairMap (x<span class="fu">:</span>y<span class="fu">:</span>rest) <span class="fu">=</span> f x y <span class="fu">:</span> pairMap rest</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">    pairMap xs <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">  </a>
<a class="sourceLine" id="cb2-9" data-line-number="9"><span class="fu">&gt;&gt;&gt;</span> treeFold (<span class="fu">+</span>) <span class="dv">0</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb2-10" data-line-number="10">(<span class="dv">0</span> <span class="fu">+</span> <span class="dv">1</span>) <span class="fu">+</span> (<span class="dv">2</span> <span class="fu">+</span> <span class="dv">3</span>)</a></code></pre></div>
<p>Already this function was kind of magical: if your binary operator merges two sorted lists, <code>foldr</code> will give you insertion sort, whereas <code>treeFold</code> will give you merge sort; for summing floats, <code>treeFold</code> has a lower error growth than <code>sum</code>. By dividing up the work better, we were able to improve the characteristics of many algorithms automatically. We also saw that it could easily be made parallel:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">parseq ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">parseq a b <span class="fu">=</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">    runST</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">        (bool (par a b) (seq a b) <span class="fu">&lt;$&gt;</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">         unsafeIOToST (liftA2 (<span class="fu">&gt;</span>) numSparks getNumCapabilities))</a>
<a class="sourceLine" id="cb3-6" data-line-number="6"></a>
<a class="sourceLine" id="cb3-7" data-line-number="7"><span class="ot">treeFoldParallel ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb3-8" data-line-number="8">treeFoldParallel f <span class="fu">=</span></a>
<a class="sourceLine" id="cb3-9" data-line-number="9">    treeFold</a>
<a class="sourceLine" id="cb3-10" data-line-number="10">        (\l r <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb3-11" data-line-number="11">              r <span class="ot">`parseq`</span> (l <span class="ot">`parseq`</span> f l r))</a></code></pre></div>
<p>In the next post, we saw how we could make the fold incremental, by using binary number representations for data structures. This let us do 2 things: it meant the fold was structurally terminating, so it would pass the termination checker (efficiently) in languages like Agda or Idris, and it meant we could write <code>scanl</code> using the fold. The <code>scanl</code> was also efficient: you could run the fold at any point in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math> time, and work would be shared between subsequent runs. Effectively, this let us use it to solve greedy optimization problems. We also saw how it was effectively constructing an implicit binomial priority queue under the hood, and how it exploited laziness to get sharing.</p>
<p>Iâ€™ve gotten huge mileage out of this fold and the general ideas about it, and today Iâ€™m going to show one more use of it. Weâ€™re going to improve some of the asymptotics of the data structure presented in <span class="citation" data-cites="lampropoulos_ode_2017">Lampropoulos, Spector-Zabusky, and Foner (<a href="#ref-lampropoulos_ode_2017">2017</a>)</span>.</p>
<h1 id="a-random-urn">A Random Urn</h1>
<p>The paper opens with the problem:</p>
<blockquote>
<p>Suppose you have an urn containing two red balls, four green balls, and three blue balls. If you take three balls out of the urn, what is the probability that two of them are green?</p>
</blockquote>
<p>If you were to take just <em>one</em> ball out of the earn, calculating the associated probabilities would be easy. Once you get to the second, though, you have to update the previous probability <em>based on what ball was removed</em>. In other words, we need to be able to dynamically update the distribution.</p>
<p>Using lists, this would obviously become an <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n)</annotation></semantics></math> operation. In the paper, an almost-perfect binary tree is used. This turns the operation into one thatâ€™s <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math>. The rest of the operations have the following complexities:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Operation</th>
<th>Complexity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>insert</code></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>remove</code></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>fromList</code></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n)</annotation></semantics></math></td>
</tr>
</tbody>
</table>
<p>As a quick spoiler, the improved version presented here has these complexities:</p>
<table>
<thead>
<tr class="header">
<th>Operation</th>
<th>Complexity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>insert</code></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math></td>
</tr>
<tr class="even">
<td><code>remove</code></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math></td>
</tr>
<tr class="odd">
<td><code>merge</code></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math></td>
</tr>
<tr class="even">
<td><code>fromList</code></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n)</annotation></semantics></math></td>
</tr>
</tbody>
</table>
<p>We add another operation (<code>merge</code>), which means that the new structure is viable as an instance of <code>Alternative</code>, <code>Monad</code>, and so on, making it an efficient monad for weighted backtracking search.</p>
<h1 id="priority-queues">Priority Queues</h1>
<p>The key thing to notice in the paper which will let us improve the structure is that what theyâ€™re designing is actually a <em>priority queue</em>. Well, a weird looking priority queue, but a priority queue nonetheless.</p>
<p>Think about it like a max-priority queue (pop returns the largest element first), with a degree of â€œrandomizationâ€. In other words, when you go to do a pop, all of the comparisons between the ordering keys (the weights in this case) sprinkles some randomness into the equation, meaning that instead of <code>1 &lt; 2</code> returning <code>True</code>, it returns <code>True</code> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mn>2</mn><mn>3</mn></mfrac><annotation encoding="application/x-tex">\frac{2}{3}</annotation></semantics></math> of the time, and <code>False</code> the other <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mn>1</mn><mn>3</mn></mfrac><annotation encoding="application/x-tex">\frac{1}{3}</annotation></semantics></math>.</p>
<p>This way of doing things means that not every priority queue is suitable: we want to run comparisons at <code>pop</code> time (not <code>insert</code>), so a binary heap (for instance) wonâ€™t do. At branches (non-leaves), the queue will only be allowed store <em>summaries</em> of the data, not the â€œmax elementâ€.</p>
<p>The one presented in the paper is something like a Braun priority queue: the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n)</annotation></semantics></math> <code>fromList</code> implementation is reminiscent of the one in <span class="citation" data-cites="okasaki_three_1997">Okasaki (<a href="#ref-okasaki_three_1997">1997</a>)</span>.</p>
<p>So what priority queue can we choose to get us the desired efficiency? Why, a binomial one of course!</p>
<h1 id="the-data-structure">The Data Structure</h1>
<p>The urn structure itself looks a lot like a binomial heap:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">Tree</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  {<span class="ot"> weight ::</span> <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">Word</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">  ,<span class="ot"> branch ::</span> <span class="dt">Node</span> a</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">  }</a>
<a class="sourceLine" id="cb4-6" data-line-number="6"></a>
<a class="sourceLine" id="cb4-7" data-line-number="7"><span class="kw">data</span> <span class="dt">Node</span> a</a>
<a class="sourceLine" id="cb4-8" data-line-number="8">  <span class="fu">=</span> <span class="dt">Leaf</span> a</a>
<a class="sourceLine" id="cb4-9" data-line-number="9">  <span class="fu">|</span> <span class="dt">Branch</span> (<span class="dt">Tree</span> a) (<span class="dt">Node</span> a)</a>
<a class="sourceLine" id="cb4-10" data-line-number="10"></a>
<a class="sourceLine" id="cb4-11" data-line-number="11"><span class="kw">data</span> <span class="dt">Heap</span> a</a>
<a class="sourceLine" id="cb4-12" data-line-number="12">  <span class="fu">=</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb4-13" data-line-number="13">  <span class="fu">|</span> <span class="dt">Cons</span> <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">Word</span> (<span class="dt">Tree</span> a) (<span class="dt">Heap</span> a)</a>
<a class="sourceLine" id="cb4-14" data-line-number="14">  </a>
<a class="sourceLine" id="cb4-15" data-line-number="15"><span class="kw">data</span> <span class="dt">Urn</span> a <span class="fu">=</span></a>
<a class="sourceLine" id="cb4-16" data-line-number="16">    <span class="dt">Urn</span> <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">Word</span></a>
<a class="sourceLine" id="cb4-17" data-line-number="17">        <span class="fu">!</span>(<span class="dt">Heap</span> a)</a></code></pre></div>
<p>By avoiding the usual <code>Skip</code> constructors you often see in a binomial heap we save a huge amount of space. Instead, we store the â€œnumber of zeroes before this bitâ€. Another thing to point out is that only left branches in the trees store their weight: the same optimization is made in the paper.</p>
<p>Insertion is not much different from insertion for a usual binomial priority queue, although we donâ€™t need to do anything to merge the trees:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">insertHeap ::</span> <span class="dt">Word</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Heap</span> a <span class="ot">-&gt;</span> <span class="dt">Heap</span> a</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">insertHeap i&#39; x&#39; <span class="fu">=</span> go <span class="dv">0</span> (<span class="dt">Tree</span> i&#39; (<span class="dt">Leaf</span> x&#39;))</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">    go <span class="fu">!</span>i x <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Cons</span> i x <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">    go <span class="fu">!</span>i x (<span class="dt">Cons</span> <span class="dv">0</span> y ys) <span class="fu">=</span> go (i<span class="fu">+</span><span class="dv">1</span>) (mergeTree x y) ys</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">    go <span class="fu">!</span>i x (<span class="dt">Cons</span> j y ys) <span class="fu">=</span> <span class="dt">Cons</span> i x (<span class="dt">Cons</span> (j<span class="fu">-</span><span class="dv">1</span>) y ys)</a>
<a class="sourceLine" id="cb5-7" data-line-number="7"></a>
<a class="sourceLine" id="cb5-8" data-line-number="8"><span class="ot">mergeTree ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb5-9" data-line-number="9">mergeTree xs ys <span class="fu">=</span></a>
<a class="sourceLine" id="cb5-10" data-line-number="10">  <span class="dt">Tree</span></a>
<a class="sourceLine" id="cb5-11" data-line-number="11">    (weight xs <span class="fu">+</span> weight ys)</a>
<a class="sourceLine" id="cb5-12" data-line-number="12">    (<span class="dt">Branch</span> xs (branch ys))</a>
<a class="sourceLine" id="cb5-13" data-line-number="13"></a>
<a class="sourceLine" id="cb5-14" data-line-number="14"><span class="ot">insert ::</span> <span class="dt">Word</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Urn</span> a <span class="ot">-&gt;</span> <span class="dt">Urn</span> a</a>
<a class="sourceLine" id="cb5-15" data-line-number="15">insert i x (<span class="dt">Urn</span> w xs) <span class="fu">=</span> <span class="dt">Urn</span> (w<span class="fu">+</span>i) (insertHeap i x xs)</a></code></pre></div>
<p>We <em>could</em> potentially get insertion from amortized <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math> to worst-case <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math> by using skew binary instead of binary (in fact I am almost sure itâ€™s possible), but then I think weâ€™d lose the efficient merge. Iâ€™ll leave exploring that for another day.</p>
<p>To get randomness, weâ€™ll write a very simple class that encapsulates only what we need:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Sample</span> m <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">    <span class="co">-- | Inclusive range</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="ot">    inRange ::</span> <span class="dt">Word</span> <span class="ot">-&gt;</span> <span class="dt">Word</span> <span class="ot">-&gt;</span> m <span class="dt">Word</span></a></code></pre></div>
<p>You can later instantiate this to whatever random monad you end up using. (The same approach was taken in the paper, although we only require <code>Functor</code> here, not <code>Monad</code>).</p>
<p>Sampling (with replacement) first randomly chooses a tree from the top-level list, and then we drill down into that tree with binary search.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">sample ::</span> (<span class="dt">Functor</span> m, <span class="dt">Sample</span> m) <span class="ot">=&gt;</span> <span class="dt">Urn</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (m a)</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">sample (<span class="dt">Urn</span> _ <span class="dt">Nil</span>) <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">sample (<span class="dt">Urn</span> w&#39; (<span class="dt">Cons</span> _ x&#39; xs&#39;)) <span class="fu">=</span> <span class="dt">Just</span> (fmap (go x&#39; xs&#39;) (inRange <span class="dv">0</span> (w&#39; <span class="fu">-</span> <span class="dv">1</span>)))</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5">    go x <span class="dt">Nil</span> <span class="fu">!</span>w <span class="fu">=</span> go&#39; w (branch x)</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">    go x (<span class="dt">Cons</span> _ y ys) <span class="fu">!</span>w</a>
<a class="sourceLine" id="cb7-7" data-line-number="7">      <span class="fu">|</span> w <span class="fu">&lt;</span> weight x <span class="fu">=</span> go&#39; w (branch x)</a>
<a class="sourceLine" id="cb7-8" data-line-number="8">      <span class="fu">|</span> otherwise    <span class="fu">=</span> go y ys (w <span class="fu">-</span> weight x)</a>
<a class="sourceLine" id="cb7-9" data-line-number="9">    go&#39; <span class="fu">!</span>_ (<span class="dt">Leaf</span> x) <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb7-10" data-line-number="10">    go&#39; <span class="fu">!</span>i (<span class="dt">Branch</span> xs ys)</a>
<a class="sourceLine" id="cb7-11" data-line-number="11">      <span class="fu">|</span> i <span class="fu">&lt;</span> weight xs <span class="fu">=</span> go&#39; i (branch xs)</a>
<a class="sourceLine" id="cb7-12" data-line-number="12">      <span class="fu">|</span> otherwise <span class="fu">=</span> go&#39; (i <span class="fu">-</span> weight xs) ys</a></code></pre></div>
<p>So weâ€™re off to a good start, but <code>remove</code> is a complex operation. We take the same route taken in the paper: first, we perform an â€œunconsâ€-like operation, which pops out the last inserted element. Then, we randomly choose a point in the tree (using the same logic as in <code>sample</code>), and replace it with the popped element<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">remove ::</span> (<span class="dt">Functor</span> m, <span class="dt">Sample</span> m) <span class="ot">=&gt;</span> <span class="dt">Urn</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (m ((a, <span class="dt">Word</span>), <span class="dt">Urn</span> a))</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">remove (<span class="dt">Urn</span> w hp) <span class="fu">=</span> fmap go&#39; (Heap.uninsert hp)</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">    go&#39; (vw,v,hp&#39;) <span class="fu">=</span> fmap (<span class="ot">`go`</span> hp&#39;) (inRange <span class="dv">0</span> (w<span class="fu">-</span><span class="dv">1</span>))</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">        go <span class="fu">!</span>_  <span class="dt">Nil</span> <span class="fu">=</span> ((v, vw), <span class="dt">Urn</span> <span class="dv">0</span> <span class="dt">Nil</span>)</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">        go <span class="fu">!</span>rw vs<span class="fu">@</span>(<span class="dt">Cons</span> i&#39; x&#39; xs&#39;)</a>
<a class="sourceLine" id="cb8-8" data-line-number="8">          <span class="fu">|</span> rw <span class="fu">&lt;</span> vw <span class="fu">=</span> ((v, vw), <span class="dt">Urn</span> (w <span class="fu">-</span> vw) vs)</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">          <span class="fu">|</span> otherwise <span class="fu">=</span> replace (rw <span class="fu">-</span> vw) i&#39; x&#39; xs&#39;</a>
<a class="sourceLine" id="cb8-10" data-line-number="10">            (\ys yw y <span class="ot">-&gt;</span> ((y, yw), <span class="dt">Urn</span> (w <span class="fu">-</span> yw) ys))</a>
<a class="sourceLine" id="cb8-11" data-line-number="11"></a>
<a class="sourceLine" id="cb8-12" data-line-number="12">        replace <span class="fu">!</span>rw i x <span class="dt">Nil</span> k <span class="fu">=</span> replaceTree rw x (\t <span class="ot">-&gt;</span> k (<span class="dt">Cons</span> i t <span class="dt">Nil</span>))</a>
<a class="sourceLine" id="cb8-13" data-line-number="13">        replace <span class="fu">!</span>rw i x xs<span class="fu">@</span>(<span class="dt">Cons</span> j y ys) k</a>
<a class="sourceLine" id="cb8-14" data-line-number="14">          <span class="fu">|</span> rw <span class="fu">&lt;</span> weight x <span class="fu">=</span> replaceTree rw x (\t <span class="ot">-&gt;</span> k (<span class="dt">Cons</span> i t xs))</a>
<a class="sourceLine" id="cb8-15" data-line-number="15">          <span class="fu">|</span> otherwise <span class="fu">=</span> replace (rw <span class="fu">-</span> weight x) j y ys (k <span class="fu">.</span> <span class="dt">Cons</span> i x)</a>
<a class="sourceLine" id="cb8-16" data-line-number="16"></a>
<a class="sourceLine" id="cb8-17" data-line-number="17">        replaceTree <span class="fu">!</span>_  (<span class="dt">Tree</span> tw (<span class="dt">Leaf</span> x)) k <span class="fu">=</span> k (<span class="dt">Tree</span> vw (<span class="dt">Leaf</span> v)) tw x</a>
<a class="sourceLine" id="cb8-18" data-line-number="18">        replaceTree <span class="fu">!</span>rw (<span class="dt">Tree</span> tw (<span class="dt">Branch</span> xs ys)) k</a>
<a class="sourceLine" id="cb8-19" data-line-number="19">          <span class="fu">|</span> rw <span class="fu">&lt;</span> weight xs <span class="fu">=</span> replaceTree rw xs</a>
<a class="sourceLine" id="cb8-20" data-line-number="20">            (\t <span class="ot">-&gt;</span> k (<span class="dt">Tree</span> (tw <span class="fu">+</span> (weight t <span class="fu">-</span> weight xs)) (<span class="dt">Branch</span> t ys)))</a>
<a class="sourceLine" id="cb8-21" data-line-number="21">          <span class="fu">|</span> otherwise <span class="fu">=</span> replaceTree (rw <span class="fu">-</span> weight xs)</a>
<a class="sourceLine" id="cb8-22" data-line-number="22">            (<span class="dt">Tree</span> (tw <span class="fu">-</span> weight xs) ys)</a>
<a class="sourceLine" id="cb8-23" data-line-number="23">            (\t <span class="ot">-&gt;</span> k (<span class="dt">Tree</span> (weight xs <span class="fu">+</span> weight t) (<span class="dt">Branch</span> xs (branch t))))</a></code></pre></div>
<p>Merge is the same as on binomial heaps:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">mergeHeap ::</span> <span class="dt">Heap</span> a <span class="ot">-&gt;</span> <span class="dt">Heap</span> a <span class="ot">-&gt;</span> <span class="dt">Heap</span> a</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">mergeHeap <span class="dt">Nil</span> <span class="fu">=</span> id</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">mergeHeap (<span class="dt">Cons</span> i&#39; x&#39; xs&#39;) <span class="fu">=</span> merger i&#39; x&#39; xs&#39;</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">    merger <span class="fu">!</span>i x xs <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Cons</span> i x xs</a>
<a class="sourceLine" id="cb9-6" data-line-number="6">    merger <span class="fu">!</span>i x xs (<span class="dt">Cons</span> j y ys) <span class="fu">=</span> merge&#39; i x xs j y ys</a>
<a class="sourceLine" id="cb9-7" data-line-number="7"></a>
<a class="sourceLine" id="cb9-8" data-line-number="8">    merge&#39; <span class="fu">!</span>i x xs <span class="fu">!</span>j y ys <span class="fu">=</span> <span class="kw">case</span> compare i j <span class="kw">of</span></a>
<a class="sourceLine" id="cb9-9" data-line-number="9">        <span class="dt">LT</span> <span class="ot">-&gt;</span> <span class="dt">Cons</span> i x (merger (j<span class="fu">-</span>i<span class="fu">-</span><span class="dv">1</span>) y ys xs)</a>
<a class="sourceLine" id="cb9-10" data-line-number="10">        <span class="dt">GT</span> <span class="ot">-&gt;</span> <span class="dt">Cons</span> j y (merger (i<span class="fu">-</span>j<span class="fu">-</span><span class="dv">1</span>) x xs ys)</a>
<a class="sourceLine" id="cb9-11" data-line-number="11">        <span class="dt">EQ</span> <span class="ot">-&gt;</span> mergec (succ i) (mergeTree x y) xs ys</a>
<a class="sourceLine" id="cb9-12" data-line-number="12"></a>
<a class="sourceLine" id="cb9-13" data-line-number="13">    mergec <span class="fu">!</span>p <span class="fu">!</span>t <span class="dt">Nil</span> <span class="fu">=</span> carryLonger p t</a>
<a class="sourceLine" id="cb9-14" data-line-number="14">    mergec <span class="fu">!</span>p <span class="fu">!</span>t (<span class="dt">Cons</span> i x xs) <span class="fu">=</span> mergecr p t i x xs</a>
<a class="sourceLine" id="cb9-15" data-line-number="15"></a>
<a class="sourceLine" id="cb9-16" data-line-number="16">    mergecr <span class="fu">!</span>p <span class="fu">!</span>t <span class="fu">!</span>i x xs <span class="dt">Nil</span> <span class="fu">=</span> carryLonger&#39; p t i x xs</a>
<a class="sourceLine" id="cb9-17" data-line-number="17">    mergecr <span class="fu">!</span>p <span class="fu">!</span>t <span class="fu">!</span>i x xs (<span class="dt">Cons</span> j y ys) <span class="fu">=</span> mergec&#39; p t i x xs j y ys</a>
<a class="sourceLine" id="cb9-18" data-line-number="18"></a>
<a class="sourceLine" id="cb9-19" data-line-number="19">    mergec&#39; <span class="fu">!</span>p t <span class="fu">!</span>i x xs <span class="fu">!</span>j y ys <span class="fu">=</span> <span class="kw">case</span> compare i j <span class="kw">of</span></a>
<a class="sourceLine" id="cb9-20" data-line-number="20">      <span class="dt">LT</span> <span class="ot">-&gt;</span> mergecr&#39;&#39; p t i x xs (j<span class="fu">-</span>i<span class="fu">-</span><span class="dv">1</span>) y ys</a>
<a class="sourceLine" id="cb9-21" data-line-number="21">      <span class="dt">GT</span> <span class="ot">-&gt;</span> mergecr&#39;&#39; p t j y ys (i<span class="fu">-</span>j<span class="fu">-</span><span class="dv">1</span>) x xs</a>
<a class="sourceLine" id="cb9-22" data-line-number="22">      <span class="dt">EQ</span> <span class="ot">-&gt;</span> <span class="dt">Cons</span> p t (mergec i (mergeTree x y) xs ys)</a>
<a class="sourceLine" id="cb9-23" data-line-number="23"></a>
<a class="sourceLine" id="cb9-24" data-line-number="24">    mergecr&#39;&#39; <span class="fu">!</span>p <span class="fu">!</span>t  <span class="dv">0</span> x xs <span class="fu">!</span>j y ys <span class="fu">=</span> mergecr (p<span class="fu">+</span><span class="dv">1</span>) (mergeTree t x) j y ys xs</a>
<a class="sourceLine" id="cb9-25" data-line-number="25">    mergecr&#39;&#39; <span class="fu">!</span>p <span class="fu">!</span>t <span class="fu">!</span>i x xs <span class="fu">!</span>j y ys <span class="fu">=</span> <span class="dt">Cons</span> p t (<span class="dt">Cons</span> (i<span class="fu">-</span><span class="dv">1</span>) x (merger j y ys xs))</a>
<a class="sourceLine" id="cb9-26" data-line-number="26"></a>
<a class="sourceLine" id="cb9-27" data-line-number="27">    carryLonger <span class="fu">!</span>i <span class="fu">!</span>t <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Cons</span> i t <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb9-28" data-line-number="28">    carryLonger <span class="fu">!</span>i <span class="fu">!</span>t (<span class="dt">Cons</span> j y ys) <span class="fu">=</span> carryLonger&#39; i t j y ys</a>
<a class="sourceLine" id="cb9-29" data-line-number="29"></a>
<a class="sourceLine" id="cb9-30" data-line-number="30">    carryLonger&#39; <span class="fu">!</span>i <span class="fu">!</span>t  <span class="dv">0</span> y ys <span class="fu">=</span> carryLonger (succ i) (mergeTree t y) ys</a>
<a class="sourceLine" id="cb9-31" data-line-number="31">    carryLonger&#39; <span class="fu">!</span>i <span class="fu">!</span>t <span class="fu">!</span>j y ys <span class="fu">=</span> <span class="dt">Cons</span> i t (<span class="dt">Cons</span> (j<span class="fu">-</span><span class="dv">1</span>) y ys)</a>
<a class="sourceLine" id="cb9-32" data-line-number="32"></a>
<a class="sourceLine" id="cb9-33" data-line-number="33"><span class="ot">merge ::</span> <span class="dt">Urn</span> a <span class="ot">-&gt;</span> <span class="dt">Urn</span> a <span class="ot">-&gt;</span> <span class="dt">Urn</span> a</a>
<a class="sourceLine" id="cb9-34" data-line-number="34">merge (<span class="dt">Urn</span> i xs) (<span class="dt">Urn</span> j ys) <span class="fu">=</span> <span class="dt">Urn</span> (i<span class="fu">+</span>j) (mergeHeap xs ys)   </a></code></pre></div>
<h1 id="finger-trees">Finger Trees</h1>
<p>Again, the cleverness of all the tree folds is that they intelligently batch summarizing operations, allowing you to efficiently so prefix-scan-like operations that exploit sharing.</p>
<p>The bare-bones version just uses binary numbers: you can upgrade the <code>cons</code> operation to worst-case constant-time if you use <em>skew</em> binary. Are there other optimizations? Yes! What if we wanted to stick something on to the <em>other</em> end, for instance? What if we wanted to reverse?</p>
<p>If you figure out a way to do <em>all</em> these optimizations, and put them into one big data structure, you get the mother-of-all â€œbatchingâ€ data structures: the finger tree. This is the basis for Haskellâ€™s Data.Sequence, but it can also implement priority queues, urns (Iâ€™d imagine), fenwick-tree-like structures, and more.</p>
<h1 id="uses-and-further-work">Uses and Further Work</h1>
<p>First and foremost, I should test the above implementations! Iâ€™m pretty confident the asymptotics are correct, but Iâ€™m certain the implementations have bugs.</p>
<p>The efficient <code>merge</code> is intriguing: it means that <code>Urn</code> could conceivably be <code>Alternative</code>, <code>MonadPlus</code>, etc. I have yet to see a use for that, but itâ€™s interesting nonetheless! Iâ€™m constantly looking for a way to express something like Dijkstraâ€™s algorithm algebraicly, using the usual <code>Alternative</code> combinators; I donâ€™t know if this is related.</p>
<p>The other interesting point is that, for this to be an instance of <code>Applicative</code>, it would need some analogue for multiplication for the weights. Iâ€™m not sure what that should be.</p>
<p>This is inherently <em>max</em>-priority. Itâ€™s not obvious how to translate what we have into a min-priority queue version.</p>
<p>Finally, it might be worth trying out different priority queues (a pairing heap is very similar in structure to this). Also, we could rearrange the weights so that larger ones are higher in each tree: this might give a performance boost.</p>
<div id="refs" class="references">
<div id="ref-lampropoulos_ode_2017">
<p>Lampropoulos, Leonidas, Antal Spector-Zabusky, and Kenneth Foner. 2017. â€œOde on a random urn (functional pearl).â€ In, 26â€“37. ACM Press. doi:<a href="https://doi.org/10.1145/3122955.3122959">10.1145/3122955.3122959</a>. <a href="https://www.cis.upenn.edu/~llamp/pdf/urns.pdf" class="uri">https://www.cis.upenn.edu/~llamp/pdf/urns.pdf</a>.</p>
</div>
<div id="ref-okasaki_three_1997">
<p>Okasaki, Chris. 1997. â€œThree Algorithms on Braun Trees.â€ <em>Journal of Functional Programming</em> 7 (6) (November): 661â€“666. doi:<a href="https://doi.org/10.1017/S0956796897002876">10.1017/S0956796897002876</a>. <a href="https://www.eecs.northwestern.edu/~robby/courses/395-495-2013-fall/three-algorithms-on-braun-trees.pdf" class="uri">https://www.eecs.northwestern.edu/~robby/courses/395-495-2013-fall/three-algorithms-on-braun-trees.pdf</a>.</p>
</div>
</div>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Thereâ€™s one extra step I havenâ€™t mentioned: we also must allow the first element (the last inserted) to be chosen, so we run the random-number generator once to check if thatâ€™s the element we want to choose.<a href="#fnref1" class="footnote-back">â†©</a></p></li>
</ol>
</section>
]]></description>
    <pubDate>Tue, 15 Jan 2019 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2019-01-15-binomial-urn.html</guid>
    <dc:creator>Donnacha OisÃ­n Kidney</dc:creator>
</item>
<item>
    <title>Balancing Scans</title>
    <link>https://doisinkidney.com/posts/2018-12-21-balancing-scans.html</link>
    <description><![CDATA[<div class="info">
    Posted on December 21, 2018
</div>
<div class="info">
    
        Part 2 of a <a href="/series/Balanced%20Folds.html">3-part series on Balanced Folds</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Agda.html">Agda</a>
    
</div>

<p><a href="2017-10-30-balancing-folds.html">Previously</a> I tried to figure out a way to fold lists in a more balanced way. Usually, when folding lists, youâ€™ve got two choices for your folds, both of which are extremely unbalanced in one direction or another. Jon Fairbairn <a href="https://www.mail-archive.com/haskell@haskell.org/msg01788.html">wrote</a> a more balanced version, which looked something like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">treeFold ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">treeFold f <span class="fu">=</span> go</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">    go x [] <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">    go a (b<span class="fu">:</span>l) <span class="fu">=</span> go (f a b) (pairMap l)</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">    pairMap (x<span class="fu">:</span>y<span class="fu">:</span>rest) <span class="fu">=</span> f x y <span class="fu">:</span> pairMap rest</a>
<a class="sourceLine" id="cb1-7" data-line-number="7">    pairMap xs <span class="fu">=</span> xs</a></code></pre></div>
<h1 id="magical-speedups">Magical Speedups</h1>
<p>The fold above is kind of magical: for a huge class of algorithms, it kind of â€œautomaticallyâ€ improves some factor of theirs from <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n)</annotation></semantics></math> to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math>. For instance: to sum a list of floats, <code class="sourceCode haskell">foldl&#39; (<span class="fu">+</span>) <span class="dv">0</span></code> will have an error growth of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n)</annotation></semantics></math>; <code>treeFold (+) 0</code>, though, has an error rate of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math>. Similarly, using the following function to merge two sorted lists:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">merge ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">merge [] ys <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">merge (x<span class="fu">:</span>xs) ys <span class="fu">=</span> go x xs ys</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5">    go x xs [] <span class="fu">=</span> x <span class="fu">:</span> xs</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">    go x xs (y<span class="fu">:</span>ys)</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">      <span class="fu">|</span> x <span class="fu">&lt;=</span> y    <span class="fu">=</span> x <span class="fu">:</span> go y ys xs</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">      <span class="fu">|</span> otherwise <span class="fu">=</span> y <span class="fu">:</span> go x xs ys</a></code></pre></div>
<p>We get either insertion sort (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n^2)</annotation></semantics></math>) or merge sort (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n \log n)</annotation></semantics></math>) just depending on which fold you use.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1">foldr    merge [] <span class="fu">.</span> map pure <span class="co">-- n^2</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">treeFold merge [] <span class="fu">.</span> map pure <span class="co">-- n log(n)</span></a></code></pre></div>
<p>Iâ€™ll give some more examples later, but effectively it gives us a better â€œdivideâ€ step in many divide and conquer algorithms.</p>
<h1 id="termination">Termination</h1>
<p>As it was such a useful fold, and so integral to many tricky algorithms, I really wanted to have it available in Agda. Unfortunately, though, the functions (as defined above) arenâ€™t structurally terminating, and there doesnâ€™t <em>look</em> like thereâ€™s an obvious way to make it so. I tried to make well founded recursion work, but the proofs were ugly and slow.</p>
<p>However, we can use some structures from a <a href="2018-11-20-fast-verified-structures.html">previous post</a>: the nested binary sequence, for instance. It has some extra nice properties: instead of nesting the types, we can just apply the combining function.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">mutual</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  <span class="kw">data</span> Tree <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">    2^<span class="ot">_</span>Ã—<span class="ot">_</span>+<span class="ot">_</span> <span class="ot">:</span> â„• <span class="ot">â†’</span> A <span class="ot">â†’</span> Node A <span class="ot">â†’</span> Tree A</a>
<a class="sourceLine" id="cb4-4" data-line-number="4"></a>
<a class="sourceLine" id="cb4-5" data-line-number="5">  <span class="kw">data</span> Node <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">    âŸ¨âŸ©  <span class="ot">:</span> Node A</a>
<a class="sourceLine" id="cb4-7" data-line-number="7">    âŸ¨<span class="ot">_</span>âŸ© <span class="ot">:</span> Tree A <span class="ot">â†’</span> Node A</a>
<a class="sourceLine" id="cb4-8" data-line-number="8"></a>
<a class="sourceLine" id="cb4-9" data-line-number="9"><span class="kw">module</span> TreeFold <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">(_</span>*<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">â†’</span> A <span class="ot">â†’</span> A<span class="ot">)</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-10" data-line-number="10">  <span class="kw">infixr</span> <span class="dv">5</span> <span class="ot">_</span>âŠ›<span class="ot">_</span> 2^<span class="ot">_</span>Ã—<span class="ot">_</span>âŠ›<span class="ot">_</span></a>
<a class="sourceLine" id="cb4-11" data-line-number="11"></a>
<a class="sourceLine" id="cb4-12" data-line-number="12">  2^<span class="ot">_</span>Ã—<span class="ot">_</span>âŠ›<span class="ot">_</span> <span class="ot">:</span> â„• <span class="ot">â†’</span> A <span class="ot">â†’</span> Tree A <span class="ot">â†’</span> Tree A</a>
<a class="sourceLine" id="cb4-13" data-line-number="13">  2^ n Ã— x âŠ› 2^ suc m Ã— y + ys <span class="ot">=</span> 2^ n Ã— x + âŸ¨ 2^ m Ã— y + ys âŸ©</a>
<a class="sourceLine" id="cb4-14" data-line-number="14">  2^ n Ã— x âŠ› 2^ zero  Ã— y + âŸ¨âŸ© <span class="ot">=</span> 2^ suc n Ã— <span class="ot">(</span>x * y<span class="ot">)</span> + âŸ¨âŸ©</a>
<a class="sourceLine" id="cb4-15" data-line-number="15">  2^ n Ã— x âŠ› 2^ zero  Ã— y + âŸ¨ ys âŸ© <span class="ot">=</span> 2^ suc n Ã— <span class="ot">(</span>x * y<span class="ot">)</span> âŠ› ys</a>
<a class="sourceLine" id="cb4-16" data-line-number="16"></a>
<a class="sourceLine" id="cb4-17" data-line-number="17">  <span class="ot">_</span>âŠ›<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">â†’</span> Tree A <span class="ot">â†’</span> Tree A</a>
<a class="sourceLine" id="cb4-18" data-line-number="18">  <span class="ot">_</span>âŠ›<span class="ot">_</span> <span class="ot">=</span> 2^ <span class="dv">0</span> Ã—<span class="ot">_</span>âŠ›<span class="ot">_</span></a>
<a class="sourceLine" id="cb4-19" data-line-number="19"></a>
<a class="sourceLine" id="cb4-20" data-line-number="20">  âŸ¦<span class="ot">_</span>âŸ§â†“ <span class="ot">:</span> Tree A <span class="ot">â†’</span> A</a>
<a class="sourceLine" id="cb4-21" data-line-number="21">  âŸ¦ 2^ <span class="ot">_</span> Ã— x + âŸ¨âŸ© âŸ§â†“ <span class="ot">=</span> x</a>
<a class="sourceLine" id="cb4-22" data-line-number="22">  âŸ¦ 2^ <span class="ot">_</span> Ã— x + âŸ¨ xs âŸ© âŸ§â†“ <span class="ot">=</span> x * âŸ¦ xs âŸ§â†“</a>
<a class="sourceLine" id="cb4-23" data-line-number="23"></a>
<a class="sourceLine" id="cb4-24" data-line-number="24">  âŸ¦<span class="ot">_</span>âŸ§â†‘ <span class="ot">:</span> A <span class="ot">â†’</span> Tree A</a>
<a class="sourceLine" id="cb4-25" data-line-number="25">  âŸ¦ x âŸ§â†‘ <span class="ot">=</span> 2^ <span class="dv">0</span> Ã— x + âŸ¨âŸ©</a>
<a class="sourceLine" id="cb4-26" data-line-number="26"></a>
<a class="sourceLine" id="cb4-27" data-line-number="27">  â¦…<span class="ot">_</span>,<span class="ot">_</span>â¦† <span class="ot">:</span> A <span class="ot">â†’</span> List A <span class="ot">â†’</span> A</a>
<a class="sourceLine" id="cb4-28" data-line-number="28">  â¦… x , xs â¦† <span class="ot">=</span> âŸ¦ foldr <span class="ot">_</span>âŠ›<span class="ot">_</span> âŸ¦ x âŸ§â†‘ xs âŸ§â†“</a></code></pre></div>
<p>Alternatively, we can get <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math> cons with the skew array:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">5</span> <span class="ot">_</span>âŠ›<span class="ot">_</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="ot">_</span>âŠ›<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">â†’</span> Tree A <span class="ot">â†’</span> Tree A</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">x âŠ› 2^ n Ã— y  + âŸ¨âŸ© <span class="ot">=</span> 2^ <span class="dv">0</span> Ã— x + âŸ¨ 2^ n Ã— y + âŸ¨âŸ© âŸ©</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">x âŠ› 2^ n Ã— yâ‚ + âŸ¨ 2^ <span class="dv">0</span>     Ã— yâ‚‚ + ys âŸ© <span class="ot">=</span> 2^ suc n Ã— <span class="ot">(</span>x * <span class="ot">(</span>yâ‚ * yâ‚‚<span class="ot">))</span> + ys</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">x âŠ› 2^ n Ã— yâ‚ + âŸ¨ 2^ suc m Ã— yâ‚‚ + ys âŸ© <span class="ot">=</span> 2^ <span class="dv">0</span> Ã— x + âŸ¨ 2^ n Ã— yâ‚ + âŸ¨ 2^ m Ã— yâ‚‚ + ys âŸ© âŸ©</a></code></pre></div>
<p>Using this, a proper and efficient merge sort is very straightforward:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">data</span> Total <span class="ot">{</span>a r<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">(_</span>â‰¤<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">â†’</span> A <span class="ot">â†’</span> <span class="dt">Set</span> r<span class="ot">)</span> <span class="ot">(</span>x y <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">(</span>a âŠ” r<span class="ot">)</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  xâ‰¤y <span class="ot">:</span> â¦ƒ <span class="ot">_</span> <span class="ot">:</span> x â‰¤ y â¦„ <span class="ot">â†’</span> Total <span class="ot">_</span>â‰¤<span class="ot">_</span> x y</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  yâ‰¤x <span class="ot">:</span> â¦ƒ <span class="ot">_</span> <span class="ot">:</span> y â‰¤ x â¦„ <span class="ot">â†’</span> Total <span class="ot">_</span>â‰¤<span class="ot">_</span> x y</a>
<a class="sourceLine" id="cb6-4" data-line-number="4"></a>
<a class="sourceLine" id="cb6-5" data-line-number="5"><span class="kw">module</span> Sorting <span class="ot">{</span>a r<span class="ot">}</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">               <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span></a>
<a class="sourceLine" id="cb6-7" data-line-number="7">               <span class="ot">{_</span>â‰¤<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">â†’</span> A <span class="ot">â†’</span> <span class="dt">Set</span> r<span class="ot">}</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">               <span class="ot">(_</span>â‰¤?<span class="ot">_</span> <span class="ot">:</span> <span class="ot">âˆ€</span> x y <span class="ot">â†’</span> Total <span class="ot">_</span>â‰¤<span class="ot">_</span> x y<span class="ot">)</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-9" data-line-number="9">  <span class="kw">data</span> [âˆ™] <span class="ot">:</span> <span class="dt">Set</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-10" data-line-number="10">    âŠ¥   <span class="ot">:</span> [âˆ™]</a>
<a class="sourceLine" id="cb6-11" data-line-number="11">    [<span class="ot">_</span>] <span class="ot">:</span> A <span class="ot">â†’</span> [âˆ™]</a>
<a class="sourceLine" id="cb6-12" data-line-number="12"></a>
<a class="sourceLine" id="cb6-13" data-line-number="13">  <span class="kw">data</span> <span class="ot">_</span>â‰¥<span class="ot">_</span> <span class="ot">(</span>x <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">:</span> [âˆ™] <span class="ot">â†’</span> <span class="dt">Set</span> <span class="ot">(</span>a âŠ” r<span class="ot">)</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-14" data-line-number="14">    instance âŒˆ<span class="ot">_</span>âŒ‰ <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>y<span class="ot">}</span> <span class="ot">â†’</span> y â‰¤ x <span class="ot">â†’</span> x â‰¥ [ y ]</a>
<a class="sourceLine" id="cb6-15" data-line-number="15">    instance âŒŠâŠ¥âŒ‹ <span class="ot">:</span> x â‰¥ âŠ¥</a>
<a class="sourceLine" id="cb6-16" data-line-number="16"></a>
<a class="sourceLine" id="cb6-17" data-line-number="17">  <span class="kw">infixr</span> <span class="dv">5</span> <span class="ot">_</span>âˆ·<span class="ot">_</span></a>
<a class="sourceLine" id="cb6-18" data-line-number="18">  <span class="kw">data</span> Ordered <span class="ot">(</span>b <span class="ot">:</span> [âˆ™]<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">(</span>a âŠ” r<span class="ot">)</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-19" data-line-number="19">    []  <span class="ot">:</span> Ordered b</a>
<a class="sourceLine" id="cb6-20" data-line-number="20">    <span class="ot">_</span>âˆ·<span class="ot">_</span> <span class="ot">:</span> <span class="ot">âˆ€</span> x <span class="ot">â†’</span> â¦ƒ xâ‰¥b <span class="ot">:</span> x â‰¥ b â¦„ <span class="ot">â†’</span> <span class="ot">(</span>xs <span class="ot">:</span> Ordered [ x ]<span class="ot">)</span> <span class="ot">â†’</span> Ordered b</a>
<a class="sourceLine" id="cb6-21" data-line-number="21"></a>
<a class="sourceLine" id="cb6-22" data-line-number="22">  <span class="ot">_</span>âˆª<span class="ot">_</span> <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>b<span class="ot">}</span> <span class="ot">â†’</span> Ordered b <span class="ot">â†’</span> Ordered b <span class="ot">â†’</span> Ordered b</a>
<a class="sourceLine" id="cb6-23" data-line-number="23">  [] âˆª ys <span class="ot">=</span> ys</a>
<a class="sourceLine" id="cb6-24" data-line-number="24">  <span class="ot">(</span>x âˆ· xs<span class="ot">)</span> âˆª ys <span class="ot">=</span> âŸ… x âˆ¹ xs âˆª ys âŸ†</a>
<a class="sourceLine" id="cb6-25" data-line-number="25">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-26" data-line-number="26">    âŸ…<span class="ot">_</span>âˆ¹<span class="ot">_</span>âˆª<span class="ot">_</span>âŸ† <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>b<span class="ot">}</span> <span class="ot">â†’</span> <span class="ot">âˆ€</span> x â¦ƒ <span class="ot">_</span> <span class="ot">:</span> x â‰¥ b â¦„ <span class="ot">â†’</span> Ordered [ x ] <span class="ot">â†’</span> Ordered b <span class="ot">â†’</span> Ordered b</a>
<a class="sourceLine" id="cb6-27" data-line-number="27">    âŸ…<span class="ot">_</span>âˆª<span class="ot">_</span>âˆ¹<span class="ot">_</span>âŸ† <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>b<span class="ot">}</span> <span class="ot">â†’</span> Ordered b <span class="ot">â†’</span> <span class="ot">âˆ€</span> y â¦ƒ <span class="ot">_</span> <span class="ot">:</span> y â‰¥ b â¦„ <span class="ot">â†’</span> Ordered [ y ] <span class="ot">â†’</span> Ordered b</a>
<a class="sourceLine" id="cb6-28" data-line-number="28">    merge <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>b<span class="ot">}</span> x y â¦ƒ <span class="ot">_</span> <span class="ot">:</span> x â‰¥ b â¦„ â¦ƒ <span class="ot">_</span> <span class="ot">:</span> y â‰¥ b â¦„</a>
<a class="sourceLine" id="cb6-29" data-line-number="29">          <span class="ot">â†’</span> Total <span class="ot">_</span>â‰¤<span class="ot">_</span> x y</a>
<a class="sourceLine" id="cb6-30" data-line-number="30">          <span class="ot">â†’</span> Ordered [ x ]</a>
<a class="sourceLine" id="cb6-31" data-line-number="31">          <span class="ot">â†’</span> Ordered [ y ]</a>
<a class="sourceLine" id="cb6-32" data-line-number="32">          <span class="ot">â†’</span> Ordered b</a>
<a class="sourceLine" id="cb6-33" data-line-number="33"></a>
<a class="sourceLine" id="cb6-34" data-line-number="34">    âŸ… x âˆ¹ xs âˆª [] âŸ† <span class="ot">=</span> x âˆ· xs</a>
<a class="sourceLine" id="cb6-35" data-line-number="35">    âŸ… x âˆ¹ xs âˆª y âˆ· ys âŸ† <span class="ot">=</span> merge x y <span class="ot">(</span>x â‰¤? y<span class="ot">)</span> xs ys</a>
<a class="sourceLine" id="cb6-36" data-line-number="36">    âŸ… [] âˆª y âˆ¹ ys âŸ† <span class="ot">=</span> y âˆ· ys</a>
<a class="sourceLine" id="cb6-37" data-line-number="37">    âŸ… x âˆ· xs âˆª y âˆ¹ ys âŸ† <span class="ot">=</span> merge x y <span class="ot">(</span>x â‰¤? y<span class="ot">)</span> xs ys</a>
<a class="sourceLine" id="cb6-38" data-line-number="38"></a>
<a class="sourceLine" id="cb6-39" data-line-number="39">    merge x y xâ‰¤y xs ys <span class="ot">=</span> x âˆ· âŸ… xs âˆª y âˆ¹ ys âŸ†</a>
<a class="sourceLine" id="cb6-40" data-line-number="40">    merge x y yâ‰¤x xs ys <span class="ot">=</span> y âˆ· âŸ… x âˆ¹ xs âˆª ys âŸ†</a>
<a class="sourceLine" id="cb6-41" data-line-number="41"></a>
<a class="sourceLine" id="cb6-42" data-line-number="42"></a>
<a class="sourceLine" id="cb6-43" data-line-number="43">  <span class="kw">open</span> TreeFold</a>
<a class="sourceLine" id="cb6-44" data-line-number="44"></a>
<a class="sourceLine" id="cb6-45" data-line-number="45">  sort <span class="ot">:</span> List A <span class="ot">â†’</span> Ordered âŠ¥</a>
<a class="sourceLine" id="cb6-46" data-line-number="46">  sort <span class="ot">=</span> â¦… <span class="ot">_</span>âˆª<span class="ot">_</span> , [] â¦† âˆ˜ map <span class="ot">(_</span>âˆ· []<span class="ot">)</span></a></code></pre></div>
<h1 id="validity">Validity</h1>
<p>It would be nice if we could verify these optimizated versions of folds. Luckily, by writing them using <code>foldr</code>, weâ€™ve stumbled into well-trodden ground: the <em>foldr fusion law</em>. It states that if you have some transformation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>, and two binary operators <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>âŠ•</mo><annotation encoding="application/x-tex">\oplus</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>âŠ—</mo><annotation encoding="application/x-tex">\otimes</annotation></semantics></math>, then:</p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right"><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>âŠ•</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="left"></mtd><mtd columnalign="right"><mo>=</mo><mspace width="0.278em"></mspace></mtd><mtd columnalign="left"><mi>x</mi><mo>âŠ—</mo><mi>f</mi><mi>y</mi></mtd></mtr><mtr><mtd columnalign="right"><mo>âŸ¹</mo><mi>f</mi><mo>âˆ˜</mo><mtext mathvariant="normal">foldr</mtext><mo>âŠ•</mo><mi>e</mi></mtd><mtd columnalign="left"></mtd><mtd columnalign="right"><mo>=</mo><mspace width="0.278em"></mspace></mtd><mtd columnalign="left"><mtext mathvariant="normal">foldr</mtext><mo>âŠ—</mo><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mi>e</mi><mo stretchy="false" form="postfix">)</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align}
   f (x \oplus y)                         &amp;&amp;=\;&amp; x \otimes f y \\
   \implies f \circ \text{foldr} \oplus e &amp;&amp;=\;&amp; \text{foldr} \otimes (f e)
\end{align}</annotation></semantics></math>
<p>This fits right in with the function we used above. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> is <code>âŸ¦_âŸ§â†“</code>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>âŠ•</mo><annotation encoding="application/x-tex">\oplus</annotation></semantics></math> is <code>_âŠ›_</code>, and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>âŠ—</mo><annotation encoding="application/x-tex">\otimes</annotation></semantics></math> is whatever combining function was passed in. Letâ€™s prove the foldr fusion law, then, before we go any further.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">module</span> Proofs</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  <span class="ot">{</span>a r<span class="ot">}</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">  <span class="ot">{</span>R <span class="ot">:</span> Rel A r<span class="ot">}</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6"></a>
<a class="sourceLine" id="cb7-7" data-line-number="7">  <span class="kw">infix</span> <span class="dv">4</span> <span class="ot">_</span>â‰ˆ<span class="ot">_</span></a>
<a class="sourceLine" id="cb7-8" data-line-number="8">  <span class="ot">_</span>â‰ˆ<span class="ot">_</span> <span class="ot">=</span> R</a>
<a class="sourceLine" id="cb7-9" data-line-number="9"></a>
<a class="sourceLine" id="cb7-10" data-line-number="10">  <span class="kw">open</span> <span class="kw">import</span> Algebra<span class="ot">.</span>FunctionProperties <span class="ot">_</span>â‰ˆ<span class="ot">_</span></a>
<a class="sourceLine" id="cb7-11" data-line-number="11"></a>
<a class="sourceLine" id="cb7-12" data-line-number="12">  foldr-universal <span class="ot">:</span> Transitive <span class="ot">_</span>â‰ˆ<span class="ot">_</span></a>
<a class="sourceLine" id="cb7-13" data-line-number="13">                  <span class="ot">â†’</span> <span class="ot">âˆ€</span> <span class="ot">{</span>b<span class="ot">}</span> <span class="ot">{</span>B <span class="ot">:</span> <span class="dt">Set</span> b<span class="ot">}</span> <span class="ot">(</span>h <span class="ot">:</span> List B <span class="ot">â†’</span> A<span class="ot">)</span> f e</a>
<a class="sourceLine" id="cb7-14" data-line-number="14">                  <span class="ot">â†’</span> âˆ€[ f âŠ¢ Congruentâ‚ ]</a>
<a class="sourceLine" id="cb7-15" data-line-number="15">                  <span class="ot">â†’</span> <span class="ot">(</span>h [] â‰ˆ e<span class="ot">)</span></a>
<a class="sourceLine" id="cb7-16" data-line-number="16">                  <span class="ot">â†’</span> <span class="ot">(âˆ€</span> x xs <span class="ot">â†’</span> h <span class="ot">(</span>x âˆ· xs<span class="ot">)</span> â‰ˆ f x <span class="ot">(</span>h xs<span class="ot">))</span></a>
<a class="sourceLine" id="cb7-17" data-line-number="17">                  <span class="ot">â†’</span> <span class="ot">âˆ€</span> xs <span class="ot">â†’</span> h xs â‰ˆ foldr f e xs</a>
<a class="sourceLine" id="cb7-18" data-line-number="18">  foldr-universal <span class="ot">_</span>â—‹<span class="ot">_</span> h f e fâŸ¨<span class="ot">_</span>âŸ© â‡’[] â‡’<span class="ot">_</span>âˆ·<span class="ot">_</span> [] <span class="ot">=</span> â‡’[]</a>
<a class="sourceLine" id="cb7-19" data-line-number="19">  foldr-universal <span class="ot">_</span>â—‹<span class="ot">_</span> h f e fâŸ¨<span class="ot">_</span>âŸ© â‡’[] â‡’<span class="ot">_</span>âˆ·<span class="ot">_</span> <span class="ot">(</span>x âˆ· xs<span class="ot">)</span> <span class="ot">=</span></a>
<a class="sourceLine" id="cb7-20" data-line-number="20">    <span class="ot">(</span>â‡’ x âˆ· xs<span class="ot">)</span> â—‹ fâŸ¨ foldr-universal <span class="ot">_</span>â—‹<span class="ot">_</span> h f e fâŸ¨<span class="ot">_</span>âŸ© â‡’[] â‡’<span class="ot">_</span>âˆ·<span class="ot">_</span> xs âŸ©</a>
<a class="sourceLine" id="cb7-21" data-line-number="21"></a>
<a class="sourceLine" id="cb7-22" data-line-number="22">  foldr-fusion <span class="ot">:</span> Transitive <span class="ot">_</span>â‰ˆ<span class="ot">_</span></a>
<a class="sourceLine" id="cb7-23" data-line-number="23">               <span class="ot">â†’</span> Reflexive <span class="ot">_</span>â‰ˆ<span class="ot">_</span></a>
<a class="sourceLine" id="cb7-24" data-line-number="24">               <span class="ot">â†’</span> <span class="ot">âˆ€</span> <span class="ot">{</span>b c<span class="ot">}</span> <span class="ot">{</span>B <span class="ot">:</span> <span class="dt">Set</span> b<span class="ot">}</span> <span class="ot">{</span>C <span class="ot">:</span> <span class="dt">Set</span> c<span class="ot">}</span> <span class="ot">(</span>f <span class="ot">:</span> C <span class="ot">â†’</span> A<span class="ot">)</span> <span class="ot">{_</span>âŠ•<span class="ot">_</span> <span class="ot">:</span> B <span class="ot">â†’</span> C <span class="ot">â†’</span> C<span class="ot">}</span> <span class="ot">{_</span>âŠ—<span class="ot">_</span> <span class="ot">:</span> B <span class="ot">â†’</span> A <span class="ot">â†’</span> A<span class="ot">}</span> e</a>
<a class="sourceLine" id="cb7-25" data-line-number="25">               <span class="ot">â†’</span> âˆ€[ <span class="ot">_</span>âŠ—<span class="ot">_</span> âŠ¢ Congruentâ‚ ]</a>
<a class="sourceLine" id="cb7-26" data-line-number="26">               <span class="ot">â†’</span> <span class="ot">(âˆ€</span> x y <span class="ot">â†’</span> f <span class="ot">(</span>x âŠ• y<span class="ot">)</span> â‰ˆ x âŠ— f y<span class="ot">)</span></a>
<a class="sourceLine" id="cb7-27" data-line-number="27">               <span class="ot">â†’</span> <span class="ot">âˆ€</span> xs <span class="ot">â†’</span> f <span class="ot">(</span>foldr <span class="ot">_</span>âŠ•<span class="ot">_</span> e xs<span class="ot">)</span> â‰ˆ foldr <span class="ot">_</span>âŠ—<span class="ot">_</span> <span class="ot">(</span>f e<span class="ot">)</span> xs</a>
<a class="sourceLine" id="cb7-28" data-line-number="28">  foldr-fusion <span class="ot">_</span>â—‹<span class="ot">_</span> âˆ h <span class="ot">{</span>f<span class="ot">}</span> <span class="ot">{</span>g<span class="ot">}</span> e gâŸ¨<span class="ot">_</span>âŸ© fuse <span class="ot">=</span></a>
<a class="sourceLine" id="cb7-29" data-line-number="29">    foldr-universal <span class="ot">_</span>â—‹<span class="ot">_</span> <span class="ot">(</span>h âˆ˜ foldr f e<span class="ot">)</span> g <span class="ot">(</span>h e<span class="ot">)</span> gâŸ¨<span class="ot">_</span>âŸ© âˆ <span class="ot">(Î»</span> x xs <span class="ot">â†’</span> fuse x <span class="ot">(</span>foldr f e xs<span class="ot">))</span></a></code></pre></div>
<p>Weâ€™re not using the proofs in Agdaâ€™s standard library because these are tied to propositional equality. In other words, instead of using an abstract binary relation, they prove things over <em>actual</em> equality. Thatâ€™s all well and good, but as you can see above, we donâ€™t need propositional equality: we donâ€™t even need the relation to be an equivalence, we just need transitivity and reflexivity.</p>
<p>After that, we can state precisely what correspondence the tree fold has, and under what conditions it does the same things as a fold:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">module</span> <span class="ot">_</span> <span class="ot">{_</span>*<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">â†’</span> A <span class="ot">â†’</span> A<span class="ot">}</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  <span class="kw">open</span> TreeFold <span class="ot">_</span>*<span class="ot">_</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3"></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">  treeFoldHom <span class="ot">:</span> Transitive <span class="ot">_</span>â‰ˆ<span class="ot">_</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5">              <span class="ot">â†’</span> Reflexive <span class="ot">_</span>â‰ˆ<span class="ot">_</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">              <span class="ot">â†’</span> Associative <span class="ot">_</span>*<span class="ot">_</span></a>
<a class="sourceLine" id="cb8-7" data-line-number="7">              <span class="ot">â†’</span> RightCongruent <span class="ot">_</span>*<span class="ot">_</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8">              <span class="ot">â†’</span> <span class="ot">âˆ€</span> x xs</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">              <span class="ot">â†’</span> â¦… x , xs â¦† â‰ˆ foldr <span class="ot">_</span>*<span class="ot">_</span> x xs</a>
<a class="sourceLine" id="cb8-10" data-line-number="10">  treeFoldHom <span class="ot">_</span>â—‹<span class="ot">_</span> âˆ assoc *âŸ¨<span class="ot">_</span>âŸ© b <span class="ot">=</span> foldr-fusion <span class="ot">_</span>â—‹<span class="ot">_</span> âˆ âŸ¦<span class="ot">_</span>âŸ§â†“ âŸ¦ b âŸ§â†‘ *âŸ¨<span class="ot">_</span>âŸ© <span class="ot">(</span>âŠ›-hom zero<span class="ot">)</span></a>
<a class="sourceLine" id="cb8-11" data-line-number="11">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-12" data-line-number="12">    âŠ›-hom <span class="ot">:</span> <span class="ot">âˆ€</span> n x xs <span class="ot">â†’</span> âŸ¦ 2^ n Ã— x âŠ› xs âŸ§â†“ â‰ˆ x * âŸ¦ xs âŸ§â†“</a>
<a class="sourceLine" id="cb8-13" data-line-number="13">    âŠ›-hom n x <span class="ot">(</span>2^ suc m Ã— y + âŸ¨âŸ©    <span class="ot">)</span> <span class="ot">=</span> âˆ</a>
<a class="sourceLine" id="cb8-14" data-line-number="14">    âŠ›-hom n x <span class="ot">(</span>2^ suc m Ã— y + âŸ¨ ys âŸ©<span class="ot">)</span> <span class="ot">=</span> âˆ</a>
<a class="sourceLine" id="cb8-15" data-line-number="15">    âŠ›-hom n x <span class="ot">(</span>2^ zero  Ã— y + âŸ¨âŸ©    <span class="ot">)</span> <span class="ot">=</span> âˆ</a>
<a class="sourceLine" id="cb8-16" data-line-number="16">    âŠ›-hom n x <span class="ot">(</span>2^ zero  Ã— y + âŸ¨ ys âŸ©<span class="ot">)</span> <span class="ot">=</span> âŠ›-hom <span class="ot">(</span>suc n<span class="ot">)</span> <span class="ot">(</span>x * y<span class="ot">)</span> ys â—‹ assoc x y âŸ¦ ys âŸ§â†“</a></code></pre></div>
<h1 id="implicit-data-structures">â€œImplicitâ€ Data Structures</h1>
<p>Consider the following implementation of the tree above in Haskell:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Tree</span> a <span class="fu">=</span> [(<span class="dt">Int</span>,a)]</a>
<a class="sourceLine" id="cb9-2" data-line-number="2"></a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="ot">cons ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">cons (<span class="fu">*</span>) <span class="fu">=</span> cons&#39; <span class="dv">0</span> </a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6">    cons&#39; n x [] <span class="fu">=</span> [(n,x)]</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">    cons&#39; n x ((<span class="dv">0</span>,y)<span class="fu">:</span>ys) <span class="fu">=</span> cons&#39; (n<span class="fu">+</span><span class="dv">1</span>) (x <span class="fu">*</span> y) ys</a>
<a class="sourceLine" id="cb9-8" data-line-number="8">    cons&#39; n x ((m,y)<span class="fu">:</span>ys) <span class="fu">=</span> (n,x) <span class="fu">:</span> (m<span class="fu">-</span><span class="dv">1</span>,y) <span class="fu">:</span> ys</a></code></pre></div>
<p>The <code>cons</code> function â€œincrementsâ€ that list as if it were the bits of a binary number. Now, consider using the <code>merge</code> function from above, in a pattern like this:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">f <span class="fu">=</span> foldr (cons merge <span class="fu">.</span> pure) []</a></code></pre></div>
<p>What does <code>f</code> build? A list of lists, right?</p>
<p>Kind of. Thatâ€™s whatâ€™s built in terms of the observable, but whatâ€™s actually stored in memory us a bunch of thunks. The shape of <em>those</em> is what Iâ€™m interested in. We can try and see what they look like by using a data structure that doesnâ€™t force on merge:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a <span class="fu">=</span> <span class="dt">Leaf</span> a <span class="fu">|</span> <span class="dt">Tree</span> a <span class="fu">:*:</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb11-2" data-line-number="2"></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">f <span class="fu">=</span> foldr (cons (<span class="fu">:*:</span>) <span class="fu">.</span> <span class="dt">Leaf</span>) []</a></code></pre></div>
<p>Using a handy tree-drawing function, we can see what <code>f [1..13]</code> looks like:</p>
<pre><code>[(0,*),(1,*),(0,*)]
    â””1    â”‚ â”Œ2  â”‚  â”Œ6
          â”‚â”Œâ”¤   â”‚ â”Œâ”¤
          â”‚â”‚â””3  â”‚ â”‚â””7
          â””â”¤    â”‚â”Œâ”¤
           â”‚â”Œ4  â”‚â”‚â”‚â”Œ8
           â””â”¤   â”‚â”‚â””â”¤
            â””5  â”‚â”‚ â””9
                â””â”¤
                 â”‚ â”Œ10
                 â”‚â”Œâ”¤
                 â”‚â”‚â””11
                 â””â”¤
                  â”‚â”Œ12
                  â””â”¤
                   â””13</code></pre>
<p>Itâ€™s a binomial heap! Itâ€™s a list of trees, each one contains <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mi>n</mi></msup><annotation encoding="application/x-tex">2^n</annotation></semantics></math> elements. But theyâ€™re not in heap order, you say? Well, as a matter of fact, they <em>are</em>. It just hasnâ€™t been evaluated yet. Once we forceâ€”sayâ€”the first element, the rest will shuffle themselves into a tree of thunks.</p>
<p>This illustrates a pretty interesting similarity between binomial heaps and merge sort. Performance-wise, though, thereâ€™s another interesting property: the thunks <em>stay thunked</em>. In other words, if we do a merge sort via:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1">sort <span class="fu">=</span> foldr (merge <span class="fu">.</span> snd) [] <span class="fu">.</span> foldr (cons merge <span class="fu">.</span> pure) []</a></code></pre></div>
<p>We could instead freeze the fold, and look at it at every point:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1">sortPrefixes <span class="fu">=</span> map (foldr (merge <span class="fu">.</span> snd) []) <span class="fu">.</span> scanl (flip (cons merge <span class="fu">.</span> pure)) []</a>
<a class="sourceLine" id="cb14-2" data-line-number="2"><span class="fu">&gt;&gt;&gt;</span> [[],[<span class="dv">1</span>],[<span class="dv">1</span>,<span class="dv">4</span>],[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">4</span>],[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>],[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>]]</a></code></pre></div>
<p>And <code>sortPrefixes</code> is only <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n^2)</annotation></semantics></math> (rather than <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n^2 \log n)</annotation></semantics></math>). I confess I donâ€™t know of a use for sorted prefixes, but it should illustrate the general idea: we get a pretty decent batching of operations, with the ability to freeze at any point in time. The other nice property (which I mentioned in the last post) is that any of the tree folds are extremely parallel.</p>
<h1 id="random-shuffles">Random Shuffles</h1>
<p><a href="http://okmij.org/ftp/Haskell/AlgorithmsH.html#perfect-shuffle">Thereâ€™s a great article on shuffling in Haskell</a> which provides an <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n \log n)</annotation></semantics></math> implementation of a perfect random shuffle. Unfortunately, the <a href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle">Fisher-Yates shuffle</a> isnâ€™t applicable in a pure functional setting, so you have to be a little cleverer.</p>
<p>The first implementation most people jump to (certainly the one I thought of) is to assign everything in the sequence a random number, and then sort according to that number. Perhaps surprisingly, this <em>isnâ€™t</em> perfectly random! Itâ€™s a little weird, but the example in the article explains it well: basically, for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> elements, your random numbers will have <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>n</mi><mi>n</mi></msup><annotation encoding="application/x-tex">n^n</annotation></semantics></math> possible values, but the output of the sort will have <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>!</mi></mrow><annotation encoding="application/x-tex">n!</annotation></semantics></math> possible values. Since they donâ€™t divide into each other evenly, youâ€™re going to have some extra weight on some permutations, and less on others.</p>
<p>Instead, we can generate a random <a href="https://en.wikipedia.org/wiki/Factorial_number_system"><em>factoradic</em></a> number. A factoradic number is one where the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>th digit is in base <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>. Because of this, a factoradic number with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> digits has <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>!</mi></mrow><annotation encoding="application/x-tex">n!</annotation></semantics></math> possible values: exactly what we want.</p>
<p>In the article, the digits of the number are used to pop values from a binary tree. Because the last digit will have <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> possible values, and the second last <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>âˆ’</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math>, and so on, you can keep popping without hitting an empty tree.</p>
<p>This has the correct time complexityâ€”<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n \log n)</annotation></semantics></math>â€”but thereâ€™s a lot of overhead. Building the tree, then indexing into it, the rebuilding after each pop, etc.</p>
<p>Weâ€™d <em>like</em> to just sort the list, according to the indices. The problem is that the indices are relative: if you want to <code>cons</code> something onto the list, you have to increment the rest of the indices, as theyâ€™ve all shifted right by one.</p>
<p>What weâ€™ll do instead is use the indices as <em>gaps</em>. Our merge function looks like the following:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1">merge [] ys <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">merge xs [] <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">merge ((x,i)<span class="fu">:</span>xs) ((y,j)<span class="fu">:</span>ys)</a>
<a class="sourceLine" id="cb15-4" data-line-number="4">  <span class="fu">|</span> i <span class="fu">&lt;=</span> j    <span class="fu">=</span> (x,i) <span class="fu">:</span> merge xs ((y,j<span class="fu">-</span>i)<span class="fu">:</span>ys)</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">  <span class="fu">|</span> otherwise <span class="fu">=</span> (y,j) <span class="fu">:</span> merge ((x,i<span class="fu">-</span>j<span class="fu">-</span><span class="dv">1</span>)<span class="fu">:</span>xs) ys</a></code></pre></div>
<p>With that, and the same <code>cons</code> as above, we get a very simple random shuffle algorithm:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1">shuffle xs <span class="fu">=</span> map fst</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">           <span class="fu">.</span> foldr (merge <span class="fu">.</span> snd) []</a>
<a class="sourceLine" id="cb16-3" data-line-number="3">           <span class="fu">.</span> foldr f (const []) xs</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-5" data-line-number="5">    f x xs (i<span class="fu">:</span>is) <span class="fu">=</span> cons merge [(x,i)] (xs is)</a></code></pre></div>
<p>The other interesting thing about this algorithm is that it can use Peano numbers with taking too much of a performance hit:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1">merge <span class="fu">:</span> <span class="ot">âˆ€</span> {a} {<span class="dt">A</span> <span class="fu">:</span> <span class="dt">Set</span> a} <span class="ot">â†’</span> <span class="dt">List</span> (<span class="dt">A</span> Ã— â„•) <span class="ot">â†’</span> <span class="dt">List</span> (<span class="dt">A</span> Ã— â„•) <span class="ot">â†’</span> <span class="dt">List</span> (<span class="dt">A</span> Ã— â„•)</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">merge xs [] <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb17-3" data-line-number="3">merge {<span class="dt">A</span> <span class="fu">=</span> <span class="dt">A</span>} xs ((y , j) <span class="ot">âˆ·</span> ys) <span class="fu">=</span> go<span class="fu">-</span>r xs y j ys</a>
<a class="sourceLine" id="cb17-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb17-5" data-line-number="5">  go<span class="fu">-</span>l <span class="fu">:</span> <span class="dt">A</span> <span class="ot">â†’</span> â„• <span class="ot">â†’</span> <span class="dt">List</span> (<span class="dt">A</span> Ã— â„•) <span class="ot">â†’</span> <span class="dt">List</span> (<span class="dt">A</span> Ã— â„•) <span class="ot">â†’</span> <span class="dt">List</span> (<span class="dt">A</span> Ã— â„•)</a>
<a class="sourceLine" id="cb17-6" data-line-number="6">  go<span class="fu">-</span>r <span class="fu">:</span> <span class="dt">List</span> (<span class="dt">A</span> Ã— â„•) <span class="ot">â†’</span> <span class="dt">A</span> <span class="ot">â†’</span> â„• <span class="ot">â†’</span> <span class="dt">List</span> (<span class="dt">A</span> Ã— â„•) <span class="ot">â†’</span> <span class="dt">List</span> (<span class="dt">A</span> Ã— â„•)</a>
<a class="sourceLine" id="cb17-7" data-line-number="7">  go <span class="fu">:</span> â„• <span class="ot">â†’</span> â„• <span class="ot">â†’</span> <span class="dt">A</span> <span class="ot">â†’</span> â„• <span class="ot">â†’</span> <span class="dt">List</span> (<span class="dt">A</span> Ã— â„•) <span class="ot">â†’</span> <span class="dt">A</span> <span class="ot">â†’</span> â„• <span class="ot">â†’</span> <span class="dt">List</span> (<span class="dt">A</span> Ã— â„•) <span class="ot">â†’</span> <span class="dt">List</span> (<span class="dt">A</span> Ã— â„•)</a>
<a class="sourceLine" id="cb17-8" data-line-number="8"></a>
<a class="sourceLine" id="cb17-9" data-line-number="9">  go i     zero   x iâ€² xs y jâ€² ys <span class="fu">=</span> (y , jâ€²) <span class="ot">âˆ·</span> go<span class="fu">-</span>l x i xs ys</a>
<a class="sourceLine" id="cb17-10" data-line-number="10">  go zero (suc j) x iâ€² xs y jâ€² ys <span class="fu">=</span> (x , iâ€²) <span class="ot">âˆ·</span> go<span class="fu">-</span>r xs y j ys</a>
<a class="sourceLine" id="cb17-11" data-line-number="11">  go (suc i) (suc j) <span class="fu">=</span> go i j</a>
<a class="sourceLine" id="cb17-12" data-line-number="12"></a>
<a class="sourceLine" id="cb17-13" data-line-number="13">  go<span class="fu">-</span>l x i xs [] <span class="fu">=</span> (x , i) <span class="ot">âˆ·</span> xs</a>
<a class="sourceLine" id="cb17-14" data-line-number="14">  go<span class="fu">-</span>l x i xs ((y , j) <span class="ot">âˆ·</span> ys) <span class="fu">=</span> go i j x i xs y j ys</a>
<a class="sourceLine" id="cb17-15" data-line-number="15"></a>
<a class="sourceLine" id="cb17-16" data-line-number="16">  go<span class="fu">-</span>r [] y j ys <span class="fu">=</span> (y , j) <span class="ot">âˆ·</span> ys</a>
<a class="sourceLine" id="cb17-17" data-line-number="17">  go<span class="fu">-</span>r ((x , i) <span class="ot">âˆ·</span> xs) y j ys <span class="fu">=</span> go i j x i xs y j ys</a>
<a class="sourceLine" id="cb17-18" data-line-number="18"></a>
<a class="sourceLine" id="cb17-19" data-line-number="19">shuffle <span class="fu">:</span> <span class="ot">âˆ€</span> {a} {<span class="dt">A</span> <span class="fu">:</span> <span class="dt">Set</span> a} <span class="ot">â†’</span> <span class="dt">List</span> <span class="dt">A</span> <span class="ot">â†’</span> <span class="dt">List</span> â„• <span class="ot">â†’</span> <span class="dt">List</span> <span class="dt">A</span></a>
<a class="sourceLine" id="cb17-20" data-line-number="20">shuffle {a} {<span class="dt">A</span>} xs i <span class="fu">=</span> map projâ‚ (â¦… [] , zip<span class="fu">-</span>inds xs i â¦†)</a>
<a class="sourceLine" id="cb17-21" data-line-number="21">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb17-22" data-line-number="22">  open <span class="dt">TreeFold</span> {a} {<span class="dt">List</span> (<span class="dt">A</span> Ã— â„•)} merge</a>
<a class="sourceLine" id="cb17-23" data-line-number="23"></a>
<a class="sourceLine" id="cb17-24" data-line-number="24">  zip<span class="fu">-</span>inds <span class="fu">:</span> <span class="dt">List</span> <span class="dt">A</span> <span class="ot">â†’</span> <span class="dt">List</span> â„• <span class="ot">â†’</span> <span class="dt">List</span> (<span class="dt">List</span> (<span class="dt">A</span> Ã— â„•))</a>
<a class="sourceLine" id="cb17-25" data-line-number="25">  zip<span class="fu">-</span>inds [] inds <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb17-26" data-line-number="26">  zip<span class="fu">-</span>inds (x <span class="ot">âˆ·</span> xs) [] <span class="fu">=</span> ((x , <span class="dv">0</span>) <span class="ot">âˆ·</span> []) <span class="ot">âˆ·</span> zip<span class="fu">-</span>inds xs []</a>
<a class="sourceLine" id="cb17-27" data-line-number="27">  zip<span class="fu">-</span>inds (x <span class="ot">âˆ·</span> xs) (i <span class="ot">âˆ·</span> inds) <span class="fu">=</span> ((x , i) <span class="ot">âˆ·</span> []) <span class="ot">âˆ·</span> zip<span class="fu">-</span>inds xs inds</a></code></pre></div>
<p>I donâ€™t know exactly what the complexity of this is, but I <em>think</em> it should be better than the usual approach of popping from a vector.</p>
<h1 id="future-stuff">Future Stuff</h1>
<p>This is just a collection of random thoughts for now, but I intend to work on using these folds to see if there are any other algorithms they can be useful for. In particular, I think I can write a version of Data.List.permutations which benefits from sharing. And Iâ€™m interested in using the implicit binomial heap for some search problems.</p>
]]></description>
    <pubDate>Fri, 21 Dec 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-12-21-balancing-scans.html</guid>
    <dc:creator>Donnacha OisÃ­n Kidney</dc:creator>
</item>
<item>
    <title>Pure and Lazy Breadth-First Traversals of Graphs in Haskell</title>
    <link>https://doisinkidney.com/posts/2018-12-18-traversing-graphs.html</link>
    <description><![CDATA[<div class="info">
    Posted on December 18, 2018
</div>
<div class="info">
    
        Part 5 of a <a href="/series/Breadth-First%20Traversals.html">5-part series on Breadth-First Traversals</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<p>Today, Iâ€™m going to look at extending the previous breadth-first traversal algorithms to arbitrary graphs (rather than just trees). Graphs with cycles are notoriously cumbersome in functional languages, so this actually proves to be a little trickier than I thought it would be. First, a quick recap.</p>
<h1 id="ways-to-breadth-first-search">3 Ways to Breadth-First Search</h1>
<p>So far, we have three major ways to traverse a tree in breadth-first order. The first is the simplest, and the fastest:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">bfe ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">bfe r <span class="fu">=</span> f r b []</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">    f (<span class="dt">Node</span> x xs) fw bw <span class="fu">=</span> x <span class="fu">:</span> fw (xs <span class="fu">:</span> bw)</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">  </a>
<a class="sourceLine" id="cb1-6" data-line-number="6">    b [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb1-7" data-line-number="7">    b qs <span class="fu">=</span> foldl (foldr f) b qs []</a></code></pre></div>
<p>Given a tree like the following:</p>
<pre><code>   â”Œ4
 â”Œ2â”¤
 â”‚ â”‚ â”Œ8
 â”‚ â””5â”¤
 â”‚   â””9
1â”¤
 â”‚   â”Œ10
 â”‚ â”Œ6â”˜
 â””3â”¤
   â””7</code></pre>
<p>We get:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> bfe tree</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>]</a></code></pre></div>
<p>It also demonstrates a theme that will run through this post: lists are the only <em>visible</em> data structure (other than the tree, of course). However, we are carefully batching the operations on those lists (the <code>foldl</code> is effectively a reverse) so that they have the same complexity as if we had used a queue. In actual fact, when lists are used this way, they <em>are</em> queues: â€œcorecursiveâ€ ones <span class="citation" data-cites="allison_circular_2006 smith_lloyd_2009">(Allison <a href="#ref-allison_circular_2006">2006</a>; Smith <a href="#ref-smith_lloyd_2009">2009</a>)</span>.</p>
<p>The next two functions perform a breadth-first traversal â€œlevel-wiseâ€: instead of just returning all the nodes of the tree, we get them delimited by how far they are from the root.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">lwe ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">lwe r <span class="fu">=</span> f b r [] []</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">    f k (<span class="dt">Node</span> x xs) ls qs <span class="fu">=</span> k (x <span class="fu">:</span> ls) (xs <span class="fu">:</span> qs)</a>
<a class="sourceLine" id="cb4-5" data-line-number="5"></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">    b _ [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb4-7" data-line-number="7">    b k qs <span class="fu">=</span> k <span class="fu">:</span> foldl (foldl f) b qs [] []</a>
<a class="sourceLine" id="cb4-8" data-line-number="8"></a>
<a class="sourceLine" id="cb4-9" data-line-number="9"><span class="fu">&gt;&gt;&gt;</span> lwe tree</a>
<a class="sourceLine" id="cb4-10" data-line-number="10">[[<span class="dv">1</span>],[<span class="dv">2</span>,<span class="dv">3</span>],[<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>],[<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>]]</a></code></pre></div>
<p>The above function is very clearly related to the <code>bfe</code> function: we just add another queue (representing the current level), and work from there.</p>
<p>The third of these functions also does level-wise enumeration, but in a direct style (without continuations).</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">lwe ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">lwe r <span class="fu">=</span> f r []</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">    f (<span class="dt">Node</span> x xs) (q<span class="fu">:</span>qs) <span class="fu">=</span> (x<span class="fu">:</span>q) <span class="fu">:</span> foldr f qs xs</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">    f (<span class="dt">Node</span> x xs) []     <span class="fu">=</span> [x]   <span class="fu">:</span> foldr f [] xs</a></code></pre></div>
<p>There are more techniques out there than just these three (including the one in <a href="http://hackage.haskell.org/package/containers-0.6.0.1/docs/Data-Tree.html#v:levels">Data.Tree</a>), but these are my favorite, and theyâ€™re what Iâ€™ll be looking at today.</p>
<h1 id="graphs-and-purity">Graphs and Purity</h1>
<p>Functional programming in general excels at working with trees and similar data structures. Graphs, though, are trickier. Thereâ€™s been a lot of recent work in improving the situation <span class="citation" data-cites="mokhov_algebraic_2017">(Mokhov <a href="#ref-mokhov_algebraic_2017">2017</a>)</span>, but Iâ€™m going to keep it simple today: a graph is just a function.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Graph</span> a <span class="fu">=</span> a <span class="ot">-&gt;</span> [a]</a></code></pre></div>
<p>So the tree from above could be represented as:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1">graph <span class="dv">1</span> <span class="fu">=</span> [<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">graph <span class="dv">2</span> <span class="fu">=</span> [<span class="dv">4</span>,<span class="dv">5</span>]</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">graph <span class="dv">3</span> <span class="fu">=</span> [<span class="dv">6</span>,<span class="dv">7</span>]</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">graph <span class="dv">5</span> <span class="fu">=</span> [<span class="dv">8</span>,<span class="dv">9</span>]</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">graph <span class="dv">6</span> <span class="fu">=</span> [<span class="dv">10</span>]</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">graph _ <span class="fu">=</span> []</a></code></pre></div>
<p>As it happens, all of the algorithms that follow will work on graphs represented as rose trees (or represented any way, really).</p>
<p>So letâ€™s fire up our first traversal!</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">bfs ::</span> <span class="dt">Graph</span> a <span class="ot">-&gt;</span> <span class="dt">Graph</span> a</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">bfs g r <span class="fu">=</span> f r b []</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">    f x fw bw <span class="fu">=</span> x <span class="fu">:</span> fw (g x <span class="fu">:</span> bw)</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">  </a>
<a class="sourceLine" id="cb8-6" data-line-number="6">    b [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">    b qs <span class="fu">=</span> foldl (foldr f) b qs []</a>
<a class="sourceLine" id="cb8-8" data-line-number="8">    </a>
<a class="sourceLine" id="cb8-9" data-line-number="9"><span class="fu">&gt;&gt;&gt;</span> bfs graph <span class="dv">1</span></a>
<a class="sourceLine" id="cb8-10" data-line-number="10">[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>]</a></code></pre></div>
<p>Unfortunately, this wonâ€™t handle cycles properly:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1">graph <span class="dv">1</span> <span class="fu">=</span> [<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">graph <span class="dv">2</span> <span class="fu">=</span> [<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">graph <span class="dv">3</span> <span class="fu">=</span> [<span class="dv">6</span>,<span class="dv">7</span>]</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">graph <span class="dv">5</span> <span class="fu">=</span> [<span class="dv">8</span>,<span class="dv">9</span>]</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">graph <span class="dv">6</span> <span class="fu">=</span> [<span class="dv">10</span>]</a>
<a class="sourceLine" id="cb9-6" data-line-number="6">graph _ <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb9-7" data-line-number="7"></a>
<a class="sourceLine" id="cb9-8" data-line-number="8"><span class="fu">&gt;&gt;&gt;</span> bfs graph <span class="dv">1</span></a>
<a class="sourceLine" id="cb9-9" data-line-number="9">[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">1</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">10</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">1</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">10</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">1</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">10</span>,<span class="dv">4</span>,<span class="dv">5</span><span class="fu">...</span></a></code></pre></div>
<p>We need a way to mark off what weâ€™ve already seen. The following isnâ€™t good enough, also:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> nub (bfs graph <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span><span class="fu">...</span></a></code></pre></div>
<p>It will hang without finishing the list. The solution is to mark off nodes as we find them, with some set structure:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">bfs ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Graph</span> a <span class="ot">-&gt;</span> <span class="dt">Graph</span> a</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">bfs g ts <span class="fu">=</span> f ts b [] Set.empty</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4">    f x fw bw s</a>
<a class="sourceLine" id="cb11-5" data-line-number="5">      <span class="fu">|</span> Set.member x s <span class="fu">=</span> fw bw s</a>
<a class="sourceLine" id="cb11-6" data-line-number="6">      <span class="fu">|</span> otherwise      <span class="fu">=</span> x <span class="fu">:</span> fw (g x <span class="fu">:</span> bw) (Set.insert x s)</a>
<a class="sourceLine" id="cb11-7" data-line-number="7"></a>
<a class="sourceLine" id="cb11-8" data-line-number="8">    b [] _ <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb11-9" data-line-number="9">    b qs s <span class="fu">=</span> foldl (foldr f) b qs [] s</a>
<a class="sourceLine" id="cb11-10" data-line-number="10"></a>
<a class="sourceLine" id="cb11-11" data-line-number="11"><span class="fu">&gt;&gt;&gt;</span> bfs graph <span class="dv">1</span></a>
<a class="sourceLine" id="cb11-12" data-line-number="12">[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>]</a></code></pre></div>
<p>The levelwise algorithm is similar:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="ot">lws ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Graph</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [[a]] </a>
<a class="sourceLine" id="cb12-2" data-line-number="2">lws g r <span class="fu">=</span> f b r [] [] Set.empty</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">    f k x ls qs s</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">      <span class="fu">|</span> Set.member x s <span class="fu">=</span> k ls qs s</a>
<a class="sourceLine" id="cb12-6" data-line-number="6">      <span class="fu">|</span> otherwise <span class="fu">=</span> k (x <span class="fu">:</span> ls) (g x <span class="fu">:</span> qs) (Set.insert x s)</a>
<a class="sourceLine" id="cb12-7" data-line-number="7"></a>
<a class="sourceLine" id="cb12-8" data-line-number="8">    b _ [] _ <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb12-9" data-line-number="9">    b k qs s <span class="fu">=</span> k <span class="fu">:</span> foldl (foldl f) b qs [] [] s</a></code></pre></div>
<h1 id="tying-the-knot">Tying the Knot</h1>
<p>The other levelwise algorithm <em>doesnâ€™t</em> translate across so easily. To see why, letâ€™s look at the version without cycle detection:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="ot">lws ::</span> <span class="dt">Graph</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">lws g r <span class="fu">=</span> f r []</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4">    f x (q<span class="fu">:</span>qs) <span class="fu">=</span> (x<span class="fu">:</span>q) <span class="fu">:</span> foldr f qs (g x)</a>
<a class="sourceLine" id="cb13-5" data-line-number="5">    f x []     <span class="fu">=</span> [x]   <span class="fu">:</span> foldr f [] (g x)</a></code></pre></div>
<p>The recursive call is being made <em>depth</em>-first, not breadth-first. The result, of course, is breadth-first, but thatâ€™s only because the recursive call zips as it goes.</p>
<p>Just looking at the fourth line for now:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1">f x (q<span class="fu">:</span>qs) <span class="fu">=</span> (x<span class="fu">:</span>q) <span class="fu">:</span> foldr f qs (g x)</a></code></pre></div>
<p>We want whatever process built up that <code>q</code> to be denied access to <code>x</code>. The following doesnâ€™t work:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1">f x (q<span class="fu">:</span>qs) <span class="fu">=</span> (x<span class="fu">:</span>filter (x<span class="fu">/=</span>) q) <span class="fu">:</span> foldr f qs (g x)</a></code></pre></div>
<p>As well as being terribly slow, the later computation can diverge when it finds a cycle, and filtering wonâ€™t do anything to help that.</p>
<p>The solution is to â€œtie the knotâ€. We basically do two passes over the data: one to build up the â€œseen so farâ€ list, and then another to do the actual search. The trick is to do both of these passes at once, and feed the result back into the demanding computation.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1">lws g r <span class="fu">=</span> takeWhile (not<span class="fu">.</span>null) (map fst (fix (f r <span class="fu">.</span> push)))</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3">    push xs <span class="fu">=</span> ([],Set.empty) <span class="fu">:</span> [ ([],seen) <span class="fu">|</span> (_,seen) <span class="ot">&lt;-</span> xs ]</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">    f x q<span class="fu">@</span>((l,s)<span class="fu">:</span>qs)</a>
<a class="sourceLine" id="cb16-5" data-line-number="5">      <span class="fu">|</span> Set.member x s <span class="fu">=</span> q</a>
<a class="sourceLine" id="cb16-6" data-line-number="6">      <span class="fu">|</span> otherwise <span class="fu">=</span> (x<span class="fu">:</span>l, Set.insert x s) <span class="fu">:</span> foldr f qs (g x)</a></code></pre></div>
<p>And it works!</p>
<p>I got the idea for this trick from the appendix of <span class="citation" data-cites="okasaki_breadth-first_2000">Okasaki (<a href="#ref-okasaki_breadth-first_2000">2000</a>)</span>. Thereâ€™s something similar in <span class="citation" data-cites="kiselyov_pure-functional_2002">Kiselyov (<a href="#ref-kiselyov_pure-functional_2002">2002</a>)</span>.</p>
<hr />
<h1 id="references" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-allison_circular_2006">
<p>Allison, Lloyd. 2006. â€œCircular Programs and Self-Referential Structures.â€ <em>Software: Practice and Experience</em> 19 (2) (October): 99â€“109. doi:<a href="https://doi.org/10.1002/spe.4380190202">10.1002/spe.4380190202</a>. <a href="http://users.monash.edu/~lloyd/tildeFP/1989SPE/" class="uri">http://users.monash.edu/~lloyd/tildeFP/1989SPE/</a>.</p>
</div>
<div id="ref-kiselyov_pure-functional_2002">
<p>Kiselyov, Oleg. 2002. â€œPure-functional transformations of cyclic graphs and the Credit Card Transform.â€ <a href="http://okmij.org/ftp/Haskell/AlgorithmsH.html\#ccard-transform" class="uri">http://okmij.org/ftp/Haskell/AlgorithmsH.html\#ccard-transform</a>.</p>
</div>
<div id="ref-mokhov_algebraic_2017">
<p>Mokhov, Andrey. 2017. â€œAlgebraic Graphs with Class (Functional Pearl).â€ In <em>Proceedings of the 10th ACM SIGPLAN International Symposium on Haskell</em>, 2â€“13. Haskell 2017. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/3122955.3122956">10.1145/3122955.3122956</a>. <a href="http://doi.acm.org/10.1145/3122955.3122956" class="uri">http://doi.acm.org/10.1145/3122955.3122956</a>.</p>
</div>
<div id="ref-okasaki_breadth-first_2000">
<p>Okasaki, Chris. 2000. â€œBreadth-first Numbering: Lessons from a Small Exercise in Algorithm Design.â€ In <em>Proceedings of the Fifth ACM SIGPLAN International Conference on Functional Programming</em>, 131â€“136. ICFP â€™00. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/351240.351253">10.1145/351240.351253</a>. <a href="https://www.cs.tufts.edu/~nr/cs257/archive/chris-okasaki/breadth-first.pdf" class="uri">https://www.cs.tufts.edu/~nr/cs257/archive/chris-okasaki/breadth-first.pdf</a>.</p>
</div>
<div id="ref-smith_lloyd_2009">
<p>Smith, Leon P. 2009. â€œLloyd Allisonâ€™s Corecursive Queues: Why Continuations Matter.â€ <em>The Monad.Reader</em> 14 (14) (July): 28. <a href="https://meldingmonads.files.wordpress.com/2009/06/corecqueues.pdf" class="uri">https://meldingmonads.files.wordpress.com/2009/06/corecqueues.pdf</a>.</p>
</div>
</div>
]]></description>
    <pubDate>Tue, 18 Dec 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-12-18-traversing-graphs.html</guid>
    <dc:creator>Donnacha OisÃ­n Kidney</dc:creator>
</item>
<item>
    <title>Prime Sieves in Agda</title>
    <link>https://doisinkidney.com/posts/2018-12-14-primes-in-agda.html</link>
    <description><![CDATA[<div class="info">
    Posted on December 14, 2018
</div>
<div class="info">
    
        Part 2 of a <a href="/series/Prime%20Sieves.html">2-part series on Prime Sieves</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Agda.html">Agda</a>
    
</div>

<p>Prime numbers in Agda are <em>slow</em>. First, theyâ€™re Peano-based, so a huge chunk of optimizations we might make in other languages are out of the window. Second, we really often want to <em>prove</em> that theyâ€™re prime, so the generation code has to carry verification logic with it (I wonâ€™t do that today, though). And third, as always in Agda, you have to convince the compiler of termination. With all of that in mind, letâ€™s try and write a (very slow, very basic) prime sieve in Agda.</p>
<p>First, we can make an â€œarrayâ€ of numbers that we cross off as we go.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb1-1" data-line-number="1">primes <span class="ot">:</span> <span class="ot">âˆ€</span> n <span class="ot">â†’</span> List <span class="ot">(</span>Fin n<span class="ot">)</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">primes zero <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">primes <span class="ot">(</span>suc zero<span class="ot">)</span> <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">primes <span class="ot">(</span>suc <span class="ot">(</span>suc zero<span class="ot">))</span> <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">primes <span class="ot">(</span>suc <span class="ot">(</span>suc <span class="ot">(</span>suc m<span class="ot">)))</span> <span class="ot">=</span> sieve <span class="ot">(</span>tabulate <span class="ot">(</span>just âˆ˜ Fin<span class="ot">.</span>suc<span class="ot">))</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">  cross-off <span class="ot">:</span> Fin <span class="ot">_</span> <span class="ot">â†’</span> List <span class="ot">(</span>Maybe <span class="ot">(</span>Fin <span class="ot">_))</span> <span class="ot">â†’</span> List <span class="ot">(</span>Maybe <span class="ot">(</span>Fin <span class="ot">_))</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"></a>
<a class="sourceLine" id="cb1-9" data-line-number="9">  sieve <span class="ot">:</span> List <span class="ot">(</span>Maybe <span class="ot">(</span>Fin <span class="ot">_))</span> <span class="ot">â†’</span> List <span class="ot">(</span>Fin <span class="ot">_)</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10">  sieve [] <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb1-11" data-line-number="11">  sieve <span class="ot">(</span>nothing âˆ· xs<span class="ot">)</span> <span class="ot">=</span>         sieve xs</a>
<a class="sourceLine" id="cb1-12" data-line-number="12">  sieve <span class="ot">(</span>just x  âˆ· xs<span class="ot">)</span> <span class="ot">=</span> suc x âˆ· sieve <span class="ot">(</span>cross-off x xs<span class="ot">)</span></a>
<a class="sourceLine" id="cb1-13" data-line-number="13"></a>
<a class="sourceLine" id="cb1-14" data-line-number="14">  cross-off p fs <span class="ot">=</span> foldr f <span class="ot">(</span>const []<span class="ot">)</span> fs p</a>
<a class="sourceLine" id="cb1-15" data-line-number="15">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-16" data-line-number="16">    B <span class="ot">=</span> <span class="ot">âˆ€</span> <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">â†’</span> Fin i <span class="ot">â†’</span> List <span class="ot">(</span>Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">2</span> + m<span class="ot">)))</span></a>
<a class="sourceLine" id="cb1-17" data-line-number="17"></a>
<a class="sourceLine" id="cb1-18" data-line-number="18">    f <span class="ot">:</span> Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">2</span> + m<span class="ot">))</span> <span class="ot">â†’</span> B <span class="ot">â†’</span> B</a>
<a class="sourceLine" id="cb1-19" data-line-number="19">    f <span class="ot">_</span> xs zero    <span class="ot">=</span> nothing âˆ· xs p</a>
<a class="sourceLine" id="cb1-20" data-line-number="20">    f x xs <span class="ot">(</span>suc y<span class="ot">)</span> <span class="ot">=</span> x       âˆ· xs y</a></code></pre></div>
<p>Very simple so far: we run through the list, filtering out the multiples of each prime as we see it. Unfortunately, this wonâ€™t pass the termination checker. This recursive call to <code>sieve</code> is the problem:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb2-1" data-line-number="1">sieve <span class="ot">(</span>just x âˆ· xs<span class="ot">)</span> <span class="ot">=</span> suc x âˆ· sieve <span class="ot">(</span>cross-off x xs<span class="ot">)</span></a></code></pre></div>
<p>Agda finds if a function is terminating by checking that at least one argument gets (structurally) smaller on every recursive call. <code>sieve</code> only takes one argument (the input list), so thatâ€™s the one that needs to get smaller. In the line above, if we replaced it with the following:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb3-1" data-line-number="1">sieve <span class="ot">(</span>just x âˆ· xs<span class="ot">)</span> <span class="ot">=</span> suc x âˆ· sieve xs</a></code></pre></div>
<p>Weâ€™d be good to go: <code>xs</code> is definitely smaller than <code>(just x âˆ· xs)</code>. <code>cross-off x xs</code>, though? The thing is, <code>cross-off</code> returns a list of the same length that itâ€™s given. But the function call is opaque: Agda canâ€™t automatically see the fact that the length stays the same. Reaching for a proof here is the wrong move, though: you can get all of the same benefit by switching out the list for a length-indexed vector.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb4-1" data-line-number="1">primes <span class="ot">:</span> <span class="ot">âˆ€</span> n <span class="ot">â†’</span> List <span class="ot">(</span>Fin n<span class="ot">)</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">primes zero <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">primes <span class="ot">(</span>suc zero<span class="ot">)</span> <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">primes <span class="ot">(</span>suc <span class="ot">(</span>suc zero<span class="ot">))</span> <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">primes <span class="ot">(</span>suc <span class="ot">(</span>suc <span class="ot">(</span>suc m<span class="ot">)))</span> <span class="ot">=</span> sieve <span class="ot">(</span>tabulate <span class="ot">(</span>just âˆ˜ Fin<span class="ot">.</span>suc<span class="ot">))</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7">  cross-off <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">â†’</span> Fin <span class="ot">_</span> <span class="ot">â†’</span> Vec <span class="ot">(</span>Maybe <span class="ot">_)</span> n <span class="ot">â†’</span> Vec <span class="ot">(</span>Maybe <span class="ot">_)</span> n</a>
<a class="sourceLine" id="cb4-8" data-line-number="8"></a>
<a class="sourceLine" id="cb4-9" data-line-number="9">  sieve <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">â†’</span>  Vec <span class="ot">(</span>Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">2</span> + m<span class="ot">)))</span> n <span class="ot">â†’</span> List <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">3</span> + m<span class="ot">))</span></a>
<a class="sourceLine" id="cb4-10" data-line-number="10">  sieve [] <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb4-11" data-line-number="11">  sieve <span class="ot">(</span>nothing âˆ· xs<span class="ot">)</span> <span class="ot">=</span>         sieve xs</a>
<a class="sourceLine" id="cb4-12" data-line-number="12">  sieve <span class="ot">(</span>just x  âˆ· xs<span class="ot">)</span> <span class="ot">=</span> suc x âˆ· sieve <span class="ot">(</span>cross-off x xs<span class="ot">)</span></a>
<a class="sourceLine" id="cb4-13" data-line-number="13"></a>
<a class="sourceLine" id="cb4-14" data-line-number="14">  cross-off p fs <span class="ot">=</span> foldr B f <span class="ot">(</span>const []<span class="ot">)</span> fs p</a>
<a class="sourceLine" id="cb4-15" data-line-number="15">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-16" data-line-number="16">    B <span class="ot">=</span> <span class="ot">Î»</span> n <span class="ot">â†’</span> <span class="ot">âˆ€</span> <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">â†’</span> Fin i <span class="ot">â†’</span> Vec <span class="ot">(</span>Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">2</span> + m<span class="ot">)))</span> n</a>
<a class="sourceLine" id="cb4-17" data-line-number="17"></a>
<a class="sourceLine" id="cb4-18" data-line-number="18">    f <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">â†’</span> Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">2</span> + m<span class="ot">))</span> <span class="ot">â†’</span> B n <span class="ot">â†’</span> B <span class="ot">(</span>suc n<span class="ot">)</span></a>
<a class="sourceLine" id="cb4-19" data-line-number="19">    f <span class="ot">_</span> xs zero    <span class="ot">=</span> nothing âˆ· xs p</a>
<a class="sourceLine" id="cb4-20" data-line-number="20">    f x xs <span class="ot">(</span>suc y<span class="ot">)</span> <span class="ot">=</span> x       âˆ· xs y</a></code></pre></div>
<p>Actually, my explanation above is a little bit of a lie. Often, the way I think about dependently-typed programs has a lot to do with my intuition for â€œproofsâ€ and so on. But this leads you down the wrong path (and itâ€™s why writing a proof that <code>cross-off</code> returns a list of the same length is the wrong move).</p>
<p>The actual termination checking algorithm is very simple, albeit strict: the argument passed recursively must be <em>structurally</em> smaller. Thatâ€™s it. Basically, the recursive argument has to be contained in one of the arguments passed. It has nothing to do with Agda â€œseeingâ€ inside the function <code>cross-off</code> or anything like that. What weâ€™ve done above (to make it terminate) is add another argument to the function: the length of the vector. The argument is implicit, but if we were to make it explicit in the recursive call:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb5-1" data-line-number="1">sieve <span class="ot">{</span>suc n<span class="ot">}</span> <span class="ot">(</span>just x  âˆ· xs<span class="ot">)</span> <span class="ot">=</span> suc x âˆ· sieve <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">(</span>cross-off x xs<span class="ot">)</span></a></code></pre></div>
<p>We can see that it does indeed get structurally smaller.</p>
<h1 id="adding-the-squaring-optimization">Adding the Squaring Optimization</h1>
<p>A simple improvement we should be able to make is stopping once we hit the square root of the limit. Since we donâ€™t want to be squaring as we go, weâ€™ll use the following identity:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><msup><mo stretchy="false" form="postfix">)</mo><mn>2</mn></msup><mo>=</mo><msup><mi>n</mi><mn>2</mn></msup><mo>+</mo><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">(n + 1)^2 = n^2 + 2n + 1</annotation></semantics></math></p>
<p>to figure out the square of the next number from the previous. In fact, weâ€™ll just pass in the limit, and reduce it by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2n + 1</annotation></semantics></math> each time, until it reaches zero:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb6-1" data-line-number="1">primes <span class="ot">:</span> <span class="ot">âˆ€</span> n <span class="ot">â†’</span> List <span class="ot">(</span>Fin n<span class="ot">)</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">primes zero <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">primes <span class="ot">(</span>suc zero<span class="ot">)</span> <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">primes <span class="ot">(</span>suc <span class="ot">(</span>suc zero<span class="ot">))</span> <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">primes <span class="ot">(</span>suc <span class="ot">(</span>suc <span class="ot">(</span>suc m<span class="ot">)))</span> <span class="ot">=</span> sieve <span class="dv">1</span> m <span class="ot">(</span>Vec<span class="ot">.</span>tabulate <span class="ot">(</span>just âˆ˜ Fin<span class="ot">.</span>suc âˆ˜ Fin<span class="ot">.</span>suc<span class="ot">))</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-7" data-line-number="7">  cross-off <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">â†’</span> â„• <span class="ot">â†’</span> Vec <span class="ot">(</span>Maybe <span class="ot">_)</span> n <span class="ot">â†’</span> Vec <span class="ot">(</span>Maybe <span class="ot">_)</span> n</a>
<a class="sourceLine" id="cb6-8" data-line-number="8"></a>
<a class="sourceLine" id="cb6-9" data-line-number="9">  sieve <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">â†’</span> â„• <span class="ot">â†’</span> â„• <span class="ot">â†’</span> Vec <span class="ot">(</span>Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">3</span> + m<span class="ot">)))</span> n <span class="ot">â†’</span> List <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">3</span> + m<span class="ot">))</span></a>
<a class="sourceLine" id="cb6-10" data-line-number="10">  sieve <span class="ot">_</span> zero <span class="ot">=</span> List<span class="ot">.</span>mapMaybe id âˆ˜ Vec<span class="ot">.</span>toList</a>
<a class="sourceLine" id="cb6-11" data-line-number="11">  sieve <span class="ot">_</span> <span class="ot">(</span>suc <span class="ot">_)</span> [] <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb6-12" data-line-number="12">  sieve i <span class="ot">(</span>suc l<span class="ot">)</span> <span class="ot">(</span>nothing âˆ· xs<span class="ot">)</span> <span class="ot">=</span>     sieve <span class="ot">(</span>suc i<span class="ot">)</span> <span class="ot">(</span>l âˆ¸ i âˆ¸ i<span class="ot">)</span> xs</a>
<a class="sourceLine" id="cb6-13" data-line-number="13">  sieve i <span class="ot">(</span>suc l<span class="ot">)</span> <span class="ot">(</span>just x  âˆ· xs<span class="ot">)</span> <span class="ot">=</span> x âˆ· sieve <span class="ot">(</span>suc i<span class="ot">)</span> <span class="ot">(</span>l âˆ¸ i âˆ¸ i<span class="ot">)</span> <span class="ot">(</span>cross-off i xs<span class="ot">)</span></a>
<a class="sourceLine" id="cb6-14" data-line-number="14"></a>
<a class="sourceLine" id="cb6-15" data-line-number="15">  cross-off p fs <span class="ot">=</span> Vec<span class="ot">.</span>foldr B f <span class="ot">(</span>const []<span class="ot">)</span> fs p</a>
<a class="sourceLine" id="cb6-16" data-line-number="16">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-17" data-line-number="17">      B <span class="ot">=</span> <span class="ot">Î»</span> n <span class="ot">â†’</span> â„• <span class="ot">â†’</span> Vec <span class="ot">(</span>Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">3</span> + m<span class="ot">)))</span> n</a>
<a class="sourceLine" id="cb6-18" data-line-number="18"></a>
<a class="sourceLine" id="cb6-19" data-line-number="19">      f <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">â†’</span> Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">3</span> + m<span class="ot">))</span> <span class="ot">â†’</span> B i <span class="ot">â†’</span> B <span class="ot">(</span>suc i<span class="ot">)</span></a>
<a class="sourceLine" id="cb6-20" data-line-number="20">      f <span class="ot">_</span> xs zero    <span class="ot">=</span> nothing âˆ· xs p</a>
<a class="sourceLine" id="cb6-21" data-line-number="21">      f x xs <span class="ot">(</span>suc y<span class="ot">)</span> <span class="ot">=</span> x       âˆ· xs y</a></code></pre></div>
<h1 id="finding-prime-factors">Finding Prime Factors</h1>
<p>A slight variation on the code above (the first version) will give us the prime factors of a number:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb7-1" data-line-number="1">primeFactors <span class="ot">:</span> <span class="ot">âˆ€</span> n <span class="ot">â†’</span> List <span class="ot">(</span>Fin n<span class="ot">)</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">primeFactors zero <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">primeFactors <span class="ot">(</span>suc zero<span class="ot">)</span> <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">primeFactors <span class="ot">(</span>suc <span class="ot">(</span>suc zero<span class="ot">))</span> <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">primeFactors <span class="ot">(</span>suc <span class="ot">(</span>suc <span class="ot">(</span>suc m<span class="ot">)))</span> <span class="ot">=</span> sieve <span class="ot">(</span>Vec<span class="ot">.</span>tabulate <span class="ot">(</span>just âˆ˜ Fin<span class="ot">.</span>suc<span class="ot">))</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-7" data-line-number="7">  sieve <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">â†’</span> Vec <span class="ot">(</span>Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">2</span> + m<span class="ot">)))</span> n <span class="ot">â†’</span> List <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">3</span> + m<span class="ot">))</span></a>
<a class="sourceLine" id="cb7-8" data-line-number="8">  sieve [] <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb7-9" data-line-number="9">  sieve <span class="ot">(</span>nothing âˆ· xs<span class="ot">)</span> <span class="ot">=</span> sieve xs</a>
<a class="sourceLine" id="cb7-10" data-line-number="10">  sieve <span class="ot">(</span>just x  âˆ· xs<span class="ot">)</span> <span class="ot">=</span> Vec<span class="ot">.</span>foldr B remove b xs sieve x</a>
<a class="sourceLine" id="cb7-11" data-line-number="11">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-12" data-line-number="12">    B <span class="ot">=</span> <span class="ot">Î»</span> n <span class="ot">â†’</span> <span class="ot">âˆ€</span> <span class="ot">{</span>i<span class="ot">}</span></a>
<a class="sourceLine" id="cb7-13" data-line-number="13">            <span class="ot">â†’</span> <span class="ot">(</span>Vec <span class="ot">(</span>Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">2</span> + m<span class="ot">)))</span> n</a>
<a class="sourceLine" id="cb7-14" data-line-number="14">            <span class="ot">â†’</span> List <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">3</span> + m<span class="ot">)))</span></a>
<a class="sourceLine" id="cb7-15" data-line-number="15">            <span class="ot">â†’</span> Fin i</a>
<a class="sourceLine" id="cb7-16" data-line-number="16">            <span class="ot">â†’</span> List <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">3</span> + m<span class="ot">))</span></a>
<a class="sourceLine" id="cb7-17" data-line-number="17"></a>
<a class="sourceLine" id="cb7-18" data-line-number="18">    b <span class="ot">:</span> B <span class="dv">0</span></a>
<a class="sourceLine" id="cb7-19" data-line-number="19">    b k zero    <span class="ot">=</span> suc x âˆ· k []</a>
<a class="sourceLine" id="cb7-20" data-line-number="20">    b k <span class="ot">(</span>suc <span class="ot">_)</span> <span class="ot">=</span>         k []</a>
<a class="sourceLine" id="cb7-21" data-line-number="21"></a>
<a class="sourceLine" id="cb7-22" data-line-number="22">    remove <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">â†’</span> Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">2</span> + m<span class="ot">))</span> <span class="ot">â†’</span> B n <span class="ot">â†’</span> B <span class="ot">(</span>suc n<span class="ot">)</span></a>
<a class="sourceLine" id="cb7-23" data-line-number="23">    remove y ys k zero    <span class="ot">=</span> ys <span class="ot">(</span>k âˆ˜ <span class="ot">(</span>nothing âˆ·<span class="ot">_))</span> x</a>
<a class="sourceLine" id="cb7-24" data-line-number="24">    remove y ys k <span class="ot">(</span>suc j<span class="ot">)</span> <span class="ot">=</span> ys <span class="ot">(</span>k âˆ˜ <span class="ot">(</span>y âˆ·<span class="ot">_))</span> j</a></code></pre></div>
<p>Adding the squaring optimization complicates things significantly:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb8-1" data-line-number="1">primeFactors <span class="ot">:</span> <span class="ot">âˆ€</span> n <span class="ot">â†’</span> List <span class="ot">(</span>Fin n<span class="ot">)</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">primeFactors zero <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">primeFactors <span class="ot">(</span>suc zero<span class="ot">)</span> <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">primeFactors <span class="ot">(</span>suc <span class="ot">(</span>suc zero<span class="ot">))</span> <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">primeFactors <span class="ot">(</span>suc <span class="ot">(</span>suc <span class="ot">(</span>suc m<span class="ot">)))</span> <span class="ot">=</span> sqr <span class="ot">(</span>suc m<span class="ot">)</span> m suc sieve</a>
<a class="sourceLine" id="cb8-6" data-line-number="6">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-7" data-line-number="7">  <span class="ot">_</span>2F-<span class="ot">_</span> <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">â†’</span> â„• <span class="ot">â†’</span> Fin n <span class="ot">â†’</span> â„•</a>
<a class="sourceLine" id="cb8-8" data-line-number="8">  x           2F- zero <span class="ot">=</span> x</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">  zero        2F- suc y <span class="ot">=</span> zero</a>
<a class="sourceLine" id="cb8-10" data-line-number="10">  suc zero    2F- suc y <span class="ot">=</span> zero</a>
<a class="sourceLine" id="cb8-11" data-line-number="11">  suc <span class="ot">(</span>suc x<span class="ot">)</span> 2F- suc y <span class="ot">=</span> x 2F- y</a>
<a class="sourceLine" id="cb8-12" data-line-number="12"></a>
<a class="sourceLine" id="cb8-13" data-line-number="13">  sqr <span class="ot">:</span> <span class="ot">âˆ€</span> n</a>
<a class="sourceLine" id="cb8-14" data-line-number="14">      <span class="ot">â†’</span> â„•</a>
<a class="sourceLine" id="cb8-15" data-line-number="15">      <span class="ot">â†’</span> <span class="ot">(</span>Fin n <span class="ot">â†’</span> Fin <span class="ot">(</span><span class="dv">2</span> + m<span class="ot">))</span></a>
<a class="sourceLine" id="cb8-16" data-line-number="16">      <span class="ot">â†’</span> <span class="ot">(âˆ€</span> <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">â†’</span> Vec <span class="ot">(</span>Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">2</span> + m<span class="ot">)))</span> i <span class="ot">â†’</span> â„• <span class="ot">â†’</span> List <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">3</span> + m<span class="ot">)))</span></a>
<a class="sourceLine" id="cb8-17" data-line-number="17">      <span class="ot">â†’</span> List <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">3</span> + m<span class="ot">))</span></a>
<a class="sourceLine" id="cb8-18" data-line-number="18">  sqr n       zero    f k <span class="ot">=</span> k [] n</a>
<a class="sourceLine" id="cb8-19" data-line-number="19">  sqr zero    <span class="ot">(</span>suc l<span class="ot">)</span> f k <span class="ot">=</span> k [] zero</a>
<a class="sourceLine" id="cb8-20" data-line-number="20">  sqr <span class="ot">(</span>suc n<span class="ot">)</span> <span class="ot">(</span>suc l<span class="ot">)</span> f k <span class="ot">=</span></a>
<a class="sourceLine" id="cb8-21" data-line-number="21">    <span class="kw">let</span> x <span class="ot">=</span> f zero</a>
<a class="sourceLine" id="cb8-22" data-line-number="22">    <span class="kw">in</span> sqr n <span class="ot">(</span>l 2F- x<span class="ot">)</span> <span class="ot">(</span>f âˆ˜ suc<span class="ot">)</span> <span class="ot">(</span>k âˆ˜ <span class="ot">(</span>just x âˆ·<span class="ot">_))</span></a>
<a class="sourceLine" id="cb8-23" data-line-number="23"></a>
<a class="sourceLine" id="cb8-24" data-line-number="24">  sieve <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">â†’</span> Vec <span class="ot">(</span>Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">2</span> + m<span class="ot">)))</span> n <span class="ot">â†’</span> â„• <span class="ot">â†’</span> List <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">3</span> + m<span class="ot">))</span></a>
<a class="sourceLine" id="cb8-25" data-line-number="25">  sieve xsâ€² i <span class="ot">=</span> go xsâ€²</a>
<a class="sourceLine" id="cb8-26" data-line-number="26">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-27" data-line-number="27">    go <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">â†’</span> Vec <span class="ot">(</span>Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">2</span> + m<span class="ot">)))</span> n <span class="ot">â†’</span> List <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">3</span> + m<span class="ot">))</span></a>
<a class="sourceLine" id="cb8-28" data-line-number="28">    go [] <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb8-29" data-line-number="29">    go <span class="ot">(</span>nothing âˆ· xs<span class="ot">)</span> <span class="ot">=</span> go xs</a>
<a class="sourceLine" id="cb8-30" data-line-number="30">    go <span class="ot">(</span>just x  âˆ· xs<span class="ot">)</span> <span class="ot">=</span> Vec<span class="ot">.</span>foldr B remove <span class="ot">(</span>b i<span class="ot">)</span> xs x go</a>
<a class="sourceLine" id="cb8-31" data-line-number="31">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-32" data-line-number="32">      B <span class="ot">=</span> <span class="ot">Î»</span> n <span class="ot">â†’</span> <span class="ot">âˆ€</span> <span class="ot">{</span>i<span class="ot">}</span></a>
<a class="sourceLine" id="cb8-33" data-line-number="33">              <span class="ot">â†’</span> Fin i</a>
<a class="sourceLine" id="cb8-34" data-line-number="34">              <span class="ot">â†’</span> <span class="ot">(</span>Vec <span class="ot">(</span>Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">2</span> + m<span class="ot">)))</span> n <span class="ot">â†’</span> List <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">3</span> + m<span class="ot">)))</span></a>
<a class="sourceLine" id="cb8-35" data-line-number="35">              <span class="ot">â†’</span> List <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">3</span> + m<span class="ot">))</span></a>
<a class="sourceLine" id="cb8-36" data-line-number="36"></a>
<a class="sourceLine" id="cb8-37" data-line-number="37">      b <span class="ot">:</span> â„• <span class="ot">â†’</span> B <span class="dv">0</span></a>
<a class="sourceLine" id="cb8-38" data-line-number="38">      b zero    zero    k <span class="ot">=</span> suc x âˆ· k []</a>
<a class="sourceLine" id="cb8-39" data-line-number="39">      b zero    <span class="ot">(</span>suc y<span class="ot">)</span> k <span class="ot">=</span> k []</a>
<a class="sourceLine" id="cb8-40" data-line-number="40">      b <span class="ot">(</span>suc n<span class="ot">)</span> zero    k <span class="ot">=</span> b n x k</a>
<a class="sourceLine" id="cb8-41" data-line-number="41">      b <span class="ot">(</span>suc n<span class="ot">)</span> <span class="ot">(</span>suc y<span class="ot">)</span> k <span class="ot">=</span> b n y k</a>
<a class="sourceLine" id="cb8-42" data-line-number="42"></a>
<a class="sourceLine" id="cb8-43" data-line-number="43">      remove <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">â†’</span> Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">2</span> + m<span class="ot">))</span> <span class="ot">â†’</span> B n <span class="ot">â†’</span> B <span class="ot">(</span>suc n<span class="ot">)</span></a>
<a class="sourceLine" id="cb8-44" data-line-number="44">      remove y ys zero    k <span class="ot">=</span> ys x <span class="ot">(</span>k âˆ˜ <span class="ot">(</span>nothing âˆ·<span class="ot">_))</span></a>
<a class="sourceLine" id="cb8-45" data-line-number="45">      remove y ys <span class="ot">(</span>suc j<span class="ot">)</span> k <span class="ot">=</span> ys j <span class="ot">(</span>k âˆ˜ <span class="ot">(</span>y âˆ·<span class="ot">_))</span></a></code></pre></div>
<h1 id="infinitude">Infinitude</h1>
<p>The above sieve arenâ€™t â€œtrueâ€ in that each <code>remove</code> is linear, so the performance is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n^2)</annotation></semantics></math> overall. This is the same problem we ran into with the naive infinite sieve in Haskell.</p>
<p>Since it bears such a similarity to the infinite sieve, we have to ask: can <em>this</em> sieve be infinite? Agda supports a notion of infinite data, so it would seem like it:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">5</span> <span class="ot">_</span>â—‚<span class="ot">_</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="kw">record</span> Stream <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  <span class="kw">constructor</span> <span class="ot">_</span>â—‚<span class="ot">_</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4">  <span class="kw">coinductive</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  <span class="kw">field</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6">    head <span class="ot">:</span> A</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">    tail <span class="ot">:</span> Stream A</a>
<a class="sourceLine" id="cb9-8" data-line-number="8"><span class="kw">open</span> Stream</a>
<a class="sourceLine" id="cb9-9" data-line-number="9"></a>
<a class="sourceLine" id="cb9-10" data-line-number="10">primes <span class="ot">:</span> Stream â„•</a>
<a class="sourceLine" id="cb9-11" data-line-number="11">primes <span class="ot">=</span> sieve <span class="dv">1</span> nats</a>
<a class="sourceLine" id="cb9-12" data-line-number="12">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-13" data-line-number="13">  nats <span class="ot">:</span> Stream â„•</a>
<a class="sourceLine" id="cb9-14" data-line-number="14">  head nats <span class="ot">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb9-15" data-line-number="15">  tail nats <span class="ot">=</span> nats</a>
<a class="sourceLine" id="cb9-16" data-line-number="16"></a>
<a class="sourceLine" id="cb9-17" data-line-number="17">  sieve <span class="ot">:</span> â„• <span class="ot">â†’</span> Stream â„• <span class="ot">â†’</span> Stream â„•</a>
<a class="sourceLine" id="cb9-18" data-line-number="18">  head <span class="ot">(</span>sieve i xs<span class="ot">)</span> <span class="ot">=</span> suc i</a>
<a class="sourceLine" id="cb9-19" data-line-number="19">  tail <span class="ot">(</span>sieve i xs<span class="ot">)</span> <span class="ot">=</span> remove i <span class="ot">(</span>head xs<span class="ot">)</span> <span class="ot">(</span>tail xs<span class="ot">)</span> <span class="ot">(</span>sieve âˆ˜ suc âˆ˜ <span class="ot">(_</span>+ i<span class="ot">))</span></a>
<a class="sourceLine" id="cb9-20" data-line-number="20">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-21" data-line-number="21">    remove <span class="ot">:</span> â„• <span class="ot">â†’</span> â„• <span class="ot">â†’</span> Stream â„• <span class="ot">â†’</span> <span class="ot">(</span>â„• <span class="ot">â†’</span> Stream â„• <span class="ot">â†’</span> Stream â„•<span class="ot">)</span> <span class="ot">â†’</span> Stream â„•</a>
<a class="sourceLine" id="cb9-22" data-line-number="22">    remove zero zero zs       k <span class="ot">=</span> remove i <span class="ot">(</span>head zs<span class="ot">)</span> <span class="ot">(</span>tail zs<span class="ot">)</span> <span class="ot">(</span>k âˆ˜ suc<span class="ot">)</span></a>
<a class="sourceLine" id="cb9-23" data-line-number="23">    remove zero <span class="ot">(</span>suc z<span class="ot">)</span> zs    k <span class="ot">=</span> remove i z zs <span class="ot">(</span>k âˆ˜ suc<span class="ot">)</span></a>
<a class="sourceLine" id="cb9-24" data-line-number="24">    remove <span class="ot">(</span>suc y<span class="ot">)</span> zero zs    k <span class="ot">=</span> k zero <span class="ot">(</span>remove y <span class="ot">(</span>head zs<span class="ot">)</span> <span class="ot">(</span>tail zs<span class="ot">)</span> <span class="ot">_</span>â—‚<span class="ot">_)</span></a>
<a class="sourceLine" id="cb9-25" data-line-number="25">    remove <span class="ot">(</span>suc y<span class="ot">)</span> <span class="ot">(</span>suc z<span class="ot">)</span> zs k <span class="ot">=</span> remove y z zs <span class="ot">(</span>k âˆ˜ suc<span class="ot">)</span></a></code></pre></div>
<p>But this wonâ€™t pass the termination checker. What we actually need to prove to do so is that there are infinitely many primes: <a href="https://gist.github.com/copumpkin/1286093">a nontrivial task in Agda</a>.</p>
]]></description>
    <pubDate>Fri, 14 Dec 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-12-14-primes-in-agda.html</guid>
    <dc:creator>Donnacha OisÃ­n Kidney</dc:creator>
</item>
<item>
    <title>Keeping Formal Verification in Bounds</title>
    <link>https://doisinkidney.com/posts/2018-11-20-fast-verified-structures.html</link>
    <description><![CDATA[<div class="info">
    Posted on November 20, 2018
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Agda.html">Agda</a>
    
</div>

<p>One of the favorite pastimes of both Haskell and Agda programmers alike is verifying data structures. Among my favorite examples are Red-Black trees <span class="citation" data-cites="might_missing_2015 weirich_depending_2014">(Might <a href="#ref-might_missing_2015">2015</a>; Weirich <a href="#ref-weirich_depending_2014">2014</a>, verified for balance)</span>, perfect binary trees <span class="citation" data-cites="hinze_perfect_1999">(Hinze <a href="#ref-hinze_perfect_1999">1999</a>)</span>, square matrices <span class="citation" data-cites="okasaki_fast_1999">(Okasaki <a href="#ref-okasaki_fast_1999">1999</a><a href="#ref-okasaki_fast_1999">a</a>)</span>, search trees <span class="citation" data-cites="mcbride_how_2014">(McBride <a href="#ref-mcbride_how_2014">2014</a>, verified for balance and order)</span>, and binomial heaps <span class="citation" data-cites="hinze_numerical_1998">(Hinze <a href="#ref-hinze_numerical_1998">1998</a>, verified for structure)</span>.</p>
<p>There are many ways to verify data structures. One technique which has had recent massive success is to convert Haskell code to Coq, and then verify the Coq translation: this was the route taken by <span class="citation" data-cites="breitner_ready_2018-1">Breitner et al. (<a href="#ref-breitner_ready_2018-1">2018</a>)</span> to verify <code>Set</code> and <code>IntSet</code> in containers (a mammoth achievement, in my opinion).</p>
<p>This approach has some obvious advantages: you separate implementation from testing (which is usually a good idea), and your verification language can be different from your implementation language, with each tailored towards its particular domain.</p>
<p>LiquidHaskell <span class="citation" data-cites="bakst_liquidhaskell_2018">(Bakst et al. <a href="#ref-bakst_liquidhaskell_2018">2018</a>)</span> (and other tools like it) adds an extra type system to Haskell tailor-made for verification. The added type system (refinement types) is more automated (the typechecker uses Z3), more suited for â€œinvariantâ€-like things (it supports subtyping), and has a bunch of domain-specific built-ins (reasoning about sets, equations, etc.). Iâ€™d encourage anyone who hasnâ€™t used it to give it a try: especially if youâ€™re experienced writing any kind of proof in a language like Agda or Idris, LiquidHaskell proofs are <em>shockingly</em> simple and easy.</p>
<p>What Iâ€™m going to focus on today, though, is writing <em>correct-by-construction</em> data structures, using Haskell and Agdaâ€™s own type systems. In particular, Iâ€™m going to look at how to write <em>fast</em> verification. In the other two approaches, we donâ€™t really care about the â€œspeedâ€ of the proofs: sure, itâ€™s nice to speed up compilation and so on, but we donâ€™t have to worry about our implementation suffering at runtime because of some complex proof. When writing correct-by-construction code, though, our task is doubly hard: we now have to worry about the time complexity of both the implementation <em>and the proofs</em>.</p>
<p>In this post, Iâ€™m going to demonstrate some techniques to write proofs that stay within the complexity bounds of the algorithms theyâ€™re verifying (without cheating!). Along the way Iâ€™m going to verify some data structures I havenâ€™t seen verified before (a skew-binary random-access list).</p>
<h1 id="technique-1-start-with-an-unverified-implementation-then-index">Technique 1: Start With an Unverified Implementation, then Index</h1>
<p>To demonstrate the first two techniques, weâ€™re going to write a type for modular arithmetic. For a more tactile metaphor, think of the flip clock:</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/c/c3/Split-flap_display.jpg" /></p>
<p>Each digit can be incremented <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> times, where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> is whatever base youâ€™re using (12 for our flip-clock above). Once you hit the limit, it flips the next digit along. Weâ€™ll start with just one digit, and then just string them together to get our full type. That in mind, our â€œdigitâ€ type has two requirements:</p>
<ol>
<li>It should be incrementable.</li>
<li>Once it hits its limit, it should flip back to zero, and let us know that a flip was performed.</li>
</ol>
<p>Anyone whoâ€™s used a little Agda or Idris will be familiar with the <code>Fin</code> type:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> Fin <span class="ot">:</span> â„• <span class="ot">â†’</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  zero <span class="ot">:</span> <span class="ot">{</span>n <span class="ot">:</span> â„•<span class="ot">}</span> <span class="ot">â†’</span> Fin <span class="ot">(</span>suc n<span class="ot">)</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  suc  <span class="ot">:</span> <span class="ot">{</span>n <span class="ot">:</span> â„•<span class="ot">}</span> <span class="ot">â†’</span> Fin n <span class="ot">â†’</span> Fin <span class="ot">(</span>suc n<span class="ot">)</span></a></code></pre></div>
<p><code>Fin n</code> is the standard way to encode â€œnumbers smaller than <code>n</code>â€. However, for digits theyâ€™re entirely unsuitable: since the limit parameter changes on successor, the kind of increment we want is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n)</annotation></semantics></math>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb2-1" data-line-number="1">try-suc <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">â†’</span> Fin n <span class="ot">â†’</span> Maybe <span class="ot">(</span>Fin n<span class="ot">)</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">try-suc <span class="ot">(</span>suc x<span class="ot">)</span> <span class="ot">=</span> Maybe<span class="ot">.</span>map suc <span class="ot">(</span>try-suc x<span class="ot">)</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">try-suc <span class="ot">{</span>suc n<span class="ot">}</span> zero <span class="kw">with</span> n</a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="ot">...</span> <span class="ot">|</span> zero <span class="ot">=</span> nothing</a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="ot">...</span> <span class="ot">|</span> suc <span class="ot">_</span> <span class="ot">=</span> just <span class="ot">(</span>suc zero<span class="ot">)</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6"></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">suc-flip <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">â†’</span> Fin n <span class="ot">â†’</span> Fin n Ã— Bool</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">suc-flip <span class="ot">{</span>suc n<span class="ot">}</span> x <span class="ot">=</span> maybe <span class="ot">(_</span>, false<span class="ot">)</span> <span class="ot">(</span>zero , true<span class="ot">)</span> <span class="ot">(</span>try-suc x<span class="ot">)</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9">suc-flip <span class="ot">{</span>zero<span class="ot">}</span> <span class="ot">()</span></a></code></pre></div>
<p>If we keep going down this path with proofs in mind, we might next look at the various <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>â‰¤</mo><annotation encoding="application/x-tex">\leq</annotation></semantics></math> proofs in the Agda standard library (<a href="https://github.com/agda/agda-stdlib/blob/18b45b151f44cee2114fa4b3c1ad9ea532baf919/src/Data/Nat/Base.agda#L28">here</a>, <a href="https://github.com/agda/agda-stdlib/blob/18b45b151f44cee2114fa4b3c1ad9ea532baf919/src/Data/Nat/Base.agda#L117">here</a>, and <a href="https://github.com/agda/agda-stdlib/blob/18b45b151f44cee2114fa4b3c1ad9ea532baf919/src/Data/Nat/Base.agda#L133">here</a>), and see if we can we can wrangle them into doing what we want.</p>
<p>For me, though, this wasnâ€™t a fruitful approach. Instead, weâ€™ll try and think of how weâ€™d do this without proving anything, and then see if thereâ€™s any place in the resulting data structure we can hang some proof.</p>
<p>So, in an unproven way, letâ€™s start with some numbers. Since weâ€™re going to be incrementing, theyâ€™d better be unary:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">data</span> â„• <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  zero <span class="ot">:</span> â„•</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">  suc <span class="ot">:</span> â„• <span class="ot">â†’</span> â„•</a></code></pre></div>
<p>And then, for the â€œflippableâ€ type, weâ€™ll just store the limit alongside the value:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">record</span> Flipper <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  <span class="kw">constructor</span> <span class="ot">_</span>&amp;<span class="ot">_</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  <span class="kw">field</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">    val <span class="ot">:</span> â„•</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">    lim <span class="ot">:</span> â„•</a></code></pre></div>
<p>Weâ€™re not there yet: to check if weâ€™ve gone over the limit, weâ€™ll still have to compare <code>val</code> and <code>lim</code>. Hopefully you can guess the optimization weâ€™ll make: instead of storing the limit, weâ€™ll store the space left:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">record</span> Flipper <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">  <span class="kw">constructor</span> <span class="ot">_</span>&amp;<span class="ot">_</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  <span class="kw">field</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">    space <span class="ot">:</span> â„•</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">    val   <span class="ot">:</span> â„•</a></code></pre></div>
<p>And we get our flip function:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb6-1" data-line-number="1">suc-flip <span class="ot">:</span> Flipper <span class="ot">â†’</span> Flipper Ã— Bool</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">suc-flip <span class="ot">(</span>zero  &amp; n<span class="ot">)</span> <span class="ot">=</span> <span class="ot">(</span>suc n &amp; zero <span class="ot">)</span>, true</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">suc-flip <span class="ot">(</span>suc m &amp; n<span class="ot">)</span> <span class="ot">=</span> <span class="ot">(</span>m     &amp; suc n<span class="ot">)</span>, false</a></code></pre></div>
<p>When thereâ€™s no space left, the digit must be maximal (9 in decimal, for instance), so itâ€™ll be one less than the base. That lets us stick it in for the base, rather than recalculating. In the other case, we just take one from the space left, and add it to the value.</p>
<p>So, to â€œproveâ€ this implementation, we might first reach for an equality proof that <code>val + space</code> is equal to your base. Donâ€™t! Both <code>val</code> and <code>space</code> are inductive structures, which could be giving us information on every application of <code>suc</code>! Letâ€™s set our sights on <code>val</code> and see how we can hang our proofs off of it.</p>
<p>Weâ€™re going to upgrade our Peano number with some information, which means that our resulting type is going to look an awful lot like a Peano number. In other words, two cases: <code>zero</code> and <code>suc</code>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">data</span> Val <span class="ot">_</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  zero-case <span class="ot">:</span> Val <span class="ot">_</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  suc-case  <span class="ot">:</span> Val <span class="ot">_</span> <span class="ot">â†’</span> Val <span class="ot">_</span></a></code></pre></div>
<p>For the <code>suc-case</code>, remember we only want to be allowed to increment it when the space left is more than zero. So letâ€™s encode it:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">data</span> Val <span class="ot">_</span> <span class="ot">:</span> â„• <span class="ot">â†’</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  zero-case <span class="ot">:</span> Val <span class="ot">_</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  suc-case  <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>space<span class="ot">}</span> <span class="ot">â†’</span> Val <span class="ot">_</span> <span class="ot">(</span>suc space<span class="ot">)</span> <span class="ot">â†’</span> Val <span class="ot">_</span> space</a></code></pre></div>
<p>And for the <code>zero-case</code>, the space left is just the base. So letâ€™s stick the base into the type as well:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">data</span> Val <span class="ot">(</span>base <span class="ot">:</span> â„•<span class="ot">)</span> <span class="ot">:</span> â„• <span class="ot">â†’</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">  zero-case <span class="ot">:</span> Val base base</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  suc-case  <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>space<span class="ot">}</span> <span class="ot">â†’</span> Val base <span class="ot">(</span>suc space<span class="ot">)</span> <span class="ot">â†’</span> Val base space</a></code></pre></div>
<p>(Weâ€™ve changed around the way â€œbaseâ€ works: itâ€™s now one smaller. So to encode base-10 youâ€™d have <code>Val 9 space</code>. You can get back to the other encoding with a simple wrapper, this way just makes things slightly easier from now on).</p>
<p>Finally, our flipper:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">record</span> Flipper <span class="ot">(</span>base <span class="ot">:</span> â„•<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">  <span class="kw">constructor</span> <span class="ot">_</span>&amp;<span class="ot">_</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  <span class="kw">field</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4">    space <span class="ot">:</span> â„•</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">    val <span class="ot">:</span> Val base space</a>
<a class="sourceLine" id="cb10-6" data-line-number="6"></a>
<a class="sourceLine" id="cb10-7" data-line-number="7">suc-flip <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">â†’</span> Flipper n <span class="ot">â†’</span> Flipper n Ã— Bool</a>
<a class="sourceLine" id="cb10-8" data-line-number="8">suc-flip <span class="ot">(</span>zero  &amp; m<span class="ot">)</span> <span class="ot">=</span> <span class="ot">(_</span> &amp;  zero-case<span class="ot">)</span> , true</a>
<a class="sourceLine" id="cb10-9" data-line-number="9">suc-flip <span class="ot">(</span>suc n &amp; m<span class="ot">)</span> <span class="ot">=</span> <span class="ot">(</span>n &amp; suc-case m<span class="ot">)</span> , false</a></code></pre></div>
<p>Great! Everything works.</p>
<p>You may have noticed that the <code>Val</code> type is actually a proof for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>â‰¥</mo><annotation encoding="application/x-tex">\geq</annotation></semantics></math> in disguise:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">data</span> <span class="ot">_</span>â‰¥<span class="ot">_</span> <span class="ot">(</span>m <span class="ot">:</span> â„•<span class="ot">)</span> <span class="ot">:</span> â„• <span class="ot">â†’</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2">  mâ‰¥m <span class="ot">:</span> m â‰¥ m</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  mâ‰¥p <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">â†’</span> m â‰¥ suc n <span class="ot">â†’</span> m â‰¥ n</a></code></pre></div>
<p>And the flipper itself is just an existential in disguise:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb12-1" data-line-number="1">Flipper <span class="ot">:</span> â„• <span class="ot">â†’</span> <span class="dt">Set</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">Flipper n <span class="ot">=</span> âˆƒ <span class="ot">(</span>n â‰¥<span class="ot">_)</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3"></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">suc-flip <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">â†’</span> Flipper n <span class="ot">â†’</span> Flipper n Ã— Bool</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">suc-flip <span class="ot">(</span>zero  , m<span class="ot">)</span> <span class="ot">=</span> <span class="ot">(_</span> , mâ‰¥m  <span class="ot">)</span>, true</a>
<a class="sourceLine" id="cb12-6" data-line-number="6">suc-flip <span class="ot">(</span>suc n , m<span class="ot">)</span> <span class="ot">=</span> <span class="ot">(</span>n , mâ‰¥p m<span class="ot">)</span>, false</a></code></pre></div>
<p>Hopefully this explanation will help you understand how to get from the specification to those 8 lines. This technique is going to come in especially handy later when we base data structures off of number systems.</p>
<h1 id="technique-2-once-you-eliminate-the-impossible-whatever-remains-no-matter-how-improbable-must-be-the-truth.">Technique 2: Once you eliminate the impossible, whatever remains, no matter how improbable, must be the truth.</h1>
<p>For this next trick, weâ€™ll add an extra operation to the flipper type above: conversion from a natural number. We want to be able to do it in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n)</annotation></semantics></math> time, and we wonâ€™t allow ourselves to change the original type definition. Hereâ€™s the type weâ€™re aiming for:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb13-1" data-line-number="1">fromNat <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>m<span class="ot">}</span> <span class="ot">(</span>n <span class="ot">:</span> â„•<span class="ot">)</span> <span class="ot">â†’</span> <span class="ot">(</span>mâ‰¥n <span class="ot">:</span> m â‰¥ n<span class="ot">)</span> <span class="ot">â†’</span> Flipper m</a></code></pre></div>
<p>We pass in a proof that the natural number weâ€™re converting from is indeed in range (itâ€™s marked irrelevant so we donâ€™t pay for it). Hereâ€™s a non-answer:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb14-1" data-line-number="1">fromNat <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>m<span class="ot">}</span> <span class="ot">(</span>n <span class="ot">:</span> â„•<span class="ot">)</span> <span class="ot">â†’</span> <span class="ot">{</span>mâ‰¥n <span class="ot">:</span> m â‰¥ n<span class="ot">}</span> <span class="ot">â†’</span> Flipper m</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">fromNat n <span class="ot">{</span>mâ‰¥n<span class="ot">}</span> <span class="ot">=</span> n , mâ‰¥n</a></code></pre></div>
<p>While this looks fine, itâ€™s actually the <em>inverse</em> of what we want. We defined the inductive structure to be indicated by the inequality proof itself. Letâ€™s make the desired output explicit:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb15-1" data-line-number="1">toNat <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>n m<span class="ot">}</span> <span class="ot">â†’</span> n â‰¥ m <span class="ot">â†’</span> â„•</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">toNat mâ‰¥m <span class="ot">=</span> zero</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">toNat <span class="ot">(</span>mâ‰¥p nâ‰¥m<span class="ot">)</span> <span class="ot">=</span> suc <span class="ot">(</span>toNat nâ‰¥m<span class="ot">)</span></a>
<a class="sourceLine" id="cb15-4" data-line-number="4"></a>
<a class="sourceLine" id="cb15-5" data-line-number="5">fromNat-â‰¡ <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>n<span class="ot">}</span> m</a>
<a class="sourceLine" id="cb15-6" data-line-number="6">          <span class="ot">â†’</span> <span class="ot">.(</span>nâ‰¥m <span class="ot">:</span> n â‰¥ m<span class="ot">)</span></a>
<a class="sourceLine" id="cb15-7" data-line-number="7">          <span class="ot">â†’</span>  Î£[ n-m âˆˆ Flipper n ] toNat <span class="ot">(</span>projâ‚‚ n-m<span class="ot">)</span> â‰¡ m</a></code></pre></div>
<p>And finally we can try an implementation:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb16-1" data-line-number="1">fromNat-â‰¡ zero    <span class="ot">_</span>   <span class="ot">=</span> <span class="ot">(_</span> , mâ‰¥m<span class="ot">)</span> , refl</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">fromNat-â‰¡ <span class="ot">(</span>suc m<span class="ot">)</span> nâ‰¥m <span class="ot">=</span> ??? <span class="ot">(</span>fromNat-â‰¡ m <span class="ot">(</span>mâ‰¥p nâ‰¥m<span class="ot">))</span></a></code></pre></div>
<p>In the <code>???</code> there, we want some kind of successor function. The problem is that we would also need to prove that we <em>can</em> do a successor call. Except we donâ€™t want to do that: proving that thereâ€™s space left is an expensive operation, and one we can avoid with another trick: first, we <em>assume</em> that thereâ€™s space left.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb17-1" data-line-number="1">fromNat-â‰¡ zero    nâ‰¥m <span class="ot">=</span> <span class="ot">(</span> <span class="ot">_</span> , mâ‰¥m<span class="ot">)</span> , refl</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">fromNat-â‰¡ <span class="ot">(</span>suc n<span class="ot">)</span> nâ‰¥m <span class="kw">with</span> fromNat-â‰¡ n <span class="ot">(</span>mâ‰¥p nâ‰¥m<span class="ot">)</span></a>
<a class="sourceLine" id="cb17-3" data-line-number="3"><span class="ot">...</span> <span class="ot">|</span> <span class="ot">(</span>suc space , n-1<span class="ot">)</span>, xâ‰¡m  <span class="ot">=</span> <span class="ot">(</span>space , mâ‰¥p n-1<span class="ot">)</span>, cong suc xâ‰¡m</a>
<a class="sourceLine" id="cb17-4" data-line-number="4"><span class="ot">...</span> <span class="ot">|</span> <span class="ot">(</span>zero      , n-1<span class="ot">)</span>, refl <span class="ot">=</span> ???</a></code></pre></div>
<p>But what about the second case? Well, we have to prove this impossible. What if itâ€™s an extremely complex, expensive proof? It doesnâ€™t matter! It will never be run! In contrast to proving the â€œhappy pathâ€ correct, if we can confine all of the ugly complex cases to the unhappy paths, we can spend as long as we want proving them impossible without having to worry about runtime cost. Hereâ€™s the full function.</p>
<details>
<p><summary> <code>fromNat</code> implementation </summary></p>
<div class="sourceCode" id="cb18"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb18-1" data-line-number="1">fromNat-â‰¡ <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>n<span class="ot">}</span> m</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">          <span class="ot">â†’</span> <span class="ot">.(</span>nâ‰¥m <span class="ot">:</span> n â‰¥ m<span class="ot">)</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3">          <span class="ot">â†’</span>  Î£[ n-m âˆˆ Flipper n ] toNat <span class="ot">(</span>projâ‚‚ n-m<span class="ot">)</span> â‰¡ m</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">fromNat-â‰¡ zero    nâ‰¥m <span class="ot">=</span> <span class="ot">(</span> <span class="ot">_</span> , mâ‰¥m<span class="ot">)</span> , refl</a>
<a class="sourceLine" id="cb18-5" data-line-number="5">fromNat-â‰¡ <span class="ot">(</span>suc n<span class="ot">)</span> nâ‰¥m <span class="kw">with</span> fromNat-â‰¡ n <span class="ot">(</span>mâ‰¥p nâ‰¥m<span class="ot">)</span></a>
<a class="sourceLine" id="cb18-6" data-line-number="6"><span class="ot">...</span> <span class="ot">|</span> <span class="ot">(</span>suc space , n-1<span class="ot">)</span>, xâ‰¡m  <span class="ot">=</span> <span class="ot">(</span>space , mâ‰¥p n-1<span class="ot">)</span>, cong suc xâ‰¡m</a>
<a class="sourceLine" id="cb18-7" data-line-number="7"><span class="ot">...</span> <span class="ot">|</span> <span class="ot">(</span>zero      , nâ‰¥0<span class="ot">)</span>, refl <span class="ot">=</span> Irrel<span class="ot">.</span>âŠ¥-elim <span class="ot">(</span>contra <span class="ot">_</span> zero nâ‰¥0 nâ‰¥m<span class="ot">)</span></a>
<a class="sourceLine" id="cb18-8" data-line-number="8">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-9" data-line-number="9">  <span class="kw">import</span> Data<span class="ot">.</span>Nat<span class="ot">.</span>Properties as <span class="dt">Prop</span></a>
<a class="sourceLine" id="cb18-10" data-line-number="10"></a>
<a class="sourceLine" id="cb18-11" data-line-number="11">  nâ‰±sk+n <span class="ot">:</span> <span class="ot">âˆ€</span> n k <span class="ot">{</span>sk+n<span class="ot">}</span> <span class="ot">â†’</span> sk+n â‰¡ suc k â„•<span class="ot">.</span>+ n <span class="ot">â†’</span> n â‰¥ sk+n <span class="ot">â†’</span> âŠ¥</a>
<a class="sourceLine" id="cb18-12" data-line-number="12">  nâ‰±sk+n n k wit <span class="ot">(</span>mâ‰¥p nâ‰¥sk+n<span class="ot">)</span> <span class="ot">=</span> nâ‰±sk+n n <span class="ot">(</span>suc k<span class="ot">)</span> <span class="ot">(</span>cong suc wit<span class="ot">)</span> nâ‰¥sk+n</a>
<a class="sourceLine" id="cb18-13" data-line-number="13">  nâ‰±sk+n n k wit mâ‰¥m <span class="kw">with</span> <span class="dt">Prop</span><span class="ot">.</span>+-cancelÊ³-â‰¡ <span class="dv">0</span> <span class="ot">(</span>suc k<span class="ot">)</span> wit</a>
<a class="sourceLine" id="cb18-14" data-line-number="14">  <span class="ot">...</span> <span class="ot">|</span> <span class="ot">()</span></a>
<a class="sourceLine" id="cb18-15" data-line-number="15"></a>
<a class="sourceLine" id="cb18-16" data-line-number="16">  contra <span class="ot">:</span> <span class="ot">âˆ€</span> n m <span class="ot">â†’</span> <span class="ot">(</span>nâ‰¥m <span class="ot">:</span> n â‰¥ m<span class="ot">)</span> <span class="ot">â†’</span> n â‰¥ suc <span class="ot">(</span>m â„•<span class="ot">.</span>+ toNat nâ‰¥m<span class="ot">)</span> <span class="ot">â†’</span> âŠ¥</a>
<a class="sourceLine" id="cb18-17" data-line-number="17">  contra n m mâ‰¥m nâ‰¥st <span class="ot">=</span> nâ‰±sk+n n zero <span class="ot">(</span>cong suc <span class="ot">(</span><span class="dt">Prop</span><span class="ot">.</span>+-identityÊ³ n<span class="ot">))</span> nâ‰¥st</a>
<a class="sourceLine" id="cb18-18" data-line-number="18">  contra n m <span class="ot">(</span>mâ‰¥p nâ‰¥m<span class="ot">)</span> nâ‰¥st <span class="ot">=</span></a>
<a class="sourceLine" id="cb18-19" data-line-number="19">    contra</a>
<a class="sourceLine" id="cb18-20" data-line-number="20">      n</a>
<a class="sourceLine" id="cb18-21" data-line-number="21">      <span class="ot">(</span>suc m<span class="ot">)</span></a>
<a class="sourceLine" id="cb18-22" data-line-number="22">      nâ‰¥m</a>
<a class="sourceLine" id="cb18-23" data-line-number="23">      <span class="ot">(</span>subst <span class="ot">(Î»</span> x <span class="ot">â†’</span> n â‰¥ suc x<span class="ot">)</span> <span class="ot">(</span><span class="dt">Prop</span><span class="ot">.</span>+-suc m <span class="ot">(</span>toNat nâ‰¥m<span class="ot">))</span> nâ‰¥st<span class="ot">)</span></a>
<a class="sourceLine" id="cb18-24" data-line-number="24"></a>
<a class="sourceLine" id="cb18-25" data-line-number="25">fromNat <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>n<span class="ot">}</span> m <span class="ot">â†’</span> <span class="ot">.(</span>nâ‰¥m <span class="ot">:</span> n â‰¥ m<span class="ot">)</span> <span class="ot">â†’</span> Flipper n</a>
<a class="sourceLine" id="cb18-26" data-line-number="26">fromNat m nâ‰¥m <span class="ot">=</span> projâ‚ <span class="ot">(</span>fromNat-â‰¡ m nâ‰¥m<span class="ot">)</span></a></code></pre></div>
</details>
<h1 id="technique-3-make-indices-correct-by-construction">Technique 3: Make Indices Correct-By-Construction</h1>
<p>Weâ€™re going to switch into Haskell now, and in particular to functional arrays. These are data structures which arenâ€™t real arrays, but they offer you the kind of interface youâ€™d want from an array in a functional setting. You canâ€™t get better than <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math> indexing, unfortunately <span class="citation" data-cites="ben-amram_pointers_1992">(Ben-Amram and Galil <a href="#ref-ben-amram_pointers_1992">1992</a>)</span>, but often itâ€™s enough.</p>
<p>The first â€œfunctional arrayâ€ weâ€™re going to be looking at nested binary random-access lists. It has <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math> indexing, as you might expect, and amortized single-threaded <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math> <code>cons</code>.</p>
<p>It starts out like a binary random-access list (â€œrandom-access listâ€ is another name for â€œfunctional arrayâ€). You can find a full explanation of the structure in your nearest copy of Purely Functional Data Structures <span class="citation" data-cites="okasaki_purely_1999">(Okasaki <a href="#ref-okasaki_purely_1999">1999</a><a href="#ref-okasaki_purely_1999">b</a>)</span>, but briefly: the structure mimics a binary number, in that itâ€™s a list of â€œbitsâ€. At each set bit, it stores a tree with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mi>i</mi></msup><annotation encoding="application/x-tex">2^i</annotation></semantics></math> elements, where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math> is the position in the list. In this way, every binary number <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> has an analogous list of â€œbitsâ€ which contains, in total, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> elements.</p>
<p>The â€œnestedâ€ part refers to how weâ€™re going to implement the trees. It works a little like this:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a <span class="fu">=</span> <span class="dt">Leaf</span> a <span class="fu">|</span> <span class="dt">Node</span> (<span class="dt">Tree</span> (a,a))</a></code></pre></div>
<p>You might have to squint at that definition for a second to understand it: instead of storing two trees at the <code>Node</code> constructor (which is what youâ€™d usually do), we store a tree with double the elements. This has two advantages: all of the children have the same number of elements (this tree, for instance, is always some power of 2), and it also cuts down on memory use.</p>
<p>For the binary random-access list, weâ€™ll use the nested encoding of trees to encode the contents of each bit. Thereâ€™s an implementation of this very thing on Hackage <span class="citation" data-cites="komuves_nested-sequence_2016">(Komuves and Divianszky <a href="#ref-komuves_nested-sequence_2016">2016</a>)</span>, and Okasaki himself wrote something very similar to it <span class="citation" data-cites="okasaki_fast_1999">(<a href="#ref-okasaki_fast_1999">1999</a><a href="#ref-okasaki_fast_1999">a</a>)</span>, but weâ€™re going to go a little further than both of those by indexing the type by its size. Here it is:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Bit</span> <span class="fu">=</span> <span class="dt">O</span> <span class="fu">|</span> <span class="dt">I</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2"></a>
<a class="sourceLine" id="cb20-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Seq</span> ns a <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-4" data-line-number="4">    <span class="dt">Nil</span><span class="ot">  ::</span>                      <span class="dt">Seq</span> <span class="ch">&#39;[]      a</span></a>
<a class="sourceLine" id="cb20-5" data-line-number="5">    <span class="dt">Even</span><span class="ot"> ::</span>      <span class="dt">Seq</span> xs (a,a) <span class="ot">-&gt;</span> <span class="dt">Seq</span> (<span class="dt">O</span> <span class="fu">:</span> xs) a</a>
<a class="sourceLine" id="cb20-6" data-line-number="6">    <span class="dt">Odd</span><span class="ot">  ::</span> a <span class="ot">-&gt;</span> <span class="dt">Seq</span> xs (a,a) <span class="ot">-&gt;</span> <span class="dt">Seq</span> (<span class="dt">I</span> <span class="fu">:</span> xs) a</a></code></pre></div>
<p>The operations weâ€™re interested will be <code>cons</code> and <code>uncons</code>: for the indices, they correspond to incrementing and decrementing the numbers, respectively. As such, weâ€™ll need type-level functions for those:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">Inc</span> (<span class="ot">ns ::</span> [<span class="dt">Bit</span>])<span class="ot"> ::</span> [<span class="dt">Bit</span>] <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-2" data-line-number="2">    <span class="dt">Inc</span> <span class="ch">&#39;[] = &#39;</span>[<span class="dt">I</span>]</a>
<a class="sourceLine" id="cb21-3" data-line-number="3">    <span class="dt">Inc</span> (<span class="dt">O</span> <span class="fu">:</span> xs) <span class="fu">=</span> <span class="dt">I</span> <span class="fu">:</span> xs</a>
<a class="sourceLine" id="cb21-4" data-line-number="4">    <span class="dt">Inc</span> (<span class="dt">I</span> <span class="fu">:</span> xs) <span class="fu">=</span> <span class="dt">O</span> <span class="fu">:</span> <span class="dt">Inc</span> xs</a></code></pre></div>
<p>And now the <code>cons</code> function:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="ot">cons ::</span> a <span class="ot">-&gt;</span> <span class="dt">Seq</span> ns a <span class="ot">-&gt;</span> <span class="dt">Seq</span> (<span class="dt">Inc</span> ns) a</a>
<a class="sourceLine" id="cb22-2" data-line-number="2">cons x <span class="dt">Nil</span>        <span class="fu">=</span> <span class="dt">Odd</span> x <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb22-3" data-line-number="3">cons x (<span class="dt">Even</span>  xs) <span class="fu">=</span> <span class="dt">Odd</span> x xs</a>
<a class="sourceLine" id="cb22-4" data-line-number="4">cons x (<span class="dt">Odd</span> y ys) <span class="fu">=</span> <span class="dt">Even</span> (cons (x,y) ys)</a></code></pre></div>
<p>However, weâ€™re going to run into trouble if we try to write <code>uncons</code>:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">Dec</span> (<span class="ot">ns ::</span> [<span class="dt">Bit</span>])<span class="ot"> ::</span> [<span class="dt">Bit</span>] <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-2" data-line-number="2">    <span class="dt">Dec</span> (<span class="dt">I</span> <span class="fu">:</span> xs) <span class="fu">=</span> <span class="dt">O</span> <span class="fu">:</span> xs</a>
<a class="sourceLine" id="cb23-3" data-line-number="3">    <span class="dt">Dec</span> (<span class="dt">O</span> <span class="fu">:</span> xs) <span class="fu">=</span> <span class="dt">I</span> <span class="fu">:</span> <span class="dt">Dec</span> xs</a>
<a class="sourceLine" id="cb23-4" data-line-number="4">    <span class="dt">Dec</span> <span class="ch">&#39;[] = ???</span></a>
<a class="sourceLine" id="cb23-5" data-line-number="5">    </a>
<a class="sourceLine" id="cb23-6" data-line-number="6"><span class="ot">uncons ::</span> <span class="dt">Seq</span> ns a <span class="ot">-&gt;</span> (a, <span class="dt">Seq</span> (<span class="dt">Dec</span> ns) a)</a>
<a class="sourceLine" id="cb23-7" data-line-number="7">uncons (<span class="dt">Odd</span> x xs) <span class="fu">=</span> (x, <span class="dt">Even</span> xs)</a>
<a class="sourceLine" id="cb23-8" data-line-number="8">uncons (<span class="dt">Even</span>  xs) <span class="fu">=</span> <span class="kw">case</span> uncons xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb23-9" data-line-number="9">    ((x,y),ys) <span class="ot">-&gt;</span> (x, <span class="dt">Odd</span> y ys)</a>
<a class="sourceLine" id="cb23-10" data-line-number="10">uncons <span class="dt">Nil</span> <span class="fu">=</span> <span class="fu">???</span></a></code></pre></div>
<p>We <em>should</em> be able to write this function without returning a <code>Maybe</code>. Because we statically know the size, we can encode â€œonly nonempty sequencesâ€. The problem is that <code>Seq [] a</code> isnâ€™t the only non-empty sequence: thereâ€™s also <code>Seq [O] a</code> and <code>Seq [O,O] a</code>, and so on. Our binary number system is redundant, because it contains trailing zeroes.</p>
<p>We could add some kind of proof into the data structure, but that would (again) be expensive. Instead, we can make the index <em>itself</em> correct-by-construction, by choosing a non-redundant representation of binary numbers.</p>
<p>Hereâ€™s the trick: instead of having a list of bits, weâ€™re going to have a list of â€œthe distance to the next oneâ€. This eliminates the redundancy, and translates into our data structure like so:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="kw">data</span> <span class="dt">N</span> <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">|</span> <span class="dt">S</span> <span class="dt">N</span></a>
<a class="sourceLine" id="cb24-2" data-line-number="2"></a>
<a class="sourceLine" id="cb24-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Nest</span> n ns a <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-4" data-line-number="4">    <span class="dt">Odd</span><span class="ot">  ::</span> a <span class="ot">-&gt;</span> (<span class="dt">Seq</span>    ns (a,a)) <span class="ot">-&gt;</span> <span class="dt">Nest</span> <span class="dt">Z</span>     ns a</a>
<a class="sourceLine" id="cb24-5" data-line-number="5">    <span class="dt">Even</span><span class="ot"> ::</span>      (<span class="dt">Nest</span> n ns (a,a)) <span class="ot">-&gt;</span> <span class="dt">Nest</span> (<span class="dt">S</span> n) ns a</a>
<a class="sourceLine" id="cb24-6" data-line-number="6"></a>
<a class="sourceLine" id="cb24-7" data-line-number="7"><span class="kw">data</span> <span class="dt">Seq</span> ns a <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-8" data-line-number="8">    <span class="dt">Nil</span><span class="ot">  ::</span> <span class="dt">Seq</span> <span class="ch">&#39;[] a</span></a>
<a class="sourceLine" id="cb24-9" data-line-number="9">    <span class="dt">Cons</span><span class="ot"> ::</span> <span class="dt">Nest</span> n ns a <span class="ot">-&gt;</span> <span class="dt">Seq</span> (n <span class="fu">:</span> ns) a</a></code></pre></div>
<p>Lovely! Crucially for our <code>uncons</code>, we now know that any non-empty list of bits is a non-zero list of bits, so we can type â€œnonempty sequenceâ€ easily:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">Dec</span> (<span class="ot">n ::</span> <span class="dt">N</span>) (<span class="ot">ns ::</span> [<span class="dt">N</span>]) <span class="fu">=</span> (<span class="ot">r ::</span> [<span class="dt">N</span>]) <span class="fu">|</span> r <span class="ot">-&gt;</span> n ns <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-2" data-line-number="2">    <span class="dt">Dec</span> (<span class="dt">S</span> n) ns       <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">:</span> <span class="dt">Dec</span> n ns</a>
<a class="sourceLine" id="cb25-3" data-line-number="3">    <span class="dt">Dec</span> <span class="dt">Z</span>     <span class="ch">&#39;[]      = &#39;</span>[]</a>
<a class="sourceLine" id="cb25-4" data-line-number="4">    <span class="dt">Dec</span> <span class="dt">Z</span>     (n <span class="fu">:</span> ns) <span class="fu">=</span> <span class="dt">S</span> n <span class="fu">:</span> ns</a>
<a class="sourceLine" id="cb25-5" data-line-number="5"></a>
<a class="sourceLine" id="cb25-6" data-line-number="6"><span class="ot">uncons ::</span> <span class="dt">Seq</span> (n <span class="fu">:</span> ns) a <span class="ot">-&gt;</span> (a, <span class="dt">Seq</span> (<span class="dt">Dec</span> n ns) a)</a>
<a class="sourceLine" id="cb25-7" data-line-number="7">uncons (<span class="dt">Cons</span> xs&#39;) <span class="fu">=</span> go xs&#39;</a>
<a class="sourceLine" id="cb25-8" data-line-number="8">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-9" data-line-number="9"><span class="ot">    go ::</span> <span class="dt">Nest</span> n ns a <span class="ot">-&gt;</span> (a, <span class="dt">Seq</span> (<span class="dt">Dec</span> n ns) a)</a>
<a class="sourceLine" id="cb25-10" data-line-number="10">    go (<span class="dt">Odd</span> x <span class="dt">Nil</span>) <span class="fu">=</span> (x, <span class="dt">Nil</span>)</a>
<a class="sourceLine" id="cb25-11" data-line-number="11">    go (<span class="dt">Odd</span> x (<span class="dt">Cons</span> xs)) <span class="fu">=</span> (x, <span class="dt">Cons</span> (<span class="dt">Even</span> xs))</a>
<a class="sourceLine" id="cb25-12" data-line-number="12">    go (<span class="dt">Even</span> xs) <span class="fu">=</span> <span class="kw">case</span> go xs <span class="kw">of</span> ((x,y),ys) <span class="ot">-&gt;</span> (x, <span class="dt">Cons</span> (<span class="dt">Odd</span> y ys))</a></code></pre></div>
<p>Weâ€™re still not done, though: hereâ€™s our new type family for incrementing things.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">Inc</span> (<span class="ot">ns ::</span> [<span class="dt">N</span>])<span class="ot"> ::</span> [<span class="dt">N</span>] <span class="kw">where</span></a>
<a class="sourceLine" id="cb26-2" data-line-number="2">    <span class="dt">Inc</span> <span class="ch">&#39;[] = &#39;</span>[<span class="dt">Z</span>]</a>
<a class="sourceLine" id="cb26-3" data-line-number="3">    <span class="dt">Inc</span> (<span class="dt">S</span> n <span class="fu">:</span> ns) <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">:</span> n <span class="fu">:</span> ns</a>
<a class="sourceLine" id="cb26-4" data-line-number="4">    <span class="dt">Inc</span> (<span class="dt">Z</span>   <span class="fu">:</span> ns) <span class="fu">=</span> <span class="dt">Carry</span> (<span class="dt">Inc</span> ns)</a>
<a class="sourceLine" id="cb26-5" data-line-number="5">    </a>
<a class="sourceLine" id="cb26-6" data-line-number="6"><span class="kw">type</span> family <span class="dt">Carry</span> (<span class="ot">ns ::</span> [<span class="dt">N</span>])<span class="ot"> ::</span> [<span class="dt">N</span>] <span class="kw">where</span></a>
<a class="sourceLine" id="cb26-7" data-line-number="7">    <span class="dt">Carry</span> <span class="ch">&#39;[] = &#39;</span>[]</a>
<a class="sourceLine" id="cb26-8" data-line-number="8">    <span class="dt">Carry</span> (n <span class="fu">:</span> ns) <span class="fu">=</span> <span class="dt">S</span> n <span class="fu">:</span> ns</a></code></pre></div>
<p>The <code>Carry</code> there is ugly, and that ugliness carries into the <code>cons</code> function:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="ot">cons ::</span> a <span class="ot">-&gt;</span> <span class="dt">Seq</span> ns a <span class="ot">-&gt;</span> <span class="dt">Seq</span> (<span class="dt">Inc</span> ns) a</a>
<a class="sourceLine" id="cb27-2" data-line-number="2">cons x <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Cons</span> (<span class="dt">Odd</span> x <span class="dt">Nil</span>)</a>
<a class="sourceLine" id="cb27-3" data-line-number="3">cons x&#39; (<span class="dt">Cons</span> xs&#39;) <span class="fu">=</span> go x&#39; xs&#39;</a>
<a class="sourceLine" id="cb27-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb27-5" data-line-number="5"><span class="ot">    go ::</span> a <span class="ot">-&gt;</span> <span class="dt">Nest</span> n ns a <span class="ot">-&gt;</span> <span class="dt">Seq</span> (<span class="dt">Inc</span> (n<span class="fu">:</span>ns)) a</a>
<a class="sourceLine" id="cb27-6" data-line-number="6">    go x (<span class="dt">Even</span>  xs) <span class="fu">=</span> <span class="dt">Cons</span> (<span class="dt">Odd</span> x (<span class="dt">Cons</span> xs))</a>
<a class="sourceLine" id="cb27-7" data-line-number="7">    go x (<span class="dt">Odd</span> y <span class="dt">Nil</span>) <span class="fu">=</span> <span class="dt">Cons</span> (<span class="dt">Even</span> (<span class="dt">Odd</span> (x,y) <span class="dt">Nil</span>))</a>
<a class="sourceLine" id="cb27-8" data-line-number="8">    go x (<span class="dt">Odd</span> y (<span class="dt">Cons</span> ys)) <span class="fu">=</span> carry (go (x,y) ys)</a>
<a class="sourceLine" id="cb27-9" data-line-number="9"></a>
<a class="sourceLine" id="cb27-10" data-line-number="10"><span class="ot">    carry ::</span> <span class="dt">Seq</span> ns (a,a) <span class="ot">-&gt;</span> <span class="dt">Seq</span> (<span class="dt">Carry</span> ns) a</a>
<a class="sourceLine" id="cb27-11" data-line-number="11">    carry <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb27-12" data-line-number="12">    carry (<span class="dt">Cons</span> xs) <span class="fu">=</span> <span class="dt">Cons</span> (<span class="dt">Even</span> xs)</a></code></pre></div>
<p>To clean it up, weâ€™re going to use another technique.</p>
<h1 id="technique-4-provide-information-on-indices-as-early-as-possible">Technique 4: Provide Information on Indices as Early as Possible</h1>
<p>You occasionally see people wonder about the usual definition of addition on Peano numbers:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb28-1" data-line-number="1"><span class="ot">_</span>+<span class="ot">_</span> <span class="ot">:</span> â„• <span class="ot">â†’</span> â„• <span class="ot">â†’</span> â„•</a>
<a class="sourceLine" id="cb28-2" data-line-number="2">zero  + m <span class="ot">=</span> m</a>
<a class="sourceLine" id="cb28-3" data-line-number="3">suc n + m <span class="ot">=</span> suc <span class="ot">(</span>n + m<span class="ot">)</span></a></code></pre></div>
<p>Itâ€™s very simple, with only two equations. When someone sees the following error, then:</p>
<blockquote>
<p><code>couldn't match type n with n + 0</code></p>
</blockquote>
<p>They might be tempted to add it as an equation to the function:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb29-1" data-line-number="1"><span class="ot">_</span>+<span class="ot">_</span> <span class="ot">:</span> â„• <span class="ot">â†’</span> â„• <span class="ot">â†’</span> â„•</a>
<a class="sourceLine" id="cb29-2" data-line-number="2">zero  + m    <span class="ot">=</span> m</a>
<a class="sourceLine" id="cb29-3" data-line-number="3">n     + zero <span class="ot">=</span> n</a>
<a class="sourceLine" id="cb29-4" data-line-number="4">suc n + m    <span class="ot">=</span> suc <span class="ot">(</span>n + m<span class="ot">)</span></a></code></pre></div>
<p>Similarly, when someone sees the other error commonly found with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>+</mo><annotation encoding="application/x-tex">+</annotation></semantics></math>:</p>
<blockquote>
<p><code>couldn't match type S n + m with n + S m</code></p>
</blockquote>
<p>Theyâ€™ll add that equation in too! In fact, that particular equation will provide a valid definition of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>+</mo><annotation encoding="application/x-tex">+</annotation></semantics></math>:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="ot">_</span>+<span class="ot">_</span> <span class="ot">:</span> â„• <span class="ot">â†’</span> â„• <span class="ot">â†’</span> â„•</a>
<a class="sourceLine" id="cb30-2" data-line-number="2">zero  + m <span class="ot">=</span> m</a>
<a class="sourceLine" id="cb30-3" data-line-number="3">suc n + m <span class="ot">=</span> n + suc m</a></code></pre></div>
<p>So why is the first definition of + the one almost always used? Because it <em>maximizes output information from minimal input</em>. Take the second implementation above, the one with the zero on the right. In this function, we have to look at the second argument in the second clause: in other words, we donâ€™t get to find out about the output until weâ€™ve looked at both <code>n</code> and <code>m</code>. In the usual definition, if you know the first argument is <code>suc</code> something, you also know the <em>output</em> must be <code>suc</code> something.</p>
<p>Similarly with the third implementation: we have to examine the first argument in its <em>entirety</em> before we wrap the output in a constructor. Yes, we can of course prove that theyâ€™re all equivalent, but remember: proofs are expensive, and weâ€™re looking for speed here. So the first definition of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>+</mo><annotation encoding="application/x-tex">+</annotation></semantics></math> is our best bet, since it tells us the most without having to prove anything.</p>
<p>Looking back at our definition of <code>Inc</code>, we can actually provide more information a little sooner:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">Inc</span> (<span class="ot">ns ::</span> [<span class="dt">N</span>])<span class="ot"> ::</span> [<span class="dt">N</span>] <span class="kw">where</span></a>
<a class="sourceLine" id="cb31-2" data-line-number="2">    <span class="dt">Inc</span> <span class="ch">&#39;[] = &#39;</span>[<span class="dt">Z</span>]</a>
<a class="sourceLine" id="cb31-3" data-line-number="3">    <span class="dt">Inc</span> (<span class="dt">S</span> n <span class="fu">:</span> ns) <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">:</span> n <span class="fu">:</span> ns</a>
<a class="sourceLine" id="cb31-4" data-line-number="4">    <span class="dt">Inc</span> (<span class="dt">Z</span>   <span class="fu">:</span> ns) <span class="fu">=</span> <span class="dt">Carry</span> (<span class="dt">Inc</span> ns)</a></code></pre></div>
<p>In all of the outputs, the list is non-empty. We can encode that, by having two different functions for the head and tail of the list:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">IncHead</span> (<span class="ot">ns ::</span> [<span class="dt">N</span>])<span class="ot"> ::</span> <span class="dt">N</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-2" data-line-number="2">    <span class="dt">IncHead</span> <span class="ch">&#39;[] = Z</span></a>
<a class="sourceLine" id="cb32-3" data-line-number="3">    <span class="dt">IncHead</span> (n <span class="fu">:</span> ns) <span class="fu">=</span> <span class="dt">IncHead&#39;</span> n ns</a>
<a class="sourceLine" id="cb32-4" data-line-number="4"></a>
<a class="sourceLine" id="cb32-5" data-line-number="5"><span class="kw">type</span> family <span class="dt">IncHead&#39;</span> (<span class="ot">n ::</span> <span class="dt">N</span>) (<span class="ot">ns ::</span> [<span class="dt">N</span>])<span class="ot"> ::</span> <span class="dt">N</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-6" data-line-number="6">    <span class="dt">IncHead&#39;</span> (<span class="dt">S</span> n) ns <span class="fu">=</span> <span class="dt">Z</span></a>
<a class="sourceLine" id="cb32-7" data-line-number="7">    <span class="dt">IncHead&#39;</span> <span class="dt">Z</span> ns <span class="fu">=</span> <span class="dt">S</span> (<span class="dt">IncHead</span> ns)</a>
<a class="sourceLine" id="cb32-8" data-line-number="8"></a>
<a class="sourceLine" id="cb32-9" data-line-number="9"><span class="kw">type</span> family <span class="dt">IncTail</span> (<span class="ot">ns ::</span> [<span class="dt">N</span>])<span class="ot"> ::</span> [<span class="dt">N</span>] <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-10" data-line-number="10">    <span class="dt">IncTail</span> <span class="ch">&#39;[] = &#39;</span>[]</a>
<a class="sourceLine" id="cb32-11" data-line-number="11">    <span class="dt">IncTail</span> (n <span class="fu">:</span> ns) <span class="fu">=</span> <span class="dt">IncTail&#39;</span> n ns</a>
<a class="sourceLine" id="cb32-12" data-line-number="12"></a>
<a class="sourceLine" id="cb32-13" data-line-number="13"><span class="kw">type</span> family <span class="dt">IncTail&#39;</span> (<span class="ot">n ::</span> <span class="dt">N</span>) (<span class="ot">ns ::</span> [<span class="dt">N</span>])<span class="ot"> ::</span> [<span class="dt">N</span>] <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-14" data-line-number="14">    <span class="dt">IncTail&#39;</span> (<span class="dt">S</span> n) ns <span class="fu">=</span> n <span class="fu">:</span> ns</a>
<a class="sourceLine" id="cb32-15" data-line-number="15">    <span class="dt">IncTail&#39;</span> <span class="dt">Z</span> ns <span class="fu">=</span> <span class="dt">IncTail</span> ns</a>
<a class="sourceLine" id="cb32-16" data-line-number="16"></a>
<a class="sourceLine" id="cb32-17" data-line-number="17"><span class="kw">type</span> <span class="dt">Inc</span> (<span class="ot">ns ::</span> [<span class="dt">N</span>]) <span class="fu">=</span> <span class="dt">IncHead</span> ns <span class="fu">:</span> <span class="dt">IncTail</span> ns</a></code></pre></div>
<p>This tells the typechecker that weâ€™re not returning an empty sequence right away, so we donâ€™t have to pattern-match to prove it later, giving us a more efficient function.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" data-line-number="1"><span class="ot">cons ::</span> a <span class="ot">-&gt;</span> <span class="dt">Seq</span> ns a <span class="ot">-&gt;</span> <span class="dt">Seq</span> (<span class="dt">Inc</span> ns) a</a>
<a class="sourceLine" id="cb33-2" data-line-number="2">cons x&#39; xs&#39; <span class="fu">=</span> <span class="dt">Cons</span> (go x&#39; xs&#39;)</a>
<a class="sourceLine" id="cb33-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb33-4" data-line-number="4"><span class="ot">    go ::</span> a <span class="ot">-&gt;</span> <span class="dt">Seq</span> ns a <span class="ot">-&gt;</span> <span class="dt">Nest</span> (<span class="dt">IncHead</span> ns) (<span class="dt">IncTail</span> ns) a</a>
<a class="sourceLine" id="cb33-5" data-line-number="5">    go x <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Odd</span> x <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb33-6" data-line-number="6">    go x (<span class="dt">Cons</span> (<span class="dt">Even</span>  xs)) <span class="fu">=</span> <span class="dt">Odd</span> x (<span class="dt">Cons</span> xs)</a>
<a class="sourceLine" id="cb33-7" data-line-number="7">    go x (<span class="dt">Cons</span> (<span class="dt">Odd</span> y ys)) <span class="fu">=</span> <span class="dt">Even</span> (go (x,y) ys)</a></code></pre></div>
<h1 id="technique-5-lazy-proofs">Technique 5: Lazy Proofs</h1>
<p>Briefly after introducing the binary random-access list, Okasaki describes the <em>skew-binary</em> random-access list. As well as having the same indexing cost as the type above, it supports <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math> <code>cons</code>. But waitâ€”didnâ€™t the previous structure have <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math> <code>cons</code>? Not really. Unfortunately, in a pure functional setting, imperative-style amortization measurements arenâ€™t always valid. Say we perform a <code>cons</code> in the worst case, and it takes <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>log</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\log n</annotation></semantics></math> time. In an imperative setting, thatâ€™s no problem, because all of the rest of the operations are not going to be on the worst-case. In a pure setting, though, the old structure is still sitting around. You can still access it, and you can still get that awful worst-case time.</p>
<p>This is where the skew binary tree comes in. Itâ€™s based on the <a href="https://en.wikipedia.org/wiki/Skew_binary_number_system">skew binary numbers</a>: these work similarly to binary, but youâ€™re allowed have (at most) a single 2 digit before any ones. This gives you <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math> incrementing and decrementing, which is what we need here. Letâ€™s get started.</p>
<p>First, our type-level numbers. Weâ€™re going to use the sparse encoding as above, but we need some way to encode â€œyouâ€™re only allowed one 2â€. The most lightweight way to do it I can think of is by implicitly assuming the second number in the list of gaps is one less than the others. In other words, we encode a 2 with <code>[n, 0, m]</code>. That <code>0</code> means that at position <code>n</code> thereâ€™s a 2, not a 1.</p>
<p>The corresponding type families for increment and decrement are clearly <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math>:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">Inc</span> (<span class="ot">ns ::</span> [<span class="dt">N</span>]) <span class="fu">=</span> (<span class="ot">ms ::</span> [<span class="dt">N</span>]) <span class="fu">|</span> ms <span class="ot">-&gt;</span> ns <span class="kw">where</span></a>
<a class="sourceLine" id="cb34-2" data-line-number="2">    <span class="dt">Inc</span> <span class="ch">&#39;[]              = Z   : &#39;</span>[]</a>
<a class="sourceLine" id="cb34-3" data-line-number="3">    <span class="dt">Inc</span> (x  <span class="fu">:</span> <span class="ch">&#39;[])       = Z   : x  : &#39;</span>[]</a>
<a class="sourceLine" id="cb34-4" data-line-number="4">    <span class="dt">Inc</span> (x  <span class="fu">:</span> <span class="dt">Z</span>    <span class="fu">:</span> xs) <span class="fu">=</span> <span class="dt">S</span> x <span class="fu">:</span> xs</a>
<a class="sourceLine" id="cb34-5" data-line-number="5">    <span class="dt">Inc</span> (x1 <span class="fu">:</span> <span class="dt">S</span> x2 <span class="fu">:</span> xs) <span class="fu">=</span> <span class="dt">Z</span>   <span class="fu">:</span> x1 <span class="fu">:</span> x2 <span class="fu">:</span> xs</a>
<a class="sourceLine" id="cb34-6" data-line-number="6"></a>
<a class="sourceLine" id="cb34-7" data-line-number="7"><span class="kw">type</span> family <span class="dt">Dec</span> (<span class="ot">n ::</span> <span class="dt">N</span>) (<span class="ot">ns ::</span> [<span class="dt">N</span>]) <span class="fu">=</span> (<span class="ot">ms ::</span> [<span class="dt">N</span>]) <span class="fu">|</span> ms <span class="ot">-&gt;</span> n ns <span class="kw">where</span></a>
<a class="sourceLine" id="cb34-8" data-line-number="8">    <span class="dt">Dec</span> (<span class="dt">S</span> x)  xs            <span class="fu">=</span> x  <span class="fu">:</span> <span class="dt">Z</span> <span class="fu">:</span> xs</a>
<a class="sourceLine" id="cb34-9" data-line-number="9">    <span class="dt">Dec</span> <span class="dt">Z</span>     <span class="ch">&#39;[]            = &#39;</span>[]</a>
<a class="sourceLine" id="cb34-10" data-line-number="10">    <span class="dt">Dec</span> <span class="dt">Z</span>     (x  <span class="fu">:</span> <span class="ch">&#39;[])     = x  : &#39;</span>[]</a>
<a class="sourceLine" id="cb34-11" data-line-number="11">    <span class="dt">Dec</span> <span class="dt">Z</span>     (x1 <span class="fu">:</span> x2 <span class="fu">:</span> xs) <span class="fu">=</span> x1 <span class="fu">:</span> <span class="dt">S</span> x2 <span class="fu">:</span> xs</a></code></pre></div>
<p>We donâ€™t need to split this into head and tail families as we did before because thereâ€™s no recursive call: we know all weâ€™re ever going to know about the output following <em>any</em> match on the input.</p>
<p>Thereâ€™s another problem before we write the implementation: we canâ€™t use the <code>Nest</code> construction that we had before, because then the head would be buried in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>log</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\log n</annotation></semantics></math> constructors (or thereabouts). Instead, weâ€™re going to have to use GADTs to encode the â€œgapâ€ type, alongside the relevant tree. This gap type is going to be very similar to the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>â‰¥</mo><annotation encoding="application/x-tex">\geq</annotation></semantics></math> proof we had for the modular counters, but with an extra parameter:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb35-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Gap</span> (<span class="ot">n ::</span> <span class="dt">N</span>) (<span class="ot">g ::</span> <span class="dt">N</span>) (<span class="ot">m ::</span> <span class="dt">N</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb35-2" data-line-number="2">    <span class="dt">Zy</span><span class="ot"> ::</span> <span class="dt">Gap</span> n <span class="dt">Z</span> n</a>
<a class="sourceLine" id="cb35-3" data-line-number="3">    <span class="dt">Sy</span><span class="ot"> ::</span> <span class="dt">Gap</span> n g m <span class="ot">-&gt;</span> <span class="dt">Gap</span> n (<span class="dt">S</span> g) (<span class="dt">S</span> m)</a></code></pre></div>
<p><code>Gap n g m</code> means there is a gap of <code>g</code> between <code>n</code> and <code>m</code>. Or, stated another way, it means <code>n + g = m</code>. Its inductive structure mimics the <code>g</code> parameter (itâ€™s basically the <code>g</code> parameter itself with some added information).</p>
<p>With all of that together, hereâ€™s the definition of the array itself:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">Tree</span> (<span class="ot">n ::</span> <span class="dt">N</span>) (<span class="ot">a ::</span> <span class="dt">Type</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb36-2" data-line-number="2">    <span class="dt">Tree</span> <span class="dt">Z</span> a <span class="fu">=</span> a</a>
<a class="sourceLine" id="cb36-3" data-line-number="3">    <span class="dt">Tree</span> (<span class="dt">S</span> n) a <span class="fu">=</span> <span class="dt">Node</span> n a</a>
<a class="sourceLine" id="cb36-4" data-line-number="4"></a>
<a class="sourceLine" id="cb36-5" data-line-number="5"><span class="kw">data</span> <span class="dt">Node</span> n a <span class="fu">=</span> <span class="dt">Node</span> a (<span class="dt">Tree</span> n a) (<span class="dt">Tree</span> n a)</a>
<a class="sourceLine" id="cb36-6" data-line-number="6"></a>
<a class="sourceLine" id="cb36-7" data-line-number="7"><span class="kw">data</span> <span class="dt">SeqTail</span> (<span class="ot">n ::</span> <span class="dt">N</span>) (<span class="ot">ns ::</span> [<span class="dt">N</span>]) (<span class="ot">a ::</span> <span class="dt">Type</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb36-8" data-line-number="8">    <span class="dt">NilT</span><span class="ot">  ::</span> <span class="dt">SeqTail</span> n <span class="ch">&#39;[] a</span></a>
<a class="sourceLine" id="cb36-9" data-line-number="9">    <span class="dt">ConsT</span><span class="ot"> ::</span> <span class="dt">Gap</span> n g m</a>
<a class="sourceLine" id="cb36-10" data-line-number="10">          <span class="ot">-&gt;</span> <span class="dt">Tree</span> m a</a>
<a class="sourceLine" id="cb36-11" data-line-number="11">          <span class="ot">-&gt;</span> <span class="dt">SeqTail</span> (<span class="dt">S</span> m) ms a</a>
<a class="sourceLine" id="cb36-12" data-line-number="12">          <span class="ot">-&gt;</span> <span class="dt">SeqTail</span> n (g <span class="fu">:</span> ms) a</a>
<a class="sourceLine" id="cb36-13" data-line-number="13"></a>
<a class="sourceLine" id="cb36-14" data-line-number="14"><span class="kw">data</span> <span class="dt">Seq</span> (<span class="ot">ns ::</span> [<span class="dt">N</span>]) (<span class="ot">a ::</span> <span class="dt">Type</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb36-15" data-line-number="15">    <span class="dt">Nil</span><span class="ot">  ::</span> <span class="dt">Seq</span> <span class="ch">&#39;[] a</span></a>
<a class="sourceLine" id="cb36-16" data-line-number="16">    <span class="dt">Cons</span><span class="ot"> ::</span> <span class="dt">Gap</span> <span class="dt">Z</span> g n</a>
<a class="sourceLine" id="cb36-17" data-line-number="17">         <span class="ot">-&gt;</span> <span class="dt">Tree</span> n a</a>
<a class="sourceLine" id="cb36-18" data-line-number="18">         <span class="ot">-&gt;</span> <span class="dt">SeqTail</span> n ns a</a>
<a class="sourceLine" id="cb36-19" data-line-number="19">         <span class="ot">-&gt;</span> <span class="dt">Seq</span> (g <span class="fu">:</span> ns) a</a></code></pre></div>
<p>The <code>cons</code> operation again mimics the increment function, but thereâ€™s one final snag before itâ€™ll typecheck:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb37-1" data-line-number="1"><span class="ot">cons ::</span> a <span class="ot">-&gt;</span> <span class="dt">Seq</span> ns a <span class="ot">-&gt;</span> <span class="dt">Seq</span> (<span class="dt">Inc</span> ns) a</a>
<a class="sourceLine" id="cb37-2" data-line-number="2">cons x <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Cons</span> <span class="dt">Zy</span> x <span class="dt">NilT</span></a>
<a class="sourceLine" id="cb37-3" data-line-number="3">cons x (<span class="dt">Cons</span> zn y <span class="dt">NilT</span>) <span class="fu">=</span> <span class="dt">Cons</span> <span class="dt">Zy</span> x (<span class="dt">ConsT</span> zn y <span class="dt">NilT</span>)</a>
<a class="sourceLine" id="cb37-4" data-line-number="4">cons x (<span class="dt">Cons</span> zn y1 (<span class="dt">ConsT</span> <span class="dt">Zy</span> y2 ys)) <span class="fu">=</span> <span class="dt">Cons</span>(<span class="dt">Sy</span> zn) (<span class="dt">Node</span> x y1 y2) ys</a>
<a class="sourceLine" id="cb37-5" data-line-number="5">cons x (<span class="dt">Cons</span> zn y1 (<span class="dt">ConsT</span> (<span class="dt">Sy</span> nm) y2 ys)) <span class="fu">=</span></a>
<a class="sourceLine" id="cb37-6" data-line-number="6">    <span class="dt">Cons</span> <span class="dt">Zy</span> x (<span class="dt">ConsT</span> zn y1 (<span class="dt">ConsT</span> <span class="fu">???</span> y2 ys))</a></code></pre></div>
<p>On the final line, the <code>???</code> is missing. In the unverified version, <code>nm</code> would slot right in there. Here, though, if we try it we get an error, which basically amounts to:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb38-1" data-line-number="1"><span class="dt">Gap</span> n g m <span class="fu">/=</span> <span class="dt">Gap</span> (<span class="dt">S</span> n) g (<span class="dt">S</span> m)</a></code></pre></div>
<p>At this point, Iâ€™d usually throw out the inductive-style proof, and replace it with a proof of equality, which Iâ€™d aggressively erase in all of the functions. I said at the beginning I wouldnâ€™t cheat, though, so hereâ€™s what Iâ€™ll do instead:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb39-1" data-line-number="1"><span class="ot">gapr ::</span> <span class="dt">Gap</span> n g m <span class="ot">-&gt;</span> <span class="dt">Gap</span> (<span class="dt">S</span> n) g (<span class="dt">S</span> m)</a>
<a class="sourceLine" id="cb39-2" data-line-number="2">gapr <span class="dt">Zy</span>       <span class="fu">=</span> <span class="dt">Zy</span></a>
<a class="sourceLine" id="cb39-3" data-line-number="3">gapr (<span class="dt">Sy</span> pnm) <span class="fu">=</span> <span class="dt">Sy</span> (gapr pnm)</a>
<a class="sourceLine" id="cb39-4" data-line-number="4"></a>
<a class="sourceLine" id="cb39-5" data-line-number="5"><span class="ot">cons ::</span> a <span class="ot">-&gt;</span> <span class="dt">Seq</span> ns a <span class="ot">-&gt;</span> <span class="dt">Seq</span> (<span class="dt">Inc</span> ns) a</a>
<a class="sourceLine" id="cb39-6" data-line-number="6">cons x <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Cons</span> <span class="dt">Zy</span> x <span class="dt">NilT</span></a>
<a class="sourceLine" id="cb39-7" data-line-number="7">cons x (<span class="dt">Cons</span> zn y <span class="dt">NilT</span>) <span class="fu">=</span> <span class="dt">Cons</span> <span class="dt">Zy</span> x (<span class="dt">ConsT</span> zn y <span class="dt">NilT</span>)</a>
<a class="sourceLine" id="cb39-8" data-line-number="8">cons x (<span class="dt">Cons</span> zn y1 (<span class="dt">ConsT</span> <span class="dt">Zy</span> y2 ys)) <span class="fu">=</span> <span class="dt">Cons</span> (<span class="dt">Sy</span> zn) (<span class="dt">Node</span> x y1 y2) ys</a>
<a class="sourceLine" id="cb39-9" data-line-number="9">cons x (<span class="dt">Cons</span> zn y1 (<span class="dt">ConsT</span> (<span class="dt">Sy</span> nm) y2 ys)) <span class="fu">=</span></a>
<a class="sourceLine" id="cb39-10" data-line-number="10">    <span class="dt">Cons</span> <span class="dt">Zy</span> x (<span class="dt">ConsT</span> zn y1 (<span class="dt">ConsT</span> (gapr nm) y2 ys))</a></code></pre></div>
<p>At first glance, weâ€™ve lost the complexity bounds. That <code>gapr</code> operation is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>log</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\log n</annotation></semantics></math> (or something), and weâ€™re performing it pretty frequently. We might keep the amortized bounds, but isnâ€™t that not really worthy in a pure setting?</p>
<p>That would all be true, if it werenâ€™t for laziness. Because we <em>delay</em> the evaluation of <code>gapr</code>, we wonâ€™t have to pay for it all in one big thunk. In fact, because itâ€™s basically a unary number, we only have to pay for one part of it at a time. I havenâ€™t yet fully worked out the proofs, but Iâ€™m pretty sure weâ€™re guaranteed <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math> worst-case time here too.</p>
<h1 id="technique-6-when-all-else-fails-prove-it-later">Technique 6: When All Else Fails, Prove it Later</h1>
<p>About a year ago, I <a href="/posts/2017-04-23-verifying-data-structures-in-haskell-lhs.html">tried</a> to write a verified version of binomial heaps, which could then be used for sorting traversable containers. Unfortunately, I couldnâ€™t figure out how to write delete-min, and gave up. I <em>did</em> recognize that the redundancy of the binary representation was a problem, but I couldnâ€™t figure out much more than that.</p>
<p>Now, though, we have a new non-redundant representation of binary numbers, and some handy techniques to go along with it.</p>
<p>Unfortunately, I ran into a similar roadblock in the implementation. Hereâ€™s the point where I was stuck:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb40-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Zipper</span> a n xs <span class="fu">=</span> <span class="dt">Zipper</span> a (<span class="dt">Node</span> n a) (<span class="dt">Binomial</span> n xs a)</a>
<a class="sourceLine" id="cb40-2" data-line-number="2"></a>
<a class="sourceLine" id="cb40-3" data-line-number="3"><span class="ot">slideLeft ::</span> <span class="dt">Zipper</span> a (<span class="dt">S</span> n) xs <span class="ot">-&gt;</span> <span class="dt">Zipper</span> a n (<span class="dt">Z</span> <span class="fu">:</span> xs)</a>
<a class="sourceLine" id="cb40-4" data-line-number="4">slideLeft (<span class="dt">Zipper</span> m (t <span class="fu">:&lt;</span> ts) hs) <span class="fu">=</span> <span class="dt">Zipper</span> m ts (<span class="dt">Cons</span> (<span class="dt">Odd</span> t hs))</a>
<a class="sourceLine" id="cb40-5" data-line-number="5"></a>
<a class="sourceLine" id="cb40-6" data-line-number="6"><span class="ot">minView ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Binomial</span> n (x <span class="fu">:</span> xs) a <span class="ot">-&gt;</span> (a, <span class="dt">Binomial</span> n (<span class="dt">Decr</span> x xs) a)</a>
<a class="sourceLine" id="cb40-7" data-line-number="7">minView (<span class="dt">Cons</span> xs&#39;) <span class="fu">=</span> unZipper (go xs&#39;)</a>
<a class="sourceLine" id="cb40-8" data-line-number="8">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb40-9" data-line-number="9">    unZipper (<span class="dt">Zipper</span> x _ xs) <span class="fu">=</span> (x, xs)</a>
<a class="sourceLine" id="cb40-10" data-line-number="10"></a>
<a class="sourceLine" id="cb40-11" data-line-number="11"><span class="ot">    go ::</span> forall a n x xs<span class="fu">.</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Nest</span> n x xs a <span class="ot">-&gt;</span> <span class="dt">Zipper</span> a n (<span class="dt">Decr</span> x xs)</a>
<a class="sourceLine" id="cb40-12" data-line-number="12">    go (<span class="dt">Even</span> xs) <span class="fu">=</span> slideLeft (go xs)</a>
<a class="sourceLine" id="cb40-13" data-line-number="13">    go (<span class="dt">Odd</span> (<span class="dt">Root</span> x ts) <span class="dt">Empty</span>) <span class="fu">=</span> <span class="dt">Zipper</span> x ts <span class="dt">Empty</span></a>
<a class="sourceLine" id="cb40-14" data-line-number="14">    go (<span class="dt">Odd</span> c<span class="fu">@</span>(<span class="dt">Root</span> x ts) (<span class="dt">Cons</span> xs)) <span class="fu">=</span></a>
<a class="sourceLine" id="cb40-15" data-line-number="15">        <span class="kw">case</span> go xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb40-16" data-line-number="16">            (<span class="dt">Zipper</span> m (t&#39; <span class="fu">:&lt;</span> _) hs)</a>
<a class="sourceLine" id="cb40-17" data-line-number="17">              <span class="fu">|</span> m <span class="fu">&gt;=</span> x <span class="ot">-&gt;</span> <span class="dt">Zipper</span> x ts (<span class="dt">Cons</span> (<span class="dt">Even</span> xs))</a>
<a class="sourceLine" id="cb40-18" data-line-number="18">              <span class="fu">|</span> otherwise <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb40-19" data-line-number="19">                  <span class="dt">Zipper</span> m ts</a>
<a class="sourceLine" id="cb40-20" data-line-number="20">                      (<span class="kw">case</span> hs <span class="kw">of</span></a>
<a class="sourceLine" id="cb40-21" data-line-number="21">                           <span class="dt">Empty</span> <span class="ot">-&gt;</span> <span class="dt">Cons</span> (<span class="dt">Even</span> (<span class="dt">Odd</span> (mergeTree c t&#39;) <span class="dt">Empty</span>))</a>
<a class="sourceLine" id="cb40-22" data-line-number="22">                           <span class="dt">Cons</span> hs&#39; <span class="ot">-&gt;</span> <span class="dt">Cons</span> (<span class="dt">Even</span> (carryOneNest (mergeTree c t&#39;) hs&#39;)))</a></code></pre></div>
<p>The last two lines donâ€™t typecheck! The errors were complex, but effectively they stated:</p>
<blockquote>
<p><code>Could not deduce</code></p>
<blockquote>
<p><code class="sourceCode haskell">x <span class="fu">:</span> xs <span class="fu">~</span> [<span class="dt">Z</span>]</code></p>
</blockquote>
<p><code>from the context</code></p>
<blockquote>
<p><code class="sourceCode haskell"><span class="dt">Decr</span> x xs <span class="fu">~</span> []</code></p>
</blockquote>
</blockquote>
<p>and:</p>
<blockquote>
<p><code>Could not deduce</code></p>
<blockquote>
<p><code class="sourceCode haskell">x <span class="fu">:</span> xs <span class="fu">~</span> <span class="dt">Inc</span> (y <span class="fu">:</span> ys)</code></p>
</blockquote>
<p><code>from the context</code></p>
<blockquote>
<p><code class="sourceCode haskell"><span class="dt">Decr</span> x xs <span class="fu">~</span> y <span class="fu">:</span> ys</code></p>
</blockquote>
</blockquote>
<p>The thing is, all of those look pretty provable. So, for this technique, we first figure out what proofs we need, and <em>assume</em> we have them. This means changing <code>minView</code> to the following:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb41-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Zipper</span> a n xs <span class="fu">=</span> <span class="dt">Zipper</span> a (<span class="dt">Node</span> n a) (<span class="dt">Binomial</span> n xs a)</a>
<a class="sourceLine" id="cb41-2" data-line-number="2"></a>
<a class="sourceLine" id="cb41-3" data-line-number="3"><span class="ot">slideLeft ::</span> <span class="dt">Zipper</span> a (<span class="dt">S</span> n) xs <span class="ot">-&gt;</span> <span class="dt">Zipper</span> a n (<span class="dt">Z</span> <span class="fu">:</span> xs)</a>
<a class="sourceLine" id="cb41-4" data-line-number="4">slideLeft (<span class="dt">Zipper</span> m (t <span class="fu">:&lt;</span> ts) hs) <span class="fu">=</span> <span class="dt">Zipper</span> m ts (<span class="dt">Cons</span> (<span class="dt">Odd</span> t hs))</a>
<a class="sourceLine" id="cb41-5" data-line-number="5"></a>
<a class="sourceLine" id="cb41-6" data-line-number="6"><span class="ot">minView ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Binomial</span> n (x <span class="fu">:</span> xs) a <span class="ot">-&gt;</span> (a, <span class="dt">Binomial</span> n (<span class="dt">Decr</span> x xs) a)</a>
<a class="sourceLine" id="cb41-7" data-line-number="7">minView (<span class="dt">Cons</span> xs&#39;) <span class="fu">=</span> unZipper (go xs&#39;)</a>
<a class="sourceLine" id="cb41-8" data-line-number="8">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb41-9" data-line-number="9">    unZipper (<span class="dt">Zipper</span> x _ xs) <span class="fu">=</span> (x, xs)</a>
<a class="sourceLine" id="cb41-10" data-line-number="10"></a>
<a class="sourceLine" id="cb41-11" data-line-number="11"><span class="ot">    go ::</span> forall a n x xs<span class="fu">.</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Nest</span> n x xs a <span class="ot">-&gt;</span> <span class="dt">Zipper</span> a n (<span class="dt">Decr</span> x xs)</a>
<a class="sourceLine" id="cb41-12" data-line-number="12">    go (<span class="dt">Even</span> xs) <span class="fu">=</span> slideLeft (go xs)</a>
<a class="sourceLine" id="cb41-13" data-line-number="13">    go (<span class="dt">Odd</span> (<span class="dt">Root</span> x ts) <span class="dt">Empty</span>) <span class="fu">=</span> <span class="dt">Zipper</span> x ts <span class="dt">Empty</span></a>
<a class="sourceLine" id="cb41-14" data-line-number="14">    go (<span class="dt">Odd</span> c<span class="fu">@</span>(<span class="dt">Root</span> x ts) (<span class="dt">Cons</span> xs)) <span class="fu">=</span></a>
<a class="sourceLine" id="cb41-15" data-line-number="15">        <span class="kw">case</span> go xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb41-16" data-line-number="16">            (<span class="dt">Zipper</span> m (t&#39; <span class="fu">:&lt;</span> _) (<span class="ot">hs ::</span> <span class="dt">Binomial</span> (<span class="dt">S</span> n) (<span class="dt">Decr</span> y ys) a))</a>
<a class="sourceLine" id="cb41-17" data-line-number="17">              <span class="fu">|</span> m <span class="fu">&gt;=</span> x <span class="ot">-&gt;</span> <span class="dt">Zipper</span> x ts (<span class="dt">Cons</span> (<span class="dt">Even</span> xs))</a>
<a class="sourceLine" id="cb41-18" data-line-number="18">              <span class="fu">|</span> otherwise <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb41-19" data-line-number="19">                  <span class="dt">Zipper</span> m ts</a>
<a class="sourceLine" id="cb41-20" data-line-number="20">                      (<span class="kw">case</span> hs <span class="kw">of</span></a>
<a class="sourceLine" id="cb41-21" data-line-number="21">                           <span class="dt">Empty</span> <span class="ot">-&gt;</span> gcastWith (lemma1 <span class="fu">@</span>y <span class="fu">@</span>ys <span class="dt">Refl</span>)</a>
<a class="sourceLine" id="cb41-22" data-line-number="22">                               <span class="dt">Cons</span> (<span class="dt">Even</span> (<span class="dt">Odd</span> (mergeTree c t&#39;) <span class="dt">Empty</span>))</a>
<a class="sourceLine" id="cb41-23" data-line-number="23">                           <span class="dt">Cons</span> hs&#39; <span class="ot">-&gt;</span> gcastWith (lemma2 <span class="fu">@</span>y <span class="fu">@</span>ys <span class="dt">Refl</span>)</a>
<a class="sourceLine" id="cb41-24" data-line-number="24">                               <span class="dt">Cons</span> (<span class="dt">Even</span> (carryOneNest (mergeTree c t&#39;) hs&#39;)))</a></code></pre></div>
<p>And writing in the templates for our lemmas:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb42-1" data-line-number="1"><span class="ot">lemma1 ::</span> forall x xs<span class="fu">.</span> <span class="dt">Decr</span> x xs <span class="fu">:~:</span> <span class="ch">&#39;[] -&gt; x : xs :~: Z : &#39;</span>[]</a>
<a class="sourceLine" id="cb42-2" data-line-number="2">lemma1 <span class="fu">=</span> _</a>
<a class="sourceLine" id="cb42-3" data-line-number="3"></a>
<a class="sourceLine" id="cb42-4" data-line-number="4"><span class="ot">lemma2 ::</span> forall x xs y ys<span class="fu">.</span> <span class="dt">Decr</span> x xs <span class="fu">:~:</span> y <span class="fu">:</span> ys <span class="ot">-&gt;</span> x <span class="fu">:</span> xs <span class="fu">:~:</span> <span class="dt">Inc</span> (y <span class="fu">:</span> ys)</a>
<a class="sourceLine" id="cb42-5" data-line-number="5">lemma2 <span class="fu">=</span> _</a></code></pre></div>
<p>We now need to provide the <em>implementations</em> for <code>lemma1</code> and <code>lemma2</code>. With this approach, even if we fail to do the next steps, we can cop out here and sub in <code>unsafeCoerce Refl</code> in place of the two proofs, maintaining the efficiency. We wonâ€™t need to, though!</p>
<p>Unlike in Agda, the types for those proofs wonâ€™t be around at runtime, so we wonâ€™t have anything to pattern match on. Weâ€™ll need to look for things in the surrounding area which could act like singletons for the lemmas.</p>
<p>It turns out that the <code>xs</code> and <code>hs'</code> floating around can do exactly that: they tell us about the type-level <code>y</code> and <code>x</code>. So we just pass them to the lemmas (where theyâ€™re needed). This changes the last 4 lines of <code>minView</code> to:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb43-1" data-line-number="1"><span class="dt">Empty</span> <span class="ot">-&gt;</span> gcastWith (lemma1 <span class="dt">Refl</span> xs)</a>
<a class="sourceLine" id="cb43-2" data-line-number="2">    <span class="dt">Cons</span> (<span class="dt">Even</span> (<span class="dt">Odd</span> (mergeTree c t&#39;) <span class="dt">Empty</span>))</a>
<a class="sourceLine" id="cb43-3" data-line-number="3"><span class="dt">Cons</span> hs&#39; <span class="ot">-&gt;</span> gcastWith (lemma2 <span class="dt">Refl</span> xs hs&#39;)</a>
<a class="sourceLine" id="cb43-4" data-line-number="4">    <span class="dt">Cons</span> (<span class="dt">Even</span> (carryOneNest (mergeTree c t&#39;) hs&#39;))</a></code></pre></div>
<p>Now, we just have to fill in the lemmas! If we were lucky, theyâ€™d actually be constant-time.</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb44-1" data-line-number="1"><span class="ot">lemma1 ::</span> forall x xs n a<span class="fu">.</span> <span class="dt">Decr</span> x xs <span class="fu">:~:</span> <span class="ch">&#39;[]</span></a>
<a class="sourceLine" id="cb44-2" data-line-number="2">       <span class="ot">-&gt;</span>  <span class="dt">Nest</span> n x xs a</a>
<a class="sourceLine" id="cb44-3" data-line-number="3">       <span class="ot">-&gt;</span> x <span class="fu">:</span> xs <span class="fu">:~:</span> <span class="dt">Z</span> <span class="fu">:</span> <span class="ch">&#39;[]</span></a>
<a class="sourceLine" id="cb44-4" data-line-number="4">lemma1 <span class="dt">Refl</span> (<span class="dt">Odd</span> _ <span class="dt">Empty</span>) <span class="fu">=</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb44-5" data-line-number="5"></a>
<a class="sourceLine" id="cb44-6" data-line-number="6"><span class="ot">lemma2 ::</span> forall x xs y ys n a<span class="fu">.</span></a>
<a class="sourceLine" id="cb44-7" data-line-number="7">          <span class="dt">Decr</span> x xs <span class="fu">:~:</span> y <span class="fu">:</span> ys</a>
<a class="sourceLine" id="cb44-8" data-line-number="8">       <span class="ot">-&gt;</span> <span class="dt">Nest</span> n x xs a</a>
<a class="sourceLine" id="cb44-9" data-line-number="9">       <span class="ot">-&gt;</span> <span class="dt">Nest</span> n y ys a</a>
<a class="sourceLine" id="cb44-10" data-line-number="10">       <span class="ot">-&gt;</span> x <span class="fu">:</span> xs <span class="fu">:~:</span> <span class="dt">Inc</span> (y <span class="fu">:</span> ys)</a>
<a class="sourceLine" id="cb44-11" data-line-number="11">lemma2 <span class="dt">Refl</span> (<span class="dt">Even</span> (<span class="dt">Odd</span> _ <span class="dt">Empty</span>)) (<span class="dt">Odd</span> _ <span class="dt">Empty</span>) <span class="fu">=</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb44-12" data-line-number="12">lemma2 <span class="dt">Refl</span> (<span class="dt">Odd</span> _ (<span class="dt">Cons</span> _)) (<span class="dt">Even</span> _) <span class="fu">=</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb44-13" data-line-number="13">lemma2 <span class="dt">Refl</span> (<span class="dt">Even</span> xs) (<span class="dt">Odd</span> _ (<span class="dt">Cons</span> ys)) <span class="fu">=</span></a>
<a class="sourceLine" id="cb44-14" data-line-number="14">  gcastWith (lemma2 <span class="dt">Refl</span> xs ys) <span class="dt">Refl</span></a></code></pre></div>
<p>If they <em>had</em> been constant-time, that would have let us throw them out: each proof would essentially show you what cases needed to be scrutinized to satisfy the typechecker. You then just scrutinize those cases in the actual function, and it should all typecheck.</p>
<p>As it is, <code>lemma2</code> is actually ok. It does cost <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math>, but so does <code>carryOneNest</code>: weâ€™ve maintained the complexity! We <em>could</em> stop here, satisfied.</p>
<p>Thereâ€™s another option, though, one that I picked up from Stephanie Weirichâ€™s talk <span class="citation" data-cites="weirich_dependent_2017">(<a href="#ref-weirich_dependent_2017">2017</a>)</span>: you thread the requirement through the function as an equality constraint. It wonâ€™t always work, but when your functionâ€™s call graph matches that of the proof, the constraint will indeed be satisfied, with no runtime cost. In this case, we can whittle down the proof obligation to the following:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb45-1" data-line-number="1"><span class="dt">Inc</span> (<span class="dt">Decr</span> x xs) <span class="fu">~</span> (x <span class="fu">:</span> xs)</a></code></pre></div>
<p>Now we change the recursive <code>go</code> into continuation-passing style, and add that constraint to its signature, and everything works!</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb46-1" data-line-number="1"><span class="ot">minView ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Binomial</span> n (x <span class="fu">:</span> xs) a <span class="ot">-&gt;</span> (a, <span class="dt">Binomial</span> n (<span class="dt">Decr</span> x xs) a)</a>
<a class="sourceLine" id="cb46-2" data-line-number="2">minView (<span class="dt">Cons</span> xs&#39;) <span class="fu">=</span> go xs&#39; \(<span class="dt">Zipper</span> x _ xs) <span class="ot">-&gt;</span> (x,xs)</a>
<a class="sourceLine" id="cb46-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb46-4" data-line-number="4"><span class="ot">    go ::</span> <span class="dt">Ord</span> a</a>
<a class="sourceLine" id="cb46-5" data-line-number="5">       <span class="ot">=&gt;</span> <span class="dt">Nest</span> n x xs a</a>
<a class="sourceLine" id="cb46-6" data-line-number="6">       <span class="ot">-&gt;</span> (<span class="dt">Inc</span> (<span class="dt">Decr</span> x xs) <span class="fu">~</span> (x <span class="fu">:</span> xs) <span class="ot">=&gt;</span> <span class="dt">Zipper</span> a n (<span class="dt">Decr</span> x xs) <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb46-7" data-line-number="7">    go (<span class="dt">Even</span> xs) k <span class="fu">=</span> go xs \(<span class="dt">Zipper</span> m (t <span class="fu">:&lt;</span> ts) hs) <span class="ot">-&gt;</span> k (<span class="dt">Zipper</span> m ts (<span class="dt">Cons</span> (<span class="dt">Odd</span> t hs)))</a>
<a class="sourceLine" id="cb46-8" data-line-number="8">    go (<span class="dt">Odd</span> (<span class="dt">Root</span> x ts) <span class="dt">Empty</span>) k <span class="fu">=</span> k (<span class="dt">Zipper</span> x ts <span class="dt">Empty</span>)</a>
<a class="sourceLine" id="cb46-9" data-line-number="9">    go (<span class="dt">Odd</span> c<span class="fu">@</span>(<span class="dt">Root</span> x cs) (<span class="dt">Cons</span> xs)) k <span class="fu">=</span></a>
<a class="sourceLine" id="cb46-10" data-line-number="10">        go xs</a>
<a class="sourceLine" id="cb46-11" data-line-number="11">            \<span class="kw">case</span></a>
<a class="sourceLine" id="cb46-12" data-line-number="12">                <span class="dt">Zipper</span> m _ _ <span class="fu">|</span> m <span class="fu">&gt;=</span> x <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb46-13" data-line-number="13">                    k (<span class="dt">Zipper</span> x cs (<span class="dt">Cons</span> (<span class="dt">Even</span> xs)))</a>
<a class="sourceLine" id="cb46-14" data-line-number="14">                <span class="dt">Zipper</span> m (t <span class="fu">:&lt;</span> ts) <span class="dt">Empty</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb46-15" data-line-number="15">                    k (<span class="dt">Zipper</span> m ts (<span class="dt">Cons</span> (<span class="dt">Even</span> (<span class="dt">Odd</span> (mergeTree c t) <span class="dt">Empty</span>))))</a>
<a class="sourceLine" id="cb46-16" data-line-number="16">                <span class="dt">Zipper</span> m (t <span class="fu">:&lt;</span> ts) (<span class="dt">Cons</span> hs) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb46-17" data-line-number="17">                    k (<span class="dt">Zipper</span> m ts (<span class="dt">Cons</span> (<span class="dt">Even</span> (carryOneNest (mergeTree c t) hs))))</a></code></pre></div>
<h1 id="conclusion">Conclusion</h1>
<p>As I mentioned in the beginning, a huge amount of this stuff is <em>much</em> easier using other systems. On top of that, thereâ€™s currently a lot of work being done on dependent type erasure, so that proofs like the above donâ€™t even exist at runtime. In other words, thereâ€™s a chance that all of these techniques will soon be useless!</p>
<p>Efficient proof-carrying code makes for an interesting puzzle, though, even if it is a bit of a hair shirt.</p>
<h1 id="code">Code</h1>
<p>Fuller implementations of the structures here are in <a href="https://github.com/oisdk/pure-arrays">this</a> git repository.</p>
<h1 id="references" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-bakst_liquidhaskell_2018">
<p>Bakst, Alexander, Ranjit Jhala, Ming Kawaguchi, Patrick Rondon, Eric Seidel, Michael Smith, Anish Tondwalkar, Chris Tetreault, and Niki Vazou. 2018. â€œLiquidHaskell: Liquid Types For Haskell.â€ ucsd-progsys. <a href="https://github.com/ucsd-progsys/liquidhaskell" class="uri">https://github.com/ucsd-progsys/liquidhaskell</a>.</p>
</div>
<div id="ref-ben-amram_pointers_1992">
<p>Ben-Amram, Amir M., and Zvi Galil. 1992. â€œOn Pointers Versus Addresses.â€ <em>J. ACM</em> 39 (3) (July): 617â€“648. doi:<a href="https://doi.org/10.1145/146637.146666">10.1145/146637.146666</a>. <a href="http://doi.acm.org/10.1145/146637.146666" class="uri">http://doi.acm.org/10.1145/146637.146666</a>.</p>
</div>
<div id="ref-breitner_ready_2018-1">
<p>Breitner, Joachim, Antal Spector-Zabusky, Yao Li, Christine Rizkallah, John Wiegley, and Stephanie Weirich. 2018. â€œReady, Set, Verify! Applying Hs-to-coq to Real-world Haskell Code (Experience Report).â€ <em>Proc. ACM Program. Lang.</em> 2 (ICFP) (July): 89:1â€“89:16. doi:<a href="https://doi.org/10.1145/3236784">10.1145/3236784</a>. <a href="http://doi.acm.org/10.1145/3236784" class="uri">http://doi.acm.org/10.1145/3236784</a>.</p>
</div>
<div id="ref-hinze_numerical_1998">
<p>Hinze, Ralf. 1998. <em>Numerical Representations as Higher-Order Nested Datatypes</em>. Institut fÃ¼r Informatik III, UniversitÃ¤t Bonn. <a href="http://www.cs.ox.ac.uk/ralf.hinze/publications/\#R5" class="uri">http://www.cs.ox.ac.uk/ralf.hinze/publications/\#R5</a>.</p>
</div>
<div id="ref-hinze_perfect_1999">
<p>â€”â€”â€”. 1999. <em>Perfect Trees and Bit-reversal Permutations</em>.</p>
</div>
<div id="ref-komuves_nested-sequence_2016">
<p>Komuves, Balazs, and Peter Divianszky. 2016. â€œNested-sequence: List-like data structures with O(Log(n)) random access.â€ <a href="http://hackage.haskell.org/package/nested-sequence" class="uri">http://hackage.haskell.org/package/nested-sequence</a>.</p>
</div>
<div id="ref-mcbride_how_2014">
<p>McBride, Conor Thomas. 2014. â€œHow to Keep Your Neighbours in Order.â€ In <em>Proceedings of the 19th ACM SIGPLAN International Conference on Functional Programming</em>, 297â€“309. ICFP â€™14. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/2628136.2628163">10.1145/2628136.2628163</a>. <a href="https://personal.cis.strath.ac.uk/conor.mcbride/pub/Pivotal.pdf" class="uri">https://personal.cis.strath.ac.uk/conor.mcbride/pub/Pivotal.pdf</a>.</p>
</div>
<div id="ref-might_missing_2015">
<p>Might, Matthew. 2015. â€œMissing method: How to delete from Okasakiâ€™s red-black trees.â€ <em>matt.might.net</em>. <a href="http://matt.might.net/articles/red-black-delete/" class="uri">http://matt.might.net/articles/red-black-delete/</a>.</p>
</div>
<div id="ref-okasaki_fast_1999">
<p>Okasaki, Chris. 1999a. â€œFrom Fast Exponentiation to Square Matrices: An Adventure in Types.â€ In <em>Proceedings of the ACM SIGPLAN International Conference on Functional Programming (ICFPâ€™99), Paris, France, September 27-29, 1999</em>, 34:28. ACM. <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.456.357\&amp;rep=rep1\&amp;type=pdf" class="uri">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.456.357\&amp;rep=rep1\&amp;type=pdf</a>.</p>
</div>
<div id="ref-okasaki_purely_1999">
<p>â€”â€”â€”. 1999b. <em>Purely Functional Data Structures</em>. Cambridge University Press.</p>
</div>
<div id="ref-weirich_depending_2014">
<p>Weirich, Stephanie. 2014. â€œDepending on Types.â€ In <em>Proceedings of the 19th ACM SIGPLAN International Conference on Functional Programming</em>, 241â€“241. ICFP â€™14. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/2628136.2631168">10.1145/2628136.2631168</a>. <a href="https://www.cis.upenn.edu/~sweirich/talks/icfp14.pdf" class="uri">https://www.cis.upenn.edu/~sweirich/talks/icfp14.pdf</a>.</p>
</div>
<div id="ref-weirich_dependent_2017">
<p>â€”â€”â€”. 2017. â€œDependent Types in Haskell.â€ St. Louis, MO, USA. <a href="https://www.youtube.com/watch?v=wNa3MMbhwS4" class="uri">https://www.youtube.com/watch?v=wNa3MMbhwS4</a>.</p>
</div>
</div>
]]></description>
    <pubDate>Tue, 20 Nov 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-11-20-fast-verified-structures.html</guid>
    <dc:creator>Donnacha OisÃ­n Kidney</dc:creator>
</item>
<item>
    <title>A Very Simple Prime Sieve in Haskell</title>
    <link>https://doisinkidney.com/posts/2018-11-10-a-very-simple-prime-sieve.html</link>
    <description><![CDATA[<div class="info">
    Posted on November 10, 2018
</div>
<div class="info">
    
        Part 1 of a <a href="/series/Prime%20Sieves.html">2-part series on Prime Sieves</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<p>A few days ago, the <a href="https://www.youtube.com/user/Computerphile">Computerphile YouTube channel</a> put up a video about infinite lists in Haskell <span class="citation" data-cites="haran_infinity_2018">(Haran <a href="#ref-haran_infinity_2018">2018</a>)</span>. Itâ€™s pretty basic, but finishes up with a definition of an infinite list of prime numbers. The definition was something like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1">primes <span class="fu">=</span> sieve [<span class="dv">2</span><span class="fu">..</span>]</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">sieve (p<span class="fu">:</span>ps) <span class="fu">=</span> p <span class="fu">:</span> sieve [ x <span class="fu">|</span> x <span class="ot">&lt;-</span> ps, mod x p <span class="fu">/=</span> <span class="dv">0</span> ]</a></code></pre></div>
<p>This really demonstrates the elegance of list comprehensions coupled with lazy evaluation. If weâ€™re being totally pedantic, however, this <em>isnâ€™t</em> a genuine <a href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes">sieve of Eratosthenes</a>. And this makes sense: the â€œtrueâ€ sieve of Eratosthenes <span class="citation" data-cites="oneill_genuine_2009">(Oâ€™Neill <a href="#ref-oneill_genuine_2009">2009</a>)</span> is probably too complex to demonstrate in a video meant to be an introduction to Haskell. This isnâ€™t because Haskell is bad at this particular problem, mind you: itâ€™s because a lazy, infinite sieve is something very hard to implement indeed.</p>
<p>Anyway, Iâ€™m going to try today to show a very simple prime sieve that (hopefully) rivals the simplicity of the definition above.</p>
<h1 id="a-first-attempt">A First Attempt</h1>
<p>Visualizations of the sieve of Eratosthenes often rely on metaphors of â€œcrossing outâ€ on some large table. Once you hit a prime, you cross off all of its multiples in the rest of the table, and then you move to the next crossed-off number.</p>
<figure>
<img src="https://upload.wikimedia.org/wikipedia/commons/0/0b/Sieve_of_Eratosthenes_animation.svg" alt="Sieve of Eratosthenes Animation. By Ricordisamoa, CC BY-SA 3.0, from Wikimedia Commons" /><figcaption>Sieve of Eratosthenes Animation. By Ricordisamoa, CC BY-SA 3.0, from Wikimedia Commons</figcaption>
</figure>
<p>Working with a finite array, it should be easy to see that this is extremely efficient. Youâ€™re crossing off every non-prime exactly once, only using addition and squaring.</p>
<p>To extend it to infinite lists, we will use the following function:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1">[] \\ ys <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">xs \\ [] <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">(x<span class="fu">:</span>xs) \\ (y<span class="fu">:</span>ys) <span class="fu">=</span> <span class="kw">case</span> compare x y <span class="kw">of</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">    <span class="dt">LT</span> <span class="ot">-&gt;</span> x <span class="fu">:</span> xs \\ (y<span class="fu">:</span>ys)</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">    <span class="dt">EQ</span> <span class="ot">-&gt;</span> xs \\ ys</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">    <span class="dt">GT</span> <span class="ot">-&gt;</span> (x<span class="fu">:</span>xs) \\ ys</a></code></pre></div>
<p>Weâ€™re â€œsubtractingâ€ the right list from the left. Crucially, it works with infinite lists:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> take <span class="dv">10</span> ([<span class="dv">1</span><span class="fu">..</span>] \\ [<span class="dv">2</span>,<span class="dv">4</span><span class="fu">..</span>])</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">[<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">7</span>,<span class="dv">9</span>,<span class="dv">11</span>,<span class="dv">13</span>,<span class="dv">15</span>,<span class="dv">17</span>,<span class="dv">19</span>]</a></code></pre></div>
<p>Finally, it only works if both lists are ordered and donâ€™t contain duplicates, but our sieve does indeed satisfy that requirement. Using this, weâ€™ve already got a sieve:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">sieve (p<span class="fu">:</span>ps) <span class="fu">=</span> p <span class="fu">:</span> sieve (ps \\ [p<span class="fu">*</span>p, p<span class="fu">*</span>p<span class="fu">+</span>p<span class="fu">..</span>])</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">primes <span class="fu">=</span> <span class="dv">2</span> <span class="fu">:</span> sieve [<span class="dv">3</span>,<span class="dv">5</span><span class="fu">..</span>]</a></code></pre></div>
<p>No division, just addition and squaring, as promised. Unfortunately, though, this doesnâ€™t have the time complexity we want. See, in the <code>(\\)</code> operation, we have to test every entry in the sieve against the prime factor: when weâ€™re crossing off from an array, we just jump to the next composite number.</p>
<h1 id="using-a-queue">Using a Queue</h1>
<p>The way we speed up the â€œcrossing-offâ€ section of the algorithms is by using a priority queue: this was the optimization provided in <span class="citation" data-cites="oneill_genuine_2009">Oâ€™Neill (<a href="#ref-oneill_genuine_2009">2009</a>)</span>. Before we go any further, then, letâ€™s put one together:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:-</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Queue</span> a b <span class="fu">=</span> <span class="dt">Queue</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">    {<span class="ot"> minKey ::</span> <span class="fu">!</span>a</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">    ,<span class="ot"> minVal ::</span> b</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">    ,<span class="ot"> rest   ::</span> <span class="dt">List</span> a b</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">    }</a>
<a class="sourceLine" id="cb5-7" data-line-number="7"></a>
<a class="sourceLine" id="cb5-8" data-line-number="8"><span class="kw">data</span> <span class="dt">List</span> a b</a>
<a class="sourceLine" id="cb5-9" data-line-number="9">    <span class="fu">=</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb5-10" data-line-number="10">    <span class="fu">|</span> (<span class="fu">:-</span>) <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span>(<span class="dt">Queue</span> a b)</a>
<a class="sourceLine" id="cb5-11" data-line-number="11">           (<span class="dt">List</span> a b)</a>
<a class="sourceLine" id="cb5-12" data-line-number="12"></a>
<a class="sourceLine" id="cb5-13" data-line-number="13"></a>
<a class="sourceLine" id="cb5-14" data-line-number="14"><span class="ot">(&lt;+&gt;) ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Queue</span> a b <span class="ot">-&gt;</span> <span class="dt">Queue</span> a b <span class="ot">-&gt;</span> <span class="dt">Queue</span> a b</a>
<a class="sourceLine" id="cb5-15" data-line-number="15">(<span class="fu">&lt;+&gt;</span>) q1<span class="fu">@</span>(<span class="dt">Queue</span> x1 y1 ts1) q2<span class="fu">@</span>(<span class="dt">Queue</span> x2 y2 ts2)</a>
<a class="sourceLine" id="cb5-16" data-line-number="16">  <span class="fu">|</span> x1 <span class="fu">&lt;=</span> x2 <span class="fu">=</span> <span class="dt">Queue</span> x1 y1 (q2 <span class="fu">:-</span> ts1)</a>
<a class="sourceLine" id="cb5-17" data-line-number="17">  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Queue</span> x2 y2 (q1 <span class="fu">:-</span> ts2)</a>
<a class="sourceLine" id="cb5-18" data-line-number="18"></a>
<a class="sourceLine" id="cb5-19" data-line-number="19"><span class="ot">mergeQs ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">List</span> a b <span class="ot">-&gt;</span> <span class="dt">Queue</span> a b</a>
<a class="sourceLine" id="cb5-20" data-line-number="20">mergeQs (t <span class="fu">:-</span> <span class="dt">Nil</span>)        <span class="fu">=</span> t</a>
<a class="sourceLine" id="cb5-21" data-line-number="21">mergeQs (t1 <span class="fu">:-</span> t2 <span class="fu">:-</span> <span class="dt">Nil</span>) <span class="fu">=</span> t1 <span class="fu">&lt;+&gt;</span> t2</a>
<a class="sourceLine" id="cb5-22" data-line-number="22">mergeQs (t1 <span class="fu">:-</span> t2 <span class="fu">:-</span> ts)  <span class="fu">=</span> (t1 <span class="fu">&lt;+&gt;</span> t2) <span class="fu">&lt;+&gt;</span> mergeQs ts</a>
<a class="sourceLine" id="cb5-23" data-line-number="23">mergeQs <span class="dt">Nil</span>               <span class="fu">=</span> errorWithoutStackTrace <span class="st">&quot;tried to merge empty list&quot;</span></a>
<a class="sourceLine" id="cb5-24" data-line-number="24"></a>
<a class="sourceLine" id="cb5-25" data-line-number="25"><span class="ot">insert ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Queue</span> a b <span class="ot">-&gt;</span> <span class="dt">Queue</span> a b</a>
<a class="sourceLine" id="cb5-26" data-line-number="26">insert <span class="fu">!</span>k <span class="fu">!</span>v <span class="fu">=</span> (<span class="fu">&lt;+&gt;</span>) (singleton k v)</a>
<a class="sourceLine" id="cb5-27" data-line-number="27"></a>
<a class="sourceLine" id="cb5-28" data-line-number="28"><span class="ot">singleton ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Queue</span> a b</a>
<a class="sourceLine" id="cb5-29" data-line-number="29">singleton <span class="fu">!</span>k <span class="fu">!</span>v <span class="fu">=</span> <span class="dt">Queue</span> k v <span class="dt">Nil</span></a></code></pre></div>
<p>These are pairing heaps: Iâ€™m using them here because theyâ€™re relatively simple and very fast. A lot of their speed comes from the fact that the top-level constructor (<code>Queue</code>) is <em>non-empty</em>. Since, in this algorithm, weâ€™re only actually going to be working with non-empty queues, this saves us a pattern match on pretty much every function. Theyâ€™re also whatâ€™s used in <a href="https://github.com/haskell/containers/blob/master/Data/Sequence/Internal/sorting.md#sorting">Data.Sequence for sorting</a>.</p>
<p>With that, we can write our proper sieve:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1">insertPrime x xs <span class="fu">=</span> insert (x<span class="fu">*</span>x) (map (<span class="fu">*</span>x) xs)</a>
<a class="sourceLine" id="cb6-2" data-line-number="2"></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">adjust x q<span class="fu">@</span>(<span class="dt">Queue</span> y (z<span class="fu">:</span>zs) qs)</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">  <span class="fu">|</span> y <span class="fu">&lt;=</span> x <span class="fu">=</span> adjust x (insert z zs (mergeQs qs))</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">  <span class="fu">|</span> otherwise <span class="fu">=</span> q</a>
<a class="sourceLine" id="cb6-6" data-line-number="6"></a>
<a class="sourceLine" id="cb6-7" data-line-number="7">sieve (x<span class="fu">:</span>xs) <span class="fu">=</span> x <span class="fu">:</span> sieve&#39; xs (singleton (x<span class="fu">*</span>x) (map (<span class="fu">*</span>x) xs))</a>
<a class="sourceLine" id="cb6-8" data-line-number="8">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-9" data-line-number="9">    sieve&#39; (x<span class="fu">:</span>xs) table</a>
<a class="sourceLine" id="cb6-10" data-line-number="10">      <span class="fu">|</span> minKey table <span class="fu">&lt;=</span> x <span class="fu">=</span> sieve&#39; xs (adjust x table)</a>
<a class="sourceLine" id="cb6-11" data-line-number="11">      <span class="fu">|</span> otherwise <span class="fu">=</span> x <span class="fu">:</span> sieve&#39; xs (insertPrime x xs table)</a>
<a class="sourceLine" id="cb6-12" data-line-number="12">      </a>
<a class="sourceLine" id="cb6-13" data-line-number="13">primes <span class="fu">=</span> <span class="dv">2</span> <span class="fu">:</span> sieve [<span class="dv">3</span>,<span class="dv">5</span><span class="fu">..</span>]</a></code></pre></div>
<h1 id="simplifying">Simplifying</h1>
<p>The priority queue stores lists alongside their keys: what you might notice is that those lists are simply sequences of the type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mi>x</mi><mo>,</mo><mn>2</mn><mi>x</mi><mo>,</mo><mn>3</mn><mi>x</mi><mo>,</mo><mn>4</mn><mi>x</mi><mi>.</mi><mi>.</mi><mi>.</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[x, 2x, 3x, 4x...]</annotation></semantics></math> and so on. Rather than storing the whole list, we can instead store just the head and the step. This also simplifies (and greatly speeds up) the expensive <code>map (*x)</code> operation to just <em>two</em> multiplications. If you wanted, you could just sub in this representation of streams for all the lists above:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Stepper</span> a <span class="fu">=</span> <span class="dt">Stepper</span> {<span class="ot"> start ::</span> a,<span class="ot"> step ::</span> a }</a>
<a class="sourceLine" id="cb7-2" data-line-number="2"></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="ot">nextStep ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Stepper</span> a <span class="ot">-&gt;</span> (a, <span class="dt">Stepper</span> a)</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">nextStep (<span class="dt">Stepper</span> x y) <span class="fu">=</span> (x, <span class="dt">Stepper</span> (x<span class="fu">+</span>y) y)</a>
<a class="sourceLine" id="cb7-5" data-line-number="5"></a>
<a class="sourceLine" id="cb7-6" data-line-number="6">pattern x <span class="fu">:-</span> xs <span class="ot">&lt;-</span> (nextStep <span class="ot">-&gt;</span> (x,xs))</a>
<a class="sourceLine" id="cb7-7" data-line-number="7"></a>
<a class="sourceLine" id="cb7-8" data-line-number="8"><span class="ot">(^*) ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Stepper</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Stepper</span> a</a>
<a class="sourceLine" id="cb7-9" data-line-number="9"><span class="dt">Stepper</span> x y <span class="fu">^*</span> f <span class="fu">=</span> <span class="dt">Stepper</span> (x <span class="fu">*</span> f) (y <span class="fu">*</span> f)</a></code></pre></div>
<p>If you were so inclined, you could even make it conform to <code>Foldable</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Stepper</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">    <span class="dt">Stepper</span><span class="ot"> ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Stepper</span> a</a>
<a class="sourceLine" id="cb8-3" data-line-number="3"></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">nextStep (<span class="dt">Stepper</span> x y) <span class="fu">=</span> (x, <span class="dt">Stepper</span> (x<span class="fu">+</span>y) y)</a>
<a class="sourceLine" id="cb8-5" data-line-number="5"></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">pattern x <span class="fu">:-</span> xs <span class="ot">&lt;-</span> (nextStep <span class="ot">-&gt;</span> (x,xs))</a>
<a class="sourceLine" id="cb8-7" data-line-number="7"></a>
<a class="sourceLine" id="cb8-8" data-line-number="8"><span class="kw">instance</span> <span class="dt">Foldable</span> <span class="dt">Stepper</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-9" data-line-number="9">    foldr f b (x <span class="fu">:-</span> xs) <span class="fu">=</span> f x (foldr f b xs)</a></code></pre></div>
<p>But thatâ€™s overkill for what we need here.</p>
<p>Second observation is that if we remove the wheel (from 2), the â€œstartâ€ is simply the <em>key</em> in the priority queue, again cutting down on space.</p>
<p>Finally, we get the implementation:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1">primes <span class="fu">=</span> <span class="dv">2</span> <span class="fu">:</span> sieve <span class="dv">3</span> (singleton <span class="dv">4</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">    adjust x q<span class="fu">@</span>(<span class="dt">Queue</span> y z qs)</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">        <span class="fu">|</span> x <span class="fu">&lt;</span> y <span class="fu">=</span> q</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">        <span class="fu">|</span> otherwise <span class="fu">=</span> adjust x (insert (y <span class="fu">+</span> z) z (mergeQs qs))</a>
<a class="sourceLine" id="cb9-6" data-line-number="6">    sieve x q</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">        <span class="fu">|</span> x <span class="fu">&lt;</span> minKey q <span class="fu">=</span> x <span class="fu">:</span> sieve (x <span class="fu">+</span> <span class="dv">1</span>) (insert (x <span class="fu">*</span> x) x q)</a>
<a class="sourceLine" id="cb9-8" data-line-number="8">        <span class="fu">|</span> otherwise <span class="fu">=</span> sieve (x <span class="fu">+</span> <span class="dv">1</span>) (adjust x q)</a></code></pre></div>
<p>8 lines for a lazy prime sieve isnâ€™t bad!</p>
<p>I havenâ€™t tried a huge amount to optimize the function, but it might be worth looking in to how to add back the wheels. I noticed that for no wheels, the queue contains only two elements per key; for one (the 2 wheel), we needed 3. I wonder if this pattern continues: possibly we could represent wheels as finite lists at each key in the queue. Maybe in a later post.</p>
<div id="refs" class="references">
<div id="ref-haran_infinity_2018">
<p>Haran, Brady. 2018. â€œTo Infinity &amp; Beyond - Computerphile.â€ <a href="https://www.youtube.com/watch?v=bnRNiE_OVWA\&amp;feature=youtu.be" class="uri">https://www.youtube.com/watch?v=bnRNiE_OVWA\&amp;feature=youtu.be</a>.</p>
</div>
<div id="ref-oneill_genuine_2009">
<p>Oâ€™Neill, Melissa E. 2009. â€œThe Genuine Sieve of Eratosthenes.â€ <em>Journal of Functional Programming</em> 19 (01) (January): 95. doi:<a href="https://doi.org/10.1017/S0956796808007004">10.1017/S0956796808007004</a>. <a href="https://pdfs.semanticscholar.org/b7d6/7986e54f852de25e2d803472f31fb53184d5.pdf" class="uri">https://pdfs.semanticscholar.org/b7d6/7986e54f852de25e2d803472f31fb53184d5.pdf</a>.</p>
</div>
</div>
]]></description>
    <pubDate>Sat, 10 Nov 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-11-10-a-very-simple-prime-sieve.html</guid>
    <dc:creator>Donnacha OisÃ­n Kidney</dc:creator>
</item>
<item>
    <title>Total Combinations</title>
    <link>https://doisinkidney.com/posts/2018-10-16-total-combinations.html</link>
    <description><![CDATA[<div class="info">
    Posted on October 16, 2018
</div>
<div class="info">
    
        Part 1 of a <a href="/series/Total%20Combinatorics.html">1-part series on Total Combinatorics</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Agda.html">Agda</a>, <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<p>Hereâ€™s a quick puzzle: from a finite alphabet, produce an infinite list of infinite strings, each of them unique.</p>
<p>Itâ€™s not a super hard problem, but here are some examples of what you might get. Given the alphabet of <code>0</code> and <code>1</code>, for instance, you could produce the following:</p>
<pre><code>0000000...
1000000...
0100000...
1100000...
0010000...
1010000...
0110000...
1110000...
0001000...</code></pre>
<p>In other words, the enumeration of the binary numbers (least-significant-digit first). Weâ€™ll just deal with bits first:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Bit</span> <span class="fu">=</span> <span class="dt">O</span> <span class="fu">|</span> <span class="dt">I</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Bit</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">    showsPrec _ <span class="dt">O</span> <span class="fu">=</span> (<span class="fu">:</span>) <span class="ch">&#39;0&#39;</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5">    showsPrec _ <span class="dt">I</span> <span class="fu">=</span> (<span class="fu">:</span>) <span class="ch">&#39;1&#39;</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6">    showList xs s <span class="fu">=</span> foldr f s xs</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8">        f <span class="dt">O</span> a <span class="fu">=</span> <span class="ch">&#39;0&#39;</span> <span class="fu">:</span> a</a>
<a class="sourceLine" id="cb2-9" data-line-number="9">        f <span class="dt">I</span> a <span class="fu">=</span> <span class="ch">&#39;1&#39;</span> <span class="fu">:</span> a</a></code></pre></div>
<p>Thinking recursively, we can see that the tail of each list is actually the original sequence, doubled-up:</p>
<p><code class="sourceCode"> 0<span class="er">000000</span>... <br/> 1<span class="er">000000</span>... <br/> 0<span class="er">100000</span>... <br/> 1<span class="er">100000</span>... <br/> 0<span class="er">010000</span>... <br/> 1<span class="er">010000</span>... <br/> 0<span class="er">110000</span>... <br/> 1<span class="er">110000</span>... <br/> 0<span class="er">001000</span>... <br/> </code></p>
<p>As it happens, we get something like this pattern with the monad instance for lists <em>anyway</em>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> (,) <span class="fu">&lt;$&gt;</span> [<span class="dt">O</span>,<span class="dt">I</span>] <span class="fu">&lt;*&gt;</span> <span class="st">&quot;abc&quot;</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">[(<span class="dv">0</span>,<span class="ch">&#39;a&#39;</span>),(<span class="dv">0</span>,<span class="ch">&#39;b&#39;</span>),(<span class="dv">0</span>,<span class="ch">&#39;c&#39;</span>),(<span class="dv">1</span>,<span class="ch">&#39;a&#39;</span>),(<span class="dv">1</span>,<span class="ch">&#39;b&#39;</span>),(<span class="dv">1</span>,<span class="ch">&#39;c&#39;</span>)]</a></code></pre></div>
<p>Well, actually itâ€™s the wrong way around. We want to loop through the <em>first</em> list the quickest, incrementing the second slower. No worries, we can just use a flipped version of <code>&lt;*&gt;</code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">infixl</span> <span class="dv">4</span> <span class="fu">&lt;&lt;&gt;</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="ot">(&lt;&lt;&gt;) ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">fs <span class="fu">&lt;&lt;&gt;</span> xs <span class="fu">=</span> flip (<span class="fu">$</span>) <span class="fu">&lt;$&gt;</span> xs <span class="fu">&lt;*&gt;</span> fs</a>
<a class="sourceLine" id="cb4-4" data-line-number="4"></a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="fu">&gt;&gt;&gt;</span> (,) <span class="fu">&lt;$&gt;</span> [<span class="dt">O</span>,<span class="dt">I</span>] <span class="fu">&lt;&lt;&gt;</span> <span class="st">&quot;abc&quot;</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">[(<span class="dv">0</span>,<span class="ch">&#39;a&#39;</span>),(<span class="dv">1</span>,<span class="ch">&#39;a&#39;</span>),(<span class="dv">0</span>,<span class="ch">&#39;b&#39;</span>),(<span class="dv">1</span>,<span class="ch">&#39;b&#39;</span>),(<span class="dv">0</span>,<span class="ch">&#39;c&#39;</span>),(<span class="dv">1</span>,<span class="ch">&#39;c&#39;</span>)]</a></code></pre></div>
<p>Brilliant! So we can write our function now, yes?</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1">bins <span class="fu">=</span> (<span class="fu">:</span>) <span class="fu">&lt;$&gt;</span> [<span class="dt">O</span>,<span class="dt">I</span>] <span class="fu">&lt;&lt;&gt;</span> bins</a></code></pre></div>
<p>Nope! That wonâ€™t ever produce an answer, unfortunately.</p>
<h1 id="productivity">Productivity</h1>
<p>The issue with our definition above is that itâ€™s not lazy enough: it demands information that it hasnâ€™t produced yet, so it gets caught in an infinite loop before it can do anything!</p>
<p>We need to kick-start it a little, so it can produce output <em>before</em> it asks itself for more. Because we know what the first line is going to be, we can just tell it that:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1">bins <span class="fu">=</span> (<span class="fu">:</span>) <span class="fu">&lt;$&gt;</span> [<span class="dt">O</span>,<span class="dt">I</span>] <span class="fu">&lt;&lt;&gt;</span> (repeat <span class="dt">O</span> <span class="fu">:</span> tail bins)</a>
<a class="sourceLine" id="cb6-2" data-line-number="2"></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="fu">&gt;&gt;&gt;</span> mapM_ print (take <span class="dv">8</span> (map (take <span class="dv">3</span>) bins))</a>
<a class="sourceLine" id="cb6-4" data-line-number="4"><span class="dv">000</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5"><span class="dv">100</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6"><span class="dv">010</span></a>
<a class="sourceLine" id="cb6-7" data-line-number="7"><span class="dv">110</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8"><span class="dv">001</span></a>
<a class="sourceLine" id="cb6-9" data-line-number="9"><span class="dv">101</span></a>
<a class="sourceLine" id="cb6-10" data-line-number="10"><span class="dv">011</span></a>
<a class="sourceLine" id="cb6-11" data-line-number="11"><span class="dv">111</span></a></code></pre></div>
<p>The property that this function has that the previous didnâ€™t is <em>productivity</em>: the dual of termination. See, we want to avoid a <em>kind</em> of infinite loops in <code>bins</code>, but we donâ€™t want to avoid infinite things altogether: the list it produces is meant to be infinite, for goodnessâ€™ sake. Instead, what it needs to do is produce every new value in <em>finite</em> time.</p>
<h1 id="checking-productivity">Checking Productivity</h1>
<p>In total languages, like Agda, termination checking is a must. To express computation like that above, though, you often also want a <em>productivity</em> checker. Agda can do that, too.</p>
<p>Letâ€™s get started then. First, a stream:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">5</span> <span class="ot">_</span>â—‚<span class="ot">_</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="kw">record</span> Stream <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  <span class="kw">coinductive</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">  <span class="kw">constructor</span> <span class="ot">_</span>â—‚<span class="ot">_</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5">  <span class="kw">field</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6">    head <span class="ot">:</span> A</a>
<a class="sourceLine" id="cb7-7" data-line-number="7">    tail <span class="ot">:</span> Stream A</a>
<a class="sourceLine" id="cb7-8" data-line-number="8"><span class="kw">open</span> Stream</a></code></pre></div>
<p>In Haskell, there was no need to define a separate stream type: the type of lists contains both finite and infinite lists.</p>
<p>Agda can get a little more specific: here, weâ€™ve used the <code>coinductive</code> keyword, which means weâ€™re free to create infinite <code>Stream</code>s. Rather than the usual termination checking (which would kick in when we consume a recursive, inductive type), we now get productivity checking: when creating a <code>Stream</code>, the <code>tail</code> must always be available in finite time. For a finite type, weâ€™d have used the <code>inductive</code> keyword instead; this wouldnâ€™t be much use, though, since thereâ€™s no way to create a finite <code>Stream</code> without a nil constructor!<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a></p>
<p>One of the interesting things about working with infinite data (when youâ€™re forced to notice that itâ€™s infinite, as you are in Agda) is that <em>everything</em> gets flipped. So you have to prove productivity, not totality; you use product types, rather than sums; and to define functions, you use <em>co</em>patterns, rather than patterns.</p>
<h1 id="copatterns">Copatterns</h1>
<p>Copatterns are a handy syntactic construct for writing functions about record types. Letâ€™s start with an example, and then Iâ€™ll try explain a little:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb8-1" data-line-number="1">pure <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">â†’</span> A <span class="ot">â†’</span> Stream A</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">head <span class="ot">(</span>pure x<span class="ot">)</span> <span class="ot">=</span> x</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">tail <span class="ot">(</span>pure x<span class="ot">)</span> <span class="ot">=</span> pure x</a></code></pre></div>
<p>Here, weâ€™re defining <code>pure</code> on streams: <code>pure x</code> produces an infinite stream of <code>x</code>. Its equivalent would be repeat in Haskell:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1">repeat<span class="ot"> ::</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">repeat x <span class="fu">=</span> x <span class="fu">:</span> repeat x</a></code></pre></div>
<p>Except instead of describing what it <em>is</em>, you describe how it <em>acts</em> (itâ€™s kind of an intensional vs.Â extensional thing). In other words, if you want to make a stream <code>xs</code>, you have to answer the questions â€œwhatâ€™s the head of <code>xs</code>?â€ and â€œwhatâ€™s the tail of <code>xs</code>?â€</p>
<p>Contrast this with pattern-matching: weâ€™re producing (rather than consuming) a value, and in pattern matching, you have to answer a question for each <em>case</em>. If you want to consume a list <code>xs</code>, you have to answer the questions â€œwhat do you do when itâ€™s nil?â€ and â€œwhat do you do when itâ€™s cons?â€</p>
<p>Anyway, I think the symmetry is kind of cool. Letâ€™s get back to writing our functions.</p>
<h1 id="sized-types">Sized Types</h1>
<p>Unfortunately, we donâ€™t have enough to prove productivity yet. As an explanation why, letâ€™s first try produce the famous <code>fibs</code> list. Written here in Haskell:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">fibs <span class="fu">=</span> <span class="dv">0</span> <span class="fu">:</span> <span class="dv">1</span> <span class="fu">:</span> zipWith (<span class="fu">+</span>) fibs (tail fibs)</a></code></pre></div>
<p>Instead of <code>zipWith</code>, letâ€™s define <code>&lt;*&gt;</code>. That will let us use <a href="https://agda.readthedocs.io/en/v2.5.4.1/language/syntactic-sugar.html#idiom-brackets">idiom brackets</a>.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">_</span>&lt;*&gt;<span class="ot">_</span> <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>a b<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">{</span>B <span class="ot">:</span> <span class="dt">Set</span> b<span class="ot">}</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2">      <span class="ot">â†’</span> Stream <span class="ot">(</span>A <span class="ot">â†’</span> B<span class="ot">)</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">      <span class="ot">â†’</span> Stream A</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">      <span class="ot">â†’</span> Stream B</a>
<a class="sourceLine" id="cb11-5" data-line-number="5">head <span class="ot">(</span>fs &lt;*&gt; xs<span class="ot">)</span> <span class="ot">=</span> head fs <span class="ot">(</span>head xs<span class="ot">)</span></a>
<a class="sourceLine" id="cb11-6" data-line-number="6">tail <span class="ot">(</span>fs &lt;*&gt; xs<span class="ot">)</span> <span class="ot">=</span> tail fs &lt;*&gt; tail xs</a></code></pre></div>
<p>And hereâ€™s <code>fibs</code>:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb12-1" data-line-number="1">fibs <span class="ot">:</span> Stream â„•</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">head fibs <span class="ot">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">head <span class="ot">(</span>tail fibs<span class="ot">)</span> <span class="ot">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">tail <span class="ot">(</span>tail fibs<span class="ot">)</span> <span class="ot">=</span> â¦‡ fibs + tail fibs â¦ˆ</a></code></pre></div>
<p>But it doesnâ€™t pass the productivity checker! Because we use a higher-order function (<code>&lt;*&gt;</code>), Agda wonâ€™t look at how much it dips into the infinite supply of values. This is a problem: we need it to know that <code>&lt;*&gt;</code> only needs the heads of its arguments to produce a head, and so on. The solution? Encode this information in the types.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">5</span> <span class="ot">_</span>â—‚<span class="ot">_</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2"><span class="kw">record</span> Stream <span class="ot">{</span>i <span class="ot">:</span> Size<span class="ot">}</span> <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">  <span class="kw">coinductive</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4">  <span class="kw">constructor</span> <span class="ot">_</span>â—‚<span class="ot">_</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5">  <span class="kw">field</span></a>
<a class="sourceLine" id="cb13-6" data-line-number="6">    head <span class="ot">:</span> A</a>
<a class="sourceLine" id="cb13-7" data-line-number="7">    tail <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>j <span class="ot">:</span> Size&lt; i<span class="ot">}</span> <span class="ot">â†’</span> Stream <span class="ot">{</span>j<span class="ot">}</span> A</a>
<a class="sourceLine" id="cb13-8" data-line-number="8"><span class="kw">open</span> Stream</a></code></pre></div>
<p>Now, <code>Stream</code> has an implicit <em>size</em> parameter. Basically, <code>Stream {i} A</code> can produce <code>i</code> more values. So <code>cons</code>, then, gives a stream one extra value to produce:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb14-1" data-line-number="1">cons <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>i a<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">â†’</span> A <span class="ot">â†’</span> Stream <span class="ot">{</span>i<span class="ot">}</span> A <span class="ot">â†’</span> Stream <span class="ot">{</span>â†‘ i<span class="ot">}</span> A</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">head <span class="ot">(</span>cons x xs<span class="ot">)</span> <span class="ot">=</span> x</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">tail <span class="ot">(</span>cons x xs<span class="ot">)</span> <span class="ot">=</span> xs</a></code></pre></div>
<p>Conversely, we can write a different definition of <code>tail</code> that consumes one value<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb15-1" data-line-number="1">tailâ€² <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>i a<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">â†’</span> Stream <span class="ot">{</span>â†‘ i<span class="ot">}</span> A <span class="ot">â†’</span> Stream <span class="ot">{</span>i<span class="ot">}</span> A</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">tailâ€² <span class="ot">{</span>i<span class="ot">}</span> xs <span class="ot">=</span> tail xs <span class="ot">{</span>i<span class="ot">}</span></a></code></pre></div>
<p>For <code>&lt;*&gt;</code>, we want to show that its result can produce just as much values as its inputs can:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="ot">_</span>&lt;*&gt;<span class="ot">_</span> <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>i a b<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">{</span>B <span class="ot">:</span> <span class="dt">Set</span> b<span class="ot">}</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2">      <span class="ot">â†’</span> Stream <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">(</span>A <span class="ot">â†’</span> B<span class="ot">)</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3">      <span class="ot">â†’</span> Stream <span class="ot">{</span>i<span class="ot">}</span> A</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">      <span class="ot">â†’</span> Stream <span class="ot">{</span>i<span class="ot">}</span> B</a>
<a class="sourceLine" id="cb16-5" data-line-number="5">head <span class="ot">(</span>fs &lt;*&gt; xs<span class="ot">)</span> <span class="ot">=</span> head fs <span class="ot">(</span>head xs<span class="ot">)</span></a>
<a class="sourceLine" id="cb16-6" data-line-number="6">tail <span class="ot">(</span>fs &lt;*&gt; xs<span class="ot">)</span> <span class="ot">=</span> tail fs &lt;*&gt; tail xs</a></code></pre></div>
<p>How does this help the termination/productivity checker? Well, for terminating functions, we have to keep giving the <code>tail</code> field smaller and smaller sizes, meaning that weâ€™ll eventually hit zero (and terminate). For productivity, we now have a way to talk about â€œdefinednessâ€ in types, so we can make sure that a recursive call doesnâ€™t dip into a supply it hasnâ€™t produced yet.</p>
<p>One more thing: <code>Size</code> types have strange typing rules, mainly for ergonomic purposes (this is why weâ€™re not just using an <code>â„•</code> parameter). One of them is that if you donâ€™t specify the size, itâ€™s defaulted to <code>âˆ</code>, so functions written without size annotations donâ€™t have to be changed with this new definition:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb17-1" data-line-number="1">pure <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">â†’</span> A <span class="ot">â†’</span> Stream A</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">head <span class="ot">(</span>pure x<span class="ot">)</span> <span class="ot">=</span> x</a>
<a class="sourceLine" id="cb17-3" data-line-number="3">tail <span class="ot">(</span>pure x<span class="ot">)</span> <span class="ot">=</span> pure x</a></code></pre></div>
<p>Finally <code>fibs</code>:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb18-1" data-line-number="1">fibs <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">â†’</span> Stream <span class="ot">{</span>i<span class="ot">}</span> â„•</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">head fibs <span class="ot">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3">head <span class="ot">(</span>tail fibs<span class="ot">)</span> <span class="ot">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb18-4" data-line-number="4">tail <span class="ot">(</span>tail fibs<span class="ot">)</span> <span class="ot">=</span> â¦‡ fibs + tail fibs â¦ˆ</a></code></pre></div>
<h1 id="bugs">Bugs!</h1>
<p>Before I show the Agda solution, Iâ€™d like to point out some bugs that were revealed in the Haskell version by trying to implement it totally. First of all, the function signature. â€œTakes an alphabet and produces unique stringsâ€ seems like this:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="ot">strings ::</span> [a] <span class="ot">-&gt;</span> [[a]]</a></code></pre></div>
<p>But what should you produce in this case:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1">strings []</a></code></pre></div>
<p>So it must be a non-empty list, giving us the following type and definition:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="ot">strings ::</span> <span class="dt">NonEmpty</span> a <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">strings (x <span class="fu">:|</span> xs) <span class="fu">=</span> (<span class="fu">:</span>) <span class="fu">&lt;$&gt;</span> (x<span class="fu">:</span>xs) <span class="fu">&lt;&lt;&gt;</span> (repeat x <span class="fu">:</span> tail (strings (x <span class="fu">:|</span> xs)))</a></code></pre></div>
<p>But this has a bug too! What happens if we pass in the following:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1">strings (x <span class="fu">:|</span> [])</a></code></pre></div>
<p>So this fails the specification: there is only one unique infinite string from that alphabet (<code>pure x</code>). Interestingly, though, our implementation above also wonâ€™t produce any output beyond the first element. I suppose, in a way, these things cancel each other out: our function does indeed produce all of the unique strings, itâ€™s just a pity that it goes into an infinite loop to do so!</p>
<h1 id="bringing-it-all-together">Bringing it all Together</h1>
<p>Finally, we have our function:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb23-1" data-line-number="1">strings <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>i a<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">â†’</span> A Ã— A Ã— List A <span class="ot">â†’</span> Stream <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">(</span>Stream A<span class="ot">)</span></a>
<a class="sourceLine" id="cb23-2" data-line-number="2">head <span class="ot">(</span>strings <span class="ot">(</span>x , <span class="ot">_</span> , <span class="ot">_))</span> <span class="ot">=</span> pure x</a>
<a class="sourceLine" id="cb23-3" data-line-number="3">tail <span class="ot">(</span>strings <span class="ot">{</span>A <span class="ot">=</span> A<span class="ot">}</span> xs<span class="ot">@(</span>xâ‚ , xâ‚‚ , xt<span class="ot">))</span> <span class="ot">=</span> go xâ‚‚ xt <span class="ot">(</span>strings xs<span class="ot">)</span></a>
<a class="sourceLine" id="cb23-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-5" data-line-number="5">  go <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">â†’</span> A <span class="ot">â†’</span> List A <span class="ot">â†’</span> Stream <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">(</span>Stream A<span class="ot">)</span> <span class="ot">â†’</span> Stream <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">(</span>Stream A<span class="ot">)</span></a>
<a class="sourceLine" id="cb23-6" data-line-number="6">  head <span class="ot">(</span>head <span class="ot">(</span>go y ys zs<span class="ot">))</span> <span class="ot">=</span> y</a>
<a class="sourceLine" id="cb23-7" data-line-number="7">  tail <span class="ot">(</span>head <span class="ot">(</span>go y ys zs<span class="ot">))</span> <span class="ot">=</span> head zs</a>
<a class="sourceLine" id="cb23-8" data-line-number="8">  tail <span class="ot">(</span>go <span class="ot">_</span> [] zs<span class="ot">)</span> <span class="ot">=</span> go xâ‚ <span class="ot">(</span>xâ‚‚ âˆ· xt<span class="ot">)</span> <span class="ot">(</span>tail zs<span class="ot">)</span></a>
<a class="sourceLine" id="cb23-9" data-line-number="9">  tail <span class="ot">(</span>go <span class="ot">_</span> <span class="ot">(</span>y âˆ· ys<span class="ot">)</span> zs<span class="ot">)</span> <span class="ot">=</span> go y ys zs</a></code></pre></div>
<p>As you can see, we do need to kick-start it without a recursive call (the first line is <code>pure x</code>). Then, <code>go</code> takes as a third argument the â€œtailsâ€ argument, and does the kind of backwards Cartesian product we want. However, since weâ€™re into the second element of the stream now, we want to avoid repeating what we already said, which is why we have to give <code>go</code> <code>xâ‚‚</code>, rather than <code>xâ‚</code>. This is what forces us to take at least two elements, rather than at least one, also: we canâ€™t just take the tail of the call to <code>go</code> (this is what we did in the Haskell version of <code>strings</code> with the <code>NonEmpty</code> list), as the recursive call to strings then doesnâ€™t decrease in size:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb24-1" data-line-number="1">strings <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>i a<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">â†’</span> A Ã— List A <span class="ot">â†’</span> Stream <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">(</span>Stream A<span class="ot">)</span></a>
<a class="sourceLine" id="cb24-2" data-line-number="2">head <span class="ot">(</span>strings <span class="ot">(</span>x , <span class="ot">_))</span> <span class="ot">=</span> pure x</a>
<a class="sourceLine" id="cb24-3" data-line-number="3">tail <span class="ot">(</span>strings <span class="ot">{</span>A <span class="ot">=</span> A<span class="ot">}</span> xs<span class="ot">@(</span>x , xt<span class="ot">))</span> <span class="ot">=</span> tail <span class="ot">(</span>go x xt <span class="ot">(</span>strings xs<span class="ot">))</span></a>
<a class="sourceLine" id="cb24-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-5" data-line-number="5">  go <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">â†’</span> A <span class="ot">â†’</span> List A <span class="ot">â†’</span> Stream <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">(</span>Stream A<span class="ot">)</span> <span class="ot">â†’</span> Stream <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">(</span>Stream A<span class="ot">)</span></a>
<a class="sourceLine" id="cb24-6" data-line-number="6">  head <span class="ot">(</span>head <span class="ot">(</span>go y ys zs<span class="ot">))</span> <span class="ot">=</span> y</a>
<a class="sourceLine" id="cb24-7" data-line-number="7">  tail <span class="ot">(</span>head <span class="ot">(</span>go y ys zs<span class="ot">))</span> <span class="ot">=</span> head zs</a>
<a class="sourceLine" id="cb24-8" data-line-number="8">  tail <span class="ot">(</span>go <span class="ot">_</span> [] zs<span class="ot">)</span> <span class="ot">=</span> go x xt <span class="ot">(</span>tail zs<span class="ot">)</span></a>
<a class="sourceLine" id="cb24-9" data-line-number="9">  tail <span class="ot">(</span>go <span class="ot">_</span> <span class="ot">(</span>y âˆ· ys<span class="ot">)</span> zs<span class="ot">)</span> <span class="ot">=</span> go y ys zs</a></code></pre></div>
<p>Agda will warn about termination on this function. Now, if you slap a pragma on it, it <em>will</em> produce the correct results for enough arguments, but give it one and youâ€™ll get an infinite loop, just as you were warned!</p>
<h1 id="further-work">Further Work</h1>
<p>Iâ€™m having a lot of fun with copatterns for various algorithms (especially combinatorics). Iâ€™m planning on working on two particular tasks with them for the next posts in this series:</p>
<dl>
<dt>Proving <code>strings</code></dt>
<dd><p>Iâ€™d like to prove that <code>strings</code> does indeed produce a stream of unique values. Following from that, it would be cool to do a Cantor diagonalisation on its output.</p>
</dd>
<dt>Permutations</dt>
<dd><p>Haskellâ€™s <a href="http://hackage.haskell.org/package/base-4.12.0.0/docs/src/Data.OldList.html#permutations">permutations implementation in Data.List</a> does some interesting tricks to make it as lazy as possible. It would be great to write an implementation that is verified to be as lazy as possible: the pattern of â€œdefinednessâ€ is complex, though, so I donâ€™t know if itâ€™s possible with Agdaâ€™s current sized types.</p>
</dd>
</dl>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Thanks to <a href="http://gelisam.blogspot.com/">gelisam</a> for pointing out the poor phrasing here. Updated on 2018/10/16<a href="#fnref1" class="footnote-back">â†©</a></p></li>
<li id="fn2"><p>You might wonder why the definition of <code>tail</code> doesnâ€™t have this signature to begin with. The reason is that our record type must be <em>parameterized</em> (not indexed) over its size (as itâ€™s a record type), so we use a less-than proof instead.<a href="#fnref2" class="footnote-back">â†©</a></p></li>
</ol>
</section>
]]></description>
    <pubDate>Tue, 16 Oct 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-10-16-total-combinations.html</guid>
    <dc:creator>Donnacha OisÃ­n Kidney</dc:creator>
</item>
<item>
    <title>Agda Beginner(-ish) Tips, Tricks, and Pitfalls</title>
    <link>https://doisinkidney.com/posts/2018-09-20-agda-tips.html</link>
    <description><![CDATA[<div class="info">
    Posted on September 20, 2018
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Agda.html">Agda</a>
    
</div>

<p>Iâ€™m in the middle of quite a large Agda project at the moment, and Iâ€™ve picked up a few tips and tricks in the past few weeks. Iâ€™d imagine a lot of these are quite obvious once you get to grips with Agda, so Iâ€™m writing them down before I forget that they were once confusing stumbling blocks. Hopefully this helps other people trying to learn the language!</p>
<h1 id="parameterized-modules-strangeness">Parameterized Modules Strangeness</h1>
<p>Agda lets you parameterize modules, just as you can datatypes, with types, values, etc. Itâ€™s extremely handy for those situations where you want to be generic over some type, but that type wonâ€™t change inside the generic code. The keys to dictionaries is a good example: you can start the module with:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">module</span> Map <span class="ot">(</span>Key <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">(</span>Ordering <span class="ot">:</span> Ord Key<span class="ot">)</span> <span class="kw">where</span></a></code></pre></div>
<p>And now, where in Haskell youâ€™d have to write something like <code>Ord a =&gt; Map a</code>â€¦ in pretty much any function signature, you can just refer to <code>Key</code>, and youâ€™re good to go. Itâ€™s kind of like a dynamic type synonym, in that way.</p>
<p>Hereâ€™s the strangeness, though: what if you donâ€™t supply one of the arguments?</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">import</span> Map</a></code></pre></div>
<p>This wonâ€™t give you a type error, strange as it may seem. This will perform <em>lambda lifting</em>, meaning that now, every function exported by the module will have the type signature:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">(</span>Key <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">(</span>Ordering <span class="ot">:</span> Ord Key<span class="ot">)</span> <span class="ot">...</span></a></code></pre></div>
<p>Preceding its normal signature. In other words, it changes it into what you would have had to write in Haskell.</p>
<p>This is a powerful feature, but it can also give you some confusing errors if you donâ€™t know about it (especially if the module has implicit arguments).</p>
<h1 id="auto">Auto</h1>
<p>If youâ€™ve got a hole in your program, you can put the cursor in it and press <code>SPC-m-a</code> (in spacemacs), and Agda will try and find the automatic solution to the problem. For a while, I didnâ€™t think much of this feature, as rare was the program which Agda could figure out. Turns out I was just using it wrong! Into the hole you should type the options for the proof search: enabling case-splitting (<code>-c</code>), enabling the use of available definitions (<code>-r</code>), and listing possible solutions (<code>-l</code>).</p>
<h1 id="well-founded-recursion">Well-Founded Recursion</h1>
<p>Often, a program will not be obviously terminating (according to Agdaâ€™s termination checker). The first piece of advice is this: <em>donâ€™t</em> use well-founded recursion. Itâ€™s a huge hammer, and often you can get away with fiddling with the function (try inlining definitions, rewriting generic functions to monomorphic versions, or replacing with-blocks with helper functions), or using one of the <a href="https://gallais.github.io/blog/termination-tricks.html">more lightweight techniques</a> out there.</p>
<p>However, sometimes it really is the best option, so you have to grit your teeth and use it. What I expected (and what I used originally) was a recursion combinator, with a type something like:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb4-1" data-line-number="1">wf-rec <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>a b<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">{</span>B <span class="ot">:</span> <span class="dt">Set</span> b<span class="ot">}</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">       <span class="ot">â†’</span> <span class="ot">((</span>x <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">â†’</span> <span class="ot">((</span>y <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">â†’</span> y &lt; x <span class="ot">â†’</span> B<span class="ot">)</span> <span class="ot">â†’</span> B<span class="ot">)</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">       <span class="ot">â†’</span> A <span class="ot">â†’</span> B</a></code></pre></div>
<p>So weâ€™re trying to generate a function of type <code>A â†’ B</code>, but thereâ€™s a hairy recursive call in there somewhere. Instead we use this function, and pass it a version of our function that uses the supplied function rather than making a recursive call:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb5-1" data-line-number="1">terminating <span class="ot">:</span> A <span class="ot">â†’</span> B</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">terminating <span class="ot">=</span> wf-rec <span class="ot">(Î»</span> x recursive-call <span class="ot">â†’</span> <span class="ot">...)</span></a></code></pre></div>
<p>In other words, instead of calling the function itself, you call <code>recursive-call</code> above. Along with the argument, you supply a proof that itâ€™s smaller than the outer argument (<code>y &lt; x</code>; assume for now that the definition of <code>&lt;</code> is just some relation like <a href="https://github.com/agda/agda-stdlib/blob/442cd8a06b63f7e3550af55fb75c9d345c6ddb8f/src/Data/Nat/Base.agda#L31"><code>_&lt;_</code> in Data.Nat</a>).</p>
<p>But wait! You donâ€™t have to use it! Instead of all that, you can just pass the <code>Acc _&lt;_ x</code> type as a parameter to your function. In other words, if you have a dangerous function:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb6-1" data-line-number="1">f <span class="ot">:</span> A <span class="ot">â†’</span> B</a></code></pre></div>
<p>Instead write:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb7-1" data-line-number="1">f-step <span class="ot">:</span> <span class="ot">(</span>x <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">â†’</span> Acc <span class="ot">_</span>&lt;<span class="ot">_</span> x <span class="ot">â†’</span> B</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">f-step <span class="ot">=</span> <span class="ot">...</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">f <span class="ot">:</span> A <span class="ot">â†’</span> B</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">f x <span class="ot">=</span> f-step x <span class="ot">...</span></a></code></pre></div>
<p>Once you pattern match on the accessibility relation, the termination checker is satisfied. This is much easier to understand (for me anyway), and made it <em>much</em> easier to write proofs about it.</p>
<p>Thanks to <a href="http://oleg.fi">Oleg Grenrus (phadej)</a> on irc for helping me out with this! Funnily enough, he actually recommended the <code>Acc</code> approach, and I instead originally went with the recursion combinator. Would have saved a couple hours if Iâ€™d just listened! Also worth mentioning is the approach recommended by <a href="https://gallais.github.io">Guillaume Allais (gallais)</a>, detailed <a href="https://gallais.github.io/agdarsec/Induction.Nat.Strong.html">here</a>. Havenâ€™t had time to figure it out, so this article may be updated to recommend it instead in the future.</p>
<h1 id="dont-touch-the-green-slime">Donâ€™t Touch The Green Slime!</h1>
<p>This one is really important. If I hadnâ€™t read the exact explanation <a href="https://twitter.com/pigworker/status/1013535783234473984">here</a> I think I may have given up with Agda (or at the very least the project Iâ€™m working on) out of frustration.</p>
<p>Basically the problem arises like this. Say youâ€™re writing a function to split a vector in two. You can specify the type pretty precisely:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb8-1" data-line-number="1">split <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>a n m<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">â†’</span> Vec A <span class="ot">(</span>n + m<span class="ot">)</span> <span class="ot">â†’</span> Vec A n Ã— Vec A m</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">split xs <span class="ot">=</span> <span class="ot">{!!}</span></a></code></pre></div>
<p>Try to pattern-match on <code>xs</code>, though, and youâ€™ll get the following error:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb9-1" data-line-number="1">I&#39;m not sure if there should be a case for the <span class="kw">constructor</span> [],</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">because I get stuck when trying <span class="kw">to</span> solve the following unification</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">problems <span class="ot">(</span>inferred index â‰Ÿ expected index<span class="ot">):</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4">  zero â‰Ÿ n + m</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">when checking that the expression ? has type Vec <span class="ot">.</span>A <span class="ot">.</span>n Ã— Vec <span class="ot">.</span>A <span class="ot">.</span>m</a></code></pre></div>
<p>What?! Thatâ€™s weird. Anyway, you fiddle around with the function, end up pattern matching on the <code>n</code> instead, and continue on with your life.</p>
<p>What about this, though: you want to write a type for proofs that one number is less than or equal to another. You go with something like this:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">infix</span> <span class="dv">4</span> <span class="ot">_</span>â‰¤<span class="ot">_</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="kw">data</span> <span class="ot">_</span>â‰¤<span class="ot">_</span> <span class="ot">(</span>n <span class="ot">:</span> â„•<span class="ot">)</span> <span class="ot">:</span> â„• <span class="ot">â†’</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  proof <span class="ot">:</span> <span class="ot">âˆ€</span> k <span class="ot">â†’</span> n â‰¤ n + k</a></code></pre></div>
<p>And you want to use it in a proof. Hereâ€™s the example weâ€™ll be using: if two numbers are less than some limit <code>u</code>, then their maximum is also less than that limit:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb11-1" data-line-number="1">max <span class="ot">:</span> â„• <span class="ot">â†’</span> â„• <span class="ot">â†’</span> â„•</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">max zero m <span class="ot">=</span> m</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">max <span class="ot">(</span>suc n<span class="ot">)</span> zero <span class="ot">=</span> suc n</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">max <span class="ot">(</span>suc n<span class="ot">)</span> <span class="ot">(</span>suc m<span class="ot">)</span> <span class="ot">=</span> suc <span class="ot">(</span>max n m<span class="ot">)</span></a>
<a class="sourceLine" id="cb11-5" data-line-number="5"></a>
<a class="sourceLine" id="cb11-6" data-line-number="6">max-â‰¤ <span class="ot">:</span> <span class="ot">âˆ€</span> n m <span class="ot">{</span>u<span class="ot">}</span> <span class="ot">â†’</span> n â‰¤ u <span class="ot">â†’</span> m â‰¤ u <span class="ot">â†’</span> max n m â‰¤ u</a>
<a class="sourceLine" id="cb11-7" data-line-number="7">max-â‰¤ n m <span class="ot">(</span>proof k<span class="ot">)</span> mâ‰¤u <span class="ot">=</span> <span class="ot">{!!}</span></a></code></pre></div>
<p>It wonâ€™t let you match on <code>mâ‰¤u</code>! Hereâ€™s the error:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb12-1" data-line-number="1">I&#39;m not sure if there should be a case for the <span class="kw">constructor</span> proof,</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">because I get stuck when trying <span class="kw">to</span> solve the following unification</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">problems <span class="ot">(</span>inferred index â‰Ÿ expected index<span class="ot">):</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">  mâ‚ + kâ‚‚ â‰Ÿ nâ‚ + kâ‚</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">when checking that the expression ? has type max n m â‰¤ n + k</a></code></pre></div>
<p>What do you <em>mean</em> youâ€™re not sure if thereâ€™s a case for the constructor <code>proof</code>: itâ€™s the <em>only</em> case!</p>
<p>The problem is that Agda is trying to <em>unify</em> two types who both have calls to user-defined functions in them, which is a hard problem. As phrased by Conor McBride:</p>
<blockquote>
<p>When combining prescriptive and descriptive indices, ensure both are in constructor form. Exclude defined functions which yield difficult unification problems.</p>
</blockquote>
<p>So if you ever get the â€œIâ€™m not sure ifâ€¦â€ error, try either to:</p>
<ol>
<li>Redefine the indices so they use constructors, not functions.</li>
<li>Remove the index, instead having a proof inside the type of equality. What does that mean? Basically, transform the definition of <code>â‰¤</code> above into <a href="https://github.com/agda/agda-stdlib/blob/442cd8a06b63f7e3550af55fb75c9d345c6ddb8f/src/Data/Nat/Base.agda#L72-L76">the one in Data.Nat</a>.</li>
</ol>
<h1 id="inspect">Inspect</h1>
<p>The use-case I had for this is a little long, Iâ€™m afraid (too long to include here), but it <em>did</em> come in handy. Basically, if youâ€™re trying to prove something about a function, you may well want to <em>run</em> that function and pattern match on the result.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb13-1" data-line-number="1">f-is-the-same-as-g <span class="ot">:</span> <span class="ot">âˆ€</span> x <span class="ot">â†’</span> f x â‰¡ g x</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">f-is-the-same-as-g x <span class="kw">with</span> f x</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">f-is-the-same-as-g x <span class="ot">|</span> y <span class="ot">=</span> <span class="ot">{!!}</span></a></code></pre></div>
<p>This is a little different from the normal way of doing things, where youâ€™d pattern match on the argument. It is a pattern youâ€™ll sometimes need to write, though. And hereâ€™s the issue: that <code>y</code> has nothing to do with <code>f x</code>, as far as Agda is concerned. All youâ€™ve done is introduced a new variable, and thatâ€™s that.</p>
<p>This is exactly the problem <a href="https://github.com/agda/agda-stdlib/blob/442cd8a06b63f7e3550af55fb75c9d345c6ddb8f/src/Relation/Binary/PropositionalEquality.agda#L111-L113"><code>inspect</code></a> solves: it runs your function, giving you a result, but <em>also</em> giving you a proof that the result is equal to running the function. You use it like this:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb14-1" data-line-number="1">f-is-the-same-as-g <span class="ot">:</span> <span class="ot">âˆ€</span> x <span class="ot">â†’</span> f x â‰¡ g x</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">f-is-the-same-as-g x <span class="kw">with</span> f x <span class="ot">|</span> inspect f x</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">f-is-the-same-as-g x <span class="ot">|</span> y <span class="ot">|</span> [ fxâ‰¡y ] <span class="ot">=</span> <span class="ot">{!!}</span></a></code></pre></div>
<h1 id="spc-g-g">SPC-G-G</h1>
<p>Because the Agda standard library is a big fan of type synonyms (<code>Opâ‚‚ A</code> instead of <code>A â†’ A â†’ A</code> for example), itâ€™s handy to know that pressing <code>SPC-G-G</code> (in spacemacs) over any identifier will bring you to the definition. Also, you can normalize a type with <code>SPC-m-n</code>.</p>
<h1 id="irrelevance">Irrelevance</h1>
<p>This one is a little confusing, because Agdaâ€™s notion of â€œirrelevanceâ€ is different from Idrisâ€™, or Haskellâ€™s. In all three languages, irrelevance is used for performance: it means that a value doesnâ€™t need to be around at runtime, so the compiler can elide it.</p>
<p>Thatâ€™s where the similarities stop though. In Haskell, <em>all</em> types are irrelevant: theyâ€™re figments of the typecheckerâ€™s imagination. You canâ€™t get a type at runtime full stop.</p>
<p>In dependently typed languages, this isnâ€™t a distinction we can rely on. The line between runtime entities and compile-time entities is drawn elsewhere, so quite often types <em>need</em> to exist at runtime. As you might guess, though, they donâ€™t always need to. The length of a length-indexed vector, for instance, is completely determined by the structure of the vector: why would you bother storing all of that information at runtime? This is what Idris recognizes, and what it tries to remedy: it analyses code for these kinds of opportunities for elision, and does so when it can. Kind of like Haskellâ€™s fusion, though, itâ€™s an invisible optimization, and thereâ€™s no way to make Idris throw a type error when it canâ€™t elide something you want it to elide.</p>
<p>Agda is totally different. Something is irrelevant in Agda if itâ€™s <em>unique</em>. Or, rather, itâ€™s irrelevant if all you rely on is its existence. Itâ€™s used for proofs that you carry around with you: in a rational number type, you might use it to say that the numerator and denominator have no common factors. The only information you want from this proof is whether it holds or not, so itâ€™s the perfect candidate for irrelevance.</p>
<p>Weirdly, this means itâ€™s useless for the length-indexed vector kind of stuff mentioned above. In fact, it doe exactly the opposite of what you might expect: if the length parameter is marked as irrelevant, the the types <code>Vec A n</code> and <code>Vec A (suc n)</code> are the same!</p>
<p>The way you <em>can</em> use it is to pattern-match if itâ€™s impossible. Again, itâ€™s designed for eliding proofs that you may carry with you otherwise.</p>
<h1 id="future-tips">Future Tips</h1>
<p>Once Iâ€™m finished the project, Iâ€™ll try write up a guide on how to do literate Agda files. There were a couple of weird nuances that I had to pick up on the way, mainly to do with getting unicode to work.</p>
]]></description>
    <pubDate>Thu, 20 Sep 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-09-20-agda-tips.html</guid>
    <dc:creator>Donnacha OisÃ­n Kidney</dc:creator>
</item>
<item>
    <title>Verified AVL Trees in Haskell and Agda</title>
    <link>https://doisinkidney.com/posts/2018-07-30-verified-avl.html</link>
    <description><![CDATA[<div class="info">
    Posted on July 30, 2018
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Agda.html">Agda</a>
    
</div>

<p>Iâ€™ve been writing a lot of Agda recently, and had the occasion to write a <a href="https://en.wikipedia.org/wiki/Fenwick_tree">Fenwick tree</a> that did some rebalancing. I went with <a href="https://en.wikipedia.org/wiki/AVL_tree">AVL</a>-style rebalancing (rather than <a href="https://en.wikipedia.org/wiki/Redâ€“black_tree">red-black</a> or <a href="https://en.wikipedia.org/wiki/Weight-balanced_tree">trees of bounded balance</a>). Iâ€™d written pretty full implementations of the other two before, and the Agda standard library <span class="citation" data-cites="danielsson_agda_2018">(Danielsson <a href="#ref-danielsson_agda_2018">2018</a>)</span> has an implementation already that I was able to use as a starting point. Also, apparently, AVL trees seem to perform better than red-black trees in practice <span class="citation" data-cites="pfaff_performance_2004">(Pfaff <a href="#ref-pfaff_performance_2004">2004</a>)</span>.</p>
<p>This post will be similar in style to Stephanie Weirichâ€™s talk <span class="citation" data-cites="weirich_depending_2014">(<a href="#ref-weirich_depending_2014">2014</a>)</span>, which compares an Agda implementation of verified red-black trees to a Haskell one. When thereâ€™s two columns of code side-by-side, the left-hand side is Haskell, the right Agda.</p>
<p>The method of constructing the ordering proof is taken from â€œHow to Keep Your Neighbours in Orderâ€ <span class="citation" data-cites="mcbride_how_2014">(<a href="#ref-mcbride_how_2014">2014</a>)</span> by Conor McBride; the structural proofs are somewhat inspired by the implementation in the Agda standard library, but are mainly my own.</p>
<h1 id="height">Height</h1>
<p>AVL trees are more strictly balanced than red-black trees: the height of neighboring subtrees can differ by at most one. To store the height, we will start as every dependently-typed program does: with Peano numbers.</p>
<style>
.column {
    float: left;
    width: 50%;
}
.row:after {
    content: "";
    display: table;
    clear: both;
}
</style>
<div class="row">
<div class="column">
<p>Haskell</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> <span class="dt">N</span> <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">|</span> <span class="dt">S</span> <span class="dt">N</span></a></code></pre></div>
</div>
<div class="column">
<p>Agda</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> â„• <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  zero <span class="ot">:</span> â„•</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  suc  <span class="ot">:</span> â„• <span class="ot">â†’</span> â„•</a></code></pre></div>
</div>
</div>
<p>The trees will be balanced one of three possible ways: left-heavy, right-heavy, or even. We can represent these three cases in a GADT in the case of Haskell, or an indexed datatype in the case of Agda:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Balance</span><span class="ot"> ::</span> <span class="dt">N</span> <span class="ot">-&gt;</span> <span class="dt">N</span> <span class="ot">-&gt;</span> <span class="dt">N</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">      <span class="dt">L</span><span class="ot"> ::</span> <span class="dt">Balance</span> (<span class="dt">S</span> n) n    (<span class="dt">S</span> n)</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">      <span class="dt">O</span><span class="ot"> ::</span> <span class="dt">Balance</span>  n    n     n</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">      <span class="dt">R</span><span class="ot"> ::</span> <span class="dt">Balance</span>  n   (<span class="dt">S</span> n) (<span class="dt">S</span> n)</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb4"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">data</span> âŸ¨<span class="ot">_</span>âŠ”<span class="ot">_</span>âŸ©â‰¡<span class="ot">_</span> <span class="ot">:</span> â„• <span class="ot">â†’</span> â„• <span class="ot">â†’</span> â„• <span class="ot">â†’</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  â—¿  <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">â†’</span> âŸ¨ suc  n âŠ”      n âŸ©â‰¡ suc  n</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  â–½  <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">â†’</span> âŸ¨      n âŠ”      n âŸ©â‰¡      n</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">  â—º  <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">â†’</span> âŸ¨      n âŠ” suc  n âŸ©â‰¡ suc  n</a></code></pre></div>
</div>
</div>
<p>Those unfamiliar with Agda might be a little intimidated by the mixfix operator in the balance definition: weâ€™re using it here because the type can be seen of a proof that:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">max(x,y) = z</annotation></semantics></math></p>
<p>Or, using the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>âŠ”</mo><annotation encoding="application/x-tex">\sqcup</annotation></semantics></math> operator:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>âŠ”</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">(x \sqcup y) = z</annotation></semantics></math></p>
<p>Weâ€™ll use this proof in the tree itself, as weâ€™ll need to know the maximum of the height of a nodeâ€™s two subtrees to find the height of the node. Before we do that, weâ€™ll need a couple helper functions for manipulating the balance:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">balr ::</span> <span class="dt">Balance</span> x y z <span class="ot">-&gt;</span> <span class="dt">Balance</span> z x z</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">balr <span class="dt">L</span> <span class="fu">=</span> <span class="dt">O</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">balr <span class="dt">O</span> <span class="fu">=</span> <span class="dt">O</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">balr <span class="dt">R</span> <span class="fu">=</span> <span class="dt">L</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5"></a>
<a class="sourceLine" id="cb5-6" data-line-number="6"><span class="ot">ball ::</span> <span class="dt">Balance</span> x y z <span class="ot">-&gt;</span> <span class="dt">Balance</span> y z z</a>
<a class="sourceLine" id="cb5-7" data-line-number="7">ball <span class="dt">L</span> <span class="fu">=</span> <span class="dt">R</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8">ball <span class="dt">O</span> <span class="fu">=</span> <span class="dt">O</span></a>
<a class="sourceLine" id="cb5-9" data-line-number="9">ball <span class="dt">R</span> <span class="fu">=</span> <span class="dt">O</span></a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb6"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb6-1" data-line-number="1">âƒ• <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>x y z<span class="ot">}</span> <span class="ot">â†’</span> âŸ¨ x âŠ” y âŸ©â‰¡ z <span class="ot">â†’</span> âŸ¨ z âŠ” x âŸ©â‰¡ z</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">âƒ•  â—¿  <span class="ot">=</span> â–½</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">âƒ•  â–½  <span class="ot">=</span> â–½</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">âƒ•  â—º  <span class="ot">=</span> â—¿</a>
<a class="sourceLine" id="cb6-5" data-line-number="5"></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">âƒ” <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>x y z<span class="ot">}</span> <span class="ot">â†’</span> âŸ¨ x âŠ” y âŸ©â‰¡ z <span class="ot">â†’</span> âŸ¨ y âŠ” z âŸ©â‰¡ z</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">âƒ”  â—¿  <span class="ot">=</span> â—º</a>
<a class="sourceLine" id="cb6-8" data-line-number="8">âƒ”  â–½  <span class="ot">=</span> â–½</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">âƒ”  â—º  <span class="ot">=</span> â–½</a></code></pre></div>
</div>
</div>
<h1 id="ordering">Ordering</h1>
<p>Along with the verification of the structure of the tree, we will also want to verify that its contents are ordered correctly. Unfortunately, this property is a little out of reach for Haskell, but itâ€™s 100% doable in Agda. First, weâ€™ll need a way to describe orders on a data type. In Haskell, we might write:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Ord</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="ot">  (==) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="ot">  (&lt;)  ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a></code></pre></div>
</div>
<div class="column">
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>*</mo><mo>*</mo><mo>*</mo></mrow><annotation encoding="application/x-tex">***</annotation></semantics></math>
</div>
</div>
<p>That <code class="sourceCode haskell"><span class="dt">Bool</span></code> throws away any information gained in the comparison, though: we want to supply a proof with the result of the comparison. First, equality:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">infix <span class="dv">4</span> <span class="fu">==</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="kw">data</span><span class="ot"> (==) ::</span> <span class="dt">Type</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">          <span class="ot">-&gt;</span> <span class="dt">Type</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">          <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5">  <span class="dt">Refl</span><span class="ot"> ::</span> x <span class="fu">==</span> x</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb9"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">infix</span> <span class="dv">4</span> <span class="ot">_</span>â‰¡<span class="ot">_</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="kw">data</span> <span class="ot">_</span>â‰¡<span class="ot">_</span> <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">         <span class="ot">(</span>x <span class="ot">:</span> A<span class="ot">)</span> </a>
<a class="sourceLine" id="cb9-4" data-line-number="4">         <span class="ot">:</span> A <span class="ot">â†’</span> <span class="dt">Set</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  refl <span class="ot">:</span> x â‰¡ x</a></code></pre></div>
</div>
</div>
<p>This is one of the many ways to describe equality in Agda. Itâ€™s a type with only one constructor, and it can only be constructed when its two arguments are the same. When we pattern match on the constructor, then, weâ€™re given a proof that whatever things those arguments refer to must be the same.</p>
<p>Next, we need to describe an order. For this, weâ€™ll need two types: the empty type, and the unit type.</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Void</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Unit</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="kw">where</span> <span class="dt">Unit</span><span class="ot"> ::</span> <span class="dt">Unit</span></a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb11"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">data</span> âŠ¥ <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2"><span class="kw">data</span> âŠ¤ <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span> âŸ¨âŸ© <span class="ot">:</span> âŠ¤</a></code></pre></div>
</div>
</div>
<p>These are kind of like type-level Bools, with one extra, powerful addition: they keep their proof after construction. Because <code class="sourceCode agda">âŠ¥</code> has no constructors, if someone tells you theyâ€™re going to give you one, you can be pretty sure theyâ€™re lying. How do we use this? Well, first, on the numbers:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">type</span> family (<span class="ot">n ::</span> <span class="dt">N</span>) <span class="fu">&lt;</span> (<span class="ot">m ::</span> <span class="dt">N</span>)</a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="ot">    ::</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">  x   <span class="fu">&lt;</span> <span class="dt">Z</span>   <span class="fu">=</span> <span class="dt">Void</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">  <span class="dt">Z</span>   <span class="fu">&lt;</span> <span class="dt">S</span> y <span class="fu">=</span> <span class="dt">Unit</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5">  <span class="dt">S</span> x <span class="fu">&lt;</span> <span class="dt">S</span> y <span class="fu">=</span> x <span class="fu">&lt;</span> y</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb13"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="ot">_</span>â„•&lt;<span class="ot">_</span> <span class="ot">:</span> â„• <span class="ot">â†’</span> â„• <span class="ot">â†’</span> <span class="dt">Set</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">x     â„•&lt; zero  <span class="ot">=</span> âŠ¥</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">zero  â„•&lt; suc y <span class="ot">=</span> âŠ¤</a>
<a class="sourceLine" id="cb13-4" data-line-number="4">suc x â„•&lt; suc y <span class="ot">=</span> x â„•&lt; y</a></code></pre></div>
</div>
</div>
<p>Therefore, if we ask for something of type <code class="sourceCode agda">x â„•&lt; y</code> (for some <code>x</code> and <code>y</code>), we know that it only exists when <code>x</code> really is less than <code>y</code> (according to the definition above).</p>
<p>For our actual code, weâ€™ll parameterize the whole thing over some abstract key type. Weâ€™ll do this using a module (a feature recently added to Haskell, as it happens). That might look something like this:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1">signature <span class="dt">Key</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2">  <span class="kw">import</span> <span class="dt">Data.Kind</span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3">  <span class="kw">data</span> <span class="dt">Key</span></a>
<a class="sourceLine" id="cb14-4" data-line-number="4">  <span class="kw">type</span> family (<span class="ot">n ::</span> <span class="dt">Key</span>) <span class="fu">&lt;</span> (<span class="ot">m ::</span> <span class="dt">Key</span>)</a>
<a class="sourceLine" id="cb14-5" data-line-number="5"><span class="ot">    ::</span> <span class="dt">Type</span></a>
<a class="sourceLine" id="cb14-6" data-line-number="6"></a>
<a class="sourceLine" id="cb14-7" data-line-number="7"><span class="kw">module</span> <span class="dt">AVL</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-8" data-line-number="8">  <span class="kw">import</span> <span class="dt">Key</span></a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb15"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="kw">module</span> AVL</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">  <span class="ot">{</span>k r<span class="ot">}</span> <span class="ot">(</span>Key <span class="ot">:</span> <span class="dt">Set</span> k<span class="ot">)</span></a>
<a class="sourceLine" id="cb15-3" data-line-number="3">  <span class="ot">{_</span>&lt;<span class="ot">_</span> <span class="ot">:</span> Rel Key r<span class="ot">}</span></a>
<a class="sourceLine" id="cb15-4" data-line-number="4">  <span class="ot">(</span>isStrictTotalOrder</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">   <span class="ot">:</span> IsStrictTotalOrder <span class="ot">_</span>â‰¡<span class="ot">_</span> <span class="ot">_</span>&lt;<span class="ot">_)</span></a>
<a class="sourceLine" id="cb15-6" data-line-number="6">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-7" data-line-number="7"></a>
<a class="sourceLine" id="cb15-8" data-line-number="8">  <span class="kw">open</span> IsStrictTotalOrder isStrictTotalOrder</a></code></pre></div>
</div>
</div>
<p>(the <code class="sourceCode agda">k</code> and <code class="sourceCode agda">r</code> here, as well as the <code class="sourceCode agda">Lift</code>ing noise below, are to do with Agdaâ€™s universe system, which Iâ€™ll try explain in a bit)</p>
<p>Now, the trick for the ordering is to keep a proof that two neighboring values are ordered correctly in the tree at each leaf (as thereâ€™s a leaf between every pair of nodes, this is exactly the place you <em>should</em> store such a proof). A problem arises with the extremal leaves in the tree (leftmost and rightmost): each leaf is missing one neighboring value, so how can it store a proof of order? The solution is to affix two elements to our key type which we define as the greatest and least elements of the set.</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"></a>
<a class="sourceLine" id="cb16-2" data-line-number="2"></a>
<a class="sourceLine" id="cb16-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Bound</span> <span class="fu">=</span> <span class="dt">LB</span> <span class="fu">|</span> <span class="dt">IB</span> <span class="dt">Key</span> <span class="fu">|</span> <span class="dt">UB</span></a>
<a class="sourceLine" id="cb16-4" data-line-number="4"></a>
<a class="sourceLine" id="cb16-5" data-line-number="5"></a>
<a class="sourceLine" id="cb16-6" data-line-number="6"></a>
<a class="sourceLine" id="cb16-7" data-line-number="7">infix <span class="dv">4</span> <span class="fu">&lt;:</span></a>
<a class="sourceLine" id="cb16-8" data-line-number="8"></a>
<a class="sourceLine" id="cb16-9" data-line-number="9"><span class="kw">type</span> family (<span class="ot">x ::</span> <span class="dt">Bound</span>) <span class="fu">&lt;:</span> (<span class="ot">y ::</span> <span class="dt">Bound</span>)</a>
<a class="sourceLine" id="cb16-10" data-line-number="10"><span class="ot">    ::</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-11" data-line-number="11">  <span class="dt">LB</span>   <span class="fu">&lt;:</span> <span class="dt">LB</span>   <span class="fu">=</span> <span class="dt">Void</span></a>
<a class="sourceLine" id="cb16-12" data-line-number="12">  <span class="dt">LB</span>   <span class="fu">&lt;:</span> <span class="dt">UB</span>   <span class="fu">=</span> <span class="dt">Unit</span></a>
<a class="sourceLine" id="cb16-13" data-line-number="13">  <span class="dt">LB</span>   <span class="fu">&lt;:</span> <span class="dt">IB</span> _ <span class="fu">=</span> <span class="dt">Unit</span></a>
<a class="sourceLine" id="cb16-14" data-line-number="14">  <span class="dt">UB</span>   <span class="fu">&lt;:</span> _    <span class="fu">=</span> <span class="dt">Void</span></a>
<a class="sourceLine" id="cb16-15" data-line-number="15">  <span class="dt">IB</span> _ <span class="fu">&lt;:</span> <span class="dt">LB</span>   <span class="fu">=</span> <span class="dt">Void</span></a>
<a class="sourceLine" id="cb16-16" data-line-number="16">  <span class="dt">IB</span> _ <span class="fu">&lt;:</span> <span class="dt">UB</span>   <span class="fu">=</span> <span class="dt">Unit</span></a>
<a class="sourceLine" id="cb16-17" data-line-number="17">  <span class="dt">IB</span> x <span class="fu">&lt;:</span> <span class="dt">IB</span> y <span class="fu">=</span> x <span class="fu">&lt;</span> y</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb17"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw">infix</span> <span class="dv">5</span> [<span class="ot">_</span>]</a>
<a class="sourceLine" id="cb17-2" data-line-number="2"></a>
<a class="sourceLine" id="cb17-3" data-line-number="3"><span class="kw">data</span> [âˆ™] <span class="ot">:</span> <span class="dt">Set</span> k <span class="kw">where</span></a>
<a class="sourceLine" id="cb17-4" data-line-number="4">  âŒŠâŒ‹ âŒˆâŒ‰ <span class="ot">:</span> [âˆ™]</a>
<a class="sourceLine" id="cb17-5" data-line-number="5">  [<span class="ot">_</span>]   <span class="ot">:</span> <span class="ot">(</span>k <span class="ot">:</span> Key<span class="ot">)</span> <span class="ot">â†’</span> [âˆ™]</a>
<a class="sourceLine" id="cb17-6" data-line-number="6"></a>
<a class="sourceLine" id="cb17-7" data-line-number="7"><span class="kw">infix</span> <span class="dv">4</span> <span class="ot">_</span>[&lt;]<span class="ot">_</span></a>
<a class="sourceLine" id="cb17-8" data-line-number="8"></a>
<a class="sourceLine" id="cb17-9" data-line-number="9"><span class="ot">_</span>[&lt;]<span class="ot">_</span> <span class="ot">:</span> [âˆ™] <span class="ot">â†’</span> [âˆ™] <span class="ot">â†’</span> <span class="dt">Set</span> r</a>
<a class="sourceLine" id="cb17-10" data-line-number="10">âŒŠâŒ‹     [&lt;] âŒŠâŒ‹    <span class="ot">=</span> Lift r âŠ¥</a>
<a class="sourceLine" id="cb17-11" data-line-number="11">âŒŠâŒ‹     [&lt;] âŒˆâŒ‰    <span class="ot">=</span> Lift r âŠ¤</a>
<a class="sourceLine" id="cb17-12" data-line-number="12">âŒŠâŒ‹     [&lt;] [ <span class="ot">_</span> ] <span class="ot">=</span> Lift r âŠ¤</a>
<a class="sourceLine" id="cb17-13" data-line-number="13">âŒˆâŒ‰     [&lt;] <span class="ot">_</span>     <span class="ot">=</span> Lift r âŠ¥</a>
<a class="sourceLine" id="cb17-14" data-line-number="14">[ <span class="ot">_</span> ]  [&lt;] âŒŠâŒ‹    <span class="ot">=</span> Lift r âŠ¥</a>
<a class="sourceLine" id="cb17-15" data-line-number="15">[ <span class="ot">_</span> ]  [&lt;] âŒˆâŒ‰    <span class="ot">=</span> Lift r âŠ¤</a>
<a class="sourceLine" id="cb17-16" data-line-number="16">[ x ]  [&lt;] [ y ] <span class="ot">=</span> x &lt; y</a></code></pre></div>
</div>
</div>
<h1 id="the-tree-type">The Tree Type</h1>
<p>After all that, we can get bring back Haskell into the story, and define or tree types:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"></a>
<a class="sourceLine" id="cb18-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Tree</span><span class="ot"> ::</span> <span class="dt">N</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3">          <span class="ot">-&gt;</span> <span class="dt">Type</span></a>
<a class="sourceLine" id="cb18-4" data-line-number="4">          <span class="ot">-&gt;</span> <span class="dt">Type</span></a>
<a class="sourceLine" id="cb18-5" data-line-number="5">          <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-6" data-line-number="6">  <span class="dt">Leaf</span><span class="ot"> ::</span> <span class="dt">Tree</span> <span class="dt">Z</span> k v</a>
<a class="sourceLine" id="cb18-7" data-line-number="7">  <span class="dt">Node</span><span class="ot"> ::</span> k</a>
<a class="sourceLine" id="cb18-8" data-line-number="8">       <span class="ot">-&gt;</span> v</a>
<a class="sourceLine" id="cb18-9" data-line-number="9">       <span class="ot">-&gt;</span> <span class="dt">Balance</span> lh rh h</a>
<a class="sourceLine" id="cb18-10" data-line-number="10">       <span class="ot">-&gt;</span> <span class="dt">Tree</span> lh k v</a>
<a class="sourceLine" id="cb18-11" data-line-number="11">       <span class="ot">-&gt;</span> <span class="dt">Tree</span> rh k v</a>
<a class="sourceLine" id="cb18-12" data-line-number="12">       <span class="ot">-&gt;</span> <span class="dt">Tree</span> (<span class="dt">S</span> h) k v</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb19"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="kw">data</span> Tree <span class="ot">{</span>v<span class="ot">}</span> </a>
<a class="sourceLine" id="cb19-2" data-line-number="2">          <span class="ot">(</span>V <span class="ot">:</span> Key <span class="ot">â†’</span> <span class="dt">Set</span> v<span class="ot">)</span></a>
<a class="sourceLine" id="cb19-3" data-line-number="3">          <span class="ot">(</span>l u <span class="ot">:</span> [âˆ™]<span class="ot">)</span> <span class="ot">:</span> â„• <span class="ot">â†’</span></a>
<a class="sourceLine" id="cb19-4" data-line-number="4">          <span class="dt">Set</span> <span class="ot">(</span>k âŠ” v âŠ” r<span class="ot">)</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-5" data-line-number="5">  leaf  <span class="ot">:</span> <span class="ot">(</span>l&lt;u <span class="ot">:</span> l [&lt;] u<span class="ot">)</span> <span class="ot">â†’</span> Tree V l u <span class="dv">0</span></a>
<a class="sourceLine" id="cb19-6" data-line-number="6">  node  <span class="ot">:</span> <span class="ot">âˆ€</span>  <span class="ot">{</span>h lh rh<span class="ot">}</span></a>
<a class="sourceLine" id="cb19-7" data-line-number="7">             <span class="ot">(</span>k <span class="ot">:</span> Key<span class="ot">)</span></a>
<a class="sourceLine" id="cb19-8" data-line-number="8">             <span class="ot">(</span>v <span class="ot">:</span> V k<span class="ot">)</span></a>
<a class="sourceLine" id="cb19-9" data-line-number="9">             <span class="ot">(</span>bl <span class="ot">:</span> âŸ¨ lh âŠ” rh âŸ©â‰¡ h<span class="ot">)</span></a>
<a class="sourceLine" id="cb19-10" data-line-number="10">             <span class="ot">(</span>lk <span class="ot">:</span> Tree V l [ k ] lh<span class="ot">)</span></a>
<a class="sourceLine" id="cb19-11" data-line-number="11">             <span class="ot">(</span>ku <span class="ot">:</span> Tree V [ k ] u rh<span class="ot">)</span> <span class="ot">â†’</span></a>
<a class="sourceLine" id="cb19-12" data-line-number="12">             Tree V l u <span class="ot">(</span>suc h<span class="ot">)</span></a></code></pre></div>
</div>
</div>
<p>The two definitions are similar, but have a few obvious differences. The Agda version stores the ordering proof at the leaves, as well as the bounds as indices. Its <a href="https://pigworker.wordpress.com/2015/01/09/universe-hierarchies/"><em>universe</em></a> is also different: briefly, universes are one of the ways to avoid Russellâ€™s paradox when youâ€™re dealing with dependent types.</p>
<p>In normal, standard Haskell, we think of types as things that describe values (how quaint!). When youâ€™ve got a list, everything in the list has the same type, and that is good and right.</p>
<p>These days, though, weâ€™re not so constrained:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:-</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2"><span class="kw">data</span> <span class="dt">List</span> xs <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-3" data-line-number="3">  <span class="dt">Nil</span><span class="ot">  ::</span> <span class="dt">List</span> <span class="ch">&#39;[]</span></a>
<a class="sourceLine" id="cb20-4" data-line-number="4"><span class="ot">  (:-) ::</span> x</a>
<a class="sourceLine" id="cb20-5" data-line-number="5">       <span class="ot">-&gt;</span> <span class="dt">List</span> xs</a>
<a class="sourceLine" id="cb20-6" data-line-number="6">       <span class="ot">-&gt;</span> <span class="dt">List</span> (x <span class="fu">:</span> xs)</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb21"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">5</span> <span class="ot">_</span>á¦<span class="ot">_</span></a>
<a class="sourceLine" id="cb21-2" data-line-number="2"><span class="kw">data</span> Listâ€² <span class="ot">:</span> List <span class="dt">Set</span> <span class="ot">â†’</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-3" data-line-number="3">  nil <span class="ot">:</span> Listâ€² []</a>
<a class="sourceLine" id="cb21-4" data-line-number="4">  <span class="ot">_</span>á¦<span class="ot">_</span> <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>x xs<span class="ot">}</span></a>
<a class="sourceLine" id="cb21-5" data-line-number="5">      <span class="ot">â†’</span> x </a>
<a class="sourceLine" id="cb21-6" data-line-number="6">      <span class="ot">â†’</span> Listâ€² xs </a>
<a class="sourceLine" id="cb21-7" data-line-number="7">      <span class="ot">â†’</span> Listâ€² <span class="ot">(</span>x âˆ· xs<span class="ot">)</span></a></code></pre></div>
</div>
</div>
<p>This can quite happily store elements of different types:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="ot">example ::</span> <span class="dt">List</span> [<span class="dt">Bool</span>, <span class="dt">String</span>, <span class="dt">Integer</span>]</a>
<a class="sourceLine" id="cb22-2" data-line-number="2">example <span class="fu">=</span> <span class="dt">True</span> <span class="fu">:-</span> <span class="st">&quot;true&quot;</span> <span class="fu">:-</span> <span class="dv">1</span> <span class="fu">:-</span> <span class="dt">Nil</span></a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb23"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb23-1" data-line-number="1">example <span class="ot">:</span> Listâ€² <span class="ot">(</span>Bool âˆ· String âˆ· â„• âˆ· []<span class="ot">)</span></a>
<a class="sourceLine" id="cb23-2" data-line-number="2">example <span class="ot">=</span> true á¦ <span class="st">&quot;true&quot;</span> á¦ <span class="dv">1</span> á¦ nil</a></code></pre></div>
</div>
</div>
<p>And look at that bizarre-looking list on the wrong side of â€œ<code class="sourceCode haskell"><span class="ot">::</span></code>â€! Types arenâ€™t just describing values, theyâ€™re acting like values themselves. What type does <code class="sourceCode haskell">[<span class="dt">Bool</span>, <span class="dt">String</span>, <span class="dt">Integer</span>]</code> even have, anyway? Why, <code class="sourceCode haskell">[<span class="dt">Type</span>]</code> of course!</p>
<p>So we see that types can be put in lists, and types have types: the natural question then is:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="dt">Type</span><span class="ot"> ::</span> <span class="fu">???</span></a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb25"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="dt">Set</span> <span class="ot">:</span> ???</a></code></pre></div>
</div>
</div>
<p>And this is where Haskell and Agda diverge: in Haskell, we say <code class="sourceCode haskell"><span class="dt">Type</span><span class="ot"> ::</span> <span class="dt">Type</span></code> (as the old extension <code class="sourceCode haskell"><span class="dt">TypeInType</span></code> implied), and thatâ€™s that. From a certain point of view, weâ€™ve opened the door to Russellâ€™s paradox (weâ€™ve allowed a set to be a member of itself). This isnâ€™t an issue in Haskell, though, as the type-level language was already inconsistent.</p>
<p>Agda goes another way, saying that <code class="sourceCode agda"><span class="dt">Set</span></code> (Agdaâ€™s equivalent for <code class="sourceCode haskell"><span class="dt">Type</span></code>) has the type <code class="sourceCode agda"><span class="dt">Setâ‚</span></code>, and <code class="sourceCode agda"><span class="dt">Setâ‚</span></code> has the type <code class="sourceCode agda"><span class="dt">Setâ‚‚</span></code>, and so on<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>. These different sets are called â€œuniversesâ€ and their numbers â€œlevelsâ€. When we write <code class="sourceCode agda">k âŠ” v âŠ” r</code>, weâ€™re saying we want to take the greatest universe level from those three possible levels: the level of the key, the value, and the relation, respectively.</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="dt">Type</span><span class="ot"> ::</span> <span class="dt">Type</span></a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb27"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="dt">Set</span> <span class="ot">:</span> <span class="dt">Setâ‚</span></a></code></pre></div>
</div>
</div>
<h1 id="rotations">Rotations</h1>
<p>AVL trees maintain their invariants through relatively simple rotations. Weâ€™ll start with the right rotation, which fixes an imbalance of two on the left. Because the size of the tree returned might change, weâ€™ll need to wrap it in a datatype:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1"><span class="kw">data</span><span class="ot"> (++?) ::</span> (<span class="dt">N</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>)</a>
<a class="sourceLine" id="cb28-2" data-line-number="2">           <span class="ot">-&gt;</span> (<span class="dt">N</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>)</a>
<a class="sourceLine" id="cb28-3" data-line-number="3">           <span class="kw">where</span></a>
<a class="sourceLine" id="cb28-4" data-line-number="4">  <span class="dt">Stay</span><span class="ot"> ::</span> t n     <span class="ot">-&gt;</span> t <span class="fu">++?</span> n</a>
<a class="sourceLine" id="cb28-5" data-line-number="5">  <span class="dt">Incr</span><span class="ot"> ::</span> t (<span class="dt">S</span> n) <span class="ot">-&gt;</span> t <span class="fu">++?</span> n</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb29"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb29-1" data-line-number="1"></a>
<a class="sourceLine" id="cb29-2" data-line-number="2"><span class="ot">_</span>1?+âŸ¨<span class="ot">_</span>âŸ© <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>ğ“<span class="ot">}</span> <span class="ot">(</span>T <span class="ot">:</span> â„• <span class="ot">â†’</span> <span class="dt">Set</span> ğ“<span class="ot">)</span> <span class="ot">â†’</span> â„• <span class="ot">â†’</span> <span class="dt">Set</span> ğ“</a>
<a class="sourceLine" id="cb29-3" data-line-number="3">T 1?+âŸ¨ n âŸ© <span class="ot">=</span> âˆƒ[ inc? ] T <span class="ot">(</span>if inc?</a>
<a class="sourceLine" id="cb29-4" data-line-number="4">                            then suc n</a>
<a class="sourceLine" id="cb29-5" data-line-number="5">                            else n<span class="ot">)</span></a>
<a class="sourceLine" id="cb29-6" data-line-number="6"></a>
<a class="sourceLine" id="cb29-7" data-line-number="7"><span class="kw">pattern</span> 0+<span class="ot">_</span> tr <span class="ot">=</span> false , tr</a>
<a class="sourceLine" id="cb29-8" data-line-number="8"><span class="kw">pattern</span> 1+<span class="ot">_</span> tr <span class="ot">=</span> true  , tr</a></code></pre></div>
</div>
</div>
<p>We could actually have the Agda definition be the same as Haskellâ€™s, it doesnâ€™t make much difference. Iâ€™m mainly using it here to demonstrate dependent pairs in Agda. The first member of the pair is just a boolean (increased in height/not increased in height). The second member is a tree whose height <em>depends</em> on the actual value of the boolean. The <code class="sourceCode agda">âˆƒ</code> business is just a fancy syntax; it also waggles its eyebrows at the way a (dependent) pair of type <code>(x , y)</code> means â€œThere exists an x such that yâ€.</p>
<p>Using this, we can write the type for right-rotation:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="ot">rotr ::</span> k</a>
<a class="sourceLine" id="cb30-2" data-line-number="2">     <span class="ot">-&gt;</span> v</a>
<a class="sourceLine" id="cb30-3" data-line-number="3">     <span class="ot">-&gt;</span> <span class="dt">Tree</span> (<span class="dt">S</span> (<span class="dt">S</span> rh)) k v</a>
<a class="sourceLine" id="cb30-4" data-line-number="4">     <span class="ot">-&gt;</span> <span class="dt">Tree</span> rh k v</a>
<a class="sourceLine" id="cb30-5" data-line-number="5">     <span class="ot">-&gt;</span> <span class="dt">Tree</span> k v <span class="fu">++?</span> <span class="dt">S</span> (<span class="dt">S</span> rh)</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb31"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb31-1" data-line-number="1">rotÊ³ <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>lb ub rh v<span class="ot">}</span> <span class="ot">{</span>V <span class="ot">:</span> Key <span class="ot">â†’</span> <span class="dt">Set</span> v<span class="ot">}</span></a>
<a class="sourceLine" id="cb31-2" data-line-number="2">     <span class="ot">â†’</span> <span class="ot">(</span>k <span class="ot">:</span> Key<span class="ot">)</span></a>
<a class="sourceLine" id="cb31-3" data-line-number="3">     <span class="ot">â†’</span> V k</a>
<a class="sourceLine" id="cb31-4" data-line-number="4">     <span class="ot">â†’</span> Tree V lb [ k ] <span class="ot">(</span>suc <span class="ot">(</span>suc rh<span class="ot">))</span></a>
<a class="sourceLine" id="cb31-5" data-line-number="5">     <span class="ot">â†’</span> Tree V [ k ] ub rh</a>
<a class="sourceLine" id="cb31-6" data-line-number="6">     <span class="ot">â†’</span> Tree V lb ub 1?+âŸ¨ suc <span class="ot">(</span>suc rh<span class="ot">)</span> âŸ©</a></code></pre></div>
</div>
</div>
<p>There are two possible cases, single rotation:</p>
<style>
.tree {
  margin: auto;
  width: 30%;
}
</style>
<div class="tree">
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" data-line-number="1">   â”Œa       â”Œa</a>
<a class="sourceLine" id="cb32-2" data-line-number="2"> â”Œyâ”¤       yâ”¤</a>
<a class="sourceLine" id="cb32-3" data-line-number="3"> â”‚ â””b <span class="fu">---&gt;</span>  â”‚ â”Œb</a>
<a class="sourceLine" id="cb32-4" data-line-number="4">xâ”¤          â””xâ”¤</a>
<a class="sourceLine" id="cb32-5" data-line-number="5"> â””c           â””c</a></code></pre></div>
</div>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" data-line-number="1">rotr x xv (<span class="dt">Node</span> y yv <span class="dt">L</span> a b) c <span class="fu">=</span></a>
<a class="sourceLine" id="cb33-2" data-line-number="2">  <span class="dt">Stay</span> (<span class="dt">Node</span> y yv <span class="dt">O</span> a (<span class="dt">Node</span> x xv <span class="dt">O</span> b c))</a>
<a class="sourceLine" id="cb33-3" data-line-number="3">rotr x xv (<span class="dt">Node</span> y yv <span class="dt">O</span> a b) c <span class="fu">=</span></a>
<a class="sourceLine" id="cb33-4" data-line-number="4">  <span class="dt">Incr</span> (<span class="dt">Node</span> y yv <span class="dt">R</span> a (<span class="dt">Node</span> x xv <span class="dt">L</span> b c))</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb34"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb34-1" data-line-number="1">rotÊ³ x xv <span class="ot">(</span>node y yv â—¿ a b<span class="ot">)</span> c <span class="ot">=</span></a>
<a class="sourceLine" id="cb34-2" data-line-number="2">  0+ <span class="ot">(</span>node y yv â–½ a <span class="ot">(</span>node x xv â–½  b c<span class="ot">))</span></a>
<a class="sourceLine" id="cb34-3" data-line-number="3">rotÊ³ x xv <span class="ot">(</span>node y yv â–½ a b<span class="ot">)</span> c <span class="ot">=</span></a>
<a class="sourceLine" id="cb34-4" data-line-number="4">  1+ <span class="ot">(</span>node y yv â—º a <span class="ot">(</span>node x xv â—¿  b c<span class="ot">))</span></a></code></pre></div>
</div>
</div>
<p>And double:</p>
<div class="tree">
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb35-1" data-line-number="1">   â”Œa           â”Œa</a>
<a class="sourceLine" id="cb35-2" data-line-number="2"> â”Œyâ”¤          â”Œyâ”¤</a>
<a class="sourceLine" id="cb35-3" data-line-number="3"> â”‚ â”‚ â”Œb       â”‚ â””b</a>
<a class="sourceLine" id="cb35-4" data-line-number="4"> â”‚ â””zâ”¤  <span class="fu">---&gt;</span> zâ”¤</a>
<a class="sourceLine" id="cb35-5" data-line-number="5"> â”‚   â””c       â”‚ â”Œc</a>
<a class="sourceLine" id="cb35-6" data-line-number="6">xâ”¤            â””xâ”¤</a>
<a class="sourceLine" id="cb35-7" data-line-number="7"> â””d             â””d</a></code></pre></div>
</div>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" data-line-number="1">rotr x xv (<span class="dt">Node</span> y yv <span class="dt">R</span> a </a>
<a class="sourceLine" id="cb36-2" data-line-number="2">            (<span class="dt">Node</span> z zv bl b c)) d <span class="fu">=</span></a>
<a class="sourceLine" id="cb36-3" data-line-number="3">  <span class="dt">Stay</span> (<span class="dt">Node</span> z zv <span class="dt">O</span> </a>
<a class="sourceLine" id="cb36-4" data-line-number="4">         (<span class="dt">Node</span> y yv (balr bl) a b)</a>
<a class="sourceLine" id="cb36-5" data-line-number="5">         (<span class="dt">Node</span> x xv (ball bl) c d))</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb37"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb37-1" data-line-number="1">rotÊ³ x xv <span class="ot">(</span>node y yv â—º  a</a>
<a class="sourceLine" id="cb37-2" data-line-number="2">            <span class="ot">(</span>node z zv bl b c<span class="ot">))</span> d <span class="ot">=</span></a>
<a class="sourceLine" id="cb37-3" data-line-number="3">  0+ <span class="ot">(</span>node z zv â–½</a>
<a class="sourceLine" id="cb37-4" data-line-number="4">       <span class="ot">(</span>node y yv <span class="ot">(</span>âƒ• bl<span class="ot">)</span> a b<span class="ot">)</span></a>
<a class="sourceLine" id="cb37-5" data-line-number="5">       <span class="ot">(</span>node x xv <span class="ot">(</span>âƒ” bl<span class="ot">)</span> c d<span class="ot">))</span></a></code></pre></div>
</div>
</div>
<p>I wonâ€™t bore you with left-rotation: suffice to say, itâ€™s the opposite of right-rotation.</p>
<h1 id="insertion">Insertion</h1>
<p>Finally, the main event: insertion. Once the above functions have all been defined, itâ€™s not very difficult, as it happens: by and large, the types guide you to the right answer. Of course, this is only after we decided to use the pivotal pragmatism and balance approach.</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb38-1" data-line-number="1">insertWith</a>
<a class="sourceLine" id="cb38-2" data-line-number="2"><span class="ot">    ::</span> <span class="dt">Ord</span> k</a>
<a class="sourceLine" id="cb38-3" data-line-number="3">    <span class="ot">=&gt;</span> (v <span class="ot">-&gt;</span> v <span class="ot">-&gt;</span> v)</a>
<a class="sourceLine" id="cb38-4" data-line-number="4">    <span class="ot">-&gt;</span> k</a>
<a class="sourceLine" id="cb38-5" data-line-number="5">    <span class="ot">-&gt;</span> v</a>
<a class="sourceLine" id="cb38-6" data-line-number="6">    <span class="ot">-&gt;</span> <span class="dt">Tree</span> h k v</a>
<a class="sourceLine" id="cb38-7" data-line-number="7">    <span class="ot">-&gt;</span> <span class="dt">Tree</span> k v <span class="fu">++?</span> h</a>
<a class="sourceLine" id="cb38-8" data-line-number="8">insertWith _ v vc <span class="dt">Leaf</span> <span class="fu">=</span></a>
<a class="sourceLine" id="cb38-9" data-line-number="9">  <span class="dt">Incr</span> (<span class="dt">Node</span> v vc <span class="dt">O</span> <span class="dt">Leaf</span> <span class="dt">Leaf</span>)</a>
<a class="sourceLine" id="cb38-10" data-line-number="10">insertWith f v vc (<span class="dt">Node</span> k kc bl tl tr) <span class="fu">=</span></a>
<a class="sourceLine" id="cb38-11" data-line-number="11">  <span class="kw">case</span> compare v k <span class="kw">of</span></a>
<a class="sourceLine" id="cb38-12" data-line-number="12">    <span class="dt">LT</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb38-13" data-line-number="13">      <span class="kw">case</span> insertWith f v vc tl <span class="kw">of</span></a>
<a class="sourceLine" id="cb38-14" data-line-number="14">        <span class="dt">Stay</span> tl&#39; <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb38-15" data-line-number="15">          <span class="dt">Stay</span> (<span class="dt">Node</span> k kc bl tl&#39; tr)</a>
<a class="sourceLine" id="cb38-16" data-line-number="16">        <span class="dt">Incr</span> tl&#39; <span class="ot">-&gt;</span> <span class="kw">case</span> bl <span class="kw">of</span></a>
<a class="sourceLine" id="cb38-17" data-line-number="17">          <span class="dt">L</span> <span class="ot">-&gt;</span> rotr k kc tl&#39; tr</a>
<a class="sourceLine" id="cb38-18" data-line-number="18">          <span class="dt">O</span> <span class="ot">-&gt;</span> <span class="dt">Incr</span> (<span class="dt">Node</span> k kc <span class="dt">L</span> tl&#39; tr)</a>
<a class="sourceLine" id="cb38-19" data-line-number="19">          <span class="dt">R</span> <span class="ot">-&gt;</span> <span class="dt">Stay</span> (<span class="dt">Node</span> k kc <span class="dt">O</span> tl&#39; tr)</a>
<a class="sourceLine" id="cb38-20" data-line-number="20">    <span class="dt">EQ</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb38-21" data-line-number="21">      <span class="dt">Stay</span> (<span class="dt">Node</span> v (f vc kc) bl tl tr)</a>
<a class="sourceLine" id="cb38-22" data-line-number="22">    <span class="dt">GT</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb38-23" data-line-number="23">      <span class="kw">case</span> insertWith f v vc tr <span class="kw">of</span></a>
<a class="sourceLine" id="cb38-24" data-line-number="24">        <span class="dt">Stay</span> tr&#39; <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb38-25" data-line-number="25">          <span class="dt">Stay</span> (<span class="dt">Node</span> k kc bl tl tr&#39;)</a>
<a class="sourceLine" id="cb38-26" data-line-number="26">        <span class="dt">Incr</span> tr&#39; <span class="ot">-&gt;</span> <span class="kw">case</span> bl <span class="kw">of</span></a>
<a class="sourceLine" id="cb38-27" data-line-number="27">          <span class="dt">L</span> <span class="ot">-&gt;</span> <span class="dt">Stay</span> (<span class="dt">Node</span> k kc <span class="dt">O</span> tl tr&#39;)</a>
<a class="sourceLine" id="cb38-28" data-line-number="28">          <span class="dt">O</span> <span class="ot">-&gt;</span> <span class="dt">Incr</span> (<span class="dt">Node</span> k kc <span class="dt">R</span> tl tr&#39;)</a>
<a class="sourceLine" id="cb38-29" data-line-number="29">          <span class="dt">R</span> <span class="ot">-&gt;</span> rotl k kc tl tr&#39;</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb39"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb39-1" data-line-number="1">insert <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>l u h v<span class="ot">}</span></a>
<a class="sourceLine" id="cb39-2" data-line-number="2">           <span class="ot">{</span>V <span class="ot">:</span> Key <span class="ot">â†’</span> <span class="dt">Set</span> v<span class="ot">}</span></a>
<a class="sourceLine" id="cb39-3" data-line-number="3">           <span class="ot">(</span>k <span class="ot">:</span> Key<span class="ot">)</span></a>
<a class="sourceLine" id="cb39-4" data-line-number="4">       <span class="ot">â†’</span> V k</a>
<a class="sourceLine" id="cb39-5" data-line-number="5">       <span class="ot">â†’</span> <span class="ot">(</span>V k <span class="ot">â†’</span> V k <span class="ot">â†’</span> V k<span class="ot">)</span></a>
<a class="sourceLine" id="cb39-6" data-line-number="6">       <span class="ot">â†’</span> Tree V l u h</a>
<a class="sourceLine" id="cb39-7" data-line-number="7">       <span class="ot">â†’</span> l &lt; k &lt; u</a>
<a class="sourceLine" id="cb39-8" data-line-number="8">       <span class="ot">â†’</span> Tree V l u 1?+âŸ¨ h âŸ©</a>
<a class="sourceLine" id="cb39-9" data-line-number="9">insert v vc f <span class="ot">(</span>leaf l&lt;u<span class="ot">)</span> <span class="ot">(</span>l , u<span class="ot">)</span> <span class="ot">=</span></a>
<a class="sourceLine" id="cb39-10" data-line-number="10">  1+ <span class="ot">(</span>node v vc â–½ <span class="ot">(</span>leaf l<span class="ot">)</span> <span class="ot">(</span>leaf u<span class="ot">))</span></a>
<a class="sourceLine" id="cb39-11" data-line-number="11">insert v vc f <span class="ot">(</span>node k kc bl tl tr<span class="ot">)</span> prf</a>
<a class="sourceLine" id="cb39-12" data-line-number="12">  <span class="kw">with</span> compare v k</a>
<a class="sourceLine" id="cb39-13" data-line-number="13">insert v vc f <span class="ot">(</span>node k kc bl tl tr<span class="ot">)</span> <span class="ot">(</span>l , <span class="ot">_)</span></a>
<a class="sourceLine" id="cb39-14" data-line-number="14">    <span class="ot">|</span> tri&lt; a <span class="ot">_</span> <span class="ot">_</span> <span class="kw">with</span> insert v vc f tl <span class="ot">(</span>l , a<span class="ot">)</span></a>
<a class="sourceLine" id="cb39-15" data-line-number="15"><span class="ot">...</span> <span class="ot">|</span> 0+ tlâ€² <span class="ot">=</span> 0+ <span class="ot">(</span>node k kc bl tlâ€² tr<span class="ot">)</span></a>
<a class="sourceLine" id="cb39-16" data-line-number="16"><span class="ot">...</span> <span class="ot">|</span> 1+ tlâ€² <span class="kw">with</span> bl</a>
<a class="sourceLine" id="cb39-17" data-line-number="17"><span class="ot">...</span> <span class="ot">|</span> â—¿ <span class="ot">=</span> rotÊ³ k kc tlâ€² tr</a>
<a class="sourceLine" id="cb39-18" data-line-number="18"><span class="ot">...</span> <span class="ot">|</span> â–½ <span class="ot">=</span> 1+ <span class="ot">(</span>node k kc  â—¿  tlâ€² tr<span class="ot">)</span></a>
<a class="sourceLine" id="cb39-19" data-line-number="19"><span class="ot">...</span> <span class="ot">|</span> â—º <span class="ot">=</span> 0+ <span class="ot">(</span>node k kc  â–½  tlâ€² tr<span class="ot">)</span></a>
<a class="sourceLine" id="cb39-20" data-line-number="20">insert v vc f <span class="ot">(</span>node k kc bl tl tr<span class="ot">)</span> <span class="ot">_</span></a>
<a class="sourceLine" id="cb39-21" data-line-number="21">    <span class="ot">|</span> triâ‰ˆ <span class="ot">_</span> refl <span class="ot">_</span> <span class="ot">=</span></a>
<a class="sourceLine" id="cb39-22" data-line-number="22">        0+ <span class="ot">(</span>node k <span class="ot">(</span>f vc kc<span class="ot">)</span> bl tl tr<span class="ot">)</span></a>
<a class="sourceLine" id="cb39-23" data-line-number="23">insert v vc f <span class="ot">(</span>node k kc bl tl tr<span class="ot">)</span> <span class="ot">(_</span> , u<span class="ot">)</span></a>
<a class="sourceLine" id="cb39-24" data-line-number="24">    <span class="ot">|</span> tri&gt; <span class="ot">_</span> <span class="ot">_</span> c <span class="kw">with</span> insert v vc f tr <span class="ot">(</span>c , u<span class="ot">)</span></a>
<a class="sourceLine" id="cb39-25" data-line-number="25"><span class="ot">...</span> <span class="ot">|</span> 0+ trâ€² <span class="ot">=</span> 0+ <span class="ot">(</span>node k kc bl tl trâ€²<span class="ot">)</span></a>
<a class="sourceLine" id="cb39-26" data-line-number="26"><span class="ot">...</span> <span class="ot">|</span> 1+ trâ€² <span class="kw">with</span> bl</a>
<a class="sourceLine" id="cb39-27" data-line-number="27"><span class="ot">...</span> <span class="ot">|</span> â—¿ <span class="ot">=</span> 0+ <span class="ot">(</span>node k kc â–½ tl trâ€²<span class="ot">)</span></a>
<a class="sourceLine" id="cb39-28" data-line-number="28"><span class="ot">...</span> <span class="ot">|</span> â–½ <span class="ot">=</span> 1+ <span class="ot">(</span>node k kc â—º tl trâ€²<span class="ot">)</span></a>
<a class="sourceLine" id="cb39-29" data-line-number="29"><span class="ot">...</span> <span class="ot">|</span> â—º <span class="ot">=</span> rotË¡ k kc tl trâ€²</a></code></pre></div>
</div>
</div>
<h1 id="conclusion">Conclusion</h1>
<p>Overall, Iâ€™ve been enjoying programming in Agda. The things I liked and didnâ€™t like surprised me:</p>
<dl>
<dt>Editor Support</dt>
<dd><p>Is excellent. I use <a href="http://spacemacs.org">spacemacs</a>, and the whole thing worked pretty seamlessly. Proof search and auto was maybe not as powerful as Idrisâ€™, although that might be down to lack of experience (noteâ€”as I write this, I see you can enable case-splitting in proof search, so it looks like I was right about my lack of experience). In many ways, it was much better than Haskellâ€™s editor support: personally, I have never managed to get case-splitting to work in my Haskell setup, never mind some of the fancier features that you get in Agda.</p>
<p>Itâ€™s worth noting that my experience with Idris is similar: maybe itâ€™s something about dependent types?</p>
<p>Of course, I missed lots of extra tools, like linters, code formatters, etc., but the tight integration with the compiler was so useful it more than made up for it.</p>
<p>Also, Iâ€™d implore anyone whoâ€™s had trouble with emacs before to give <a href="http://spacemacs.org">spacemacs</a> a go. It works well out-of-the-box, and has a system for keybinding discovery that <em>actually works</em>.</p>
</dd>
<dt>Documentation</dt>
<dd><p>Pretty good, considering. There are some missing parts (<a href="https://agda.readthedocs.io/en/v2.5.4.1/language/rewriting.html">rewriting</a> and <a href="https://agda.readthedocs.io/en/v2.5.4.1/language/telescopes.html">telescopes</a> are both stubs on the documentation site), but there seemed to be more fully worked-out examples available online for different concepts when I needed to figure them out.</p>
</dd>
</dl>
<p>Now, the thing about a lot of these complaints/commendations (<em>especially</em> with regards to tooling and personal setups) is that people tend to be pretty bad about evaluating how difficult finicky tasks like editor setups are. Once youâ€™ve gotten the hang of some of this stuff, you forget that you ever didnâ€™t. Agda is the second dependently-typed language Iâ€™ve really gone for a deepish dive on, and Iâ€™ve been using spacemacs for a while, so YMMV.</p>
<p>One area of the language itself that I would have liked to see more on was irrelevance. Looking back at the definition of the tree type, in the Haskell version thereâ€™s no singleton storing the height (the balance type stores all the information we need), which means that it definitely doesnâ€™t exist at runtime. As I understand it, that implies that the type should be irrelevant in the equivalent Agda. However, when I actually mark it as irrelevant, everything works fine, except that missing cases warnings start showing up. I couldnâ€™t figure out why: Haskell was able to infer full case coverage without the index, after all. Equality proof erasure, also: is it safe? Consistent?</p>
<p>All in all, Iâ€™d encourage more Haskellers to give Agda a try. Itâ€™s fun, interesting, and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="script"><mi>ğ’°</mi><mi>ğ“ƒ</mi><mi>ğ’¾</mi><mi>ğ’¸</mi><mi>â„´</mi><mi>ğ’¹</mi><mi>â„¯</mi></mstyle><annotation encoding="application/x-tex">\mathcal{Unicode}</annotation></semantics></math>!</p>
<h1 id="further-reading">Further Reading</h1>
<p>No â€œdeletion is left as an exercise to the readerâ€ here, no sir! Fuller implementations of both the Haskell and Agda versions of the code here are available: first, a pdf of the Agda code with lovely colours is <a href="/pdfs/AVL.pdf">here</a>. The accompanying repository is <a href="https://github.com/oisdk/agda-avl">here</a>, and the equivalent for the Haskell code is <a href="https://github.com/oisdk/verified-avl">here</a>. Of course, if you would rather read something by someone who knows what theyâ€™re talking about, please see the</p>
<h1 id="references" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-danielsson_agda_2018">
<p>Danielsson, Nils Anders. 2018. â€œThe Agda standard library.â€</p>
</div>
<div id="ref-mcbride_how_2014">
<p>McBride, Conor Thomas. 2014. â€œHow to Keep Your Neighbours in Order.â€ In <em>Proceedings of the 19th ACM SIGPLAN International Conference on Functional Programming</em>, 297â€“309. ICFP â€™14. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/2628136.2628163">10.1145/2628136.2628163</a>.</p>
</div>
<div id="ref-pfaff_performance_2004">
<p>Pfaff, Ben. 2004. â€œPerformance Analysis of BSTs in System Software.â€ In <em>Proceedings of the Joint International Conference on Measurement and Modeling of Computer Systems</em>, 410â€“411. SIGMETRICS â€™04/Performance â€™04. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/1005686.1005742">10.1145/1005686.1005742</a>.</p>
</div>
<div id="ref-weirich_depending_2014">
<p>Weirich, Stephanie. 2014. â€œDepending on Types.â€ In <em>Proceedings of the 19th ACM SIGPLAN International Conference on Functional Programming</em>, 241â€“241. ICFP â€™14. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/2628136.2631168">10.1145/2628136.2631168</a>.</p>
</div>
</div>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>My phrasing is maybe a little confusing here. When <code class="sourceCode haskell"><span class="dt">Set</span></code> â€œhas the typeâ€ <code class="sourceCode agda"><span class="dt">Setâ‚</span></code> it means that <code class="sourceCode haskell"><span class="dt">Set</span></code> is <em>in</em> <code class="sourceCode agda"><span class="dt">Setâ‚</span></code>, not the other way around.<a href="#fnref1" class="footnote-back">â†©</a></p></li>
</ol>
</section>
]]></description>
    <pubDate>Mon, 30 Jul 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-07-30-verified-avl.html</guid>
    <dc:creator>Donnacha OisÃ­n Kidney</dc:creator>
</item>
<item>
    <title>Probabilistic Functional Programming</title>
    <link>https://doisinkidney.com/posts/2018-07-17-probability-presentation.html</link>
    <description><![CDATA[<div class="info">
    Posted on July 17, 2018
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Probability.html">Probability</a>
    
</div>

<p><a href="/pdfs/prob-presentation.pdf">Here</a> are the slides for a short talk I gave to a reading group Iâ€™m in at Harvard today. The speaker notes are included in the pdf, code and the tex is available in the <a href="https://github.com/oisdk/prob-presentation">repository</a>.</p>
]]></description>
    <pubDate>Tue, 17 Jul 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-07-17-probability-presentation.html</guid>
    <dc:creator>Donnacha OisÃ­n Kidney</dc:creator>
</item>
<item>
    <title>Probability 5 Ways</title>
    <link>https://doisinkidney.com/posts/2018-06-30-probability-5-ways.html</link>
    <description><![CDATA[<div class="info">
    Posted on June 30, 2018
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Probability.html">Probability</a>, <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<p>Ever since the famous pearl by <span class="citation" data-cites="erwig_functional_2006">Erwig and Kollmansberger (<a href="#ref-erwig_functional_2006">2006</a>)</span>, probabilistic programming with monads has been an interesting and diverse area in functional programming, with many different approaches.</p>
<p>Iâ€™m going to present five here, some of which I have not seen before.</p>
<h1 id="the-classic">The Classic</h1>
<p>As presented in the paper, a simple and elegant formulation of probability distributions looks like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Prob</span> a</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Prob</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">    {<span class="ot"> runProb ::</span> [(a, <span class="dt">Rational</span>)]</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">    }</a></code></pre></div>
<p>Itâ€™s a list of possible events, each tagged with their probability of happening. Hereâ€™s the probability distribution representing a die roll, for instance:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">die ::</span> <span class="dt">Prob</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">die <span class="fu">=</span> [ (x, <span class="dv">1</span><span class="fu">/</span><span class="dv">6</span>) <span class="fu">|</span> x <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span><span class="dv">6</span>] ]</a></code></pre></div>
<p>The semantics can afford to be a little fuzzy: it doesnâ€™t hugely matter if the probabilities donâ€™t add up to 1 (you can still extract meaningful answers when they donâ€™t). However, I canâ€™t see a way in which either negative probabilities or an empty list would make sense. It would be nice if those states were unrepresentable.</p>
<p>Its monadic structure multiplies conditional events:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Prob</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">    fmap f xs <span class="fu">=</span> <span class="dt">Prob</span> [ (f x, p) <span class="fu">|</span> (x,p) <span class="ot">&lt;-</span> runProb xs ]</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">    </a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Prob</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">    pure x <span class="fu">=</span> <span class="dt">Prob</span> [(x,<span class="dv">1</span>)]</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">    fs <span class="fu">&lt;*&gt;</span> xs</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">        <span class="fu">=</span> <span class="dt">Prob</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8">        [ (f x,fp<span class="fu">*</span>xp)</a>
<a class="sourceLine" id="cb3-9" data-line-number="9">        <span class="fu">|</span> (f,fp) <span class="ot">&lt;-</span> runProb fs</a>
<a class="sourceLine" id="cb3-10" data-line-number="10">        , (x,xp) <span class="ot">&lt;-</span> runProb xs ]</a>
<a class="sourceLine" id="cb3-11" data-line-number="11">                     </a>
<a class="sourceLine" id="cb3-12" data-line-number="12"><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Prob</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-13" data-line-number="13">    xs <span class="fu">&gt;&gt;=</span> f</a>
<a class="sourceLine" id="cb3-14" data-line-number="14">        <span class="fu">=</span> <span class="dt">Prob</span></a>
<a class="sourceLine" id="cb3-15" data-line-number="15">        [ (y,xp<span class="fu">*</span>yp)</a>
<a class="sourceLine" id="cb3-16" data-line-number="16">        <span class="fu">|</span> (x,xp) <span class="ot">&lt;-</span> runProb xs</a>
<a class="sourceLine" id="cb3-17" data-line-number="17">        , (y,yp) <span class="ot">&lt;-</span> runProb (f x) ]</a></code></pre></div>
<p>In most of the examples, weâ€™ll need a few extra functions in order for the types to be useful. First is support:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">support ::</span> <span class="dt">Prob</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">support <span class="fu">=</span> fmap fst <span class="fu">.</span> runProb</a></code></pre></div>
<p>And second is expectation:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">expect ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Rational</span>) <span class="ot">-&gt;</span> <span class="dt">Prob</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">expect p xs <span class="fu">=</span> sum [ p x <span class="fu">*</span> xp <span class="fu">|</span> (x,xp) <span class="ot">&lt;-</span> runProb xs ]</a>
<a class="sourceLine" id="cb5-3" data-line-number="3"></a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="ot">probOf ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Prob</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">probOf p <span class="fu">=</span> expect (bool <span class="dv">0</span> <span class="dv">1</span> <span class="fu">.</span> p)</a></code></pre></div>
<p>Itâ€™s useful to be able to construct uniform distributions:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1">uniform xs <span class="fu">=</span> <span class="dt">Prob</span> [ (x,n) <span class="fu">|</span> x <span class="ot">&lt;-</span> xs ]</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">    n <span class="fu">=</span> <span class="dv">1</span> <span class="fu">%</span> toEnum (length xs)</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">    </a>
<a class="sourceLine" id="cb6-5" data-line-number="5">die <span class="fu">=</span> uniform [<span class="dv">1</span><span class="fu">..</span><span class="dv">6</span>]</a>
<a class="sourceLine" id="cb6-6" data-line-number="6"></a>
<a class="sourceLine" id="cb6-7" data-line-number="7"><span class="fu">&gt;&gt;&gt;</span> probOf (<span class="dv">7</span><span class="fu">==</span>) <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">  x <span class="ot">&lt;-</span> die</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">  y <span class="ot">&lt;-</span> die</a>
<a class="sourceLine" id="cb6-10" data-line-number="10">  pure (x<span class="fu">+</span>y)</a>
<a class="sourceLine" id="cb6-11" data-line-number="11"><span class="dv">1</span> <span class="fu">%</span> <span class="dv">6</span></a></code></pre></div>
<h1 id="the-bells-and-whistles">The Bells and Whistles</h1>
<p>As elegant as the above approach is, it leaves something to be desired when it comes to efficiency. In particular, youâ€™ll see a combinatorial explosion at every step. To demonstrate, letâ€™s take the example above, using three-sided dice instead so it doesnâ€™t take up too much space.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1">die <span class="fu">=</span> uniform [<span class="dv">1</span><span class="fu">..</span><span class="dv">3</span>]</a>
<a class="sourceLine" id="cb7-2" data-line-number="2"></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">example <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">  x <span class="ot">&lt;-</span> die</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">  y <span class="ot">&lt;-</span> die</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">  pure (x<span class="fu">+</span>y)</a></code></pre></div>
<p>The probability table looks like this:</p>
<pre class="center"><code>2 1/9
3 2/9
4 1/3
5 2/9
6 1/9</code></pre>
<p>But the internal representation looks like this:</p>
<pre><code>2 1/9
3 1/9
4 1/9
3 1/9
4 1/9
5 1/9
4 1/9
5 1/9
6 1/9</code></pre>
<p>States are duplicated, because the implementation has no way of knowing that two outcomes are the same. We could collapse equivalent outcomes if we used a <code class="sourceCode haskell"><span class="dt">Map</span></code>, but then we canâ€™t implement <code class="sourceCode haskell"><span class="dt">Functor</span></code>, <code class="sourceCode haskell"><span class="dt">Applicative</span></code>, or <code class="sourceCode haskell"><span class="dt">Monad</span></code>. The types:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="ot">    fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</a>
<a class="sourceLine" id="cb10-3" data-line-number="3"></a>
<a class="sourceLine" id="cb10-4" data-line-number="4"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Applicative</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-5" data-line-number="5"><span class="ot">    pure ::</span> a <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb10-6" data-line-number="6"><span class="ot">    (&lt;*&gt;) ::</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</a>
<a class="sourceLine" id="cb10-7" data-line-number="7"></a>
<a class="sourceLine" id="cb10-8" data-line-number="8"><span class="kw">class</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">Monad</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-9" data-line-number="9"><span class="ot">    (&gt;&gt;=) ::</span> f a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> f b</a></code></pre></div>
<p>Donâ€™t allow an <code class="sourceCode haskell"><span class="dt">Ord</span></code> constraint, which is what weâ€™d need to remove duplicates. We can instead make our own classes which <em>do</em> allow constraints:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">{-# LANGUAGE RebindableSyntax #-}</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2"><span class="ot">{-# LANGUAGE TypeFamilies     #-}</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3"></a>
<a class="sourceLine" id="cb11-4" data-line-number="4"><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (<span class="dt">Functor</span>(..),<span class="dt">Applicative</span>(..),<span class="dt">Monad</span>(..))</a>
<a class="sourceLine" id="cb11-5" data-line-number="5"></a>
<a class="sourceLine" id="cb11-6" data-line-number="6"><span class="kw">import</span> <span class="dt">Data.Kind</span></a>
<a class="sourceLine" id="cb11-7" data-line-number="7"></a>
<a class="sourceLine" id="cb11-8" data-line-number="8"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-9" data-line-number="9">    <span class="kw">type</span> <span class="dt">Domain</span> f<span class="ot"> a ::</span> <span class="dt">Constraint</span></a>
<a class="sourceLine" id="cb11-10" data-line-number="10">    <span class="kw">type</span> <span class="dt">Domain</span> f a <span class="fu">=</span> ()</a>
<a class="sourceLine" id="cb11-11" data-line-number="11"><span class="ot">    fmap ::</span> <span class="dt">Domain</span> f b <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</a>
<a class="sourceLine" id="cb11-12" data-line-number="12"></a>
<a class="sourceLine" id="cb11-13" data-line-number="13"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Applicative</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-14" data-line-number="14">    <span class="ot">{-# MINIMAL pure, liftA2 #-}</span></a>
<a class="sourceLine" id="cb11-15" data-line-number="15"><span class="ot">    pure   ::</span> <span class="dt">Domain</span> f a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb11-16" data-line-number="16"><span class="ot">    liftA2 ::</span> <span class="dt">Domain</span> f c <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f c</a>
<a class="sourceLine" id="cb11-17" data-line-number="17">    </a>
<a class="sourceLine" id="cb11-18" data-line-number="18"><span class="ot">    (&lt;*&gt;) ::</span> <span class="dt">Domain</span> f b <span class="ot">=&gt;</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</a>
<a class="sourceLine" id="cb11-19" data-line-number="19">    (<span class="fu">&lt;*&gt;</span>) <span class="fu">=</span> liftA2 (<span class="fu">$</span>) </a>
<a class="sourceLine" id="cb11-20" data-line-number="20"></a>
<a class="sourceLine" id="cb11-21" data-line-number="21"><span class="kw">class</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">Monad</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-22" data-line-number="22"><span class="ot">    (&gt;&gt;=) ::</span> <span class="dt">Domain</span> f b <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> f b</a>
<a class="sourceLine" id="cb11-23" data-line-number="23"></a>
<a class="sourceLine" id="cb11-24" data-line-number="24">fail<span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb11-25" data-line-number="25">fail <span class="fu">=</span> error</a>
<a class="sourceLine" id="cb11-26" data-line-number="26"></a>
<a class="sourceLine" id="cb11-27" data-line-number="27">return<span class="ot"> ::</span> (<span class="dt">Applicative</span> f, <span class="dt">Domain</span> f a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb11-28" data-line-number="28">return <span class="fu">=</span> pure</a></code></pre></div>
<p>This setup gets over a couple common annoyances in Haskell, like making <a href="http://hackage.haskell.org/package/containers-0.6.0.1/docs/Data-Set.html"><code class="sourceCode haskell"><span class="dt">Data.Set</span></code></a> a Monad:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">    <span class="kw">type</span> <span class="dt">Domain</span> <span class="dt">Set</span> a <span class="fu">=</span> <span class="dt">Ord</span> a</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">    fmap <span class="fu">=</span> Set.map</a>
<a class="sourceLine" id="cb12-4" data-line-number="4"></a>
<a class="sourceLine" id="cb12-5" data-line-number="5"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-6" data-line-number="6">    pure <span class="fu">=</span> Set.singleton</a>
<a class="sourceLine" id="cb12-7" data-line-number="7">    liftA2 f xs ys <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb12-8" data-line-number="8">        x <span class="ot">&lt;-</span> xs</a>
<a class="sourceLine" id="cb12-9" data-line-number="9">        y <span class="ot">&lt;-</span> ys</a>
<a class="sourceLine" id="cb12-10" data-line-number="10">        pure (f x y)</a>
<a class="sourceLine" id="cb12-11" data-line-number="11"></a>
<a class="sourceLine" id="cb12-12" data-line-number="12"><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-13" data-line-number="13">    (<span class="fu">&gt;&gt;=</span>) <span class="fu">=</span> flip foldMap</a></code></pre></div>
<p>And, of course, the probability monad:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Prob</span> a <span class="fu">=</span> <span class="dt">Prob</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">    {<span class="ot"> runProb ::</span> <span class="dt">Map</span> a <span class="dt">Rational</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">    }</a>
<a class="sourceLine" id="cb13-4" data-line-number="4"></a>
<a class="sourceLine" id="cb13-5" data-line-number="5"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Prob</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-6" data-line-number="6">    <span class="kw">type</span> <span class="dt">Domain</span> <span class="dt">Prob</span> a <span class="fu">=</span> <span class="dt">Ord</span> a</a>
<a class="sourceLine" id="cb13-7" data-line-number="7">    fmap f <span class="fu">=</span> <span class="dt">Prob</span> <span class="fu">.</span> Map.mapKeysWith (<span class="fu">+</span>) f <span class="fu">.</span> runProb</a>
<a class="sourceLine" id="cb13-8" data-line-number="8"></a>
<a class="sourceLine" id="cb13-9" data-line-number="9"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Prob</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-10" data-line-number="10">    pure x <span class="fu">=</span> <span class="dt">Prob</span> (Map.singleton x <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb13-11" data-line-number="11">    liftA2 f xs ys <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb13-12" data-line-number="12">      x <span class="ot">&lt;-</span> xs</a>
<a class="sourceLine" id="cb13-13" data-line-number="13">      y <span class="ot">&lt;-</span> ys</a>
<a class="sourceLine" id="cb13-14" data-line-number="14">      pure (f x y)</a>
<a class="sourceLine" id="cb13-15" data-line-number="15">      </a>
<a class="sourceLine" id="cb13-16" data-line-number="16"><span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Prob</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-17" data-line-number="17">    mempty <span class="fu">=</span> <span class="dt">Prob</span> Map.empty</a>
<a class="sourceLine" id="cb13-18" data-line-number="18">    mappend (<span class="dt">Prob</span> xs) (<span class="dt">Prob</span> ys) <span class="fu">=</span> <span class="dt">Prob</span> (Map.unionWith (<span class="fu">+</span>) xs ys)</a>
<a class="sourceLine" id="cb13-19" data-line-number="19"></a>
<a class="sourceLine" id="cb13-20" data-line-number="20"><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Prob</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-21" data-line-number="21">    <span class="dt">Prob</span> xs <span class="fu">&gt;&gt;=</span> f</a>
<a class="sourceLine" id="cb13-22" data-line-number="22">        <span class="fu">=</span> Map.foldMapWithKey ((<span class="dt">Prob</span> <span class="fu">.</span>) <span class="fu">.</span> flip (Map.map <span class="fu">.</span> (<span class="fu">*</span>)) <span class="fu">.</span> runProb <span class="fu">.</span> f) xs</a>
<a class="sourceLine" id="cb13-23" data-line-number="23"></a>
<a class="sourceLine" id="cb13-24" data-line-number="24">support <span class="fu">=</span> Map.keys <span class="fu">.</span> runProb</a>
<a class="sourceLine" id="cb13-25" data-line-number="25"></a>
<a class="sourceLine" id="cb13-26" data-line-number="26">expect p <span class="fu">=</span> getSum <span class="fu">.</span> Map.foldMapWithKey (\k v <span class="ot">-&gt;</span> <span class="dt">Sum</span> (p k <span class="fu">*</span> v)) <span class="fu">.</span> runProb</a>
<a class="sourceLine" id="cb13-27" data-line-number="27"></a>
<a class="sourceLine" id="cb13-28" data-line-number="28">probOf p <span class="fu">=</span> expect (bool <span class="dv">0</span> <span class="dv">1</span> <span class="fu">.</span> p)</a>
<a class="sourceLine" id="cb13-29" data-line-number="29"></a>
<a class="sourceLine" id="cb13-30" data-line-number="30">uniform xs <span class="fu">=</span> <span class="dt">Prob</span> (Map.fromList [ (x,n) <span class="fu">|</span> x <span class="ot">&lt;-</span> xs ])</a>
<a class="sourceLine" id="cb13-31" data-line-number="31">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-32" data-line-number="32">    n <span class="fu">=</span> <span class="dv">1</span> <span class="fu">%</span> toEnum (length xs)</a>
<a class="sourceLine" id="cb13-33" data-line-number="33"></a>
<a class="sourceLine" id="cb13-34" data-line-number="34">ifThenElse <span class="dt">True</span> t _ <span class="fu">=</span> t</a>
<a class="sourceLine" id="cb13-35" data-line-number="35">ifThenElse <span class="dt">False</span> _ f <span class="fu">=</span> f</a>
<a class="sourceLine" id="cb13-36" data-line-number="36"></a>
<a class="sourceLine" id="cb13-37" data-line-number="37">die <span class="fu">=</span> uniform [<span class="dv">1</span><span class="fu">..</span><span class="dv">6</span>]</a>
<a class="sourceLine" id="cb13-38" data-line-number="38"></a>
<a class="sourceLine" id="cb13-39" data-line-number="39"><span class="fu">&gt;&gt;&gt;</span> probOf (<span class="dv">7</span><span class="fu">==</span>) <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb13-40" data-line-number="40">  x <span class="ot">&lt;-</span> die</a>
<a class="sourceLine" id="cb13-41" data-line-number="41">  y <span class="ot">&lt;-</span> die</a>
<a class="sourceLine" id="cb13-42" data-line-number="42">  pure (x <span class="fu">+</span> y)</a>
<a class="sourceLine" id="cb13-43" data-line-number="43"><span class="dv">1</span> <span class="fu">%</span> <span class="dv">6</span></a></code></pre></div>
<h1 id="free">Free</h1>
<p>Coming up with the right implementation all at once is quite difficult: luckily, there are more general techniques for designing DSLs that break the problem into smaller parts, which also give us some insight into the underlying composition of the probability monad.</p>
<p>The technique relies on an algebraic concept called â€œfree objectsâ€. A free object for some class is a minimal implementation of that class. The classic example is lists: theyâ€™re the free monoid. Monoid requires that you have an additive operation, an empty element, and that the additive operation be associative. Lists have all of these things: what makes them <em>free</em>, though, is that they have nothing else. For instance, the additive operation on lists (concatenation) isnâ€™t commutative: if it was, they wouldnâ€™t be the free monoid any more, because they satisfy an extra law thatâ€™s not in monoid.</p>
<p>For our case, we can use the free monad: this takes a functor and gives it a monad instance, in a way we know will satisfy all the laws. This encoding is used in several papers <span class="citation" data-cites="scibior_practical_2015 larsen_memory_2011">(Åšcibior, Ghahramani, and Gordon <a href="#ref-scibior_practical_2015">2015</a>; Larsen <a href="#ref-larsen_memory_2011">2011</a>)</span>.</p>
<p>The idea is to first figure out what primitive operation you need. Weâ€™ll use weighted choice:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="ot">choose ::</span> <span class="dt">Prob</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span> <span class="ot">-&gt;</span> <span class="dt">Prob</span> a <span class="ot">-&gt;</span> <span class="dt">Prob</span> a</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">choose <span class="fu">=</span> <span class="fu">...</span></a></code></pre></div>
<p>Then you encode it as a functor:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Choose</span> a</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Choose</span> <span class="dt">Rational</span> a a</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">    <span class="kw">deriving</span> (<span class="dt">Functor</span>,<span class="dt">Foldable</span>)</a></code></pre></div>
<p>Weâ€™ll say the left-hand-choice has chance <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>, and the right-hand <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>âˆ’</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">1-p</annotation></semantics></math>. Then, you just wrap it in the free monad:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Prob</span> <span class="fu">=</span> <span class="dt">Free</span> <span class="dt">Choose</span></a></code></pre></div>
<p>And you already have a monad instance. Support comes from the <a href="http://hackage.haskell.org/package/base-4.11.1.0/docs/Data-Foldable.html#v:toList"><code class="sourceCode haskell"><span class="dt">Foldable</span></code></a> instance:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Data.Foldable</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2"></a>
<a class="sourceLine" id="cb17-3" data-line-number="3"><span class="ot">support ::</span> <span class="dt">Prob</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb17-4" data-line-number="4">support <span class="fu">=</span> toList</a></code></pre></div>
<p>Expectation is an â€œinterpreterâ€ for the DSL:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="ot">expect ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Rational</span>) <span class="ot">-&gt;</span> <span class="dt">Prob</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2">expect p <span class="fu">=</span> iter f <span class="fu">.</span> fmap p</a>
<a class="sourceLine" id="cb18-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-4" data-line-number="4">    f (<span class="dt">Choose</span> c l r) <span class="fu">=</span> l <span class="fu">*</span> c <span class="fu">+</span> r <span class="fu">*</span> (<span class="dv">1</span><span class="fu">-</span>c)</a></code></pre></div>
<p>For building up the tree, we can use Huffmanâ€™s algorithm:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="ot">fromList ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Rational</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Prob</span> a</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">fromList p <span class="fu">=</span> go <span class="fu">.</span> foldMap (\x <span class="ot">-&gt;</span> singleton (p x) (<span class="dt">Pure</span> x))</a>
<a class="sourceLine" id="cb19-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-4" data-line-number="4">    go xs <span class="fu">=</span> <span class="kw">case</span> minView xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb19-5" data-line-number="5">      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> error <span class="st">&quot;empty list&quot;</span></a>
<a class="sourceLine" id="cb19-6" data-line-number="6">      <span class="dt">Just</span> ((xp,x),ys) <span class="ot">-&gt;</span> <span class="kw">case</span> minView ys <span class="kw">of</span></a>
<a class="sourceLine" id="cb19-7" data-line-number="7">        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> x</a>
<a class="sourceLine" id="cb19-8" data-line-number="8">        <span class="dt">Just</span> ((yp,y),zs) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb19-9" data-line-number="9">          go (insertHeap (xp<span class="fu">+</span>yp) (<span class="dt">Free</span> (<span class="dt">Choose</span> (xp<span class="fu">/</span>(xp<span class="fu">+</span>yp)) x y)) zs)</a></code></pre></div>
<p>And finally, it gets the same notation as before:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1">uniform <span class="fu">=</span> fromList (const <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb20-2" data-line-number="2"></a>
<a class="sourceLine" id="cb20-3" data-line-number="3">die <span class="fu">=</span> uniform [<span class="dv">1</span><span class="fu">..</span><span class="dv">6</span>]</a>
<a class="sourceLine" id="cb20-4" data-line-number="4"></a>
<a class="sourceLine" id="cb20-5" data-line-number="5">probOf p <span class="fu">=</span> expect (bool <span class="dv">0</span> <span class="dv">1</span> <span class="fu">.</span> p)</a>
<a class="sourceLine" id="cb20-6" data-line-number="6"></a>
<a class="sourceLine" id="cb20-7" data-line-number="7"><span class="fu">&gt;&gt;&gt;</span> probOf (<span class="dv">7</span><span class="fu">==</span>) <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb20-8" data-line-number="8">  x <span class="ot">&lt;-</span> die</a>
<a class="sourceLine" id="cb20-9" data-line-number="9">  y <span class="ot">&lt;-</span> die</a>
<a class="sourceLine" id="cb20-10" data-line-number="10">  pure (x <span class="fu">+</span> y)</a>
<a class="sourceLine" id="cb20-11" data-line-number="11"><span class="dv">1</span> <span class="fu">%</span> <span class="dv">6</span></a></code></pre></div>
<p>One of the advantages of the free approach is that itâ€™s easy to define multiple interpreters. We could, for instance, write an interpreter that constructs a diagram:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> drawTree ((,) <span class="fu">&lt;$&gt;</span> uniform <span class="st">&quot;abc&quot;</span> <span class="fu">&lt;*&gt;</span> uniform <span class="st">&quot;de&quot;</span>)</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">           â”Œ(<span class="ch">&#39;c&#39;</span>,<span class="ch">&#39;d&#39;</span>)</a>
<a class="sourceLine" id="cb21-3" data-line-number="3">     â”Œ<span class="dv">1</span> <span class="fu">%</span> 2â”¤</a>
<a class="sourceLine" id="cb21-4" data-line-number="4">     â”‚     â””(<span class="ch">&#39;c&#39;</span>,<span class="ch">&#39;e&#39;</span>)</a>
<a class="sourceLine" id="cb21-5" data-line-number="5"><span class="dv">1</span> <span class="fu">%</span> 3â”¤</a>
<a class="sourceLine" id="cb21-6" data-line-number="6">     â”‚           â”Œ(<span class="ch">&#39;a&#39;</span>,<span class="ch">&#39;d&#39;</span>)</a>
<a class="sourceLine" id="cb21-7" data-line-number="7">     â”‚     â”Œ<span class="dv">1</span> <span class="fu">%</span> 2â”¤</a>
<a class="sourceLine" id="cb21-8" data-line-number="8">     â”‚     â”‚     â””(<span class="ch">&#39;a&#39;</span>,<span class="ch">&#39;e&#39;</span>)</a>
<a class="sourceLine" id="cb21-9" data-line-number="9">     â””<span class="dv">1</span> <span class="fu">%</span> 2â”¤</a>
<a class="sourceLine" id="cb21-10" data-line-number="10">           â”‚     â”Œ(<span class="ch">&#39;b&#39;</span>,<span class="ch">&#39;d&#39;</span>)</a>
<a class="sourceLine" id="cb21-11" data-line-number="11">           â””<span class="dv">1</span> <span class="fu">%</span> 2â”¤</a>
<a class="sourceLine" id="cb21-12" data-line-number="12">                 â””(<span class="ch">&#39;b&#39;</span>,<span class="ch">&#39;e&#39;</span>)</a></code></pre></div>
<h1 id="final">Final</h1>
<p>Thereâ€™s a lot to be said about free objects in category theory, also. Specifically, theyâ€™re related to initial and terminal (also called final) objects. The encoding above is initial, the final encoding is simply <code class="sourceCode haskell"><span class="dt">Cont</span></code>:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Cont</span> r a <span class="fu">=</span> <span class="dt">Cont</span> {<span class="ot"> runCont ::</span> (a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r }</a>
<a class="sourceLine" id="cb22-2" data-line-number="2"></a>
<a class="sourceLine" id="cb22-3" data-line-number="3"><span class="kw">type</span> <span class="dt">Prob</span> <span class="fu">=</span> <span class="dt">Cont</span> <span class="dt">Rational</span></a></code></pre></div>
<p>Here, also, we get the monad instance for free. In contrast to previously, expect is free:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1">expect <span class="fu">=</span> flip runCont</a></code></pre></div>
<p>Support, though, isnâ€™t possible.</p>
<p>This version is also called the Giry monad: thereâ€™s a deep and fascinating theory behind it, which I probably wonâ€™t be able to do justice to here. Check out Jared Tobinâ€™s post <span class="citation" data-cites="tobin_implementing_2017">(<a href="#ref-tobin_implementing_2017">2017</a>)</span> for a good deep dive on it.</p>
<h1 id="cofree">Cofree</h1>
<p>The branching structure of the tree captures the semantics of the probability monad well, but it doesnâ€™t give us much insight into the original implementation. The question is, how can we deconstruct this:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Prob</span> a</a>
<a class="sourceLine" id="cb24-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Prob</span></a>
<a class="sourceLine" id="cb24-3" data-line-number="3">    {<span class="ot"> runProb ::</span> [(a, <span class="dt">Rational</span>)]</a>
<a class="sourceLine" id="cb24-4" data-line-number="4">    }</a></code></pre></div>
<p>Eric Kidd <span class="citation" data-cites="kidd_build_2007">(<a href="#ref-kidd_build_2007">2007</a>)</span> pointed out that the monad is the composition of the writer and list monads:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Prob</span> <span class="fu">=</span> <span class="dt">WriterT</span> (<span class="dt">Product</span> <span class="dt">Rational</span>) []</a></code></pre></div>
<p>but that seems unsatisfying: in contrast to the tree-based version, we donâ€™t encode any branching structure, weâ€™re able to have empty distributions, and it has the combinatorial explosion problem.</p>
<p>Adding a weighting to nondeterminism is encapsulated more concretely by the <code class="sourceCode haskell"><span class="dt">ListT</span></code> transformer. It looks like this:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">ListT</span> m a</a>
<a class="sourceLine" id="cb26-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">ListT</span></a>
<a class="sourceLine" id="cb26-3" data-line-number="3">    {<span class="ot"> runListT ::</span> m (<span class="dt">Maybe</span> (a, <span class="dt">ListT</span> m a))</a>
<a class="sourceLine" id="cb26-4" data-line-number="4">    }</a></code></pre></div>
<p>Itâ€™s a cons-list, with an effect before every layer<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>.</p>
<p>While this can be used to give us the monad we need, Iâ€™ve found that something more like this fits the abstraction better:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="kw">data</span> <span class="dt">ListT</span> m a</a>
<a class="sourceLine" id="cb27-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">ListT</span> a (m (<span class="dt">Maybe</span> (<span class="dt">ListT</span> m a)))</a></code></pre></div>
<p>Itâ€™s a nonempty list, with the first element exposed. Turns out this is very similar to the cofree comonad:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Cofree</span> f a <span class="fu">=</span> a <span class="fu">:&lt;</span> f (<span class="dt">Cofree</span> f a)</a></code></pre></div>
<p>Just like the initial free encoding, we can start with a primitive operation:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Perhaps</span> a</a>
<a class="sourceLine" id="cb29-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Impossible</span></a>
<a class="sourceLine" id="cb29-3" data-line-number="3">    <span class="fu">|</span> <span class="dt">WithChance</span> <span class="dt">Rational</span> a</a>
<a class="sourceLine" id="cb29-4" data-line-number="4">    <span class="kw">deriving</span> (<span class="dt">Functor</span>,<span class="dt">Foldable</span>)</a></code></pre></div>
<p>And we get all of our instances as well:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Prob</span> a</a>
<a class="sourceLine" id="cb30-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Prob</span></a>
<a class="sourceLine" id="cb30-3" data-line-number="3">    {<span class="ot"> runProb ::</span> <span class="dt">Cofree</span> <span class="dt">Perhaps</span> a</a>
<a class="sourceLine" id="cb30-4" data-line-number="4">    } <span class="kw">deriving</span> (<span class="dt">Functor</span>,<span class="dt">Foldable</span>)</a>
<a class="sourceLine" id="cb30-5" data-line-number="5">    </a>
<a class="sourceLine" id="cb30-6" data-line-number="6"><span class="kw">instance</span> <span class="dt">Comonad</span> <span class="dt">Prob</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-7" data-line-number="7">    extract (<span class="dt">Prob</span> xs) <span class="fu">=</span> extract xs</a>
<a class="sourceLine" id="cb30-8" data-line-number="8">    duplicate (<span class="dt">Prob</span> xs) <span class="fu">=</span> <span class="dt">Prob</span> (fmap <span class="dt">Prob</span> (duplicate xs))</a>
<a class="sourceLine" id="cb30-9" data-line-number="9"></a>
<a class="sourceLine" id="cb30-10" data-line-number="10"><span class="ot">foldProb ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Rational</span> <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Prob</span> a <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb30-11" data-line-number="11">foldProb f b <span class="fu">=</span> r <span class="fu">.</span> runProb</a>
<a class="sourceLine" id="cb30-12" data-line-number="12">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-13" data-line-number="13">    r (x <span class="fu">:&lt;</span> <span class="dt">Impossible</span>) <span class="fu">=</span> b x</a>
<a class="sourceLine" id="cb30-14" data-line-number="14">    r (x <span class="fu">:&lt;</span> <span class="dt">WithChance</span> p xs) <span class="fu">=</span> f x p (r xs)</a>
<a class="sourceLine" id="cb30-15" data-line-number="15"></a>
<a class="sourceLine" id="cb30-16" data-line-number="16"><span class="ot">uniform ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Prob</span> a</a>
<a class="sourceLine" id="cb30-17" data-line-number="17">uniform (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="dt">Prob</span> (coiterW f (<span class="dt">EnvT</span> (length xs) (x <span class="fu">:|</span> xs)))</a>
<a class="sourceLine" id="cb30-18" data-line-number="18">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-19" data-line-number="19">    f (<span class="dt">EnvT</span> <span class="dv">0</span> (_ <span class="fu">:|</span> [])) <span class="fu">=</span> <span class="dt">Impossible</span></a>
<a class="sourceLine" id="cb30-20" data-line-number="20">    f (<span class="dt">EnvT</span> n (_ <span class="fu">:|</span> (y<span class="fu">:</span>ys))) </a>
<a class="sourceLine" id="cb30-21" data-line-number="21">        <span class="fu">=</span> <span class="dt">WithChance</span> (<span class="dv">1</span> <span class="fu">%</span> fromIntegral n) (<span class="dt">EnvT</span> (n <span class="fu">-</span> <span class="dv">1</span>) (y<span class="fu">:|</span>ys))</a>
<a class="sourceLine" id="cb30-22" data-line-number="22"></a>
<a class="sourceLine" id="cb30-23" data-line-number="23"><span class="ot">expect ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Rational</span>) <span class="ot">-&gt;</span> <span class="dt">Prob</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span></a>
<a class="sourceLine" id="cb30-24" data-line-number="24">expect p <span class="fu">=</span> foldProb f p</a>
<a class="sourceLine" id="cb30-25" data-line-number="25">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-26" data-line-number="26">    f x n xs <span class="fu">=</span> (p x <span class="fu">*</span> n <span class="fu">+</span> xs) <span class="fu">/</span> (n <span class="fu">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb30-27" data-line-number="27"></a>
<a class="sourceLine" id="cb30-28" data-line-number="28"><span class="ot">probOf ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Prob</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span></a>
<a class="sourceLine" id="cb30-29" data-line-number="29">probOf p <span class="fu">=</span> expect (\x <span class="ot">-&gt;</span> <span class="kw">if</span> p x <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb30-30" data-line-number="30"></a>
<a class="sourceLine" id="cb30-31" data-line-number="31"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Prob</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-32" data-line-number="32">    pure x <span class="fu">=</span> <span class="dt">Prob</span> (x <span class="fu">:&lt;</span> <span class="dt">Impossible</span>)</a>
<a class="sourceLine" id="cb30-33" data-line-number="33">    (<span class="fu">&lt;*&gt;</span>) <span class="fu">=</span> ap</a>
<a class="sourceLine" id="cb30-34" data-line-number="34">    </a>
<a class="sourceLine" id="cb30-35" data-line-number="35"><span class="ot">append ::</span> <span class="dt">Prob</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span> <span class="ot">-&gt;</span> <span class="dt">Prob</span> a <span class="ot">-&gt;</span> <span class="dt">Prob</span> a</a>
<a class="sourceLine" id="cb30-36" data-line-number="36">append <span class="fu">=</span> foldProb f (\x y <span class="ot">-&gt;</span>  <span class="dt">Prob</span> <span class="fu">.</span> (x <span class="fu">:&lt;</span>) <span class="fu">.</span> <span class="dt">WithChance</span> y <span class="fu">.</span> runProb)</a>
<a class="sourceLine" id="cb30-37" data-line-number="37">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-38" data-line-number="38">    f e r a p <span class="fu">=</span> <span class="dt">Prob</span> <span class="fu">.</span> (e <span class="fu">:&lt;</span>) <span class="fu">.</span> <span class="dt">WithChance</span> ip <span class="fu">.</span> runProb <span class="fu">.</span> a op</a>
<a class="sourceLine" id="cb30-39" data-line-number="39">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-40" data-line-number="40">        ip <span class="fu">=</span> p <span class="fu">*</span> r <span class="fu">/</span> (p <span class="fu">+</span> r <span class="fu">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb30-41" data-line-number="41">        op <span class="fu">=</span> p <span class="fu">/</span> (r <span class="fu">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb30-42" data-line-number="42"></a>
<a class="sourceLine" id="cb30-43" data-line-number="43"><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Prob</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-44" data-line-number="44">    xs <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> foldProb (append <span class="fu">.</span> f) f xs</a></code></pre></div>
<p>We see here that weâ€™re talking about gambling-style odds, rather than probability. I wonder if the two representations are dual somehow?</p>
<p>The application of comonads to streams (<code class="sourceCode haskell"><span class="dt">ListT</span></code>) has been explored before <span class="citation" data-cites="uustalu_essence_2005">(Uustalu and Vene <a href="#ref-uustalu_essence_2005">2005</a>)</span>; I wonder if there are any insights to be gleaned from this particular probability comonad.</p>
<h1 id="references" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-erwig_functional_2006">
<p>Erwig, Martin, and Steve Kollmansberger. 2006. â€œFunctional pearls: Probabilistic functional programming in Haskell.â€ <em>Journal of Functional Programming</em> 16 (1): 21â€“34. doi:<a href="https://doi.org/10.1017/S0956796805005721">10.1017/S0956796805005721</a>.</p>
</div>
<div id="ref-kidd_build_2007">
<p>Kidd, Eric. 2007. â€œBuild your own probability monads.â€</p>
</div>
<div id="ref-larsen_memory_2011">
<p>Larsen, Ken Friis. 2011. â€œMemory Efficient Implementation of Probability Monads.â€</p>
</div>
<div id="ref-scibior_practical_2015">
<p>Åšcibior, Adam, Zoubin Ghahramani, and Andrew D. Gordon. 2015. â€œPractical Probabilistic Programming with Monads.â€ In <em>Proceedings of the 2015 ACM SIGPLAN Symposium on Haskell</em>, 50:165â€“176. Haskell â€™15. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/2804302.2804317">10.1145/2804302.2804317</a>.</p>
</div>
<div id="ref-tobin_implementing_2017">
<p>Tobin, Jared. 2017. â€œImplementing the Giry Monad.â€ <em>jtobin.io</em>.</p>
</div>
<div id="ref-uustalu_essence_2005">
<p>Uustalu, Tarmo, and Varmo Vene. 2005. â€œThe Essence of Dataflow Programming.â€ In <em>Proceedings of the Third Asian Conference on Programming Languages and Systems</em>, 2â€“18. APLASâ€™05. Berlin, Heidelberg: Springer-Verlag. doi:<a href="https://doi.org/10.1007/11575467_2">10.1007/11575467_2</a>.</p>
</div>
</div>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Note this is <em>not</em> the same as the <code class="sourceCode haskell"><span class="dt">ListT</span></code> in <a href="http://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-List.html">transformers</a>; instead itâ€™s a â€œ<a href="https://wiki.haskell.org/ListT_done_right">ListT done right</a>â€.<a href="#fnref1" class="footnote-back">â†©</a></p></li>
</ol>
</section>
]]></description>
    <pubDate>Sat, 30 Jun 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-06-30-probability-5-ways.html</guid>
    <dc:creator>Donnacha OisÃ­n Kidney</dc:creator>
</item>
<item>
    <title>Scheduling Effects</title>
    <link>https://doisinkidney.com/posts/2018-06-23-scheduling-effects.html</link>
    <description><![CDATA[<div class="info">
    Posted on June 23, 2018
</div>
<div class="info">
    
        Part 4 of a <a href="/series/Breadth-First%20Traversals.html">5-part series on Breadth-First Traversals</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<p>After the <a href="2018-06-03-breadth-first-traversals-in-too-much-detail.html">last post</a>, Noah Easterly pointed me to their <a href="https://hackage.haskell.org/package/tree-traversals">tree-traversals library</a>, and in particular the <a href="https://hackage.haskell.org/package/tree-traversals-0.1.0.0/docs/Control-Applicative-Phases.html#t:Phases"><code class="sourceCode haskell"><span class="dt">Phases</span></code></a> applicative transformer. It allows you to batch applicative effects to be run together: for the breadth-first traversal, we can batch the effects from each level together, giving us a lovely short solution to the problem.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1">breadthFirst c <span class="fu">=</span> runPhasesForwards <span class="fu">.</span> go</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">    go (x<span class="fu">:&lt;</span>xs) <span class="fu">=</span> liftA2 (<span class="fu">:&lt;</span>) (now (c x)) (delay (traverse go xs))</a></code></pre></div>
<p>In my efforts to speed this implementation up, I came across a wide and interesting literature on scheduling effects, which Iâ€™ll go through a little here.</p>
<h1 id="coroutines">Coroutines</h1>
<p>The first thing that jumps to mind, for me, when I think of â€œschedulingâ€ is coroutines. These are constructs that let you finely control the order of execution of effects. Theyâ€™re well explored in Haskell by now, and most libraries will let you do something like the following:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1">oneThenTwo <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  liftIO <span class="fu">$</span> print <span class="dv">1</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  delay <span class="fu">$</span> liftIO <span class="fu">$</span> print <span class="dv">2</span></a></code></pre></div>
<p>We first print <code>1</code>, then, after a delay, we print <code>2</code>. The <code class="sourceCode haskell">delay</code> doesnâ€™t make a difference if we just run the whole thing:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> retract oneThenTwo</a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="dv">1</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="dv">2</span></a></code></pre></div>
<p>But you can see its effect when we use the <code class="sourceCode haskell">interleave</code> combinator:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> retract <span class="fu">$</span> interleave (replicate <span class="dv">3</span> oneThenTwo)</a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="dv">1</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="dv">1</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="dv">1</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="dv">2</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6"><span class="dv">2</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7"><span class="dv">2</span></a></code></pre></div>
<p>Hopefully you can see how useful this might be, and the similarity to the <code class="sourceCode haskell"><span class="dt">Phases</span></code> construction.</p>
<p>The genealogy of most coroutine libraries in Haskell seems to trace back to <span class="citation" data-cites="blazevic_coroutine_2011">BlaÅ¾eviÄ‡ (<a href="#ref-blazevic_coroutine_2011">2011</a>)</span> or <span class="citation" data-cites="kiselyov_iteratees_2012">Kiselyov (<a href="#ref-kiselyov_iteratees_2012">2012</a>)</span>: the implementation I have been using in these past few examples (<a href="http://hackage.haskell.org/package/free-5.0.2/docs/Control-Monad-Trans-Iter.html"><code>IterT</code></a>) comes from a slightly different place. Letâ€™s take a quick detour to explore it a little.</p>
<h1 id="partiality">Partiality</h1>
<p>In functional programming, there are several constructions for modeling error-like states: <code class="sourceCode haskell"><span class="dt">Maybe</span></code> for your nulls, <code class="sourceCode haskell"><span class="dt">Either</span></code> for your exceptions. What separates these approaches from the â€œunsafeâ€ variants (null pointers, unchecked exceptions) is that we can <em>prove</em>, in the type system, that the error case is handled correctly.</p>
<p>Conspicuously absent from the usual toolbox for modeling partiality is a way to model <em>nontermination</em>. At first glance, it may seem strange to attempt to do so in Haskell. After all, if I have a function of type:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a></code></pre></div>
<p>I can prove that I wonâ€™t throw any errors (with <code class="sourceCode haskell"><span class="dt">Either</span></code>, that is), because the type <code class="sourceCode haskell"><span class="dt">Int</span></code> doesnâ€™t contain <code class="sourceCode haskell"><span class="dt">Left</span> _</code>. Iâ€™ve also proved, miraculously, that I wonâ€™t make any null dereferences, because <code class="sourceCode haskell"><span class="dt">Int</span></code> also doesnâ€™t contain <code class="sourceCode haskell"><span class="dt">Nothing</span></code>. I <em>havenâ€™t</em> proved, however, that I wonâ€™t loop infinitely, because (in Haskell), <code class="sourceCode haskell"><span class="dt">Int</span></code> absolutely <em>does</em> contain <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>âŠ¥</mi><annotation encoding="application/x-tex">\bot</annotation></semantics></math>.</p>
<p>So weâ€™re somewhat scuppered. On the other hand, While we canâ€™t <em>prove</em> termination in Haskell, we can:</p>
<ol>
<li>Model it.</li>
<li>Prove it in something else.</li>
</ol>
<p>Which is exactly what Venanzio Capretta did in the fascinating (and quite accessible) talk â€œPartiality is an effectâ€ <span class="citation" data-cites="capretta_partiality_2004">(Capretta, Altenkirch, and Uustalu <a href="#ref-capretta_partiality_2004">2004</a>)</span><a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>.</p>
<p>The monad in question looks like this:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode idris"><code class="sourceCode idris"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Iter</span> a</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Now</span> a</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">    <span class="fu">|</span> <span class="dt">Later</span> (<span class="dt">Inf</span> (<span class="dt">Iter</span> a))</a></code></pre></div>
<p>Weâ€™re writing in Idris for the time being, so that we can prove termination and so on. The â€œrecursive callâ€ to <code class="sourceCode haskell"><span class="dt">Iter</span></code> is guarded by the <code class="sourceCode haskell"><span class="dt">Inf</span></code> type: this turns on a different kind of totality checking in the compiler. Usually, Idris will prevent you from constructing infinite values. But thatâ€™s exactly what we want to do here. Take the little-known function <a href="http://hackage.haskell.org/package/base-4.11.1.0/docs/Prelude.html#v:until"><code class="sourceCode haskell">until</code></a>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1">until<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a></code></pre></div>
<p>Itâ€™s clearly not necessarily total, and the totality checker will complain as such when we try and implement it directly:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode idris"><code class="sourceCode idris"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="fu">until</span> <span class="ot">:</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">until p f x <span class="fu">=</span> <span class="kw">if</span> p x <span class="kw">then</span> x <span class="kw">else</span> until p f (f x)</a></code></pre></div>
<p>But we can use <code class="sourceCode haskell"><span class="dt">Iter</span></code> to model that possible totality:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode idris"><code class="sourceCode idris"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="fu">until</span> <span class="ot">:</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Iter</span> a</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">until p f x <span class="fu">=</span> <span class="kw">if</span> p x <span class="kw">then</span> <span class="dt">Now</span> x <span class="kw">else</span> <span class="dt">Later</span> (until p f (f x))</a></code></pre></div>
<p>Of course, nothingâ€™s for free: when we get the ability to construct infinite values, we lose the ability to consume them.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode idris"><code class="sourceCode idris"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="fu">run</span> <span class="ot">:</span> <span class="dt">Iter</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">run (<span class="dt">Now</span> x) <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">run (<span class="dt">Later</span> x) <span class="fu">=</span> run x</a></code></pre></div>
<p>We get an error on the <code class="sourceCode haskell">run</code> function. However, as you would expect, we can run <em>guarded</em> iteration: iteration up until some finite point.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode idris"><code class="sourceCode idris"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="fu">runUntil</span> <span class="ot">:</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Iter</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">runUntil <span class="dt">Z</span> <span class="fu">_</span> <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">runUntil (<span class="dt">S</span> n) (<span class="dt">Now</span> x) <span class="fu">=</span> <span class="dt">Just</span> x</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">runUntil (<span class="dt">S</span> n) (<span class="dt">Later</span> x) <span class="fu">=</span> runUntil n x</a></code></pre></div>
<p>Making our way back to Haskell, we must firstâ€”as is the lawâ€”add a type parameter, and upgrade our humble monad to a monad transformer:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">IterT</span> m a <span class="fu">=</span> <span class="dt">IterT</span> {<span class="ot"> runIterT ::</span> m (<span class="dt">Either</span> a (<span class="dt">IterT</span> m a)) }</a>
<a class="sourceLine" id="cb12-2" data-line-number="2"></a>
<a class="sourceLine" id="cb12-3" data-line-number="3"><span class="kw">type</span> <span class="dt">Iter</span> <span class="fu">=</span> <span class="dt">IterT</span> <span class="dt">Identity</span></a></code></pre></div>
<p>The semantic meaning of the extra <code class="sourceCode haskell">m</code> here is interesting: each layer adds not just a recursive step, or a single iteration, but a single effect. Interpreting things in this way gets us back to the original goal:</p>
<h1 id="scheduling">Scheduling</h1>
<p>The <code class="sourceCode haskell"><span class="dt">Later</span></code> constructor above can be translated to a <code class="sourceCode haskell">delay</code> function on the transformer:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1">delay <span class="fu">=</span> <span class="dt">IterT</span> <span class="fu">.</span> pure <span class="fu">.</span> <span class="dt">Right</span></a></code></pre></div>
<p>And using this again, we can write the following incredibly short definition for <code class="sourceCode haskell">unfoldTreeM_BF</code>:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="ot">unfoldTreeM_BF ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (b <span class="ot">-&gt;</span> m (a, [b])) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> m (<span class="dt">Tree</span> a)</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">unfoldTreeM_BF f <span class="fu">=</span> retract <span class="fu">.</span> go</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-4" data-line-number="4">    go b <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb14-5" data-line-number="5">      (x,xs) <span class="ot">&lt;-</span> lift (f b)</a>
<a class="sourceLine" id="cb14-6" data-line-number="6">      fmap (<span class="dt">Node</span> x) (interleave (map (delay <span class="fu">.</span> go) xs))</a></code></pre></div>
<h1 id="applicative">Applicative</h1>
<p>It would be nice to bring this back to traversals, but alas, <code class="sourceCode haskell"><span class="dt">IterT</span></code> is pretty monad-centric. Whatâ€™s more, if itâ€™s analogous to <code class="sourceCode haskell"><span class="dt">Phases</span></code> it certainly doesnâ€™t look like it:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Phases</span> f a <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2">  <span class="dt">Lift</span><span class="ot"> ::</span> f a <span class="ot">-&gt;</span> <span class="dt">Phases</span> f a</a>
<a class="sourceLine" id="cb15-3" data-line-number="3"><span class="ot">  (:&lt;*&gt;) ::</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Phases</span> f a <span class="ot">-&gt;</span> <span class="dt">Phases</span> f b</a></code></pre></div>
<p>However, in the documentation for <a href="http://hackage.haskell.org/package/free-5.0.2/docs/Control-Monad-Trans-Iter.html#t:IterT"><code class="sourceCode haskell"><span class="dt">IterT</span></code></a>, thereâ€™s the following little note:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="dt">IterT</span> <span class="fu">~</span> <span class="dt">FreeT</span> <span class="dt">Identity</span></a></code></pre></div>
<p>Where <code class="sourceCode haskell"><span class="dt">FreeT</span></code> is the <a href="http://hackage.haskell.org/package/free-5.0.2/docs/Control-Monad-Trans-Free.html">free monad transformer</a>. This seems to strongly hint that we could get the same thing for applicatives with <a href="http://hackage.haskell.org/package/free-5.0.2/docs/Control-Applicative-Trans-Free.html"><code class="sourceCode haskell"><span class="dt">ApT</span></code></a>. Letâ€™s try it:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Phases</span> f a <span class="fu">=</span> <span class="dt">Phases</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2">    {<span class="ot"> runPhases ::</span> <span class="dt">ApT</span> <span class="dt">Identity</span> f a</a>
<a class="sourceLine" id="cb17-3" data-line-number="3">    } <span class="kw">deriving</span> <span class="dt">Functor</span></a></code></pre></div>
<p>The <code class="sourceCode haskell"><span class="dt">Applicative</span></code> instance is a little hairy, but it <em>seems</em> correct:</p>
<details>
<p><summary> Applicative Instance </summary></p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2">         <span class="dt">Applicative</span> (<span class="dt">Phases</span> f) <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3">    pure <span class="fu">=</span> <span class="dt">Phases</span> <span class="fu">.</span> pure</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">    liftA2 f&#39; (<span class="dt">Phases</span> (<span class="dt">ApT</span> xs&#39;)) (<span class="dt">Phases</span> (<span class="dt">ApT</span> ys&#39;)) <span class="fu">=</span></a>
<a class="sourceLine" id="cb18-5" data-line-number="5">        <span class="dt">Phases</span> (<span class="dt">ApT</span> (liftA2 (go f&#39;) xs&#39; ys&#39;))</a>
<a class="sourceLine" id="cb18-6" data-line-number="6">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-7" data-line-number="7">        go</a>
<a class="sourceLine" id="cb18-8" data-line-number="8"><span class="ot">            ::</span> <span class="ot">âˆ€</span> a b c<span class="fu">.</span></a>
<a class="sourceLine" id="cb18-9" data-line-number="9">               (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c)</a>
<a class="sourceLine" id="cb18-10" data-line-number="10">            <span class="ot">-&gt;</span> <span class="dt">ApF</span> <span class="dt">Identity</span> f a</a>
<a class="sourceLine" id="cb18-11" data-line-number="11">            <span class="ot">-&gt;</span> <span class="dt">ApF</span> <span class="dt">Identity</span> f b</a>
<a class="sourceLine" id="cb18-12" data-line-number="12">            <span class="ot">-&gt;</span> <span class="dt">ApF</span> <span class="dt">Identity</span> f c</a>
<a class="sourceLine" id="cb18-13" data-line-number="13">        go f (<span class="dt">Pure</span> x) ys <span class="fu">=</span> fmap (f x) ys</a>
<a class="sourceLine" id="cb18-14" data-line-number="14">        go f xs (<span class="dt">Pure</span> y) <span class="fu">=</span> fmap (<span class="ot">`f`</span> y) xs</a>
<a class="sourceLine" id="cb18-15" data-line-number="15">        go f (<span class="dt">Ap</span> x (<span class="dt">ApT</span> xs)) (<span class="dt">Ap</span> y (<span class="dt">ApT</span> ys)) <span class="fu">=</span></a>
<a class="sourceLine" id="cb18-16" data-line-number="16">            <span class="dt">Ap</span></a>
<a class="sourceLine" id="cb18-17" data-line-number="17">                (liftA2 (,) x y)</a>
<a class="sourceLine" id="cb18-18" data-line-number="18">                (<span class="dt">ApT</span> (liftA2 (go (\xx yy <span class="ot">-&gt;</span> uncurry f <span class="fu">.</span> (xx <span class="fu">***</span> yy))) xs ys))</a></code></pre></div>
</details>
<p>(on a side note: thank <em>goodness</em> for <code class="sourceCode haskell">liftA2</code> finally getting into <code class="sourceCode haskell"><span class="dt">Applicative</span></code>)</p>
<p>And we get all the normal combinators:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="ot">delay ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">Phases</span> f a <span class="ot">-&gt;</span> <span class="dt">Phases</span> f a</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">delay <span class="fu">=</span> <span class="dt">Phases</span> <span class="fu">.</span> <span class="dt">ApT</span> <span class="fu">.</span> pure <span class="fu">.</span> <span class="dt">Ap</span> (pure ()) <span class="fu">.</span> fmap const <span class="fu">.</span> runPhases</a>
<a class="sourceLine" id="cb19-3" data-line-number="3"></a>
<a class="sourceLine" id="cb19-4" data-line-number="4"><span class="ot">lift ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Phases</span> f a</a>
<a class="sourceLine" id="cb19-5" data-line-number="5">lift <span class="fu">=</span> <span class="dt">Phases</span> <span class="fu">.</span> liftApO</a></code></pre></div>
<p>The issue comes with running the thing at the end: <code class="sourceCode haskell"><span class="dt">Monad</span></code> creeps back in.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="ot">retract ::</span> <span class="dt">Monad</span> f <span class="ot">=&gt;</span> <span class="dt">Phases</span> f a <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb20-2" data-line-number="2">retract <span class="fu">=</span> fmap (runIdentity <span class="fu">.</span> retractAp) <span class="fu">.</span> joinApT <span class="fu">.</span> runPhases</a></code></pre></div>
<p>Because the effects are all layered on top of each other, you need to flatten them out at the end, which requires <code class="sourceCode haskell">join</code>. Mind you, it does work: itâ€™s just not as general as it could be.</p>
<p>Allâ€™s not lost, though. Turns out, we never needed the transformer in the first place: we could just define the different applicative instance straight off.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Phases</span> f a <span class="fu">=</span> <span class="dt">Phases</span></a>
<a class="sourceLine" id="cb21-2" data-line-number="2">    {<span class="ot"> runPhases ::</span> <span class="dt">Ap</span> f a</a>
<a class="sourceLine" id="cb21-3" data-line-number="3">    } <span class="kw">deriving</span> <span class="dt">Functor</span></a>
<a class="sourceLine" id="cb21-4" data-line-number="4"></a>
<a class="sourceLine" id="cb21-5" data-line-number="5"><span class="kw">instance</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb21-6" data-line-number="6">         <span class="dt">Applicative</span> (<span class="dt">Phases</span> f) <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-7" data-line-number="7">    pure <span class="fu">=</span> <span class="dt">Phases</span> <span class="fu">.</span> <span class="dt">Pure</span></a>
<a class="sourceLine" id="cb21-8" data-line-number="8">    liftA2 f&#39; (<span class="dt">Phases</span> xs&#39;) (<span class="dt">Phases</span> ys&#39;) <span class="fu">=</span> <span class="dt">Phases</span> (go f&#39; xs&#39; ys&#39;)</a>
<a class="sourceLine" id="cb21-9" data-line-number="9">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-10" data-line-number="10"><span class="ot">        go ::</span> <span class="ot">âˆ€</span> a b c<span class="fu">.</span></a>
<a class="sourceLine" id="cb21-11" data-line-number="11">              (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c)</a>
<a class="sourceLine" id="cb21-12" data-line-number="12">           <span class="ot">-&gt;</span> <span class="dt">Ap</span> f a</a>
<a class="sourceLine" id="cb21-13" data-line-number="13">           <span class="ot">-&gt;</span> <span class="dt">Ap</span> f b</a>
<a class="sourceLine" id="cb21-14" data-line-number="14">           <span class="ot">-&gt;</span> <span class="dt">Ap</span> f c</a>
<a class="sourceLine" id="cb21-15" data-line-number="15">        go f (<span class="dt">Pure</span> x) ys <span class="fu">=</span> fmap (f x) ys</a>
<a class="sourceLine" id="cb21-16" data-line-number="16">        go f xs (<span class="dt">Pure</span> y) <span class="fu">=</span> fmap (<span class="ot">`f`</span> y) xs</a>
<a class="sourceLine" id="cb21-17" data-line-number="17">        go f (<span class="dt">Ap</span> x xs) (<span class="dt">Ap</span> y ys) <span class="fu">=</span></a>
<a class="sourceLine" id="cb21-18" data-line-number="18">            <span class="dt">Ap</span></a>
<a class="sourceLine" id="cb21-19" data-line-number="19">                (liftA2 (,) x y)</a>
<a class="sourceLine" id="cb21-20" data-line-number="20">                (go (\xx yy <span class="ot">-&gt;</span> uncurry f <span class="fu">.</span> (xx <span class="fu">***</span> yy)) xs ys)</a>
<a class="sourceLine" id="cb21-21" data-line-number="21"></a>
<a class="sourceLine" id="cb21-22" data-line-number="22"><span class="ot">delay ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">Phases</span> f a <span class="ot">-&gt;</span> <span class="dt">Phases</span> f a</a>
<a class="sourceLine" id="cb21-23" data-line-number="23">delay <span class="fu">=</span> <span class="dt">Phases</span> <span class="fu">.</span> <span class="dt">Ap</span> (pure ()) <span class="fu">.</span> fmap const <span class="fu">.</span> runPhases</a>
<a class="sourceLine" id="cb21-24" data-line-number="24"></a>
<a class="sourceLine" id="cb21-25" data-line-number="25"><span class="ot">retract ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">Phases</span> f a <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb21-26" data-line-number="26">retract <span class="fu">=</span> retractAp <span class="fu">.</span> runPhases</a>
<a class="sourceLine" id="cb21-27" data-line-number="27"></a>
<a class="sourceLine" id="cb21-28" data-line-number="28"><span class="ot">lift ::</span> f a <span class="ot">-&gt;</span> <span class="dt">Phases</span> f a</a>
<a class="sourceLine" id="cb21-29" data-line-number="29">lift <span class="fu">=</span> <span class="dt">Phases</span> <span class="fu">.</span> liftAp</a></code></pre></div>
<h1 id="more-coroutines">More Coroutines</h1>
<p>In the wonderful article Coroutine Pipelines <span class="citation" data-cites="blazevic_coroutine_2011">(BlaÅ¾eviÄ‡ <a href="#ref-blazevic_coroutine_2011">2011</a>)</span>, several different threads on coroutine-like constructions are unified. What Iâ€™ve demonstrated above isnâ€™t yet as powerful as what you might see in a full coroutine library: ideally, youâ€™d want generators and sinks. As it turns out, when we look back at the note from <code class="sourceCode haskell"><span class="dt">IterT</span></code>:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="dt">IterT</span> <span class="fu">~</span> <span class="dt">FreeT</span> <span class="dt">Identity</span></a></code></pre></div>
<p>We can get both of those other constructs by swapping out <code class="sourceCode haskell"><span class="dt">Identity</span></code><a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="dt">Generator</span> a <span class="fu">=</span> <span class="dt">FreeT</span> ((,) a)</a>
<a class="sourceLine" id="cb23-2" data-line-number="2"><span class="dt">Sink</span> a <span class="fu">=</span> <span class="dt">FreeT</span> ((<span class="ot">-&gt;</span>) a)</a></code></pre></div>
<p>(<code class="sourceCode haskell"><span class="dt">Sink</span></code> is usually called an <code class="sourceCode haskell"><span class="dt">Iteratee</span></code>)</p>
<p>This is the fundamental abstraction that underlies things like the pipes library <span class="citation" data-cites="gonzalez_pipes_2018">(Gonzalez <a href="#ref-gonzalez_pipes_2018">2018</a>)</span>.</p>
<h1 id="interleaving">Interleaving</h1>
<p>The only missing part from the first coroutine example by now is <code class="sourceCode haskell">interleave</code>. In the free library, it has the following signature:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="ot">interleave ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> [<span class="dt">IterT</span> m a] <span class="ot">-&gt;</span> <span class="dt">IterT</span> m [a]</a></code></pre></div>
<p>But we should be able to spot that, really, itâ€™s a traversal. And, as a traversal, it should rely on some underlying <code class="sourceCode haskell"><span class="dt">Applicative</span></code> instance. Letâ€™s try and come up with one:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Parallel</span> m f a <span class="fu">=</span> <span class="dt">Parallel</span></a>
<a class="sourceLine" id="cb25-2" data-line-number="2">    {<span class="ot"> runParallel ::</span> <span class="dt">FreeT</span> m f a</a>
<a class="sourceLine" id="cb25-3" data-line-number="3">    }</a>
<a class="sourceLine" id="cb25-4" data-line-number="4"></a>
<a class="sourceLine" id="cb25-5" data-line-number="5"><span class="kw">instance</span> (<span class="dt">Functor</span> f, <span class="dt">Functor</span> m) <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb25-6" data-line-number="6">         <span class="dt">Functor</span> (<span class="dt">Parallel</span> m f) <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-7" data-line-number="7">    fmap f <span class="fu">=</span> <span class="dt">Parallel</span> <span class="fu">.</span> <span class="dt">FreeT</span> <span class="fu">.</span> fmap go <span class="fu">.</span> runFreeT <span class="fu">.</span> runParallel</a>
<a class="sourceLine" id="cb25-8" data-line-number="8">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-9" data-line-number="9">        go <span class="fu">=</span> bimap f (<span class="dt">FreeT</span> <span class="fu">.</span> fmap go <span class="fu">.</span> runFreeT)</a>
<a class="sourceLine" id="cb25-10" data-line-number="10"></a>
<a class="sourceLine" id="cb25-11" data-line-number="11"><span class="kw">instance</span> (<span class="dt">Applicative</span> f, <span class="dt">Applicative</span> m) <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb25-12" data-line-number="12">         <span class="dt">Applicative</span> (<span class="dt">Parallel</span> m f) <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-13" data-line-number="13">    pure <span class="fu">=</span> <span class="dt">Parallel</span> <span class="fu">.</span> <span class="dt">FreeT</span> <span class="fu">.</span> pure <span class="fu">.</span> <span class="dt">Pure</span></a>
<a class="sourceLine" id="cb25-14" data-line-number="14">    <span class="dt">Parallel</span> fs&#39; <span class="fu">&lt;*&gt;</span> <span class="dt">Parallel</span> xs&#39; <span class="fu">=</span> <span class="dt">Parallel</span> (unw fs&#39; xs&#39;)</a>
<a class="sourceLine" id="cb25-15" data-line-number="15">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-16" data-line-number="16">        unw (<span class="dt">FreeT</span> fs) (<span class="dt">FreeT</span> xs) <span class="fu">=</span> <span class="dt">FreeT</span> (liftA2 go fs xs)</a>
<a class="sourceLine" id="cb25-17" data-line-number="17">        go (<span class="dt">Pure</span> f) <span class="fu">=</span> bimap f (runParallel <span class="fu">.</span> fmap f <span class="fu">.</span> <span class="dt">Parallel</span>)</a>
<a class="sourceLine" id="cb25-18" data-line-number="18">        go (<span class="dt">Free</span> fs) <span class="fu">=</span> <span class="dt">Free</span> <span class="fu">.</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb25-19" data-line-number="19">            <span class="dt">Pure</span> x <span class="ot">-&gt;</span> fmap (runParallel <span class="fu">.</span> fmap (<span class="fu">$</span>x) <span class="fu">.</span> <span class="dt">Parallel</span>) fs</a>
<a class="sourceLine" id="cb25-20" data-line-number="20">            <span class="dt">Free</span> xs <span class="ot">-&gt;</span> liftA2 unw fs xs</a></code></pre></div>
<p>Now, interleave is just <code class="sourceCode haskell">sequenceA</code>!</p>
<h1 id="applicatives-again">Applicatives, Again</h1>
<p>So we can see that thereâ€™s a â€œparallelâ€ applicative for both the free monad and the free applicative. To try and understand this type a little better, we can leverage our intuition about a much simpler, more familiar setting: lists. Thereâ€™s an interesting similarity between lists and the free monad: <code class="sourceCode haskell"><span class="dt">FreeT</span> ((,) a)</code>) looks a lot like â€œ<a href="https://wiki.haskell.org/ListT_done_right"><code class="sourceCode haskell"><span class="dt">ListT</span></code> done right</a>â€ (so much so, in fact, that most coroutine libraries provide their own version of it). More concretely, list also has a famous â€œparallelâ€ applicative: <a href="http://hackage.haskell.org/package/base-4.11.1.0/docs/Control-Applicative.html#t:ZipList"><code class="sourceCode haskell"><span class="dt">ZipList</span></code></a>!</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">ZipList</span> a</a>
<a class="sourceLine" id="cb26-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">ZipList</span> </a>
<a class="sourceLine" id="cb26-3" data-line-number="3">    {<span class="ot"> getZipList ::</span> [a]</a>
<a class="sourceLine" id="cb26-4" data-line-number="4">    } <span class="kw">deriving</span> <span class="dt">Functor</span></a>
<a class="sourceLine" id="cb26-5" data-line-number="5"></a>
<a class="sourceLine" id="cb26-6" data-line-number="6"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">ZipList</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb26-7" data-line-number="7">  pure <span class="fu">=</span> <span class="dt">ZipList</span> <span class="fu">.</span> repeat</a>
<a class="sourceLine" id="cb26-8" data-line-number="8">  liftA2 f (<span class="dt">ZipList</span> xs) (<span class="dt">ZipList</span> ys) <span class="fu">=</span> <span class="dt">ZipList</span> (zipWith f xs ys)</a></code></pre></div>
<p>Weâ€™ll use some of our knowledge about <code class="sourceCode haskell"><span class="dt">ZipList</span></code> to help us in the next section.</p>
<h1 id="timekeeping">Timekeeping</h1>
<p>Weâ€™ve seen that efforts to model both coroutines and partiality end up in the same neighborhood: thereâ€™s yet another way to get there, which seems (at first) almost the opposite of the second. It starts with a blog post from Conor McBride <span class="citation" data-cites="mcbride_time_2009">(<a href="#ref-mcbride_time_2009">2009</a>)</span> called â€œTime flies like an applicative functorâ€. Curiously, here too breadth-first labeling is the focus. Remember first the lovely circular solution from <span class="citation" data-cites="jones_linear-time_1993-1">(<span class="citeproc-not-found" data-reference-id="jones_linear-time_1993-1"><strong>???</strong></span>)</span>:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a <span class="fu">=</span> <span class="dt">Leaf</span> <span class="fu">|</span> <span class="dt">Node</span> a (<span class="dt">Tree</span> a) (<span class="dt">Tree</span> a)</a>
<a class="sourceLine" id="cb27-2" data-line-number="2"></a>
<a class="sourceLine" id="cb27-3" data-line-number="3"><span class="ot">relabel ::</span> <span class="dt">Tree</span> x <span class="ot">-&gt;</span> [[a]] <span class="ot">-&gt;</span> (<span class="dt">Tree</span> a, [[a]])</a>
<a class="sourceLine" id="cb27-4" data-line-number="4">relabel <span class="dt">Leaf</span> xss <span class="fu">=</span> (<span class="dt">Leaf</span>,xss)</a>
<a class="sourceLine" id="cb27-5" data-line-number="5">relabel (<span class="dt">Node</span> _ l r) ((x<span class="fu">:</span>xs)<span class="fu">:</span>xss0) <span class="fu">=</span></a>
<a class="sourceLine" id="cb27-6" data-line-number="6">  <span class="kw">let</span> (l&#39;,xss1) <span class="fu">=</span> relabel l xss0</a>
<a class="sourceLine" id="cb27-7" data-line-number="7">      (r&#39;,xss2) <span class="fu">=</span> relabel r xss1</a>
<a class="sourceLine" id="cb27-8" data-line-number="8">  <span class="kw">in</span> (<span class="dt">Node</span> x l&#39; r&#39;,xs<span class="fu">:</span>xss2)</a>
<a class="sourceLine" id="cb27-9" data-line-number="9">  </a>
<a class="sourceLine" id="cb27-10" data-line-number="10"><span class="ot">bflabel ::</span> <span class="dt">Tree</span> x <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb27-11" data-line-number="11">bflabel tr xs <span class="fu">=</span> u</a>
<a class="sourceLine" id="cb27-12" data-line-number="12">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb27-13" data-line-number="13">    (u,xss) <span class="fu">=</span> relabel tr (xs<span class="fu">:</span>xss)</a></code></pre></div>
<p>As lovely as it is, spare a thought for the poor totality checker: itâ€™s hard to imagine how it would even <em>start</em> to show that something so lazy and circular would terminate. <code class="sourceCode haskell"><span class="dt">IterT</span></code> wonâ€™t help us here, either: it can help us express programs that <em>might</em> diverge, not weird-looking ones that definitely wonâ€™t.</p>
<p>The solution presented is a type (<code class="sourceCode haskell"><span class="dt">De</span></code>) which has a limited set of combinators: a fixpoint (<code class="sourceCode haskell"><span class="ot">fix ::</span> (<span class="dt">De</span> x <span class="ot">-&gt;</span> x) <span class="ot">-&gt;</span> x</code>), and an applicative instance. As long as all problematic recursive calls are instead expressed using those combinators, the termination checker should be satisfied.</p>
<p><code class="sourceCode haskell"><span class="dt">De</span></code> can be thought of as a â€œdelayâ€ wrapper. Values of type <code class="sourceCode haskell"><span class="dt">De</span> a</code> are one step in the future, <code class="sourceCode haskell"><span class="dt">De</span> (<span class="dt">De</span> a)</code> are two, and so on. This idea was later expanded upon in <span class="citation" data-cites="atkey_how_2011">Atkey (<a href="#ref-atkey_how_2011">2011</a>)</span> and <span class="citation" data-cites="atkey_productive_2013">Atkey and McBride (<a href="#ref-atkey_productive_2013">2013</a>)</span> to <em>clock variables</em>. Instead of types with a delay, types are tagged with how much more time they have (something like â€œfuelâ€ in the Idris sense, maybe). So a value of type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>a</mi><mstyle mathvariant="sans-serif"><mi>ğ–ª</mi></mstyle></msup><annotation encoding="application/x-tex">a^\mathsf{K}</annotation></semantics></math> is tagged with time <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="sans-serif"><mi>ğ–ª</mi></mstyle><annotation encoding="application/x-tex">\mathsf{K}</annotation></semantics></math>, effectively meaning â€œI have <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="sans-serif"><mi>ğ–ª</mi></mstyle><annotation encoding="application/x-tex">\mathsf{K}</annotation></semantics></math> productive steps left before I divergeâ€. â€œProductive stepsâ€ will mean something different for every data type: for lists, it could mean that it can produce up until the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="sans-serif"><mi>ğ–ª</mi></mstyle><annotation encoding="application/x-tex">\mathsf{K}</annotation></semantics></math>th cons-cell. In the paper <span class="citation" data-cites="atkey_productive_2013">(Atkey and McBride <a href="#ref-atkey_productive_2013">2013</a>)</span> this is fleshed out a little more, with fixpoint combinators and so on. As a concrete example, take the type of the cons operator on streams:</p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">Cons</mtext><mo>:</mo><mtext mathvariant="normal">a</mtext><mo>â†’</mo><msup><mtext mathvariant="normal">Stream a</mtext><mstyle mathvariant="sans-serif"><mi>ğ–ª</mi></mstyle></msup><mo>â†’</mo><msup><mtext mathvariant="normal">Stream a</mtext><mrow><mstyle mathvariant="sans-serif"><mi>ğ–ª</mi></mstyle><mo>+</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">\begin{equation}
\text{Cons} : \text{a}
\rightarrow \text{Stream a}^\mathsf{K}
\rightarrow \text{Stream a}^{\mathsf{K}+1}
\end{equation}</annotation></semantics></math>
<p>It increments the clock on the type, saying that it has one more productive step than it did before. This is kind of the opposite of a â€œdelayâ€: previously, the scheduling types have meant â€œthis is available <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="sans-serif"><mi>ğ–ª</mi></mstyle><annotation encoding="application/x-tex">\mathsf{K}</annotation></semantics></math> number of steps in the futureâ€ rather than â€œthis is available for another <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="sans-serif"><mi>ğ–ª</mi></mstyle><annotation encoding="application/x-tex">\mathsf{K}</annotation></semantics></math> stepsâ€. We can still describe delays in this system, though, using the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mo>âŠ³</mo><mstyle mathvariant="sans-serif"><mi>ğ–ª</mi></mstyle></msup><annotation encoding="application/x-tex">\rhd^\mathsf{K}</annotation></semantics></math> notation:</p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">Cons</mtext><mo>:</mo><mtext mathvariant="normal">a</mtext><mo>â†’</mo><mover><mo>âŠ³</mo><mstyle mathvariant="sans-serif"><mi>ğ–ª</mi></mstyle></mover><mtext mathvariant="normal">Stream a</mtext><mo>â†’</mo><mtext mathvariant="normal">Stream a</mtext></mrow><annotation encoding="application/x-tex">\begin{equation}
\text{Cons} : \text{a}
\rightarrow \rhd^\mathsf{K}\text{Stream a}
\rightarrow \text{Stream a}
\end{equation}</annotation></semantics></math>
<p>Letâ€™s first try express some of this in the free monad:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1"><span class="kw">data</span> <span class="dt">K</span> <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">|</span> <span class="dt">S</span> <span class="dt">K</span></a>
<a class="sourceLine" id="cb28-2" data-line-number="2"></a>
<a class="sourceLine" id="cb28-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Delay</span><span class="ot"> ::</span> <span class="dt">K</span> <span class="ot">-&gt;</span> (<span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> (<span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb28-4" data-line-number="4">  <span class="dt">Now</span><span class="ot">   ::</span> a <span class="ot">-&gt;</span> <span class="dt">Delay</span> n f m a</a>
<a class="sourceLine" id="cb28-5" data-line-number="5">  <span class="dt">Later</span><span class="ot"> ::</span> f (<span class="dt">DelayT</span> n f m a) <span class="ot">-&gt;</span> <span class="dt">Delay</span> (<span class="dt">S</span> n) f m a</a>
<a class="sourceLine" id="cb28-6" data-line-number="6"></a>
<a class="sourceLine" id="cb28-7" data-line-number="7"><span class="kw">instance</span> (<span class="dt">Functor</span> f, <span class="dt">Functor</span> m) <span class="ot">=&gt;</span> <span class="dt">Functor</span> (<span class="dt">Delay</span> n f m) <span class="kw">where</span></a>
<a class="sourceLine" id="cb28-8" data-line-number="8">  fmap f (<span class="dt">Now</span> x) <span class="fu">=</span> <span class="dt">Now</span> (f x)</a>
<a class="sourceLine" id="cb28-9" data-line-number="9">  fmap f (<span class="dt">Later</span> xs) <span class="fu">=</span> <span class="dt">Later</span> (fmap (fmap f) xs)</a>
<a class="sourceLine" id="cb28-10" data-line-number="10"></a>
<a class="sourceLine" id="cb28-11" data-line-number="11"><span class="kw">newtype</span> <span class="dt">DelayT</span> n f m a <span class="fu">=</span> <span class="dt">DelayT</span> {<span class="ot"> runDelayT ::</span> m (<span class="dt">Delay</span> n f m a) }</a>
<a class="sourceLine" id="cb28-12" data-line-number="12"></a>
<a class="sourceLine" id="cb28-13" data-line-number="13"><span class="kw">instance</span> (<span class="dt">Functor</span> f, <span class="dt">Functor</span> m) <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb28-14" data-line-number="14">         <span class="dt">Functor</span> (<span class="dt">DelayT</span> n f m) <span class="kw">where</span></a>
<a class="sourceLine" id="cb28-15" data-line-number="15">    fmap f <span class="fu">=</span> <span class="dt">DelayT</span> <span class="fu">.</span> fmap (fmap f) <span class="fu">.</span> runDelayT</a></code></pre></div>
<p>We can straight away express one of the combinators from the paper, <code class="sourceCode haskell">force</code>:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" data-line-number="1"><span class="ot">force ::</span> <span class="dt">Functor</span> m <span class="ot">=&gt;</span> (<span class="ot">âˆ€</span> k<span class="fu">.</span> <span class="dt">DelayT</span> k f m a) <span class="ot">-&gt;</span> m a</a>
<a class="sourceLine" id="cb29-2" data-line-number="2">force (<span class="dt">DelayT</span> xs) <span class="fu">=</span> fmap f xs</a>
<a class="sourceLine" id="cb29-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb29-4" data-line-number="4"><span class="ot">    f ::</span> <span class="dt">Delay</span> <span class="dt">Z</span> f m a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb29-5" data-line-number="5">    f (<span class="dt">Now</span> x) <span class="fu">=</span> x</a></code></pre></div>
<p>Similar trick to <a href="http://hackage.haskell.org/package/base-4.11.1.0/docs/Control-Monad-ST.html#v:runST"><code class="sourceCode haskell">runST</code></a> here: if the type is delayed however long we want it to be, then it mustnâ€™t really be delayed at all.</p>
<p>Next, remember that we have types for streams (generators) from the <code class="sourceCode haskell"><span class="dt">IterT</span></code> monad:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Stream</span> n a <span class="fu">=</span> <span class="dt">DelayT</span> n ((,) a)</a></code></pre></div>
<p>And cons does indeed have the right type:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" data-line-number="1"><span class="ot">cons ::</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Stream</span> n a m b <span class="ot">-&gt;</span> <span class="dt">Stream</span> (<span class="dt">S</span> n) a m b</a>
<a class="sourceLine" id="cb31-2" data-line-number="2">cons x xs <span class="fu">=</span> <span class="dt">DelayT</span> (pure (<span class="dt">Later</span> (x,xs)))</a></code></pre></div>
<p>We also get an applicative:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" data-line-number="1"><span class="kw">instance</span> (<span class="dt">Applicative</span> f, <span class="dt">Applicative</span> m) <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb32-2" data-line-number="2">         <span class="dt">Applicative</span> (<span class="dt">DelayT</span> n f m) <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-3" data-line-number="3">    pure <span class="fu">=</span> <span class="dt">DelayT</span> <span class="fu">.</span> pure <span class="fu">.</span> <span class="dt">Now</span></a>
<a class="sourceLine" id="cb32-4" data-line-number="4">    <span class="dt">DelayT</span> fs&#39; <span class="fu">&lt;*&gt;</span> <span class="dt">DelayT</span> xs&#39; <span class="fu">=</span> <span class="dt">DelayT</span> (liftA2 go fs&#39; xs&#39;)</a>
<a class="sourceLine" id="cb32-5" data-line-number="5">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-6" data-line-number="6"><span class="ot">        go ::</span> <span class="ot">âˆ€</span> k a b<span class="fu">.</span> <span class="dt">Delay</span> k f m (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Delay</span> k f m a <span class="ot">-&gt;</span> <span class="dt">Delay</span> k f m b</a>
<a class="sourceLine" id="cb32-7" data-line-number="7">        go (<span class="dt">Now</span> f) <span class="fu">=</span> fmap f</a>
<a class="sourceLine" id="cb32-8" data-line-number="8">        go (<span class="dt">Later</span> fs) <span class="fu">=</span> <span class="dt">Later</span> <span class="fu">.</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb32-9" data-line-number="9">            <span class="dt">Now</span> x <span class="ot">-&gt;</span> fmap (fmap (<span class="fu">$</span>x)) fs</a>
<a class="sourceLine" id="cb32-10" data-line-number="10">            <span class="dt">Later</span> xs <span class="ot">-&gt;</span> liftA2 (<span class="fu">&lt;*&gt;</span>) fs xs</a></code></pre></div>
<p>Now, Iâ€™m not sure how much this stuff actually corresponds to the paper, but what caught my eye is the statement that <code class="sourceCode haskell"><span class="dt">De</span></code> is a classic â€œapplicative-not-monadâ€: just like <code class="sourceCode haskell"><span class="dt">ZipList</span></code>. However, under the analogy that the free monad is listy, and the parallel construction is ziplist-y, what we have in the <code class="sourceCode haskell"><span class="dt">DelayT</span></code> is the equivalent of a length-indexed list. These have an applicative instance similar to ziplists: but they also have a monad. Can we apply the same trick here?</p>
<h1 id="future-posts">Future Posts</h1>
<p>Thereâ€™s a lot of fascinating stuff out thereâ€”about clock variables, especiallyâ€”that I hope to get a chance to learn about once I get a chance. What Iâ€™m particularly interested to follow up on includes:</p>
<ol>
<li>Comonads and their relationship to these constructions. Streams are naturally expressed as comonads, could they be used as a basis on which to build a similar â€œdelayâ€ mechanism?</li>
<li>Iâ€™d love to explore more efficient implementations like the ones in <span class="citation" data-cites="spivey_faster_2017">Spivey (<a href="#ref-spivey_faster_2017">2017</a>)</span>.</li>
<li>Iâ€™m interested to see the relationship between these types, power series, and algebras for combinatorial search <span class="citation" data-cites="spivey_algebras_2009">(Spivey <a href="#ref-spivey_algebras_2009">2009</a>)</span>.</li>
</ol>
<h1 id="references" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-atkey_how_2011">
<p>Atkey, Robert. 2011. â€œHow to be a Productive Programmer - by putting things off until tomorrow.â€ Heriot-Watt University.</p>
</div>
<div id="ref-atkey_productive_2013">
<p>Atkey, Robert, and Conor McBride. 2013. â€œProductive coprogramming with guarded recursion.â€ In, 197. ACM Press. doi:<a href="https://doi.org/10.1145/2500365.2500597">10.1145/2500365.2500597</a>.</p>
</div>
<div id="ref-blazevic_coroutine_2011">
<p>BlaÅ¾eviÄ‡, Mario. 2011. â€œCoroutine Pipelines.â€ <em>The Monad.Reader</em> 19 (19) (August): 29â€“50.</p>
</div>
<div id="ref-capretta_partiality_2004">
<p>Capretta, Venanzio, Thorsten Altenkirch, and Tarmo Uustalu. 2004. â€œPartiality is an effect.â€ In <em>Dependently Typed Programming</em>, 04381:20. Dagstuhl Seminar Proceedings. Dagstuhl, Germany: Internationales Begegnungs- und Forschungszentrum fÃ¼r Informatik (IBFI), Schloss Dagstuhl, Germany.</p>
</div>
<div id="ref-gonzalez_pipes_2018">
<p>Gonzalez, Gabriel. 2018. â€œPipes: Compositional pipelines.â€</p>
</div>
<div id="ref-kiselyov_iteratees_2012">
<p>Kiselyov, Oleg. 2012. â€œIteratees.â€ In <em>Proceedings of the 11th International Conference on Functional and Logic Programming</em>, 166â€“181. Lecture Notes in Computer Science. Berlin, Heidelberg: Springer, Berlin, Heidelberg. doi:<a href="https://doi.org/10.1007/978-3-642-29822-6_15">10.1007/978-3-642-29822-6_15</a>.</p>
</div>
<div id="ref-mcbride_time_2009">
<p>McBride, Conor. 2009. â€œTime flies like an applicative functor.â€ <em>Epilogue for Epigram</em>.</p>
</div>
<div id="ref-spivey_algebras_2009">
<p>Spivey, J. Michael. 2009. â€œAlgebras for combinatorial search.â€ <em>Journal of Functional Programming</em> 19 (3-4) (July): 469â€“487. doi:<a href="https://doi.org/10.1017/S0956796809007321">10.1017/S0956796809007321</a>.</p>
</div>
<div id="ref-spivey_faster_2017">
<p>Spivey, Michael. 2017. â€œFaster coroutine pipelines.â€ <em>Proceedings of the ACM on Programming Languages</em> 1 (ICFP) (August): 1â€“23. doi:<a href="https://doi.org/10.1145/3110249">10.1145/3110249</a>.</p>
</div>
</div>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>There is a later, seemingly more formal version of the talk available <span class="citation" data-cites="capretta_partiality_2005">(<span class="citeproc-not-found" data-reference-id="capretta_partiality_2005"><strong>???</strong></span>)</span>, but the one from 2004 was a little easier for me to understand, and had a lot more Haskell code.<a href="#fnref1" class="footnote-back">â†©</a></p></li>
<li id="fn2"><p>Small note: <code>(,) a</code> and <code>(-&gt;) a</code> are adjunct. I wonder if there is any implication from this? Certainly, producers and consumers seem adjunct, but thereâ€™s no instance I can find for it in adjunctions.<a href="#fnref2" class="footnote-back">â†©</a></p></li>
</ol>
</section>
]]></description>
    <pubDate>Sat, 23 Jun 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-06-23-scheduling-effects.html</guid>
    <dc:creator>Donnacha OisÃ­n Kidney</dc:creator>
</item>
<item>
    <title>Breadth-First Traversals in Far Too Much Detail</title>
    <link>https://doisinkidney.com/posts/2018-06-03-breadth-first-traversals-in-too-much-detail.html</link>
    <description><![CDATA[<div class="info">
    Posted on June  3, 2018
</div>
<div class="info">
    
        Part 3 of a <a href="/series/Breadth-First%20Traversals.html">5-part series on Breadth-First Traversals</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<p>After looking at the algorithms I <a href="2018-06-01-rose-trees-breadth-first-traversing.html">posted last time</a>, I noticed some patterns emerging which I thought deserved a slightly longer post. Iâ€™ll go through the problem <span class="citation" data-cites="gibbons_breadth-first_2015">(Gibbons <a href="#ref-gibbons_breadth-first_2015">2015</a>)</span> in a little more detail, and present some more algorithms to go along with it.</p>
<h1 id="the-problem">The Problem</h1>
<p>The original question was posed by <a href="https://www.facebook.com/groups/programming.haskell/permalink/985981691412832/">Etian Chatav</a>:</p>
<blockquote>
<p>What is the correct way to write breadth first traversal of a <code class="sourceCode haskell">[<span class="dt">Tree</span>]</code>?</p>
</blockquote>
<p>The breadth-first traversal here is a traversal in the lensy sense, i.e:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">breadthFirst ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> [<span class="dt">Tree</span> a] <span class="ot">-&gt;</span> f [<span class="dt">Tree</span> b]</a></code></pre></div>
<p>The <code class="sourceCode haskell"><span class="dt">Tree</span></code> type weâ€™re referring to here is a rose tree; we can take the one defined in <a href="http://hackage.haskell.org/package/containers-0.5.11.0/docs/Data-Tree.html#t:Tree"><code class="sourceCode haskell"><span class="dt">Data.Tree</span></code></a>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Node</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">    {<span class="ot"> rootLabel ::</span> a</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">    ,<span class="ot"> subForest ::</span> [<span class="dt">Tree</span> a]</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">    }</a></code></pre></div>
<p>Finally, instead of solving the (somewhat intermediate) problem of traversing a forest, weâ€™ll look directly at traversing the tree itself. In other words, our solution should have the type:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">breadthFirst ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> f (<span class="dt">Tree</span> b)</a></code></pre></div>
<h1 id="breadth-first-enumeration">Breadth-First Enumeration</h1>
<p>As in <span class="citation" data-cites="gibbons_breadth-first_2015">Gibbons (<a href="#ref-gibbons_breadth-first_2015">2015</a>)</span>, letâ€™s first look at just converting the tree to a list in breadth-first order. In other words, given the tree:</p>
<pre><code>   â”Œ3
 â”Œ2â”¤
 â”‚ â””4
1â”¤
 â”‚ â”Œ6
 â””5â”¤
   â””7</code></pre>
<p>We want the list:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1">[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">5</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">6</span>,<span class="dv">7</span>]</a></code></pre></div>
<p>Last time I looked at this problem, the function I arrived at was as follows:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">breadthFirstEnumerate ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">breadthFirstEnumerate ts <span class="fu">=</span> f ts b []</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">    f (<span class="dt">Node</span> x xs) fw bw <span class="fu">=</span> x <span class="fu">:</span> fw (xs <span class="fu">:</span> bw)</a>
<a class="sourceLine" id="cb6-5" data-line-number="5"></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">    b [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">    b qs <span class="fu">=</span> foldl (foldr f) b qs []</a></code></pre></div>
<p>Itâ€™s admittedly a little difficult to understand, but itâ€™s really not too complex: weâ€™re popping items off the front of a queue, and pushing the subforest onto the end. <code class="sourceCode haskell">fw</code> is the recursive call here: thatâ€™s where we send the queue with the element pushed on. Even though it may <em>look</em> like weâ€™re pushing onto the front (as weâ€™re using a cons), this is really the <em>end</em> of the queue, since itâ€™s being consumed in reverse, with <code class="sourceCode haskell">foldl</code>.</p>
<p>We can compare it to the technique used in <span class="citation" data-cites="allison_circular_2006">Allison (<a href="#ref-allison_circular_2006">2006</a>)</span> and <span class="citation" data-cites="smith_lloyd_2009">Smith (<a href="#ref-smith_lloyd_2009">2009</a>)</span>, where itâ€™s called <em>corecursive queues</em>. Breadth-first enumeration is accomplished as follows in <span class="citation" data-cites="smith_lloyd_2009">Smith (<a href="#ref-smith_lloyd_2009">2009</a>)</span>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">levelOrder ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">levelOrder tr <span class="fu">=</span> map rootLabel qs</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">    qs <span class="fu">=</span> enqs [tr] <span class="dv">0</span> qs</a>
<a class="sourceLine" id="cb7-5" data-line-number="5"></a>
<a class="sourceLine" id="cb7-6" data-line-number="6">    enqs []     n xs <span class="fu">=</span> deq n xs</a>
<a class="sourceLine" id="cb7-7" data-line-number="7">    enqs (t<span class="fu">:</span>ts) n xs <span class="fu">=</span> t <span class="fu">:</span> enqs  ts (n<span class="fu">+</span><span class="dv">1</span>) xs</a>
<a class="sourceLine" id="cb7-8" data-line-number="8"></a>
<a class="sourceLine" id="cb7-9" data-line-number="9">    deq <span class="dv">0</span> _      <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb7-10" data-line-number="10">    deq n (x<span class="fu">:</span>xs) <span class="fu">=</span> enqs (subForest x) (n<span class="fu">-</span><span class="dv">1</span>) xs</a></code></pre></div>
<p>We get to avoid tracking the length of the queue, however.</p>
<h1 id="level-order-enumeration">Level-Order Enumeration</h1>
<p>Before we go the full way to traversal, we can try add a little structure to our breadth-first enumeration, by delimiting between levels in the tree. We want our function to have the following type:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">levels ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [[a]]</a></code></pre></div>
<p>Looking back at our example tree:</p>
<pre><code>   â”Œ3
 â”Œ2â”¤
 â”‚ â””4
1â”¤
 â”‚ â”Œ6
 â””5â”¤
   â””7</code></pre>
<p>We now want the list:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">[[<span class="dv">1</span>],[<span class="dv">2</span>,<span class="dv">5</span>],[<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">6</span>,<span class="dv">7</span>]]</a></code></pre></div>
<p>This function is strictly more powerful than <code class="sourceCode haskell">breadthFirstEnumerate</code>, as we can define one in terms of the other:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1">breadthFirstEnumerate <span class="fu">=</span> concat <span class="fu">.</span> levels</a></code></pre></div>
<p>Itâ€™s also just a generally useful function, so there are several example implementations available online.</p>
<h3 id="iterative-style">Iterative-Style</h3>
<p>The one provided in <a href="http://hackage.haskell.org/package/containers-0.5.11.0/docs/src/Data.Tree.html#levels">Data.Tree</a> is as follows:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1">levels t <span class="fu">=</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">    map (map rootLabel) <span class="fu">$</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">        takeWhile (not <span class="fu">.</span> null) <span class="fu">$</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">        iterate (concatMap subForest) [t]</a></code></pre></div>
<p>Pretty nice, but it looks to me like itâ€™s doing a lot of redundant work. We could write it as an unfold:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1">levels t <span class="fu">=</span>  unfoldr (f <span class="fu">.</span> concat) [[t]]</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">    f [] <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4">    f xs <span class="fu">=</span> <span class="dt">Just</span> (unzip [(y,ys) <span class="fu">|</span> <span class="dt">Node</span> y ys <span class="ot">&lt;-</span> xs])</a></code></pre></div>
<p>The performance danger here lies in <code class="sourceCode haskell">unzip</code>: one could potentially optimize that for a speedup.</p>
<h3 id="with-an-implicit-queue">With an (implicit) Queue</h3>
<p>Another definition, in the style of <code class="sourceCode haskell">breadthFirstEnumerate</code> above, is as follows:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1">levels ts <span class="fu">=</span> f b ts [] []</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3">    f k (<span class="dt">Node</span> x xs) ls qs <span class="fu">=</span> k (x <span class="fu">:</span> ls) (xs <span class="fu">:</span> qs)</a>
<a class="sourceLine" id="cb14-4" data-line-number="4"></a>
<a class="sourceLine" id="cb14-5" data-line-number="5">    b _ [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb14-6" data-line-number="6">    b k qs <span class="fu">=</span> k <span class="fu">:</span> foldl (foldl f) b qs [] []</a></code></pre></div>
<p>Here, we maintain a stack building up the current level, as well as a queue that we send to the next level. Because weâ€™re consing onto the front of the stack, the subforest needs to be traversed in reverse, to build up the output list in the right order. This is why weâ€™re using a second <code class="sourceCode haskell">foldl</code> here, whereas the original had <code class="sourceCode haskell">foldr</code> on the inner loop.</p>
<h3 id="zippy-style">Zippy-Style</h3>
<p>Looking at the implicit queue version, I noticed that itâ€™s just using a church-encoded pair to reverse the direction of the fold. Instead of doing both reversals, we can use a normal pair, and run it in one direction:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1">levels ts <span class="fu">=</span> b (f ts ([],[]))</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-3" data-line-number="3">    f (<span class="dt">Node</span> x xs) (ls,qs) <span class="fu">=</span> (x<span class="fu">:</span>ls,xs<span class="fu">:</span>qs)</a>
<a class="sourceLine" id="cb15-4" data-line-number="4"></a>
<a class="sourceLine" id="cb15-5" data-line-number="5">    b (_,[]) <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb15-6" data-line-number="6">    b (k,qs) <span class="fu">=</span> k <span class="fu">:</span> b (foldr (flip (foldr f)) ([],[]) qs)</a></code></pre></div>
<p>Secondly, weâ€™re running a fold on the second component of the pair: why not run the fold immediately, rather than building the intermediate list. In fact, weâ€™re running a fold over the <em>whole</em> thing, which we can do straight away:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1">levels ts <span class="fu">=</span> f ts []</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3">    f (<span class="dt">Node</span> x xs) (q<span class="fu">:</span>qs) <span class="fu">=</span> (x<span class="fu">:</span>q) <span class="fu">:</span> foldr f qs xs</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">    f (<span class="dt">Node</span> x xs) []     <span class="fu">=</span> [x]   <span class="fu">:</span> foldr f [] xs</a></code></pre></div>
<p>After looking at it for a while, I realized itâ€™s similar to an inlined version of the algorithm presented in <span class="citation" data-cites="gibbons_breadth-first_2015">Gibbons (<a href="#ref-gibbons_breadth-first_2015">2015</a>)</span>:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1">levels t <span class="fu">=</span> [rootLabel t] <span class="fu">:</span> foldr (lzw (<span class="fu">++</span>)) [] (map levels (subForest t))</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb17-3" data-line-number="3">    lzw f (x<span class="fu">:</span>xs) (y<span class="fu">:</span>ys) <span class="fu">=</span> f x y <span class="fu">:</span> lzw f xs ys</a>
<a class="sourceLine" id="cb17-4" data-line-number="4">    lzw _ xs [] <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb17-5" data-line-number="5">    lzw _ [] ys <span class="fu">=</span> ys</a></code></pre></div>
<h1 id="cofree">Cofree</h1>
<p>Before going any further, all of the functions so far can be redefined to work on the <a href="http://hackage.haskell.org/package/free-5.0.2/docs/Control-Comonad-Cofree.html">cofree comonad</a>:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Cofree</span> f a <span class="fu">=</span> a <span class="fu">:&lt;</span> f (<span class="dt">Cofree</span> f a)</a></code></pre></div>
<p>When <code class="sourceCode haskell">f</code> is specialized to <code class="sourceCode haskell">[]</code>, we get the original rose tree. So far, though, all we actually require is <code class="sourceCode haskell"><span class="dt">Foldable</span></code>.</p>
<p>From now on, then, weâ€™ll use <code class="sourceCode haskell"><span class="dt">Cofree</span></code> instead of <code class="sourceCode haskell"><span class="dt">Tree</span></code>.</p>
<h1 id="traversing">Traversing</h1>
<p>Finally, we can begin on the traversal itself. We know how to execute the effects in the right order, whatâ€™s missing is to build the tree back up in the right order.</p>
<h3 id="filling">Filling</h3>
<p>First thing weâ€™ll use is a trick with <code class="sourceCode haskell"><span class="dt">Traversable</span></code>, where we fill a container from a list. In other words:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1">fill [(),(),(),()] [<span class="dv">1</span><span class="fu">..</span>] <span class="fu">=</span> ([<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>],[<span class="dv">5</span><span class="fu">..</span>])</a></code></pre></div>
<p>With the state monad (or applicative, in this case, I suppose), we can define a â€œpopâ€ action, which takes an element from the supply:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1">pop <span class="fu">=</span> state (\(x<span class="fu">:</span>xs) <span class="ot">-&gt;</span> (x,xs))</a></code></pre></div>
<p>And then we <code class="sourceCode haskell">traverse</code> that action over our container:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1">fill <span class="fu">=</span> traverse (const pop)</a></code></pre></div>
<p>When we use fill, itâ€™ll have the following type:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="ot">breadthFirst ::</span> (<span class="dt">Applicative</span> f, <span class="dt">Traversable</span> t)</a>
<a class="sourceLine" id="cb22-2" data-line-number="2">             <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> <span class="dt">Cofree</span> t a <span class="ot">-&gt;</span> f (<span class="dt">Cofree</span> t b)</a>
<a class="sourceLine" id="cb22-3" data-line-number="3">breadthFirst <span class="fu">=</span> <span class="fu">...</span></a>
<a class="sourceLine" id="cb22-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-5" data-line-number="5">    <span class="fu">...</span></a>
<a class="sourceLine" id="cb22-6" data-line-number="6"><span class="ot">    fill ::</span> t (<span class="dt">Cofree</span> t a) <span class="ot">-&gt;</span> <span class="dt">State</span> [<span class="dt">Cofree</span> t b] (t (<span class="dt">Cofree</span> t b))</a>
<a class="sourceLine" id="cb22-7" data-line-number="7">    fill <span class="fu">=</span> traverse (const pop)</a></code></pre></div>
<p>Hopefully that makes sense: weâ€™re going to get the subforest from here:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Cofree</span> t a <span class="fu">=</span> a <span class="fu">:&lt;</span> t (<span class="dt">Cofree</span> t a)</a>
<a class="sourceLine" id="cb23-2" data-line-number="2">                       <span class="fu">^^^^^^^^^^^^^^</span></a></code></pre></div>
<p>And weâ€™re going to fill it with the result of the traversal, which changes the contents from <code>a</code>s to <code>b</code>s.</p>
<h3 id="composing-applicatives">Composing Applicatives</h3>
<p>One of the nice things about working with applicatives is that they compose, in a variety of different ways. In other words, if I have one effect, <code class="sourceCode haskell">f</code>, and another <code class="sourceCode haskell">g</code>, and I want to run them both on the contents of some list, I can do it in one pass, either by layering the effects, or putting them side-by-side.</p>
<p>In our case, we need to deal with two effects: the one generated by the traversal, (the one the caller wants to use), and the internal state weâ€™re using to fill up the forests in our tree. We could use <a href="http://hackage.haskell.org/package/base-4.11.1.0/docs/Data-Functor-Compose.html#t:Compose"><code class="sourceCode haskell"><span class="dt">Compose</span></code></a> explicitly, but we can avoid some calls to <code class="sourceCode haskell">pure</code> if we write the combinators weâ€™re going to use directly:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1">map2</a>
<a class="sourceLine" id="cb24-2" data-line-number="2"><span class="ot">    ::</span> (<span class="dt">Functor</span> f, <span class="dt">Functor</span> g)</a>
<a class="sourceLine" id="cb24-3" data-line-number="3">    <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> g b <span class="ot">-&gt;</span> f (g c)</a>
<a class="sourceLine" id="cb24-4" data-line-number="4">map2 f x xs <span class="fu">=</span></a>
<a class="sourceLine" id="cb24-5" data-line-number="5">    fmap (\y <span class="ot">-&gt;</span> fmap (f y) xs) x</a>
<a class="sourceLine" id="cb24-6" data-line-number="6"></a>
<a class="sourceLine" id="cb24-7" data-line-number="7">app2</a>
<a class="sourceLine" id="cb24-8" data-line-number="8"><span class="ot">    ::</span> (<span class="dt">Applicative</span> f, <span class="dt">Applicative</span> g)</a>
<a class="sourceLine" id="cb24-9" data-line-number="9">    <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> g b <span class="ot">-&gt;</span> f (g c) <span class="ot">-&gt;</span> f (g d)</a>
<a class="sourceLine" id="cb24-10" data-line-number="10">app2 f x xs <span class="fu">=</span></a>
<a class="sourceLine" id="cb24-11" data-line-number="11">    liftA2 (\y <span class="ot">-&gt;</span> liftA2 (f y) xs) x</a></code></pre></div>
<p>The outer applicative (<code>f</code>) will be the userâ€™s effect, the inner will be <code>State</code>.</p>
<h1 id="take-1-zippy-style-traversing">Take 1: Zippy-Style Traversing</h1>
<p>First weâ€™ll try convert the zippy-style <code class="sourceCode haskell">levels</code> to a traversal. First, convert the function over to the cofree comonad:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1">levels tr <span class="fu">=</span> f tr []</a>
<a class="sourceLine" id="cb25-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-3" data-line-number="3">    f (x<span class="fu">:&lt;</span>xs) (q<span class="fu">:</span>qs) <span class="fu">=</span> (x<span class="fu">:</span>q) <span class="fu">:</span> foldr f qs xs</a>
<a class="sourceLine" id="cb25-4" data-line-number="4">    f (x<span class="fu">:&lt;</span>xs) []     <span class="fu">=</span> [x]   <span class="fu">:</span> foldr f [] xs</a></code></pre></div>
<p>Next, instead of building up a list of just the root labels, weâ€™ll pair them with the subforests:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1">breadthFirst tr <span class="fu">=</span> f tr []</a>
<a class="sourceLine" id="cb26-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb26-3" data-line-number="3">    f (x<span class="fu">:&lt;</span>xs) (q<span class="fu">:</span>qs) <span class="fu">=</span> ((x,xs)<span class="fu">:</span>q) <span class="fu">:</span> foldr f qs xs</a>
<a class="sourceLine" id="cb26-4" data-line-number="4">    f (x<span class="fu">:&lt;</span>xs) []     <span class="fu">=</span> [(x,xs)]   <span class="fu">:</span> foldr f [] xs</a></code></pre></div>
<p>Next, weâ€™ll fill the subforests:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1">breadthFirst tr <span class="fu">=</span> f tr []</a>
<a class="sourceLine" id="cb27-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb27-3" data-line-number="3">    f (x<span class="fu">:&lt;</span>xs) (q<span class="fu">:</span>qs) <span class="fu">=</span> ((x,fill xs)<span class="fu">:</span>q) <span class="fu">:</span> foldr f qs xs</a>
<a class="sourceLine" id="cb27-4" data-line-number="4">    f (x<span class="fu">:&lt;</span>xs) []     <span class="fu">=</span> [(x,fill xs)]   <span class="fu">:</span> foldr f [] xs</a></code></pre></div>
<p>Then, we can run the applicative effect on the root label:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1">breadthFirst c tr <span class="fu">=</span> f tr []</a>
<a class="sourceLine" id="cb28-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb28-3" data-line-number="3">    f (x<span class="fu">:&lt;</span>xs) (q<span class="fu">:</span>qs) <span class="fu">=</span> ((c x,fill xs)<span class="fu">:</span>q) <span class="fu">:</span> foldr f qs xs</a>
<a class="sourceLine" id="cb28-4" data-line-number="4">    f (x<span class="fu">:&lt;</span>xs) []     <span class="fu">=</span> [(c x,fill xs)]   <span class="fu">:</span> foldr f [] xs</a></code></pre></div>
<p>Now, to combine the effects, we can use the combinators we defined before:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" data-line-number="1">breadthFirst c tr <span class="fu">=</span> f tr []</a>
<a class="sourceLine" id="cb29-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb29-3" data-line-number="3">    f (x<span class="fu">:&lt;</span>xs) (q<span class="fu">:</span>qs) <span class="fu">=</span></a>
<a class="sourceLine" id="cb29-4" data-line-number="4">        app2 (\y ys zs <span class="ot">-&gt;</span> (y<span class="fu">:&lt;</span>ys) <span class="fu">:</span> zs) (c x) (fill xs) q <span class="fu">:</span> foldr f qs xs</a>
<a class="sourceLine" id="cb29-5" data-line-number="5">    f (x<span class="fu">:&lt;</span>xs) [] <span class="fu">=</span></a>
<a class="sourceLine" id="cb29-6" data-line-number="6">        map2 (\y ys <span class="ot">-&gt;</span> [y<span class="fu">:&lt;</span>ys]) (c x) (fill xs) <span class="fu">:</span> foldr f [] xs</a></code></pre></div>
<p>This builds a list containing all of the level-wise traversals of the tree. To collapse them into one, we can use a fold:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="ot">breadthFirst ::</span> (<span class="dt">Traversable</span> t, <span class="dt">Applicative</span> f)</a>
<a class="sourceLine" id="cb30-2" data-line-number="2">             <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b)</a>
<a class="sourceLine" id="cb30-3" data-line-number="3">             <span class="ot">-&gt;</span> <span class="dt">Cofree</span> t a</a>
<a class="sourceLine" id="cb30-4" data-line-number="4">             <span class="ot">-&gt;</span> f (<span class="dt">Cofree</span> t b)</a>
<a class="sourceLine" id="cb30-5" data-line-number="5">breadthFirst c tr <span class="fu">=</span></a>
<a class="sourceLine" id="cb30-6" data-line-number="6">    head <span class="fu">&lt;$&gt;</span> foldr (liftA2 evalState) (pure []) (f tr [])</a>
<a class="sourceLine" id="cb30-7" data-line-number="7">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-8" data-line-number="8">    f (x<span class="fu">:&lt;</span>xs) (q<span class="fu">:</span>qs) <span class="fu">=</span></a>
<a class="sourceLine" id="cb30-9" data-line-number="9">        app2 (\y ys zs <span class="ot">-&gt;</span> (y<span class="fu">:&lt;</span>ys)<span class="fu">:</span>zs) (c x) (fill xs) q <span class="fu">:</span> foldr f qs xs</a>
<a class="sourceLine" id="cb30-10" data-line-number="10">    f (x<span class="fu">:&lt;</span>xs) [] <span class="fu">=</span></a>
<a class="sourceLine" id="cb30-11" data-line-number="11">        map2 (\y ys <span class="ot">-&gt;</span> [y<span class="fu">:&lt;</span>ys]) (c x) (fill xs) <span class="fu">:</span> foldr f [] xs</a></code></pre></div>
<h1 id="take-2-queue-based-traversing">Take 2: Queue-Based Traversing</h1>
<p>Converting the queue-based implementation is easy once weâ€™ve done it with the zippy one. The result is (to my eye) a little easier to read, also:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" data-line-number="1">breadthFirst</a>
<a class="sourceLine" id="cb31-2" data-line-number="2"><span class="ot">    ::</span> (<span class="dt">Applicative</span> f, <span class="dt">Traversable</span> t)</a>
<a class="sourceLine" id="cb31-3" data-line-number="3">    <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> <span class="dt">Cofree</span> t a <span class="ot">-&gt;</span> f (<span class="dt">Cofree</span> t b)</a>
<a class="sourceLine" id="cb31-4" data-line-number="4">breadthFirst c tr <span class="fu">=</span></a>
<a class="sourceLine" id="cb31-5" data-line-number="5">    fmap head (f b tr e [])</a>
<a class="sourceLine" id="cb31-6" data-line-number="6">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb31-7" data-line-number="7">    f k (x<span class="fu">:&lt;</span>xs) ls qs <span class="fu">=</span></a>
<a class="sourceLine" id="cb31-8" data-line-number="8">      k (app2 (\y ys zs <span class="ot">-&gt;</span> (y<span class="fu">:&lt;</span>ys)<span class="fu">:</span>zs) (c x) (fill xs) ls) (xs<span class="fu">:</span>qs)</a>
<a class="sourceLine" id="cb31-9" data-line-number="9"></a>
<a class="sourceLine" id="cb31-10" data-line-number="10">    b _ [] <span class="fu">=</span> pure []</a>
<a class="sourceLine" id="cb31-11" data-line-number="11">    b l qs <span class="fu">=</span> liftA2 evalState l (foldl (foldl f) b qs e [])</a>
<a class="sourceLine" id="cb31-12" data-line-number="12"></a>
<a class="sourceLine" id="cb31-13" data-line-number="13">    e <span class="fu">=</span> pure (pure [])</a></code></pre></div>
<p>There are a couple things to notice here: first, weâ€™re not using <code class="sourceCode haskell">map2</code> anywhere. Thatâ€™s because in the zippy version we were able to notice when the queue was exhausted, so we could just output the singleton effect. Here, instead, weâ€™re using <code class="sourceCode haskell">pure (pure [])</code>: this is potentially a source of inefficiency, as <code class="sourceCode haskell">liftA2 f (pure x) y</code> is less efficient than <code class="sourceCode haskell">fmap (f x) y</code> for some applicatives.</p>
<p>On the other hand, we donâ€™t build up a list of levels to be combined with <code class="sourceCode haskell">foldr (liftA2 evalState)</code> at any point: we combine them at every level immediately. You may be able to do the same in the zippy version, but I havenâ€™t figured it out yet.</p>
<h3 id="yoneda">Yoneda</h3>
<p>The final point to make here is to do with the very last thing we do in the traversal: <code class="sourceCode haskell">fmap head</code>. Strictly speaking, any <code class="sourceCode haskell">fmap</code>s in the code should be unnecessary: we <em>should</em> be able to fuse them all with any call to <code class="sourceCode haskell">liftA2</code>. This transformation is often called the â€œYoneda embeddingâ€. We can use it here like so:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" data-line-number="1">breadthFirst</a>
<a class="sourceLine" id="cb32-2" data-line-number="2"><span class="ot">    ::</span> <span class="ot">âˆ€</span> t a f b<span class="fu">.</span> (<span class="dt">Traversable</span> t, <span class="dt">Applicative</span> f)</a>
<a class="sourceLine" id="cb32-3" data-line-number="3">    <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> <span class="dt">Cofree</span> t a <span class="ot">-&gt;</span> f (<span class="dt">Cofree</span> t b)</a>
<a class="sourceLine" id="cb32-4" data-line-number="4">breadthFirst c tr <span class="fu">=</span> f (b head) tr e []</a>
<a class="sourceLine" id="cb32-5" data-line-number="5">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-6" data-line-number="6">    f k (x<span class="fu">:&lt;</span>xs) ls qs <span class="fu">=</span></a>
<a class="sourceLine" id="cb32-7" data-line-number="7">        k (app2 (\y ys zs <span class="ot">-&gt;</span> (y<span class="fu">:&lt;</span>ys) <span class="fu">:</span> zs) (c x) (fill xs) ls) (xs <span class="fu">:</span> qs)</a>
<a class="sourceLine" id="cb32-8" data-line-number="8"></a>
<a class="sourceLine" id="cb32-9" data-line-number="9"><span class="ot">    b ::</span> <span class="ot">âˆ€</span> x<span class="fu">.</span> ([<span class="dt">Cofree</span> t b] <span class="ot">-&gt;</span> x)</a>
<a class="sourceLine" id="cb32-10" data-line-number="10">      <span class="ot">-&gt;</span> f (<span class="dt">State</span> [<span class="dt">Cofree</span> t b] [<span class="dt">Cofree</span> t b])</a>
<a class="sourceLine" id="cb32-11" data-line-number="11">      <span class="ot">-&gt;</span> [t (<span class="dt">Cofree</span> t a)]</a>
<a class="sourceLine" id="cb32-12" data-line-number="12">      <span class="ot">-&gt;</span> f x</a>
<a class="sourceLine" id="cb32-13" data-line-number="13">    b k _ [] <span class="fu">=</span> pure (k [])</a>
<a class="sourceLine" id="cb32-14" data-line-number="14">    b k l qs <span class="fu">=</span></a>
<a class="sourceLine" id="cb32-15" data-line-number="15">        liftA2 (\x <span class="ot">-&gt;</span> k <span class="fu">.</span> evalState x) l (foldl (foldl f) (b id) qs e [])</a>
<a class="sourceLine" id="cb32-16" data-line-number="16"></a>
<a class="sourceLine" id="cb32-17" data-line-number="17">    e <span class="fu">=</span> pure (pure [])</a></code></pre></div>
<p>Notice that we need scoped type variables here, since the type of <code class="sourceCode haskell">b</code> changes depending on when itâ€™s called.</p>
<h1 id="take-3-iterative-traversing">Take 3: Iterative Traversing</h1>
<p>Transforming the iterative version is slightly different from the other two:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" data-line-number="1">breadthFirst c tr <span class="fu">=</span> fmap head (go [tr])</a>
<a class="sourceLine" id="cb33-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb33-3" data-line-number="3">    go [] <span class="fu">=</span> pure []</a>
<a class="sourceLine" id="cb33-4" data-line-number="4">    go xs <span class="fu">=</span></a>
<a class="sourceLine" id="cb33-5" data-line-number="5">        liftA2</a>
<a class="sourceLine" id="cb33-6" data-line-number="6">            evalState</a>
<a class="sourceLine" id="cb33-7" data-line-number="7">            (getCompose (traverse f xs))</a>
<a class="sourceLine" id="cb33-8" data-line-number="8">            (go (foldr (\(_<span class="fu">:&lt;</span>ys) b <span class="ot">-&gt;</span> foldr (<span class="fu">:</span>) b ys) [] xs))</a>
<a class="sourceLine" id="cb33-9" data-line-number="9">    f (x<span class="fu">:&lt;</span>xs) <span class="fu">=</span> <span class="dt">Compose</span> (map2 (<span class="fu">:&lt;</span>) (c x) (fill xs))</a></code></pre></div>
<p>Weâ€™re using <code class="sourceCode haskell"><span class="dt">Compose</span></code> directly here, in contrast to the other two algorithms.</p>
<h1 id="comparison">Comparison</h1>
<p>Performance-wise, no one algorithm wins out in every case. For enumeration, the zippy algorithm is the fastest in most casesâ€”except when the tree had a large branching factor; then, the iterative algorithm wins out. For the traversals, the iterative algorithm is usually betterâ€”except for monads with more expensive applicative instances.</p>
<p>Iâ€™m still not convinced that the zippy traversal is as optimized as it could be, however. If anyone has a better implementation, Iâ€™d love to see it!</p>
<h1 id="fusion">Fusion</h1>
<p>Using the composability of applicatives, we can fuse several operations over traversables into one pass. Unfortunately, however, this can often introduce a memory overhead that makes the whole operation slower overall. One such example is the iterative algorithm above:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" data-line-number="1">breadthFirst c tr <span class="fu">=</span> fmap head (go [tr])</a>
<a class="sourceLine" id="cb34-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb34-3" data-line-number="3">    go [] <span class="fu">=</span> pure []</a>
<a class="sourceLine" id="cb34-4" data-line-number="4">    go xs <span class="fu">=</span> liftA2 evalState zs (go (ys []))</a>
<a class="sourceLine" id="cb34-5" data-line-number="5">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb34-6" data-line-number="6">        <span class="dt">Compose</span> (<span class="dt">Endo</span> ys,<span class="dt">Compose</span> zs) <span class="fu">=</span> traverse f xs</a>
<a class="sourceLine" id="cb34-7" data-line-number="7">    f (x <span class="fu">:&lt;</span> xs) <span class="fu">=</span></a>
<a class="sourceLine" id="cb34-8" data-line-number="8">        <span class="dt">Compose</span></a>
<a class="sourceLine" id="cb34-9" data-line-number="9">            (<span class="dt">Endo</span> (flip (foldr (<span class="fu">:</span>)) xs)</a>
<a class="sourceLine" id="cb34-10" data-line-number="10">            ,<span class="dt">Compose</span> (map2 (<span class="fu">:&lt;</span>) (c x) (fill xs)))</a></code></pre></div>
<p>We only traverse the subforest of each node once now, fusing the fill operation with building the list to send to the recursive call. This is expensive (especially memory-wise), though, and traversing the descendant is cheap; the result is that the one-pass version is slower (in my tests).</p>
<h1 id="generalizing">Generalizing</h1>
<p>The cofree comonad allows us to generalize over the type of â€œdescendantsâ€â€”from lists (in <code class="sourceCode haskell"><span class="dt">Tree</span></code>) to anything traversable. We could also generalize over the type of the traversal itself: given a way to access the descendants of a node, we should be able to traverse all nodes in a breadth-first order. This kind of thing is usually accomplished by <a href="http://hackage.haskell.org/package/lens-4.16.1/docs/Control-Lens-Plated.html">Plated</a>: itâ€™s a class that gives you a traversal over the immediate descendants of some recursive type. Adapting the iterative version is relatively simple:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb35-1" data-line-number="1"><span class="ot">breadthFirstOf ::</span> <span class="dt">Traversal&#39;</span> a a <span class="ot">-&gt;</span> <span class="dt">Traversal&#39;</span> a a</a>
<a class="sourceLine" id="cb35-2" data-line-number="2">breadthFirstOf trav c tr <span class="fu">=</span> fmap head (go [tr])</a>
<a class="sourceLine" id="cb35-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb35-4" data-line-number="4">    go [] <span class="fu">=</span> pure []</a>
<a class="sourceLine" id="cb35-5" data-line-number="5">    go xs <span class="fu">=</span></a>
<a class="sourceLine" id="cb35-6" data-line-number="6">        liftA2</a>
<a class="sourceLine" id="cb35-7" data-line-number="7">            evalState</a>
<a class="sourceLine" id="cb35-8" data-line-number="8">            (getCompose (traverse f xs))</a>
<a class="sourceLine" id="cb35-9" data-line-number="9">            (go (foldr (\ys b <span class="ot">-&gt;</span> foldrOf trav (<span class="fu">:</span>) b ys) [] xs))</a>
<a class="sourceLine" id="cb35-10" data-line-number="10">    f xs <span class="fu">=</span> <span class="dt">Compose</span> (fmap fill (c xs))</a>
<a class="sourceLine" id="cb35-11" data-line-number="11">    fill <span class="fu">=</span> trav (const (<span class="dt">State</span> (\(x<span class="fu">:</span>xs) <span class="ot">-&gt;</span> (x, xs))))</a></code></pre></div>
<p>We can use this version to get back some of the old functions above:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" data-line-number="1"><span class="ot">breadthFirstEnumerate ::</span>  <span class="dt">Traversable</span> f <span class="ot">=&gt;</span> <span class="dt">Cofree</span> f a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb36-2" data-line-number="2">breadthFirstEnumerate <span class="fu">=</span> toListOf (breadthFirstOf plate <span class="fu">.</span> _extract)</a></code></pre></div>
<h1 id="unfolding">Unfolding</h1>
<p>Building a tree breadth-first, monadically, is still an unsolved problem <span class="citation" data-cites="feuer_is_2015">(it looks like: Feuer <a href="#ref-feuer_is_2015">2015</a>)</span>.</p>
<p>Using some of these we can implement a monadic breadth-first unfold for the cofree comonad:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb37-1" data-line-number="1"><span class="ot">unfoldM ::</span> (<span class="dt">Monad</span> m, <span class="dt">Traversable</span> t)</a>
<a class="sourceLine" id="cb37-2" data-line-number="2">        <span class="ot">=&gt;</span> (b <span class="ot">-&gt;</span> m (a, t b))</a>
<a class="sourceLine" id="cb37-3" data-line-number="3">        <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb37-4" data-line-number="4">        <span class="ot">-&gt;</span> m (<span class="dt">Cofree</span> t a)</a>
<a class="sourceLine" id="cb37-5" data-line-number="5">unfoldM c tr <span class="fu">=</span> go head [tr]</a>
<a class="sourceLine" id="cb37-6" data-line-number="6">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb37-7" data-line-number="7">    go k [] <span class="fu">=</span> pure (k [])</a>
<a class="sourceLine" id="cb37-8" data-line-number="8">    go k xs <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb37-9" data-line-number="9">        ys <span class="ot">&lt;-</span> traverse c xs</a>
<a class="sourceLine" id="cb37-10" data-line-number="10">        go (k <span class="fu">.</span> evalState (traverse f ys)) (toList (<span class="dt">Compose</span> (<span class="dt">Compose</span> ys)))</a>
<a class="sourceLine" id="cb37-11" data-line-number="11">    f (x,xs) <span class="fu">=</span> fmap (x<span class="fu">:&lt;</span>) (fill xs)</a></code></pre></div>
<h1 id="references" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-allison_circular_2006">
<p>Allison, Lloyd. 2006. â€œCircular Programs and Self-Referential Structures.â€ <em>Software: Practice and Experience</em> 19 (2) (October 30): 99â€“109. doi:<a href="https://doi.org/10.1002/spe.4380190202">10.1002/spe.4380190202</a>. <a href="http://users.monash.edu/~lloyd/tildeFP/1989SPE/" class="uri">http://users.monash.edu/~lloyd/tildeFP/1989SPE/</a>.</p>
</div>
<div id="ref-feuer_is_2015">
<p>Feuer, David. 2015. â€œIs a lazy, breadth-first monadic rose tree unfold possible?â€ Question. <em>Stack Overflow</em>. <a href="https://stackoverflow.com/q/27748526" class="uri">https://stackoverflow.com/q/27748526</a>.</p>
</div>
<div id="ref-gibbons_breadth-first_2015">
<p>Gibbons, Jeremy. 2015. â€œBreadth-First Traversal.â€ <em>Patterns in Functional Programming</em>. <a href="https://patternsinfp.wordpress.com/2015/03/05/breadth-first-traversal/" class="uri">https://patternsinfp.wordpress.com/2015/03/05/breadth-first-traversal/</a>.</p>
</div>
<div id="ref-smith_lloyd_2009">
<p>Smith, Leon P. 2009. â€œLloyd Allisonâ€™s Corecursive Queues: Why Continuations Matter.â€ <em>The Monad.Reader</em>, July 29. <a href="https://meldingmonads.files.wordpress.com/2009/06/corecqueues.pdf" class="uri">https://meldingmonads.files.wordpress.com/2009/06/corecqueues.pdf</a>.</p>
</div>
</div>
]]></description>
    <pubDate>Sun, 03 Jun 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-06-03-breadth-first-traversals-in-too-much-detail.html</guid>
    <dc:creator>Donnacha OisÃ­n Kidney</dc:creator>
</item>
<item>
    <title>Breadth-First Rose Trees: Traversals and the Cofree Comonad</title>
    <link>https://doisinkidney.com/posts/2018-06-01-rose-trees-breadth-first-traversing.html</link>
    <description><![CDATA[<div class="info">
    Posted on June  1, 2018
</div>
<div class="info">
    
        Part 2 of a <a href="/series/Breadth-First%20Traversals.html">5-part series on Breadth-First Traversals</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<p>I was looking again at the issue of writing breadth-first traversals for rose trees, and in particular the problem explored in <span class="citation" data-cites="gibbons_breadth-first_2015">Gibbons (<a href="#ref-gibbons_breadth-first_2015">2015</a>)</span>. The breadth-first traversal here is a traversal in the lensy sense.</p>
<p>First, letâ€™s look back at getting the levels out of the tree. Hereâ€™s the old function I arrived at last time:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">levels ::</span> <span class="dt">Forest</span> a <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">levels ts <span class="fu">=</span> foldl f b ts [] []</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">    f k (<span class="dt">Node</span> x xs) ls qs <span class="fu">=</span> k (x <span class="fu">:</span> ls) (xs <span class="fu">:</span> qs)</a>
<a class="sourceLine" id="cb1-5" data-line-number="5"></a>
<a class="sourceLine" id="cb1-6" data-line-number="6">    b _ [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb1-7" data-line-number="7">    b k qs <span class="fu">=</span> k <span class="fu">:</span> foldl (foldl f) b qs [] []</a></code></pre></div>
<p>After wrangling the definition a little, I got to the following (much cleaner) definition:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">levels ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">levels tr <span class="fu">=</span> f tr [] <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  f (<span class="dt">Node</span> x xs) (y<span class="fu">:</span>ys) <span class="fu">=</span> (x<span class="fu">:</span>y) <span class="fu">:</span> foldr f ys xs</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">  f (<span class="dt">Node</span> x xs) []     <span class="fu">=</span> [x]   <span class="fu">:</span> foldr f [] xs</a></code></pre></div>
<h1 id="cofree">Cofree</h1>
<p>Before going any further, all of the functions so far can be redefined to work on the <a href="http://hackage.haskell.org/package/free-5.0.2/docs/Control-Comonad-Cofree.html">cofree comonad</a>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Cofree</span> f a <span class="fu">=</span> a <span class="fu">:&lt;</span> f (<span class="dt">Cofree</span> f a)</a></code></pre></div>
<p>When <code class="sourceCode haskell">f</code> is specialized to <code class="sourceCode haskell">[]</code>, we get the original rose tree. But what we actually require is much less specific: <code class="sourceCode haskell">levels</code>, for instance, only needs <code class="sourceCode haskell"><span class="dt">Foldable</span></code>.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">levelsCofree ::</span> <span class="dt">Foldable</span> f <span class="ot">=&gt;</span> <span class="dt">Cofree</span> f a <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">levelsCofree tr <span class="fu">=</span> f tr []</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">    f (x<span class="fu">:&lt;</span>xs) (y<span class="fu">:</span>ys) <span class="fu">=</span> (x<span class="fu">:</span>y) <span class="fu">:</span> foldr f ys xs</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">    f (x<span class="fu">:&lt;</span>xs) []     <span class="fu">=</span> [x]   <span class="fu">:</span> foldr f [] xs</a></code></pre></div>
<p>Using this, we can write the efficient breadth-first traversal:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1">breadthFirst</a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="ot">    ::</span> (<span class="dt">Applicative</span> f, <span class="dt">Traversable</span> t)</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">    <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> <span class="dt">Cofree</span> t a <span class="ot">-&gt;</span> f (<span class="dt">Cofree</span> t b)</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">breadthFirst c (t<span class="fu">:&lt;</span>ts) <span class="fu">=</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">    liftA2 evalState (map2 (<span class="fu">:&lt;</span>) (c t) (fill ts)) chld</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-7" data-line-number="7">    chld <span class="fu">=</span> foldr (liftA2 evalState) (pure []) (foldr f [] ts)</a>
<a class="sourceLine" id="cb5-8" data-line-number="8">    fill <span class="fu">=</span> traverse (const (state (\(x<span class="fu">:</span>xs) <span class="ot">-&gt;</span> (x,xs))))</a>
<a class="sourceLine" id="cb5-9" data-line-number="9"></a>
<a class="sourceLine" id="cb5-10" data-line-number="10">    f (x<span class="fu">:&lt;</span>xs) (q<span class="fu">:</span>qs)</a>
<a class="sourceLine" id="cb5-11" data-line-number="11">        <span class="fu">=</span> app2 (\y ys zs <span class="ot">-&gt;</span> (y<span class="fu">:&lt;</span>ys) <span class="fu">:</span> zs) (c x) (fill xs) q</a>
<a class="sourceLine" id="cb5-12" data-line-number="12">        <span class="fu">:</span> foldr f qs xs</a>
<a class="sourceLine" id="cb5-13" data-line-number="13">    f (x<span class="fu">:&lt;</span>xs) []</a>
<a class="sourceLine" id="cb5-14" data-line-number="14">        <span class="fu">=</span> map2 (\y ys <span class="ot">-&gt;</span> [y<span class="fu">:&lt;</span>ys]) (c x) (fill xs)</a>
<a class="sourceLine" id="cb5-15" data-line-number="15">        <span class="fu">:</span> foldr f [] xs</a>
<a class="sourceLine" id="cb5-16" data-line-number="16"></a>
<a class="sourceLine" id="cb5-17" data-line-number="17">    map2 k x xs <span class="fu">=</span> fmap   (\y <span class="ot">-&gt;</span> fmap   (k y) xs) x</a>
<a class="sourceLine" id="cb5-18" data-line-number="18">    app2 k x xs <span class="fu">=</span> liftA2 (\y <span class="ot">-&gt;</span> liftA2 (k y) xs) x</a></code></pre></div>
<p>At every level, the subforestâ€™s shape it taken (<code class="sourceCode haskell">fill</code>), and itâ€™s traversed recursively. We can fuse these two steps into one:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1">breadthFirst</a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="ot">    ::</span> (<span class="dt">Traversable</span> t, <span class="dt">Applicative</span> f)</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">    <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> <span class="dt">Cofree</span> t a  <span class="ot">-&gt;</span> f (<span class="dt">Cofree</span> t b)</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">breadthFirst c (t<span class="fu">:&lt;</span>ts) <span class="fu">=</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">    liftA2</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">        evalState</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">        (map2 (<span class="fu">:&lt;</span>) (c t) fill)</a>
<a class="sourceLine" id="cb6-8" data-line-number="8">        (foldr (liftA2 evalState) (pure []) (chld []))</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-10" data-line-number="10">    <span class="dt">Compose</span> (<span class="dt">Endo</span> chld,fill) <span class="fu">=</span> go ts</a>
<a class="sourceLine" id="cb6-11" data-line-number="11"></a>
<a class="sourceLine" id="cb6-12" data-line-number="12">    go <span class="fu">=</span> traverse (\x <span class="ot">-&gt;</span> <span class="dt">Compose</span> (<span class="dt">Endo</span> (f x), state (\(y<span class="fu">:</span>ys) <span class="ot">-&gt;</span> (y,ys))))</a>
<a class="sourceLine" id="cb6-13" data-line-number="13"></a>
<a class="sourceLine" id="cb6-14" data-line-number="14">    f (x<span class="fu">:&lt;</span>xs) (q<span class="fu">:</span>qs) <span class="fu">=</span> app2 (\y ys zs <span class="ot">-&gt;</span> (y<span class="fu">:&lt;</span>ys) <span class="fu">:</span> zs) (c x) r q <span class="fu">:</span> rs qs</a>
<a class="sourceLine" id="cb6-15" data-line-number="15">      <span class="kw">where</span> <span class="dt">Compose</span> (<span class="dt">Endo</span> rs,r) <span class="fu">=</span> go xs</a>
<a class="sourceLine" id="cb6-16" data-line-number="16">    f (x<span class="fu">:&lt;</span>xs) [] <span class="fu">=</span> map2 (\y ys <span class="ot">-&gt;</span> [y<span class="fu">:&lt;</span>ys]) (c x) r <span class="fu">:</span> rs []</a>
<a class="sourceLine" id="cb6-17" data-line-number="17">      <span class="kw">where</span> <span class="dt">Compose</span> (<span class="dt">Endo</span> rs,r) <span class="fu">=</span> go xs</a>
<a class="sourceLine" id="cb6-18" data-line-number="18"></a>
<a class="sourceLine" id="cb6-19" data-line-number="19">    map2 k x xs <span class="fu">=</span> fmap   (\y <span class="ot">-&gt;</span> fmap   (k y) xs) x</a>
<a class="sourceLine" id="cb6-20" data-line-number="20">    app2 k x xs <span class="fu">=</span> liftA2 (\y <span class="ot">-&gt;</span> liftA2 (k y) xs) x</a></code></pre></div>
<p>The overhead from this approach scraps any benefit, though.</p>
<div id="refs" class="references">
<div id="ref-gibbons_breadth-first_2015">
<p>Gibbons, Jeremy. 2015. â€œBreadth-First Traversal.â€ <em>Patterns in Functional Programming</em>. <a href="https://patternsinfp.wordpress.com/2015/03/05/breadth-first-traversal/" class="uri">https://patternsinfp.wordpress.com/2015/03/05/breadth-first-traversal/</a>.</p>
</div>
</div>
]]></description>
    <pubDate>Fri, 01 Jun 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-06-01-rose-trees-breadth-first-traversing.html</guid>
    <dc:creator>Donnacha OisÃ­n Kidney</dc:creator>
</item>
<item>
    <title>Sorting Small Things in Haskell</title>
    <link>https://doisinkidney.com/posts/2018-05-06-sorting-small.html</link>
    <description><![CDATA[<div class="info">
    Posted on May  6, 2018
</div>
<div class="info">
    
        Part 1 of a <a href="/series/Sorting.html">1-part series on Sorting</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Algorithms.html">Algorithms</a>
    
</div>

<p>I was working on some performance-intensive stuff recently, and I ran into the issue of sorting very small amounts of values (think 3, 4, 5).</p>
<p>The standard way to do this is with <a href="https://en.wikipedia.org/wiki/Sorting_network">sorting networks</a>. The way Iâ€™ll be using doesnâ€™t actually perform any parallelism (unfortunately), but it is a clean way to write the networks in Haskell without too much repetition.</p>
<p><a href="http://pages.ripco.net/~jgamble/nw.html">This</a> website will generate an optimal sorting network for your given size, and the output (for 3) looks like this:</p>
<pre><code>[[1,2]]
[[0,2]]
[[0,1]]</code></pre>
<p>Each pair of indices represents a â€œcompare-and-swapâ€ operation: so the first line means â€œcompare the value at 1 to the value at 2: if itâ€™s bigger, swap themâ€. For 5, the network looks like this:</p>
<pre><code>[[0,1],[2,3]]
[[0,2],[1,3]]
[[1,2],[0,4]]
[[1,4]]
[[2,4]]
[[3,4]]</code></pre>
<p>Pairs on the same line can be performed in parallel.</p>
<p>For our case, Iâ€™m going to be looking at sorting tuples, but the technique can easily be generalized to vectors, etc.</p>
<p>The first trick is to figure out how to do â€œswappingâ€: we donâ€™t want mutation, so what we can do instead is swap the <em>reference</em> to some value, by shadowing its name. In other words:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">swap2 ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> (a, a)</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">swap2 lte x y <span class="fu">|</span> lte x y <span class="fu">=</span> (x, y)</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">              <span class="fu">|</span> otherwise <span class="fu">=</span> (y, x)</a>
<a class="sourceLine" id="cb3-4" data-line-number="4"></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="ot">sort3 ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> (a,a,a) <span class="ot">-&gt;</span> (a,a,a)</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">sort3 lte (_0,_1,_2)</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">    <span class="fu">=</span> <span class="kw">case</span> swap2 lte _1 _2 <span class="kw">of</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8">      (_1, _2) <span class="ot">-&gt;</span> <span class="kw">case</span> swap2 lte _0 _2 <span class="kw">of</span></a>
<a class="sourceLine" id="cb3-9" data-line-number="9">        (_0, _2) <span class="ot">-&gt;</span> <span class="kw">case</span> swap2 lte _0 _1 <span class="kw">of</span></a>
<a class="sourceLine" id="cb3-10" data-line-number="10">          (_0, _1) <span class="ot">-&gt;</span> (_0, _1, _2)</a></code></pre></div>
<p>The indentation is hard to read, though, and wrapping-and-unwrapping tuples makes me nervous about the performance (although it may be inlined). The next step is to <em>church-encode</em> the pairs returned:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">swap2 ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">swap2 lte x y k</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">    <span class="fu">|</span> lte x y <span class="fu">=</span> k x y</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">    <span class="fu">|</span> otherwise <span class="fu">=</span> k y x</a>
<a class="sourceLine" id="cb4-5" data-line-number="5"></a>
<a class="sourceLine" id="cb4-6" data-line-number="6"><span class="ot">sort3 ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> (a,a,a) <span class="ot">-&gt;</span> (a,a,a)</a>
<a class="sourceLine" id="cb4-7" data-line-number="7">sort3 lte (_0,_1,_2)</a>
<a class="sourceLine" id="cb4-8" data-line-number="8">    <span class="fu">=</span> swap2 lte _1 _2 <span class="fu">$</span> \ _1 _2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb4-9" data-line-number="9">      swap2 lte _0 _2 <span class="fu">$</span> \ _0 _2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb4-10" data-line-number="10">      swap2 lte _0 _1 <span class="fu">$</span> \ _0 _1 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb4-11" data-line-number="11">      (_0,_1,_2)</a></code></pre></div>
<p>Then, to get this to compile down to efficient code, we can make judicious use of <a href="http://hackage.haskell.org/package/base-4.11.1.0/docs/GHC-Exts.html#v:inline"><code class="sourceCode haskell">inline</code></a> from GHC.Exts:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">import</span> <span class="dt">GHC.Exts</span> (inline)</a>
<a class="sourceLine" id="cb5-2" data-line-number="2"></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="ot">swap2 ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">swap2 lte x y k</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">    <span class="fu">|</span> inline lte x y <span class="fu">=</span> inline k x y</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">    <span class="fu">|</span> otherwise <span class="fu">=</span> inline k y x</a>
<a class="sourceLine" id="cb5-7" data-line-number="7"><span class="ot">{-# INLINE swap2 #-}</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8"></a>
<a class="sourceLine" id="cb5-9" data-line-number="9"><span class="ot">sort3 ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> (a, a, a) <span class="ot">-&gt;</span> (a, a, a)</a>
<a class="sourceLine" id="cb5-10" data-line-number="10">sort3 lte (_0,_1,_2)</a>
<a class="sourceLine" id="cb5-11" data-line-number="11">    <span class="fu">=</span> swap2 lte _1 _2 <span class="fu">$</span> \ _1 _2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb5-12" data-line-number="12">      swap2 lte _0 _2 <span class="fu">$</span> \ _0 _2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb5-13" data-line-number="13">      swap2 lte _0 _1 <span class="fu">$</span> \ _0 _1 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb5-14" data-line-number="14">      (_0,_1,_2)</a>
<a class="sourceLine" id="cb5-15" data-line-number="15"><span class="ot">{-# INLINE sort3 #-}</span></a></code></pre></div>
<p>And to see if this really does make efficient code, letâ€™s look at the core (cleaned up):</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1">sort3</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  <span class="fu">=</span> \ (<span class="ot">lte ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">      (<span class="ot">ds ::</span> (a, a, a)) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">      <span class="kw">case</span> ds <span class="kw">of</span> wild_X8 (_0, _1, _2) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">      <span class="kw">case</span> lte _1 _2 <span class="kw">of</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">        <span class="dt">False</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb6-7" data-line-number="7">          <span class="kw">case</span> lte _0 _1 <span class="kw">of</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">            <span class="dt">False</span> <span class="ot">-&gt;</span> (_2, _1, _0)</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">            <span class="dt">True</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb6-10" data-line-number="10">              <span class="kw">case</span> lte _0 _2 <span class="kw">of</span></a>
<a class="sourceLine" id="cb6-11" data-line-number="11">                <span class="dt">False</span> <span class="ot">-&gt;</span> (_2, _0, _1)</a>
<a class="sourceLine" id="cb6-12" data-line-number="12">                <span class="dt">True</span> <span class="ot">-&gt;</span> (_0, _2, _1)</a>
<a class="sourceLine" id="cb6-13" data-line-number="13">        <span class="dt">True</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb6-14" data-line-number="14">          <span class="kw">case</span> lte _0 _2 <span class="kw">of</span></a>
<a class="sourceLine" id="cb6-15" data-line-number="15">            <span class="dt">False</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb6-16" data-line-number="16">              <span class="kw">case</span> lte _2 _1 <span class="kw">of</span></a>
<a class="sourceLine" id="cb6-17" data-line-number="17">                <span class="dt">False</span> <span class="ot">-&gt;</span> (_1, _2, _0)</a>
<a class="sourceLine" id="cb6-18" data-line-number="18">                <span class="dt">True</span> <span class="ot">-&gt;</span> (_2, _1, _0)</a>
<a class="sourceLine" id="cb6-19" data-line-number="19">            <span class="dt">True</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb6-20" data-line-number="20">              <span class="kw">case</span> lte _0 _1 <span class="kw">of</span></a>
<a class="sourceLine" id="cb6-21" data-line-number="21">                <span class="dt">False</span> <span class="ot">-&gt;</span> (_1, _0, _2)</a>
<a class="sourceLine" id="cb6-22" data-line-number="22">                <span class="dt">True</span> <span class="ot">-&gt;</span> wild_X8</a></code></pre></div>
<p>Fantastic! When we specialize to <code class="sourceCode haskell"><span class="dt">Int</span></code>, we get all of the proper unpacking:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">sort3Int ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Int</span>, <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">sort3Int <span class="fu">=</span> inline sort3 (<span class="fu">&lt;=</span>)</a></code></pre></div>
<p>Core (with just the variable names cleaned up this time):</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">sort3Int</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  <span class="fu">=</span> \ (<span class="ot">w ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>, <span class="dt">Int</span>)) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">      <span class="kw">case</span> w <span class="kw">of</span> w_X { (_0, _1, _2) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">      <span class="kw">case</span> _0 <span class="kw">of</span> w_0 { <span class="dt">GHC.Types.I</span><span class="fu">#</span> _0U <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5">      <span class="kw">case</span> _1 <span class="kw">of</span> w_1 { <span class="dt">GHC.Types.I</span><span class="fu">#</span> _1U <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">      <span class="kw">case</span> _2 <span class="kw">of</span> w_2 { <span class="dt">GHC.Types.I</span><span class="fu">#</span> _2U <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb8-7" data-line-number="7">      <span class="kw">case</span> <span class="fu">GHC.Prim.&lt;=#</span> _1U _2U <span class="kw">of</span> {</a>
<a class="sourceLine" id="cb8-8" data-line-number="8">        __DEFAULT <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb8-9" data-line-number="9">          <span class="kw">case</span> <span class="fu">GHC.Prim.&lt;=#</span> _0U _1U <span class="kw">of</span> {</a>
<a class="sourceLine" id="cb8-10" data-line-number="10">            __DEFAULT <span class="ot">-&gt;</span> (w_2, w_1, w_0);</a>
<a class="sourceLine" id="cb8-11" data-line-number="11">            <span class="dv">1</span><span class="fu">#</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb8-12" data-line-number="12">              <span class="kw">case</span> <span class="fu">GHC.Prim.&lt;=#</span> _0U _2U <span class="kw">of</span> {</a>
<a class="sourceLine" id="cb8-13" data-line-number="13">                __DEFAULT <span class="ot">-&gt;</span> (w_2, w_0, w_1);</a>
<a class="sourceLine" id="cb8-14" data-line-number="14">                <span class="dv">1</span><span class="fu">#</span> <span class="ot">-&gt;</span> (w_0, w_2, w_1)</a>
<a class="sourceLine" id="cb8-15" data-line-number="15">              }</a>
<a class="sourceLine" id="cb8-16" data-line-number="16">          };</a>
<a class="sourceLine" id="cb8-17" data-line-number="17">        <span class="dv">1</span><span class="fu">#</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb8-18" data-line-number="18">          <span class="kw">case</span> <span class="fu">GHC.Prim.&lt;=#</span> _0U _2U <span class="kw">of</span> {</a>
<a class="sourceLine" id="cb8-19" data-line-number="19">            __DEFAULT <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb8-20" data-line-number="20">              <span class="kw">case</span> <span class="fu">GHC.Prim.&lt;=#</span> _2U _1U <span class="kw">of</span> {</a>
<a class="sourceLine" id="cb8-21" data-line-number="21">                __DEFAULT <span class="ot">-&gt;</span> (w_1, w_2, w_0);</a>
<a class="sourceLine" id="cb8-22" data-line-number="22">                <span class="dv">1</span><span class="fu">#</span> <span class="ot">-&gt;</span> (w_2, w_1, w_0)</a>
<a class="sourceLine" id="cb8-23" data-line-number="23">              };</a>
<a class="sourceLine" id="cb8-24" data-line-number="24">            <span class="dv">1</span><span class="fu">#</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb8-25" data-line-number="25">              <span class="kw">case</span> <span class="fu">GHC.Prim.&lt;=#</span> _0U _1U <span class="kw">of</span> {</a>
<a class="sourceLine" id="cb8-26" data-line-number="26">                __DEFAULT <span class="ot">-&gt;</span> (w_1, w_0, w_2);</a>
<a class="sourceLine" id="cb8-27" data-line-number="27">                <span class="dv">1</span><span class="fu">#</span> <span class="ot">-&gt;</span> w_X</a>
<a class="sourceLine" id="cb8-28" data-line-number="28">              }</a>
<a class="sourceLine" id="cb8-29" data-line-number="29">          }</a>
<a class="sourceLine" id="cb8-30" data-line-number="30">      }</a>
<a class="sourceLine" id="cb8-31" data-line-number="31">      }</a>
<a class="sourceLine" id="cb8-32" data-line-number="32">      }</a>
<a class="sourceLine" id="cb8-33" data-line-number="33">      }</a>
<a class="sourceLine" id="cb8-34" data-line-number="34">      }</a></code></pre></div>
<p>Now, for the real test: sorting 5-tuples, using the network above.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">sort5 ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> (a,a,a,a,a) <span class="ot">-&gt;</span> (a,a,a,a,a)</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">sort5 lte (_0,_1,_2,_3,_4)</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">    <span class="fu">=</span> swap2 lte _0 _1 <span class="fu">$</span> \ _0 _1 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4">      swap2 lte _2 _3 <span class="fu">$</span> \ _2 _3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">      swap2 lte _0 _2 <span class="fu">$</span> \ _0 _2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6">      swap2 lte _1 _3 <span class="fu">$</span> \ _1 _3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-7" data-line-number="7">      swap2 lte _1 _2 <span class="fu">$</span> \ _1 _2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-8" data-line-number="8">      swap2 lte _0 _4 <span class="fu">$</span> \ _0 _4 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-9" data-line-number="9">      swap2 lte _1 _4 <span class="fu">$</span> \ _1 _4 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-10" data-line-number="10">      swap2 lte _2 _4 <span class="fu">$</span> \ _2 _4 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-11" data-line-number="11">      swap2 lte _3 _4 <span class="fu">$</span> \ _3 _4 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-12" data-line-number="12">      (_0,_1,_2,_3,_4)</a>
<a class="sourceLine" id="cb9-13" data-line-number="13"><span class="ot">{-# INLINE sort5 #-}</span></a></code></pre></div>
<p>The core output from this is over 1000 lines long: you can see it (with the variable names cleaned up) <a href="https://gist.github.com/oisdk/ec25d76d918135c4c28777e1b84ead5f">here</a>.</p>
<p>In my benchmarks, these functions are indeed quicker than their counterparts in vector, but Iâ€™m not confident in my knowledge of Haskell performance to make much of a strong statement about them.</p>
]]></description>
    <pubDate>Sun, 06 May 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-05-06-sorting-small.html</guid>
    <dc:creator>Donnacha OisÃ­n Kidney</dc:creator>
</item>
<item>
    <title>Type-Level Induction in Haskell</title>
    <link>https://doisinkidney.com/posts/2018-05-05-induction.html</link>
    <description><![CDATA[<div class="info">
    Posted on May  5, 2018
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Dependent%20Types.html">Dependent Types</a>
    
</div>

<p>The code from this post is available as a <a href="https://gist.github.com/oisdk/23c430b807c788dd43dc4d986c5fdfdd">gist</a>.</p>
<p>One of the most basic tools for use in type-level programming is the Peano definition of the natural numbers:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> â„•</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Z</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">    <span class="fu">|</span> <span class="dt">S</span> â„•</a></code></pre></div>
<p>Using the new <code class="sourceCode haskell"><span class="dt">TypeFamilyDependencies</span></code> extension, these numbers can be used to describe the â€œsizeâ€ of some type. Iâ€™m going to use the proportion symbol here:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">type</span> family (t <span class="ot">âˆ·</span> k) âˆ (n <span class="ot">âˆ·</span> â„•) <span class="fu">=</span> (a <span class="ot">âˆ·</span> <span class="dt">Type</span>) <span class="fu">|</span> a <span class="ot">â†’</span> t n k</a></code></pre></div>
<p>Using this type family we can describe induction on the natural numbers:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Finite</span> n <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">    induction <span class="ot">âˆ·</span> t âˆ <span class="dt">Z</span> <span class="ot">â†’</span> (<span class="ot">âˆ€</span> k<span class="fu">.</span> t âˆ k <span class="ot">â†’</span> t âˆ <span class="dt">S</span> k) <span class="ot">â†’</span> t âˆ n</a>
<a class="sourceLine" id="cb3-3" data-line-number="3"></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="kw">instance</span> <span class="dt">Finite</span> <span class="dt">Z</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">    induction z _ <span class="fu">=</span> z</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">    <span class="ot">{-# inline induction #-}</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7"></a>
<a class="sourceLine" id="cb3-8" data-line-number="8"><span class="kw">instance</span> <span class="dt">Finite</span> n <span class="ot">â‡’</span> <span class="dt">Finite</span> (<span class="dt">S</span> n) <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-9" data-line-number="9">    induction z s <span class="fu">=</span> s (induction z s)</a>
<a class="sourceLine" id="cb3-10" data-line-number="10">    <span class="ot">{-# inline induction #-}</span></a></code></pre></div>
<p>The <code class="sourceCode haskell">induction</code> function reads as the standard mathematical definition of induction: given a proof (value) of the zero case, and a proof that any proof is true for its successor, we can give you a proof of the case for any finite number.</p>
<p>An added bonus here is that the size of something can usually be resolved at compile-time, so any inductive function on it should also be resolved at compile time.</p>
<p>We can use it to provide the standard instances for basic length-indexed lists:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:-</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="kw">data</span> <span class="dt">List</span> n a <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">        <span class="dt">Nil</span>  <span class="ot">âˆ·</span> <span class="dt">List</span> <span class="dt">Z</span> a</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">        (<span class="fu">:-</span>) <span class="ot">âˆ·</span> a <span class="ot">â†’</span> <span class="dt">List</span> n a <span class="ot">â†’</span> <span class="dt">List</span> (<span class="dt">S</span> n) a</a></code></pre></div>
<p>Some instances for those lists are easy:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">List</span> n) <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">    fmap _ <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">    fmap f (x <span class="fu">:-</span> xs) <span class="fu">=</span> f x <span class="fu">:-</span> fmap f xs</a></code></pre></div>
<p>However, for <code class="sourceCode haskell"><span class="dt">Applicative</span></code>, we need some way to recurse on the size of the list. This is where induction comes in.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">type</span> <span class="kw">instance</span> <span class="ch">&#39;(List,a) âˆ n = List n a</span></a></code></pre></div>
<p>This lets us write <code class="sourceCode haskell">pure</code> in a pleasingly simple way:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Finite</span> n <span class="ot">â‡’</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">         <span class="dt">Applicative</span> (<span class="dt">List</span> n) <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">    pure x <span class="fu">=</span> induction <span class="dt">Nil</span> (x <span class="fu">:-</span>)</a></code></pre></div>
<p>But can we also write <code class="sourceCode haskell"><span class="fu">&lt;*&gt;</span></code> using induction? Yes! Because weâ€™ve factored out the induction itself, we just need to describe the notion of a â€œsizedâ€ function:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">data</span> a â†¦ b</a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="kw">type</span> <span class="kw">instance</span> ((x <span class="ot">âˆ·</span> a) â†¦ (y <span class="ot">âˆ·</span> b)) âˆ n <span class="fu">=</span> (x âˆ n) <span class="ot">â†’</span> (y âˆ n)</a></code></pre></div>
<p>Then we can write <code class="sourceCode haskell"><span class="fu">&lt;*&gt;</span></code> as so:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Finite</span> n <span class="ot">â‡’</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">         <span class="dt">Applicative</span> (<span class="dt">List</span> n) <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">    pure x <span class="fu">=</span> induction <span class="dt">Nil</span> (x <span class="fu">:-</span>)</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">    (<span class="fu">&lt;*&gt;</span>) <span class="fu">=</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">        induction</a>
<a class="sourceLine" id="cb9-6" data-line-number="6">            (\<span class="dt">Nil</span> <span class="dt">Nil</span> <span class="ot">â†’</span> <span class="dt">Nil</span>)</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">            (\k (f <span class="fu">:-</span> fs) (x <span class="fu">:-</span> xs) <span class="ot">â†’</span> f x <span class="fu">:-</span> k fs xs)</a></code></pre></div>
<p>What about the <code class="sourceCode haskell"><span class="dt">Monad</span></code> instance? For that, we need a little bit of plumbing: the type signature of <code class="sourceCode haskell"><span class="fu">&gt;&gt;=</span></code> is:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">(<span class="fu">&gt;&gt;=</span>) <span class="ot">âˆ·</span> m a <span class="ot">â†’</span> (a <span class="ot">â†’</span> m b) <span class="ot">â†’</span> m b</a></code></pre></div>
<p>One of the parameters (the second <code>a</code>) doesnâ€™t have a size: weâ€™ll need to work around that, with <code class="sourceCode haskell"><span class="dt">Const</span></code>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">type</span> <span class="kw">instance</span> (<span class="dt">Const</span> a <span class="ot">âˆ·</span> â„• <span class="ot">â†’</span> <span class="dt">Type</span>) âˆ n <span class="fu">=</span> <span class="dt">Const</span> a n</a></code></pre></div>
<p>Using this, we can write our <code class="sourceCode haskell"><span class="dt">Monad</span></code> instance:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1">head&#39; <span class="ot">âˆ·</span> <span class="dt">List</span> (<span class="dt">S</span> n) a <span class="ot">â†’</span> a</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">head&#39; (x <span class="fu">:-</span> _) <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb12-3" data-line-number="3"></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">tail&#39; <span class="ot">âˆ·</span> <span class="dt">List</span> (<span class="dt">S</span> n) a <span class="ot">â†’</span> <span class="dt">List</span> n a</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">tail&#39; (_ <span class="fu">:-</span> xs) <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb12-6" data-line-number="6"></a>
<a class="sourceLine" id="cb12-7" data-line-number="7"><span class="kw">instance</span> <span class="dt">Finite</span> n <span class="ot">â‡’</span></a>
<a class="sourceLine" id="cb12-8" data-line-number="8">         <span class="dt">Monad</span> (<span class="dt">List</span> n) <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-9" data-line-number="9">    xs <span class="fu">&gt;&gt;=</span> (f <span class="ot">âˆ·</span> a <span class="ot">â†’</span> <span class="dt">List</span> n b) <span class="fu">=</span></a>
<a class="sourceLine" id="cb12-10" data-line-number="10">        induction</a>
<a class="sourceLine" id="cb12-11" data-line-number="11">            (\<span class="dt">Nil</span> _ <span class="ot">â†’</span> <span class="dt">Nil</span>)</a>
<a class="sourceLine" id="cb12-12" data-line-number="12">            (\k (y <span class="fu">:-</span> ys) fn <span class="ot">â†’</span> head&#39; (fn (<span class="dt">Const</span> y)) <span class="fu">:-</span></a>
<a class="sourceLine" id="cb12-13" data-line-number="13">                               k ys (tail&#39; <span class="fu">.</span> fn <span class="fu">.</span> <span class="dt">Const</span> <span class="fu">.</span> getConst))</a>
<a class="sourceLine" id="cb12-14" data-line-number="14">            xs</a>
<a class="sourceLine" id="cb12-15" data-line-number="15">            (f <span class="fu">.</span> getConst <span class="ot">âˆ·</span> <span class="dt">Const</span> a n <span class="ot">â†’</span> <span class="dt">List</span> n b)</a></code></pre></div>
<h2 id="type-family-dependencies">Type Family Dependencies</h2>
<p>Getting the above to work actually took a surprising amount of work: the crux is that the <code class="sourceCode haskell">âˆ</code> type family needs to be injective, so the â€œsuccessorâ€ proof can typecheck. Unfortunately, this means that every type can only have one notion of â€œsizeâ€. What Iâ€™d prefer is to be able to pass in a function indicating exactly <em>how</em> to get the size out of a type, that could change depending on the situation. So we could recurse on the first argument of a function, for instance, or just its second, or just the result. This would need either type-level lambdas (which would be cool), or <a href="https://ghc.haskell.org/trac/ghc/ticket/10832">generalized type family dependencies</a>.</p>
]]></description>
    <pubDate>Sat, 05 May 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-05-05-induction.html</guid>
    <dc:creator>Donnacha OisÃ­n Kidney</dc:creator>
</item>
<item>
    <title>5 Cool Things You Can Do With Pattern Synonyms</title>
    <link>https://doisinkidney.com/posts/2018-04-12-pattern-synonyms.html</link>
    <description><![CDATA[<div class="info">
    Posted on April 12, 2018
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Pattern%20Synonyms.html">Pattern Synonyms</a>
    
</div>

<p><a href="https://ghc.haskell.org/trac/ghc/wiki/PatternSynonyms">Pattern Synonyms</a> is an excellent extension for Haskell. There are some <a href="https://ocharles.org.uk/blog/posts/2014-12-03-pattern-synonyms.html">very</a> <a href="https://www.schoolofhaskell.com/user/icelandj/Pattern%20synonyms">cool</a> examples of their use out there, and I thought Iâ€™d add to the list.</p>
<h1 id="make-things-look-like-lists">Make Things Look Like Lists</h1>
<p>Lists are <em>the</em> fundamental data structure for functional programmers. Unfortunately, once more specialized structures are required, you often have to switch over to an uncomfortable, annoying API which isnâ€™t as pleasant or fun to use as cons and nil. With pattern synonyms, though, thatâ€™s not so! For instance, hereâ€™s how you would do it with a run-length-encoded list:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> <span class="dt">List</span> a</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">    <span class="fu">|</span> <span class="dt">ConsN</span> <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">Int</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">            a</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">            (<span class="dt">List</span> a)</a>
<a class="sourceLine" id="cb1-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="ot">cons ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a</a>
<a class="sourceLine" id="cb1-8" data-line-number="8">cons x (<span class="dt">ConsN</span> i y ys)</a>
<a class="sourceLine" id="cb1-9" data-line-number="9">  <span class="fu">|</span> x <span class="fu">==</span> y <span class="fu">=</span> <span class="dt">ConsN</span> (i<span class="fu">+</span><span class="dv">1</span>) y ys</a>
<a class="sourceLine" id="cb1-10" data-line-number="10">cons x xs <span class="fu">=</span> <span class="dt">ConsN</span> <span class="dv">1</span> x xs</a>
<a class="sourceLine" id="cb1-11" data-line-number="11"></a>
<a class="sourceLine" id="cb1-12" data-line-number="12"><span class="ot">uncons ::</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, <span class="dt">List</span> a)</a>
<a class="sourceLine" id="cb1-13" data-line-number="13">uncons <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb1-14" data-line-number="14">uncons (<span class="dt">ConsN</span> <span class="dv">1</span> x xs) <span class="fu">=</span> <span class="dt">Just</span> (x, xs)</a>
<a class="sourceLine" id="cb1-15" data-line-number="15">uncons (<span class="dt">ConsN</span> n x xs) <span class="fu">=</span> <span class="dt">Just</span> (x, <span class="dt">ConsN</span> (n<span class="fu">-</span><span class="dv">1</span>) x xs)</a>
<a class="sourceLine" id="cb1-16" data-line-number="16"></a>
<a class="sourceLine" id="cb1-17" data-line-number="17"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:-</span></a>
<a class="sourceLine" id="cb1-18" data-line-number="18">pattern<span class="ot"> (:-) ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a</a>
<a class="sourceLine" id="cb1-19" data-line-number="19">pattern x <span class="fu">:-</span> xs <span class="ot">&lt;-</span> (uncons <span class="ot">-&gt;</span> <span class="dt">Just</span> (x, xs))</a>
<a class="sourceLine" id="cb1-20" data-line-number="20">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-21" data-line-number="21">    x <span class="fu">:-</span> xs <span class="fu">=</span> cons x xs</a>
<a class="sourceLine" id="cb1-22" data-line-number="22"><span class="ot">{-# COMPLETE Nil, (:-) #-}</span></a>
<a class="sourceLine" id="cb1-23" data-line-number="23"></a>
<a class="sourceLine" id="cb1-24" data-line-number="24">zip<span class="ot"> ::</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> b <span class="ot">-&gt;</span> <span class="dt">List</span> (a,b)</a>
<a class="sourceLine" id="cb1-25" data-line-number="25">zip (x <span class="fu">:-</span> xs) (y <span class="fu">:-</span> ys) <span class="fu">=</span> (x,y) <span class="fu">:-</span> zip xs ys</a>
<a class="sourceLine" id="cb1-26" data-line-number="26">zip _ _ <span class="fu">=</span> <span class="dt">Nil</span></a></code></pre></div>
<p>A little more useful would be to do the same with a heap:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Leaf</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">    <span class="fu">|</span> <span class="dt">Node</span> a (<span class="dt">Tree</span> a) (<span class="dt">Tree</span> a)</a>
<a class="sourceLine" id="cb2-4" data-line-number="4"></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="ot">smerge ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">smerge <span class="dt">Leaf</span> ys <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">smerge xs <span class="dt">Leaf</span> <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">smerge h1<span class="fu">@</span>(<span class="dt">Node</span> x lx rx) h2<span class="fu">@</span>(<span class="dt">Node</span> y ly ry)</a>
<a class="sourceLine" id="cb2-9" data-line-number="9">  <span class="fu">|</span> x <span class="fu">&lt;=</span> y    <span class="fu">=</span> <span class="dt">Node</span> x (smerge h2 rx) lx</a>
<a class="sourceLine" id="cb2-10" data-line-number="10">  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Node</span> y (smerge h1 ry) ly</a>
<a class="sourceLine" id="cb2-11" data-line-number="11"></a>
<a class="sourceLine" id="cb2-12" data-line-number="12"><span class="ot">cons ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb2-13" data-line-number="13">cons x <span class="fu">=</span> smerge (<span class="dt">Node</span> x <span class="dt">Leaf</span> <span class="dt">Leaf</span>)</a>
<a class="sourceLine" id="cb2-14" data-line-number="14"></a>
<a class="sourceLine" id="cb2-15" data-line-number="15"><span class="ot">uncons ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, <span class="dt">Tree</span> a)</a>
<a class="sourceLine" id="cb2-16" data-line-number="16">uncons <span class="dt">Leaf</span> <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb2-17" data-line-number="17">uncons (<span class="dt">Node</span> x l r) <span class="fu">=</span> <span class="dt">Just</span> (x, smerge l r)</a>
<a class="sourceLine" id="cb2-18" data-line-number="18"></a>
<a class="sourceLine" id="cb2-19" data-line-number="19"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:-</span></a>
<a class="sourceLine" id="cb2-20" data-line-number="20">pattern<span class="ot"> (:-) ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb2-21" data-line-number="21">pattern x <span class="fu">:-</span> xs <span class="ot">&lt;-</span> (uncons <span class="ot">-&gt;</span> <span class="dt">Just</span> (x, xs))</a>
<a class="sourceLine" id="cb2-22" data-line-number="22">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-23" data-line-number="23">    x <span class="fu">:-</span> xs <span class="fu">=</span> cons x xs</a>
<a class="sourceLine" id="cb2-24" data-line-number="24"><span class="ot">{-# COMPLETE Leaf, (:-) #-}</span></a>
<a class="sourceLine" id="cb2-25" data-line-number="25"></a>
<a class="sourceLine" id="cb2-26" data-line-number="26">sort<span class="ot"> ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb2-27" data-line-number="27">sort <span class="fu">=</span> go <span class="fu">.</span> foldr (<span class="fu">:-</span>) <span class="dt">Leaf</span></a>
<a class="sourceLine" id="cb2-28" data-line-number="28">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-29" data-line-number="29">    go <span class="dt">Leaf</span> <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb2-30" data-line-number="30">    go (x <span class="fu">:-</span> xs) <span class="fu">=</span> x <span class="fu">:</span> go xs</a></code></pre></div>
<p>In fact, this pattern can be generalized, so <em>any</em> container-like-thing with a cons-like-thing can be modified as you would with lists. You can see the generalization in <a href="https://hackage.haskell.org/package/lens-4.16.1/docs/Control-Lens-Cons.html#v::-60-">lens</a>.</p>
<h1 id="retroactively-make-lyah-examples-work">Retroactively Make <a href="http://learnyouahaskell.com">LYAH</a> Examples Work</h1>
<p>One of the most confusing things I remember about learning Haskell early-on was that the vast majority of the Monads examples didnâ€™t work, because they were written pre-transformers. In other words, the state monad was defined like so:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">State</span> s a <span class="fu">=</span> <span class="dt">State</span> {<span class="ot"> runState ::</span> s <span class="ot">-&gt;</span> (a, s) }</a></code></pre></div>
<p>But in transformers nowadays (which is where you get <code class="sourceCode haskell"><span class="dt">State</span></code> from if you import it in the normal way), the definition is:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">StateT</span> s m a <span class="fu">=</span> <span class="dt">StateT</span> {<span class="ot"> runStateT ::</span> s <span class="ot">-&gt;</span> m (a, s) }</a>
<a class="sourceLine" id="cb4-2" data-line-number="2"></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="kw">type</span> <span class="dt">State</span> s <span class="fu">=</span> <span class="dt">StateT</span> s <span class="dt">Identity</span></a></code></pre></div>
<p>This results in some <em>very</em> confusing error messages when you try run example code.</p>
<p>However, we can pretend that the change never happened, with a simple pattern synonym:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">StateT</span> s m a <span class="fu">=</span> <span class="dt">StateT</span> {<span class="ot"> runStateT ::</span> s <span class="ot">-&gt;</span> m (a, s) }</a>
<a class="sourceLine" id="cb5-2" data-line-number="2"></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="kw">type</span> <span class="dt">State</span> s <span class="fu">=</span> <span class="dt">StateT</span> s <span class="dt">Identity</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4"></a>
<a class="sourceLine" id="cb5-5" data-line-number="5"><span class="ot">runState ::</span> <span class="dt">State</span> s a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> (a, s)</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">runState xs <span class="fu">=</span> runIdentity <span class="fu">.</span> runStateT xs</a>
<a class="sourceLine" id="cb5-7" data-line-number="7"></a>
<a class="sourceLine" id="cb5-8" data-line-number="8">pattern <span class="dt">State</span><span class="ot"> ::</span> (s <span class="ot">-&gt;</span> (a, s)) <span class="ot">-&gt;</span> <span class="dt">State</span> s a</a>
<a class="sourceLine" id="cb5-9" data-line-number="9">pattern <span class="dt">State</span> x <span class="ot">&lt;-</span> (runState <span class="ot">-&gt;</span> x)</a>
<a class="sourceLine" id="cb5-10" data-line-number="10">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-11" data-line-number="11">    <span class="dt">State</span> x <span class="fu">=</span> <span class="dt">StateT</span> (<span class="dt">Identity</span> <span class="fu">.</span> x)</a></code></pre></div>
<h1 id="getting-type-level-numbers-with-an-efficient-runtime-representation">Getting Type-Level Numbers With an Efficient Runtime Representation</h1>
<p>If you want to write type-level proofs on numbers, youâ€™ll probably end up using Peano numerals and singletons:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Nat</span> <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">|</span> <span class="dt">S</span> <span class="dt">Nat</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Natty</span> n <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">  <span class="dt">Zy</span><span class="ot"> ::</span> <span class="dt">Natty</span> <span class="dt">Z</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">  <span class="dt">Sy</span><span class="ot"> ::</span> <span class="dt">Natty</span> n <span class="ot">-&gt;</span> <span class="dt">Natty</span> (<span class="dt">S</span> n)</a>
<a class="sourceLine" id="cb6-6" data-line-number="6"></a>
<a class="sourceLine" id="cb6-7" data-line-number="7"><span class="kw">type</span> family (<span class="fu">+</span>) (<span class="ot">n ::</span> <span class="dt">Nat</span>) (<span class="ot">m ::</span> <span class="dt">Nat</span>)<span class="ot"> ::</span> <span class="dt">Nat</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">  <span class="dt">Z</span> <span class="fu">+</span> m <span class="fu">=</span> m</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">  <span class="dt">S</span> n <span class="fu">+</span> m <span class="fu">=</span> <span class="dt">S</span> (n <span class="fu">+</span> m)</a>
<a class="sourceLine" id="cb6-10" data-line-number="10"></a>
<a class="sourceLine" id="cb6-11" data-line-number="11"><span class="ot">plusZeroIsZero ::</span> <span class="dt">Natty</span> n <span class="ot">-&gt;</span> n <span class="fu">+</span> <span class="dt">Z</span> <span class="fu">:~:</span> n</a>
<a class="sourceLine" id="cb6-12" data-line-number="12">plusZeroIsZero <span class="dt">Zy</span> <span class="fu">=</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb6-13" data-line-number="13">plusZeroIsZero (<span class="dt">Sy</span> n) <span class="fu">=</span> <span class="kw">case</span> plusZeroIsZero n <span class="kw">of</span></a>
<a class="sourceLine" id="cb6-14" data-line-number="14">  <span class="dt">Refl</span> <span class="ot">-&gt;</span> <span class="dt">Refl</span></a></code></pre></div>
<p>Pretty cool, right? We can even erase the proof (if we really trust it) using rewrite rules:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">{-# RULES </span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="ot">&quot;plusZeroIsZero&quot; forall n. plusZeroIsZero n = unsafeCoerce Refl</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="ot">#-}</span></a></code></pre></div>
<p>This isnâ€™t <em>ideal</em>, but itâ€™s getting there.</p>
<p>However, if we ever want to use these things at runtime (perhaps as a type-level indication of some data structureâ€™s size), weâ€™re going to rely on the value-level Peano addition, which is bad news.</p>
<p>Not so with pattern synonyms!</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">data</span> family <span class="dt">The</span><span class="ot"> k ::</span> k <span class="ot">-&gt;</span> <span class="dt">Type</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"></a>
<a class="sourceLine" id="cb8-3" data-line-number="3"><span class="kw">class</span> <span class="dt">Sing</span> (<span class="ot">a ::</span> k) <span class="kw">where</span><span class="ot"> sing ::</span> <span class="dt">The</span> k (<span class="ot">a ::</span> k)</a>
<a class="sourceLine" id="cb8-4" data-line-number="4"></a>
<a class="sourceLine" id="cb8-5" data-line-number="5"><span class="kw">data</span> <span class="dt">Nat</span> <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">|</span> <span class="dt">S</span> <span class="dt">Nat</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6"></a>
<a class="sourceLine" id="cb8-7" data-line-number="7"><span class="kw">newtype</span> <span class="kw">instance</span> <span class="dt">The</span> <span class="dt">Nat</span> n <span class="fu">=</span> <span class="dt">NatSing</span> <span class="dt">Natural</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8"></a>
<a class="sourceLine" id="cb8-9" data-line-number="9"><span class="kw">instance</span> <span class="dt">Sing</span> <span class="dt">Z</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-10" data-line-number="10">    sing <span class="fu">=</span> <span class="dt">NatSing</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb8-11" data-line-number="11"></a>
<a class="sourceLine" id="cb8-12" data-line-number="12"><span class="kw">instance</span> <span class="dt">Sing</span> n <span class="ot">=&gt;</span> <span class="dt">Sing</span> (<span class="dt">S</span> n) <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-13" data-line-number="13">    sing <span class="fu">=</span></a>
<a class="sourceLine" id="cb8-14" data-line-number="14">        (<span class="ot">coerce ::</span> (<span class="dt">Natural</span> <span class="ot">-&gt;</span> <span class="dt">Natural</span>) <span class="ot">-&gt;</span> (<span class="dt">The</span> <span class="dt">Nat</span> n <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> (<span class="dt">S</span> n)))</a>
<a class="sourceLine" id="cb8-15" data-line-number="15">            succ sing</a>
<a class="sourceLine" id="cb8-16" data-line-number="16"></a>
<a class="sourceLine" id="cb8-17" data-line-number="17"><span class="kw">data</span> <span class="dt">Natty</span> n <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-18" data-line-number="18">        <span class="dt">ZZy</span><span class="ot"> ::</span> <span class="dt">Natty</span> <span class="dt">Z</span></a>
<a class="sourceLine" id="cb8-19" data-line-number="19">        <span class="dt">SSy</span><span class="ot"> ::</span> <span class="dt">The</span> <span class="dt">Nat</span> n <span class="ot">-&gt;</span> <span class="dt">Natty</span> (<span class="dt">S</span> n)</a>
<a class="sourceLine" id="cb8-20" data-line-number="20"></a>
<a class="sourceLine" id="cb8-21" data-line-number="21"><span class="ot">getNatty ::</span> <span class="dt">The</span> <span class="dt">Nat</span> n <span class="ot">-&gt;</span> <span class="dt">Natty</span> n</a>
<a class="sourceLine" id="cb8-22" data-line-number="22">getNatty (<span class="dt">NatSing</span><span class="ot"> n ::</span> <span class="dt">The</span> <span class="dt">Nat</span> n) <span class="fu">=</span> <span class="kw">case</span> n <span class="kw">of</span></a>
<a class="sourceLine" id="cb8-23" data-line-number="23">  <span class="dv">0</span> <span class="ot">-&gt;</span> gcastWith (unsafeCoerce <span class="dt">Refl</span><span class="ot"> ::</span> n <span class="fu">:~:</span> <span class="dt">Z</span>) <span class="dt">ZZy</span></a>
<a class="sourceLine" id="cb8-24" data-line-number="24">  _ <span class="ot">-&gt;</span> gcastWith (unsafeCoerce <span class="dt">Refl</span><span class="ot"> ::</span> n <span class="fu">:~:</span> <span class="dt">S</span> m) (<span class="dt">SSy</span> (<span class="dt">NatSing</span> (pred n)))</a>
<a class="sourceLine" id="cb8-25" data-line-number="25"></a>
<a class="sourceLine" id="cb8-26" data-line-number="26">pattern <span class="dt">Zy</span><span class="ot"> ::</span> () <span class="ot">=&gt;</span> (n <span class="fu">~</span> <span class="dt">Z</span>) <span class="ot">=&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> n</a>
<a class="sourceLine" id="cb8-27" data-line-number="27">pattern <span class="dt">Zy</span> <span class="ot">&lt;-</span> (getNatty <span class="ot">-&gt;</span> <span class="dt">ZZy</span>) <span class="kw">where</span> <span class="dt">Zy</span> <span class="fu">=</span> <span class="dt">NatSing</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb8-28" data-line-number="28"></a>
<a class="sourceLine" id="cb8-29" data-line-number="29">pattern <span class="dt">Sy</span><span class="ot"> ::</span> () <span class="ot">=&gt;</span> (n <span class="fu">~</span> <span class="dt">S</span> m) <span class="ot">=&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> m <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> n</a>
<a class="sourceLine" id="cb8-30" data-line-number="30">pattern <span class="dt">Sy</span> x <span class="ot">&lt;-</span> (getNatty <span class="ot">-&gt;</span> <span class="dt">SSy</span> x) <span class="kw">where</span> <span class="dt">Sy</span> (<span class="dt">NatSing</span> x) <span class="fu">=</span> <span class="dt">NatSing</span> (succ x)</a>
<a class="sourceLine" id="cb8-31" data-line-number="31"><span class="ot">{-# COMPLETE Zy, Sy #-}</span></a>
<a class="sourceLine" id="cb8-32" data-line-number="32"></a>
<a class="sourceLine" id="cb8-33" data-line-number="33"><span class="kw">type</span> family (<span class="fu">+</span>) (<span class="ot">n ::</span> <span class="dt">Nat</span>) (<span class="ot">m ::</span> <span class="dt">Nat</span>)<span class="ot"> ::</span> <span class="dt">Nat</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-34" data-line-number="34">        <span class="dt">Z</span> <span class="fu">+</span> m <span class="fu">=</span> m</a>
<a class="sourceLine" id="cb8-35" data-line-number="35">        <span class="dt">S</span> n <span class="fu">+</span> m <span class="fu">=</span> <span class="dt">S</span> (n <span class="fu">+</span> m)</a>
<a class="sourceLine" id="cb8-36" data-line-number="36"></a>
<a class="sourceLine" id="cb8-37" data-line-number="37"><span class="co">-- | Efficient addition, with type-level proof.</span></a>
<a class="sourceLine" id="cb8-38" data-line-number="38"><span class="ot">add ::</span> <span class="dt">The</span> <span class="dt">Nat</span> n <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> m <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> (n <span class="fu">+</span> m)</a>
<a class="sourceLine" id="cb8-39" data-line-number="39">add <span class="fu">=</span> (<span class="ot">coerce ::</span> (<span class="dt">Natural</span> <span class="ot">-&gt;</span> <span class="dt">Natural</span> <span class="ot">-&gt;</span> <span class="dt">Natural</span>)</a>
<a class="sourceLine" id="cb8-40" data-line-number="40">              <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> n <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> m <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> (n <span class="fu">+</span> m)) (<span class="fu">+</span>)</a>
<a class="sourceLine" id="cb8-41" data-line-number="41"></a>
<a class="sourceLine" id="cb8-42" data-line-number="42"><span class="co">-- | Proof on efficient representation.</span></a>
<a class="sourceLine" id="cb8-43" data-line-number="43"><span class="ot">addZeroRight ::</span> <span class="dt">The</span> <span class="dt">Nat</span> n <span class="ot">-&gt;</span> n <span class="fu">+</span> <span class="dt">Z</span> <span class="fu">:~:</span> n</a>
<a class="sourceLine" id="cb8-44" data-line-number="44">addZeroRight <span class="dt">Zy</span> <span class="fu">=</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb8-45" data-line-number="45">addZeroRight (<span class="dt">Sy</span> n) <span class="fu">=</span> gcastWith (addZeroRight n) <span class="dt">Refl</span></a></code></pre></div>
<p>(unfortunately, incomplete pattern warnings donâ€™t work here)</p>
<h1 id="hide-your-implementations">Hide Your Implementations</h1>
<p>So youâ€™ve got a tree type:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Tip</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">    <span class="fu">|</span> <span class="dt">Bin</span> a (<span class="dt">Tree</span> a) (<span class="dt">Tree</span> a)</a></code></pre></div>
<p>And youâ€™ve spent some time writing a (reasonably difficult) function on the tree:</p>
<details>
<p><summary> Complicated function on the tree </summary></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">showTree ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">showTree <span class="dt">Tip</span> <span class="fu">=</span> <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3">showTree (<span class="dt">Bin</span> x&#39; ls&#39; rs&#39;) <span class="fu">=</span> go <span class="dt">True</span> id xlen&#39; ls&#39;</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">                          <span class="fu">$</span> showString xshw&#39;</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">                          <span class="fu">$</span> endc ls&#39; rs&#39;</a>
<a class="sourceLine" id="cb10-6" data-line-number="6">                          <span class="fu">$</span> showChar <span class="ch">&#39;\n&#39;</span></a>
<a class="sourceLine" id="cb10-7" data-line-number="7">                          <span class="fu">$</span> go <span class="dt">False</span> id xlen&#39; rs&#39; <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb10-8" data-line-number="8">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-9" data-line-number="9">    xshw&#39; <span class="fu">=</span> show x&#39;</a>
<a class="sourceLine" id="cb10-10" data-line-number="10">    xlen&#39; <span class="fu">=</span> length xshw&#39;</a>
<a class="sourceLine" id="cb10-11" data-line-number="11"></a>
<a class="sourceLine" id="cb10-12" data-line-number="12">    go _ _ _ <span class="dt">Tip</span> <span class="fu">=</span> id</a>
<a class="sourceLine" id="cb10-13" data-line-number="13">    go up k i (<span class="dt">Bin</span> x ls rs) <span class="fu">=</span> branch <span class="dt">True</span> ls</a>
<a class="sourceLine" id="cb10-14" data-line-number="14">                            <span class="fu">.</span> k</a>
<a class="sourceLine" id="cb10-15" data-line-number="15">                            <span class="fu">.</span> pad i</a>
<a class="sourceLine" id="cb10-16" data-line-number="16">                            <span class="fu">.</span> showChar (bool <span class="ch">&#39;â””&#39;</span> <span class="ch">&#39;â”Œ&#39;</span> up)</a>
<a class="sourceLine" id="cb10-17" data-line-number="17">                            <span class="fu">.</span> showString xshw</a>
<a class="sourceLine" id="cb10-18" data-line-number="18">                            <span class="fu">.</span> endc ls rs</a>
<a class="sourceLine" id="cb10-19" data-line-number="19">                            <span class="fu">.</span> showChar <span class="ch">&#39;\n&#39;</span></a>
<a class="sourceLine" id="cb10-20" data-line-number="20">                            <span class="fu">.</span> branch <span class="dt">False</span> rs</a>
<a class="sourceLine" id="cb10-21" data-line-number="21">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-22" data-line-number="22">        xshw <span class="fu">=</span> show x</a>
<a class="sourceLine" id="cb10-23" data-line-number="23">        xlen <span class="fu">=</span> length xshw</a>
<a class="sourceLine" id="cb10-24" data-line-number="24">        branch d</a>
<a class="sourceLine" id="cb10-25" data-line-number="25">          <span class="fu">|</span> d <span class="fu">==</span> up <span class="fu">=</span> go d (k <span class="fu">.</span> pad i) (xlen <span class="fu">+</span> <span class="dv">1</span>) </a>
<a class="sourceLine" id="cb10-26" data-line-number="26">          <span class="fu">|</span> otherwise <span class="fu">=</span> go d (k <span class="fu">.</span> pad i <span class="fu">.</span> showChar <span class="ch">&#39;â”‚&#39;</span>) xlen </a>
<a class="sourceLine" id="cb10-27" data-line-number="27"></a>
<a class="sourceLine" id="cb10-28" data-line-number="28">    endc <span class="dt">Tip</span>    <span class="dt">Tip</span>    <span class="fu">=</span> id</a>
<a class="sourceLine" id="cb10-29" data-line-number="29">    endc <span class="dt">Bin</span> {} <span class="dt">Tip</span>    <span class="fu">=</span> showChar <span class="ch">&#39;â”˜&#39;</span></a>
<a class="sourceLine" id="cb10-30" data-line-number="30">    endc <span class="dt">Tip</span>    <span class="dt">Bin</span> {} <span class="fu">=</span> showChar <span class="ch">&#39;â”&#39;</span></a>
<a class="sourceLine" id="cb10-31" data-line-number="31">    endc <span class="dt">Bin</span> {} <span class="dt">Bin</span> {} <span class="fu">=</span> showChar <span class="ch">&#39;â”¤&#39;</span></a>
<a class="sourceLine" id="cb10-32" data-line-number="32"></a>
<a class="sourceLine" id="cb10-33" data-line-number="33">    pad <span class="fu">=</span> (<span class="fu">++</span>) <span class="fu">.</span> flip replicate <span class="ch">&#39; &#39;</span></a></code></pre></div>
</details>
<p>But, for some reason or another, you need to add a field to your <code class="sourceCode haskell"><span class="dt">Bin</span></code> constructor, to store the size of the subtree (for instance). Does this function have to change? No! Simply change the tree definition as so:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Tip</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">    <span class="fu">|</span> <span class="dt">Bin&#39;</span> <span class="dt">Int</span> a (<span class="dt">Tree</span> a) (<span class="dt">Tree</span> a)</a>
<a class="sourceLine" id="cb11-4" data-line-number="4"></a>
<a class="sourceLine" id="cb11-5" data-line-number="5">pattern <span class="dt">Bin</span> x ls rs <span class="ot">&lt;-</span> <span class="dt">Bin&#39;</span> n x ls rs</a>
<a class="sourceLine" id="cb11-6" data-line-number="6"><span class="ot">{-# COMPLETE Tip, Bin #-}</span></a></code></pre></div>
<p>And all the old code works!</p>
<p>This gets to the core of pattern synonyms: itâ€™s another tool which we can use to separate implementation from API.</p>
<h1 id="better-smart-constructors">Better Smart Constructors</h1>
<p>Say youâ€™ve got a data type that has certain constraints on what values it can hold. Youâ€™re not writing a paper for ICFP, so expressing those constraints as a beautiful type isnâ€™t required: you just want to only export the constructor and accessors, and write some tests to make sure that those functions always obey the constraints.</p>
<p>But once you do this youâ€™ve lost something: pattern-matching. Letâ€™s get it back with pattern synonyms!</p>
<p>As our simple example, our constraint is going to be â€œA list where the values are always orderedâ€:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">List</span> a <span class="fu">=</span> <span class="dt">List</span> {<span class="ot"> getList ::</span> [a] }</a>
<a class="sourceLine" id="cb12-2" data-line-number="2"></a>
<a class="sourceLine" id="cb12-3" data-line-number="3"><span class="ot">cons ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a</a>
<a class="sourceLine" id="cb12-4" data-line-number="4">cons x (<span class="dt">List</span> xs) <span class="fu">=</span> <span class="dt">List</span> (insert x xs)</a>
<a class="sourceLine" id="cb12-5" data-line-number="5"></a>
<a class="sourceLine" id="cb12-6" data-line-number="6"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:-</span></a>
<a class="sourceLine" id="cb12-7" data-line-number="7">pattern<span class="ot"> (:-) ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a</a>
<a class="sourceLine" id="cb12-8" data-line-number="8">pattern x <span class="fu">:-</span> xs <span class="ot">&lt;-</span> (<span class="dt">List</span> (x<span class="fu">:</span>xs))</a>
<a class="sourceLine" id="cb12-9" data-line-number="9">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-10" data-line-number="10">    x <span class="fu">:-</span> xs <span class="fu">=</span> cons x xs</a>
<a class="sourceLine" id="cb12-11" data-line-number="11"></a>
<a class="sourceLine" id="cb12-12" data-line-number="12">pattern <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">List</span> []</a>
<a class="sourceLine" id="cb12-13" data-line-number="13"><span class="ot">{-# COMPLETE Nil, (:-) #-}</span></a></code></pre></div>
]]></description>
    <pubDate>Thu, 12 Apr 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-04-12-pattern-synonyms.html</guid>
    <dc:creator>Donnacha OisÃ­n Kidney</dc:creator>
</item>
<item>
    <title>Countdown</title>
    <link>https://doisinkidney.com/posts/2018-03-20-countdown.html</link>
    <description><![CDATA[<div class="info">
    Posted on March 20, 2018
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Algorithms.html">Algorithms</a>
    
</div>

<p>Thereâ€™s a popular UK TV show called <a href="https://en.wikipedia.org/wiki/Countdown_(game_show)">Countdown</a> with a round where contestants have to get as close to some target number as possible by constructing an arithmetic expression from six random numbers.</p>
<p>You donâ€™t have to use all of the numbers, and youâ€™re allowed use four operations: addition, subtraction, multiplication, and division. Additionally, each stage of the calculation must result in a positive integer.</p>
<p>Hereâ€™s an example. Try get to the target 586:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mo>,</mo><mn>25</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>5</mn><mo>,</mo><mn>3</mn><mo>,</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">100,25,1,5,3,10</annotation></semantics></math></p>
<p>On the show, contestants get 30 seconds to think of an answer.</p>
<details>
<summary> Solution </summary> <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>25</mn><mo>*</mo><mn>3</mn><mo>+</mo><mn>10</mn><mo>+</mo><mn>100</mn><mo>*</mo><mn>5</mn><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">25 * 3 + 10 + 100 * 5 + 1</annotation></semantics></math>
</details>
<p>Solving it in Haskell was first explored in depth in <span class="citation" data-cites="hutton_countdown_2002">Hutton (<a href="#ref-hutton_countdown_2002">2002</a>)</span>. There, a basic â€œgenerate-and-testâ€ implementation was provided and proven correct.</p>
<p>As an optimization problem, there are several factors which will influence the choice of algorithm:</p>
<ol type="1">
<li>Thereâ€™s no obvious heuristic for constructing subexpressions in order to get to a final result. In other words, if we have <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>25</mn><mo>*</mo><mn>3</mn><mo>+</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">25 * 3 + 10</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>25</mn><mo>*</mo><mn>3</mn><mo>*</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">25 * 3 * 10</annotation></semantics></math>, thereâ€™s no easy way to tell which is â€œcloserâ€ to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>586</mn><annotation encoding="application/x-tex">586</annotation></semantics></math>. The latter is closer numerically, but the former is what we ended up using in the solution.</li>
<li>Because certain subexpressions arenâ€™t allowed, weâ€™ll be able to prune the search space as we go.</li>
<li>Ideally, weâ€™d only want to calculate each possible subexpression once, making it a pretty standard dynamic programming problem.</li>
</ol>
<p>Iâ€™ll be focusing on the third point in this post, but we can add the second point in at the end. First, however, letâ€™s write a naive implementation.</p>
<h2 id="generating-all-expressions">Generating all Expressions</h2>
<p>I canâ€™t think of a simpler way to solve the problem than generate-and-test, so weâ€™ll work from there. Testing is easy (<code class="sourceCode haskell">(target <span class="fu">==</span>) <span class="fu">.</span> eval</code>), so weâ€™ll focus on generation. The core function weâ€™ll use for this is usually called â€œunmergesâ€:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1">unmerges [x,y] <span class="fu">=</span> [([x],[y])]</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">unmerges (x<span class="fu">:</span>xs) <span class="fu">=</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">    ([x],xs) <span class="fu">:</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">    concat</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">        [ [(x<span class="fu">:</span>ys,zs),(ys,x<span class="fu">:</span>zs)]</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">        <span class="fu">|</span> (ys,zs) <span class="ot">&lt;-</span> unmerges xs ]</a>
<a class="sourceLine" id="cb1-7" data-line-number="7">unmerges _ <span class="fu">=</span> []</a></code></pre></div>
<p>It generates all possible 2-partitions of a list, ignoring order:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> unmerges <span class="st">&quot;abc&quot;</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">[(<span class="st">&quot;a&quot;</span>,<span class="st">&quot;bc&quot;</span>),(<span class="st">&quot;ab&quot;</span>,<span class="st">&quot;c&quot;</span>),(<span class="st">&quot;b&quot;</span>,<span class="st">&quot;ac&quot;</span>)]</a></code></pre></div>
<p>I havenâ€™t looked much into how to optimize this function or make it nicer, as weâ€™ll be swapping it out later.</p>
<p>Next, we need to make the recursive calls:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">allExprs ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a]) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">allExprs _ [x] <span class="fu">=</span> [x]</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">allExprs c xs <span class="fu">=</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">    [ e</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">    <span class="fu">|</span> (ys,zs) <span class="ot">&lt;-</span> unmerges xs</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">    , y <span class="ot">&lt;-</span> allExprs c ys</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">    , z <span class="ot">&lt;-</span> allExprs c zs</a>
<a class="sourceLine" id="cb3-8" data-line-number="8">    , e <span class="ot">&lt;-</span> c y z ]</a></code></pre></div>
<p>Finally, using the <a href="https://hackage.haskell.org/package/simple-reflect">simple-reflect</a> library, we can take a look at the output:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> allExprs (\x y <span class="ot">-&gt;</span> [x<span class="fu">+</span>y,x<span class="fu">*</span>y]) [<span class="dv">1</span>,<span class="dv">2</span>]<span class="ot"> ::</span> [<span class="dt">Expr</span>]</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">[<span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span>,<span class="dv">1</span> <span class="fu">*</span> <span class="dv">2</span>]</a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="fu">&gt;&gt;&gt;</span> allExprs (\x y <span class="ot">-&gt;</span> [x<span class="fu">+</span>y]) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]<span class="ot"> ::</span> [<span class="dt">Expr</span>]</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">[<span class="dv">1</span> <span class="fu">+</span> (<span class="dv">2</span> <span class="fu">+</span> <span class="dv">3</span>),<span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span> <span class="fu">+</span> <span class="dv">3</span>,<span class="dv">2</span> <span class="fu">+</span> (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">3</span>)]</a></code></pre></div>
<p>Even at this early stage, we can actually already write a rudimentary solution:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">countdown ::</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> [<span class="dt">Expr</span>]</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">countdown xs targ <span class="fu">=</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">    filter</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">        ((<span class="fu">==</span>) targ <span class="fu">.</span> toInteger)</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">        (allExprs</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">             (\x y <span class="ot">-&gt;</span> [x,y,x<span class="fu">+</span>y,x<span class="fu">*</span>y])</a>
<a class="sourceLine" id="cb5-7" data-line-number="7">             (map fromInteger xs))</a>
<a class="sourceLine" id="cb5-8" data-line-number="8"></a>
<a class="sourceLine" id="cb5-9" data-line-number="9"><span class="fu">&gt;&gt;&gt;</span> mapM_ print (countdown [<span class="dv">100</span>,<span class="dv">25</span>,<span class="dv">1</span>,<span class="dv">5</span>,<span class="dv">3</span>,<span class="dv">10</span>] <span class="dv">586</span>)</a>
<a class="sourceLine" id="cb5-10" data-line-number="10"><span class="dv">1</span> <span class="fu">+</span> (<span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> (<span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> <span class="dv">10</span>))</a>
<a class="sourceLine" id="cb5-11" data-line-number="11"><span class="dv">1</span> <span class="fu">+</span> (<span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> <span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb5-12" data-line-number="12"><span class="dv">1</span> <span class="fu">+</span> (<span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> (<span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> <span class="dv">10</span>))</a>
<a class="sourceLine" id="cb5-13" data-line-number="13"><span class="dv">1</span> <span class="fu">+</span> <span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> (<span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb5-14" data-line-number="14"><span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> (<span class="dv">1</span> <span class="fu">+</span> (<span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> <span class="dv">10</span>))</a>
<a class="sourceLine" id="cb5-15" data-line-number="15"><span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb5-16" data-line-number="16"><span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> (<span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">10</span>))</a>
<a class="sourceLine" id="cb5-17" data-line-number="17"><span class="dv">1</span> <span class="fu">+</span> (<span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> <span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span>) <span class="fu">+</span> <span class="dv">10</span></a>
<a class="sourceLine" id="cb5-18" data-line-number="18"><span class="dv">1</span> <span class="fu">+</span> <span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> <span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> <span class="dv">10</span></a>
<a class="sourceLine" id="cb5-19" data-line-number="19"><span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span>) <span class="fu">+</span> <span class="dv">10</span></a>
<a class="sourceLine" id="cb5-20" data-line-number="20"><span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> <span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb5-21" data-line-number="21"><span class="dv">1</span> <span class="fu">+</span> <span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> (<span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb5-22" data-line-number="22"><span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> (<span class="dv">1</span> <span class="fu">+</span> (<span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> <span class="dv">10</span>))</a>
<a class="sourceLine" id="cb5-23" data-line-number="23"><span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb5-24" data-line-number="24"><span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> (<span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">10</span>))</a></code></pre></div>
<p>As you can see from the output, thereâ€™s a lot of repetition. Weâ€™ll need to do some memoization to speed it up.</p>
<h2 id="pure-memoization">Pure Memoization</h2>
<p>The normal way most programmers think about â€œmemoizationâ€ is something like this:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb6-1" data-line-number="1">memo_dict <span class="op">=</span> {<span class="dv">0</span>:<span class="dv">0</span>,<span class="dv">1</span>:<span class="dv">1</span>}</a>
<a class="sourceLine" id="cb6-2" data-line-number="2"></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="kw">def</span> fib(n):</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">    <span class="cf">if</span> n <span class="kw">in</span> memo_dict:</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">        <span class="cf">return</span> memo_dict[n]</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">    <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">        res <span class="op">=</span> fib(n<span class="dv">-1</span>) <span class="op">+</span> fib(n<span class="dv">-2</span>)</a>
<a class="sourceLine" id="cb6-8" data-line-number="8">        memo_dict[n] <span class="op">=</span> res</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">        <span class="cf">return</span> res</a></code></pre></div>
<p>In other words, itâ€™s a fundamentally stateful process. We need to mutate some mapping when we havenâ€™t seen the argument before.</p>
<p>Using laziness, though, we can emulate the same behavior purely. Instead of mutating the mapping on function calls, we fill the whole thing at the beginning, and then index into it. As long as the mapping is lazy, itâ€™ll only evaluate the function calls when theyâ€™re needed. We could use lists as our mapping to the natural numbers:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1">fibs <span class="fu">=</span> <span class="dv">0</span> <span class="fu">:</span> <span class="dv">1</span> <span class="fu">:</span> map fib [<span class="dv">2</span><span class="fu">..</span>]</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">fib n <span class="fu">=</span> fibs <span class="fu">!!</span> (n<span class="fu">-</span><span class="dv">1</span>) <span class="fu">+</span> fibs <span class="fu">!!</span> (n<span class="fu">-</span><span class="dv">2</span>)</a></code></pre></div>
<p>The benefit here is that we avoid the extra work of redundant calls. However, we pay for the speedup in three ways:</p>
<ol class="example" type="1">
<li>Space: we need to take up memory space storing the cached solutions.</li>
<li>Indexing: while we no longer have to pay for the expensive recursive calls, we <em>do</em> now have to pay for indexing into the data structure. In this example, weâ€™re paying linear time to index into the list.</li>
<li>Generality: the memoization is tied directly to the argument type to the function. We need to be able to use the argument to our memoized function as an index into some data structure. While a lot of argument types admit some type of indexing (whether theyâ€™re <code class="sourceCode haskell"><span class="dt">Hashable</span></code>, <code class="sourceCode haskell"><span class="dt">Ord</span></code>, etc.), some donâ€™t, and we canâ€™t memoize those using this technique.</li>
</ol>
<p>Weâ€™re going to look at a technique that allow us to somewhat mitigate 2 and 3 above, using something called a <em>nexus</em>.</p>
<h2 id="nexuses">Nexuses</h2>
<p>The standard technique of memoization is focused on the arguments to the function, creating a concrete representation of them in memory to map to the results. Using nexuses, as described in <span class="citation" data-cites="bird_functional_2003">Bird and Hinze (<a href="#ref-bird_functional_2003">2003</a>)</span>, weâ€™ll instead focus on the function itself, creating a concrete representation of its call graph in memory. Hereâ€™s the call graph of Fibonacci:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">                                            â”Œfib(<span class="dv">1</span>)<span class="fu">=</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">                                   â”Œfib(<span class="dv">2</span>)<span class="fu">=</span>1â”¤</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">                                   â”‚        â””fib(<span class="dv">0</span>)<span class="fu">=</span><span class="dv">0</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">                          â”Œfib(<span class="dv">3</span>)<span class="fu">=</span>2â”¤</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">                          â”‚        â””fib(<span class="dv">1</span>)<span class="fu">=</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">                 â”Œfib(<span class="dv">4</span>)<span class="fu">=</span>3â”¤</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">                 â”‚        â”‚        â”Œfib(<span class="dv">1</span>)<span class="fu">=</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8">                 â”‚        â””fib(<span class="dv">2</span>)<span class="fu">=</span>1â”¤</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">                 â”‚                 â””fib(<span class="dv">0</span>)<span class="fu">=</span><span class="dv">0</span></a>
<a class="sourceLine" id="cb8-10" data-line-number="10">        â”Œfib(<span class="dv">5</span>)<span class="fu">=</span>5â”¤</a>
<a class="sourceLine" id="cb8-11" data-line-number="11">        â”‚        â”‚                 â”Œfib(<span class="dv">1</span>)<span class="fu">=</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb8-12" data-line-number="12">        â”‚        â”‚        â”Œfib(<span class="dv">2</span>)<span class="fu">=</span>1â”¤</a>
<a class="sourceLine" id="cb8-13" data-line-number="13">        â”‚        â”‚        â”‚        â””fib(<span class="dv">0</span>)<span class="fu">=</span><span class="dv">0</span></a>
<a class="sourceLine" id="cb8-14" data-line-number="14">        â”‚        â””fib(<span class="dv">3</span>)<span class="fu">=</span>2â”¤</a>
<a class="sourceLine" id="cb8-15" data-line-number="15">        â”‚                 â””fib(<span class="dv">1</span>)<span class="fu">=</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb8-16" data-line-number="16">fib(<span class="dv">6</span>)<span class="fu">=</span>8â”¤</a>
<a class="sourceLine" id="cb8-17" data-line-number="17">        â”‚                          â”Œfib(<span class="dv">1</span>)<span class="fu">=</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb8-18" data-line-number="18">        â”‚                 â”Œfib(<span class="dv">2</span>)<span class="fu">=</span>1â”¤</a>
<a class="sourceLine" id="cb8-19" data-line-number="19">        â”‚                 â”‚        â””fib(<span class="dv">0</span>)<span class="fu">=</span><span class="dv">0</span></a>
<a class="sourceLine" id="cb8-20" data-line-number="20">        â”‚        â”Œfib(<span class="dv">3</span>)<span class="fu">=</span>2â”¤</a>
<a class="sourceLine" id="cb8-21" data-line-number="21">        â”‚        â”‚        â””fib(<span class="dv">1</span>)<span class="fu">=</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb8-22" data-line-number="22">        â””fib(<span class="dv">4</span>)<span class="fu">=</span>3â”¤</a>
<a class="sourceLine" id="cb8-23" data-line-number="23">                 â”‚        â”Œfib(<span class="dv">1</span>)<span class="fu">=</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb8-24" data-line-number="24">                 â””fib(<span class="dv">2</span>)<span class="fu">=</span>1â”¤</a>
<a class="sourceLine" id="cb8-25" data-line-number="25">                          â””fib(<span class="dv">0</span>)<span class="fu">=</span><span class="dv">0</span></a></code></pre></div>
<p>Turning <em>that</em> into a concrete datatype wouldnâ€™t do us much good: it still has the massively redundant computations in it. However, we can recognize that entire subtrees are duplicates of each other: in those cases, instead of creating both subtrees, we could just create one and have each parent point to it<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1">        â”Œfib(<span class="dv">5</span>)<span class="fu">=</span>5â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬fib(<span class="dv">3</span>)<span class="fu">=</span>2â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬fib(<span class="dv">1</span>)<span class="fu">=</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2">fib(<span class="dv">6</span>)<span class="fu">=</span>8â”¤        â”‚        â”‚        â”‚        â”‚</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">        â””â”€â”€â”€â”€â”€â”€â”€â”€â”´fib(<span class="dv">4</span>)<span class="fu">=</span>3â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´fib(<span class="dv">2</span>)<span class="fu">=</span>1â”´fib(<span class="dv">0</span>)<span class="fu">=</span><span class="dv">0</span></a></code></pre></div>
<p>This is a nexus. In Haskell, itâ€™s not observably different from the other form, except that it takes up significantly less space. Itâ€™s also much quicker to construct.</p>
<p>If we use it to memoize <code class="sourceCode haskell">fib</code>, weâ€™ll no longer be indexing on the argument: weâ€™ll instead follow the relevant branch in the tree to the subcomputation, which is just chasing a pointer. It also means the argument doesnâ€™t have to be constrained to any specific type. Hereâ€™s how youâ€™d do it:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Leaf</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">    <span class="fu">|</span> <span class="dt">Node</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">    {<span class="ot"> val   ::</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5">    ,<span class="ot"> left  ::</span> <span class="dt">Tree</span></a>
<a class="sourceLine" id="cb12-6" data-line-number="6">    ,<span class="ot"> right ::</span> <span class="dt">Tree</span>}</a>
<a class="sourceLine" id="cb12-7" data-line-number="7"></a>
<a class="sourceLine" id="cb12-8" data-line-number="8"><span class="ot">fib ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb12-9" data-line-number="9">fib <span class="fu">=</span> val <span class="fu">.</span> go</a>
<a class="sourceLine" id="cb12-10" data-line-number="10">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-11" data-line-number="11">    go <span class="dv">0</span> <span class="fu">=</span> <span class="dt">Node</span> <span class="dv">0</span> <span class="dt">Leaf</span> <span class="dt">Leaf</span></a>
<a class="sourceLine" id="cb12-12" data-line-number="12">    go <span class="dv">1</span> <span class="fu">=</span> <span class="dt">Node</span> <span class="dv">1</span> (<span class="dt">Node</span> <span class="dv">0</span> <span class="dt">Leaf</span> <span class="dt">Leaf</span>) <span class="dt">Leaf</span></a>
<a class="sourceLine" id="cb12-13" data-line-number="13">    go n <span class="fu">=</span> node t (left t) <span class="kw">where</span> t <span class="fu">=</span> go (n<span class="fu">-</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb12-14" data-line-number="14">    node l r <span class="fu">=</span> <span class="dt">Node</span> (val l <span class="fu">+</span> val r) l r</a></code></pre></div>
<p>So this approach sounds amazing, right? No constraints on the argument type, no need to pay for indexing: why doesnâ€™t everyone use it everywhere? The main reason is that figuring out a nexus for the call-graph is <em>hard</em>. In fact, finding an optimal one is NP-hard in general <span class="citation" data-cites="steffen_table_2006">(Steffen and Giegerich <a href="#ref-steffen_table_2006">2006</a>)</span>.</p>
<p>The second problem is that itâ€™s difficult to abstract out. The standard technique of memoization relies on building a mapping from keys to values: about as bread-and-butter as it gets in programming. Even more, we already know how to say â€œvalues of this type can be used efficiently as keys in some mappingâ€: for Data.Map itâ€™s <code class="sourceCode haskell"><span class="dt">Ord</span></code>, for Data.HashMap itâ€™s <code class="sourceCode haskell"><span class="dt">Hashable</span></code>. All of this together means we can build a nice library for memoization which exports the two following functions:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="ot">memoHash ::</span> <span class="dt">Hashable</span> a <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b)</a>
<a class="sourceLine" id="cb13-2" data-line-number="2"><span class="ot">memoOrd ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b)</a></code></pre></div>
<p>Building a nexus, however, is not bread-and-butter. On top of that, itâ€™s difficult to say something like â€œrecursive functions of this structure can be constructed using a nexusâ€. Whatâ€™s the typeclass for that? In comparison to the signatures above, the constraint will need to be on the <em>arrows</em>, not the <code class="sourceCode haskell">a</code>. Even talking about the structure of recursive functions is regarded as somewhat of an advanced subject: that said, the <a href="https://hackage.haskell.org/package/recursion-schemes">recursion-schemes</a> package allows us to do so, and even has facilities for constructing something <em>like</em> nexuses with histomorphisms <span class="citation" data-cites="tobin_time_2016">(Tobin <a href="#ref-tobin_time_2016">2016</a>)</span>. Iâ€™m still looking to see if thereâ€™s a library out there that <em>does</em> manage to abstract nexuses in an ergonomic way, so Iâ€™d love to hear if there was one (or if thereâ€™s some more generalized form which accomplishes the same).</p>
<h2 id="memoizing-countdown">Memoizing Countdown</h2>
<p>Thatâ€™s enough preamble. The nexus we want to construct for countdown is <em>not</em> going to memoize as much as possible: in particular, weâ€™re only going to memoize the shape of the trees, not the operators used. This will massively reduce the memory overhead, and still give a decent speedup <span class="citation" data-cites="bird_countdown:_2005">(Bird and Mu <a href="#ref-bird_countdown:_2005">2005</a>, 11 â€œbuilding a skeleton tree firstâ€)</span>.</p>
<p>With that in mind, the ideal nexus looks something like this:</p>
<p><img src="/images/boolean-lattice.svg" /></p>
<p>We can represent the tree in Haskell as a rose tree:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Node</span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3">    {<span class="ot"> root   ::</span> a</a>
<a class="sourceLine" id="cb14-4" data-line-number="4">    ,<span class="ot"> forest ::</span> <span class="dt">Forest</span> a</a>
<a class="sourceLine" id="cb14-5" data-line-number="5">    }</a>
<a class="sourceLine" id="cb14-6" data-line-number="6"></a>
<a class="sourceLine" id="cb14-7" data-line-number="7"><span class="kw">type</span> <span class="dt">Forest</span> a <span class="fu">=</span> [<span class="dt">Tree</span> a]</a></code></pre></div>
<p>Constructing the nexus itself isnâ€™t actually the most interesting part of this solution: <em>consuming</em> it is. We need to be able to go from the structure above into a list thatâ€™s the equivalent of <code class="sourceCode haskell">unmerges</code>. Doing a breadth-first traversal of the diagram above (without the top element) will give us:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mi>c</mi><mo>,</mo><mi>a</mi><mi>b</mi><mi>d</mi><mo>,</mo><mi>a</mi><mi>c</mi><mi>d</mi><mo>,</mo><mi>b</mi><mi>c</mi><mi>d</mi><mo>,</mo><mi>a</mi><mi>b</mi><mo>,</mo><mi>a</mi><mi>c</mi><mo>,</mo><mi>b</mi><mi>c</mi><mo>,</mo><mi>a</mi><mi>d</mi><mo>,</mo><mi>b</mi><mi>d</mi><mo>,</mo><mi>c</mi><mi>d</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo>,</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">abc, abd, acd, bcd, ab, ac, bc, ad, bd, cd, a, b, c, d</annotation></semantics></math></p>
<p>If you split that list in half, and zip it with its reverse, youâ€™ll get the output of <code class="sourceCode haskell">unmerges</code>.</p>
<p>However, the breadth-first traversal of the diagram isnâ€™t the same thing as the breadth-first traversal of the rose tree. The latter will traverse <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mi>c</mi><mo>,</mo><mi>a</mi><mi>b</mi><mi>d</mi><mo>,</mo><mi>a</mi><mi>c</mi><mi>d</mi><mo>,</mo><mi>b</mi><mi>c</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">abc, abd, acd, bcd</annotation></semantics></math>, and then the children of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">abc</annotation></semantics></math> (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mo>,</mo><mi>a</mi><mi>c</mi><mo>,</mo><mi>b</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">ab,ac,bc</annotation></semantics></math>), and then the children of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">abd</annotation></semantics></math> (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mo>,</mo><mi>a</mi><mi>d</mi><mo>,</mo><mi>b</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">ab,ad,bd</annotation></semantics></math>): and hereâ€™s our problem. We traverse <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">ab</annotation></semantics></math> twice, because we canâ€™t know that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">abc</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">abd</annotation></semantics></math> are pointing to the same value. What we have to do is first prune the tree, removing duplicates, and then perform a breadth-first traversal on that.</p>
<h3 id="pruning">Pruning</h3>
<p>Luckily, the duplicates follow a pattern, allowing us to remove them without having to do any equality checking. In each row, the first node has no duplicates in its children, the secondâ€™s first child is a duplicate, the thirdâ€™s first and second children are duplicates, and so on. You should be able to see this in the diagram above. Adapting a little from the paper, we get an algorithm like this:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="ot">para ::</span> (a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">para f b <span class="fu">=</span> go</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-4" data-line-number="4">    go [] <span class="fu">=</span> b</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">    go (x<span class="fu">:</span>xs) <span class="fu">=</span> f x xs (go xs)</a>
<a class="sourceLine" id="cb15-6" data-line-number="6"></a>
<a class="sourceLine" id="cb15-7" data-line-number="7"><span class="ot">prune ::</span> <span class="dt">Forest</span> a <span class="ot">-&gt;</span> <span class="dt">Forest</span> a</a>
<a class="sourceLine" id="cb15-8" data-line-number="8">prune ts <span class="fu">=</span> pruneAt ts <span class="dv">0</span> </a>
<a class="sourceLine" id="cb15-9" data-line-number="9">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-10" data-line-number="10">    pruneAt <span class="fu">=</span> para f (const [])</a>
<a class="sourceLine" id="cb15-11" data-line-number="11">    f (<span class="dt">Node</span> x []) t _ _ <span class="fu">=</span> <span class="dt">Node</span> x [] <span class="fu">:</span> t</a>
<a class="sourceLine" id="cb15-12" data-line-number="12">    f (<span class="dt">Node</span> x us) _ a k <span class="fu">=</span></a>
<a class="sourceLine" id="cb15-13" data-line-number="13">        <span class="dt">Node</span> x (pruneAt (drop k us) k) <span class="fu">:</span> a (k <span class="fu">+</span> <span class="dv">1</span>)</a></code></pre></div>
<h3 id="breadth-first-traversal">Breadth-First Traversal</h3>
<p>I went through this in a <a href="/posts/2018-03-17-rose-trees-breadth-first.html">previous post</a>, so this is the end solution:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="ot">breadthFirst ::</span> <span class="dt">Forest</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">breadthFirst ts <span class="fu">=</span> foldr f b ts []</a>
<a class="sourceLine" id="cb16-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-4" data-line-number="4">    f (<span class="dt">Node</span> x xs) fw bw <span class="fu">=</span> x <span class="fu">:</span> fw (xs<span class="fu">:</span>bw)</a>
<a class="sourceLine" id="cb16-5" data-line-number="5"></a>
<a class="sourceLine" id="cb16-6" data-line-number="6">    b [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb16-7" data-line-number="7">    b q <span class="fu">=</span> foldl (foldr f) b q []</a></code></pre></div>
<p>With the appropriate incantations, this is actually the fastest implementation Iâ€™ve found.</p>
<h3 id="fusing">Fusing</h3>
<p>We can actually inline both of the above functions, fusing them together:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="ot">spanNexus ::</span> <span class="dt">Forest</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">spanNexus ts <span class="fu">=</span> foldr f (const b) ts <span class="dv">0</span> []</a>
<a class="sourceLine" id="cb17-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb17-4" data-line-number="4">    f (<span class="dt">Node</span> x us) fw k bw <span class="fu">=</span> x <span class="fu">:</span> fw (k<span class="fu">+</span><span class="dv">1</span>) ((drop k us, k) <span class="fu">:</span> bw)</a>
<a class="sourceLine" id="cb17-5" data-line-number="5"></a>
<a class="sourceLine" id="cb17-6" data-line-number="6">    b [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb17-7" data-line-number="7">    b qs <span class="fu">=</span> foldl (uncurry <span class="fu">.</span> foldr f <span class="fu">.</span> const) b qs []</a></code></pre></div>
<h3 id="halving-convolving-and-folding">Halving, Convolving, and Folding</h3>
<p>So, now we can go from the tree to our list of splits. Next step is to convert that list into the output of unmerges, by zipping the reverse of the first half with the second. We can use an algorithm described in <span class="citation" data-cites="danvy_there_2005">Danvy and Goldberg (<a href="#ref-danvy_there_2005">2005</a>)</span> to do the zipping and reversing:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1">fold xs n <span class="fu">=</span> go xs n (const [])</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3">    go xs <span class="dv">0</span>     k <span class="fu">=</span> k xs</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">    go (x<span class="fu">:</span>xs) n k <span class="fu">=</span> go xs (n<span class="fu">-</span><span class="dv">2</span>) (\(y<span class="fu">:</span>ys) <span class="ot">-&gt;</span> (x,y) <span class="fu">:</span> k ys)</a></code></pre></div>
<p>And we can inline the function which collapses those results into one:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1">fold xs n <span class="fu">=</span> go xs n (const [])</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-3" data-line-number="3">    go <span class="dv">0</span> xss k <span class="fu">=</span> k xss</a>
<a class="sourceLine" id="cb19-4" data-line-number="4">    go n (xs<span class="fu">:</span>xss) k <span class="fu">=</span></a>
<a class="sourceLine" id="cb19-5" data-line-number="5">        go (n<span class="fu">-</span><span class="dv">2</span>) xss (\(ys<span class="fu">:</span>yss) <span class="ot">-&gt;</span> [ z</a>
<a class="sourceLine" id="cb19-6" data-line-number="6">                                      <span class="fu">|</span> x <span class="ot">&lt;-</span> xs</a>
<a class="sourceLine" id="cb19-7" data-line-number="7">                                      , y <span class="ot">&lt;-</span> ys</a>
<a class="sourceLine" id="cb19-8" data-line-number="8">                                      , z <span class="ot">&lt;-</span> cmb x y</a>
<a class="sourceLine" id="cb19-9" data-line-number="9">                                      ] <span class="fu">++</span> k yss)</a></code></pre></div>
<p>And thatâ€™s all we need!</p>
<details>
<p><summary> Full Code </summary></p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Tree</span> <span class="kw">as</span> <span class="dt">Rose</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2"></a>
<a class="sourceLine" id="cb20-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb20-4" data-line-number="4">    <span class="fu">=</span> <span class="dt">Leaf</span> <span class="dt">Int</span> a</a>
<a class="sourceLine" id="cb20-5" data-line-number="5">    <span class="fu">|</span> <span class="dt">Node</span> [<span class="dt">Tree</span> a]</a>
<a class="sourceLine" id="cb20-6" data-line-number="6">    <span class="kw">deriving</span> (<span class="dt">Show</span>,<span class="dt">Eq</span>,<span class="dt">Functor</span>)</a>
<a class="sourceLine" id="cb20-7" data-line-number="7">    </a>
<a class="sourceLine" id="cb20-8" data-line-number="8"><span class="ot">enumerateTrees ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a]) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb20-9" data-line-number="9">enumerateTrees _ [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb20-10" data-line-number="10">enumerateTrees cmb xs <span class="fu">=</span> (extract <span class="fu">.</span> steps <span class="fu">.</span> initial) xs</a>
<a class="sourceLine" id="cb20-11" data-line-number="11">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-12" data-line-number="12">    step <span class="fu">=</span> map nodes <span class="fu">.</span> group</a>
<a class="sourceLine" id="cb20-13" data-line-number="13"></a>
<a class="sourceLine" id="cb20-14" data-line-number="14">    steps [x] <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb20-15" data-line-number="15">    steps xs <span class="fu">=</span> steps (step xs)</a>
<a class="sourceLine" id="cb20-16" data-line-number="16"></a>
<a class="sourceLine" id="cb20-17" data-line-number="17">    initial <span class="fu">=</span> map (<span class="dt">Leaf</span> <span class="dv">1</span> <span class="fu">.</span> flip <span class="dt">Rose.Node</span> [] <span class="fu">.</span> pure)</a>
<a class="sourceLine" id="cb20-18" data-line-number="18"></a>
<a class="sourceLine" id="cb20-19" data-line-number="19">    extract (<span class="dt">Leaf</span> _ x) <span class="fu">=</span> Rose.rootLabel x</a>
<a class="sourceLine" id="cb20-20" data-line-number="20">    extract (<span class="dt">Node</span> [x]) <span class="fu">=</span> extract x</a>
<a class="sourceLine" id="cb20-21" data-line-number="21"></a>
<a class="sourceLine" id="cb20-22" data-line-number="22">    group [_] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb20-23" data-line-number="23">    group (<span class="dt">Leaf</span> _ x<span class="fu">:</span>vs) <span class="fu">=</span> <span class="dt">Node</span> [<span class="dt">Leaf</span> <span class="dv">2</span> [x, y] <span class="fu">|</span> <span class="dt">Leaf</span> _ y <span class="ot">&lt;-</span> vs] <span class="fu">:</span> group vs</a>
<a class="sourceLine" id="cb20-24" data-line-number="24">    group (<span class="dt">Node</span>   u<span class="fu">:</span>vs) <span class="fu">=</span> <span class="dt">Node</span> (zipWith comb (group u) vs) <span class="fu">:</span> group vs</a>
<a class="sourceLine" id="cb20-25" data-line-number="25"></a>
<a class="sourceLine" id="cb20-26" data-line-number="26">    comb (<span class="dt">Leaf</span> n xs) (<span class="dt">Leaf</span> _ x) <span class="fu">=</span> <span class="dt">Leaf</span> (n <span class="fu">+</span> <span class="dv">1</span>) (xs <span class="fu">++</span> [x])</a>
<a class="sourceLine" id="cb20-27" data-line-number="27">    comb (<span class="dt">Node</span> us) (<span class="dt">Node</span> vs) <span class="fu">=</span> <span class="dt">Node</span> (zipWith comb us vs)</a>
<a class="sourceLine" id="cb20-28" data-line-number="28"></a>
<a class="sourceLine" id="cb20-29" data-line-number="29">    forest ts <span class="fu">=</span> foldr f (const b) ts <span class="dv">0</span> []</a>
<a class="sourceLine" id="cb20-30" data-line-number="30">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-31" data-line-number="31">        f (<span class="dt">Rose.Node</span> x []) fw <span class="fu">!</span>k bw <span class="fu">=</span> x <span class="fu">:</span> fw (k <span class="fu">+</span> <span class="dv">1</span>) bw</a>
<a class="sourceLine" id="cb20-32" data-line-number="32">        f (<span class="dt">Rose.Node</span> x us) fw <span class="fu">!</span>k bw <span class="fu">=</span> x <span class="fu">:</span> fw (k <span class="fu">+</span> <span class="dv">1</span>) ((drop k us, k) <span class="fu">:</span> bw)</a>
<a class="sourceLine" id="cb20-33" data-line-number="33"></a>
<a class="sourceLine" id="cb20-34" data-line-number="34">        b [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb20-35" data-line-number="35">        b qs <span class="fu">=</span> foldl (uncurry <span class="fu">.</span> foldr f <span class="fu">.</span> const) b qs []</a>
<a class="sourceLine" id="cb20-36" data-line-number="36"></a>
<a class="sourceLine" id="cb20-37" data-line-number="37">    nodes (<span class="dt">Leaf</span> n x) <span class="fu">=</span> <span class="dt">Leaf</span> <span class="dv">1</span> (node n x)</a>
<a class="sourceLine" id="cb20-38" data-line-number="38">    nodes (<span class="dt">Node</span> xs) <span class="fu">=</span> <span class="dt">Node</span> (map nodes xs)</a>
<a class="sourceLine" id="cb20-39" data-line-number="39"></a>
<a class="sourceLine" id="cb20-40" data-line-number="40">    node n ts <span class="fu">=</span> <span class="dt">Rose.Node</span> (walk (<span class="dv">2</span> <span class="fu">^</span> n <span class="fu">-</span> <span class="dv">2</span>) (forest ts) (const [])) ts</a>
<a class="sourceLine" id="cb20-41" data-line-number="41">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-42" data-line-number="42">        walk <span class="dv">0</span> xss k <span class="fu">=</span> k xss</a>
<a class="sourceLine" id="cb20-43" data-line-number="43">        walk n (xs<span class="fu">:</span>xss) k <span class="fu">=</span></a>
<a class="sourceLine" id="cb20-44" data-line-number="44">            walk (n<span class="fu">-</span><span class="dv">2</span>) xss (\(ys<span class="fu">:</span>yss) <span class="ot">-&gt;</span> [ z</a>
<a class="sourceLine" id="cb20-45" data-line-number="45">                                         <span class="fu">|</span> x <span class="ot">&lt;-</span> xs</a>
<a class="sourceLine" id="cb20-46" data-line-number="46">                                         , y <span class="ot">&lt;-</span> ys</a>
<a class="sourceLine" id="cb20-47" data-line-number="47">                                         , z <span class="ot">&lt;-</span> cmb x y</a>
<a class="sourceLine" id="cb20-48" data-line-number="48">                                         ] <span class="fu">++</span> k yss)</a></code></pre></div>
</details>
<h2 id="using-it-for-countdown">Using it for Countdown</h2>
<p>The first thing to do for the Countdown solution is to figure out a representation for expressions. The one from simple-reflect is perfect for displaying the result, but we should memoize its calculation.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Memoed</span></a>
<a class="sourceLine" id="cb21-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">Memoed</span></a>
<a class="sourceLine" id="cb21-3" data-line-number="3">  {<span class="ot"> expr   ::</span> <span class="dt">Expr</span></a>
<a class="sourceLine" id="cb21-4" data-line-number="4">  ,<span class="ot"> result ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb21-5" data-line-number="5">  }</a></code></pre></div>
<p>Then, some helpers for building:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Op</span> <span class="fu">=</span> <span class="dt">Add</span> <span class="fu">|</span> <span class="dt">Dif</span> <span class="fu">|</span> <span class="dt">Mul</span> <span class="fu">|</span> <span class="dt">Div</span></a>
<a class="sourceLine" id="cb22-2" data-line-number="2"></a>
<a class="sourceLine" id="cb22-3" data-line-number="3">binOp f g x y <span class="fu">=</span> <span class="dt">Memoed</span> ((f <span class="ot">`on`</span> expr) x y) ((g <span class="ot">`on`</span> result) x y)</a>
<a class="sourceLine" id="cb22-4" data-line-number="4"></a>
<a class="sourceLine" id="cb22-5" data-line-number="5"><span class="ot">apply ::</span> <span class="dt">Op</span> <span class="ot">-&gt;</span> <span class="dt">Memoed</span> <span class="ot">-&gt;</span> <span class="dt">Memoed</span> <span class="ot">-&gt;</span> <span class="dt">Memoed</span></a>
<a class="sourceLine" id="cb22-6" data-line-number="6">apply <span class="dt">Add</span> x y <span class="fu">=</span> binOp (<span class="fu">+</span>) (<span class="fu">+</span>) x y</a>
<a class="sourceLine" id="cb22-7" data-line-number="7">apply <span class="dt">Dif</span> x y</a>
<a class="sourceLine" id="cb22-8" data-line-number="8">  <span class="fu">|</span> result y <span class="fu">&lt;</span> result x <span class="fu">=</span> binOp (<span class="fu">-</span>) (<span class="fu">-</span>) x y</a>
<a class="sourceLine" id="cb22-9" data-line-number="9">  <span class="fu">|</span> otherwise <span class="fu">=</span> binOp (<span class="fu">-</span>) (<span class="fu">-</span>) y x</a>
<a class="sourceLine" id="cb22-10" data-line-number="10">apply <span class="dt">Mul</span> x y <span class="fu">=</span> binOp (<span class="fu">*</span>) (<span class="fu">*</span>) x y</a>
<a class="sourceLine" id="cb22-11" data-line-number="11">apply <span class="dt">Div</span> x y <span class="fu">=</span> binOp div div x y</a></code></pre></div>
<p>Finally, the full algorithm:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="ot">enumerateExprs ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Memoed</span>]</a>
<a class="sourceLine" id="cb23-2" data-line-number="2">enumerateExprs <span class="fu">=</span> enumerateTrees cmb <span class="fu">.</span> map (\x <span class="ot">-&gt;</span> <span class="dt">Memoed</span> (fromIntegral x) x)</a>
<a class="sourceLine" id="cb23-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-4" data-line-number="4">    cmb x y <span class="fu">=</span></a>
<a class="sourceLine" id="cb23-5" data-line-number="5">        nubs <span class="fu">$</span></a>
<a class="sourceLine" id="cb23-6" data-line-number="6">        x <span class="fu">:</span></a>
<a class="sourceLine" id="cb23-7" data-line-number="7">        y <span class="fu">:</span></a>
<a class="sourceLine" id="cb23-8" data-line-number="8">        [ apply op x y</a>
<a class="sourceLine" id="cb23-9" data-line-number="9">        <span class="fu">|</span> op <span class="ot">&lt;-</span> [<span class="dt">Add</span>, <span class="dt">Dif</span>, <span class="dt">Mul</span>, <span class="dt">Div</span>]</a>
<a class="sourceLine" id="cb23-10" data-line-number="10">        , legal op (result x) (result y) ]</a>
<a class="sourceLine" id="cb23-11" data-line-number="11">    legal <span class="dt">Add</span> _ _ <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb23-12" data-line-number="12">    legal <span class="dt">Dif</span> x y <span class="fu">=</span> x <span class="fu">/=</span> y</a>
<a class="sourceLine" id="cb23-13" data-line-number="13">    legal <span class="dt">Mul</span> _ _ <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb23-14" data-line-number="14">    legal <span class="dt">Div</span> x y <span class="fu">=</span> x <span class="ot">`mod`</span> y <span class="fu">==</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb23-15" data-line-number="15">    nubs xs <span class="fu">=</span> foldr f (const []) xs IntSet.empty</a>
<a class="sourceLine" id="cb23-16" data-line-number="16">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-17" data-line-number="17">        f e a s</a>
<a class="sourceLine" id="cb23-18" data-line-number="18">          <span class="fu">|</span> IntSet.member (result e) s <span class="fu">=</span> a s</a>
<a class="sourceLine" id="cb23-19" data-line-number="19">          <span class="fu">|</span> otherwise <span class="fu">=</span> e <span class="fu">:</span> a (IntSet.insert (result e) s)</a>
<a class="sourceLine" id="cb23-20" data-line-number="20"></a>
<a class="sourceLine" id="cb23-21" data-line-number="21"><span class="ot">countdown ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Expr</span>]</a>
<a class="sourceLine" id="cb23-22" data-line-number="22">countdown targ <span class="fu">=</span> map expr <span class="fu">.</span> filter ((<span class="fu">==</span>) targ <span class="fu">.</span> result) <span class="fu">.</span> enumerateExprs</a>
<a class="sourceLine" id="cb23-23" data-line-number="23"></a>
<a class="sourceLine" id="cb23-24" data-line-number="24"><span class="fu">&gt;&gt;&gt;</span> (mapM_ print <span class="fu">.</span> reduction <span class="fu">.</span> head) (countdown <span class="dv">586</span> [<span class="dv">100</span>,<span class="dv">25</span>,<span class="dv">1</span>,<span class="dv">5</span>,<span class="dv">3</span>,<span class="dv">10</span>])</a>
<a class="sourceLine" id="cb23-25" data-line-number="25"><span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> <span class="dv">1</span> <span class="fu">+</span> (<span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb23-26" data-line-number="26"><span class="dv">75</span> <span class="fu">+</span> <span class="dv">1</span> <span class="fu">+</span> (<span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb23-27" data-line-number="27"><span class="dv">76</span> <span class="fu">+</span> (<span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb23-28" data-line-number="28"><span class="dv">76</span> <span class="fu">+</span> (<span class="dv">500</span> <span class="fu">+</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb23-29" data-line-number="29"><span class="dv">76</span> <span class="fu">+</span> <span class="dv">510</span></a>
<a class="sourceLine" id="cb23-30" data-line-number="30"><span class="dv">586</span></a></code></pre></div>
<p>There are some optimizations going on here, taken mainly from <span class="citation" data-cites="bird_countdown:_2005">Bird and Mu (<a href="#ref-bird_countdown:_2005">2005</a>)</span>:</p>
<ol type="1">
<li>We filter out illegal operations, as described originally.</li>
<li>We filter out any expressions that have the same value.</li>
</ol>
<h2 id="testing-the-implementation">Testing the Implementation</h2>
<p>So weâ€™ve followed the paper, written the code: time to test. The specification of the function is relatively simple: calculate all applications of the commutative operator to some input, <em>without</em> recalculating subtrees.</p>
<p>Weâ€™ll need a free structure for the â€œcommutative operatorâ€:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb24-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Leaf</span> a</a>
<a class="sourceLine" id="cb24-3" data-line-number="3">    <span class="fu">|</span> <span class="dt">Tree</span> a <span class="fu">:^:</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb24-4" data-line-number="4">    <span class="kw">deriving</span> (<span class="dt">Foldable</span>,<span class="dt">Eq</span>,<span class="dt">Ord</span>,<span class="dt">Show</span>)</a></code></pre></div>
<p>Hereâ€™s the problem: itâ€™s not commutative! We can remedy it by only exporting a constructor that creates the tree in a commutative way, and we can make it a pattern synonym so it looks normal:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="ot">{-# LANGUAGE DeriveFoldable  #-}</span></a>
<a class="sourceLine" id="cb25-2" data-line-number="2"><span class="ot">{-# LANGUAGE PatternSynonyms #-}</span></a>
<a class="sourceLine" id="cb25-3" data-line-number="3"></a>
<a class="sourceLine" id="cb25-4" data-line-number="4"><span class="kw">module</span> <span class="dt">Commutative</span></a>
<a class="sourceLine" id="cb25-5" data-line-number="5">  (<span class="dt">Tree</span>(<span class="dt">Leaf</span>)</a>
<a class="sourceLine" id="cb25-6" data-line-number="6">  ,pattern (<span class="fu">:*:</span>))</a>
<a class="sourceLine" id="cb25-7" data-line-number="7">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-8" data-line-number="8"></a>
<a class="sourceLine" id="cb25-9" data-line-number="9"><span class="kw">data</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb25-10" data-line-number="10">    <span class="fu">=</span> <span class="dt">Leaf</span> a</a>
<a class="sourceLine" id="cb25-11" data-line-number="11">    <span class="fu">|</span> <span class="dt">Tree</span> a <span class="fu">:^:</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb25-12" data-line-number="12">    <span class="kw">deriving</span> (<span class="dt">Eq</span>,<span class="dt">Ord</span>,<span class="dt">Show</span>,<span class="dt">Foldable</span>)</a>
<a class="sourceLine" id="cb25-13" data-line-number="13"></a>
<a class="sourceLine" id="cb25-14" data-line-number="14">pattern<span class="ot"> (:*:) ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb25-15" data-line-number="15">pattern xs <span class="fu">:*:</span> ys <span class="ot">&lt;-</span> xs <span class="fu">:^:</span> ys <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-16" data-line-number="16">  xs <span class="fu">:*:</span> ys</a>
<a class="sourceLine" id="cb25-17" data-line-number="17">      <span class="fu">|</span> xs <span class="fu">&lt;=</span> ys <span class="fu">=</span> xs <span class="fu">:^:</span> ys</a>
<a class="sourceLine" id="cb25-18" data-line-number="18">      <span class="fu">|</span> otherwise <span class="fu">=</span> ys <span class="fu">:^:</span> xs</a>
<a class="sourceLine" id="cb25-19" data-line-number="19"></a>
<a class="sourceLine" id="cb25-20" data-line-number="20"><span class="ot">{-# COMPLETE Leaf, (:*:) #-}</span></a></code></pre></div>
<p>Now we need to check if all applications are actually tested. First, to generate all trees:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="ot">allTrees ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Set</span> (<span class="dt">Tree</span> a)</a>
<a class="sourceLine" id="cb26-2" data-line-number="2">allTrees [x] <span class="fu">=</span> Set.singleton (<span class="dt">Leaf</span> x)</a>
<a class="sourceLine" id="cb26-3" data-line-number="3">allTrees xs <span class="fu">=</span> Set.unions (map (uncurry f) (unmerges xs))</a>
<a class="sourceLine" id="cb26-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb26-5" data-line-number="5">    f ls rs <span class="fu">=</span> Set.fromList ((liftA2 (<span class="fu">:*:</span>) <span class="ot">`on`</span> (Set.toList <span class="fu">.</span> allTrees)) ls rs)</a>
<a class="sourceLine" id="cb26-6" data-line-number="6"></a>
<a class="sourceLine" id="cb26-7" data-line-number="7"><span class="ot">allSubTrees ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Set</span> (<span class="dt">Tree</span> a)</a>
<a class="sourceLine" id="cb26-8" data-line-number="8">allSubTrees [x] <span class="fu">=</span> Set.singleton (<span class="dt">Leaf</span> x)</a>
<a class="sourceLine" id="cb26-9" data-line-number="9">allSubTrees xs <span class="fu">=</span></a>
<a class="sourceLine" id="cb26-10" data-line-number="10">    Set.unions (map (uncurry f <span class="fu">.</span> (allSubTrees <span class="fu">***</span> allSubTrees)) (unmerges xs))</a>
<a class="sourceLine" id="cb26-11" data-line-number="11">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb26-12" data-line-number="12">    f ls rs <span class="fu">=</span></a>
<a class="sourceLine" id="cb26-13" data-line-number="13">        Set.unions</a>
<a class="sourceLine" id="cb26-14" data-line-number="14">            [ls, rs, Set.fromList ((liftA2 (<span class="fu">:*:</span>) <span class="ot">`on`</span> Set.toList) ls rs)]</a></code></pre></div>
<p>Then, to test:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="ot">prop_exhaustiveSearch ::</span> <span class="dt">Natural</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb27-2" data-line-number="2">prop_exhaustiveSearch n <span class="fu">=</span></a>
<a class="sourceLine" id="cb27-3" data-line-number="3">         <span class="kw">let</span> src <span class="fu">=</span> [<span class="dv">0</span> <span class="fu">..</span> fromIntegral n]</a>
<a class="sourceLine" id="cb27-4" data-line-number="4">             expect <span class="fu">=</span> allSubTrees src</a>
<a class="sourceLine" id="cb27-5" data-line-number="5">             actual <span class="fu">=</span></a>
<a class="sourceLine" id="cb27-6" data-line-number="6">                 Set.fromList</a>
<a class="sourceLine" id="cb27-7" data-line-number="7">                     (enumerateTrees</a>
<a class="sourceLine" id="cb27-8" data-line-number="8">                          (\xs ys <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb27-9" data-line-number="9">                                [xs, ys, xs <span class="fu">:*:</span> ys])</a>
<a class="sourceLine" id="cb27-10" data-line-number="10">                          (map <span class="dt">Leaf</span> src))</a>
<a class="sourceLine" id="cb27-11" data-line-number="11">         <span class="kw">in</span> expect <span class="fu">==</span> actual</a>
<a class="sourceLine" id="cb27-12" data-line-number="12"></a>
<a class="sourceLine" id="cb27-13" data-line-number="13"><span class="ot">prop_exhaustiveSearchFull ::</span> <span class="dt">Natural</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb27-14" data-line-number="14">prop_exhaustiveSearchFull n <span class="fu">=</span></a>
<a class="sourceLine" id="cb27-15" data-line-number="15">         <span class="kw">let</span> src <span class="fu">=</span> [<span class="dv">0</span> <span class="fu">..</span> fromIntegral n]</a>
<a class="sourceLine" id="cb27-16" data-line-number="16">             expect <span class="fu">=</span> Map.fromSet (const <span class="dv">1</span>) (allTrees src)</a>
<a class="sourceLine" id="cb27-17" data-line-number="17">             actual <span class="fu">=</span></a>
<a class="sourceLine" id="cb27-18" data-line-number="18">                 freqs</a>
<a class="sourceLine" id="cb27-19" data-line-number="19">                     (enumerateTrees</a>
<a class="sourceLine" id="cb27-20" data-line-number="20">                          (\xs ys <span class="ot">-&gt;</span> [xs <span class="fu">:*:</span> ys])</a>
<a class="sourceLine" id="cb27-21" data-line-number="21">                          (map <span class="dt">Leaf</span> src))</a>
<a class="sourceLine" id="cb27-22" data-line-number="22">         <span class="kw">in</span> expect <span class="fu">==</span> actual</a></code></pre></div>
<p>Testing for repeated calls is more tricky. Remember, the memoization is supposed to be unobservable: in order to see it, weâ€™re going to have to use some unsafe operations.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1">traceSubsequences</a>
<a class="sourceLine" id="cb28-2" data-line-number="2"><span class="ot">    ::</span> ((<span class="dt">Tree</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Tree</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Tree</span> <span class="dt">Int</span>]) <span class="ot">-&gt;</span> [<span class="dt">Tree</span> <span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Tree</span> <span class="dt">Int</span>])</a>
<a class="sourceLine" id="cb28-3" data-line-number="3">    <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb28-4" data-line-number="4">    <span class="ot">-&gt;</span> (<span class="dt">Map</span> (<span class="dt">Tree</span> <span class="dt">Int</span>) <span class="dt">Int</span>, [<span class="dt">Tree</span> <span class="dt">Int</span>])</a>
<a class="sourceLine" id="cb28-5" data-line-number="5">traceSubsequences enm ints <span class="fu">=</span></a>
<a class="sourceLine" id="cb28-6" data-line-number="6">    runST <span class="fu">$</span></a>
<a class="sourceLine" id="cb28-7" data-line-number="7">    <span class="kw">do</span> ref <span class="ot">&lt;-</span> newSTRef Map.empty</a>
<a class="sourceLine" id="cb28-8" data-line-number="8">       <span class="kw">let</span> res <span class="fu">=</span> enm (combine ref) (map (conv ref) ints)</a>
<a class="sourceLine" id="cb28-9" data-line-number="9">       traverse_ (foldr seq (pure ())) res</a>
<a class="sourceLine" id="cb28-10" data-line-number="10">       intm <span class="ot">&lt;-</span> readSTRef ref</a>
<a class="sourceLine" id="cb28-11" data-line-number="11">       pure (intm, res)</a>
<a class="sourceLine" id="cb28-12" data-line-number="12">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb28-13" data-line-number="13">    combine ref xs ys <span class="fu">=</span> unsafeRunST ([xs <span class="fu">:*:</span> ys] <span class="fu">&lt;$</span> modifySTRef&#39; ref (incr (xs <span class="fu">:*:</span> ys)))</a>
<a class="sourceLine" id="cb28-14" data-line-number="14">    <span class="ot">{-# NOINLINE combine #-}</span></a>
<a class="sourceLine" id="cb28-15" data-line-number="15">    conv ref x <span class="fu">=</span> unsafeRunST (<span class="dt">Leaf</span> x <span class="fu">&lt;$</span> modifySTRef&#39; ref (incr (<span class="dt">Leaf</span> x)))</a>
<a class="sourceLine" id="cb28-16" data-line-number="16">    <span class="ot">{-# NOINLINE conv #-}</span></a>
<a class="sourceLine" id="cb28-17" data-line-number="17">    unsafeRunST cmp <span class="fu">=</span> unsafePerformIO (unsafeSTToIO cmp)</a>
<a class="sourceLine" id="cb28-18" data-line-number="18"></a>
<a class="sourceLine" id="cb28-19" data-line-number="19"><span class="ot">prop_noRepeatedCalls ::</span> <span class="dt">Property</span></a>
<a class="sourceLine" id="cb28-20" data-line-number="20">prop_noRepeatedCalls <span class="fu">=</span></a>
<a class="sourceLine" id="cb28-21" data-line-number="21">    property <span class="fu">$</span> sized <span class="fu">$</span></a>
<a class="sourceLine" id="cb28-22" data-line-number="22">    \n <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb28-23" data-line-number="23">         pure <span class="fu">$</span></a>
<a class="sourceLine" id="cb28-24" data-line-number="24">         <span class="kw">let</span> src <span class="fu">=</span> [<span class="dv">0</span> <span class="fu">..</span> n]</a>
<a class="sourceLine" id="cb28-25" data-line-number="25">             (tint,tres) <span class="fu">=</span> fmap freqs (traceSubsequences enumerateTrees src)</a>
<a class="sourceLine" id="cb28-26" data-line-number="26">             (fint,fres) <span class="fu">=</span> fmap freqs (traceSubsequences dummyEnumerate src)</a>
<a class="sourceLine" id="cb28-27" data-line-number="27">         <span class="kw">in</span> counterexample</a>
<a class="sourceLine" id="cb28-28" data-line-number="28">                (mapCompare (freqs (allSubTrees src)) tint)</a>
<a class="sourceLine" id="cb28-29" data-line-number="29">                (all (<span class="dv">1</span> <span class="fu">==</span>) tint) <span class="fu">.&amp;&amp;.</span></a>
<a class="sourceLine" id="cb28-30" data-line-number="30">            counterexample (mapCompare tres fres) (tres <span class="fu">==</span> fres) <span class="fu">.&amp;&amp;.</span></a>
<a class="sourceLine" id="cb28-31" data-line-number="31">            (n <span class="fu">&gt;</span> <span class="dv">2</span> <span class="fu">==&gt;</span> tint <span class="fu">/=</span> fint)</a></code></pre></div>
<p>Here, <code class="sourceCode haskell">dummyEnumerate</code> is some method which performs the same task, but <em>doesnâ€™t</em> construct a nexus, so we can ensure that our tests really do catch faulty implementations.</p>
<div id="refs" class="references">
<div id="ref-bird_functional_2003">
<p>Bird, Richard, and Ralf Hinze. 2003. â€œFunctional Pearl Trouble Shared is Trouble Halved.â€ In <em>Proceedings of the 2003 ACM SIGPLAN Workshop on Haskell</em>, 1â€“6. Haskell â€™03. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/871895.871896">10.1145/871895.871896</a>. <a href="http://doi.acm.org/10.1145/871895.871896" class="uri">http://doi.acm.org/10.1145/871895.871896</a>.</p>
</div>
<div id="ref-bird_countdown:_2005">
<p>Bird, Richard, and Shin-Cheng Mu. 2005. â€œCountdown: A case study in origami programming.â€ <em>Journal of Functional Programming</em> 15 (05) (August): 679. doi:<a href="https://doi.org/10.1017/S0956796805005642">10.1017/S0956796805005642</a>. <a href="http://www.journals.cambridge.org/abstract_S0956796805005642" class="uri">http://www.journals.cambridge.org/abstract_S0956796805005642</a>.</p>
</div>
<div id="ref-danvy_there_2005">
<p>Danvy, Olivier, and Mayer Goldberg. 2005. â€œThere and Back Again.â€ <em>BRICS Report Series</em> 12 (3). doi:<a href="https://doi.org/10.7146/brics.v12i3.21869">10.7146/brics.v12i3.21869</a>. <a href="https://tidsskrift.dk/brics/article/view/21869" class="uri">https://tidsskrift.dk/brics/article/view/21869</a>.</p>
</div>
<div id="ref-hutton_countdown_2002">
<p>Hutton, Graham. 2002. â€œThe Countdown Problem.â€ <em>J. Funct. Program.</em> 12 (6) (November): 609â€“616. doi:<a href="https://doi.org/10.1017/S0956796801004300">10.1017/S0956796801004300</a>. <a href="http://www.cs.nott.ac.uk/~pszgmh/countdown.pdf" class="uri">http://www.cs.nott.ac.uk/~pszgmh/countdown.pdf</a>.</p>
</div>
<div id="ref-steffen_table_2006">
<p>Steffen, Peter, and Robert Giegerich. 2006. â€œTable Design in Dynamic Programming.â€ <em>Information and Computation</em> 204 (9) (September): 1325â€“1345. doi:<a href="https://doi.org/10.1016/j.ic.2006.02.006">10.1016/j.ic.2006.02.006</a>. <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.85.601&amp;rep=rep1&amp;type=pdf" class="uri">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.85.601&amp;rep=rep1&amp;type=pdf</a>.</p>
</div>
<div id="ref-tobin_time_2016">
<p>Tobin, Jared. 2016. â€œTime Traveling Recursion Schemes.â€ <em>jtobin.io</em>. <a href="https://jtobin.io/time-traveling-recursion" class="uri">https://jtobin.io/time-traveling-recursion</a>.</p>
</div>
</div>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>If you think that structure looks more like a funny linked list than a tree, thatâ€™s because it is. Instead of talking about â€œleftâ€ and â€œrightâ€ branches, we could talk about the first and second elements in a list: in fact, this is exactly whatâ€™s happening in the famous <code class="sourceCode haskell">zipWith</code> Fibonacci implementation (in reverse).</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1">fibs <span class="fu">=</span> <span class="dv">0</span> <span class="fu">:</span> <span class="dv">1</span> <span class="fu">:</span> zipWith (<span class="fu">+</span>) fibs (tail fibs)</a></code></pre></div>
<p>Or, in my favourite version:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">fib n <span class="fu">=</span> fix ((<span class="fu">:</span>) <span class="dv">0</span> <span class="fu">.</span> scanl (<span class="fu">+</span>) <span class="dv">1</span>) <span class="fu">!!</span> n</a></code></pre></div>
<a href="#fnref1" class="footnote-back">â†©</a></li>
</ol>
</section>
]]></description>
    <pubDate>Tue, 20 Mar 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-03-20-countdown.html</guid>
    <dc:creator>Donnacha OisÃ­n Kidney</dc:creator>
</item>
<item>
    <title>Rose Trees, Breadth-First</title>
    <link>https://doisinkidney.com/posts/2018-03-17-rose-trees-breadth-first.html</link>
    <description><![CDATA[<div class="info">
    Posted on March 17, 2018
</div>
<div class="info">
    
        Part 1 of a <a href="/series/Breadth-First%20Traversals.html">5-part series on Breadth-First Traversals</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<p>In contrast to the more common binary trees, in a rose tree every node can have any number of children.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Node</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">    {<span class="ot"> root   ::</span> a</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">    ,<span class="ot"> forest ::</span> <span class="dt">Forest</span> a</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">    }</a>
<a class="sourceLine" id="cb1-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="kw">type</span> <span class="dt">Forest</span> a <span class="fu">=</span> [<span class="dt">Tree</span> a]</a></code></pre></div>
<p>One of the important manipulations of this data structure, which forms the basis for several other algorithms, is a breadth-first traversal. Iâ€™d like to go through a couple of techniques for implementing it, and how more generally you can often get away with using much simpler data structures if you really pinpoint the API you need from them.</p>
<p>As a general technique, <span class="citation" data-cites="okasaki_breadth-first_2000">Okasaki (<a href="#ref-okasaki_breadth-first_2000">2000</a>)</span> advises that a queue be used:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">breadthFirst ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">breadthFirst tr <span class="fu">=</span> go (singleton tr)</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">    go q <span class="fu">=</span> <span class="kw">case</span> pop q <span class="kw">of</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5">      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> []</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">      <span class="dt">Just</span> (<span class="dt">Node</span> x xs,qs) <span class="ot">-&gt;</span> x <span class="fu">:</span> go (qs <span class="ot">`append`</span> xs)</a></code></pre></div>
<p>There are three functions left undefined there: <code class="sourceCode haskell">singleton</code>, <code class="sourceCode haskell">pop</code>, and <code class="sourceCode haskell">append</code>. They represent the API of our as-of-yet unimplemented queue, and their complexity will dictate the complexity of the overall algorithm. As a (bad) first choice, we could use simple lists, with the functions defined thus:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1">singleton x <span class="fu">=</span> [x]</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">pop (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="dt">Just</span> (x,xs)</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">pop [] <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">append <span class="fu">=</span> (<span class="fu">++</span>)</a></code></pre></div>
<p>Those repeated appends are bad news. The queue needs to be able to support popping from one side and appending from the other, which is something lists absolutely <em>cannot</em> do well.</p>
<p>We could swap in a more general queue implementation, possibly using Data.Sequence, or a pair of lists. But these are more complex and general than we need, so letâ€™s try and pare down the requirements a little more.</p>
<p>First, we donâ€™t need a pop: the go function can be expressed as a fold instead. Second, we donâ€™t need <em>every</em> append to be immediately stuck into the queue, we can batch them, first appending to a structure thatâ€™s efficient for appends, and then converting that to a structure which is efficient for folds. In code:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">breadthFirst ::</span> <span class="dt">Forest</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">breadthFirst ts <span class="fu">=</span> foldr f b ts []</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">    f (<span class="dt">Node</span> x xs) fw bw <span class="fu">=</span> x <span class="fu">:</span> fw (xs <span class="fu">:</span> bw)</a>
<a class="sourceLine" id="cb4-5" data-line-number="5"></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">    b [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb4-7" data-line-number="7">    b qs <span class="fu">=</span> foldl (foldr f) b qs []</a></code></pre></div>
<p>Weâ€™re consing instead of appending, but the consumption is being done in the correct direction anyway, because of the <code class="sourceCode haskell">foldl</code>.</p>
<h2 id="levels">Levels</h2>
<p>So next step: to get the <code class="sourceCode haskell">levels</code> function from Data.Tree. Instead of doing a breadth-first traversal, it returns the nodes at each <em>level</em> of the tree. Conceptually, every time we did the reverse above (called <code class="sourceCode haskell">foldl</code>), we will do a cons as well:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">levels ::</span> <span class="dt">Forest</span> a <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">levels ts <span class="fu">=</span> foldl f b ts [] []</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">    f k (<span class="dt">Node</span> x xs) ls qs <span class="fu">=</span> k (x <span class="fu">:</span> ls) (xs <span class="fu">:</span> qs)</a>
<a class="sourceLine" id="cb5-5" data-line-number="5"></a>
<a class="sourceLine" id="cb5-6" data-line-number="6">    b _ [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb5-7" data-line-number="7">    b k qs <span class="fu">=</span> k <span class="fu">:</span> foldl (foldl f) b qs [] []</a></code></pre></div>
<h2 id="unfolding">Unfolding</h2>
<p>The original reason I started work on these problems was <a href="https://github.com/haskell/containers/issues/124">this</a> issue in containers. It concerns the <a href="https://hackage.haskell.org/package/containers-0.5.11.0/docs/Data-Tree.html#v:unfoldTreeM_BF"><code>unfoldTreeM_BF</code></a> function. An early go at rewriting it, inspired by levels above, looks like this:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">unfoldForestM_BF ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (b <span class="ot">-&gt;</span> m (a, [b])) <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> m (<span class="dt">Forest</span> a)</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">unfoldForestM_BF f ts <span class="fu">=</span> b [ts] (const id)</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">    b [] k <span class="fu">=</span> pure (k [] [])</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">    b qs k <span class="fu">=</span> foldl (foldr t) b qs [] (\x <span class="ot">-&gt;</span> k [] <span class="fu">.</span> foldr (uncurry run) id x)</a>
<a class="sourceLine" id="cb6-6" data-line-number="6"></a>
<a class="sourceLine" id="cb6-7" data-line-number="7">    t a fw bw k <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">        (x,cs) <span class="ot">&lt;-</span> f a</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">        <span class="kw">let</span> <span class="fu">!</span>n <span class="fu">=</span> length cs</a>
<a class="sourceLine" id="cb6-10" data-line-number="10">        fw (cs <span class="fu">:</span> bw) (k <span class="fu">.</span> (<span class="fu">:</span>) (x, n))</a>
<a class="sourceLine" id="cb6-11" data-line-number="11"></a>
<a class="sourceLine" id="cb6-12" data-line-number="12">    run x n xs ys <span class="fu">=</span></a>
<a class="sourceLine" id="cb6-13" data-line-number="13">      <span class="kw">case</span> splitAt n ys <span class="kw">of</span></a>
<a class="sourceLine" id="cb6-14" data-line-number="14">          (cs,zs) <span class="ot">-&gt;</span> <span class="dt">Node</span> x cs <span class="fu">:</span> xs zs</a></code></pre></div>
<p>It basically performs the same this as the levels function, but builds the tree back up in the end using the <code class="sourceCode haskell">run</code> function. In order to do that, we store the length of each subforest on line 9, so that each node knows how much to take from each level.</p>
<p>A possible optimization is to stop taking the length. Anything in list processing that takes a length screams â€œwrongâ€ to me (although itâ€™s not always true!) so I often try to find a way to avoid it. The first option would be to keep the <code class="sourceCode haskell">cs</code> on line 8 around, and use <em>it</em> as an indicator for the length. That keeps it around longer than strictly necessary, though. The other option is to add a third level: for <code class="sourceCode haskell">breadthFirst</code> above, we had one level; for <code class="sourceCode haskell">levels</code>, we added another, to indicate the structure of the nodes and their subtrees; here, we can add a third, to maintain that structure when building back up:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">unfoldForestM_BF ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (b <span class="ot">-&gt;</span> m (a, [b])) <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> m (<span class="dt">Forest</span> a)</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">unfoldForestM_BF f ts <span class="fu">=</span> b [ts] (\ls <span class="ot">-&gt;</span> concat <span class="fu">.</span> ls)</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">    b [] k <span class="fu">=</span> pure (k id [])</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">    b qs k <span class="fu">=</span> foldl g b qs [] (\ls <span class="ot">-&gt;</span> k id <span class="fu">.</span> ls)</a>
<a class="sourceLine" id="cb7-6" data-line-number="6"></a>
<a class="sourceLine" id="cb7-7" data-line-number="7">    g a xs qs k <span class="fu">=</span> foldr t (\ls ys <span class="ot">-&gt;</span> a ys (k <span class="fu">.</span> run ls)) xs [] qs</a>
<a class="sourceLine" id="cb7-8" data-line-number="8"></a>
<a class="sourceLine" id="cb7-9" data-line-number="9">    t a fw xs bw <span class="fu">=</span> f a <span class="fu">&gt;&gt;=</span> \(x,cs) <span class="ot">-&gt;</span> fw (x<span class="fu">:</span>xs) (cs<span class="fu">:</span>bw)</a>
<a class="sourceLine" id="cb7-10" data-line-number="10"></a>
<a class="sourceLine" id="cb7-11" data-line-number="11">    run x xs <span class="fu">=</span> uncurry (<span class="fu">:</span>) <span class="fu">.</span> foldl go ((,) [] <span class="fu">.</span> xs) x</a>
<a class="sourceLine" id="cb7-12" data-line-number="12">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-13" data-line-number="13">        go ys y (z<span class="fu">:</span>zs) <span class="fu">=</span> (<span class="dt">Node</span> y z <span class="fu">:</span> ys&#39;, zs&#39;)</a>
<a class="sourceLine" id="cb7-14" data-line-number="14">          <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-15" data-line-number="15">            (ys&#39;,zs&#39;) <span class="fu">=</span> ys zs</a></code></pre></div>
<p>This unfortunately <em>slows down</em> the code.</p>
<div id="refs" class="references">
<div id="ref-okasaki_breadth-first_2000">
<p>Okasaki, Chris. 2000. â€œBreadth-first Numbering: Lessons from a Small Exercise in Algorithm Design.â€ In <em>Proceedings of the Fifth ACM SIGPLAN International Conference on Functional Programming</em>, 131â€“136. ICFP â€™00. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/351240.351253">10.1145/351240.351253</a>. <a href="https://www.cs.tufts.edu/~nr/cs257/archive/chris-okasaki/breadth-first.pdf" class="uri">https://www.cs.tufts.edu/~nr/cs257/archive/chris-okasaki/breadth-first.pdf</a>.</p>
</div>
</div>
]]></description>
    <pubDate>Sat, 17 Mar 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-03-17-rose-trees-breadth-first.html</guid>
    <dc:creator>Donnacha OisÃ­n Kidney</dc:creator>
</item>
<item>
    <title>Single-Pass Huffman Coding</title>
    <link>https://doisinkidney.com/posts/2018-02-17-single-pass-huffman.html</link>
    <description><![CDATA[<div class="info">
    Posted on February 17, 2018
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Folds.html">Folds</a>
    
</div>

<p>While working on something else, I figured out a nice Haskell implementation of Huffman coding, and I thought Iâ€™d share it here. Iâ€™ll go through a few techniques for transforming a multi-pass algorithm into a single-pass one first, and then Iâ€™ll show how to use them for Huffman. If you just want to skip to the code, itâ€™s provided at the end.<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a></p>
<p>The algorithm isnâ€™t single-pass in the sense of <a href="https://www2.cs.duke.edu/csed/curious/compression/adaptivehuff.html">Adaptive Huffman Coding</a>: it still uses the normal Huffman algorithm, but the input is transformed in the same traversal that builds the tree to transform it.</p>
<h2 id="circular-programming">Circular Programming</h2>
<p>There are several techniques for turning multi-pass algorithms into single-pass ones in functional languages. Perhaps the most famous is circular programming: using <em>laziness</em> to eliminate a pass. <span class="citation" data-cites="bird_using_1984">Bird (<a href="#ref-bird_using_1984">1984</a>)</span> used this to great effect in solving the repmin problem:</p>
<blockquote>
<p>Given a tree of integers, replace every integer with the minimum integer in the tree, in one pass.</p>
</blockquote>
<p>For an imperative programmer, the problem is relatively easy: first, write the code to find the minimum value in the tree in the standard way, using a loop and a â€œsmallest so farâ€ accumulator. Then, inside the loop, after updating the accumulator, set the value of the leaf to be a <em>reference</em> to the accumulator.</p>
<p>At first, that solution may seem necessarily impure: weâ€™re using global, mutable state to update many things at once. However, as the paper shows, we can claw back purity using laziness:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a <span class="fu">=</span> <span class="dt">Leaf</span> a <span class="fu">|</span> <span class="dt">Tree</span> a <span class="fu">:*:</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb2-2" data-line-number="2"></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="ot">repMin ::</span> <span class="dt">Tree</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Tree</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">repMin xs <span class="fu">=</span> ys <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5">  (m, ys) <span class="fu">=</span> go xs</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">  go (<span class="dt">Leaf</span> x) <span class="fu">=</span> (x, <span class="dt">Leaf</span> m)</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">  go (xs <span class="fu">:*:</span> ys) <span class="fu">=</span> (min x y, xs&#39; <span class="fu">:*:</span> ys&#39;)</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9">      (x,xs&#39;) <span class="fu">=</span> go xs</a>
<a class="sourceLine" id="cb2-10" data-line-number="10">      (y,ys&#39;) <span class="fu">=</span> go ys</a></code></pre></div>
<h2 id="there-and-back-again">There and Back Again</h2>
<p>Letâ€™s say we donâ€™t have laziness at our disposal: are we hosed? No!<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a> <span class="citation" data-cites="danvy_there_2005">Danvy and Goldberg (<a href="#ref-danvy_there_2005">2005</a>)</span> explore this very issue, by posing the question:</p>
<blockquote>
<p>Given two lists, xs and ys, can you zip xs with the reverse of ys in one pass?</p>
</blockquote>
<p>The technique used to solve the problem is named â€œThere and Back Againâ€; it should be clear why from one of the solutions:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1">convolve xs ys <span class="fu">=</span> walk xs const <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  walk [] k <span class="fu">=</span> k [] ys</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">  walk (x<span class="fu">:</span>xs) k <span class="fu">=</span> walk xs (\r (y<span class="fu">:</span>ys) <span class="ot">-&gt;</span> k ((x,y) <span class="fu">:</span> r) ys)</a></code></pre></div>
<p>The traversal of one list builds up the function to consume the other. We could write repmin in the same way:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">repMin <span class="fu">=</span> uncurry (<span class="fu">$</span>) <span class="fu">.</span> go <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  go (<span class="dt">Leaf</span> x) <span class="fu">=</span> (<span class="dt">Leaf</span>, x)</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  go (xs <span class="fu">:*:</span> ys) <span class="fu">=</span> (\m <span class="ot">-&gt;</span> xs&#39; m <span class="fu">:*:</span> ys&#39; m, min xm ym) <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">    (xs&#39;,xm) <span class="fu">=</span> go xs</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">    (ys&#39;,ym) <span class="fu">=</span> go ys</a></code></pre></div>
<h2 id="cayley-representations">Cayley Representations</h2>
<p>If youâ€™re doing a lot of appending to some list-like structure, you probably donâ€™t want to use actual lists: youâ€™ll end up traversing the left-hand-side of the append many more times than necessary. A type you can drop in to use instead is difference lists <span class="citation" data-cites="hughes_novel_1986">(Hughes <a href="#ref-hughes_novel_1986">1986</a>)</span>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">type</span> <span class="dt">DList</span> a <span class="fu">=</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb5-2" data-line-number="2"></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="ot">rep ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">DList</span> a</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">rep <span class="fu">=</span> (<span class="fu">++</span>)</a>
<a class="sourceLine" id="cb5-5" data-line-number="5"></a>
<a class="sourceLine" id="cb5-6" data-line-number="6">abs<span class="ot"> ::</span> <span class="dt">DList</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb5-7" data-line-number="7">abs xs <span class="fu">=</span> xs []</a>
<a class="sourceLine" id="cb5-8" data-line-number="8"></a>
<a class="sourceLine" id="cb5-9" data-line-number="9"><span class="ot">append ::</span> <span class="dt">DList</span> a <span class="ot">-&gt;</span> <span class="dt">DList</span> a <span class="ot">-&gt;</span> <span class="dt">DList</span> a</a>
<a class="sourceLine" id="cb5-10" data-line-number="10">append <span class="fu">=</span> (<span class="fu">.</span>)</a></code></pre></div>
<p><code class="sourceCode haskell">append</code> is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math> in this representation. In fact, for any monoid with a slow <code class="sourceCode haskell">mappend</code>, you can use the same trick: itâ€™s called the Cayley representation, and available as <code class="sourceCode haskell"><span class="dt">Endo</span></code> in <a href="https://hackage.haskell.org/package/base-4.10.1.0/docs/Data-Monoid.html#t:Endo">Data.Monoid</a>.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">rep ::</span> <span class="dt">Monoid</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Endo</span> a</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">rep x <span class="fu">=</span> <span class="dt">Endo</span> (mappend x)</a>
<a class="sourceLine" id="cb6-3" data-line-number="3"></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">abs<span class="ot"> ::</span> <span class="dt">Monoid</span> a <span class="ot">=&gt;</span> <span class="dt">Endo</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">abs (<span class="dt">Endo</span> f) <span class="fu">=</span> f mempty</a>
<a class="sourceLine" id="cb6-6" data-line-number="6"></a>
<a class="sourceLine" id="cb6-7" data-line-number="7"><span class="kw">instance</span> <span class="dt">Monoid</span> (<span class="dt">Endo</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">  mempty <span class="fu">=</span> <span class="dt">Endo</span> id</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">  mappend (<span class="dt">Endo</span> f) (<span class="dt">Endo</span> g) <span class="fu">=</span> <span class="dt">Enfo</span> (f <span class="fu">.</span> g)</a></code></pre></div>
<p>You can actually do the same transformation for â€œmonoidsâ€ in the categorical sense: applying it to monads, for instance, will give you codensity <span class="citation" data-cites="rivas_notions_2014">(Rivas and Jaskelioff <a href="#ref-rivas_notions_2014">2014</a>)</span>.</p>
<h2 id="traversable">Traversable</h2>
<p>Looking backâ€”just for a secondâ€”to the repmin example, we should be able to spot a pattern we can generalize. Thereâ€™s really nothing tree-specific about it, so why canâ€™t we apply it to lists? Or other structures, for that matter? It turns out we can: the <code class="sourceCode haskell">mapAccumL</code> function is tailor-made to this need:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">repMin ::</span> <span class="dt">Traversable</span> t <span class="ot">=&gt;</span> t <span class="dt">Integer</span> <span class="ot">-&gt;</span> t <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">repMin xs <span class="fu">=</span> ys <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  (<span class="fu">~</span>(<span class="dt">Just</span> m), ys) <span class="fu">=</span> mapAccumL f <span class="dt">Nothing</span> xs</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">  f <span class="dt">Nothing</span> x <span class="fu">=</span> (<span class="dt">Just</span> x, m)</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">  f (<span class="dt">Just</span> y) x <span class="fu">=</span> (<span class="dt">Just</span> (min x y), m)</a></code></pre></div>
<p>The tilde before the <code class="sourceCode haskell"><span class="dt">Just</span></code> ensures this wonâ€™t fail on empty input.</p>
<h1 id="huffman-coding">Huffman Coding</h1>
<p>Finally, itâ€™s time for the main event. Huffman coding is a <em>very</em> multi-pass algorithm, usually. The steps look like this:</p>
<ol type="1">
<li>Build a frequency table for each character in the input.</li>
<li>Build a priority queue from that frequency table.</li>
<li>Iteratively pop elements and combine them (into Huffman trees) from the queue until thereâ€™s only one left.</li>
<li>That Huffman tree can be used to construct the mapping from items back to their Huffman codes.</li>
<li>Traverse the input again, using the constructed mapping to replace elements with their codes.</li>
</ol>
<p>We canâ€™t <em>skip</em> any of these steps: we can try perform them all at once, though.</p>
<p>Letâ€™s write the multi-pass version first. Weâ€™ll need the frequency table:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">frequencies ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Map</span> a <span class="dt">Int</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">frequencies <span class="fu">=</span> Map.fromListWith (<span class="fu">+</span>) <span class="fu">.</span> map (flip (,) <span class="dv">1</span>)</a></code></pre></div>
<p>And a heap, ordered on the frequencies of its elements (Iâ€™m using a skew heap here):</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Heap</span> a</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  <span class="fu">|</span> <span class="dt">Node</span> <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">Int</span> a (<span class="dt">Heap</span> a) (<span class="dt">Heap</span> a)</a>
<a class="sourceLine" id="cb9-4" data-line-number="4"></a>
<a class="sourceLine" id="cb9-5" data-line-number="5"><span class="kw">instance</span> <span class="dt">Monoid</span> (<span class="dt">Heap</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6">  mappend <span class="dt">Nil</span> ys <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">  mappend xs <span class="dt">Nil</span> <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb9-8" data-line-number="8">  mappend h1<span class="fu">@</span>(<span class="dt">Node</span> i x lx rx) h2<span class="fu">@</span>(<span class="dt">Node</span> j y ly ry)</a>
<a class="sourceLine" id="cb9-9" data-line-number="9">    <span class="fu">|</span> i <span class="fu">&lt;=</span> j    <span class="fu">=</span> <span class="dt">Node</span> i x (mappend h2 rx) lx</a>
<a class="sourceLine" id="cb9-10" data-line-number="10">    <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Node</span> j y (mappend h1 ry) ly</a>
<a class="sourceLine" id="cb9-11" data-line-number="11">  mempty <span class="fu">=</span> <span class="dt">Nil</span></a></code></pre></div>
<p>Next, we need to build the tree<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>. We can use the tree type from above.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">buildTree ::</span> <span class="dt">Map</span> a <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Tree</span> a)</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">buildTree <span class="fu">=</span> prune <span class="fu">.</span> toHeap <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  toHeap <span class="fu">=</span> Map.foldMapWithKey (\k v <span class="ot">-&gt;</span> <span class="dt">Node</span> v (<span class="dt">Leaf</span> k) <span class="dt">Nil</span> <span class="dt">Nil</span>)</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">  prune <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb10-5" data-line-number="5">  prune (<span class="dt">Node</span> i x l r) <span class="fu">=</span> <span class="kw">case</span> mappend l r <span class="kw">of</span></a>
<a class="sourceLine" id="cb10-6" data-line-number="6">    <span class="dt">Nil</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> x</a>
<a class="sourceLine" id="cb10-7" data-line-number="7">    <span class="dt">Node</span> j y l&#39; r&#39; <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb10-8" data-line-number="8">      prune (mappend (<span class="dt">Node</span> (i<span class="fu">+</span>j) (x <span class="fu">:*:</span> y) <span class="dt">Nil</span> <span class="dt">Nil</span>) (mappend l&#39; r&#39;))</a></code></pre></div>
<p>Then, a way to convert between the tree and a map:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">toMapping ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Map</span> a [<span class="dt">Bool</span>]</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">toMapping (<span class="dt">Leaf</span> x) <span class="fu">=</span> Map.singleton x []</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">toMapping (xs <span class="fu">:*:</span> ys) <span class="fu">=</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4">    Map.union (fmap (<span class="dt">True</span><span class="fu">:</span>) (toMapping xs)) (fmap (<span class="dt">False</span><span class="fu">:</span>) (toMapping ys))</a></code></pre></div>
<p>And finally, putting the whole thing together:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="ot">huffman ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> (<span class="dt">Maybe</span> (<span class="dt">Tree</span> a), [[<span class="dt">Bool</span>]])</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">huffman xs <span class="fu">=</span> (tree, map (mapb <span class="fu">Map.!</span>) xs) <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">  freq <span class="fu">=</span> frequencies xs</a>
<a class="sourceLine" id="cb12-4" data-line-number="4">  tree <span class="fu">=</span> buildTree freq</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">  mapb <span class="fu">=</span> maybe Map.empty toMapping tree</a></code></pre></div>
<h2 id="removing-the-passes">Removing the passes</h2>
<p>The first thing to fix is the <code class="sourceCode haskell">toMapping</code> function: at every level, it calls <code class="sourceCode haskell">union</code>, a complex and expensive operation. However, <code class="sourceCode haskell">union</code> and <code class="sourceCode haskell">empty</code> form a monoid, so we can use the Cayley representation to reduce the calls to a minimum. Next, we want to get rid of the <code class="sourceCode haskell">fmap</code>s: we can do that by assembling a function to perform the <code class="sourceCode haskell">fmap</code> as we go, as in <code class="sourceCode haskell">convolve</code><a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a>.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="ot">toMapping ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Map</span> a [<span class="dt">Bool</span>]</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">toMapping tree <span class="fu">=</span> go tree id Map.empty <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">  go (<span class="dt">Leaf</span> x) k <span class="fu">=</span> Map.insert x (k [])</a>
<a class="sourceLine" id="cb13-4" data-line-number="4">  go (xs <span class="fu">:*:</span> ys) k <span class="fu">=</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5">    go xs (k <span class="fu">.</span> (<span class="fu">:</span>) <span class="dt">True</span>) <span class="fu">.</span> go ys (k <span class="fu">.</span> (<span class="fu">:</span>) <span class="dt">False</span>)</a></code></pre></div>
<p>Secondly, we can integrate the <code class="sourceCode haskell">toMapping</code> function with the <code class="sourceCode haskell">buildTree</code> function, removing another pass:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="ot">buildTree ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Map</span> a <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Tree</span> a, <span class="dt">Map</span> a [<span class="dt">Bool</span>])</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">buildTree <span class="fu">=</span> prune <span class="fu">.</span> toHeap <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3">  toHeap <span class="fu">=</span> Map.foldMapWithKey (\k v <span class="ot">-&gt;</span> <span class="dt">Node</span> v (<span class="dt">Leaf</span> k, leaf k) <span class="dt">Nil</span> <span class="dt">Nil</span>)</a>
<a class="sourceLine" id="cb14-4" data-line-number="4">  prune <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb14-5" data-line-number="5">  prune (<span class="dt">Node</span> i x l r) <span class="fu">=</span> <span class="kw">case</span> mappend l r <span class="kw">of</span></a>
<a class="sourceLine" id="cb14-6" data-line-number="6">    <span class="dt">Nil</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> (fmap (\k <span class="ot">-&gt;</span> k id Map.empty) x)</a>
<a class="sourceLine" id="cb14-7" data-line-number="7">    <span class="dt">Node</span> j y l&#39; r&#39; <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb14-8" data-line-number="8">      prune (mappend (<span class="dt">Node</span> (i<span class="fu">+</span>j) (cmb x y) <span class="dt">Nil</span> <span class="dt">Nil</span>) (mappend l&#39; r&#39;))</a>
<a class="sourceLine" id="cb14-9" data-line-number="9">  leaf x k <span class="fu">=</span> Map.insert x (k [])</a>
<a class="sourceLine" id="cb14-10" data-line-number="10">  node xs ys k <span class="fu">=</span> xs (k <span class="fu">.</span> (<span class="fu">:</span>) <span class="dt">True</span>) <span class="fu">.</span> ys (k <span class="fu">.</span> (<span class="fu">:</span>) <span class="dt">False</span>)</a>
<a class="sourceLine" id="cb14-11" data-line-number="11">  cmb (xt,xm) (yt,ym) <span class="fu">=</span> (xt <span class="fu">:*:</span> yt, node xm ym)</a></code></pre></div>
<p>Finally, to remove the second pass over the list, we can copy repmin, using <code class="sourceCode haskell">mapAccumL</code> to both construct the mapping and apply it to the structure in one go.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="ot">huffman ::</span> (<span class="dt">Ord</span> a, <span class="dt">Traversable</span> t) <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> (<span class="dt">Maybe</span> (<span class="dt">Tree</span> a), t [<span class="dt">Bool</span>])</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">huffman xs <span class="fu">=</span> (fmap fst tree, ys) <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-3" data-line-number="3">  (freq,ys) <span class="fu">=</span> mapAccumL f Map.empty xs</a>
<a class="sourceLine" id="cb15-4" data-line-number="4">  f fm x <span class="fu">=</span> (Map.insertWith (<span class="fu">+</span>) x <span class="dv">1</span> fm, mapb <span class="fu">Map.!</span> x)</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">  tree <span class="fu">=</span> buildTree freq</a>
<a class="sourceLine" id="cb15-6" data-line-number="6">  mapb <span class="fu">=</span> maybe Map.empty snd tree</a></code></pre></div>
<p>And thatâ€™s it!</p>
<h1 id="generalization">Generalization</h1>
<p>The similarity between the repmin function and the solution above is suggestive: is there a way to <em>encode</em> this idea of making a multi-pass algorithm single-pass? Of course! We can use an applicative:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Circular</span> a b c <span class="fu">=</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2">    <span class="dt">Circular</span> <span class="fu">!</span>a</a>
<a class="sourceLine" id="cb16-3" data-line-number="3">             (b <span class="ot">-&gt;</span> c)</a>
<a class="sourceLine" id="cb16-4" data-line-number="4"></a>
<a class="sourceLine" id="cb16-5" data-line-number="5"><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Circular</span> a b) <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-6" data-line-number="6">    fmap f (<span class="dt">Circular</span> tally run) <span class="fu">=</span> <span class="dt">Circular</span> tally (f <span class="fu">.</span> run)</a>
<a class="sourceLine" id="cb16-7" data-line-number="7"></a>
<a class="sourceLine" id="cb16-8" data-line-number="8"><span class="kw">instance</span> <span class="dt">Monoid</span> a <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb16-9" data-line-number="9">         <span class="dt">Applicative</span> (<span class="dt">Circular</span> a b) <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-10" data-line-number="10">    pure x <span class="fu">=</span> <span class="dt">Circular</span> mempty (const x)</a>
<a class="sourceLine" id="cb16-11" data-line-number="11">    <span class="dt">Circular</span> fl fr <span class="fu">&lt;*&gt;</span> <span class="dt">Circular</span> xl xr <span class="fu">=</span></a>
<a class="sourceLine" id="cb16-12" data-line-number="12">        <span class="dt">Circular</span></a>
<a class="sourceLine" id="cb16-13" data-line-number="13">            (mappend fl xl)</a>
<a class="sourceLine" id="cb16-14" data-line-number="14">            (\r <span class="ot">-&gt;</span> fr r (xr r))</a>
<a class="sourceLine" id="cb16-15" data-line-number="15"></a>
<a class="sourceLine" id="cb16-16" data-line-number="16">liftHuffman</a>
<a class="sourceLine" id="cb16-17" data-line-number="17"><span class="ot">    ::</span> <span class="dt">Ord</span> a</a>
<a class="sourceLine" id="cb16-18" data-line-number="18">    <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Circular</span> (<span class="dt">Map</span> a <span class="dt">Int</span>) (<span class="dt">Map</span> a [<span class="dt">Bool</span>]) [<span class="dt">Bool</span>]</a>
<a class="sourceLine" id="cb16-19" data-line-number="19">liftHuffman x <span class="fu">=</span> <span class="dt">Circular</span> (Map.singleton x <span class="dv">1</span>) (<span class="fu">Map.!</span> x)</a>
<a class="sourceLine" id="cb16-20" data-line-number="20"></a>
<a class="sourceLine" id="cb16-21" data-line-number="21">runHuffman</a>
<a class="sourceLine" id="cb16-22" data-line-number="22"><span class="ot">    ::</span> <span class="dt">Ord</span> a</a>
<a class="sourceLine" id="cb16-23" data-line-number="23">    <span class="ot">=&gt;</span> <span class="dt">Circular</span> (<span class="dt">Map</span> a <span class="dt">Int</span>) (<span class="dt">Map</span> a [<span class="dt">Bool</span>]) r <span class="ot">-&gt;</span> (<span class="dt">Maybe</span> (<span class="dt">Tree</span> a), r)</a>
<a class="sourceLine" id="cb16-24" data-line-number="24">runHuffman (<span class="dt">Circular</span> smry run) <span class="fu">=</span></a>
<a class="sourceLine" id="cb16-25" data-line-number="25">    maybe (<span class="dt">Nothing</span>, run Map.empty) (<span class="dt">Just</span> <span class="fu">***</span> run) (buildTree smry)</a>
<a class="sourceLine" id="cb16-26" data-line-number="26"></a>
<a class="sourceLine" id="cb16-27" data-line-number="27">huffman</a>
<a class="sourceLine" id="cb16-28" data-line-number="28"><span class="ot">    ::</span> (<span class="dt">Ord</span> a, <span class="dt">Traversable</span> t)</a>
<a class="sourceLine" id="cb16-29" data-line-number="29">    <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> (<span class="dt">Maybe</span> (<span class="dt">Tree</span> a), t [<span class="dt">Bool</span>])</a>
<a class="sourceLine" id="cb16-30" data-line-number="30">huffman <span class="fu">=</span> runHuffman <span class="fu">.</span> traverse liftHuffman</a></code></pre></div>
<p>Thanks to it being an applicative, you can do all the fun lensy things with it:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="ot">showBin ::</span> [<span class="dt">Bool</span>] <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2">showBin <span class="fu">=</span> map (bool <span class="ch">&#39;0&#39;</span> <span class="ch">&#39;1&#39;</span>)</a>
<a class="sourceLine" id="cb17-3" data-line-number="3"></a>
<a class="sourceLine" id="cb17-4" data-line-number="4"><span class="fu">&gt;&gt;&gt;</span> <span class="kw">let</span> liftBin <span class="fu">=</span> fmap showBin <span class="fu">.</span> liftHuffman</a>
<a class="sourceLine" id="cb17-5" data-line-number="5"><span class="fu">&gt;&gt;&gt;</span> (snd <span class="fu">.</span> runHuffman <span class="fu">.</span> (each<span class="fu">.</span>traverse) liftBin) (<span class="st">&quot;abb&quot;</span>, <span class="st">&quot;cad&quot;</span>, <span class="st">&quot;c&quot;</span>)</a>
<a class="sourceLine" id="cb17-6" data-line-number="6">([<span class="st">&quot;01&quot;</span>,<span class="st">&quot;11&quot;</span>,<span class="st">&quot;11&quot;</span>],[<span class="st">&quot;00&quot;</span>,<span class="st">&quot;01&quot;</span>,<span class="st">&quot;10&quot;</span>],[<span class="st">&quot;00&quot;</span>])</a></code></pre></div>
<p>Bringing us back to the start, it can also let us solve repmin!</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="ot">liftRepMin ::</span> a <span class="ot">-&gt;</span> <span class="dt">Circular</span> (<span class="dt">Option</span> (<span class="dt">Min</span> a)) a a</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">liftRepMin x <span class="fu">=</span> <span class="dt">Circular</span> (pure (pure x)) id</a>
<a class="sourceLine" id="cb18-3" data-line-number="3"></a>
<a class="sourceLine" id="cb18-4" data-line-number="4"><span class="ot">runRepMin ::</span> <span class="dt">Circular</span> (<span class="dt">Option</span> (<span class="dt">Min</span> a)) a b <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb18-5" data-line-number="5">runRepMin (<span class="dt">Circular</span> m r) <span class="fu">=</span> r (<span class="kw">case</span> m <span class="kw">of</span></a>
<a class="sourceLine" id="cb18-6" data-line-number="6">  <span class="dt">Option</span> (<span class="dt">Just</span> (<span class="dt">Min</span> x)) <span class="ot">-&gt;</span> x)</a>
<a class="sourceLine" id="cb18-7" data-line-number="7"></a>
<a class="sourceLine" id="cb18-8" data-line-number="8"><span class="ot">repMin ::</span> (<span class="dt">Ord</span> a, <span class="dt">Traversable</span> t) <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> t a</a>
<a class="sourceLine" id="cb18-9" data-line-number="9">repMin <span class="fu">=</span> runRepMin <span class="fu">.</span> traverse liftRepMin</a></code></pre></div>
<h1 id="related">Related</h1>
<p>So the <code class="sourceCode haskell"><span class="dt">Circular</span></code> type is actually just the product of reader and writer, and is closely related to the <a href="https://github.com/treeowl/sort-traversable">sort</a> type.</p>
<p>Itâ€™s also related to the <a href="https://www.reddit.com/r/haskell/comments/7qwzn4/an_update_about_the_store_monad_and_state_comonad/"><code class="sourceCode haskell"><span class="dt">Prescient</span></code></a> type, which I noticed after Iâ€™d written the above.</p>
<h1 id="references" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-bird_more_1997">
<p>Bird, Richard, Geraint Jones, and Oege De Moor. 1997. â€œMore hasteâ€š less speed: Lazy versus eager evaluation.â€ <em>Journal of Functional Programming</em> 7 (5) (September): 541â€“547. doi:<a href="https://doi.org/10.1017/S0956796897002827">10.1017/S0956796897002827</a>. <a href="https://ora.ox.ac.uk/objects/uuid:761a4646-60a2-4622-a1e0-ddea11507d57/datastreams/ATTACHMENT01" class="uri">https://ora.ox.ac.uk/objects/uuid:761a4646-60a2-4622-a1e0-ddea11507d57/datastreams/ATTACHMENT01</a>.</p>
</div>
<div id="ref-bird_using_1984">
<p>Bird, R. S. 1984. â€œUsing Circular Programs to Eliminate Multiple Traversals of Data.â€ <em>Acta Inf.</em> 21 (3) (October): 239â€“250. doi:<a href="https://doi.org/10.1007/BF00264249">10.1007/BF00264249</a>. <a href="http://dx.doi.org/10.1007/BF00264249" class="uri">http://dx.doi.org/10.1007/BF00264249</a>.</p>
</div>
<div id="ref-danvy_there_2005">
<p>Danvy, Olivier, and Mayer Goldberg. 2005. â€œThere and Back Again.â€ <a href="http://brics.dk/RS/05/3/BRICS-RS-05-3.pdf" class="uri">http://brics.dk/RS/05/3/BRICS-RS-05-3.pdf</a>.</p>
</div>
<div id="ref-hughes_novel_1986">
<p>Hughes, R. John Muir. 1986. â€œA Novel Representation of Lists and Its Application to the Function &quot;Reverse&quot;.â€ <em>Information Processing Letters</em> 22 (3) (March): 141â€“144. doi:<a href="https://doi.org/10.1016/0020-0190(86)90059-1">10.1016/0020-0190(86)90059-1</a>. <a href="http://www.sciencedirect.com/science/article/pii/0020019086900591" class="uri">http://www.sciencedirect.com/science/article/pii/0020019086900591</a>.</p>
</div>
<div id="ref-pippenger_pure_1997">
<p>Pippenger, Nicholas. 1997. â€œPure Versus Impure Lisp.â€ <em>ACM Trans. Program. Lang. Syst.</em> 19 (2) (March): 223â€“238. doi:<a href="https://doi.org/10.1145/244795.244798">10.1145/244795.244798</a>. <a href="http://doi.acm.org/10.1145/244795.244798" class="uri">http://doi.acm.org/10.1145/244795.244798</a>.</p>
</div>
<div id="ref-rivas_notions_2014">
<p>Rivas, Exequiel, and Mauro Jaskelioff. 2014. â€œNotions of Computation as Monoids.â€ <em>arXiv:1406.4823 [cs, math]</em> (May). <a href="http://arxiv.org/abs/1406.4823" class="uri">http://arxiv.org/abs/1406.4823</a>.</p>
</div>
</div>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Huffman coding single-pass implementation:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">import</span>           <span class="dt">Data.Map.Strict</span>  (<span class="dt">Map</span>)</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map.Strict</span>  <span class="kw">as</span> <span class="dt">Map</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">import</span>           <span class="dt">Data.Traversable</span> (mapAccumL)</a>
<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="kw">data</span> <span class="dt">Heap</span> a</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">  <span class="fu">=</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">  <span class="fu">|</span> <span class="dt">Node</span> <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">Int</span> a (<span class="dt">Heap</span> a) (<span class="dt">Heap</span> a)</a>
<a class="sourceLine" id="cb1-8" data-line-number="8"></a>
<a class="sourceLine" id="cb1-9" data-line-number="9"><span class="kw">instance</span> <span class="dt">Monoid</span> (<span class="dt">Heap</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10">  mappend <span class="dt">Nil</span> ys <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb1-11" data-line-number="11">  mappend xs <span class="dt">Nil</span> <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb1-12" data-line-number="12">  mappend h1<span class="fu">@</span>(<span class="dt">Node</span> i x lx rx) h2<span class="fu">@</span>(<span class="dt">Node</span> j y ly ry)</a>
<a class="sourceLine" id="cb1-13" data-line-number="13">    <span class="fu">|</span> i <span class="fu">&lt;=</span> j    <span class="fu">=</span> <span class="dt">Node</span> i x (mappend h2 rx) lx</a>
<a class="sourceLine" id="cb1-14" data-line-number="14">    <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Node</span> j y (mappend h1 ry) ly</a>
<a class="sourceLine" id="cb1-15" data-line-number="15">  mempty <span class="fu">=</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb1-16" data-line-number="16"></a>
<a class="sourceLine" id="cb1-17" data-line-number="17"><span class="kw">data</span> <span class="dt">Tree</span> a <span class="fu">=</span> <span class="dt">Leaf</span> a <span class="fu">|</span> <span class="dt">Tree</span> a <span class="fu">:*:</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb1-18" data-line-number="18"></a>
<a class="sourceLine" id="cb1-19" data-line-number="19"><span class="ot">buildTree ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Map</span> a <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Tree</span> a, <span class="dt">Map</span> a [<span class="dt">Bool</span>])</a>
<a class="sourceLine" id="cb1-20" data-line-number="20">buildTree <span class="fu">=</span> prune <span class="fu">.</span> toHeap <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-21" data-line-number="21">  toHeap <span class="fu">=</span> Map.foldMapWithKey (\k v <span class="ot">-&gt;</span> <span class="dt">Node</span> v (<span class="dt">Leaf</span> k, leaf k) <span class="dt">Nil</span> <span class="dt">Nil</span>)</a>
<a class="sourceLine" id="cb1-22" data-line-number="22">  prune <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb1-23" data-line-number="23">  prune (<span class="dt">Node</span> i x l r) <span class="fu">=</span> <span class="kw">case</span> mappend l r <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-24" data-line-number="24">    <span class="dt">Nil</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> (fmap (\k <span class="ot">-&gt;</span> k id Map.empty) x)</a>
<a class="sourceLine" id="cb1-25" data-line-number="25">    <span class="dt">Node</span> j y l&#39; r&#39; <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb1-26" data-line-number="26">      prune (mappend (<span class="dt">Node</span> (i<span class="fu">+</span>j) (cmb x y) <span class="dt">Nil</span> <span class="dt">Nil</span>) (mappend l&#39; r&#39;))</a>
<a class="sourceLine" id="cb1-27" data-line-number="27">  leaf x k <span class="fu">=</span> Map.insert x (k [])</a>
<a class="sourceLine" id="cb1-28" data-line-number="28">  node xs ys k <span class="fu">=</span> xs (k <span class="fu">.</span> (<span class="fu">:</span>) <span class="dt">True</span>) <span class="fu">.</span> ys (k <span class="fu">.</span> (<span class="fu">:</span>) <span class="dt">False</span>)</a>
<a class="sourceLine" id="cb1-29" data-line-number="29">  cmb (xt,xm) (yt,ym) <span class="fu">=</span> (xt <span class="fu">:*:</span> yt, node xm ym)</a>
<a class="sourceLine" id="cb1-30" data-line-number="30"></a>
<a class="sourceLine" id="cb1-31" data-line-number="31"><span class="ot">huffman ::</span> (<span class="dt">Ord</span> a, <span class="dt">Traversable</span> t) <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> (<span class="dt">Maybe</span> (<span class="dt">Tree</span> a), t [<span class="dt">Bool</span>])</a>
<a class="sourceLine" id="cb1-32" data-line-number="32">huffman xs <span class="fu">=</span> (fmap fst tree, ys) <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-33" data-line-number="33">  (freq,ys) <span class="fu">=</span> mapAccumL f Map.empty xs</a>
<a class="sourceLine" id="cb1-34" data-line-number="34">  f fm x <span class="fu">=</span> (Map.insertWith (<span class="fu">+</span>) x <span class="dv">1</span> fm, mapb <span class="fu">Map.!</span> x)</a>
<a class="sourceLine" id="cb1-35" data-line-number="35">  tree <span class="fu">=</span> buildTree freq</a>
<a class="sourceLine" id="cb1-36" data-line-number="36">  mapb <span class="fu">=</span> maybe Map.empty snd tree</a></code></pre></div>
<a href="#fnref1" class="footnote-back">â†©</a></li>
<li id="fn2"><p>Well, thatâ€™s a little bit of a lie. In terms of asympostics, <span class="citation" data-cites="pippenger_pure_1997">Pippenger (<a href="#ref-pippenger_pure_1997">1997</a>)</span> stated a problem that could be solved in linear time in impure Lisp, but <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Î©</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\Omega(n \log n)</annotation></semantics></math> in pure Lisp. <span class="citation" data-cites="bird_more_1997">Bird, Jones, and Moor (<a href="#ref-bird_more_1997">1997</a>)</span> then produced an algorithm that could solve the problem in linear time, by using laziness. So, in some cases, laziness will give you asymptotics you canâ€™t get without it (if you want to stay pure).<a href="#fnref2" class="footnote-back">â†©</a></p></li>
<li id="fn3"><p>Thereâ€™s actually a nicer version of the <code class="sourceCode haskell">buildTree</code> function which uses <code class="sourceCode haskell"><span class="dt">StateT</span> (<span class="dt">Heap</span> a) <span class="dt">Maybe</span></code>, but itâ€™s equivalent to this one under the hood, and I though might be a little distracting.<a href="#fnref3" class="footnote-back">â†©</a></p></li>
<li id="fn4"><p>Something to notice about this function is that itâ€™s going top-down and bottom-up at the same time. Combining the maps (with <code class="sourceCode haskell">(<span class="fu">.</span>)</code>) is done bottom-up, but building the codes is top-down. This means the codes are built in reverse order! Thatâ€™s why the accumulating parameter (<code class="sourceCode haskell">k</code>) is a difference list, rather than a normal list. As it happens, if normal lists were used, the function would be slightly more efficient through sharing, but the codes would all be reversed.<a href="#fnref4" class="footnote-back">â†©</a></p></li>
</ol>
</section>
]]></description>
    <pubDate>Sat, 17 Feb 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-02-17-single-pass-huffman.html</guid>
    <dc:creator>Donnacha OisÃ­n Kidney</dc:creator>
</item>
<item>
    <title>Monadic List Functions</title>
    <link>https://doisinkidney.com/posts/2018-02-11-monadic-list.functions.html</link>
    <description><![CDATA[<div class="info">
    Posted on February 11, 2018
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Applicative.html">Applicative</a>
    
</div>

<p>Hereâ€™s an old Haskell chestnut:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> filterM (\_ <span class="ot">-&gt;</span> [<span class="dt">False</span>, <span class="dt">True</span>]) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">[[],[<span class="dv">3</span>],[<span class="dv">2</span>],[<span class="dv">2</span>,<span class="dv">3</span>],[<span class="dv">1</span>],[<span class="dv">1</span>,<span class="dv">3</span>],[<span class="dv">1</span>,<span class="dv">2</span>],[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]]</a></code></pre></div>
<p><code class="sourceCode haskell">filterM (\_ <span class="ot">-&gt;</span> [<span class="dt">False</span>,<span class="dt">True</span>])</code> gives the power set of some input list. Itâ€™s one of the especially magical demonstrations of monads. From a high-level perspective, it makes sense: for each element in the list, we want it to be present in one output, and not present in another. Itâ€™s hard to see how it actually <em>works</em>, though. The (old<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>) <a href="https://hackage.haskell.org/package/base-4.7.0.0/docs/src/Control-Monad.html#filterM">source</a> for <code class="sourceCode haskell">filterM</code> doesnâ€™t help hugely, either:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">filterM          ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m [a]</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">filterM _ []     <span class="fu">=</span>  return []</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">filterM p (x<span class="fu">:</span>xs) <span class="fu">=</span>  <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">   flg <span class="ot">&lt;-</span> p x</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">   ys  <span class="ot">&lt;-</span> filterM p xs</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">   return (<span class="kw">if</span> flg <span class="kw">then</span> x<span class="fu">:</span>ys <span class="kw">else</span> ys)</a></code></pre></div>
<p>Again, elegant and beautiful (aside from the three-space indent), but opaque. Despite not really getting how it works, I was encouraged by its simplicity to try my hand at some of the other functions from Data.List.</p>
<h2 id="grouping">Grouping</h2>
<p>Letâ€™s start with the subject of my <a href="2018-01-07-groupBy.html">last post</a>. Hereâ€™s the implementation:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">groupBy ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">groupBy p xs <span class="fu">=</span> build (\c n <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">  <span class="kw">let</span> f x a q</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">        <span class="fu">|</span> q x <span class="fu">=</span> (x <span class="fu">:</span> ys, zs)</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">        <span class="fu">|</span> otherwise <span class="fu">=</span> ([], c (x <span class="fu">:</span> ys) zs)</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">        <span class="kw">where</span> (ys,zs) <span class="fu">=</span> a (p x)</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">  <span class="kw">in</span> snd (foldr f (const ([], n)) xs (const <span class="dt">False</span>)))</a></code></pre></div>
<p>It translates over pretty readily:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">groupByM ::</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> m <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m [[a]]</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">groupByM p xs <span class="fu">=</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  fmap snd (foldr f (const (pure ([], []))) xs (const (pure (<span class="dt">False</span>))))</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5">    f x a q <span class="fu">=</span> liftA2 st (q x) (a (p x)) <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">      st b (ys,zs)</a>
<a class="sourceLine" id="cb4-7" data-line-number="7">        <span class="fu">|</span> b <span class="fu">=</span> (x <span class="fu">:</span> ys, zs)</a>
<a class="sourceLine" id="cb4-8" data-line-number="8">        <span class="fu">|</span> otherwise <span class="fu">=</span> ([], (x<span class="fu">:</span>ys)<span class="fu">:</span>zs)</a></code></pre></div>
<p>Letâ€™s try it with a similar example to <code class="sourceCode haskell">filterM</code>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> groupByM (\_ _ <span class="ot">-&gt;</span> [<span class="dt">False</span>, <span class="dt">True</span>]) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">[[[<span class="dv">1</span>],[<span class="dv">2</span>],[<span class="dv">3</span>]],[[<span class="dv">1</span>],[<span class="dv">2</span>,<span class="dv">3</span>]],[[<span class="dv">1</span>,<span class="dv">2</span>],[<span class="dv">3</span>]],[[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]]]</a></code></pre></div>
<p>It gives the partitions of the list!</p>
<h2 id="sorting">Sorting</h2>
<p>So these monadic generalisations have been discovered before, several times over. Thereâ€™s even a <a href="https://hackage.haskell.org/package/monadlist-0.0.2">package</a> with monadic versions of the functions in Data.List. Exploring this idea with a little more formality is the paper â€œAll Sorts of Permutationsâ€ <span class="citation" data-cites="christiansen_all_2016">(Christiansen, Danilenko, and Dylus <a href="#ref-christiansen_all_2016">2016</a>)</span>, and accompanying presentation <a href="https://www.youtube.com/watch?v=vV3jqTxJ9Wc">on YouTube</a>. They show that the monadic version of sort produces permutations of the input list, and examine the output from different sorting algorithms. Hereâ€™s a couple of their implementations, altered slightly:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">insertM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> m <span class="dt">Bool</span>) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m [a]</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">insertM _ x [] <span class="fu">=</span> pure [x]</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">insertM p x yys<span class="fu">@</span>(y<span class="fu">:</span>ys) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">  lte <span class="ot">&lt;-</span> p x y</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">  <span class="kw">if</span> lte</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">    <span class="kw">then</span> pure (x<span class="fu">:</span>yys)</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">    <span class="kw">else</span> fmap (y<span class="fu">:</span>) (insertM p x ys)</a>
<a class="sourceLine" id="cb6-8" data-line-number="8"></a>
<a class="sourceLine" id="cb6-9" data-line-number="9"><span class="ot">insertSortM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> m <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m [a]</a>
<a class="sourceLine" id="cb6-10" data-line-number="10">insertSortM p <span class="fu">=</span> foldrM (insertM p) []</a>
<a class="sourceLine" id="cb6-11" data-line-number="11"></a>
<a class="sourceLine" id="cb6-12" data-line-number="12"><span class="ot">partitionM ::</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m ([a],[a])</a>
<a class="sourceLine" id="cb6-13" data-line-number="13">partitionM p <span class="fu">=</span> foldr f (pure ([],[])) <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-14" data-line-number="14">  f x <span class="fu">=</span> liftA2 ifStmt (p x) <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-15" data-line-number="15">    ifStmt flg (tr,fl)</a>
<a class="sourceLine" id="cb6-16" data-line-number="16">      <span class="fu">|</span> flg <span class="fu">=</span> (x<span class="fu">:</span>tr,fl)</a>
<a class="sourceLine" id="cb6-17" data-line-number="17">      <span class="fu">|</span> otherwise <span class="fu">=</span> (tr,x<span class="fu">:</span>fl)</a>
<a class="sourceLine" id="cb6-18" data-line-number="18">      </a>
<a class="sourceLine" id="cb6-19" data-line-number="19"><span class="ot">quickSortM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> m <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m [a]</a>
<a class="sourceLine" id="cb6-20" data-line-number="20">quickSortM p [] <span class="fu">=</span> pure []</a>
<a class="sourceLine" id="cb6-21" data-line-number="21">quickSortM p (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-22" data-line-number="22">  (gt,le) <span class="ot">&lt;-</span> partitionM (p x) xs</a>
<a class="sourceLine" id="cb6-23" data-line-number="23">  ls <span class="ot">&lt;-</span> quickSortM p le</a>
<a class="sourceLine" id="cb6-24" data-line-number="24">  gs <span class="ot">&lt;-</span> quickSortM p gt</a>
<a class="sourceLine" id="cb6-25" data-line-number="25">  pure (ls <span class="fu">++</span> [x] <span class="fu">++</span> gs)</a>
<a class="sourceLine" id="cb6-26" data-line-number="26"></a>
<a class="sourceLine" id="cb6-27" data-line-number="27"><span class="fu">&gt;&gt;&gt;</span> insertSortM (\_ _ <span class="ot">-&gt;</span> [<span class="dt">False</span>,<span class="dt">True</span>]) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb6-28" data-line-number="28">[[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>],[<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">2</span>],[<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">2</span>],[<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">3</span>],[<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">1</span>],[<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">1</span>]]</a>
<a class="sourceLine" id="cb6-29" data-line-number="29"></a>
<a class="sourceLine" id="cb6-30" data-line-number="30"><span class="fu">&gt;&gt;&gt;</span> quickSortM (\_ _ <span class="ot">-&gt;</span> [<span class="dt">False</span>,<span class="dt">True</span>]) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb6-31" data-line-number="31">[[<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">1</span>],[<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">1</span>],[<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">3</span>],[<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">2</span>],[<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">2</span>],[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]]</a></code></pre></div>
<p>As it should be easy to see, theyâ€™re very concise and elegant, and strongly resemble the pure versions of the algorithms.</p>
<h2 id="state">State</h2>
<p>So the examples above are very interesting and cool, but they donâ€™t necessarily have a place in real Haskell code. If you wanted to find the permutations, partitions, or power set of a list youâ€™d probably use a more standard implementation. Thatâ€™s not to say that these monadic functions have no uses, though: especially when coupled with <code class="sourceCode haskell"><span class="dt">State</span></code> they yield readable and fast implementations for certain tricky functions. <code class="sourceCode haskell">ordNub</code>, for instance:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">ordNub ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">ordNub <span class="fu">=</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  flip evalState Set.empty <span class="fu">.</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">  filterM</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">    (\x <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6">       flg <span class="ot">&lt;-</span> gets (Set.notMember x)</a>
<a class="sourceLine" id="cb7-7" data-line-number="7">       when flg (modify (Set.insert x))</a>
<a class="sourceLine" id="cb7-8" data-line-number="8">       pure flg)</a></code></pre></div>
<p>Alternatively, using a monadic version of <code class="sourceCode haskell">maximumOn</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">maximumOnM ::</span> (<span class="dt">Applicative</span> m, <span class="dt">Ord</span> b) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m (<span class="dt">Maybe</span> a)</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">maximumOnM p <span class="fu">=</span> (fmap <span class="fu">.</span> fmap) snd <span class="fu">.</span> foldl f (pure <span class="dt">Nothing</span>)</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">    f a e <span class="fu">=</span> liftA2 g a (p e)</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">        g <span class="dt">Nothing</span> q <span class="fu">=</span> <span class="dt">Just</span> (q, e)</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">        g b<span class="fu">@</span>(<span class="dt">Just</span> (o, y)) q</a>
<a class="sourceLine" id="cb8-8" data-line-number="8">          <span class="fu">|</span> o <span class="fu">&lt;</span> q <span class="fu">=</span> <span class="dt">Just</span> (q, e)</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">          <span class="fu">|</span> otherwise <span class="fu">=</span> b</a></code></pre></div>
<p>You can write a one-pass <code class="sourceCode haskell">mostFrequent</code>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">mostFrequent ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">mostFrequent <span class="fu">=</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  flip evalState Map.empty <span class="fu">.</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4">  maximumOnM</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">    (\x <span class="ot">-&gt;</span> maybe <span class="dv">1</span> succ <span class="fu">&lt;$&gt;</span> state (Map.insertLookupWithKey (const (<span class="fu">+</span>)) x <span class="dv">1</span>))</a></code></pre></div>
<h2 id="decision-trees">Decision Trees</h2>
<p>One of the nicest things about the paper was the diagrams of decision trees provided for each sorting algorithm. I couldnâ€™t find a library to do that for me, so I had a go at producing my own. First, weâ€™ll need a data type to represent the tree itself:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">data</span> <span class="dt">DecTree</span> t a</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">Pure</span> a</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  <span class="fu">|</span> <span class="dt">Choice</span> t (<span class="dt">DecTree</span> t a) (<span class="dt">DecTree</span> t a)</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">  <span class="kw">deriving</span> <span class="dt">Functor</span></a></code></pre></div>
<p>Weâ€™ll say the left branch is â€œtrueâ€ and the right â€œfalseâ€. Applicative and monad instances are relatively mechanical<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Applicative</span> (<span class="dt">DecTree</span> t) <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2">  pure <span class="fu">=</span> <span class="dt">Pure</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  <span class="dt">Pure</span> f <span class="fu">&lt;*&gt;</span> xs <span class="fu">=</span> fmap f xs</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">  <span class="dt">Choice</span> c ls rs <span class="fu">&lt;*&gt;</span> xs <span class="fu">=</span> <span class="dt">Choice</span> c (ls <span class="fu">&lt;*&gt;</span> xs) (rs <span class="fu">&lt;*&gt;</span> xs)</a>
<a class="sourceLine" id="cb11-5" data-line-number="5">  </a>
<a class="sourceLine" id="cb11-6" data-line-number="6"><span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">DecTree</span> t) <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-7" data-line-number="7">  <span class="dt">Pure</span> x <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> f x</a>
<a class="sourceLine" id="cb11-8" data-line-number="8">  <span class="dt">Choice</span> c ls rs <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">Choice</span> c (ls <span class="fu">&gt;&gt;=</span> f) (rs <span class="fu">&gt;&gt;=</span> f)</a></code></pre></div>
<p>We can now create a comparator function that constructs one of these trees, and remembers the values it was given:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="ot">traceCompare ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">DecTree</span> (a,a) <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">traceCompare x y <span class="fu">=</span> <span class="dt">Choice</span> (x,y) (<span class="dt">Pure</span> <span class="dt">True</span>) (<span class="dt">Pure</span> <span class="dt">False</span>)</a></code></pre></div>
<p>Finally, to draw the tree, Iâ€™ll use a function from my <a href="https://github.com/oisdk/binary-tree">binary tree</a> library:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="ot">printDecTree ::</span> (<span class="dt">Show</span> a, <span class="dt">Show</span> b) <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">DecTree</span> (a,a) b <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">printDecTree rel t <span class="fu">=</span> putStr (drawTreeWith id (go t) <span class="st">&quot;&quot;</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">  go (<span class="dt">Pure</span> xs) <span class="fu">=</span> <span class="dt">Node</span> (show xs) <span class="dt">Leaf</span> <span class="dt">Leaf</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4">  go (<span class="dt">Choice</span> (x,y) tr fl) <span class="fu">=</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5">    <span class="dt">Node</span> (show x <span class="fu">++</span> rel <span class="fu">++</span> show y) (go tr) (go fl)</a></code></pre></div>
<p>And we get these really nice diagrams out:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> (printDecTree <span class="st">&quot;&lt;=&quot;</span> <span class="fu">.</span> insertSortM traceCompare) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb14-2" data-line-number="2"></a>
<a class="sourceLine" id="cb14-3" data-line-number="3">         â”Œ[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb14-4" data-line-number="4">    â”Œ<span class="dv">1</span><span class="fu">&lt;=</span>2â”¤</a>
<a class="sourceLine" id="cb14-5" data-line-number="5">    â”‚    â”‚    â”Œ[<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb14-6" data-line-number="6">    â”‚    â””<span class="dv">1</span><span class="fu">&lt;=</span>3â”¤</a>
<a class="sourceLine" id="cb14-7" data-line-number="7">    â”‚         â””[<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb14-8" data-line-number="8"><span class="dv">2</span><span class="fu">&lt;=</span>3â”¤</a>
<a class="sourceLine" id="cb14-9" data-line-number="9">    â”‚    â”Œ[<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">2</span>]</a>
<a class="sourceLine" id="cb14-10" data-line-number="10">    â””<span class="dv">1</span><span class="fu">&lt;=</span>3â”¤</a>
<a class="sourceLine" id="cb14-11" data-line-number="11">         â”‚    â”Œ[<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">2</span>]</a>
<a class="sourceLine" id="cb14-12" data-line-number="12">         â””<span class="dv">1</span><span class="fu">&lt;=</span>2â”¤</a>
<a class="sourceLine" id="cb14-13" data-line-number="13">              â””[<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb14-14" data-line-number="14"></a>
<a class="sourceLine" id="cb14-15" data-line-number="15"><span class="fu">&gt;&gt;&gt;</span> (printDecTree <span class="st">&quot;&lt;=&quot;</span> <span class="fu">.</span> quickSortM traceCompare) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb14-16" data-line-number="16"></a>
<a class="sourceLine" id="cb14-17" data-line-number="17">              â”Œ[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb14-18" data-line-number="18">         â”Œ<span class="dv">2</span><span class="fu">&lt;=</span>3â”¤</a>
<a class="sourceLine" id="cb14-19" data-line-number="19">         â”‚    â””[<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">2</span>]</a>
<a class="sourceLine" id="cb14-20" data-line-number="20">    â”Œ<span class="dv">1</span><span class="fu">&lt;=</span>3â”¤</a>
<a class="sourceLine" id="cb14-21" data-line-number="21">    â”‚    â””[<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">2</span>]</a>
<a class="sourceLine" id="cb14-22" data-line-number="22"><span class="dv">1</span><span class="fu">&lt;=</span>2â”¤</a>
<a class="sourceLine" id="cb14-23" data-line-number="23">    â”‚    â”Œ[<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb14-24" data-line-number="24">    â””<span class="dv">1</span><span class="fu">&lt;=</span>3â”¤</a>
<a class="sourceLine" id="cb14-25" data-line-number="25">         â”‚    â”Œ[<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb14-26" data-line-number="26">         â””<span class="dv">2</span><span class="fu">&lt;=</span>3â”¤</a>
<a class="sourceLine" id="cb14-27" data-line-number="27">              â””[<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">1</span>]</a></code></pre></div>
<p>We can also try it out with the other monadic list functions:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> (printDecTree <span class="st">&quot;=&quot;</span> <span class="fu">.</span> groupByM traceCompare) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb15-2" data-line-number="2"></a>
<a class="sourceLine" id="cb15-3" data-line-number="3">       â”Œ[[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]]</a>
<a class="sourceLine" id="cb15-4" data-line-number="4">   â”Œ<span class="dv">2</span><span class="fu">=</span>3â”¤</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">   â”‚   â””[[<span class="dv">1</span>,<span class="dv">2</span>],[<span class="dv">3</span>]]</a>
<a class="sourceLine" id="cb15-6" data-line-number="6"><span class="dv">1</span><span class="fu">=</span>2â”¤</a>
<a class="sourceLine" id="cb15-7" data-line-number="7">   â”‚   â”Œ[[<span class="dv">1</span>],[<span class="dv">2</span>,<span class="dv">3</span>]]</a>
<a class="sourceLine" id="cb15-8" data-line-number="8">   â””<span class="dv">2</span><span class="fu">=</span>3â”¤</a>
<a class="sourceLine" id="cb15-9" data-line-number="9">       â””[[<span class="dv">1</span>],[<span class="dv">2</span>],[<span class="dv">3</span>]]</a></code></pre></div>
<h2 id="applicative">Applicative</h2>
<p>You might notice that none of these â€œmonadicâ€ functions actually require a monad constraint: theyâ€™re all applicative. Thereâ€™s a straightforward implementation that relies only on applicative for most of these functions, with a notable exception: sort. Getting <em>that</em> to work with just applicative is the subject of a future post.</p>
<h3 id="references" class="unnumbered">References</h3>
<div id="refs" class="references">
<div id="ref-christiansen_all_2016">
<p>Christiansen, Jan, Nikita Danilenko, and Sandra Dylus. 2016. â€œAll Sorts of Permutations (Functional Pearl).â€ In <em>Proceedings of the 21st ACM SIGPLAN International Conference on Functional Programming</em>, 168â€“179. ICFP 2016. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/2951913.2951949">10.1145/2951913.2951949</a>. <a href="http://informatik.uni-kiel.de/~sad/icfp2016-preprint.pdf" class="uri">http://informatik.uni-kiel.de/~sad/icfp2016-preprint.pdf</a>.</p>
</div>
</div>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>The definition has since been <a href="https://hackage.haskell.org/package/base-4.10.1.0/docs/src/Control.Monad.html#filterM">updated</a> to more modern Haskell: it now uses a fold, and only requires <code class="sourceCode haskell"><span class="dt">Applicative</span></code>.<a href="#fnref1" class="footnote-back">â†©</a></p></li>
<li id="fn2"><p>Part of the reason the instances are so mechanical is that this type strongly resembles the <a href="https://hackage.haskell.org/package/free-5/docs/Control-Monad-Free.html#t:Free">free monad</a>:</p>
<p><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Free</span> f a <span class="fu">=</span> <span class="dt">Pure</span> a <span class="fu">|</span> <span class="dt">Free</span> (f (<span class="dt">Free</span> f a))</code></p>
<p>In fact, the example given in the <code class="sourceCode haskell"><span class="dt">MonadFree</span></code> class is the following:</p>
<p><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Pair</span> a <span class="fu">=</span> <span class="dt">Pair</span> a a</code></p>
<p><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Tree</span> <span class="fu">=</span> <span class="dt">Free</span> <span class="dt">Pair</span></code></p>
<p>The only difference with the above type and the decision tree is that the decision tree carries a tag with it.</p>
<p>So whatâ€™s so interesting about this relationship? Well, <code class="sourceCode haskell"><span class="dt">Pair</span></code> is actually a <a href="https://hackage.haskell.org/package/adjunctions-4.4/docs/Data-Functor-Rep.html">representable functor</a>. Any representable functor <code class="sourceCode haskell">f a</code> can be converted to (and from) a function <code class="sourceCode haskell">key <span class="ot">-&gt;</span> a</code>, where <code class="sourceCode haskell">key</code> is the specific key for <code class="sourceCode haskell">f</code>. The key for <code class="sourceCode haskell"><span class="dt">Pair</span></code> is <code class="sourceCode haskell"><span class="dt">Bool</span></code>: the result of the function we passed in to the sorting functions!</p>
<p>In general, you can make a â€œdecision treeâ€ for any function of type <code class="sourceCode haskell">a <span class="ot">-&gt;</span> b</code> like so:</p>
<p><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">DecTree</span> a b r <span class="fu">=</span> <span class="dt">Rep</span> f <span class="fu">~</span> b <span class="ot">=&gt;</span> <span class="dt">Free</span> (<span class="dt">Compose</span> ((,) a) f) r</code></p>
<p>But more on that in a later post.<a href="#fnref2" class="footnote-back">â†©</a></p></li>
</ol>
</section>
]]></description>
    <pubDate>Sun, 11 Feb 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-02-11-monadic-list.functions.html</guid>
    <dc:creator>Donnacha OisÃ­n Kidney</dc:creator>
</item>
<item>
    <title>groupBy</title>
    <link>https://doisinkidney.com/posts/2018-01-07-groupBy.html</link>
    <description><![CDATA[<div class="info">
    Posted on January  7, 2018
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Folds.html">Folds</a>
    
</div>

<p>Hereâ€™s a useful function from <a href="https://hackage.haskell.org/package/base-4.10.1.0/docs/Data-List.html#v:groupBy">Data.List</a>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">groupBy ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">groupBy (<span class="fu">==</span>) <span class="st">&quot;aabcdda&quot;</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="co">-- [&quot;aa&quot;,&quot;b&quot;,&quot;c&quot;,&quot;dd&quot;,&quot;a&quot;]</span></a></code></pre></div>
<p>However, as has been pointed out before<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>, <code class="sourceCode haskell">groupBy</code> expects an equivalence relation, and can exhibit surprising behavior when it doesnâ€™t get one. Letâ€™s say, for instance, that we wanted to group numbers that were close together:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">groupClose ::</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> [[<span class="dt">Integer</span>]]</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">groupClose <span class="fu">=</span> groupBy (\x y <span class="ot">-&gt;</span> abs (x <span class="fu">-</span> y) <span class="fu">&lt;</span> <span class="dv">3</span>)</a></code></pre></div>
<p>What would you expect on the list <code>[1, 2, 3, 4, 5]</code>? All in the same group? Well, what you actually get is:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1">[[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>],[<span class="dv">4</span>,<span class="dv">5</span>]]</a></code></pre></div>
<p>This is because the implementation of <code class="sourceCode haskell">groupBy</code> only compares to the first element in each group:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">groupBy _  []           <span class="fu">=</span>  []</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">groupBy eq (x<span class="fu">:</span>xs)       <span class="fu">=</span>  (x<span class="fu">:</span>ys) <span class="fu">:</span> groupBy eq zs</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">                           <span class="kw">where</span> (ys,zs) <span class="fu">=</span> span (eq x) xs</a></code></pre></div>
<p>Brandon Simmons gave a <a href="http://brandon.si/code/an-alternative-definition-for-datalistgroupby/">definition</a> of <code class="sourceCode haskell">groupBy</code> that is perhaps more useful, but it used explicit recursion, rather than a fold.</p>
<p>A definition with <code class="sourceCode haskell">foldr</code> turned out to be trickier than I expected. I found some of the laziness properties especially difficult:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> head (groupBy (<span class="fu">==</span>) (<span class="dv">1</span><span class="fu">:</span><span class="dv">2</span><span class="fu">:</span>undefined))</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">[<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="fu">&gt;&gt;&gt;</span> (head <span class="fu">.</span> head) (groupBy (<span class="fu">==</span>) (<span class="dv">1</span><span class="fu">:</span>undefined))</a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="dv">1</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5"><span class="fu">&gt;&gt;&gt;</span> (head <span class="fu">.</span> head <span class="fu">.</span> tail) (groupBy (<span class="fu">==</span>) (<span class="dv">1</span><span class="fu">:</span><span class="dv">2</span><span class="fu">:</span>undefined))</a>
<a class="sourceLine" id="cb5-6" data-line-number="6"><span class="dv">2</span></a></code></pre></div>
<p>Hereâ€™s the definition I came up with, after some deliberation:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">groupBy ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">groupBy p xs <span class="fu">=</span> build (\c n <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  <span class="kw">let</span> f x a q</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">        <span class="fu">|</span> q x <span class="fu">=</span> (x <span class="fu">:</span> ys, zs)</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">        <span class="fu">|</span> otherwise <span class="fu">=</span> ([], c (x <span class="fu">:</span> ys) zs)</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">        <span class="kw">where</span> (ys,zs) <span class="fu">=</span> a (p x)</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">  <span class="kw">in</span> snd (foldr f (const ([], n)) xs (const <span class="dt">False</span>)))</a>
<a class="sourceLine" id="cb6-8" data-line-number="8"><span class="ot">{-# INLINE groupBy #-}</span></a></code></pre></div>
<p>Seemingly benign changes to the function will break one or more of the above tests. In particular, the laziness of a â€œwhereâ€ binding needs to be taken into account. Hereâ€™s an early attempt which failed:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">groupBy ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">groupBy p xs <span class="fu">=</span> build (\c n <span class="ot">-&gt;</span> </a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  <span class="kw">let</span> f x a q d</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">        <span class="fu">|</span> q x <span class="fu">=</span> a (p x) (d <span class="fu">.</span> (<span class="fu">:</span>) x)</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">        <span class="fu">|</span> otherwise <span class="fu">=</span> d [] (a (p x) (c <span class="fu">.</span> (<span class="fu">:</span>) x))</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">  <span class="kw">in</span> foldr f (\_ d <span class="ot">-&gt;</span> d [] n) xs (const <span class="dt">False</span>) (\ _ y <span class="ot">-&gt;</span> y))</a></code></pre></div>
<p>Once done, though, it works as expected:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> groupBy (<span class="fu">==</span>) <span class="st">&quot;aaabcccdda&quot;</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">[<span class="st">&quot;aaa&quot;</span>,<span class="st">&quot;b&quot;</span>,<span class="st">&quot;ccc&quot;</span>,<span class="st">&quot;dd&quot;</span>,<span class="st">&quot;a&quot;</span>]</a>
<a class="sourceLine" id="cb8-3" data-line-number="3"><span class="fu">&gt;&gt;&gt;</span> groupBy (<span class="fu">==</span>) []</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">[]</a>
<a class="sourceLine" id="cb8-5" data-line-number="5"><span class="fu">&gt;&gt;&gt;</span> groupBy (<span class="fu">&lt;=</span>) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">0</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">2</span>]</a>
<a class="sourceLine" id="cb8-6" data-line-number="6">[[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">3</span>],[<span class="dv">1</span>,<span class="dv">2</span>],[<span class="dv">0</span>,<span class="dv">4</span>,<span class="dv">5</span>],[<span class="dv">2</span>]]</a></code></pre></div>
<p>Itâ€™s the fastest version I could find that obeyed the above laziness properties.</p>
<p>The <a href="https://ghc.haskell.org/trac/ghc/ticket/13593">GHC page on the issue</a> unfortunately seems to indicate the implementation wonâ€™t be changed. Ah, well. Regardless, I have a <a href="https://github.com/oisdk/groupBy">repository</a> with the implementation above (with extra fusion machinery added) and comparisons to other implementations.</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>There are several threads on the libraries mailing list on this topic:</p>
<dl>
<dt>2006</dt>
<dd><a href="http://www.haskell.org/pipermail/haskell-cafe/2006-October/019148.html">mapAccumL - find max in-sequence subsequence</a>
</dd>
<dt>2007</dt>
<dd><a href="https://mail.haskell.org/pipermail/libraries/2007-August/008028.html">Data.List.groupBy with non-transitive equality predicate</a> (this is the longest discussion on the topic)
</dd>
<dt>2008</dt>
<dd><a href="https://mail.haskell.org/pipermail/libraries/2008-September/010629.html">Generalize groupBy in a useful way?</a>
</dd>
<dt>2009</dt>
<dd><a href="https://mail.haskell.org/pipermail/libraries/2009-June/011866.html">nubBy seems broken in recent GHCs</a>
</dd>
</dl>
<a href="#fnref1" class="footnote-back">â†©</a></li>
</ol>
</section>
]]></description>
    <pubDate>Sun, 07 Jan 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-01-07-groupBy.html</guid>
    <dc:creator>Donnacha OisÃ­n Kidney</dc:creator>
</item>
<item>
    <title>Balancing Folds</title>
    <link>https://doisinkidney.com/posts/2017-10-30-balancing-folds.html</link>
    <description><![CDATA[<div class="info">
    Posted on October 30, 2017
</div>
<div class="info">
    
        Part 1 of a <a href="/series/Balanced%20Folds.html">3-part series on Balanced Folds</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Folds.html">Folds</a>
    
</div>

<p>There are three main ways to fold things in Haskell: from the right, from the left, and from either side. Letâ€™s look at the left vs right variants first. <code class="sourceCode haskell">foldr</code> works from the right:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1">foldr (<span class="fu">+</span>) <span class="dv">0</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="dv">1</span> <span class="fu">+</span> (<span class="dv">2</span> <span class="fu">+</span> (<span class="dv">3</span> <span class="fu">+</span> <span class="dv">0</span>))</a></code></pre></div>
<p>And <code class="sourceCode haskell">foldl</code> from the left:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1">foldl (<span class="fu">+</span>) <span class="dv">0</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">((<span class="dv">0</span> <span class="fu">+</span> <span class="dv">1</span>) <span class="fu">+</span> <span class="dv">2</span>) <span class="fu">+</span> <span class="dv">3</span></a></code></pre></div>
<p>As youâ€™ll notice, the result of the two operations above is the same (6; although one may take much longer than the other). In fact, <em>whenever</em> the result of <code class="sourceCode haskell">foldr</code> and <code class="sourceCode haskell">foldl</code> is the same for a pair of arguments (in this case <code class="sourceCode haskell"><span class="fu">+</span></code> and <code class="sourceCode haskell"><span class="dv">0</span></code>), we say that that pair forms a <a href="https://hackage.haskell.org/package/base-4.10.0.0/docs/Data-Monoid.html#t:Monoid"><code class="sourceCode haskell"><span class="dt">Monoid</span></code></a> for some type (well, thereâ€™s some extra stuff to do with <code class="sourceCode haskell"><span class="dv">0</span></code>, but I only care about associativity at the moment). In this case, the <a href="https://hackage.haskell.org/package/base-4.10.0.0/docs/Data-Monoid.html#t:Sum"><code class="sourceCode haskell"><span class="dt">Sum</span></code></a> monoid is formed:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Sum</span> a <span class="fu">=</span> <span class="dt">Sum</span> {<span class="ot"> getSum ::</span> a }</a>
<a class="sourceLine" id="cb3-2" data-line-number="2"></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="kw">instance</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Sum</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">  mempty <span class="fu">=</span> <span class="dt">Sum</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">  mappend (<span class="dt">Sum</span> x) (<span class="dt">Sum</span> y) <span class="fu">=</span> <span class="dt">Sum</span> (x <span class="fu">+</span> y)</a></code></pre></div>
<p>When you know that you have a monoid, you can use the <a href="https://hackage.haskell.org/package/base-4.10.0.0/docs/Data-Foldable.html#v:foldMap"><code class="sourceCode haskell">foldMap</code></a> function: this is the third kind of fold. It says that you donâ€™t care which of <code class="sourceCode haskell">foldl</code> or <code class="sourceCode haskell">foldr</code> is used, so the implementer of <code class="sourceCode haskell">foldMap</code> can put the parentheses wherever they want:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">foldMap <span class="dt">Sum</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">(<span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span>) <span class="fu">+</span> (<span class="dv">3</span> <span class="fu">+</span> <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="dv">0</span> <span class="fu">+</span> ((<span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span>) <span class="fu">+</span> <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">((<span class="dv">0</span> <span class="fu">+</span> <span class="dv">1</span>) <span class="fu">+</span> <span class="dv">2</span>) <span class="fu">+</span> <span class="dv">3</span></a></code></pre></div>
<p>And we canâ€™t tell the difference from the result. This is a pretty bare-bones introduction to folds and monoids: you wonâ€™t need to know more than that for the rest of this post, but the topic area is fascinating and deep, so donâ€™t let me give you the impression that Iâ€™ve done anything more than scratched the surface.</p>
<h1 id="other-ways-to-fold">Other Ways to Fold</h1>
<p>Quite often, we <em>do</em> care about where the parentheses go. Take, for instance, a binary tree type, with values at the leaves:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">Empty</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  <span class="fu">|</span> <span class="dt">Leaf</span> a</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">  <span class="fu">|</span> <span class="dt">Tree</span> a <span class="fu">:*:</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb5-5" data-line-number="5"></a>
<a class="sourceLine" id="cb5-6" data-line-number="6"><span class="kw">instance</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb5-7" data-line-number="7">         <span class="dt">Show</span> (<span class="dt">Tree</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8">    show <span class="dt">Empty</span> <span class="fu">=</span> <span class="st">&quot;()&quot;</span></a>
<a class="sourceLine" id="cb5-9" data-line-number="9">    show (<span class="dt">Leaf</span> x) <span class="fu">=</span> show x</a>
<a class="sourceLine" id="cb5-10" data-line-number="10">    show (l <span class="fu">:*:</span> r) <span class="fu">=</span> <span class="st">&quot;(&quot;</span> <span class="fu">++</span> show l <span class="fu">++</span> <span class="st">&quot;*&quot;</span> <span class="fu">++</span> show r <span class="fu">++</span> <span class="st">&quot;)&quot;</span></a></code></pre></div>
<p>We canâ€™t (well, shouldnâ€™t) us <code class="sourceCode haskell">foldMap</code> here, because we would be able to tell the difference between different arrangements of parentheses:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> foldMap something [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb6-2" data-line-number="2"></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">((<span class="dv">1</span><span class="fu">*</span><span class="dv">2</span>)<span class="fu">*</span>(<span class="dv">3</span><span class="fu">*</span>())) â”‚ (()<span class="fu">*</span>((<span class="dv">1</span><span class="fu">*</span><span class="dv">2</span>)<span class="fu">*</span><span class="dv">3</span>)) â”‚ (((()<span class="fu">*</span><span class="dv">1</span>)<span class="fu">*</span><span class="dv">2</span>)<span class="fu">*</span><span class="dv">3</span>)</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">       â”Œ<span class="dv">1</span>      â”‚      â”Œ()       â”‚       â”Œ()</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">      â”Œâ”¤       â”‚      â”¤         â”‚      â”Œâ”¤</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">      â”‚â””<span class="dv">2</span>      â”‚      â”‚ â”Œ<span class="dv">1</span>      â”‚      â”‚â””<span class="dv">1</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">      â”¤        â”‚      â”‚â”Œâ”¤       â”‚     â”Œâ”¤</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">      â”‚â”Œ<span class="dv">3</span>      â”‚      â”‚â”‚â””<span class="dv">2</span>      â”‚     â”‚â””<span class="dv">2</span></a>
<a class="sourceLine" id="cb6-10" data-line-number="10">      â””â”¤       â”‚      â””â”¤        â”‚     â”¤</a>
<a class="sourceLine" id="cb6-11" data-line-number="11">       â””()     â”‚       â””<span class="dv">3</span>       â”‚     â””<span class="dv">3</span></a></code></pre></div>
<p>So we use one of the folds which lets us choose the arrangements of parentheses:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> (foldr (<span class="fu">:*:</span>) <span class="dt">Empty</span> <span class="fu">.</span> map <span class="dt">Leaf</span>) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">(<span class="dv">1</span><span class="fu">*</span>(<span class="dv">2</span><span class="fu">*</span>(<span class="dv">3</span><span class="fu">*</span>(<span class="dv">4</span><span class="fu">*</span>(<span class="dv">5</span><span class="fu">*</span>(<span class="dv">6</span><span class="fu">*</span>()))))))</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">     â”Œ<span class="dv">1</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">    â”Œâ”¤</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">    â”‚â””<span class="dv">2</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6">   â”Œâ”¤</a>
<a class="sourceLine" id="cb7-7" data-line-number="7">   â”‚â””<span class="dv">3</span></a>
<a class="sourceLine" id="cb7-8" data-line-number="8">  â”Œâ”¤</a>
<a class="sourceLine" id="cb7-9" data-line-number="9">  â”‚â””<span class="dv">4</span></a>
<a class="sourceLine" id="cb7-10" data-line-number="10"> â”Œâ”¤</a>
<a class="sourceLine" id="cb7-11" data-line-number="11"> â”‚â””<span class="dv">5</span></a>
<a class="sourceLine" id="cb7-12" data-line-number="12">â”Œâ”¤</a>
<a class="sourceLine" id="cb7-13" data-line-number="13">â”‚â””<span class="dv">6</span></a>
<a class="sourceLine" id="cb7-14" data-line-number="14">â”¤</a>
<a class="sourceLine" id="cb7-15" data-line-number="15">â””()</a>
<a class="sourceLine" id="cb7-16" data-line-number="16"></a>
<a class="sourceLine" id="cb7-17" data-line-number="17"><span class="fu">&gt;&gt;&gt;</span> (foldl (<span class="fu">:*:</span>) <span class="dt">Empty</span> <span class="fu">.</span> map <span class="dt">Leaf</span>) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]</a>
<a class="sourceLine" id="cb7-18" data-line-number="18">((((((()<span class="fu">*</span><span class="dv">1</span>)<span class="fu">*</span><span class="dv">2</span>)<span class="fu">*</span><span class="dv">3</span>)<span class="fu">*</span><span class="dv">4</span>)<span class="fu">*</span><span class="dv">5</span>)<span class="fu">*</span><span class="dv">6</span>)</a>
<a class="sourceLine" id="cb7-19" data-line-number="19">â”Œ()</a>
<a class="sourceLine" id="cb7-20" data-line-number="20">â”¤</a>
<a class="sourceLine" id="cb7-21" data-line-number="21">â”‚â”Œ<span class="dv">1</span></a>
<a class="sourceLine" id="cb7-22" data-line-number="22">â””â”¤</a>
<a class="sourceLine" id="cb7-23" data-line-number="23"> â”‚â”Œ<span class="dv">2</span></a>
<a class="sourceLine" id="cb7-24" data-line-number="24"> â””â”¤</a>
<a class="sourceLine" id="cb7-25" data-line-number="25">  â”‚â”Œ<span class="dv">3</span></a>
<a class="sourceLine" id="cb7-26" data-line-number="26">  â””â”¤</a>
<a class="sourceLine" id="cb7-27" data-line-number="27">   â”‚â”Œ<span class="dv">4</span></a>
<a class="sourceLine" id="cb7-28" data-line-number="28">   â””â”¤</a>
<a class="sourceLine" id="cb7-29" data-line-number="29">    â”‚â”Œ<span class="dv">5</span></a>
<a class="sourceLine" id="cb7-30" data-line-number="30">    â””â”¤</a>
<a class="sourceLine" id="cb7-31" data-line-number="31">     â””<span class="dv">6</span></a></code></pre></div>
<p>The issue is that neither of the trees generated are necessarily what we want: often, we want something more <em>balanced</em>.</p>
<h2 id="treefold">TreeFold</h2>
<p>To try and find a more balanced fold, letâ€™s (for now) assume weâ€™re always going to get non-empty input. This will let us simplify the <code class="sourceCode haskell"><span class="dt">Tree</span></code> type a little, to:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">Leaf</span> a</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  <span class="fu">|</span> <span class="dt">Tree</span> a <span class="fu">:*:</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">  <span class="kw">deriving</span> <span class="dt">Foldable</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5"></a>
<a class="sourceLine" id="cb8-6" data-line-number="6"><span class="kw">instance</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb8-7" data-line-number="7">         <span class="dt">Show</span> (<span class="dt">Tree</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8">    show (<span class="dt">Leaf</span> x) <span class="fu">=</span> show x</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">    show (l <span class="fu">:*:</span> r) <span class="fu">=</span> <span class="st">&quot;(&quot;</span> <span class="fu">++</span> show l <span class="fu">++</span> <span class="st">&quot;*&quot;</span> <span class="fu">++</span> show r <span class="fu">++</span> <span class="st">&quot;)&quot;</span></a></code></pre></div>
<p>Then, we can use Jon Fairbairnâ€™s fold described in <a href="http://www.mail-archive.com/haskell@haskell.org/msg01788.html">this</a> email, adapted a bit for our non-empty input:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Data.List.NonEmpty</span> (<span class="dt">NonEmpty</span>(..))</a>
<a class="sourceLine" id="cb9-2" data-line-number="2"></a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="ot">treeFold ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">NonEmpty</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">treeFold f <span class="fu">=</span> go</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6">    go (x <span class="fu">:|</span> []) <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">    go (a <span class="fu">:|</span> b<span class="fu">:</span>l) <span class="fu">=</span> go (f a b <span class="fu">:|</span> pairMap l)</a>
<a class="sourceLine" id="cb9-8" data-line-number="8">    pairMap (x<span class="fu">:</span>y<span class="fu">:</span>rest) <span class="fu">=</span> f x y <span class="fu">:</span> pairMap rest</a>
<a class="sourceLine" id="cb9-9" data-line-number="9">    pairMap xs <span class="fu">=</span> xs</a></code></pre></div>
<p>There are two parts to this function: <code class="sourceCode haskell">pairMap</code> and the <code class="sourceCode haskell">go</code> helper. <code class="sourceCode haskell">pairMap</code> combines adjacent elements in the list using the combining function. As a top-level function it might look like this:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">pairMap f (x<span class="fu">:</span>y<span class="fu">:</span>rest) <span class="fu">=</span> f x y <span class="fu">:</span> pairMap f rest</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">pairMap f xs <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb10-3" data-line-number="3"></a>
<a class="sourceLine" id="cb10-4" data-line-number="4">pairMap (<span class="fu">++</span>) [<span class="st">&quot;a&quot;</span>,<span class="st">&quot;b&quot;</span>,<span class="st">&quot;c&quot;</span>,<span class="st">&quot;d&quot;</span>,<span class="st">&quot;e&quot;</span>]</a>
<a class="sourceLine" id="cb10-5" data-line-number="5"><span class="co">-- [&quot;ab&quot;,&quot;cd&quot;,&quot;e&quot;]</span></a></code></pre></div>
<p>As you can see, it leaves any leftovers untouched at the end of the list.</p>
<p>The <code class="sourceCode haskell">go</code> helper applies <code class="sourceCode haskell">pairMap</code> repeatedly to the list until it has only one element. This gives us much more balanced results that <code class="sourceCode haskell">foldl</code> or <code class="sourceCode haskell">foldr</code> (turn on <code class="sourceCode haskell"><span class="fu">-</span><span class="dt">XOverloadedLists</span></code> to write non-empty lists using this syntax):</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> (treeFold (<span class="fu">:*:</span>) <span class="fu">.</span> fmap <span class="dt">Leaf</span>) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">(((<span class="dv">1</span><span class="fu">*</span><span class="dv">2</span>)<span class="fu">*</span>(<span class="dv">3</span><span class="fu">*</span><span class="dv">4</span>))<span class="fu">*</span>(<span class="dv">5</span><span class="fu">*</span><span class="dv">6</span>))</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  â”Œ<span class="dv">1</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4"> â”Œâ”¤</a>
<a class="sourceLine" id="cb11-5" data-line-number="5"> â”‚â””<span class="dv">2</span></a>
<a class="sourceLine" id="cb11-6" data-line-number="6">â”Œâ”¤</a>
<a class="sourceLine" id="cb11-7" data-line-number="7">â”‚â”‚â”Œ<span class="dv">3</span></a>
<a class="sourceLine" id="cb11-8" data-line-number="8">â”‚â””â”¤</a>
<a class="sourceLine" id="cb11-9" data-line-number="9">â”‚ â””<span class="dv">4</span></a>
<a class="sourceLine" id="cb11-10" data-line-number="10">â”¤</a>
<a class="sourceLine" id="cb11-11" data-line-number="11">â”‚â”Œ<span class="dv">5</span></a>
<a class="sourceLine" id="cb11-12" data-line-number="12">â””â”¤</a>
<a class="sourceLine" id="cb11-13" data-line-number="13"> â””<span class="dv">6</span></a>
<a class="sourceLine" id="cb11-14" data-line-number="14"></a>
<a class="sourceLine" id="cb11-15" data-line-number="15"><span class="fu">&gt;&gt;&gt;</span> (treeFold (<span class="fu">:*:</span>) <span class="fu">.</span> fmap <span class="dt">Leaf</span>) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>]</a>
<a class="sourceLine" id="cb11-16" data-line-number="16">(((<span class="dv">1</span><span class="fu">*</span><span class="dv">2</span>)<span class="fu">*</span>(<span class="dv">3</span><span class="fu">*</span><span class="dv">4</span>))<span class="fu">*</span>((<span class="dv">5</span><span class="fu">*</span><span class="dv">6</span>)<span class="fu">*</span>(<span class="dv">7</span><span class="fu">*</span><span class="dv">8</span>)))</a>
<a class="sourceLine" id="cb11-17" data-line-number="17">  â”Œ<span class="dv">1</span></a>
<a class="sourceLine" id="cb11-18" data-line-number="18"> â”Œâ”¤</a>
<a class="sourceLine" id="cb11-19" data-line-number="19"> â”‚â””<span class="dv">2</span></a>
<a class="sourceLine" id="cb11-20" data-line-number="20">â”Œâ”¤</a>
<a class="sourceLine" id="cb11-21" data-line-number="21">â”‚â”‚â”Œ<span class="dv">3</span></a>
<a class="sourceLine" id="cb11-22" data-line-number="22">â”‚â””â”¤</a>
<a class="sourceLine" id="cb11-23" data-line-number="23">â”‚ â””<span class="dv">4</span></a>
<a class="sourceLine" id="cb11-24" data-line-number="24">â”¤</a>
<a class="sourceLine" id="cb11-25" data-line-number="25">â”‚ â”Œ<span class="dv">5</span></a>
<a class="sourceLine" id="cb11-26" data-line-number="26">â”‚â”Œâ”¤</a>
<a class="sourceLine" id="cb11-27" data-line-number="27">â”‚â”‚â””<span class="dv">6</span></a>
<a class="sourceLine" id="cb11-28" data-line-number="28">â””â”¤</a>
<a class="sourceLine" id="cb11-29" data-line-number="29"> â”‚â”Œ<span class="dv">7</span></a>
<a class="sourceLine" id="cb11-30" data-line-number="30"> â””â”¤</a>
<a class="sourceLine" id="cb11-31" data-line-number="31">  â””<span class="dv">8</span></a></code></pre></div>
<p>However, there are still cases where one branch will be much larger than its sibling. The fold fills a balanced binary tree from the left, but any leftover elements are put at the top level. In other words:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> (treeFold (<span class="fu">:*:</span>) <span class="fu">.</span> fmap <span class="dt">Leaf</span>) [<span class="dv">1</span><span class="fu">..</span><span class="dv">9</span>]</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">((((<span class="dv">1</span><span class="fu">*</span><span class="dv">2</span>)<span class="fu">*</span>(<span class="dv">3</span><span class="fu">*</span><span class="dv">4</span>))<span class="fu">*</span>((<span class="dv">5</span><span class="fu">*</span><span class="dv">6</span>)<span class="fu">*</span>(<span class="dv">7</span><span class="fu">*</span><span class="dv">8</span>)))<span class="fu">*</span><span class="dv">9</span>)</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">   â”Œ<span class="dv">1</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">  â”Œâ”¤</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">  â”‚â””<span class="dv">2</span></a>
<a class="sourceLine" id="cb12-6" data-line-number="6"> â”Œâ”¤</a>
<a class="sourceLine" id="cb12-7" data-line-number="7"> â”‚â”‚â”Œ<span class="dv">3</span></a>
<a class="sourceLine" id="cb12-8" data-line-number="8"> â”‚â””â”¤</a>
<a class="sourceLine" id="cb12-9" data-line-number="9"> â”‚ â””<span class="dv">4</span></a>
<a class="sourceLine" id="cb12-10" data-line-number="10">â”Œâ”¤</a>
<a class="sourceLine" id="cb12-11" data-line-number="11">â”‚â”‚ â”Œ<span class="dv">5</span></a>
<a class="sourceLine" id="cb12-12" data-line-number="12">â”‚â”‚â”Œâ”¤</a>
<a class="sourceLine" id="cb12-13" data-line-number="13">â”‚â”‚â”‚â””<span class="dv">6</span></a>
<a class="sourceLine" id="cb12-14" data-line-number="14">â”‚â””â”¤</a>
<a class="sourceLine" id="cb12-15" data-line-number="15">â”‚ â”‚â”Œ<span class="dv">7</span></a>
<a class="sourceLine" id="cb12-16" data-line-number="16">â”‚ â””â”¤</a>
<a class="sourceLine" id="cb12-17" data-line-number="17">â”‚  â””<span class="dv">8</span></a>
<a class="sourceLine" id="cb12-18" data-line-number="18">â”¤</a>
<a class="sourceLine" id="cb12-19" data-line-number="19">â””<span class="dv">9</span></a></code></pre></div>
<p>That <code class="sourceCode haskell"><span class="dv">9</span></code> hanging out on its own there is a problem.</p>
<h2 id="typewriters-and-slaloms">Typewriters and Slaloms</h2>
<p>One observation we can make is that <code class="sourceCode haskell">pairMap</code> always starts from the same side on each iteration, like a typewriter moving from one line to the next. This has the consequence of building up the leftovers on one side, leaving them until the top level.</p>
<p>We can improve the situation slightly by going back and forth, slalom-style, so we consume leftovers on each iteration:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="ot">treeFold ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">NonEmpty</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">treeFold f <span class="fu">=</span> goTo <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">  </a>
<a class="sourceLine" id="cb13-4" data-line-number="4">  goTo (y <span class="fu">:|</span> []) <span class="fu">=</span> y</a>
<a class="sourceLine" id="cb13-5" data-line-number="5">  goTo (a <span class="fu">:|</span> b <span class="fu">:</span> rest) <span class="fu">=</span> goFro (pairMap f (f a b) rest)</a>
<a class="sourceLine" id="cb13-6" data-line-number="6">  goFro (y <span class="fu">:|</span> []) <span class="fu">=</span> y</a>
<a class="sourceLine" id="cb13-7" data-line-number="7">  goFro (a <span class="fu">:|</span> b <span class="fu">:</span> rest) <span class="fu">=</span> goTo (pairMap (flip f) (f b a) rest)</a>
<a class="sourceLine" id="cb13-8" data-line-number="8"></a>
<a class="sourceLine" id="cb13-9" data-line-number="9">  pairMap f <span class="fu">=</span> go [] <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-10" data-line-number="10">    go ys y (a<span class="fu">:</span>b<span class="fu">:</span>rest) <span class="fu">=</span> go (y<span class="fu">:</span>ys) (f a b) rest</a>
<a class="sourceLine" id="cb13-11" data-line-number="11">    go ys y [z] <span class="fu">=</span> z <span class="fu">:|</span> y <span class="fu">:</span> ys</a>
<a class="sourceLine" id="cb13-12" data-line-number="12">    go ys y [] <span class="fu">=</span> y <span class="fu">:|</span> ys</a></code></pre></div>
<p>Notice that we have to flip the combining function to make sure the ordering is the same on output. For the earlier example, this solves the issue:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> (treeFold (<span class="fu">:*:</span>) <span class="fu">.</span> fmap <span class="dt">Leaf</span>) [<span class="dv">1</span><span class="fu">..</span><span class="dv">9</span>]</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">(((<span class="dv">1</span><span class="fu">*</span><span class="dv">2</span>)<span class="fu">*</span>((<span class="dv">3</span><span class="fu">*</span><span class="dv">4</span>)<span class="fu">*</span>(<span class="dv">5</span><span class="fu">*</span><span class="dv">6</span>)))<span class="fu">*</span>((<span class="dv">7</span><span class="fu">*</span><span class="dv">8</span>)<span class="fu">*</span><span class="dv">9</span>))</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">  â”Œ<span class="dv">1</span></a>
<a class="sourceLine" id="cb14-4" data-line-number="4"> â”Œâ”¤</a>
<a class="sourceLine" id="cb14-5" data-line-number="5"> â”‚â””<span class="dv">2</span></a>
<a class="sourceLine" id="cb14-6" data-line-number="6">â”Œâ”¤</a>
<a class="sourceLine" id="cb14-7" data-line-number="7">â”‚â”‚ â”Œ<span class="dv">3</span></a>
<a class="sourceLine" id="cb14-8" data-line-number="8">â”‚â”‚â”Œâ”¤</a>
<a class="sourceLine" id="cb14-9" data-line-number="9">â”‚â”‚â”‚â””<span class="dv">4</span></a>
<a class="sourceLine" id="cb14-10" data-line-number="10">â”‚â””â”¤</a>
<a class="sourceLine" id="cb14-11" data-line-number="11">â”‚ â”‚â”Œ<span class="dv">5</span></a>
<a class="sourceLine" id="cb14-12" data-line-number="12">â”‚ â””â”¤</a>
<a class="sourceLine" id="cb14-13" data-line-number="13">â”‚  â””<span class="dv">6</span></a>
<a class="sourceLine" id="cb14-14" data-line-number="14">â”¤</a>
<a class="sourceLine" id="cb14-15" data-line-number="15">â”‚ â”Œ<span class="dv">7</span></a>
<a class="sourceLine" id="cb14-16" data-line-number="16">â”‚â”Œâ”¤</a>
<a class="sourceLine" id="cb14-17" data-line-number="17">â”‚â”‚â””<span class="dv">8</span></a>
<a class="sourceLine" id="cb14-18" data-line-number="18">â””â”¤</a>
<a class="sourceLine" id="cb14-19" data-line-number="19"> â””<span class="dv">9</span></a></code></pre></div>
<p>It does <em>not</em> build up the tree as balanced as it possibly could, though:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> (treeFold (<span class="fu">:*:</span>) <span class="fu">.</span> fmap <span class="dt">Leaf</span>) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">((<span class="dv">1</span><span class="fu">*</span><span class="dv">2</span>)<span class="fu">*</span>((<span class="dv">3</span><span class="fu">*</span><span class="dv">4</span>)<span class="fu">*</span>(<span class="dv">5</span><span class="fu">*</span><span class="dv">6</span>)))</a>
<a class="sourceLine" id="cb15-3" data-line-number="3"> â”Œ<span class="dv">1</span></a>
<a class="sourceLine" id="cb15-4" data-line-number="4">â”Œâ”¤</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">â”‚â””<span class="dv">2</span></a>
<a class="sourceLine" id="cb15-6" data-line-number="6">â”¤</a>
<a class="sourceLine" id="cb15-7" data-line-number="7">â”‚ â”Œ<span class="dv">3</span></a>
<a class="sourceLine" id="cb15-8" data-line-number="8">â”‚â”Œâ”¤</a>
<a class="sourceLine" id="cb15-9" data-line-number="9">â”‚â”‚â””<span class="dv">4</span></a>
<a class="sourceLine" id="cb15-10" data-line-number="10">â””â”¤</a>
<a class="sourceLine" id="cb15-11" data-line-number="11"> â”‚â”Œ<span class="dv">5</span></a>
<a class="sourceLine" id="cb15-12" data-line-number="12"> â””â”¤</a>
<a class="sourceLine" id="cb15-13" data-line-number="13">  â””<span class="dv">6</span></a></code></pre></div>
<p>Thereâ€™s four elements in the right branch, and two in the left in the above example. Three in each would be optimal.</p>
<p>Waitâ€”optimal in what sense, exactly? What do we mean when we say one tree is more balanced than another? Letâ€™s say the â€œbalance factorâ€ is the largest difference in size of two sibling trees:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="ot">balFac ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2">balFac <span class="fu">=</span> fst <span class="fu">.</span> go <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3"><span class="ot">  go ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> (<span class="dt">Integer</span>, <span class="dt">Integer</span>)</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">  go (<span class="dt">Leaf</span> _) <span class="fu">=</span> (<span class="dv">0</span>, <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb16-5" data-line-number="5">  go (l <span class="fu">:*:</span> r) <span class="fu">=</span> (lb <span class="ot">`max`</span> rb <span class="ot">`max`</span> abs (rs <span class="fu">-</span> ls), rs <span class="fu">+</span> ls) <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-6" data-line-number="6">    (lb,ls) <span class="fu">=</span> go l</a>
<a class="sourceLine" id="cb16-7" data-line-number="7">    (rb,rs) <span class="fu">=</span> go r</a></code></pre></div>
<p>And one tree is more balanced than another if it has a smaller balance factor.</p>
<p>Thereâ€™s effectively no limit on the balance factor for the typewriter method: when the input is one larger than a power of two, itâ€™ll stick the one extra in one branch and the rest in another (as with <code class="sourceCode haskell">[<span class="dv">1</span><span class="fu">..</span><span class="dv">9</span>]</code> in the example above).</p>
<p>For the slalom method, it looks like thereâ€™s something more interesting going on, limit-wise. I havenâ€™t been able to verify this formally (yet), but from what I can tell, a tree of height <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> will have at most a balance factor of the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>th <a href="https://oeis.org/A001045">Jacobsthal number</a>. Thatâ€™s (apparently) also the number of ways to tie a tie using <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n + 2</annotation></semantics></math> turns.</p>
<p>That was just gathered from some quick experiments and <a href="https://oeis.org/">oeis.org</a>, but it seems to make sense intuitively. Jacobsthal numbers are defined like this:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1">j <span class="dv">0</span> <span class="fu">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2">j <span class="dv">1</span> <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb17-3" data-line-number="3">j n <span class="fu">=</span> j (n<span class="fu">-</span><span class="dv">1</span>) <span class="fu">+</span> <span class="dv">2</span> <span class="fu">*</span> j (n<span class="fu">-</span><span class="dv">2</span>)</a></code></pre></div>
<p>So, at the top level, thereâ€™s the imbalance caused by the second-last <code class="sourceCode haskell">pairFold</code>, plus the imbalance caused by the third-to-last. However, the third-to-last imbalance is twice what it was at that level, because it is now working with an already-paired-up list. Why isnâ€™t the second last imbalance also doubled? Because itâ€™s counteracted by the fact that we turned around: the imbalance is in an element thatâ€™s a leftover element. At least thatâ€™s what my intuition is at this point.</p>
<p>The minimum balance factor is, of course, one. Unfortunately, to achieve that, I lost some of the properties of the previous folds:</p>
<h2 id="lengths">Lengths</h2>
<p>Up until now, I have been avoiding taking the length of the incoming list. It would lose a lot of laziness, cause an extra traversal, and generally seems like an ugly solution. Nonetheless, it gives the most balanced results I could find so far:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="ot">treeFold ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">NonEmpty</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">treeFold f (x<span class="fu">:|</span>xs) <span class="fu">=</span> go (length (x<span class="fu">:</span>xs)) (x<span class="fu">:</span>xs) <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3">  go <span class="dv">1</span> [y] <span class="fu">=</span> y</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">  go n ys <span class="fu">=</span> f (go m a) (go (n<span class="fu">-</span>m) b) <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-5" data-line-number="5">    (a,b) <span class="fu">=</span> splitAt m ys </a>
<a class="sourceLine" id="cb18-6" data-line-number="6">    m <span class="fu">=</span> n <span class="ot">`div`</span> <span class="dv">2</span></a></code></pre></div>
<p><code class="sourceCode haskell">splitAt</code> is an inefficient operation, but if we let the left-hand call return its unused input from the list, we can avoid it:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="ot">treeFold ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">NonEmpty</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">treeFold f (x<span class="fu">:|</span>xs) <span class="fu">=</span> fst (go (length (x<span class="fu">:</span>xs)) (x<span class="fu">:</span>xs)) <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-3" data-line-number="3">  go <span class="dv">1</span> (y<span class="fu">:</span>ys) <span class="fu">=</span> (y,ys)</a>
<a class="sourceLine" id="cb19-4" data-line-number="4">  go n ys <span class="fu">=</span> (f l r, rs) <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-5" data-line-number="5">    (l,ls) <span class="fu">=</span> go m ys</a>
<a class="sourceLine" id="cb19-6" data-line-number="6">    (r,rs) <span class="fu">=</span> go (n<span class="fu">-</span>m) ls</a>
<a class="sourceLine" id="cb19-7" data-line-number="7">    m <span class="fu">=</span> n <span class="ot">`div`</span> <span class="dv">2</span></a></code></pre></div>
<p>Finally, you may have spotted the state monad in this last version. We can make the similarity explicit:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="ot">treeFold ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">NonEmpty</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb20-2" data-line-number="2">treeFold f (x<span class="fu">:|</span>xs) <span class="fu">=</span> evalState (go (length (x<span class="fu">:</span>xs))) (x<span class="fu">:</span>xs) <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-3" data-line-number="3">  go <span class="dv">1</span> <span class="fu">=</span> state (\(y<span class="fu">:</span>ys) <span class="ot">-&gt;</span> (y,ys))</a>
<a class="sourceLine" id="cb20-4" data-line-number="4">  go n <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb20-5" data-line-number="5">    <span class="kw">let</span> m <span class="fu">=</span> n <span class="ot">`div`</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb20-6" data-line-number="6">    l <span class="ot">&lt;-</span> go m</a>
<a class="sourceLine" id="cb20-7" data-line-number="7">    r <span class="ot">&lt;-</span> go (n<span class="fu">-</span>m)</a>
<a class="sourceLine" id="cb20-8" data-line-number="8">    return (f l r)</a></code></pre></div>
<p>And there you have it: three different ways to fold in a more balanced way. Perhaps surprisingly, the first is the fastest in my tests. Iâ€™d love to hear if thereâ€™s a more balanced version (which is lazy, ideally) that is just as efficient as the first implementation.</p>
<h1 id="stable-summation">Stable Summation</h1>
<p>I have found two other uses for these folds other than simply constructing more balanced binary trees. The first is summation of floating-point numbers. If you sum floating-point numbers in the usual way with <code class="sourceCode haskell">foldl&#39;</code> (or, indeed, with an accumulator in an imperative language), you will see an error growth of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n)</annotation></semantics></math>, where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> is the number of floats youâ€™re summing.</p>
<p>A well-known solution to this problem is the <a href="https://en.wikipedia.org/wiki/Kahan_summation_algorithm">Kahan summation algorithm</a>. It carries with it a running compensation for accumulating errors, giving it <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math> error growth. There are two downsides to the algorithm: it takes four times the number of numerical operations to perform, and isnâ€™t parallel.</p>
<p>For that reason, itâ€™s often not used in practice: instead, floats are summed <em>pairwise</em>, in a manner often referred to as <a href="https://en.wikipedia.org/wiki/Pairwise_summation">cascade summation</a>. This is whatâ€™s used in <a href="https://github.com/numpy/numpy/pull/3685">NumPy</a>. The error growth isnâ€™t quite as goodâ€”<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ğ’ª</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log{n})</annotation></semantics></math>â€”but it takes the exact same number of operations as normal summation. On top of that:</p>
<h1 id="parallelization">Parallelization</h1>
<p>Dividing a fold into roughly-equal chunks is exactly the kind of problem encountered when trying to parallelize certain algorithms. Adapting the folds above so that their work is performed in parallel is surprisingly easy:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="ot">splitPar ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">splitPar f <span class="fu">=</span> go</a>
<a class="sourceLine" id="cb21-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-4" data-line-number="4">    go l r <span class="dv">0</span> <span class="fu">=</span> f (l <span class="dv">0</span>) (r <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb21-5" data-line-number="5">    go l r n <span class="fu">=</span> lt <span class="ot">`par`</span> (rt <span class="ot">`pseq`</span> f lt rt)</a>
<a class="sourceLine" id="cb21-6" data-line-number="6">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-7" data-line-number="7">        lt <span class="fu">=</span> l (n<span class="fu">-</span>m)</a>
<a class="sourceLine" id="cb21-8" data-line-number="8">        rt <span class="fu">=</span> r m</a>
<a class="sourceLine" id="cb21-9" data-line-number="9">        m <span class="fu">=</span> n <span class="ot">`div`</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb21-10" data-line-number="10"></a>
<a class="sourceLine" id="cb21-11" data-line-number="11"><span class="ot">treeFoldParallel ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">NonEmpty</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb21-12" data-line-number="12">treeFoldParallel f xs <span class="fu">=</span></a>
<a class="sourceLine" id="cb21-13" data-line-number="13">    treeFold const (splitPar f) xs numCapabilities</a></code></pre></div>
<p>The above will split the fold into <code class="sourceCode haskell">numCapabilities</code> chunks, and perform each one in parallel. <code class="sourceCode haskell">numCapabilities</code> is a constant defined in <a href="https://hackage.haskell.org/package/base-4.10.0.0/docs/GHC-Conc.html">GHC.Conc</a>: itâ€™s the number of threads which can be run simultaneously at any one time. Alternatively, you could the function include a parameter for how many chunks to split the computation into. You could also have the fold adapt as it went, choosing whether or not to spark based on how many sparks exist at any given time:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="ot">parseq ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb22-2" data-line-number="2">parseq a b <span class="fu">=</span></a>
<a class="sourceLine" id="cb22-3" data-line-number="3">    runST</a>
<a class="sourceLine" id="cb22-4" data-line-number="4">        (bool (par a b) (seq a b) <span class="fu">&lt;$&gt;</span></a>
<a class="sourceLine" id="cb22-5" data-line-number="5">         unsafeIOToST (liftA2 (<span class="fu">&gt;</span>) numSparks getNumCapabilities))</a>
<a class="sourceLine" id="cb22-6" data-line-number="6"></a>
<a class="sourceLine" id="cb22-7" data-line-number="7"><span class="ot">treeFoldAdaptive ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb22-8" data-line-number="8">treeFoldAdaptive f <span class="fu">=</span></a>
<a class="sourceLine" id="cb22-9" data-line-number="9">    Lazy.treeFold</a>
<a class="sourceLine" id="cb22-10" data-line-number="10">        (\l r <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb22-11" data-line-number="11">              r <span class="ot">`parseq`</span> (l <span class="ot">`parseq`</span> f l r))</a></code></pre></div>
<p>Adapted from <a href="https://www.reddit.com/r/haskell/comments/73umrw/another_parallelism_primitive_parseq/dnurduu/?utm_content=permalink&amp;utm_medium=front&amp;utm_source=reddit&amp;utm_name=haskell">this</a> comment by Edward Kmett. This is actually the fastest version of all the folds.</p>
<p>All of this is provided in a <a href="https://hackage.haskell.org/package/treefold">library</a> Iâ€™ve put up on Hackage.</p>
]]></description>
    <pubDate>Mon, 30 Oct 2017 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2017-10-30-balancing-folds.html</guid>
    <dc:creator>Donnacha OisÃ­n Kidney</dc:creator>
</item>
<item>
    <title>Convolutions and Semirings</title>
    <link>https://doisinkidney.com/posts/2017-10-13-convolutions-and-semirings.html</link>
    <description><![CDATA[<div class="info">
    Posted on October 13, 2017
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Semirings.html">Semirings</a>
    
</div>

<p>I have been working a little more on my <a href="https://hackage.haskell.org/package/semiring-num">semirings library</a> recently, and I have come across some interesting functions in the process. First, a quick recap on the <code class="sourceCode haskell"><span class="dt">Semiring</span></code> class and some related functions:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Semiring</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="ot">  one ::</span> a</a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="ot">  zero ::</span> a</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">  <span class="kw">infixl</span> <span class="dv">6</span> <span class="fu">&lt;+&gt;</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="ot">  (&lt;+&gt;) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">  <span class="kw">infixl</span> <span class="dv">7</span> <span class="fu">&lt;.&gt;</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="ot">  (&lt;.&gt;) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb1-8" data-line-number="8"></a>
<a class="sourceLine" id="cb1-9" data-line-number="9"><span class="ot">add ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Semiring</span> a) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb1-10" data-line-number="10">add <span class="fu">=</span> foldl&#39; (<span class="fu">&lt;+&gt;</span>) zero</a>
<a class="sourceLine" id="cb1-11" data-line-number="11"></a>
<a class="sourceLine" id="cb1-12" data-line-number="12"><span class="ot">mul ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Semiring</span> a) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb1-13" data-line-number="13">mul <span class="fu">=</span> foldl&#39; (<span class="fu">&lt;.&gt;</span>) one</a>
<a class="sourceLine" id="cb1-14" data-line-number="14"></a>
<a class="sourceLine" id="cb1-15" data-line-number="15"><span class="kw">instance</span> <span class="dt">Semiring</span> <span class="dt">Integer</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-16" data-line-number="16">  one <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-17" data-line-number="17">  zero <span class="fu">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb1-18" data-line-number="18">  (<span class="fu">&lt;+&gt;</span>) <span class="fu">=</span> (<span class="fu">+</span>)</a>
<a class="sourceLine" id="cb1-19" data-line-number="19">  (<span class="fu">&lt;.&gt;</span>) <span class="fu">=</span> (<span class="fu">*</span>)</a>
<a class="sourceLine" id="cb1-20" data-line-number="20"></a>
<a class="sourceLine" id="cb1-21" data-line-number="21"><span class="kw">instance</span> <span class="dt">Semiring</span> <span class="dt">Bool</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-22" data-line-number="22">  one <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb1-23" data-line-number="23">  zero <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb1-24" data-line-number="24">  (<span class="fu">&lt;+&gt;</span>) <span class="fu">=</span> (<span class="fu">||</span>)</a>
<a class="sourceLine" id="cb1-25" data-line-number="25">  (<span class="fu">&lt;.&gt;</span>) <span class="fu">=</span> (<span class="fu">&amp;&amp;</span>)</a></code></pre></div>
<p>You can think of it as a replacement for <code class="sourceCode haskell"><span class="dt">Num</span></code>, but it turns out to be much more generally useful than that.</p>
<h1 id="matrix-multiplication">Matrix Multiplication</h1>
<p>The first interesting function is to do with matrix multiplication. Hereâ€™s the code for multiplying two matrices represented as nested lists:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">mulMatrix ::</span> <span class="dt">Semiring</span> a <span class="ot">=&gt;</span> [[a]] <span class="ot">-&gt;</span> [[a]] <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">mulMatrix xs ys <span class="fu">=</span> map (\row <span class="ot">-&gt;</span> map (add <span class="fu">.</span> zipWith (<span class="fu">&lt;.&gt;</span>) row) cs) xs</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">    cs <span class="fu">=</span> transpose ys</a></code></pre></div>
<p>One of the issues with this code (other than its woeful performance) is that it seems needlessly list-specific. <code class="sourceCode haskell">zipWith</code> seems like the kind of thing that exists on a bunch of different structures. Indeed, the <a href="https://hackage.haskell.org/package/base-4.10.0.0/docs/Control-Applicative.html#t:ZipList"><code class="sourceCode haskell"><span class="dt">ZipList</span></code> wrapper</a> uses <code class="sourceCode haskell">zipWith</code> as its <code class="sourceCode haskell"><span class="fu">&lt;*&gt;</span></code> implementation. Letâ€™s try that for now:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">mulMatrix ::</span> (<span class="dt">Semiring</span> a, <span class="dt">Applicative</span> f) <span class="ot">=&gt;</span> f (f a) <span class="ot">-&gt;</span> f (f a) <span class="ot">-&gt;</span> f (f a)</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">mulMatrix xs ys <span class="fu">=</span> fmap (\row <span class="ot">-&gt;</span> fmap (add <span class="fu">.</span> liftA2 (<span class="fu">&lt;.&gt;</span>) row) cs) xs</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">    cs <span class="fu">=</span> transpose ys</a></code></pre></div>
<p>Of course, now <code class="sourceCode haskell">add</code> needs to work on our <code class="sourceCode haskell">f</code>, so it should be <code class="sourceCode haskell"><span class="dt">Foldable</span></code></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">mulMatrix </a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="ot">  ::</span> (<span class="dt">Semiring</span> a, <span class="dt">Applicative</span> f, <span class="dt">Foldable</span> f) </a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  <span class="ot">=&gt;</span> f (f a) <span class="ot">-&gt;</span> f (f a) <span class="ot">-&gt;</span> f (f a)</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">mulMatrix <span class="fu">=</span> <span class="fu">...</span></a></code></pre></div>
<p><code class="sourceCode haskell">transpose</code> is the missing piece now. A little bit of <code class="sourceCode haskell"><span class="dt">Applicative</span></code> magic can help us out again, though: <code class="sourceCode haskell">sequenceA</code> is <code class="sourceCode haskell">transpose</code> on <code class="sourceCode haskell"><span class="dt">ZipList</span></code>s <span class="citation" data-cites="mcbride_applicative_2008">(McBride and Paterson <a href="#ref-mcbride_applicative_2008">2008</a>)</span>.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1">mulMatrix </a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="ot">  ::</span> (<span class="dt">Semiring</span> a, <span class="dt">Applicative</span> f, <span class="dt">Traversable</span> f) </a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  <span class="ot">=&gt;</span> f (f a) <span class="ot">-&gt;</span> f (f a) <span class="ot">-&gt;</span> f (f a)</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">mulMatrix xs ys <span class="fu">=</span> </a>
<a class="sourceLine" id="cb5-5" data-line-number="5">    fmap (\row <span class="ot">-&gt;</span> fmap (add <span class="fu">.</span> liftA2 (<span class="fu">&lt;.&gt;</span>) row) cs) xs</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-7" data-line-number="7">    cs <span class="fu">=</span> sequenceA ys</a></code></pre></div>
<p>One further generalization: The two <code class="sourceCode haskell">f</code>s donâ€™t actually need to be the same:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1">mulMatrix</a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="ot">    ::</span> (<span class="dt">Applicative</span> n</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">       ,<span class="dt">Traversable</span> m</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">       ,<span class="dt">Applicative</span> m</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">       ,<span class="dt">Applicative</span> p</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">       ,<span class="dt">Semiring</span> a)</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">    <span class="ot">=&gt;</span> n (m a) <span class="ot">-&gt;</span> m (p a) <span class="ot">-&gt;</span> n (p a)</a>
<a class="sourceLine" id="cb6-8" data-line-number="8">mulMatrix xs ys <span class="fu">=</span> fmap (\row <span class="ot">-&gt;</span> fmap (add <span class="fu">.</span> liftA2 (<span class="fu">&lt;.&gt;</span>) row) cs) xs</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-10" data-line-number="10">    cs <span class="fu">=</span> sequenceA ys</a></code></pre></div>
<p>Happily, the way that the wrappers (<code class="sourceCode haskell">n</code>, <code class="sourceCode haskell">m</code>, and <code class="sourceCode haskell">p</code>) match up coincides precisely with how matrix dimensions match up in matrix multiplication. Quoting from the <a href="https://en.wikipedia.org/wiki/Matrix_multiplication">Wikipedia definition</a>:</p>
<blockquote>
<p>if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math> is an <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>Ã—</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n \times m</annotation></semantics></math> matrix and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math> is an <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>Ã—</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">m \times p</annotation></semantics></math> matrix, their matrix product <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">AB</annotation></semantics></math> is an <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>Ã—</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">n \times p</annotation></semantics></math> matrix</p>
</blockquote>
<p>This function is present in the <a href="https://hackage.haskell.org/package/linear-1.20.7/docs/Linear-Matrix.html#v:-33--42--33-">linear package</a> with some different constraints. In fairness, <code class="sourceCode haskell"><span class="dt">Applicative</span></code> probably isnâ€™t the best thing to use here since it doesnâ€™t work for so many instances (<a href="https://hackage.haskell.org/package/base-4.10.0.0/docs/Control-Monad-Zip.html"><code class="sourceCode haskell"><span class="dt">MonadZip</span></code></a> or something similar may be more suitable), but itâ€™s very handy to have, and works out-of the box for types like:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Three</span> a </a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">Three</span> a a a </a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  <span class="kw">deriving</span> (<span class="dt">Functor</span>, <span class="dt">Foldable</span>, <span class="dt">Traversable</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb7-4" data-line-number="4"></a>
<a class="sourceLine" id="cb7-5" data-line-number="5"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Three</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6">  pure x <span class="fu">=</span> <span class="dt">Three</span> x x x</a>
<a class="sourceLine" id="cb7-7" data-line-number="7">  <span class="dt">Three</span> fx fy fz <span class="fu">&lt;*&gt;</span> <span class="dt">Three</span> xx xy xz <span class="fu">=</span> <span class="dt">Three</span> (fx xx) (fy xy) (fz xz)</a></code></pre></div>
<p>Which makes it (to my mind) useful enough to keep. Also, it hugely simplified the code for <a href="https://github.com/oisdk/Square/blob/master/src/Data/Square.hs#L183">matrix multiplication in square matrices</a> I had, from <span class="citation" data-cites="okasaki_fast_1999">Okasaki (<a href="#ref-okasaki_fast_1999">1999</a>)</span>.</p>
<h1 id="convolutions">Convolutions</h1>
<p>If youâ€™re putting a general class in a library that you want people to use, and there exist sensible instances for common Haskell types, you should probably provide those instances in the library to avoid orphans. The meaning of â€œsensibleâ€ here is vague: generally speaking, if there is only one obvious or clear instance, then itâ€™s sensible. For a list instance for the semiring class, for instance, I could figure out several law-abiding definitions for <code class="sourceCode haskell"><span class="fu">&lt;+&gt;</span></code>, <code class="sourceCode haskell">one</code> and <code class="sourceCode haskell">zero</code>, but only one for <code class="haskel">&lt;.&gt;</code>: polynomial multiplication. You know, where you multiply two polynomials like so:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><mn>2</mn><mi>x</mi><mo>+</mo><mn>3</mn><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><mn>5</mn><mi>x</mi><mo>+</mo><mn>3</mn><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>4</mn><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mn>9</mn><msup><mi>x</mi><mn>5</mn></msup><mo>+</mo><mn>15</mn><msup><mi>x</mi><mn>4</mn></msup><mo>+</mo><mn>18</mn><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><mn>28</mn><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>38</mn><mi>x</mi><mo>+</mo><mn>24</mn></mrow><annotation encoding="application/x-tex">(x^3 + 2x + 3)(5x + 3x^2 + 4) = 9x^5 + 15x^4 + 18x^3 + 28x^2 + 38x + 24</annotation></semantics></math></p>
<p>A more general definition looks something like this:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msub><mi>a</mi><mn>0</mn></msub><msup><mi>x</mi><mn>0</mn></msup><mo>+</mo><msub><mi>a</mi><mn>1</mn></msub><msup><mi>x</mi><mn>1</mn></msup><mo>+</mo><msub><mi>a</mi><mn>2</mn></msub><msup><mi>x</mi><mn>2</mn></msup><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>b</mi><mn>0</mn></msub><msup><mi>x</mi><mn>0</mn></msup><mo>+</mo><msub><mi>b</mi><mn>1</mn></msub><msup><mi>x</mi><mn>1</mn></msup><mo>+</mo><msub><mi>b</mi><mn>2</mn></msub><msup><mi>x</mi><mn>2</mn></msup><mo stretchy="false" form="postfix">)</mo><mo>=</mo></mrow><annotation encoding="application/x-tex">(a_0x^0 + a_1x^1 + a_2x^2)(b_0x^0 + b_1x^1 + b_2x^2) =</annotation></semantics></math> <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>0</mn></msub><msub><mi>b</mi><mn>0</mn></msub><msup><mi>x</mi><mn>0</mn></msup><mo>+</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>a</mi><mn>0</mn></msub><msub><mi>b</mi><mn>1</mn></msub><mo>+</mo><msub><mi>a</mi><mn>1</mn></msub><msub><mi>b</mi><mn>0</mn></msub><mo stretchy="false" form="postfix">)</mo><msup><mi>x</mi><mn>1</mn></msup><mo>+</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>a</mi><mn>0</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mo>+</mo><msub><mi>a</mi><mn>1</mn></msub><msub><mi>b</mi><mn>1</mn></msub><mo>+</mo><msub><mi>a</mi><mn>2</mn></msub><msub><mi>b</mi><mn>0</mn></msub><mo stretchy="false" form="postfix">)</mo><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>a</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mo>+</mo><msub><mi>a</mi><mn>2</mn></msub><msub><mi>b</mi><mn>1</mn></msub><mo stretchy="false" form="postfix">)</mo><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><msub><mi>a</mi><mn>2</mn></msub><msub><mi>b</mi><mn>2</mn></msub><msup><mi>x</mi><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">a_0b_0x^0 + (a_0b_1 + a_1b_0)x^1 + (a_0b_2 + a_1b_1 + a_2b_0)x^2 + (a_1b_2 + a_2b_1)x^3 + a_2b_2x^4</annotation></semantics></math></p>
<p>Or, fully generalized:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>k</mi></msub><mo>=</mo><msub><mi>a</mi><mn>0</mn></msub><msub><mi>b</mi><mi>k</mi></msub><mo>+</mo><msub><mi>a</mi><mn>1</mn></msub><msub><mi>b</mi><mrow><mi>k</mi><mo>âˆ’</mo><mn>1</mn></mrow></msub><mo>+</mo><mi>â€¦</mi><mo>+</mo><msub><mi>a</mi><mrow><mi>k</mi><mo>âˆ’</mo><mn>1</mn></mrow></msub><msub><mi>b</mi><mn>1</mn></msub><mo>+</mo><msub><mi>a</mi><mi>k</mi></msub><msub><mi>b</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">c_k = a_0b_k + a_1b_{k-1} + \ldots + a_{k-1}b_1 + a_kb_0</annotation></semantics></math> <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>Ã—</mo><mi>g</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><munderover><mo>âˆ‘</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>n</mi><mo>+</mo><mi>m</mi></mrow></munderover><msub><mi>c</mi><mi>i</mi></msub><msup><mi>x</mi><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">f(x) \times g(x) = \sum_{i=0}^{n+m}c_ix^i</annotation></semantics></math></p>
<p>So it turns out that you can represent polynomials pretty elegantly as lists. Take an example from above:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><mn>2</mn><mi>x</mi><mo>+</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">x^3 + 2x + 3</annotation></semantics></math></p>
<p>And rearrange it in order of the powers of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><msup><mi>x</mi><mn>0</mn></msup><mo>+</mo><mn>2</mn><msup><mi>x</mi><mn>1</mn></msup><mo>+</mo><msup><mi>x</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">3x^0 + 2x^1 + x^3</annotation></semantics></math></p>
<p>And fill in missing coefficients:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><msup><mi>x</mi><mn>0</mn></msup><mo>+</mo><mn>2</mn><msup><mi>x</mi><mn>1</mn></msup><mo>+</mo><mn>0</mn><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>1</mn><msup><mi>x</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">3x^0 + 2x^1 + 0x^2 + 1x^3</annotation></semantics></math></p>
<p>And then the list representation of that polynomial is the list of those coefficients:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">[<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">0</span>, <span class="dv">1</span>]</a></code></pre></div>
<p>For me, the definitions of multiplication above were pretty hard to understand. In Haskell, however, the definition is quite beautiful:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Semiring</span> a <span class="ot">=&gt;</span> <span class="dt">Semiring</span> [a] <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">  one <span class="fu">=</span> [one]</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  zero <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">  [] <span class="fu">&lt;+&gt;</span> ys <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  xs <span class="fu">&lt;+&gt;</span> [] <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb9-6" data-line-number="6">  (x<span class="fu">:</span>xs) <span class="fu">&lt;+&gt;</span> (y<span class="fu">:</span>ys) <span class="fu">=</span> x <span class="fu">&lt;+&gt;</span> y <span class="fu">:</span> (xs <span class="fu">&lt;+&gt;</span> ys)</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">  _ <span class="fu">&lt;.&gt;</span> [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb9-8" data-line-number="8">  [] <span class="fu">&lt;.&gt;</span> _ <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb9-9" data-line-number="9">  (x<span class="fu">:</span>xs) <span class="fu">&lt;.&gt;</span> (y<span class="fu">:</span>ys) <span class="fu">=</span> (x<span class="fu">&lt;.&gt;</span>y) <span class="fu">:</span> map (x<span class="fu">&lt;.&gt;</span>) ys <span class="fu">&lt;+&gt;</span> xs <span class="fu">&lt;.&gt;</span> (y<span class="fu">:</span>ys)</a></code></pre></div>
<p>This definition for <code class="sourceCode haskell"><span class="fu">&lt;.&gt;</span></code> can be found on page 4 of <span class="citation" data-cites="mcilroy_power_1999">McIlroy (<a href="#ref-mcilroy_power_1999">1999</a>)</span>. Although there was a version of the paper with a slightly different definition:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">_ <span class="fu">&lt;.&gt;</span> [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">[] <span class="fu">&lt;.&gt;</span> _ <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">(x<span class="fu">:</span>xs) <span class="fu">&lt;.&gt;</span> (y<span class="fu">:</span>ys) </a>
<a class="sourceLine" id="cb10-4" data-line-number="4">  <span class="fu">=</span> (x<span class="fu">&lt;.&gt;</span>y) <span class="fu">:</span> (map (x<span class="fu">&lt;.&gt;</span>) ys <span class="fu">&lt;+&gt;</span> map (<span class="fu">&lt;.&gt;</span>y) xs <span class="fu">&lt;+&gt;</span> (zero <span class="fu">:</span> (xs <span class="fu">&lt;.&gt;</span> ys)))</a></code></pre></div>
<p>Similar to one which appeared in <span class="citation" data-cites="dolan_fun_2013">Dolan (<a href="#ref-dolan_fun_2013">2013</a>)</span>.</p>
<p>As it happens, I prefer the first definition. Itâ€™s shorter, and I figured out how to write it as a fold:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1">_ <span class="fu">&lt;.&gt;</span> [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">xs <span class="fu">&lt;.&gt;</span> ys <span class="fu">=</span> foldr f [] xs <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  f x zs <span class="fu">=</span> map (x <span class="fu">&lt;.&gt;</span>) ys <span class="fu">&lt;+&gt;</span> (zero <span class="fu">:</span> zs)</a></code></pre></div>
<p>And if you inline the <code class="sourceCode haskell"><span class="fu">&lt;+&gt;</span></code>, you get a reasonable speedup:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1">xs <span class="fu">&lt;.&gt;</span> ys <span class="fu">=</span> foldr f [] xs</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">    f x zs <span class="fu">=</span> foldr (g x) id ys (zero <span class="fu">:</span> zs)</a>
<a class="sourceLine" id="cb12-4" data-line-number="4">    g x y a (z<span class="fu">:</span>zs) <span class="fu">=</span> x <span class="fu">&lt;.&gt;</span> y <span class="fu">&lt;+&gt;</span> z <span class="fu">:</span> a zs</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">    g x y a [] <span class="fu">=</span> x <span class="fu">&lt;.&gt;</span> y <span class="fu">:</span> a []</a></code></pre></div>
<p>The definition of <code class="sourceCode haskell"><span class="fu">&lt;+&gt;</span></code> can also use a fold on either side for fusion purposes:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1">(<span class="fu">&lt;+&gt;</span>) <span class="fu">=</span> foldr f id <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">  f x xs (y<span class="fu">:</span>ys) <span class="fu">=</span> x <span class="fu">&lt;+&gt;</span> y <span class="fu">:</span> xs ys</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">  f x xs [] <span class="fu">=</span> x <span class="fu">:</span> xs []</a>
<a class="sourceLine" id="cb13-4" data-line-number="4"></a>
<a class="sourceLine" id="cb13-5" data-line-number="5">(<span class="fu">&lt;+&gt;</span>) <span class="fu">=</span> flip (foldr f id) <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-6" data-line-number="6">  f y ys (x<span class="fu">:</span>xs) <span class="fu">=</span> x <span class="fu">&lt;+&gt;</span> y <span class="fu">:</span> ys xs</a>
<a class="sourceLine" id="cb13-7" data-line-number="7">  f y ys [] <span class="fu">=</span> y <span class="fu">:</span> ys []</a></code></pre></div>
<p>There are rules in the library to choose one of the above definitions if fusion is available.</p>
<p>This definition is much more widely useful than it may seem at first. Say, for instance, you wanted to search through pairs of things from two infinite lists. You canâ€™t use the normal way to pair things for lists, the Cartesian product, because it will diverge:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1">[(x,y) <span class="fu">|</span> x <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span>], y <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span>]]</a>
<a class="sourceLine" id="cb14-2" data-line-number="2"><span class="co">-- [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10)...</span></a></code></pre></div>
<p>Youâ€™ll never get beyond 1 in the first list. Zipping isnâ€™t an option either, because you wonâ€™t really explore the search space, only corresponding pairs. <a href="https://byorgey.wordpress.com/2008/04/22/list-convolutions/">Brent Yorgey showed</a> that if you want a list like this:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1">[(y,x<span class="fu">-</span>y) <span class="fu">|</span> x <span class="ot">&lt;-</span> [<span class="dv">0</span><span class="fu">..</span>], y <span class="ot">&lt;-</span> [<span class="dv">0</span><span class="fu">..</span>x] ]</a>
<a class="sourceLine" id="cb15-2" data-line-number="2"><span class="co">-- [(0,0),(0,1),(1,0),(0,2),(1,1),(2,0),(0,3),(1,2),(2,1),(3,0)...</span></a></code></pre></div>
<p>Then what youâ€™re looking for is a convolution (the same thing as polynomial multiplication). <code class="sourceCode haskell"><span class="fu">&lt;.&gt;</span></code> above can be adapted readily:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="ot">convolve ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [[(a,b)]]</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">convolve xs ys <span class="fu">=</span> foldr f [] xs</a>
<a class="sourceLine" id="cb16-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-4" data-line-number="4">    f x zs <span class="fu">=</span> foldr (g x) id ys ([] <span class="fu">:</span> zs)</a>
<a class="sourceLine" id="cb16-5" data-line-number="5">    g x y a (z<span class="fu">:</span>zs) <span class="fu">=</span> ((x, y) <span class="fu">:</span> z) <span class="fu">:</span> a zs</a>
<a class="sourceLine" id="cb16-6" data-line-number="6">    g x y a [] <span class="fu">=</span> [(x, y)] <span class="fu">:</span> a []</a></code></pre></div>
<p>Flatten out this result to get your ordering. This convolution is a little different from the one in the blog post. By inlining <code class="sourceCode haskell"><span class="fu">&lt;+&gt;</span></code> we can avoid the expensive <code class="sourceCode haskell"><span class="fu">++</span></code> function, without using difference lists.</p>
<h1 id="long-multiplication">Long Multiplication</h1>
<p>Hereâ€™s another cool use of lists as polynomials: they can be used as a <a href="https://en.Wikipedia.org/wiki/Positional_notation">positional numeral system</a>. Most common numeral systems are positional, including Arabic (the system you most likely use, where twenty-four is written as 24) and binary. Non-positional systems are things like Roman numerals. Looking at the Arabic system for now, we see that the way of writing down numbers:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1989</mn><annotation encoding="application/x-tex">1989</annotation></semantics></math></p>
<p>Can be thought of the sum of each digit multiplied by ten to the power of its position:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1989</mn><mo>=</mo><mn>1</mn><mo>Ã—</mo><msup><mn>10</mn><mn>3</mn></msup><mo>+</mo><mn>9</mn><mo>Ã—</mo><msup><mn>10</mn><mn>2</mn></msup><mo>+</mo><mn>8</mn><mo>Ã—</mo><msup><mn>10</mn><mn>1</mn></msup><mo>+</mo><mn>9</mn><mo>Ã—</mo><msup><mn>10</mn><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">1989 = 1 \times 10^3 \plus 9 \times 10^2 \plus 8 \times 10^1 \plus 9 \times 10^0</annotation></semantics></math> <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1989</mn><mo>=</mo><mn>1</mn><mo>Ã—</mo><mn>1000</mn><mo>+</mo><mn>9</mn><mo>Ã—</mo><mn>100</mn><mo>+</mo><mn>8</mn><mo>Ã—</mo><mn>10</mn><mo>+</mo><mn>9</mn><mo>Ã—</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1989 = 1 \times 1000 \plus 9 \times 100 \plus 8 \times 10 \plus 9 \times 1</annotation></semantics></math> <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1989</mn><mo>=</mo><mn>1000</mn><mo>+</mo><mn>900</mn><mo>+</mo><mn>80</mn><mo>+</mo><mn>9</mn></mrow><annotation encoding="application/x-tex">1989 = 1000 \plus 900 \plus 80 \plus 9</annotation></semantics></math> <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1989</mn><mo>=</mo><mn>1989</mn></mrow><annotation encoding="application/x-tex">1989 = 1989</annotation></semantics></math></p>
<p>Where the positions are numbered from the right. In other words, itâ€™s our polynomial list from above in reverse. As well as that, the convolution is long multiplication.</p>
<p>Now, taking this straight off we can try some examples:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="co">-- 12 + 15 = 27</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2">[<span class="dv">2</span>, <span class="dv">1</span>] <span class="fu">&lt;+&gt;</span> [<span class="dv">5</span>, <span class="dv">1</span>] <span class="fu">==</span> [<span class="dv">7</span>, <span class="dv">2</span>]</a>
<a class="sourceLine" id="cb17-3" data-line-number="3"></a>
<a class="sourceLine" id="cb17-4" data-line-number="4"><span class="co">-- 23 * 2 = 46</span></a>
<a class="sourceLine" id="cb17-5" data-line-number="5">[<span class="dv">3</span>, <span class="dv">2</span>] <span class="fu">&lt;.&gt;</span> [<span class="dv">2</span>] <span class="fu">==</span> [<span class="dv">6</span>, <span class="dv">4</span>]</a></code></pre></div>
<p>The issue, of course, is that weâ€™re not handling carrying properly:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1">[<span class="dv">6</span>] <span class="fu">&lt;+&gt;</span> [<span class="dv">6</span>] <span class="fu">==</span> [<span class="dv">12</span>]</a></code></pre></div>
<p>No matter: we can perform all the carries after the addition, and everything works out fine:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1">carry</a>
<a class="sourceLine" id="cb19-2" data-line-number="2"><span class="ot">    ::</span> <span class="dt">Integral</span> a</a>
<a class="sourceLine" id="cb19-3" data-line-number="3">    <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb19-4" data-line-number="4">carry base xs <span class="fu">=</span> foldr f (toBase base) xs <span class="dv">0</span></a>
<a class="sourceLine" id="cb19-5" data-line-number="5">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-6" data-line-number="6">    f e a cin <span class="fu">=</span> r <span class="fu">:</span> a q <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-7" data-line-number="7">      (q,r) <span class="fu">=</span> quotRem (cin <span class="fu">+</span> e) base</a>
<a class="sourceLine" id="cb19-8" data-line-number="8">        </a>
<a class="sourceLine" id="cb19-9" data-line-number="9"><span class="ot">toBase ::</span> <span class="dt">Integral</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb19-10" data-line-number="10">toBase base <span class="fu">=</span> unfoldr f <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-11" data-line-number="11">  f <span class="dv">0</span> <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb19-12" data-line-number="12">  f n <span class="fu">=</span> <span class="dt">Just</span> (swap (quotRem n base))</a></code></pre></div>
<p>Wrap the whole thing in a newtype and we can have a <code class="sourceCode haskell"><span class="dt">Num</span></code> instance:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Positional</span> </a>
<a class="sourceLine" id="cb20-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">Positional</span> </a>
<a class="sourceLine" id="cb20-3" data-line-number="3">  {<span class="ot"> withBase ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> [<span class="dt">Integer</span>] </a>
<a class="sourceLine" id="cb20-4" data-line-number="4">  } </a>
<a class="sourceLine" id="cb20-5" data-line-number="5"></a>
<a class="sourceLine" id="cb20-6" data-line-number="6"><span class="kw">instance</span> <span class="dt">Num</span> <span class="dt">Positional</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-7" data-line-number="7">  <span class="dt">Positional</span> x <span class="fu">+</span> <span class="dt">Positional</span> y <span class="fu">=</span> <span class="dt">Positional</span> (carry <span class="fu">&lt;*&gt;</span> x <span class="fu">&lt;+&gt;</span> y)</a>
<a class="sourceLine" id="cb20-8" data-line-number="8">  <span class="dt">Positional</span> x <span class="fu">*</span> <span class="dt">Positional</span> y <span class="fu">=</span> <span class="dt">Positional</span> (carry <span class="fu">&lt;*&gt;</span> x <span class="fu">&lt;.&gt;</span> y)</a>
<a class="sourceLine" id="cb20-9" data-line-number="9">  fromInteger m <span class="fu">=</span> <span class="dt">Positional</span> (\base <span class="ot">-&gt;</span> toBase base m)</a>
<a class="sourceLine" id="cb20-10" data-line-number="10">  abs <span class="fu">=</span> id</a>
<a class="sourceLine" id="cb20-11" data-line-number="11">  signum <span class="fu">=</span> id</a>
<a class="sourceLine" id="cb20-12" data-line-number="12">  negate <span class="fu">=</span> id</a>
<a class="sourceLine" id="cb20-13" data-line-number="13">  </a>
<a class="sourceLine" id="cb20-14" data-line-number="14"><span class="ot">toDigits ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Positional</span> <span class="ot">-&gt;</span> [<span class="dt">Integer</span>]</a>
<a class="sourceLine" id="cb20-15" data-line-number="15">toDigits base p <span class="fu">=</span> reverse (withBase p base)</a></code></pre></div>
<p>This also lets us choose our base after the fact:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1">sumHundred <span class="fu">=</span> (sum <span class="fu">.</span> map fromInteger) [<span class="dv">1</span><span class="fu">..</span><span class="dv">100</span>]</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">toDigits <span class="dv">10</span> sumHundred</a>
<a class="sourceLine" id="cb21-3" data-line-number="3"><span class="co">-- [5,0,5,0]</span></a>
<a class="sourceLine" id="cb21-4" data-line-number="4">toDigits <span class="dv">2</span> sumHundred</a>
<a class="sourceLine" id="cb21-5" data-line-number="5"><span class="co">-- [1,0,0,1,1,1,0,1,1,1,0,1,0]</span></a></code></pre></div>
<h1 id="vectors">Vectors</h1>
<p>All the hand-optimizing, inlining, and fusion magic in the world wonâ€™t make a list-based implementation of convolution faster than a proper one on vectors, unfortunately. In particular, for larger vectors, a fast Fourier transform can be used. Also, usually code like this will be parallelized, rather than sequential. That said, it can be helpful to implement the slower version on vectors, in the usual indexed way, for comparisonâ€™s sake:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Semiring</span> a <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb22-2" data-line-number="2">         <span class="dt">Semiring</span> (<span class="dt">Vector</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-3" data-line-number="3">    one <span class="fu">=</span> Vector.singleton one</a>
<a class="sourceLine" id="cb22-4" data-line-number="4">    zero <span class="fu">=</span> Vector.empty</a>
<a class="sourceLine" id="cb22-5" data-line-number="5">    xs <span class="fu">&lt;+&gt;</span> ys <span class="fu">=</span></a>
<a class="sourceLine" id="cb22-6" data-line-number="6">        <span class="kw">case</span> compare (Vector.length xs) (Vector.length ys) <span class="kw">of</span></a>
<a class="sourceLine" id="cb22-7" data-line-number="7">            <span class="dt">EQ</span> <span class="ot">-&gt;</span> Vector.zipWith (<span class="fu">&lt;+&gt;</span>) xs ys</a>
<a class="sourceLine" id="cb22-8" data-line-number="8">            <span class="dt">LT</span> <span class="ot">-&gt;</span> Vector.unsafeAccumulate (<span class="fu">&lt;+&gt;</span>) ys (Vector.indexed xs)</a>
<a class="sourceLine" id="cb22-9" data-line-number="9">            <span class="dt">GT</span> <span class="ot">-&gt;</span> Vector.unsafeAccumulate (<span class="fu">&lt;+&gt;</span>) xs (Vector.indexed ys)</a>
<a class="sourceLine" id="cb22-10" data-line-number="10">    signal <span class="fu">&lt;.&gt;</span> kernel</a>
<a class="sourceLine" id="cb22-11" data-line-number="11">      <span class="fu">|</span> Vector.null signal <span class="fu">=</span> Vector.empty</a>
<a class="sourceLine" id="cb22-12" data-line-number="12">      <span class="fu">|</span> Vector.null kernel <span class="fu">=</span> Vector.empty</a>
<a class="sourceLine" id="cb22-13" data-line-number="13">      <span class="fu">|</span> otherwise <span class="fu">=</span> Vector.generate (slen <span class="fu">+</span> klen <span class="fu">-</span> <span class="dv">1</span>) f</a>
<a class="sourceLine" id="cb22-14" data-line-number="14">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-15" data-line-number="15">        f n <span class="fu">=</span></a>
<a class="sourceLine" id="cb22-16" data-line-number="16">            foldl&#39;</a>
<a class="sourceLine" id="cb22-17" data-line-number="17">                (\a k <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb22-18" data-line-number="18">                      a <span class="fu">&lt;+&gt;</span></a>
<a class="sourceLine" id="cb22-19" data-line-number="19">                      Vector.unsafeIndex signal k <span class="fu">&lt;.&gt;</span></a>
<a class="sourceLine" id="cb22-20" data-line-number="20">                      Vector.unsafeIndex kernel (n <span class="fu">-</span> k))</a>
<a class="sourceLine" id="cb22-21" data-line-number="21">                zero</a>
<a class="sourceLine" id="cb22-22" data-line-number="22">                [kmin <span class="fu">..</span> kmax]</a>
<a class="sourceLine" id="cb22-23" data-line-number="23">          <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-24" data-line-number="24">            <span class="fu">!</span>kmin <span class="fu">=</span> max <span class="dv">0</span> (n <span class="fu">-</span> (klen <span class="fu">-</span> <span class="dv">1</span>))</a>
<a class="sourceLine" id="cb22-25" data-line-number="25">            <span class="fu">!</span>kmax <span class="fu">=</span> min n (slen <span class="fu">-</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb22-26" data-line-number="26">        <span class="fu">!</span>slen <span class="fu">=</span> Vector.length signal</a>
<a class="sourceLine" id="cb22-27" data-line-number="27">        <span class="fu">!</span>klen <span class="fu">=</span> Vector.length kernel</a></code></pre></div>
<h1 id="search">Search</h1>
<p>As has been observed before <span class="citation" data-cites="rivas_monoids_2015">(Rivas, Jaskelioff, and Schrijvers <a href="#ref-rivas_monoids_2015">2015</a>)</span> thereâ€™s a pretty suggestive similarity between semirings and the <code class="sourceCode haskell"><span class="dt">Applicative</span></code>/<code class="sourceCode haskell"><span class="dt">Alternative</span></code> classes in Haskell:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Semiring</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-2" data-line-number="2"><span class="ot">  one ::</span> a</a>
<a class="sourceLine" id="cb23-3" data-line-number="3"><span class="ot">  zero ::</span> a</a>
<a class="sourceLine" id="cb23-4" data-line-number="4"><span class="ot">  (&lt;+&gt;) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb23-5" data-line-number="5"><span class="ot">  (&lt;.&gt;) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb23-6" data-line-number="6"></a>
<a class="sourceLine" id="cb23-7" data-line-number="7"><span class="kw">class</span> <span class="dt">Applicative</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-8" data-line-number="8"><span class="ot">  pure ::</span> a <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb23-9" data-line-number="9"><span class="ot">  (&lt;*&gt;) ::</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</a>
<a class="sourceLine" id="cb23-10" data-line-number="10"></a>
<a class="sourceLine" id="cb23-11" data-line-number="11"><span class="kw">class</span> <span class="dt">Alternative</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-12" data-line-number="12"><span class="ot">  empty ::</span> f a</a>
<a class="sourceLine" id="cb23-13" data-line-number="13"><span class="ot">  (&lt;|&gt;) ::</span> f a <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f a</a></code></pre></div>
<p>So can our implementation of convolution be used to implement the methods for these classes? Partially:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Search</span> f a <span class="fu">=</span> <span class="dt">Search</span> {<span class="ot"> runSearch ::</span> [f a] }</a>
<a class="sourceLine" id="cb24-2" data-line-number="2"></a>
<a class="sourceLine" id="cb24-3" data-line-number="3"><span class="kw">instance</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Functor</span> (<span class="dt">Search</span> f) <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-4" data-line-number="4">  fmap f (<span class="dt">Search</span> xs) <span class="fu">=</span> <span class="dt">Search</span> ((fmap<span class="fu">.</span>fmap) f xs)</a>
<a class="sourceLine" id="cb24-5" data-line-number="5"></a>
<a class="sourceLine" id="cb24-6" data-line-number="6"><span class="kw">instance</span> <span class="dt">Alternative</span> f <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="dt">Search</span> f) <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-7" data-line-number="7">  pure x <span class="fu">=</span> <span class="dt">Search</span> [pure x]</a>
<a class="sourceLine" id="cb24-8" data-line-number="8">  _ <span class="fu">&lt;*&gt;</span> <span class="dt">Search</span> [] <span class="fu">=</span> <span class="dt">Search</span> []</a>
<a class="sourceLine" id="cb24-9" data-line-number="9">  <span class="dt">Search</span> xs <span class="fu">&lt;*&gt;</span> <span class="dt">Search</span> ys <span class="fu">=</span> <span class="dt">Search</span> (foldr f [] xs) <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-10" data-line-number="10">    f x zs <span class="fu">=</span> foldr (g x) id ys (empty <span class="fu">:</span> zs)</a>
<a class="sourceLine" id="cb24-11" data-line-number="11">    g x y a (z<span class="fu">:</span>zs) <span class="fu">=</span> (x <span class="fu">&lt;*&gt;</span> y <span class="fu">&lt;|&gt;</span> z) <span class="fu">:</span> a zs</a>
<a class="sourceLine" id="cb24-12" data-line-number="12">    g x y a [] <span class="fu">=</span> (x <span class="fu">&lt;*&gt;</span> y) <span class="fu">:</span> a []</a>
<a class="sourceLine" id="cb24-13" data-line-number="13"></a>
<a class="sourceLine" id="cb24-14" data-line-number="14"><span class="kw">instance</span> <span class="dt">Alternative</span> f <span class="ot">=&gt;</span> <span class="dt">Alternative</span> (<span class="dt">Search</span> f) <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-15" data-line-number="15">  <span class="dt">Search</span> xs <span class="fu">&lt;|&gt;</span> <span class="dt">Search</span> ys <span class="fu">=</span> <span class="dt">Search</span> (go xs ys) <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-16" data-line-number="16">    go [] ys <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb24-17" data-line-number="17">    go xs [] <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb24-18" data-line-number="18">    go (x<span class="fu">:</span>xs) (y<span class="fu">:</span>ys) <span class="fu">=</span> (x <span class="fu">&lt;|&gt;</span> y) <span class="fu">:</span> go xs ys</a>
<a class="sourceLine" id="cb24-19" data-line-number="19">  empty <span class="fu">=</span> <span class="dt">Search</span> []</a></code></pre></div>
<p>At first, this seems perfect: the types all match up, and the definitions seem sensible. The issue is with the laws: <code class="sourceCode haskell"><span class="dt">Applicative</span></code> and <code class="sourceCode haskell"><span class="dt">Alternative</span></code> are missing <em>four</em> that semirings require. In particular: commutativity of plus, annihilation by zero, and distributivity left and right:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1">xs <span class="fu">&lt;|&gt;</span> ys <span class="fu">=</span> ys <span class="fu">&lt;|&gt;</span> xs</a>
<a class="sourceLine" id="cb25-2" data-line-number="2">empty <span class="fu">&lt;*&gt;</span> xs <span class="fu">=</span> fs <span class="fu">&lt;*&gt;</span> empty <span class="fu">=</span> empty</a>
<a class="sourceLine" id="cb25-3" data-line-number="3">fs <span class="fu">&lt;*&gt;</span> (xs <span class="fu">&lt;|&gt;</span> ys) <span class="fu">=</span> fs <span class="fu">&lt;*&gt;</span> xs <span class="fu">&lt;|&gt;</span> fs <span class="fu">&lt;*&gt;</span> ys</a>
<a class="sourceLine" id="cb25-4" data-line-number="4">(fs <span class="fu">&lt;|&gt;</span> gs) <span class="fu">&lt;*&gt;</span> xs <span class="fu">=</span> fs <span class="fu">&lt;*&gt;</span> xs <span class="fu">&lt;|&gt;</span> gs <span class="fu">&lt;*&gt;</span> ys</a></code></pre></div>
<p>The vast majority of the instances of <code class="sourceCode haskell"><span class="dt">Alternative</span></code> today fail one or more of these laws. Taking lists as an example, <code class="sourceCode haskell"><span class="fu">++</span></code> obviously isnâ€™t commutative, and <code class="sourceCode haskell"><span class="fu">&lt;*&gt;</span></code> only distributes when itâ€™s on the right.</p>
<p>Whatâ€™s the problem, though? Polynomial multiplication follows <em>more</em> laws than those required by <code class="sourceCode haskell"><span class="dt">Applicative</span></code>: why should that worry us? Unfortunately, in order for multiplication to follow those laws, it actually relies on the underlying semiring being law-abiding. And it <em>fails</em> the applicative laws when it isnâ€™t.</p>
<p>There are two angles from which we could come at this problem: either we relax the semiring laws and try and make our implementation of convolution rely on them as little as possible, or we find <code class="sourceCode haskell"><span class="dt">Alternative</span></code> instances which follow the semiring laws. Or we could meet in the middle, relaxing the laws as much as possible until we find some <code class="sourceCode haskell"><span class="dt">Alternative</span></code>s that meet our standards.</p>
<p>This has actually been accomplished in several papers: the previously mentioned <span class="citation" data-cites="rivas_monoids_2015">Rivas, Jaskelioff, and Schrijvers (<a href="#ref-rivas_monoids_2015">2015</a>)</span> discusses near-semirings, defined as semiring-like structures with associativity, identity, and these two laws:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>Ã—</mo><mi>x</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">0 \times x = 0</annotation></semantics></math> <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo><mo>Ã—</mo><mi>z</mi><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>Ã—</mo><mi>z</mi><mo stretchy="false" form="postfix">)</mo><mo>+</mo><mo stretchy="false" form="prefix">(</mo><mi>y</mi><mo>Ã—</mo><mi>z</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(x \plus y) \times z = (x \times z) \plus (y \times z)</annotation></semantics></math></p>
<p>In contrast to normal semirings, zero only annihilates when itâ€™s on the left, and multiplication only distributes over addition when itâ€™s on the right. Addition is not required to be commutative.</p>
<p>The lovely paper <span class="citation" data-cites="spivey_algebras_2009">Spivey (<a href="#ref-spivey_algebras_2009">2009</a>)</span> has a similar concept: a â€œbunchâ€.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Bunch</span> m <span class="kw">where</span></a>
<a class="sourceLine" id="cb26-2" data-line-number="2"><span class="ot">  return ::</span> a <span class="ot">-&gt;</span> m a</a>
<a class="sourceLine" id="cb26-3" data-line-number="3"><span class="ot">  (&gt;&gt;=) ::</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b</a>
<a class="sourceLine" id="cb26-4" data-line-number="4"><span class="ot">  zero ::</span> m a</a>
<a class="sourceLine" id="cb26-5" data-line-number="5"><span class="ot">  (&lt;|&gt;) ::</span> m a <span class="ot">-&gt;</span> m a <span class="ot">-&gt;</span> m a</a>
<a class="sourceLine" id="cb26-6" data-line-number="6"><span class="ot">  wrap ::</span> m a <span class="ot">-&gt;</span> m a</a></code></pre></div>
<p>The laws are all the same (with <code class="sourceCode haskell"><span class="fu">&lt;*&gt;</span></code> implemented in terms of <code class="sourceCode haskell"><span class="fu">&gt;&gt;=</span></code>), and the extra <code class="sourceCode haskell">wrap</code> operation can be expressed like so:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="ot">wrap ::</span> <span class="dt">Alternative</span> f <span class="ot">=&gt;</span> <span class="dt">Search</span> f a <span class="ot">-&gt;</span> <span class="dt">Search</span> f a</a>
<a class="sourceLine" id="cb27-2" data-line-number="2">wrap (<span class="dt">Search</span> xs) <span class="fu">=</span> <span class="dt">Search</span> (empty <span class="fu">:</span> xs)</a></code></pre></div>
<p>A definition of <code class="sourceCode haskell"><span class="fu">&gt;&gt;=</span></code> for our polynomials is also provided:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1">[] <span class="fu">&gt;&gt;=</span> _ <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb28-2" data-line-number="2">(x<span class="fu">:</span>xs) <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> foldr (<span class="fu">&lt;|&gt;</span>) empty (fmap f x) <span class="fu">&lt;|&gt;</span> wrap (xs <span class="fu">&gt;&gt;=</span> f)</a></code></pre></div>
<p>This will require the underlying <code class="sourceCode haskell">f</code> to be <code class="sourceCode haskell"><span class="dt">Foldable</span></code>. We can inline a little, and express the whole thing as a fold:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" data-line-number="1"><span class="kw">instance</span> (<span class="dt">Foldable</span> f, <span class="dt">Alternative</span> f) <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">Search</span> f) <span class="kw">where</span></a>
<a class="sourceLine" id="cb29-2" data-line-number="2">  <span class="dt">Search</span> xs <span class="fu">&gt;&gt;=</span> k <span class="fu">=</span> foldr f empty xs <span class="kw">where</span></a>
<a class="sourceLine" id="cb29-3" data-line-number="3">    f e a <span class="fu">=</span> foldr ((<span class="fu">&lt;|&gt;</span>) <span class="fu">.</span> k) (wrap a) e</a></code></pre></div>
<p>For <code class="sourceCode haskell"><span class="dt">Search</span></code> to meet the requirements of a bunch, the paper notes that the <code class="sourceCode haskell">f</code> must be assumed to be a bag, i.e., the order of its elements must be ignored.</p>
<p><span class="citation" data-cites="kiselyov_backtracking_2005">Kiselyov et al. (<a href="#ref-kiselyov_backtracking_2005">2005</a>)</span> kind of goes the other direction, defining a monad which has fair disjunction and conjunction. Unfortunately, the fair conjunction loses associativity.</p>
<h1 id="distance">Distance</h1>
<p>The end of the paper on algebras for combinatorial search wonders if notions of distance could be added to some of the algebras. I <em>think</em> that should be as simple as supplying a suitable near-semiring for <code class="sourceCode haskell">f</code>, but the definition of <code class="sourceCode haskell"><span class="fu">&gt;&gt;=</span></code> would need to be changed. The near-semiring I had in mind was the probability monad. It works correctly if inlined:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Search</span> s a <span class="fu">=</span> <span class="dt">Search</span> {<span class="ot"> runSearch ::</span> [[(a,s)]] }</a>
<a class="sourceLine" id="cb30-2" data-line-number="2"></a>
<a class="sourceLine" id="cb30-3" data-line-number="3"><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Search</span> s) <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-4" data-line-number="4">  fmap f (<span class="dt">Search</span> xs) <span class="fu">=</span> <span class="dt">Search</span> ((fmap<span class="fu">.</span>fmap<span class="fu">.</span>first) f xs)</a>
<a class="sourceLine" id="cb30-5" data-line-number="5"></a>
<a class="sourceLine" id="cb30-6" data-line-number="6"><span class="kw">instance</span> <span class="dt">Semiring</span> s <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="dt">Search</span> s) <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-7" data-line-number="7">  pure x <span class="fu">=</span> <span class="dt">Search</span> [[(x,one)]]</a>
<a class="sourceLine" id="cb30-8" data-line-number="8">  _ <span class="fu">&lt;*&gt;</span> <span class="dt">Search</span> [] <span class="fu">=</span> <span class="dt">Search</span> []</a>
<a class="sourceLine" id="cb30-9" data-line-number="9">  <span class="dt">Search</span> xs <span class="fu">&lt;*&gt;</span> <span class="dt">Search</span> ys <span class="fu">=</span> <span class="dt">Search</span> (foldr f [] xs) <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-10" data-line-number="10">    f x zs <span class="fu">=</span> foldr (g x) id ys (empty <span class="fu">:</span> zs)</a>
<a class="sourceLine" id="cb30-11" data-line-number="11">    g x y a (z<span class="fu">:</span>zs) <span class="fu">=</span> (m x y <span class="fu">++</span> z) <span class="fu">:</span> a zs</a>
<a class="sourceLine" id="cb30-12" data-line-number="12">    g x y a [] <span class="fu">=</span> (m x y) <span class="fu">:</span> a []</a>
<a class="sourceLine" id="cb30-13" data-line-number="13">    m ls rs <span class="fu">=</span> [(l r, lp<span class="fu">&lt;.&gt;</span>rp) <span class="fu">|</span> (l,lp) <span class="ot">&lt;-</span> ls, (r,rp) <span class="ot">&lt;-</span> rs]</a>
<a class="sourceLine" id="cb30-14" data-line-number="14"></a>
<a class="sourceLine" id="cb30-15" data-line-number="15"><span class="kw">instance</span> <span class="dt">Semiring</span> s <span class="ot">=&gt;</span> <span class="dt">Alternative</span> (<span class="dt">Search</span> s) <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-16" data-line-number="16">  <span class="dt">Search</span> xs <span class="fu">&lt;|&gt;</span> <span class="dt">Search</span> ys <span class="fu">=</span> <span class="dt">Search</span> (go xs ys) <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-17" data-line-number="17">    go [] ys <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb30-18" data-line-number="18">    go xs [] <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb30-19" data-line-number="19">    go (x<span class="fu">:</span>xs) (y<span class="fu">:</span>ys) <span class="fu">=</span> (x <span class="fu">++</span> y) <span class="fu">:</span> go xs ys</a>
<a class="sourceLine" id="cb30-20" data-line-number="20">  empty <span class="fu">=</span> <span class="dt">Search</span> []</a>
<a class="sourceLine" id="cb30-21" data-line-number="21"></a>
<a class="sourceLine" id="cb30-22" data-line-number="22"><span class="ot">wrap ::</span> <span class="dt">Search</span> s a <span class="ot">-&gt;</span> <span class="dt">Search</span> s a</a>
<a class="sourceLine" id="cb30-23" data-line-number="23">wrap (<span class="dt">Search</span> xs) <span class="fu">=</span> <span class="dt">Search</span> ([] <span class="fu">:</span> xs)</a>
<a class="sourceLine" id="cb30-24" data-line-number="24"></a>
<a class="sourceLine" id="cb30-25" data-line-number="25"><span class="kw">instance</span> <span class="dt">Semiring</span> s <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">Search</span> s) <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-26" data-line-number="26">  <span class="dt">Search</span> xs <span class="fu">&gt;&gt;=</span> k <span class="fu">=</span> foldr f empty xs <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-27" data-line-number="27">    f e a <span class="fu">=</span> foldr ((<span class="fu">&lt;|&gt;</span>) <span class="fu">.</span> uncurry (mulIn <span class="fu">.</span> k)) (wrap a) e</a>
<a class="sourceLine" id="cb30-28" data-line-number="28">    mulIn (<span class="dt">Search</span> x) xp <span class="fu">=</span> <span class="dt">Search</span> ((fmap<span class="fu">.</span>fmap<span class="fu">.</span>fmap) (xp<span class="fu">&lt;.&gt;</span>) x)</a></code></pre></div>
<p>But I couldnâ€™t figure out how to get it to work for a more generalized inner monad. The above could probably be sped up, or randomized, using the many well-known techniques for probability monad optimization.</p>
<h1 id="references" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-dolan_fun_2013">
<p>Dolan, Stephen. 2013. â€œFun with semirings: A functional pearl on the abuse of linear algebra.â€ In, 48:101. ACM Press. doi:<a href="https://doi.org/10.1145/2500365.2500613">10.1145/2500365.2500613</a>. <a href="https://www.cl.cam.ac.uk/~sd601/papers/semirings.pdf" class="uri">https://www.cl.cam.ac.uk/~sd601/papers/semirings.pdf</a>.</p>
</div>
<div id="ref-kiselyov_backtracking_2005">
<p>Kiselyov, Oleg, Chung-chieh Shan, Daniel P Friedman, and Amr Sabry. 2005. â€œBacktracking, interleaving, and terminating monad transformers (functional pearl).â€ <em>ACM SIGPLAN Notices</em> 40 (9): 192â€“203. <a href="http://okmij.org/ftp/Computation/monads.html#LogicT" class="uri">http://okmij.org/ftp/Computation/monads.html#LogicT</a>.</p>
</div>
<div id="ref-mcbride_applicative_2008">
<p>McBride, Conor, and Ross Paterson. 2008. â€œApplicative programming with effects.â€ <em>Journal of functional programming</em> 18 (01): 1â€“13. <a href="http://strictlypositive.org/Idiom.pdf" class="uri">http://strictlypositive.org/Idiom.pdf</a>.</p>
</div>
<div id="ref-mcilroy_power_1999">
<p>McIlroy, M. Douglas. 1999. â€œPower Series, Power Serious.â€ <em>J. Funct. Program.</em> 9 (3) (May): 325â€“337. doi:<a href="https://doi.org/10.1017/S0956796899003299">10.1017/S0956796899003299</a>. <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.333.3156&amp;rep=rep1&amp;type=pdf" class="uri">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.333.3156&amp;rep=rep1&amp;type=pdf</a>.</p>
</div>
<div id="ref-okasaki_fast_1999">
<p>Okasaki, Chris. 1999. â€œFrom Fast Exponentiation to Square Matrices: An Adventure in Types.â€ In <em>Proceedings of the ACM SIGPLAN International Conference on Functional Programming (ICFPâ€™99), Paris, France, September 27-29, 1999</em>, 34:28. ACM. <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.456.357&amp;rep=rep1&amp;type=pdf" class="uri">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.456.357&amp;rep=rep1&amp;type=pdf</a>.</p>
</div>
<div id="ref-rivas_monoids_2015">
<p>Rivas, Exequiel, Mauro Jaskelioff, and Tom Schrijvers. 2015. â€œFrom monoids to near-semirings: The essence of MonadPlus and Alternative.â€ In <em>Proceedings of the 17th International Symposium on Principles and Practice of Declarative Programming</em>, 196â€“207. ACM. doi:<a href="https://doi.org/10.1145/2790449.2790514">10.1145/2790449.2790514</a>. <a href="http://www.fceia.unr.edu.ar/~mauro/pubs/FromMonoidstoNearsemirings.pdf" class="uri">http://www.fceia.unr.edu.ar/~mauro/pubs/FromMonoidstoNearsemirings.pdf</a>.</p>
</div>
<div id="ref-spivey_algebras_2009">
<p>Spivey, J. Michael. 2009. â€œAlgebras for combinatorial search.â€ <em>Journal of Functional Programming</em> 19 (3-4) (July): 469â€“487. doi:<a href="https://doi.org/10.1017/S0956796809007321">10.1017/S0956796809007321</a>. <a href="https://pdfs.semanticscholar.org/db3e/373bb6e7e7837ebc524da0a25903958554ed.pdf" class="uri">https://pdfs.semanticscholar.org/db3e/373bb6e7e7837ebc524da0a25903958554ed.pdf</a>.</p>
</div>
</div>
]]></description>
    <pubDate>Fri, 13 Oct 2017 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2017-10-13-convolutions-and-semirings.html</guid>
    <dc:creator>Donnacha OisÃ­n Kidney</dc:creator>
</item>
<item>
    <title>Applicative Arithmetic</title>
    <link>https://doisinkidney.com/posts/2017-09-25-applicative-arithmetic.html</link>
    <description><![CDATA[<div class="info">
    Posted on September 25, 2017
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Applicative.html">Applicative</a>
    
</div>

<h1 id="safer-arithmetic">Safer Arithmetic</h1>
<p>There are a couple partial functions in the Haskell Prelude which people seem to agree shouldnâ€™t be there. <code class="sourceCode haskell">head</code>, for example, will throw an error on an empty list. Most seem to agree that it should work something more like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1">head<span class="ot"> ::</span> <span class="dt">Foldable</span> f <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">head <span class="fu">=</span> foldr (const <span class="fu">.</span> <span class="dt">Just</span>) <span class="dt">Nothing</span></a></code></pre></div>
<p>There are other examples, like <code class="sourceCode haskell">last</code>, <code class="sourceCode haskell"><span class="fu">!!</span></code>, etc.</p>
<p>One which people <em>donâ€™t</em> agree on, however, is division by zero. In the current Prelude, the following will throw an error:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="dv">1</span> <span class="fu">/</span> <span class="dv">0</span></a></code></pre></div>
<p>The â€œsafeâ€ version might have a signature like this:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">(/) ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</a></code></pre></div>
<p>However, this turns out to be quite a headache for writing code generally. So the default is the (somewhat) unsafe version.</p>
<p>Is there a way to introduce a safer version without much overhead, so the programmer is given the option? Of course! With some newtype magic, itâ€™s pretty simple to write a wrapper which catches division by zero in some arbitrary monad:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">AppNum</span> f a <span class="fu">=</span> <span class="dt">AppNum</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">    {<span class="ot"> runAppNum ::</span> f a</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">    } <span class="kw">deriving</span> (<span class="dt">Functor</span>,<span class="dt">Applicative</span>,<span class="dt">Monad</span>,<span class="dt">Alternative</span>,<span class="dt">Show</span>,<span class="dt">Eq</span>,<span class="dt">MonadFail</span>)</a>
<a class="sourceLine" id="cb4-4" data-line-number="4"></a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="kw">instance</span> (<span class="dt">Num</span> a, <span class="dt">Applicative</span> f) <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">         <span class="dt">Num</span> (<span class="dt">AppNum</span> f a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7">    abs <span class="fu">=</span> fmap abs</a>
<a class="sourceLine" id="cb4-8" data-line-number="8">    signum <span class="fu">=</span> fmap signum</a>
<a class="sourceLine" id="cb4-9" data-line-number="9">    (<span class="fu">+</span>) <span class="fu">=</span> liftA2 (<span class="fu">+</span>)</a>
<a class="sourceLine" id="cb4-10" data-line-number="10">    (<span class="fu">*</span>) <span class="fu">=</span> liftA2 (<span class="fu">*</span>)</a>
<a class="sourceLine" id="cb4-11" data-line-number="11">    (<span class="fu">-</span>) <span class="fu">=</span> liftA2 (<span class="fu">-</span>)</a>
<a class="sourceLine" id="cb4-12" data-line-number="12">    negate <span class="fu">=</span> fmap negate</a>
<a class="sourceLine" id="cb4-13" data-line-number="13">    fromInteger <span class="fu">=</span> pure <span class="fu">.</span> fromInteger</a>
<a class="sourceLine" id="cb4-14" data-line-number="14"></a>
<a class="sourceLine" id="cb4-15" data-line-number="15"><span class="kw">instance</span> (<span class="dt">Fractional</span> a, <span class="dt">MonadFail</span> f, <span class="dt">Eq</span> a) <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb4-16" data-line-number="16">         <span class="dt">Fractional</span> (<span class="dt">AppNum</span> f a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-17" data-line-number="17">    fromRational <span class="fu">=</span> pure <span class="fu">.</span> fromRational</a>
<a class="sourceLine" id="cb4-18" data-line-number="18">    xs <span class="fu">/</span> ys <span class="fu">=</span></a>
<a class="sourceLine" id="cb4-19" data-line-number="19">        ys <span class="fu">&gt;&gt;=</span></a>
<a class="sourceLine" id="cb4-20" data-line-number="20">        \<span class="kw">case</span></a>
<a class="sourceLine" id="cb4-21" data-line-number="21">            <span class="dv">0</span> <span class="ot">-&gt;</span> fail <span class="st">&quot;divide by zero&quot;</span></a>
<a class="sourceLine" id="cb4-22" data-line-number="22">            y <span class="ot">-&gt;</span> fmap (<span class="fu">/</span> y) xs</a></code></pre></div>
<p>Iâ€™m using the <code class="sourceCode haskell"><span class="fu">-</span><span class="dt">XLambdaCase</span></code> extension and <code class="sourceCode haskell"><span class="dt">MonadFail</span></code> here.</p>
<h1 id="free-applicatives">Free Applicatives</h1>
<p>Youâ€™ll notice that you only need <code class="sourceCode haskell"><span class="dt">Applicative</span></code> for most of the arithmetic operations above. In fact, you only need <code class="sourceCode haskell"><span class="dt">Monad</span></code> when you want to examine the contents of <code class="sourceCode haskell">f</code>. Using that fact, we can manipulate expression trees using the free applicative from the <a href="https://hackage.haskell.org/package/free">free</a> package. Say, for instance, we want to have free variables in our expressions. Using <code class="sourceCode haskell"><span class="dt">Either</span></code>, itâ€™s pretty easy:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">type</span> <span class="dt">WithVars</span> <span class="fu">=</span> <span class="dt">AppNum</span> (<span class="dt">Ap</span> (<span class="dt">Either</span> <span class="dt">String</span>)) <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="ot">var ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">WithVars</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">var <span class="fu">=</span> <span class="dt">AppNum</span> <span class="fu">.</span> liftAp <span class="fu">.</span> <span class="dt">Left</span></a></code></pre></div>
<p>We can collect the free variables from an expression:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">vars ::</span> <span class="dt">WithVars</span> <span class="ot">-&gt;</span> [<span class="dt">String</span>]</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">vars <span class="fu">=</span> runAp_ (either pure (const [])) <span class="fu">.</span> runAppNum</a>
<a class="sourceLine" id="cb6-3" data-line-number="3"></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">x <span class="fu">=</span> <span class="dv">1</span><span class="ot"> ::</span> <span class="dt">WithVars</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">y <span class="fu">=</span> var <span class="st">&quot;y&quot;</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">z <span class="fu">=</span> var <span class="st">&quot;z&quot;</span></a>
<a class="sourceLine" id="cb6-7" data-line-number="7"></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">vars (x <span class="fu">+</span> y <span class="fu">+</span> z) <span class="co">-- [&quot;y&quot;,&quot;z&quot;]</span></a></code></pre></div>
<p>If we want to sub in, though, weâ€™re going to run into a problem: we canâ€™t just pass in a <code class="sourceCode haskell"><span class="dt">Map</span> <span class="dt">String</span> <span class="dt">Integer</span></code> because youâ€™re able to construct values like this:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">bad ::</span> <span class="dt">AppNum</span> (<span class="dt">Ap</span> (<span class="dt">Either</span> <span class="dt">String</span>)) (<span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>)</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">bad <span class="fu">=</span> <span class="dt">AppNum</span> (liftAp (<span class="dt">Left</span> <span class="st">&quot;oh noes&quot;</span>))</a></code></pre></div>
<p>Weâ€™d need to pass in a <code class="sourceCode haskell"><span class="dt">Map</span> <span class="dt">String</span> (<span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>)</code> as well; in fact youâ€™d need a map for every possible type. Which isnâ€™t feasible.</p>
<h1 id="gadts">GADTs</h1>
<p>Luckily, we <em>can</em> constrain the types of variables in our expression so that theyâ€™re always <code class="sourceCode haskell"><span class="dt">Integer</span></code>, using a GADT:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Variable</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">        <span class="dt">Constant</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Variable</span> a</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">        <span class="dt">Variable</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Variable</span> <span class="dt">Integer</span></a></code></pre></div>
<p>The type above seems useless on its own: it doesnâ€™t have a <code class="sourceCode haskell"><span class="dt">Functor</span></code> instance, never mind an <code class="sourceCode haskell"><span class="dt">Applicative</span></code>, so how can it fit into <code class="sourceCode haskell"><span class="dt">AppNum</span></code>?</p>
<p>The magic comes from the free applicative, which converts any type of kind <code class="sourceCode haskell"><span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></code> into an applicative. With that in mind, we can change around the previous code:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">type</span> <span class="dt">WithVars</span> <span class="fu">=</span> <span class="dt">AppNum</span> (<span class="dt">Ap</span> <span class="dt">Variable</span>) <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"></a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="ot">var ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">WithVars</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4">var <span class="fu">=</span> <span class="dt">AppNum</span> <span class="fu">.</span> liftAp <span class="fu">.</span> <span class="dt">Variable</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5"></a>
<a class="sourceLine" id="cb9-6" data-line-number="6"><span class="ot">vars ::</span> <span class="dt">WithVars</span> <span class="ot">-&gt;</span> [<span class="dt">String</span>]</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">vars <span class="fu">=</span> runAp_ f <span class="fu">.</span> runAppNum</a>
<a class="sourceLine" id="cb9-8" data-line-number="8">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-9" data-line-number="9"><span class="ot">    f ::</span> <span class="dt">Variable</span> a <span class="ot">-&gt;</span> [<span class="dt">String</span>]</a>
<a class="sourceLine" id="cb9-10" data-line-number="10">    f (<span class="dt">Constant</span> _) <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb9-11" data-line-number="11">    f (<span class="dt">Variable</span> s) <span class="fu">=</span> [s]</a></code></pre></div>
<p>And write the function to sub in for us:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">variableA</a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="ot">    ::</span> <span class="dt">Applicative</span> f</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">    <span class="ot">=&gt;</span> (<span class="dt">String</span> <span class="ot">-&gt;</span> f <span class="dt">Integer</span>) <span class="ot">-&gt;</span> <span class="dt">Variable</span> a <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">variableA _ (<span class="dt">Constant</span> x) <span class="fu">=</span> pure x</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">variableA f (<span class="dt">Variable</span> s) <span class="fu">=</span> f s</a>
<a class="sourceLine" id="cb10-6" data-line-number="6"></a>
<a class="sourceLine" id="cb10-7" data-line-number="7"><span class="ot">variable ::</span> (<span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>) <span class="ot">-&gt;</span> <span class="dt">Variable</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb10-8" data-line-number="8">variable _ (<span class="dt">Constant</span> x) <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb10-9" data-line-number="9">variable f (<span class="dt">Variable</span> s) <span class="fu">=</span> f s</a>
<a class="sourceLine" id="cb10-10" data-line-number="10"></a>
<a class="sourceLine" id="cb10-11" data-line-number="11"><span class="ot">replace ::</span> <span class="dt">Map</span> <span class="dt">String</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">WithVars</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb10-12" data-line-number="12">replace m <span class="fu">=</span> runAp (variable (m <span class="fu">Map.!</span>)) <span class="fu">.</span> runAppNum</a>
<a class="sourceLine" id="cb10-13" data-line-number="13"></a>
<a class="sourceLine" id="cb10-14" data-line-number="14">replace (Map.fromList [(<span class="st">&quot;z&quot;</span>,<span class="dv">2</span>), (<span class="st">&quot;y&quot;</span>,<span class="dv">3</span>)]) (x <span class="fu">+</span> y <span class="fu">+</span> z)</a>
<a class="sourceLine" id="cb10-15" data-line-number="15"><span class="co">-- 6</span></a></code></pre></div>
<h1 id="accumulation">Accumulation</h1>
<p>This will fail if a free variable isnâ€™t present in the map, unfortunately. To fix it, we <em>could</em> use <code class="sourceCode haskell"><span class="dt">Either</span></code> instead of <code class="sourceCode haskell"><span class="dt">Identity</span></code>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">replace ::</span> <span class="dt">Map</span> <span class="dt">String</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">WithVars</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2">replace m <span class="fu">=</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">    runAp</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">        (variableA <span class="fu">$</span></a>
<a class="sourceLine" id="cb11-5" data-line-number="5">         \s <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb11-6" data-line-number="6">              maybe (<span class="dt">Left</span> s) <span class="dt">Right</span> (Map.lookup s m)) <span class="fu">.</span></a>
<a class="sourceLine" id="cb11-7" data-line-number="7">    runAppNum</a></code></pre></div>
<p>But this only gives us the first missing variable encountered. Weâ€™d like to get back <em>all</em> of the missing variables, ideally: accumulating the <code class="sourceCode haskell"><span class="dt">Left</span></code>s. <code class="sourceCode haskell"><span class="dt">Either</span></code> doesnâ€™t accumulate values, as if it did it would <a href="https://stackoverflow.com/a/23611068/4892417">break the monad laws</a>.</p>
<p>Thereâ€™s no issue with the <em>applicative</em> laws, though, which is why the <a href="https://hackage.haskell.org/package/validation-0.5.4">validation</a> package provides a <em>non-monadic</em> either-like type, which we can use here.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="ot">replace ::</span> <span class="dt">Map</span> <span class="dt">String</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">WithVars</span> <span class="ot">-&gt;</span> <span class="dt">AccValidation</span> [<span class="dt">String</span>] <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">replace m <span class="fu">=</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">    runAp</a>
<a class="sourceLine" id="cb12-4" data-line-number="4">        (variableA <span class="fu">$</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5">         \s <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb12-6" data-line-number="6">              maybe (<span class="dt">AccFailure</span> [s]) pure (Map.lookup s m)) <span class="fu">.</span></a>
<a class="sourceLine" id="cb12-7" data-line-number="7">    runAppNum</a>
<a class="sourceLine" id="cb12-8" data-line-number="8"></a>
<a class="sourceLine" id="cb12-9" data-line-number="9">replace (Map.fromList []) (x <span class="fu">+</span> y <span class="fu">+</span> z)</a>
<a class="sourceLine" id="cb12-10" data-line-number="10"><span class="co">-- AccFailure [&quot;y&quot;,&quot;z&quot;]</span></a></code></pre></div>
<h1 id="other-uses">Other uses</h1>
<p>There are a bunch more applicatives you could use instead of <code class="sourceCode haskell"><span class="dt">Either</span></code>. Using lists, for instance, you could calculate the possible outcomes from a range of inputs:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1">range<span class="ot"> ::</span> <span class="dt">WithVars</span> <span class="ot">-&gt;</span> [<span class="dt">Integer</span>]</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">range <span class="fu">=</span> runAp (variable (const [<span class="dv">1</span><span class="fu">..</span><span class="dv">3</span>])) <span class="fu">.</span> runAppNum</a>
<a class="sourceLine" id="cb13-3" data-line-number="3"></a>
<a class="sourceLine" id="cb13-4" data-line-number="4">range (x <span class="fu">+</span> y <span class="fu">+</span> z)</a>
<a class="sourceLine" id="cb13-5" data-line-number="5"><span class="co">-- [3,4,5,4,5,6,5,6,7]</span></a></code></pre></div>
<p>Or you could ask the user for input:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="ot">query ::</span> <span class="dt">WithVars</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2">query <span class="fu">=</span> runAp (variable f) <span class="fu">.</span> runAppNum</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-4" data-line-number="4">    f s <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb14-5" data-line-number="5">      putStr <span class="st">&quot;Input a value for &quot;</span></a>
<a class="sourceLine" id="cb14-6" data-line-number="6">      putStrLn s</a>
<a class="sourceLine" id="cb14-7" data-line-number="7">      fmap read getLine</a></code></pre></div>
<p>Finally, and this oneâ€™s a bit exotic, you could examine every variable in turn, with defaults for the others:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1">zygo</a>
<a class="sourceLine" id="cb15-2" data-line-number="2"><span class="ot">    ::</span> (forall x<span class="fu">.</span> f x <span class="ot">-&gt;</span> x)</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">    <span class="ot">-&gt;</span> (forall x<span class="fu">.</span> f x <span class="ot">-&gt;</span> (x <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> b)</a>
<a class="sourceLine" id="cb15-4" data-line-number="4">    <span class="ot">-&gt;</span> <span class="dt">Ap</span> f a</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">    <span class="ot">-&gt;</span> [b]</a>
<a class="sourceLine" id="cb15-6" data-line-number="6">zygo (<span class="ot">l ::</span> forall x<span class="fu">.</span> f x <span class="ot">-&gt;</span> x) (<span class="ot">c ::</span> forall x<span class="fu">.</span> f x <span class="ot">-&gt;</span> (x <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> b) <span class="fu">=</span></a>
<a class="sourceLine" id="cb15-7" data-line-number="7">    fst <span class="fu">.</span> go id</a>
<a class="sourceLine" id="cb15-8" data-line-number="8">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-9" data-line-number="9"><span class="ot">    go ::</span> forall c<span class="fu">.</span> (c <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Ap</span> f c <span class="ot">-&gt;</span> ([b], c)</a>
<a class="sourceLine" id="cb15-10" data-line-number="10">    go _ (<span class="dt">Pure</span> x) <span class="fu">=</span> ([], x)</a>
<a class="sourceLine" id="cb15-11" data-line-number="11">    go k (<span class="dt">Ap</span> x f) <span class="fu">=</span> (c x (k <span class="fu">.</span> ls) <span class="fu">:</span> xs, ls lx)</a>
<a class="sourceLine" id="cb15-12" data-line-number="12">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-13" data-line-number="13">        (xs,ls) <span class="fu">=</span> go (k <span class="fu">.</span> (<span class="fu">$</span> lx)) f</a>
<a class="sourceLine" id="cb15-14" data-line-number="14">        lx <span class="fu">=</span> l x</a>
<a class="sourceLine" id="cb15-15" data-line-number="15"></a>
<a class="sourceLine" id="cb15-16" data-line-number="16"><span class="ot">examineEach ::</span> <span class="dt">WithVars</span> <span class="ot">-&gt;</span> [<span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>]</a>
<a class="sourceLine" id="cb15-17" data-line-number="17">examineEach <span class="fu">=</span> zygo (variable (const <span class="dv">1</span>)) g <span class="fu">.</span> runAppNum</a>
<a class="sourceLine" id="cb15-18" data-line-number="18">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-19" data-line-number="19"><span class="ot">    g ::</span> <span class="dt">Variable</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb15-20" data-line-number="20">    g (<span class="dt">Constant</span> x) rhs _ <span class="fu">=</span> rhs x</a>
<a class="sourceLine" id="cb15-21" data-line-number="21">    g (<span class="dt">Variable</span> _) rhs i <span class="fu">=</span> rhs i</a></code></pre></div>
<p>This produces a list of functions which are equivalent to subbing in for each variable with the rest set to 1.</p>
]]></description>
    <pubDate>Mon, 25 Sep 2017 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2017-09-25-applicative-arithmetic.html</guid>
    <dc:creator>Donnacha OisÃ­n Kidney</dc:creator>
</item>
<item>
    <title>Verifying Data Structures in Haskell</title>
    <link>https://doisinkidney.com/posts/2017-04-23-verifying-data-structures-in-haskell-lhs.html</link>
    <description><![CDATA[<div class="info">
    Posted on April 23, 2017
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Dependent%20Types.html">Dependent Types</a>, <a href="/tags/Data%20Structures.html">Data Structures</a>
    
</div>

<div class="sourceCode" id="cb1"><pre class="sourceCode haskell literate hidden_source"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">{-# LANGUAGE DataKinds #-}</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="ot">{-# LANGUAGE TypeOperators #-}</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="ot">{-# LANGUAGE TypeFamilies #-}</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="ot">{-# LANGUAGE TypeInType #-}</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="ot">{-# LANGUAGE KindSignatures #-}</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="ot">{-# LANGUAGE GADTs #-}</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="ot">{-# LANGUAGE RankNTypes #-}</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"><span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9"><span class="ot">{-# LANGUAGE BangPatterns #-}</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10"><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11"><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></a>
<a class="sourceLine" id="cb1-12" data-line-number="12"><span class="ot">{-# LANGUAGE RebindableSyntax #-}</span></a>
<a class="sourceLine" id="cb1-13" data-line-number="13"></a>
<a class="sourceLine" id="cb1-14" data-line-number="14"><span class="ot">{-# OPTIONS_GHC -fplugin GHC.TypeLits.Normalise #-}</span></a>
<a class="sourceLine" id="cb1-15" data-line-number="15"></a>
<a class="sourceLine" id="cb1-16" data-line-number="16"><span class="kw">module</span> <span class="dt">VerifiedDataStructures</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-17" data-line-number="17"></a>
<a class="sourceLine" id="cb1-18" data-line-number="18"><span class="kw">import</span> <span class="dt">Data.Kind</span> <span class="kw">hiding</span> (type (*))</a>
<a class="sourceLine" id="cb1-19" data-line-number="19"><span class="kw">import</span> <span class="dt">Data.Type.Equality</span></a>
<a class="sourceLine" id="cb1-20" data-line-number="20"><span class="kw">import</span> <span class="dt">Unsafe.Coerce</span></a>
<a class="sourceLine" id="cb1-21" data-line-number="21"><span class="kw">import</span> <span class="dt">GHC.TypeLits</span> <span class="kw">hiding</span> (type (&lt;=))</a>
<a class="sourceLine" id="cb1-22" data-line-number="22"><span class="kw">import</span> <span class="dt">Data.Proxy</span></a>
<a class="sourceLine" id="cb1-23" data-line-number="23"><span class="kw">import</span> <span class="dt">Data.Coerce</span></a>
<a class="sourceLine" id="cb1-24" data-line-number="24"><span class="kw">import</span> <span class="dt">Prelude</span></a></code></pre></div>
<p>A while ago I read <a href="https://www.reddit.com/r/haskell/comments/63a4ea/fast_total_sorting_of_arbitrary_traversable/">this</a> post on reddit (by David Feuer), about sorting traversables (which was a follow-up on <a href="http://elvishjerricco.github.io/2017/03/23/applicative-sorting.html">this</a> post by Will Fancher), and I was inspired to write some pseudo-dependently-typed Haskell. The post (and subsequent <a href="https://github.com/treeowl/sort-traversable">library</a>) detailed how to use size-indexed heaps to perform fast, total sorting on any traversable. I ended up with a <a href="https://github.com/oisdk/type-indexed-queues">library</a> which has five size-indexed heaps (Braun, pairing, binomial, skew, and leftist), each verified for structural correctness. I also included the non-indexed implementations of each for comparison (as well as benchmarks, tests, and all that good stuff).</p>
<p>The purpose of this post is to go through some of the tricks I used and problems I encountered writing a lot of type-level code in modern Haskell.</p>
<h3 id="type-level-numbers-in-haskell">Type-Level Numbers in Haskell</h3>
<p>In order to index things by their size, weâ€™ll need a type-level representation of size. Weâ€™ll use <a href="https://wiki.haskell.org/Peano_numbers">Peano</a> numbers for now:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Peano</span> <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">|</span> <span class="dt">S</span> <span class="dt">Peano</span></a></code></pre></div>
<p><code class="sourceCode haskell"><span class="dt">Z</span></code> stands for zero, and <code class="sourceCode haskell"><span class="dt">S</span></code> for successor. The terseness is pretty necessary here, unfortunately: arithmetic becomes unreadable otherwise. The simplicity of this definition is useful for proofs and manipulation; however any runtime representation of these numbers is going to be woefully slow.</p>
<p>With the <code class="sourceCode haskell"><span class="dt">DataKinds</span></code> extension, the above is automatically promoted to the type-level, so we can write type-level functions (type families) on the <code class="sourceCode haskell"><span class="dt">Peano</span></code> type:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">Plus</span> (<span class="ot">n ::</span> <span class="dt">Peano</span>) (<span class="ot">m ::</span> <span class="dt">Peano</span>)<span class="ot"> ::</span> <span class="dt">Peano</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">        <span class="dt">Plus</span> <span class="dt">Z</span> m <span class="fu">=</span> m</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">        <span class="dt">Plus</span> (<span class="dt">S</span> n) m <span class="fu">=</span> <span class="dt">S</span> (<span class="dt">Plus</span> n m)</a></code></pre></div>
<p>Here the <code class="sourceCode haskell"><span class="dt">TypeFamilies</span></code> extension is needed. Iâ€™ll try and mention every extension Iâ€™m using as we go, but I might forget a few, so check the repository for all of the examples (quick aside: I <em>did</em> manage to avoid using <code class="sourceCode haskell"><span class="dt">UndecidableInstances</span></code>, but more on that later). One pragma thatâ€™s worth mentioning is:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">{-# OPTIONS_GHC -fno-warn-unticked-promoted-constructors #-}</span></a></code></pre></div>
<p>This suppresses warnings on the definition of <code class="sourceCode haskell"><span class="dt">Plus</span></code> above. Without it, GHC would want us to write:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">Plus</span> (<span class="ot">n ::</span> <span class="dt">Peano</span>) (<span class="ot">m ::</span> <span class="dt">Peano</span>)<span class="ot"> ::</span> <span class="dt">Peano</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">        <span class="dt">Plus</span> <span class="ch">&#39;Z m = m</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">        <span class="dt">Plus</span> (<span class="ch">&#39;S n) m = &#39;</span><span class="dt">S</span> (<span class="dt">Plus</span> n m)</a></code></pre></div>
<p>I think that looks pretty ugly, and it can get much worse with more involved arithmetic. The only thing I have found the warnings useful for is <code class="sourceCode haskell">[]</code>: the type-level empty list gives an error in its unticked form.</p>
<h3 id="using-the-type-level-numbers-with-a-pairing-heap">Using the Type-Level Numbers with a Pairing Heap</h3>
<p>In the original post, a pairing heap <span class="citation" data-cites="fredman_pairing_1986">(Fredman et al. <a href="#ref-fredman_pairing_1986">1986</a>)</span> was used, for its simplicity and performance. The implementation looked like this:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Heap</span> n a <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  <span class="dt">E</span><span class="ot"> ::</span> <span class="dt">Heap</span> <span class="dt">Z</span> a</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  <span class="dt">T</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">HVec</span> n a <span class="ot">-&gt;</span> <span class="dt">Heap</span> (<span class="dt">S</span> n) a</a>
<a class="sourceLine" id="cb6-4" data-line-number="4"></a>
<a class="sourceLine" id="cb6-5" data-line-number="5"><span class="kw">data</span> <span class="dt">HVec</span> n a <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">  <span class="dt">HNil</span><span class="ot"> ::</span> <span class="dt">HVec</span> <span class="dt">Z</span> a</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">  <span class="dt">HCons</span><span class="ot"> ::</span> <span class="dt">Heap</span> m a <span class="ot">-&gt;</span> <span class="dt">HVec</span> n a <span class="ot">-&gt;</span> <span class="dt">HVec</span> (<span class="dt">Plus</span> m n) a</a></code></pre></div>
<p>You immediately run into trouble when you try to define merge:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">merge ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Heap</span> m a <span class="ot">-&gt;</span> <span class="dt">Heap</span> n a <span class="ot">-&gt;</span> <span class="dt">Heap</span> (<span class="dt">Plus</span> m n) a</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">merge <span class="dt">E</span> ys <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">merge xs <span class="dt">E</span> <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">merge h1<span class="fu">@</span>(<span class="dt">T</span> x xs) h2<span class="fu">@</span>(<span class="dt">T</span> y ys)</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">  <span class="fu">|</span> x <span class="fu">&lt;=</span> y <span class="fu">=</span> <span class="dt">T</span> x (<span class="dt">HCons</span> h2 xs)</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">T</span> y (<span class="dt">HCons</span> h1 ys)</a></code></pre></div>
<p>Three errors show up here, but weâ€™ll look at the first one:</p>
<blockquote>
<p><code>Could not deduce (m ~ (Plus m Z))</code></p>
</blockquote>
<p>GHC doesnâ€™t know that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mi>x</mi><mo>+</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x = x + 0</annotation></semantics></math>. Somehow, weâ€™ll have to <em>prove</em> that it does.</p>
<h3 id="singletons">Singletons</h3>
<p>In a language with true dependent types, proving the proposition above is as simple as:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode idris"><code class="sourceCode idris"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="fu">plusZeroNeutral</span> <span class="ot">:</span> (n <span class="ot">:</span> <span class="dt">Nat</span>) <span class="ot">-&gt;</span> n <span class="fu">+</span> <span class="dv">0</span> <span class="fu">=</span> n</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">plusZeroNeutral <span class="dt">Z</span> <span class="fu">=</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">plusZeroNeutral (<span class="dt">S</span> k) <span class="fu">=</span> cong (plusZeroNeutral k)</a></code></pre></div>
<p>(this example is in Idris)</p>
<p>In Haskell, on the other hand, we canâ€™t do the same: functions on the value-level <code class="sourceCode haskell"><span class="dt">Peano</span></code> have no relationship with functions on the type-level <code class="sourceCode haskell"><span class="dt">Peano</span></code>. Thereâ€™s no way to automatically link or promote one to the other.</p>
<p>This is where singletons come in <span class="citation" data-cites="eisenberg_dependently_2012">(Eisenberg and Weirich <a href="#ref-eisenberg_dependently_2012">2012</a>)</span>. A singleton is a datatype which mirrors a type-level value exactly, except that it has a type parameter which matches the equivalent value on the type-level. In this way, we can write functions on the value-level which are linked to the type-level. Hereâ€™s a potential singleton for <code class="sourceCode haskell"><span class="dt">Peano</span></code>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Natty</span> n <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">    <span class="dt">Zy</span><span class="ot"> ::</span> <span class="dt">Natty</span> <span class="dt">Z</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">    <span class="dt">Sy</span><span class="ot"> ::</span> <span class="dt">Natty</span> n <span class="ot">-&gt;</span> <span class="dt">Natty</span> (<span class="dt">S</span> n)</a></code></pre></div>
<p>(we need <code class="sourceCode haskell"><span class="dt">GADTs</span></code> for this example)</p>
<p>Now, when we pattern-match on <code class="sourceCode haskell"><span class="dt">Natty</span></code>, we get a proof of whatever its type parameter was. Hereâ€™s a trivial example:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">isZero ::</span> <span class="dt">Natty</span> n <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (n <span class="fu">:~:</span> <span class="dt">Z</span>)</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">isZero <span class="dt">Zy</span> <span class="fu">=</span> <span class="dt">Just</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3">isZero (<span class="dt">Sy</span> _) <span class="fu">=</span> <span class="dt">Nothing</span></a></code></pre></div>
<p>When we match on <code class="sourceCode haskell"><span class="dt">Zy</span></code>, the <em>only value</em> which <code class="sourceCode haskell">n</code> could have been is <code class="sourceCode haskell"><span class="dt">Z</span></code>, because the only way to construct <code class="sourceCode haskell"><span class="dt">Zy</span></code> is if the type parameter is <code class="sourceCode haskell"><span class="dt">Z</span></code>.</p>
<p>Using this technique, the <code class="sourceCode haskell">plusZeroNeutral</code> proof looks reasonably similar to the Idris version:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">plusZeroNeutral ::</span> <span class="dt">Natty</span> n <span class="ot">-&gt;</span> <span class="dt">Plus</span> n <span class="dt">Z</span> <span class="fu">:~:</span> n</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">plusZeroNeutral <span class="dt">Zy</span> <span class="fu">=</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">plusZeroNeutral (<span class="dt">Sy</span> n) <span class="fu">=</span> <span class="kw">case</span> plusZeroNeutral n <span class="kw">of</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4">    <span class="dt">Refl</span> <span class="ot">-&gt;</span> <span class="dt">Refl</span></a></code></pre></div>
<p>To generalize the singletons a little, we could probably use the <a href="https://hackage.haskell.org/package/singletons">singletons</a> library, or we could roll our own:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">data</span> family <span class="dt">The</span><span class="ot"> k ::</span> k <span class="ot">-&gt;</span> <span class="dt">Type</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2"></a>
<a class="sourceLine" id="cb12-3" data-line-number="3"><span class="kw">data</span> <span class="kw">instance</span> <span class="dt">The</span> <span class="dt">Peano</span> n <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">    <span class="dt">Zy</span><span class="ot"> ::</span> <span class="dt">The</span> <span class="dt">Peano</span> <span class="dt">Z</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5">    <span class="dt">Sy</span><span class="ot"> ::</span> <span class="dt">The</span> <span class="dt">Peano</span> n <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Peano</span> (<span class="dt">S</span> n)</a>
<a class="sourceLine" id="cb12-6" data-line-number="6"></a>
<a class="sourceLine" id="cb12-7" data-line-number="7"><span class="ot">plusZeroNeutral ::</span> <span class="dt">The</span> <span class="dt">Peano</span> n <span class="ot">-&gt;</span> <span class="dt">Plus</span> n <span class="dt">Z</span> <span class="fu">:~:</span> n</a>
<a class="sourceLine" id="cb12-8" data-line-number="8">plusZeroNeutral <span class="dt">Zy</span> <span class="fu">=</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb12-9" data-line-number="9">plusZeroNeutral (<span class="dt">Sy</span> n) <span class="fu">=</span> <span class="kw">case</span> plusZeroNeutral n <span class="kw">of</span></a>
<a class="sourceLine" id="cb12-10" data-line-number="10">    <span class="dt">Refl</span> <span class="ot">-&gt;</span> <span class="dt">Refl</span></a></code></pre></div>
<p>The <code class="sourceCode haskell"><span class="dt">The</span></code> naming is kind of cute, I think. It makes the signature look <em>almost</em> like the Idris version (<code class="sourceCode idris">the</code> is a function from the Idris standard library). The <code class="sourceCode haskell"><span class="dt">The</span></code> type family requires the <code class="sourceCode haskell"><span class="dt">TypeInType</span></code> extension, which Iâ€™ll talk a little more about later.</p>
<h3 id="proof-erasure-and-totality">Proof Erasure and Totality</h3>
<p>Thereâ€™s an issue with these kinds of proofs: the proof code runs <em>every time</em> it is needed. Since the same value is coming out the other end each time (<code class="sourceCode haskell"><span class="dt">Refl</span></code>), this seems wasteful.</p>
<p>In a language like Idris, this problem is avoided by noticing that youâ€™re only using the proof for its type information, and then erasing it at runtime. In Haskell, we can accomplish the same with a rule:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="ot">{-# NOINLINE plusZeroNeutral #-}</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2"></a>
<a class="sourceLine" id="cb13-3" data-line-number="3"><span class="ot">{-# RULES</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4"><span class="ot">&quot;plusZeroNeutral&quot; forall x. plusZeroNeutral x </span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5"><span class="ot">  = unsafeCoerce (Refl :: &#39;Z :~: &#39;Z)</span></a>
<a class="sourceLine" id="cb13-6" data-line-number="6"><span class="ot"> #-}</span></a></code></pre></div>
<p>This basically says â€œif this type-checks, then the proof must exist, and therefore the proof must be valid. So donâ€™t bother running itâ€. Unfortunately, thatâ€™s a <em>little bit</em> of a lie. Itâ€™s pretty easy to write a proof which type-checks that <em>isnâ€™t</em> valid:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="ot">falseIsTrue ::</span> <span class="dt">False</span> <span class="fu">:~:</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2">falseIsTrue <span class="fu">=</span> falseIsTrue</a></code></pre></div>
<p>We wonâ€™t be able to perform computations which rely on this proof in Haskell, though: because the computation will never terminate, the proof will never provide an answer. This means that, while the proof isnâ€™t valid, it <em>is</em> type safe. That is, of course, unless we use our manual proof-erasure technique. The <code class="sourceCode haskell"><span class="dt">RULES</span></code> pragma will happily replace it with the <code class="sourceCode haskell">unsafeCoerce</code> version, effectively introducing unsoundness into our proofs. The reason that this doesnâ€™t cause a problem for language like Idris is that Idris has a totality checker: you <em>canâ€™t</em> write the above definition (with the totality checker turned on) in Idris.</p>
<p>So whatâ€™s the solution? Do we have to suffer through the slower proof code to maintain correctness? In reality, itâ€™s usually OK to assume termination. Itâ€™s pretty easy to see that a proof like <code class="sourceCode haskell">plusZeroNeutral</code> is total. Itâ€™s worth bearing in mind, though, that until Haskell gets a totality checker (<a href="https://typesandkinds.wordpress.com/2016/07/24/dependent-types-in-haskell-progress-report/">likely never</a>, apparently) these proofs arenâ€™t â€œproperâ€.</p>
<h3 id="generating-singletons">Generating Singletons</h3>
<p>One extra thing: while youâ€™re proving things in one area of your code, you might not have the relevant singleton handy. To generate them on-demand, youâ€™ll need a typeclass:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="kw">class</span> <span class="dt">KnownSing</span> (<span class="ot">x ::</span> k) <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2"><span class="ot">    sing ::</span> <span class="dt">The</span> k x</a>
<a class="sourceLine" id="cb15-3" data-line-number="3"></a>
<a class="sourceLine" id="cb15-4" data-line-number="4"><span class="kw">instance</span> <span class="dt">KnownSing</span> <span class="dt">Z</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-5" data-line-number="5">    sing <span class="fu">=</span> <span class="dt">Zy</span></a>
<a class="sourceLine" id="cb15-6" data-line-number="6"></a>
<a class="sourceLine" id="cb15-7" data-line-number="7"><span class="kw">instance</span> <span class="dt">KnownSing</span> n <span class="ot">=&gt;</span> <span class="dt">KnownSing</span> (<span class="dt">S</span> n) <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-8" data-line-number="8">    sing <span class="fu">=</span> <span class="dt">Sy</span> sing</a></code></pre></div>
<p>This kind of drives home the inefficiency of singleton-based proofs, and why itâ€™s important to erase them aggressively.</p>
<h3 id="proofs-bundled-with-the-data-structure">Proofs Bundled with the Data Structure</h3>
<p>One other way to solve these problems is to try find a data structure which runs the proof code anyway. As an example, consider a length-indexed list:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:-</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2"><span class="kw">data</span> <span class="dt">List</span> n a <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3">    <span class="dt">Nil</span><span class="ot"> ::</span> <span class="dt">List</span> <span class="dt">Z</span> a</a>
<a class="sourceLine" id="cb16-4" data-line-number="4"><span class="ot">    (:-) ::</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> n a <span class="ot">-&gt;</span> <span class="dt">List</span> (<span class="dt">S</span> n) a</a></code></pre></div>
<p>You might worry that concatenation of two lists requires some expensive proof code, like <code class="sourceCode haskell">merge</code> for the pairing heap. Maybe surprisingly, the default implementation just works:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">++</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2"><span class="ot">(++) ::</span> <span class="dt">List</span> n a <span class="ot">-&gt;</span> <span class="dt">List</span> m a <span class="ot">-&gt;</span> <span class="dt">List</span> (<span class="dt">Plus</span> n m) a</a>
<a class="sourceLine" id="cb17-3" data-line-number="3">(<span class="fu">++</span>) <span class="dt">Nil</span> ys <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb17-4" data-line-number="4">(<span class="fu">++</span>) (x <span class="fu">:-</span> xs) ys <span class="fu">=</span> x <span class="fu">:-</span> xs <span class="fu">++</span> ys</a></code></pre></div>
<p>Why? Well, if you look back to the definition of <code class="sourceCode haskell"><span class="dt">Plus</span></code>, itâ€™s almost exactly the same as the definition of <code class="sourceCode haskell">(<span class="fu">++</span>)</code>. In effect, weâ€™re using <em>lists</em> as the singleton for <code class="sourceCode haskell"><span class="dt">Peano</span></code> here.</p>
<p>The question is, then: is there a heap which performs these proofs automatically for functions like merge? As far as I can tell: <em>almost</em>. First though:</p>
<h3 id="small-digression-manipulating-and-using-the-length-indexed-list">Small Digression: Manipulating and Using the Length-Indexed List</h3>
<p>The standard definition of <code class="sourceCode haskell"><span class="fu">++</span></code> on normal lists can be cleaned up a little with <code class="sourceCode haskell">foldr</code></p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="ot">(++) ::</span> [a] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">(<span class="fu">++</span>) <span class="fu">=</span> flip (foldr (<span class="fu">:</span>))</a></code></pre></div>
<p>Can we get a similar definition for our length-indexed lists? Turns out we can, but the type of <code class="sourceCode haskell">foldr</code> needs to be a little different:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="ot">foldrList ::</span> (forall x<span class="fu">.</span> a <span class="ot">-&gt;</span> b x <span class="ot">-&gt;</span> b (<span class="dt">S</span> x)) </a>
<a class="sourceLine" id="cb19-2" data-line-number="2">          <span class="ot">-&gt;</span> b m <span class="ot">-&gt;</span> <span class="dt">List</span> n a <span class="ot">-&gt;</span> b (n <span class="fu">+</span> m)</a>
<a class="sourceLine" id="cb19-3" data-line-number="3">foldrList f b <span class="dt">Nil</span> <span class="fu">=</span> b</a>
<a class="sourceLine" id="cb19-4" data-line-number="4">foldrList f b (x <span class="fu">:-</span> xs) <span class="fu">=</span> f x (foldrList f b xs)</a>
<a class="sourceLine" id="cb19-5" data-line-number="5"></a>
<a class="sourceLine" id="cb19-6" data-line-number="6"><span class="kw">newtype</span> <span class="dt">Flip</span> (<span class="ot">f ::</span> t <span class="ot">-&gt;</span> u <span class="ot">-&gt;</span> <span class="dt">Type</span>) (<span class="ot">a ::</span> u) (<span class="ot">b ::</span> t) </a>
<a class="sourceLine" id="cb19-7" data-line-number="7">    <span class="fu">=</span> <span class="dt">Flip</span> {<span class="ot"> unFlip ::</span> f b a }</a>
<a class="sourceLine" id="cb19-8" data-line-number="8"></a>
<a class="sourceLine" id="cb19-9" data-line-number="9"><span class="ot">foldrList1 ::</span> (forall x<span class="fu">.</span> a <span class="ot">-&gt;</span> b x c <span class="ot">-&gt;</span> b (<span class="dt">S</span> x) c) </a>
<a class="sourceLine" id="cb19-10" data-line-number="10">           <span class="ot">-&gt;</span> b m c <span class="ot">-&gt;</span> <span class="dt">List</span> n a <span class="ot">-&gt;</span> b (n <span class="fu">+</span> m) c</a>
<a class="sourceLine" id="cb19-11" data-line-number="11">foldrList1 f b </a>
<a class="sourceLine" id="cb19-12" data-line-number="12">    <span class="fu">=</span> unFlip <span class="fu">.</span> foldrList (\e <span class="ot">-&gt;</span> <span class="dt">Flip</span> <span class="fu">.</span> f e <span class="fu">.</span> unFlip) (<span class="dt">Flip</span> b)</a>
<a class="sourceLine" id="cb19-13" data-line-number="13"></a>
<a class="sourceLine" id="cb19-14" data-line-number="14"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">++</span></a>
<a class="sourceLine" id="cb19-15" data-line-number="15"><span class="ot">(++) ::</span> <span class="dt">List</span> n a <span class="ot">-&gt;</span> <span class="dt">List</span> m a <span class="ot">-&gt;</span> <span class="dt">List</span> (n <span class="fu">+</span> m) a</a>
<a class="sourceLine" id="cb19-16" data-line-number="16">(<span class="fu">++</span>) <span class="fu">=</span> flip (foldrList1 (<span class="fu">:-</span>))</a></code></pre></div>
<p>So whatâ€™s the point of this more complicated version? Well, if this were normal Haskell, we might get some foldr-fusion or something (in reality we would probably use <a href="http://hackage.haskell.org/package/base-4.9.1.0/docs/GHC-Exts.html#v:augment"><code class="sourceCode haskell">augment</code></a> if that were the purpose).</p>
<p>With this type-level business, though, thereâ€™s a similar application: loop unrolling. Consider the natural-number type again. We can write a typeclass which will perform induction over them:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="kw">class</span> <span class="dt">KnownPeano</span> (<span class="ot">n ::</span> <span class="dt">Peano</span>)  <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2"><span class="ot">    unrollRepeat ::</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb20-3" data-line-number="3"></a>
<a class="sourceLine" id="cb20-4" data-line-number="4"><span class="kw">instance</span> <span class="dt">KnownPeano</span> <span class="dt">Z</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-5" data-line-number="5">    unrollRepeat _ <span class="fu">=</span> const id</a>
<a class="sourceLine" id="cb20-6" data-line-number="6">    <span class="ot">{-# INLINE unrollRepeat #-}</span></a>
<a class="sourceLine" id="cb20-7" data-line-number="7"></a>
<a class="sourceLine" id="cb20-8" data-line-number="8"><span class="kw">instance</span> <span class="dt">KnownPeano</span> n <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb20-9" data-line-number="9">         <span class="dt">KnownPeano</span> (<span class="dt">S</span> n) <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-10" data-line-number="10">    unrollRepeat (<span class="ot">_ ::</span> <span class="dt">Proxy</span> (<span class="dt">S</span> n)) f x <span class="fu">=</span></a>
<a class="sourceLine" id="cb20-11" data-line-number="11">        f (unrollRepeat (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> n) f x)</a>
<a class="sourceLine" id="cb20-12" data-line-number="12">    <span class="ot">{-# INLINE unrollRepeat #-}</span></a></code></pre></div>
<p>Because the recursion here calls a different <code class="sourceCode haskell">unrollRepeat</code> function in the â€œrecursiveâ€ call, we get around the <a href="http://stackoverflow.com/questions/42179783/is-there-any-way-to-inline-a-recursive-function">usual hurdle</a> of not being able to inline recursive calls. That means that the whole loop will be unrolled, at compile-time. We can do the same for foldr:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="kw">class</span> <span class="dt">HasFoldr</span> (<span class="ot">n ::</span> <span class="dt">Peano</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-2" data-line-number="2">    unrollFoldr </a>
<a class="sourceLine" id="cb21-3" data-line-number="3"><span class="ot">        ::</span> (forall x<span class="fu">.</span> a <span class="ot">-&gt;</span> b x <span class="ot">-&gt;</span> b (<span class="dt">S</span> x)) </a>
<a class="sourceLine" id="cb21-4" data-line-number="4">        <span class="ot">-&gt;</span> b m </a>
<a class="sourceLine" id="cb21-5" data-line-number="5">        <span class="ot">-&gt;</span> <span class="dt">List</span> n a </a>
<a class="sourceLine" id="cb21-6" data-line-number="6">        <span class="ot">-&gt;</span> b (n <span class="fu">+</span> m)</a>
<a class="sourceLine" id="cb21-7" data-line-number="7">  </a>
<a class="sourceLine" id="cb21-8" data-line-number="8"><span class="kw">instance</span> <span class="dt">HasFoldr</span> <span class="dt">Z</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-9" data-line-number="9">    unrollFoldr _ b _ <span class="fu">=</span> b</a>
<a class="sourceLine" id="cb21-10" data-line-number="10">    <span class="ot">{-# INLINE unrollFoldr #-}</span></a>
<a class="sourceLine" id="cb21-11" data-line-number="11"></a>
<a class="sourceLine" id="cb21-12" data-line-number="12"><span class="kw">instance</span> <span class="dt">HasFoldr</span> n <span class="ot">=&gt;</span> <span class="dt">HasFoldr</span> (<span class="dt">S</span> n) <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-13" data-line-number="13">    unrollFoldr f b (x <span class="fu">:-</span> xs) <span class="fu">=</span> f x (unrollFoldr f b xs)</a>
<a class="sourceLine" id="cb21-14" data-line-number="14">    <span class="ot">{-# INLINE unrollFoldr #-}</span></a></code></pre></div>
<p>I canâ€™t think of many uses for this technique, but one that comes to mind is an n-ary uncurry (like Lispâ€™s <a href="https://en.wikipedia.org/wiki/Apply#Common_Lisp_and_Scheme">apply</a>):</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:-</span></a>
<a class="sourceLine" id="cb22-2" data-line-number="2"><span class="kw">data</span> <span class="dt">List</span> (<span class="ot">xs ::</span> [<span class="fu">*</span>]) <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-3" data-line-number="3">        <span class="dt">Nil</span><span class="ot"> ::</span> <span class="dt">List</span> <span class="ch">&#39;[]</span></a>
<a class="sourceLine" id="cb22-4" data-line-number="4"><span class="ot">        (:-) ::</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> xs <span class="ot">-&gt;</span> <span class="dt">List</span> (a <span class="ch">&#39;: xs)</span></a>
<a class="sourceLine" id="cb22-5" data-line-number="5"></a>
<a class="sourceLine" id="cb22-6" data-line-number="6"><span class="kw">class</span> <span class="dt">KnownList</span> (<span class="ot">xs ::</span> [<span class="fu">*</span>])  <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-7" data-line-number="7">    foldrT</a>
<a class="sourceLine" id="cb22-8" data-line-number="8"><span class="ot">        ::</span> (forall y ys<span class="fu">.</span> y <span class="ot">-&gt;</span> result ys <span class="ot">-&gt;</span> result (y <span class="ch">&#39;: ys))</span></a>
<a class="sourceLine" id="cb22-9" data-line-number="9">        <span class="ot">-&gt;</span> result <span class="ch">&#39;[]</span></a>
<a class="sourceLine" id="cb22-10" data-line-number="10">        <span class="ot">-&gt;</span> <span class="dt">List</span> xs</a>
<a class="sourceLine" id="cb22-11" data-line-number="11">        <span class="ot">-&gt;</span> result xs</a>
<a class="sourceLine" id="cb22-12" data-line-number="12"></a>
<a class="sourceLine" id="cb22-13" data-line-number="13"><span class="kw">instance</span> <span class="dt">KnownList</span> (<span class="ch">&#39;[] :: [*]) where</span></a>
<a class="sourceLine" id="cb22-14" data-line-number="14">    foldrT _ <span class="fu">=</span> const</a>
<a class="sourceLine" id="cb22-15" data-line-number="15">    <span class="ot">{-# INLINE foldrT #-}</span></a>
<a class="sourceLine" id="cb22-16" data-line-number="16"></a>
<a class="sourceLine" id="cb22-17" data-line-number="17"><span class="kw">instance</span> <span class="dt">KnownList</span> xs <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb22-18" data-line-number="18">         <span class="dt">KnownList</span> (x <span class="ch">&#39;: xs) where</span></a>
<a class="sourceLine" id="cb22-19" data-line-number="19">    foldrT f b (x <span class="fu">:-</span> xs) <span class="fu">=</span> f x (foldrT f b xs)</a>
<a class="sourceLine" id="cb22-20" data-line-number="20">    <span class="ot">{-# INLINE foldrT #-}</span></a>
<a class="sourceLine" id="cb22-21" data-line-number="21"></a>
<a class="sourceLine" id="cb22-22" data-line-number="22"><span class="kw">type</span> family <span class="dt">Func</span> (<span class="ot">xs ::</span> [<span class="fu">*</span>]) (<span class="ot">y ::</span> <span class="fu">*</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-23" data-line-number="23">        <span class="dt">Func</span> <span class="ch">&#39;[] y = y</span></a>
<a class="sourceLine" id="cb22-24" data-line-number="24">        <span class="dt">Func</span> (x <span class="ch">&#39;: xs) y = x -&gt; Func xs y</span></a>
<a class="sourceLine" id="cb22-25" data-line-number="25"></a>
<a class="sourceLine" id="cb22-26" data-line-number="26"><span class="kw">newtype</span> <span class="dt">FunType</span> y xs <span class="fu">=</span> <span class="dt">FunType</span></a>
<a class="sourceLine" id="cb22-27" data-line-number="27">    {<span class="ot"> runFun ::</span> <span class="dt">Func</span> xs y <span class="ot">-&gt;</span> y</a>
<a class="sourceLine" id="cb22-28" data-line-number="28">    }</a>
<a class="sourceLine" id="cb22-29" data-line-number="29"></a>
<a class="sourceLine" id="cb22-30" data-line-number="30">uncurry</a>
<a class="sourceLine" id="cb22-31" data-line-number="31"><span class="ot">    ::</span> <span class="dt">KnownList</span> xs</a>
<a class="sourceLine" id="cb22-32" data-line-number="32">    <span class="ot">=&gt;</span> <span class="dt">Func</span> xs y <span class="ot">-&gt;</span> <span class="dt">List</span> xs <span class="ot">-&gt;</span> y</a>
<a class="sourceLine" id="cb22-33" data-line-number="33">uncurry f l <span class="fu">=</span></a>
<a class="sourceLine" id="cb22-34" data-line-number="34">    runFun</a>
<a class="sourceLine" id="cb22-35" data-line-number="35">        (foldrT</a>
<a class="sourceLine" id="cb22-36" data-line-number="36">             (c (\x g h <span class="ot">-&gt;</span> g (h x)))</a>
<a class="sourceLine" id="cb22-37" data-line-number="37">             (<span class="dt">FunType</span> id)</a>
<a class="sourceLine" id="cb22-38" data-line-number="38">             l)</a>
<a class="sourceLine" id="cb22-39" data-line-number="39">        f</a>
<a class="sourceLine" id="cb22-40" data-line-number="40">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-41" data-line-number="41"><span class="ot">    c ::</span> (a <span class="ot">-&gt;</span> ((<span class="dt">Func</span> xs y <span class="ot">-&gt;</span> y) <span class="ot">-&gt;</span> (<span class="dt">Func</span> zs z <span class="ot">-&gt;</span> z)))</a>
<a class="sourceLine" id="cb22-42" data-line-number="42">      <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> (<span class="dt">FunType</span> y xs <span class="ot">-&gt;</span> <span class="dt">FunType</span> z zs))</a>
<a class="sourceLine" id="cb22-43" data-line-number="43">    c <span class="fu">=</span> coerce</a>
<a class="sourceLine" id="cb22-44" data-line-number="44">    <span class="ot">{-# INLINE c #-}</span></a>
<a class="sourceLine" id="cb22-45" data-line-number="45"><span class="ot">{-# INLINE uncurry #-}</span></a></code></pre></div>
<p>I <em>think</em> that you can be guaranteed the above is inlined at compile-time, making it essentially equivalent to a handwritten <code class="sourceCode haskell">uncurry</code>.</p>
<h3 id="binomial-heaps">Binomial Heaps</h3>
<p>Anyway, back to the size-indexed heaps. The reason that <code class="sourceCode haskell">(<span class="fu">++</span>)</code> worked so easily on lists is that a list can be thought of as the data-structure equivalent to Peano numbers. Another numeric-system-based data structure is the binomial heap, which is based on binary numbering <span class="citation" data-cites="hinze_functional_1999">(Iâ€™m going mainly off of the description from Hinze <a href="#ref-hinze_functional_1999">1999</a>)</span>.</p>
<p>So, to work with binary numbers, letâ€™s get some preliminaries on the type-level out of the way:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="kw">data</span> <span class="kw">instance</span> <span class="dt">The</span> <span class="dt">Bool</span> x <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-2" data-line-number="2">    <span class="dt">Falsy</span><span class="ot"> ::</span> <span class="dt">The</span> <span class="dt">Bool</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb23-3" data-line-number="3">    <span class="dt">Truey</span><span class="ot"> ::</span> <span class="dt">The</span> <span class="dt">Bool</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb23-4" data-line-number="4"></a>
<a class="sourceLine" id="cb23-5" data-line-number="5"><span class="kw">data</span> <span class="kw">instance</span> <span class="dt">The</span> [k] xs <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-6" data-line-number="6">    <span class="dt">Nily</span><span class="ot"> ::</span> <span class="dt">The</span> [k] <span class="ch">&#39;[]</span></a>
<a class="sourceLine" id="cb23-7" data-line-number="7">    <span class="dt">Cony</span><span class="ot"> ::</span> <span class="dt">The</span> k x <span class="ot">-&gt;</span> <span class="dt">The</span> [k] xs <span class="ot">-&gt;</span> <span class="dt">The</span> [k] (x <span class="fu">:</span> xs)</a>
<a class="sourceLine" id="cb23-8" data-line-number="8"></a>
<a class="sourceLine" id="cb23-9" data-line-number="9"><span class="kw">instance</span> <span class="dt">KnownSing</span> <span class="dt">True</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-10" data-line-number="10">    sing <span class="fu">=</span> <span class="dt">Truey</span></a>
<a class="sourceLine" id="cb23-11" data-line-number="11"></a>
<a class="sourceLine" id="cb23-12" data-line-number="12"><span class="kw">instance</span> <span class="dt">KnownSing</span> <span class="dt">False</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-13" data-line-number="13">    sing <span class="fu">=</span> <span class="dt">Falsy</span></a>
<a class="sourceLine" id="cb23-14" data-line-number="14"></a>
<a class="sourceLine" id="cb23-15" data-line-number="15"><span class="kw">instance</span> <span class="dt">KnownSing</span> <span class="ch">&#39;[] where</span></a>
<a class="sourceLine" id="cb23-16" data-line-number="16">    sing <span class="fu">=</span> <span class="dt">Nily</span></a>
<a class="sourceLine" id="cb23-17" data-line-number="17"></a>
<a class="sourceLine" id="cb23-18" data-line-number="18"><span class="kw">instance</span> (<span class="dt">KnownSing</span> xs, <span class="dt">KnownSing</span> x) <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb23-19" data-line-number="19">         <span class="dt">KnownSing</span> (x <span class="fu">:</span> xs) <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-20" data-line-number="20">    sing <span class="fu">=</span> <span class="dt">Cony</span> sing sing</a></code></pre></div>
<p>Weâ€™ll represent a binary number as a list of Booleans:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">Sum</span> (<span class="ot">x ::</span> <span class="dt">Bool</span>) (<span class="ot">y ::</span> <span class="dt">Bool</span>) (<span class="ot">cin ::</span> <span class="dt">Bool</span>)<span class="ot"> ::</span> <span class="dt">Bool</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-2" data-line-number="2">        <span class="dt">Sum</span> <span class="dt">False</span> <span class="dt">False</span> <span class="dt">False</span> <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb24-3" data-line-number="3">        <span class="dt">Sum</span> <span class="dt">False</span> <span class="dt">False</span> <span class="dt">True</span>  <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb24-4" data-line-number="4">        <span class="dt">Sum</span> <span class="dt">False</span> <span class="dt">True</span>  <span class="dt">False</span> <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb24-5" data-line-number="5">        <span class="dt">Sum</span> <span class="dt">False</span> <span class="dt">True</span>  <span class="dt">True</span>  <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb24-6" data-line-number="6">        <span class="dt">Sum</span> <span class="dt">True</span>  <span class="dt">False</span> <span class="dt">False</span> <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb24-7" data-line-number="7">        <span class="dt">Sum</span> <span class="dt">True</span>  <span class="dt">False</span> <span class="dt">True</span>  <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb24-8" data-line-number="8">        <span class="dt">Sum</span> <span class="dt">True</span>  <span class="dt">True</span>  <span class="dt">False</span> <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb24-9" data-line-number="9">        <span class="dt">Sum</span> <span class="dt">True</span>  <span class="dt">True</span>  <span class="dt">True</span>  <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb24-10" data-line-number="10"></a>
<a class="sourceLine" id="cb24-11" data-line-number="11"><span class="kw">type</span> family <span class="dt">Carry</span> (<span class="ot">x ::</span> <span class="dt">Bool</span>) (<span class="ot">y ::</span> <span class="dt">Bool</span>) (<span class="ot">cin ::</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb24-12" data-line-number="12">     (<span class="ot">xs ::</span> [<span class="dt">Bool</span>]) (<span class="ot">ys ::</span> [<span class="dt">Bool</span>])<span class="ot"> ::</span> [<span class="dt">Bool</span>] <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-13" data-line-number="13">        <span class="dt">Carry</span> <span class="dt">False</span> <span class="dt">False</span> <span class="dt">False</span> xs ys <span class="fu">=</span> <span class="dt">Add</span> <span class="dt">False</span> xs ys</a>
<a class="sourceLine" id="cb24-14" data-line-number="14">        <span class="dt">Carry</span> <span class="dt">False</span> <span class="dt">False</span> <span class="dt">True</span>  xs ys <span class="fu">=</span> <span class="dt">Add</span> <span class="dt">False</span> xs ys</a>
<a class="sourceLine" id="cb24-15" data-line-number="15">        <span class="dt">Carry</span> <span class="dt">False</span> <span class="dt">True</span>  <span class="dt">False</span> xs ys <span class="fu">=</span> <span class="dt">Add</span> <span class="dt">False</span> xs ys</a>
<a class="sourceLine" id="cb24-16" data-line-number="16">        <span class="dt">Carry</span> <span class="dt">False</span> <span class="dt">True</span>  <span class="dt">True</span>  xs ys <span class="fu">=</span> <span class="dt">Add</span> <span class="dt">True</span>  xs ys</a>
<a class="sourceLine" id="cb24-17" data-line-number="17">        <span class="dt">Carry</span> <span class="dt">True</span>  <span class="dt">False</span> <span class="dt">False</span> xs ys <span class="fu">=</span> <span class="dt">Add</span> <span class="dt">False</span> xs ys</a>
<a class="sourceLine" id="cb24-18" data-line-number="18">        <span class="dt">Carry</span> <span class="dt">True</span>  <span class="dt">False</span> <span class="dt">True</span>  xs ys <span class="fu">=</span> <span class="dt">Add</span> <span class="dt">True</span>  xs ys</a>
<a class="sourceLine" id="cb24-19" data-line-number="19">        <span class="dt">Carry</span> <span class="dt">True</span>  <span class="dt">True</span>  <span class="dt">False</span> xs ys <span class="fu">=</span> <span class="dt">Add</span> <span class="dt">True</span>  xs ys</a>
<a class="sourceLine" id="cb24-20" data-line-number="20">        <span class="dt">Carry</span> <span class="dt">True</span>  <span class="dt">True</span>  <span class="dt">True</span>  xs ys <span class="fu">=</span> <span class="dt">Add</span> <span class="dt">True</span>  xs ys</a>
<a class="sourceLine" id="cb24-21" data-line-number="21"></a>
<a class="sourceLine" id="cb24-22" data-line-number="22"><span class="kw">type</span> family <span class="dt">Add</span> (<span class="ot">cin ::</span> <span class="dt">Bool</span>) (<span class="ot">xs ::</span> [<span class="dt">Bool</span>]) (<span class="ot">ys ::</span> [<span class="dt">Bool</span>]) <span class="ot">::</span></a>
<a class="sourceLine" id="cb24-23" data-line-number="23">     [<span class="dt">Bool</span>] <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-24" data-line-number="24">        <span class="dt">Add</span> c (x <span class="fu">:</span> xs) (y <span class="fu">:</span> ys) <span class="fu">=</span> <span class="dt">Sum</span> x y c <span class="fu">:</span> <span class="dt">Carry</span> x y c xs ys</a>
<a class="sourceLine" id="cb24-25" data-line-number="25">        <span class="dt">Add</span> <span class="dt">False</span> <span class="ch">&#39;[] ys = ys</span></a>
<a class="sourceLine" id="cb24-26" data-line-number="26">        <span class="dt">Add</span> <span class="dt">False</span> xs <span class="ch">&#39;[] = xs</span></a>
<a class="sourceLine" id="cb24-27" data-line-number="27">        <span class="dt">Add</span> <span class="dt">True</span>  <span class="ch">&#39;[] ys = CarryOne ys</span></a>
<a class="sourceLine" id="cb24-28" data-line-number="28">        <span class="dt">Add</span> <span class="dt">True</span>  xs <span class="ch">&#39;[] = CarryOne xs</span></a>
<a class="sourceLine" id="cb24-29" data-line-number="29"></a>
<a class="sourceLine" id="cb24-30" data-line-number="30"><span class="kw">type</span> family <span class="dt">CarryOne</span> (<span class="ot">xs ::</span> [<span class="dt">Bool</span>])<span class="ot"> ::</span> [<span class="dt">Bool</span>] <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-31" data-line-number="31">        <span class="dt">CarryOne</span> <span class="ch">&#39;[] = True : &#39;</span>[]</a>
<a class="sourceLine" id="cb24-32" data-line-number="32">        <span class="dt">CarryOne</span> (<span class="dt">False</span> <span class="fu">:</span> xs) <span class="fu">=</span> <span class="dt">True</span> <span class="fu">:</span> xs</a>
<a class="sourceLine" id="cb24-33" data-line-number="33">        <span class="dt">CarryOne</span> (<span class="dt">True</span>  <span class="fu">:</span> xs) <span class="fu">=</span> <span class="dt">False</span> <span class="fu">:</span> <span class="dt">CarryOne</span> xs</a></code></pre></div>
<p>The odd definition of <code class="sourceCode haskell"><span class="dt">Carry</span></code> is to avoid <code class="sourceCode haskell"><span class="dt">UndecidableInstances</span></code>: if we had written, instead:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">Carry</span> (<span class="ot">x ::</span> <span class="dt">Bool</span>) (<span class="ot">y ::</span> <span class="dt">Bool</span>) (<span class="ot">cin ::</span> <span class="dt">Bool</span>)<span class="ot"> ::</span> <span class="dt">Bool</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-2" data-line-number="2">        <span class="dt">Carry</span> <span class="dt">False</span> <span class="dt">False</span> <span class="dt">False</span> <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb25-3" data-line-number="3">        <span class="dt">Carry</span> <span class="dt">False</span> <span class="dt">False</span> <span class="dt">True</span>  <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb25-4" data-line-number="4">        <span class="dt">Carry</span> <span class="dt">False</span> <span class="dt">True</span>  <span class="dt">False</span> <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb25-5" data-line-number="5">        <span class="dt">Carry</span> <span class="dt">False</span> <span class="dt">True</span>  <span class="dt">True</span>  <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb25-6" data-line-number="6">        <span class="dt">Carry</span> <span class="dt">True</span>  <span class="dt">False</span> <span class="dt">False</span> <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb25-7" data-line-number="7">        <span class="dt">Carry</span> <span class="dt">True</span>  <span class="dt">False</span> <span class="dt">True</span>  <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb25-8" data-line-number="8">        <span class="dt">Carry</span> <span class="dt">True</span>  <span class="dt">True</span>  <span class="dt">False</span> <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb25-9" data-line-number="9">        <span class="dt">Carry</span> <span class="dt">True</span>  <span class="dt">True</span>  <span class="dt">True</span>  <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb25-10" data-line-number="10"></a>
<a class="sourceLine" id="cb25-11" data-line-number="11"><span class="kw">type</span> family <span class="dt">Add</span> (<span class="ot">cin ::</span> <span class="dt">Bool</span>) (<span class="ot">xs ::</span> [<span class="dt">Bool</span>]) (<span class="ot">ys ::</span> [<span class="dt">Bool</span>]) <span class="ot">::</span></a>
<a class="sourceLine" id="cb25-12" data-line-number="12">     [<span class="dt">Bool</span>] <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-13" data-line-number="13">        <span class="dt">Add</span> c (x <span class="fu">:</span> xs) (y <span class="fu">:</span> ys) <span class="fu">=</span> <span class="dt">Sum</span> x y c <span class="fu">:</span> <span class="dt">Add</span> (<span class="dt">Carry</span> x y c) xs ys</a>
<a class="sourceLine" id="cb25-14" data-line-number="14">        <span class="dt">Add</span> <span class="dt">False</span> <span class="ch">&#39;[] ys = ys</span></a>
<a class="sourceLine" id="cb25-15" data-line-number="15">        <span class="dt">Add</span> <span class="dt">False</span> xs <span class="ch">&#39;[] = xs</span></a>
<a class="sourceLine" id="cb25-16" data-line-number="16">        <span class="dt">Add</span> <span class="dt">True</span>  <span class="ch">&#39;[] ys = CarryOne ys</span></a>
<a class="sourceLine" id="cb25-17" data-line-number="17">        <span class="dt">Add</span> <span class="dt">True</span>  xs <span class="ch">&#39;[] = CarryOne xs</span></a></code></pre></div>
<p>We would have been warned about nested type-family application.</p>
<p>Now we can base the merge function very closely on these type families. First, though, weâ€™ll have to implement the heap.</p>
<h3 id="almost-verified-data-structures">Almost-Verified Data Structures</h3>
<p>There are different potential properties you can verify in a data structure. In the sort-traversable post, the property of interest was that the number of elements in the structure would stay the same after adding and removing some number <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> of elements. For this post, weâ€™ll also verify structural invariants. I wonâ€™t, however, verify the <a href="https://www.cs.cmu.edu/~adamchik/15-121/lectures/Binary%20Heaps/heaps.html">heap property</a>. Maybe in a later post.</p>
<p>When indexing a data structure by its size, you encode an awful lot of information into the type signature: the type becomes very <em>specific</em> to the structure in question. It is possible, though, to encode a fair few structural invariants <em>without</em> getting so specific. Hereâ€™s a signature for â€œperfect leaf treeâ€:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="kw">data</span> <span class="dt">BalTree</span> a <span class="fu">=</span> <span class="dt">Leaf</span> a <span class="fu">|</span> <span class="dt">Node</span> (<span class="dt">BalTree</span> (a,a))</a></code></pre></div>
<p>With that signature, itâ€™s <em>impossible</em> to create a tree with more elements in its left branch than its right; the size of the tree, however, remains unspecified. You can use a similar trick to implement <a href="https://github.com/oisdk/Square">matrices which must be square</a> <span class="citation" data-cites="okasaki_fast_1999">(from Okasaki <a href="#ref-okasaki_fast_1999">1999</a>)</span>: the usual trick (<code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Matrix</span> n a <span class="fu">=</span> <span class="dt">List</span> n (<span class="dt">List</span> n a)</code>) is too specific, providing size information at compile-time. If youâ€™re interested in this approach, there are several more examples in <span class="citation" data-cites="hinze_manufacturing_2001">Hinze (<a href="#ref-hinze_manufacturing_2001">2001</a>)</span>.</p>
<p>It is possible to go from the size-indexed version back to the non-indexed version, with an existential (<code class="sourceCode haskell"><span class="dt">RankNTypes</span></code> for this example):</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="kw">data</span> <span class="dt">ErasedSize</span> f a <span class="fu">=</span> forall (<span class="ot">n ::</span> <span class="dt">Peano</span>)<span class="fu">.</span> <span class="dt">ErasedSize</span></a>
<a class="sourceLine" id="cb27-2" data-line-number="2">    {<span class="ot"> runErasedSize ::</span> f n a</a>
<a class="sourceLine" id="cb27-3" data-line-number="3">    }</a></code></pre></div>
<p>This will let you prove invariants in your implementation using an index, while keeping the user-facing type signature general and non-indexed.</p>
<h3 id="a-fully-structurally-verified-binomial-heap">A Fully-Structurally-Verified Binomial Heap</h3>
<p><span class="citation" data-cites="wasserman_playing_2010">Wasserman (<a href="#ref-wasserman_playing_2010">2010</a>)</span>, was able to encode all of the structural invariants of the binomial heap <em>without</em> indexing by its size (well, all invariants except truncation, which turned out to be important a little later). Iâ€™ll be using a similar approach, except Iâ€™ll leverage some of the newer bells and whistles in GHC. Where Wassermanâ€™s version used types like this for the numbering:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Zero</span> a <span class="fu">=</span> <span class="dt">Zero</span></a>
<a class="sourceLine" id="cb28-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Succ</span> rk a <span class="fu">=</span> <span class="dt">BinomTree</span> rk a <span class="fu">:&lt;</span> rk a</a>
<a class="sourceLine" id="cb28-3" data-line-number="3"><span class="kw">data</span> <span class="dt">BinomTree</span> rk a <span class="fu">=</span> <span class="dt">BinomTree</span> a (rk a)</a></code></pre></div>
<p>We can reuse the type-level Peano numbers with a GADT:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:-</span></a>
<a class="sourceLine" id="cb29-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Binomial</span> xs rk a <span class="kw">where</span></a>
<a class="sourceLine" id="cb29-3" data-line-number="3">       <span class="dt">Nil</span><span class="ot"> ::</span> <span class="dt">Binomial</span> <span class="ch">&#39;[] n a</span></a>
<a class="sourceLine" id="cb29-4" data-line-number="4">       <span class="dt">Skip</span><span class="ot"> ::</span> <span class="dt">Binomial</span> xs (<span class="dt">S</span> rk) a <span class="ot">-&gt;</span> <span class="dt">Binomial</span> (<span class="dt">False</span> <span class="fu">:</span> xs) rk a</a>
<a class="sourceLine" id="cb29-5" data-line-number="5"><span class="ot">       (:-) ::</span> <span class="dt">Tree</span> rk a </a>
<a class="sourceLine" id="cb29-6" data-line-number="6">            <span class="ot">-&gt;</span> <span class="dt">Binomial</span> xs (<span class="dt">S</span> rk) a </a>
<a class="sourceLine" id="cb29-7" data-line-number="7">            <span class="ot">-&gt;</span> <span class="dt">Binomial</span> (<span class="dt">True</span> <span class="fu">:</span> xs) rk a</a>
<a class="sourceLine" id="cb29-8" data-line-number="8"></a>
<a class="sourceLine" id="cb29-9" data-line-number="9"><span class="kw">data</span> <span class="dt">Tree</span> rk a <span class="fu">=</span> <span class="dt">Root</span> a (<span class="dt">Node</span> rk a)</a>
<a class="sourceLine" id="cb29-10" data-line-number="10"></a>
<a class="sourceLine" id="cb29-11" data-line-number="11"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:&lt;</span></a>
<a class="sourceLine" id="cb29-12" data-line-number="12"><span class="kw">data</span> <span class="dt">Node</span> n a <span class="kw">where</span></a>
<a class="sourceLine" id="cb29-13" data-line-number="13">       <span class="dt">NilN</span><span class="ot"> ::</span> <span class="dt">Node</span> <span class="dt">Z</span> a</a>
<a class="sourceLine" id="cb29-14" data-line-number="14"><span class="ot">       (:&lt;) ::</span> <span class="dt">Tree</span> n a <span class="ot">-&gt;</span> <span class="dt">Node</span> n a <span class="ot">-&gt;</span> <span class="dt">Node</span> (<span class="dt">S</span> n) a</a></code></pre></div>
<p>The definition of <code class="sourceCode haskell"><span class="dt">Tree</span></code> here ensures that any tree of rank <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> has <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mi>n</mi></msup><annotation encoding="application/x-tex">2^n</annotation></semantics></math> elements. The binomial heap, then, is a list of trees, in ascending order of size, with a <code class="sourceCode haskell"><span class="dt">True</span></code> at every point in its type-level list where a tree is present, and a <code class="sourceCode haskell"><span class="dt">False</span></code> wherever one is absent. In other words, the type-level list is a binary encoding of the number of elements it contains.</p>
<p>And here are the merge functions:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="ot">mergeTree ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Tree</span> rk a <span class="ot">-&gt;</span> <span class="dt">Tree</span> rk a <span class="ot">-&gt;</span> <span class="dt">Tree</span> (<span class="dt">S</span> rk) a</a>
<a class="sourceLine" id="cb30-2" data-line-number="2">mergeTree xr<span class="fu">@</span>(<span class="dt">Root</span> x xs) yr<span class="fu">@</span>(<span class="dt">Root</span> y ys)</a>
<a class="sourceLine" id="cb30-3" data-line-number="3">  <span class="fu">|</span> x <span class="fu">&lt;=</span> y    <span class="fu">=</span> <span class="dt">Root</span> x (yr <span class="fu">:&lt;</span> xs)</a>
<a class="sourceLine" id="cb30-4" data-line-number="4">  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Root</span> y (xr <span class="fu">:&lt;</span> ys)</a>
<a class="sourceLine" id="cb30-5" data-line-number="5"></a>
<a class="sourceLine" id="cb30-6" data-line-number="6">merge </a>
<a class="sourceLine" id="cb30-7" data-line-number="7"><span class="ot">    ::</span> <span class="dt">Ord</span> a </a>
<a class="sourceLine" id="cb30-8" data-line-number="8">    <span class="ot">=&gt;</span> <span class="dt">Binomial</span> xs z a </a>
<a class="sourceLine" id="cb30-9" data-line-number="9">    <span class="ot">-&gt;</span> <span class="dt">Binomial</span> ys z a </a>
<a class="sourceLine" id="cb30-10" data-line-number="10">    <span class="ot">-&gt;</span> <span class="dt">Binomial</span> (<span class="dt">Add</span> <span class="dt">False</span> xs ys) z a</a>
<a class="sourceLine" id="cb30-11" data-line-number="11">merge <span class="dt">Nil</span> ys              <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb30-12" data-line-number="12">merge xs <span class="dt">Nil</span>              <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb30-13" data-line-number="13">merge (<span class="dt">Skip</span> xs) (<span class="dt">Skip</span> ys) <span class="fu">=</span> <span class="dt">Skip</span> (merge xs ys)</a>
<a class="sourceLine" id="cb30-14" data-line-number="14">merge (<span class="dt">Skip</span> xs) (y <span class="fu">:-</span> ys) <span class="fu">=</span> y <span class="fu">:-</span> merge xs ys</a>
<a class="sourceLine" id="cb30-15" data-line-number="15">merge (x <span class="fu">:-</span> xs) (<span class="dt">Skip</span> ys) <span class="fu">=</span> x <span class="fu">:-</span> merge xs ys</a>
<a class="sourceLine" id="cb30-16" data-line-number="16">merge (x <span class="fu">:-</span> xs) (y <span class="fu">:-</span> ys) <span class="fu">=</span> <span class="dt">Skip</span> (mergeCarry (mergeTree x y) xs ys)</a>
<a class="sourceLine" id="cb30-17" data-line-number="17"></a>
<a class="sourceLine" id="cb30-18" data-line-number="18">mergeCarry</a>
<a class="sourceLine" id="cb30-19" data-line-number="19"><span class="ot">    ::</span> <span class="dt">Ord</span> a</a>
<a class="sourceLine" id="cb30-20" data-line-number="20">    <span class="ot">=&gt;</span> <span class="dt">Tree</span> rk a </a>
<a class="sourceLine" id="cb30-21" data-line-number="21">    <span class="ot">-&gt;</span> <span class="dt">Binomial</span> xs rk a </a>
<a class="sourceLine" id="cb30-22" data-line-number="22">    <span class="ot">-&gt;</span> <span class="dt">Binomial</span> ys rk a </a>
<a class="sourceLine" id="cb30-23" data-line-number="23">    <span class="ot">-&gt;</span> <span class="dt">Binomial</span> (<span class="dt">Add</span> <span class="dt">True</span> xs ys) rk a</a>
<a class="sourceLine" id="cb30-24" data-line-number="24">mergeCarry t <span class="dt">Nil</span> ys              <span class="fu">=</span> carryOne t ys</a>
<a class="sourceLine" id="cb30-25" data-line-number="25">mergeCarry t xs <span class="dt">Nil</span>              <span class="fu">=</span> carryOne t xs</a>
<a class="sourceLine" id="cb30-26" data-line-number="26">mergeCarry t (<span class="dt">Skip</span> xs) (<span class="dt">Skip</span> ys) <span class="fu">=</span> t <span class="fu">:-</span> merge xs ys</a>
<a class="sourceLine" id="cb30-27" data-line-number="27">mergeCarry t (<span class="dt">Skip</span> xs) (y <span class="fu">:-</span> ys) <span class="fu">=</span> <span class="dt">Skip</span> (mergeCarry (mergeTree t y) xs ys)</a>
<a class="sourceLine" id="cb30-28" data-line-number="28">mergeCarry t (x <span class="fu">:-</span> xs) (<span class="dt">Skip</span> ys) <span class="fu">=</span> <span class="dt">Skip</span> (mergeCarry (mergeTree t x) xs ys)</a>
<a class="sourceLine" id="cb30-29" data-line-number="29">mergeCarry t (x <span class="fu">:-</span> xs) (y <span class="fu">:-</span> ys) <span class="fu">=</span> t <span class="fu">:-</span> mergeCarry (mergeTree x y) xs ys</a>
<a class="sourceLine" id="cb30-30" data-line-number="30"></a>
<a class="sourceLine" id="cb30-31" data-line-number="31">carryOne </a>
<a class="sourceLine" id="cb30-32" data-line-number="32"><span class="ot">    ::</span> <span class="dt">Ord</span> a </a>
<a class="sourceLine" id="cb30-33" data-line-number="33">    <span class="ot">=&gt;</span> <span class="dt">Tree</span> rk a <span class="ot">-&gt;</span> <span class="dt">Binomial</span> xs rk a <span class="ot">-&gt;</span> <span class="dt">Binomial</span> (<span class="dt">CarryOne</span> xs) rk a</a>
<a class="sourceLine" id="cb30-34" data-line-number="34">carryOne t <span class="dt">Nil</span>       <span class="fu">=</span> t <span class="fu">:-</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb30-35" data-line-number="35">carryOne t (<span class="dt">Skip</span> xs) <span class="fu">=</span> t <span class="fu">:-</span> xs</a>
<a class="sourceLine" id="cb30-36" data-line-number="36">carryOne t (x <span class="fu">:-</span> xs) <span class="fu">=</span> <span class="dt">Skip</span> (carryOne (mergeTree t x) xs)</a></code></pre></div>
<p>Youâ€™ll notice that no proofs are needed: thatâ€™s because the merge function itself is the same as the type family, like the way <code class="sourceCode haskell"><span class="fu">++</span></code> for lists was the same as the <code class="sourceCode haskell"><span class="dt">Plus</span></code> type family.</p>
<p>Of course, this structure is only verified insofar as you believe the type families. It does provide a degree of double-entry, though: any mistake in the type family will have to be mirrored in the merge function to type-check. On top of that, we can write some proofs of properties we might expect:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" data-line-number="1">addCommutes</a>
<a class="sourceLine" id="cb31-2" data-line-number="2"><span class="ot">  ::</span> <span class="dt">The</span> [<span class="dt">Bool</span>] xs</a>
<a class="sourceLine" id="cb31-3" data-line-number="3">  <span class="ot">-&gt;</span> <span class="dt">The</span> [<span class="dt">Bool</span>] ys</a>
<a class="sourceLine" id="cb31-4" data-line-number="4">  <span class="ot">-&gt;</span> <span class="dt">Add</span> <span class="dt">False</span> xs ys <span class="fu">:~:</span> <span class="dt">Add</span> <span class="dt">False</span> ys xs</a>
<a class="sourceLine" id="cb31-5" data-line-number="5">addCommutes <span class="dt">Nily</span> _ <span class="fu">=</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb31-6" data-line-number="6">addCommutes _ <span class="dt">Nily</span> <span class="fu">=</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb31-7" data-line-number="7">addCommutes (<span class="dt">Cony</span> <span class="dt">Falsy</span> xs) (<span class="dt">Cony</span> <span class="dt">Falsy</span> ys) <span class="fu">=</span></a>
<a class="sourceLine" id="cb31-8" data-line-number="8">    gcastWith (addCommutes xs ys) <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb31-9" data-line-number="9">addCommutes (<span class="dt">Cony</span> <span class="dt">Truey</span> xs) (<span class="dt">Cony</span> <span class="dt">Falsy</span> ys) <span class="fu">=</span></a>
<a class="sourceLine" id="cb31-10" data-line-number="10">    gcastWith (addCommutes xs ys) <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb31-11" data-line-number="11">addCommutes (<span class="dt">Cony</span> <span class="dt">Falsy</span> xs) (<span class="dt">Cony</span> <span class="dt">Truey</span> ys) <span class="fu">=</span></a>
<a class="sourceLine" id="cb31-12" data-line-number="12">    gcastWith (addCommutes xs ys) <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb31-13" data-line-number="13">addCommutes (<span class="dt">Cony</span> <span class="dt">Truey</span> xs) (<span class="dt">Cony</span> <span class="dt">Truey</span> ys) <span class="fu">=</span></a>
<a class="sourceLine" id="cb31-14" data-line-number="14">    gcastWith (addCommutesCarry xs ys) <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb31-15" data-line-number="15"></a>
<a class="sourceLine" id="cb31-16" data-line-number="16">addCommutesCarry</a>
<a class="sourceLine" id="cb31-17" data-line-number="17"><span class="ot">  ::</span> <span class="dt">The</span> [<span class="dt">Bool</span>] xs</a>
<a class="sourceLine" id="cb31-18" data-line-number="18">  <span class="ot">-&gt;</span> <span class="dt">The</span> [<span class="dt">Bool</span>] ys</a>
<a class="sourceLine" id="cb31-19" data-line-number="19">  <span class="ot">-&gt;</span> <span class="dt">Add</span> <span class="dt">True</span> xs ys <span class="fu">:~:</span> <span class="dt">Add</span> <span class="dt">True</span> ys xs</a>
<a class="sourceLine" id="cb31-20" data-line-number="20">addCommutesCarry <span class="dt">Nily</span> _ <span class="fu">=</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb31-21" data-line-number="21">addCommutesCarry _ <span class="dt">Nily</span> <span class="fu">=</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb31-22" data-line-number="22">addCommutesCarry (<span class="dt">Cony</span> <span class="dt">Falsy</span> xs) (<span class="dt">Cony</span> <span class="dt">Falsy</span> ys) <span class="fu">=</span></a>
<a class="sourceLine" id="cb31-23" data-line-number="23">    gcastWith (addCommutes xs ys) <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb31-24" data-line-number="24">addCommutesCarry (<span class="dt">Cony</span> <span class="dt">Truey</span> xs) (<span class="dt">Cony</span> <span class="dt">Falsy</span> ys) <span class="fu">=</span></a>
<a class="sourceLine" id="cb31-25" data-line-number="25">    gcastWith (addCommutesCarry xs ys) <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb31-26" data-line-number="26">addCommutesCarry (<span class="dt">Cony</span> <span class="dt">Falsy</span> xs) (<span class="dt">Cony</span> <span class="dt">Truey</span> ys) <span class="fu">=</span></a>
<a class="sourceLine" id="cb31-27" data-line-number="27">    gcastWith (addCommutesCarry xs ys) <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb31-28" data-line-number="28">addCommutesCarry (<span class="dt">Cony</span> <span class="dt">Truey</span> xs) (<span class="dt">Cony</span> <span class="dt">Truey</span> ys) <span class="fu">=</span></a>
<a class="sourceLine" id="cb31-29" data-line-number="29">    gcastWith (addCommutesCarry xs ys) <span class="dt">Refl</span></a></code></pre></div>
<p>Unfortunately, though, this method <em>does</em> require proofs (ugly proofs) for the delete-min operation. One of the issues is truncation: since the binary digits are stored least-significant-bit first, the same number can be represented with any number of trailing zeroes. This kept causing problems for me when it came to subtraction, and adding the requirement of no trailing zeroes (truncation) to the constructors for the heap was a pain, requiring extra proofs on merge to show that it preserves truncation.</p>
<h3 id="doubly-dependent-types">Doubly-Dependent Types</h3>
<p>Since some of these properties are much easier to verify on the type-level Peano numbers, one approach might be to convert back and forth between Peano numbers and binary, and use the proofs on Peano numbers instead.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">BintoPeano</span> (<span class="ot">xs ::</span> [<span class="dt">Bool</span>])<span class="ot"> ::</span> <span class="dt">Peano</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-2" data-line-number="2">        <span class="dt">BintoPeano</span> <span class="ch">&#39;[] = Z</span></a>
<a class="sourceLine" id="cb32-3" data-line-number="3">        <span class="dt">BintoPeano</span> (<span class="dt">False</span> <span class="fu">:</span> xs) <span class="fu">=</span> <span class="dt">BintoPeano</span> xs <span class="fu">+</span> <span class="dt">BintoPeano</span> xs</a>
<a class="sourceLine" id="cb32-4" data-line-number="4">        <span class="dt">BintoPeano</span> (<span class="dt">True</span> <span class="fu">:</span> xs) <span class="fu">=</span> <span class="dt">S</span> (<span class="dt">BintoPeano</span> xs <span class="fu">+</span> <span class="dt">BintoPeano</span> xs)</a></code></pre></div>
<p>First problem: this requires <code class="sourceCode haskell"><span class="dt">UndecidableInstances</span></code>. Iâ€™d <em>really</em> rather not have that turned on, to be honest. In Idris (and Agda), you can <em>prove</em> decidability using <a href="https://www.idris-lang.org/docs/0.12/contrib_doc/docs/Control.WellFounded.html">a number of different methods</a>, but this isnâ€™t available in Haskell yet.</p>
<p>Regardless, we can push on.</p>
<p>To go in the other direction, weâ€™ll need to calculate the parity of natural numbers. Taken from <a href="http://docs.idris-lang.org/en/latest/tutorial/theorems.html#theorems-in-practice">the Idris tutorial</a>:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Parity</span> (<span class="ot">n ::</span> <span class="dt">Peano</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb33-2" data-line-number="2">    <span class="dt">Even</span><span class="ot"> ::</span> <span class="dt">The</span> <span class="dt">Peano</span> n <span class="ot">-&gt;</span> <span class="dt">Parity</span> (n <span class="fu">+</span> n)</a>
<a class="sourceLine" id="cb33-3" data-line-number="3">    <span class="dt">Odd</span><span class="ot">  ::</span> <span class="dt">The</span> <span class="dt">Peano</span> n <span class="ot">-&gt;</span> <span class="dt">Parity</span> (<span class="dt">S</span> (n <span class="fu">+</span> n))</a>
<a class="sourceLine" id="cb33-4" data-line-number="4"></a>
<a class="sourceLine" id="cb33-5" data-line-number="5"><span class="ot">parity ::</span> <span class="dt">The</span> <span class="dt">Peano</span> n <span class="ot">-&gt;</span> <span class="dt">Parity</span> n</a>
<a class="sourceLine" id="cb33-6" data-line-number="6">parity <span class="dt">Zy</span> <span class="fu">=</span> <span class="dt">Even</span> <span class="dt">Zy</span></a>
<a class="sourceLine" id="cb33-7" data-line-number="7">parity (<span class="dt">Sy</span> <span class="dt">Zy</span>) <span class="fu">=</span> <span class="dt">Odd</span> <span class="dt">Zy</span></a>
<a class="sourceLine" id="cb33-8" data-line-number="8">parity (<span class="dt">Sy</span> (<span class="dt">Sy</span> n)) <span class="fu">=</span> <span class="kw">case</span> parity n <span class="kw">of</span></a>
<a class="sourceLine" id="cb33-9" data-line-number="9">  <span class="dt">Even</span> m <span class="ot">-&gt;</span> gcastWith (plusSuccDistrib m m) (<span class="dt">Even</span> (<span class="dt">Sy</span> m))</a>
<a class="sourceLine" id="cb33-10" data-line-number="10">  <span class="dt">Odd</span>  m <span class="ot">-&gt;</span> gcastWith (plusSuccDistrib m m) (<span class="dt">Odd</span> (<span class="dt">Sy</span> m))</a>
<a class="sourceLine" id="cb33-11" data-line-number="11"></a>
<a class="sourceLine" id="cb33-12" data-line-number="12"><span class="ot">plusSuccDistrib ::</span> <span class="dt">The</span> <span class="dt">Peano</span> n <span class="ot">-&gt;</span> proxy m <span class="ot">-&gt;</span> n <span class="fu">+</span> <span class="dt">S</span> m <span class="fu">:~:</span> <span class="dt">S</span> (n <span class="fu">+</span> m)</a>
<a class="sourceLine" id="cb33-13" data-line-number="13">plusSuccDistrib <span class="dt">Zy</span> _ <span class="fu">=</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb33-14" data-line-number="14">plusSuccDistrib (<span class="dt">Sy</span> n) p <span class="fu">=</span> gcastWith (plusSuccDistrib n p) <span class="dt">Refl</span></a></code></pre></div>
<p>We need this function on the type-level, though, not the value-level: here, again, we run into trouble. What does <code class="sourceCode haskell">gcastWith</code> look like on the type-level? As far as I can tell, it doesnâ€™t exist (yet. Although I havenâ€™t looked deeply into the singletons library yet).</p>
<p>This idea of doing dependently-typed stuff on the type-level <em>started</em> to be possible with <code class="sourceCode haskell"><span class="dt">TypeInType</span></code>. For instance, we could have defined our binary type as:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Binary</span><span class="ot"> ::</span> <span class="dt">Peano</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb34-2" data-line-number="2">    <span class="dt">O</span><span class="ot"> ::</span> <span class="dt">Binary</span> n <span class="ot">-&gt;</span> <span class="dt">Binary</span> (n <span class="fu">+</span> n)</a>
<a class="sourceLine" id="cb34-3" data-line-number="3">    <span class="dt">I</span><span class="ot"> ::</span> <span class="dt">Binary</span> n <span class="ot">-&gt;</span> <span class="dt">Binary</span> (<span class="dt">S</span> (n <span class="fu">+</span> n))</a>
<a class="sourceLine" id="cb34-4" data-line-number="4">    <span class="dt">E</span><span class="ot"> ::</span> <span class="dt">Binary</span> <span class="dt">Z</span></a></code></pre></div>
<p>And then the binomial heap as:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb35-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Binomial</span> (<span class="ot">xs ::</span> <span class="dt">Binary</span> n) (<span class="ot">rk ::</span> <span class="dt">Peano</span>) (<span class="ot">a ::</span> <span class="dt">Type</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb35-2" data-line-number="2">       <span class="dt">Nil</span><span class="ot"> ::</span> <span class="dt">Binomial</span> <span class="dt">E</span> n a</a>
<a class="sourceLine" id="cb35-3" data-line-number="3">       <span class="dt">Skip</span><span class="ot"> ::</span> <span class="dt">Binomial</span> xs (<span class="dt">S</span> rk) a <span class="ot">-&gt;</span> <span class="dt">Binomial</span> (<span class="dt">O</span> xs) rk a</a>
<a class="sourceLine" id="cb35-4" data-line-number="4"><span class="ot">       (:-) ::</span> <span class="dt">Tree</span> rk a </a>
<a class="sourceLine" id="cb35-5" data-line-number="5">            <span class="ot">-&gt;</span> <span class="dt">Binomial</span> xs (<span class="dt">S</span> rk) a </a>
<a class="sourceLine" id="cb35-6" data-line-number="6">            <span class="ot">-&gt;</span> <span class="dt">Binomial</span> (<span class="dt">I</span> xs) rk a</a></code></pre></div>
<p>What weâ€™re doing here is indexing a type <em>by an indexed type</em>. <a href="http://stackoverflow.com/a/13241158/4892417">This wasnâ€™t possible in Haskell a few years ago</a>. It still doesnâ€™t get us a nice definition of subtraction, though.</p>
<h3 id="using-a-typechecker-plugin">Using a Typechecker Plugin</h3>
<p>Itâ€™s pretty clear that this approach gets tedious almost immediately. Whatâ€™s more, if we want the proofs to be erased, we introduce potential for errors.</p>
<p>The solution? Beef up GHCâ€™s typechecker with a plugin. I first came across this approach in <a href="https://www.youtube.com/watch?v=u_OsUlwkmBQ">Kenneth Fonerâ€™s talk at Compose</a>. He used a plugin that called out to the <a href="https://github.com/Z3Prover/z3">Z3 theorem prover</a> <span class="citation" data-cites="diatchki_improving_2015">(from Diatchki <a href="#ref-diatchki_improving_2015">2015</a>)</span>; Iâ€™ll use a <a href="https://hackage.haskell.org/package/ghc-typelits-natnormalise">simpler plugin</a> which just normalizes type-literals.</p>
<p>From what Iâ€™ve used of these plugins so far, they seem to work really well. Theyâ€™re very unobtrusive, only requiring a pragma at the top of your file:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" data-line-number="1"><span class="ot">{-# OPTIONS_GHC -fplugin GHC.TypeLits.Normalise #-}</span></a></code></pre></div>
<p>The plugin is only called when GHC canâ€™t unify two types: this means you donâ€™t get odd-looking error messages in unrelated code (in fact, the error messages Iâ€™ve seen so far have been excellentâ€”a real improvement on the standard error messages for type-level arithmetic). Another benefit is that we get to use type-level literals (<code class="sourceCode haskell"><span class="dt">Nat</span></code> imported from <a href="https://hackage.haskell.org/package/base-4.9.1.0/docs/GHC-TypeLits.html">GHC.TypeLits</a>), rather then the noisy-looking type-level Peano numbers.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb37-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> n a <span class="fu">=</span> <span class="dt">Root</span> a (<span class="dt">Node</span> n a)</a>
<a class="sourceLine" id="cb37-2" data-line-number="2"></a>
<a class="sourceLine" id="cb37-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Node</span><span class="ot"> ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb37-4" data-line-number="4">        <span class="dt">NilN</span><span class="ot"> ::</span> <span class="dt">Node</span> <span class="dv">0</span> a</a>
<a class="sourceLine" id="cb37-5" data-line-number="5"><span class="ot">        (:&lt;) ::</span> <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span>(<span class="dt">Tree</span> n a)</a>
<a class="sourceLine" id="cb37-6" data-line-number="6">             <span class="ot">-&gt;</span> <span class="dt">Node</span> n a</a>
<a class="sourceLine" id="cb37-7" data-line-number="7">             <span class="ot">-&gt;</span> <span class="dt">Node</span> (<span class="dv">1</span> <span class="fu">+</span> n) a</a>
<a class="sourceLine" id="cb37-8" data-line-number="8"></a>
<a class="sourceLine" id="cb37-9" data-line-number="9"><span class="ot">mergeTree ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Tree</span> n a <span class="ot">-&gt;</span> <span class="dt">Tree</span> n a <span class="ot">-&gt;</span> <span class="dt">Tree</span> (<span class="dv">1</span> <span class="fu">+</span> n) a</a>
<a class="sourceLine" id="cb37-10" data-line-number="10">mergeTree xr<span class="fu">@</span>(<span class="dt">Root</span> x xs) yr<span class="fu">@</span>(<span class="dt">Root</span> y ys)</a>
<a class="sourceLine" id="cb37-11" data-line-number="11">  <span class="fu">|</span> x <span class="fu">&lt;=</span> y    <span class="fu">=</span> <span class="dt">Root</span> x (yr <span class="fu">:&lt;</span> xs)</a>
<a class="sourceLine" id="cb37-12" data-line-number="12">  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Root</span> y (xr <span class="fu">:&lt;</span> ys)</a>
<a class="sourceLine" id="cb37-13" data-line-number="13"></a>
<a class="sourceLine" id="cb37-14" data-line-number="14"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:-</span></a>
<a class="sourceLine" id="cb37-15" data-line-number="15"><span class="kw">data</span> <span class="dt">Binomial</span><span class="ot"> ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb37-16" data-line-number="16">        <span class="dt">Nil</span><span class="ot">  ::</span> <span class="dt">Binomial</span> n <span class="dv">0</span> a</a>
<a class="sourceLine" id="cb37-17" data-line-number="17"><span class="ot">        (:-) ::</span> <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span>(<span class="dt">Tree</span> z a)</a>
<a class="sourceLine" id="cb37-18" data-line-number="18">             <span class="ot">-&gt;</span> <span class="dt">Binomial</span> (<span class="dv">1</span> <span class="fu">+</span> z) xs a</a>
<a class="sourceLine" id="cb37-19" data-line-number="19">             <span class="ot">-&gt;</span> <span class="dt">Binomial</span> z (<span class="dv">1</span> <span class="fu">+</span> xs <span class="fu">+</span> xs) a</a>
<a class="sourceLine" id="cb37-20" data-line-number="20">        <span class="dt">Skip</span><span class="ot"> ::</span> <span class="dt">Binomial</span> (<span class="dv">1</span> <span class="fu">+</span> z) (<span class="dv">1</span> <span class="fu">+</span> xs) a</a>
<a class="sourceLine" id="cb37-21" data-line-number="21">             <span class="ot">-&gt;</span> <span class="dt">Binomial</span> z (<span class="dv">2</span> <span class="fu">+</span> xs <span class="fu">+</span> xs) a</a></code></pre></div>
<p>This definition also ensures that the binomial heap has no trailing zeroes in its binary representation: the <code class="sourceCode haskell"><span class="dt">Skip</span></code> constructor can only be applied to a heap bigger than zero.</p>
<p>Since weâ€™re going to be looking at several different heaps, weâ€™ll need a class to represent all of them:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb38-1" data-line-number="1"><span class="kw">class</span> <span class="dt">IndexedQueue</span> h a <span class="kw">where</span></a>
<a class="sourceLine" id="cb38-2" data-line-number="2"></a>
<a class="sourceLine" id="cb38-3" data-line-number="3">    <span class="ot">{-# MINIMAL insert, empty, minViewMay, minView #-}</span></a>
<a class="sourceLine" id="cb38-4" data-line-number="4"></a>
<a class="sourceLine" id="cb38-5" data-line-number="5">    empty</a>
<a class="sourceLine" id="cb38-6" data-line-number="6"><span class="ot">        ::</span> h <span class="dv">0</span> a</a>
<a class="sourceLine" id="cb38-7" data-line-number="7"></a>
<a class="sourceLine" id="cb38-8" data-line-number="8">    minView</a>
<a class="sourceLine" id="cb38-9" data-line-number="9"><span class="ot">        ::</span> h (<span class="dv">1</span> <span class="fu">+</span> n) a <span class="ot">-&gt;</span> (a, h n a)</a>
<a class="sourceLine" id="cb38-10" data-line-number="10"></a>
<a class="sourceLine" id="cb38-11" data-line-number="11">    singleton</a>
<a class="sourceLine" id="cb38-12" data-line-number="12"><span class="ot">        ::</span> a <span class="ot">-&gt;</span> h <span class="dv">1</span> a</a>
<a class="sourceLine" id="cb38-13" data-line-number="13">    singleton <span class="fu">=</span> flip insert empty</a>
<a class="sourceLine" id="cb38-14" data-line-number="14"></a>
<a class="sourceLine" id="cb38-15" data-line-number="15">    insert</a>
<a class="sourceLine" id="cb38-16" data-line-number="16"><span class="ot">        ::</span> a <span class="ot">-&gt;</span> h n a <span class="ot">-&gt;</span> h (<span class="dv">1</span> <span class="fu">+</span> n) a</a>
<a class="sourceLine" id="cb38-17" data-line-number="17"></a>
<a class="sourceLine" id="cb38-18" data-line-number="18">    minViewMay</a>
<a class="sourceLine" id="cb38-19" data-line-number="19"><span class="ot">       ::</span> h n a</a>
<a class="sourceLine" id="cb38-20" data-line-number="20">       <span class="ot">-&gt;</span> (n <span class="fu">~</span> <span class="dv">0</span> <span class="ot">=&gt;</span> b)</a>
<a class="sourceLine" id="cb38-21" data-line-number="21">       <span class="ot">-&gt;</span> (forall m<span class="fu">.</span> (<span class="dv">1</span> <span class="fu">+</span> m) <span class="fu">~</span> n <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> h m a <span class="ot">-&gt;</span> b)</a>
<a class="sourceLine" id="cb38-22" data-line-number="22">       <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb38-23" data-line-number="23"></a>
<a class="sourceLine" id="cb38-24" data-line-number="24"><span class="kw">class</span> <span class="dt">IndexedQueue</span> h a <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb38-25" data-line-number="25">      <span class="dt">MeldableIndexedQueue</span> h a <span class="kw">where</span></a>
<a class="sourceLine" id="cb38-26" data-line-number="26">    merge</a>
<a class="sourceLine" id="cb38-27" data-line-number="27"><span class="ot">        ::</span> h n a <span class="ot">-&gt;</span> h m a <span class="ot">-&gt;</span> h (n <span class="fu">+</span> m) a</a></code></pre></div>
<p>Youâ€™ll need <code class="sourceCode haskell"><span class="dt">MultiParamTypeClasses</span></code> for this one.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb39-1" data-line-number="1">mergeB</a>
<a class="sourceLine" id="cb39-2" data-line-number="2"><span class="ot">    ::</span> <span class="dt">Ord</span> a</a>
<a class="sourceLine" id="cb39-3" data-line-number="3">    <span class="ot">=&gt;</span> <span class="dt">Binomial</span> z xs a <span class="ot">-&gt;</span> <span class="dt">Binomial</span> z ys a <span class="ot">-&gt;</span> <span class="dt">Binomial</span> z (xs <span class="fu">+</span> ys) a</a>
<a class="sourceLine" id="cb39-4" data-line-number="4">mergeB <span class="dt">Nil</span> ys              <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb39-5" data-line-number="5">mergeB xs <span class="dt">Nil</span>              <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb39-6" data-line-number="6">mergeB (<span class="dt">Skip</span> xs) (<span class="dt">Skip</span> ys) <span class="fu">=</span> <span class="dt">Skip</span> (mergeB xs ys)</a>
<a class="sourceLine" id="cb39-7" data-line-number="7">mergeB (<span class="dt">Skip</span> xs) (y <span class="fu">:-</span> ys) <span class="fu">=</span> y <span class="fu">:-</span> mergeB xs ys</a>
<a class="sourceLine" id="cb39-8" data-line-number="8">mergeB (x <span class="fu">:-</span> xs) (<span class="dt">Skip</span> ys) <span class="fu">=</span> x <span class="fu">:-</span> mergeB xs ys</a>
<a class="sourceLine" id="cb39-9" data-line-number="9">mergeB (x <span class="fu">:-</span> xs) (y <span class="fu">:-</span> ys) <span class="fu">=</span> <span class="dt">Skip</span> (mergeCarry (mergeTree x y) xs ys)</a>
<a class="sourceLine" id="cb39-10" data-line-number="10"></a>
<a class="sourceLine" id="cb39-11" data-line-number="11">mergeCarry</a>
<a class="sourceLine" id="cb39-12" data-line-number="12"><span class="ot">    ::</span> <span class="dt">Ord</span> a</a>
<a class="sourceLine" id="cb39-13" data-line-number="13">    <span class="ot">=&gt;</span> <span class="dt">Tree</span> z a</a>
<a class="sourceLine" id="cb39-14" data-line-number="14">    <span class="ot">-&gt;</span> <span class="dt">Binomial</span> z xs a</a>
<a class="sourceLine" id="cb39-15" data-line-number="15">    <span class="ot">-&gt;</span> <span class="dt">Binomial</span> z ys a</a>
<a class="sourceLine" id="cb39-16" data-line-number="16">    <span class="ot">-&gt;</span> <span class="dt">Binomial</span> z (<span class="dv">1</span> <span class="fu">+</span> xs <span class="fu">+</span> ys) a</a>
<a class="sourceLine" id="cb39-17" data-line-number="17">mergeCarry <span class="fu">!</span>t <span class="dt">Nil</span> ys              <span class="fu">=</span> carryOne t ys</a>
<a class="sourceLine" id="cb39-18" data-line-number="18">mergeCarry <span class="fu">!</span>t xs <span class="dt">Nil</span>              <span class="fu">=</span> carryOne t xs</a>
<a class="sourceLine" id="cb39-19" data-line-number="19">mergeCarry <span class="fu">!</span>t (<span class="dt">Skip</span> xs) (<span class="dt">Skip</span> ys) <span class="fu">=</span> t <span class="fu">:-</span> mergeB xs ys</a>
<a class="sourceLine" id="cb39-20" data-line-number="20">mergeCarry <span class="fu">!</span>t (<span class="dt">Skip</span> xs) (y <span class="fu">:-</span> ys) <span class="fu">=</span> <span class="dt">Skip</span> (mergeCarry (mergeTree t y) xs ys)</a>
<a class="sourceLine" id="cb39-21" data-line-number="21">mergeCarry <span class="fu">!</span>t (x <span class="fu">:-</span> xs) (<span class="dt">Skip</span> ys) <span class="fu">=</span> <span class="dt">Skip</span> (mergeCarry (mergeTree t x) xs ys)</a>
<a class="sourceLine" id="cb39-22" data-line-number="22">mergeCarry <span class="fu">!</span>t (x <span class="fu">:-</span> xs) (y <span class="fu">:-</span> ys) <span class="fu">=</span> t <span class="fu">:-</span> mergeCarry (mergeTree x y) xs ys</a>
<a class="sourceLine" id="cb39-23" data-line-number="23"></a>
<a class="sourceLine" id="cb39-24" data-line-number="24"><span class="ot">carryOne ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Tree</span> z a <span class="ot">-&gt;</span> <span class="dt">Binomial</span> z xs a <span class="ot">-&gt;</span> <span class="dt">Binomial</span> z (<span class="dv">1</span> <span class="fu">+</span> xs) a</a>
<a class="sourceLine" id="cb39-25" data-line-number="25">carryOne <span class="fu">!</span>t <span class="dt">Nil</span>       <span class="fu">=</span> t <span class="fu">:-</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb39-26" data-line-number="26">carryOne <span class="fu">!</span>t (<span class="dt">Skip</span> xs) <span class="fu">=</span> t <span class="fu">:-</span> xs</a>
<a class="sourceLine" id="cb39-27" data-line-number="27">carryOne <span class="fu">!</span>t (x <span class="fu">:-</span> xs) <span class="fu">=</span> <span class="dt">Skip</span> (carryOne (mergeTree t x) xs)</a>
<a class="sourceLine" id="cb39-28" data-line-number="28"></a>
<a class="sourceLine" id="cb39-29" data-line-number="29"><span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">MeldableIndexedQueue</span> (<span class="dt">Binomial</span> <span class="dv">0</span>) a <span class="kw">where</span></a>
<a class="sourceLine" id="cb39-30" data-line-number="30">    merge <span class="fu">=</span> mergeB</a>
<a class="sourceLine" id="cb39-31" data-line-number="31">    <span class="ot">{-# INLINE merge #-}</span></a>
<a class="sourceLine" id="cb39-32" data-line-number="32"></a>
<a class="sourceLine" id="cb39-33" data-line-number="33"><span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">IndexedQueue</span> (<span class="dt">Binomial</span> <span class="dv">0</span>) a <span class="kw">where</span></a>
<a class="sourceLine" id="cb39-34" data-line-number="34">    empty <span class="fu">=</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb39-35" data-line-number="35">    singleton x <span class="fu">=</span> <span class="dt">Root</span> x <span class="dt">NilN</span> <span class="fu">:-</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb39-36" data-line-number="36">    insert <span class="fu">=</span> merge <span class="fu">.</span> singleton</a></code></pre></div>
<p>(<code class="sourceCode haskell"><span class="dt">BangPatterns</span></code> for this example)</p>
<p>On top of that, itâ€™s very easy to define delete-min:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb40-1" data-line-number="1">    minView xs <span class="fu">=</span> <span class="kw">case</span> minViewZip xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb40-2" data-line-number="2">      <span class="dt">Zipper</span> x _ ys <span class="ot">-&gt;</span> (x, ys)</a>
<a class="sourceLine" id="cb40-3" data-line-number="3">    minViewMay q b f <span class="fu">=</span> <span class="kw">case</span> q <span class="kw">of</span></a>
<a class="sourceLine" id="cb40-4" data-line-number="4">      <span class="dt">Nil</span> <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb40-5" data-line-number="5">      _ <span class="fu">:-</span> _ <span class="ot">-&gt;</span> uncurry f (minView q)</a>
<a class="sourceLine" id="cb40-6" data-line-number="6">      <span class="dt">Skip</span> _ <span class="ot">-&gt;</span> uncurry f (minView q)</a>
<a class="sourceLine" id="cb40-7" data-line-number="7"></a>
<a class="sourceLine" id="cb40-8" data-line-number="8"><span class="kw">data</span> <span class="dt">Zipper</span> a n rk <span class="fu">=</span> <span class="dt">Zipper</span> <span class="fu">!</span>a (<span class="dt">Node</span> rk a) (<span class="dt">Binomial</span> rk n a)</a>
<a class="sourceLine" id="cb40-9" data-line-number="9"></a>
<a class="sourceLine" id="cb40-10" data-line-number="10"><span class="ot">skip ::</span> <span class="dt">Binomial</span> (<span class="dv">1</span> <span class="fu">+</span> z) xs a <span class="ot">-&gt;</span> <span class="dt">Binomial</span> z (xs <span class="fu">+</span> xs) a</a>
<a class="sourceLine" id="cb40-11" data-line-number="11">skip x <span class="fu">=</span> <span class="kw">case</span> x <span class="kw">of</span></a>
<a class="sourceLine" id="cb40-12" data-line-number="12">  <span class="dt">Nil</span>    <span class="ot">-&gt;</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb40-13" data-line-number="13">  <span class="dt">Skip</span> _ <span class="ot">-&gt;</span> <span class="dt">Skip</span> x</a>
<a class="sourceLine" id="cb40-14" data-line-number="14">  _ <span class="fu">:-</span> _ <span class="ot">-&gt;</span> <span class="dt">Skip</span> x</a>
<a class="sourceLine" id="cb40-15" data-line-number="15"></a>
<a class="sourceLine" id="cb40-16" data-line-number="16"><span class="kw">data</span> <span class="dt">MinViewZipper</span> a n rk <span class="kw">where</span></a>
<a class="sourceLine" id="cb40-17" data-line-number="17">    <span class="dt">Infty</span><span class="ot"> ::</span> <span class="dt">MinViewZipper</span> a <span class="dv">0</span> rk</a>
<a class="sourceLine" id="cb40-18" data-line-number="18">    <span class="dt">Min</span><span class="ot"> ::</span> <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span>(<span class="dt">Zipper</span> a n rk) <span class="ot">-&gt;</span> <span class="dt">MinViewZipper</span> a (n<span class="fu">+</span><span class="dv">1</span>) rk</a>
<a class="sourceLine" id="cb40-19" data-line-number="19"></a>
<a class="sourceLine" id="cb40-20" data-line-number="20"><span class="ot">slideLeft ::</span> <span class="dt">Zipper</span> a n (<span class="dv">1</span> <span class="fu">+</span> rk) <span class="ot">-&gt;</span> <span class="dt">Zipper</span> a (<span class="dv">1</span> <span class="fu">+</span> n <span class="fu">+</span> n) rk</a>
<a class="sourceLine" id="cb40-21" data-line-number="21">slideLeft (<span class="dt">Zipper</span> m (t <span class="fu">:&lt;</span> ts) hs)</a>
<a class="sourceLine" id="cb40-22" data-line-number="22">  <span class="fu">=</span> <span class="dt">Zipper</span> m ts (t <span class="fu">:-</span> hs)</a>
<a class="sourceLine" id="cb40-23" data-line-number="23"></a>
<a class="sourceLine" id="cb40-24" data-line-number="24">pushLeft </a>
<a class="sourceLine" id="cb40-25" data-line-number="25"><span class="ot">  ::</span> <span class="dt">Ord</span> a </a>
<a class="sourceLine" id="cb40-26" data-line-number="26">  <span class="ot">=&gt;</span> <span class="dt">Tree</span> rk a </a>
<a class="sourceLine" id="cb40-27" data-line-number="27">  <span class="ot">-&gt;</span> <span class="dt">Zipper</span> a n (<span class="dv">1</span> <span class="fu">+</span> rk) </a>
<a class="sourceLine" id="cb40-28" data-line-number="28">  <span class="ot">-&gt;</span> <span class="dt">Zipper</span> a (<span class="dv">2</span> <span class="fu">+</span> n <span class="fu">+</span> n) rk</a>
<a class="sourceLine" id="cb40-29" data-line-number="29">pushLeft c (<span class="dt">Zipper</span> m (t <span class="fu">:&lt;</span> ts) hs)</a>
<a class="sourceLine" id="cb40-30" data-line-number="30">  <span class="fu">=</span> <span class="dt">Zipper</span> m ts (<span class="dt">Skip</span> (carryOne (mergeTree c t) hs))</a>
<a class="sourceLine" id="cb40-31" data-line-number="31"></a>
<a class="sourceLine" id="cb40-32" data-line-number="32"><span class="ot">minViewZip ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Binomial</span> rk (<span class="dv">1</span> <span class="fu">+</span> n) a <span class="ot">-&gt;</span> <span class="dt">Zipper</span> a n rk</a>
<a class="sourceLine" id="cb40-33" data-line-number="33">minViewZip (<span class="dt">Skip</span> xs) <span class="fu">=</span> slideLeft (minViewZip xs)</a>
<a class="sourceLine" id="cb40-34" data-line-number="34">minViewZip (t<span class="fu">@</span>(<span class="dt">Root</span> x ts) <span class="fu">:-</span> f) <span class="fu">=</span> <span class="kw">case</span> minViewZipMay f <span class="kw">of</span></a>
<a class="sourceLine" id="cb40-35" data-line-number="35">  <span class="dt">Min</span> ex<span class="fu">@</span>(<span class="dt">Zipper</span> minKey _ _) <span class="fu">|</span> minKey <span class="fu">&lt;</span> x <span class="ot">-&gt;</span> pushLeft t ex</a>
<a class="sourceLine" id="cb40-36" data-line-number="36">  _                          <span class="ot">-&gt;</span> <span class="dt">Zipper</span> x ts (skip f)</a>
<a class="sourceLine" id="cb40-37" data-line-number="37"></a>
<a class="sourceLine" id="cb40-38" data-line-number="38"><span class="ot">minViewZipMay ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Binomial</span> rk n a <span class="ot">-&gt;</span> <span class="dt">MinViewZipper</span> a n rk</a>
<a class="sourceLine" id="cb40-39" data-line-number="39">minViewZipMay (<span class="dt">Skip</span> xs) <span class="fu">=</span> <span class="dt">Min</span> (slideLeft (minViewZip xs))</a>
<a class="sourceLine" id="cb40-40" data-line-number="40">minViewZipMay <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Infty</span></a>
<a class="sourceLine" id="cb40-41" data-line-number="41">minViewZipMay (t<span class="fu">@</span>(<span class="dt">Root</span> x ts) <span class="fu">:-</span> f) <span class="fu">=</span> <span class="dt">Min</span> <span class="fu">$</span> <span class="kw">case</span> minViewZipMay f <span class="kw">of</span></a>
<a class="sourceLine" id="cb40-42" data-line-number="42">  <span class="dt">Min</span> ex<span class="fu">@</span>(<span class="dt">Zipper</span> minKey _ _) <span class="fu">|</span> minKey <span class="fu">&lt;</span> x <span class="ot">-&gt;</span> pushLeft t ex</a>
<a class="sourceLine" id="cb40-43" data-line-number="43">  _                          <span class="ot">-&gt;</span> <span class="dt">Zipper</span> x ts (skip f)</a></code></pre></div>
<p>Similarly, compare the version of the pairing heap with the plugin:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb41-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Heap</span> n a <span class="kw">where</span></a>
<a class="sourceLine" id="cb41-2" data-line-number="2">  <span class="dt">E</span><span class="ot"> ::</span> <span class="dt">Heap</span> <span class="dv">0</span> a</a>
<a class="sourceLine" id="cb41-3" data-line-number="3">  <span class="dt">T</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">HVec</span> n a <span class="ot">-&gt;</span> <span class="dt">Heap</span> (<span class="dv">1</span> <span class="fu">+</span> n) a</a>
<a class="sourceLine" id="cb41-4" data-line-number="4"></a>
<a class="sourceLine" id="cb41-5" data-line-number="5"><span class="kw">data</span> <span class="dt">HVec</span> n a <span class="kw">where</span></a>
<a class="sourceLine" id="cb41-6" data-line-number="6">  <span class="dt">HNil</span><span class="ot"> ::</span> <span class="dt">HVec</span> <span class="dv">0</span> a</a>
<a class="sourceLine" id="cb41-7" data-line-number="7">  <span class="dt">HCons</span><span class="ot"> ::</span> <span class="dt">Heap</span> m a <span class="ot">-&gt;</span> <span class="dt">HVec</span> n a <span class="ot">-&gt;</span> <span class="dt">HVec</span> (m <span class="fu">+</span> n) a</a>
<a class="sourceLine" id="cb41-8" data-line-number="8"></a>
<a class="sourceLine" id="cb41-9" data-line-number="9"><span class="ot">insert ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Heap</span> n a <span class="ot">-&gt;</span> <span class="dt">Heap</span> (<span class="dv">1</span> <span class="fu">+</span> n) a</a>
<a class="sourceLine" id="cb41-10" data-line-number="10">insert x xs <span class="fu">=</span> merge (<span class="dt">T</span> x <span class="dt">HNil</span>) xs</a>
<a class="sourceLine" id="cb41-11" data-line-number="11"></a>
<a class="sourceLine" id="cb41-12" data-line-number="12"><span class="ot">merge ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Heap</span> m a <span class="ot">-&gt;</span> <span class="dt">Heap</span> n a <span class="ot">-&gt;</span> <span class="dt">Heap</span> (m <span class="fu">+</span> n) a</a>
<a class="sourceLine" id="cb41-13" data-line-number="13">merge <span class="dt">E</span> ys <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb41-14" data-line-number="14">merge xs <span class="dt">E</span> <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb41-15" data-line-number="15">merge h1<span class="fu">@</span>(<span class="dt">T</span> x xs) h2<span class="fu">@</span>(<span class="dt">T</span> y ys)</a>
<a class="sourceLine" id="cb41-16" data-line-number="16">  <span class="fu">|</span> x <span class="fu">&lt;=</span> y <span class="fu">=</span> <span class="dt">T</span> x (<span class="dt">HCons</span> h2 xs)</a>
<a class="sourceLine" id="cb41-17" data-line-number="17">  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">T</span> y (<span class="dt">HCons</span> h1 ys)</a>
<a class="sourceLine" id="cb41-18" data-line-number="18"></a>
<a class="sourceLine" id="cb41-19" data-line-number="19"><span class="ot">minView ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Heap</span> (<span class="dv">1</span> <span class="fu">+</span> n) a <span class="ot">-&gt;</span> (a, <span class="dt">Heap</span> n a)</a>
<a class="sourceLine" id="cb41-20" data-line-number="20">minView (<span class="dt">T</span> x hs) <span class="fu">=</span> (x, mergePairs hs)</a>
<a class="sourceLine" id="cb41-21" data-line-number="21"></a>
<a class="sourceLine" id="cb41-22" data-line-number="22"><span class="ot">mergePairs ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">HVec</span> n a <span class="ot">-&gt;</span> <span class="dt">Heap</span> n a</a>
<a class="sourceLine" id="cb41-23" data-line-number="23">mergePairs <span class="dt">HNil</span> <span class="fu">=</span> <span class="dt">E</span></a>
<a class="sourceLine" id="cb41-24" data-line-number="24">mergePairs (<span class="dt">HCons</span> h <span class="dt">HNil</span>) <span class="fu">=</span> h</a>
<a class="sourceLine" id="cb41-25" data-line-number="25">mergePairs (<span class="dt">HCons</span> h1 (<span class="dt">HCons</span> h2 hs)) <span class="fu">=</span></a>
<a class="sourceLine" id="cb41-26" data-line-number="26">    merge (merge h1 h2) (mergePairs hs)</a></code></pre></div>
<p>To the version without the plugin:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb42-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Heap</span> n a <span class="kw">where</span></a>
<a class="sourceLine" id="cb42-2" data-line-number="2">  <span class="dt">E</span><span class="ot"> ::</span> <span class="dt">Heap</span> <span class="dt">Z</span> a</a>
<a class="sourceLine" id="cb42-3" data-line-number="3">  <span class="dt">T</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">HVec</span> n a <span class="ot">-&gt;</span> <span class="dt">Heap</span> (<span class="dt">S</span> n) a</a>
<a class="sourceLine" id="cb42-4" data-line-number="4"></a>
<a class="sourceLine" id="cb42-5" data-line-number="5"><span class="kw">data</span> <span class="dt">HVec</span> n a <span class="kw">where</span></a>
<a class="sourceLine" id="cb42-6" data-line-number="6">  <span class="dt">HNil</span><span class="ot"> ::</span> <span class="dt">HVec</span> <span class="dt">Z</span> a</a>
<a class="sourceLine" id="cb42-7" data-line-number="7">  <span class="dt">HCons</span><span class="ot"> ::</span> <span class="dt">Heap</span> m a <span class="ot">-&gt;</span> <span class="dt">HVec</span> n a <span class="ot">-&gt;</span> <span class="dt">HVec</span> (m <span class="fu">+</span> n) a</a>
<a class="sourceLine" id="cb42-8" data-line-number="8"></a>
<a class="sourceLine" id="cb42-9" data-line-number="9"><span class="kw">class</span> <span class="dt">Sized</span> h <span class="kw">where</span></a>
<a class="sourceLine" id="cb42-10" data-line-number="10"><span class="ot">  size ::</span> h n a <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Peano</span> n</a>
<a class="sourceLine" id="cb42-11" data-line-number="11"></a>
<a class="sourceLine" id="cb42-12" data-line-number="12"><span class="kw">instance</span> <span class="dt">Sized</span> <span class="dt">Heap</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb42-13" data-line-number="13">  size <span class="dt">E</span> <span class="fu">=</span> <span class="dt">Zy</span></a>
<a class="sourceLine" id="cb42-14" data-line-number="14">  size (<span class="dt">T</span> _ xs) <span class="fu">=</span> <span class="dt">Sy</span> (size xs)</a>
<a class="sourceLine" id="cb42-15" data-line-number="15"></a>
<a class="sourceLine" id="cb42-16" data-line-number="16"><span class="ot">plus ::</span> <span class="dt">The</span> <span class="dt">Peano</span> n <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Peano</span> m <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Peano</span> (n <span class="fu">+</span> m)</a>
<a class="sourceLine" id="cb42-17" data-line-number="17">plus <span class="dt">Zy</span> m <span class="fu">=</span> m</a>
<a class="sourceLine" id="cb42-18" data-line-number="18">plus (<span class="dt">Sy</span> n) m <span class="fu">=</span> <span class="dt">Sy</span> (plus n m)</a>
<a class="sourceLine" id="cb42-19" data-line-number="19"></a>
<a class="sourceLine" id="cb42-20" data-line-number="20"><span class="kw">instance</span> <span class="dt">Sized</span> <span class="dt">HVec</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb42-21" data-line-number="21">  size <span class="dt">HNil</span> <span class="fu">=</span> <span class="dt">Zy</span></a>
<a class="sourceLine" id="cb42-22" data-line-number="22">  size (<span class="dt">HCons</span> h hs) <span class="fu">=</span> size h <span class="ot">`plus`</span> size hs</a>
<a class="sourceLine" id="cb42-23" data-line-number="23"></a>
<a class="sourceLine" id="cb42-24" data-line-number="24"><span class="ot">insert ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Heap</span> n a <span class="ot">-&gt;</span> <span class="dt">Heap</span> (<span class="dt">S</span> n) a</a>
<a class="sourceLine" id="cb42-25" data-line-number="25">insert x xs <span class="fu">=</span> merge (<span class="dt">T</span> x <span class="dt">HNil</span>) xs</a>
<a class="sourceLine" id="cb42-26" data-line-number="26"></a>
<a class="sourceLine" id="cb42-27" data-line-number="27"><span class="ot">merge ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Heap</span> m a <span class="ot">-&gt;</span> <span class="dt">Heap</span> n a <span class="ot">-&gt;</span> <span class="dt">Heap</span> (m <span class="fu">+</span> n) a</a>
<a class="sourceLine" id="cb42-28" data-line-number="28">merge <span class="dt">E</span> ys <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb42-29" data-line-number="29">merge xs <span class="dt">E</span> <span class="fu">=</span> <span class="kw">case</span> plusZero (size xs) <span class="kw">of</span> <span class="dt">Refl</span> <span class="ot">-&gt;</span> xs</a>
<a class="sourceLine" id="cb42-30" data-line-number="30">merge h1<span class="fu">@</span>(<span class="dt">T</span> x xs) h2<span class="fu">@</span>(<span class="dt">T</span> y ys)</a>
<a class="sourceLine" id="cb42-31" data-line-number="31">  <span class="fu">|</span> x <span class="fu">&lt;=</span> y <span class="fu">=</span> <span class="kw">case</span> plusCommutative (size h2) (size xs) <span class="kw">of</span></a>
<a class="sourceLine" id="cb42-32" data-line-number="32">                    <span class="dt">Refl</span> <span class="ot">-&gt;</span> <span class="dt">T</span> x (<span class="dt">HCons</span> h2 xs)</a>
<a class="sourceLine" id="cb42-33" data-line-number="33">  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="kw">case</span> plusSuccDistrib (size xs) (size ys) <span class="kw">of</span></a>
<a class="sourceLine" id="cb42-34" data-line-number="34">                    <span class="dt">Refl</span> <span class="ot">-&gt;</span> <span class="dt">T</span> y (<span class="dt">HCons</span> h1 ys)</a>
<a class="sourceLine" id="cb42-35" data-line-number="35"></a>
<a class="sourceLine" id="cb42-36" data-line-number="36"><span class="ot">minView ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Heap</span> (<span class="dt">S</span> n) a <span class="ot">-&gt;</span> (a, <span class="dt">Heap</span> n a)</a>
<a class="sourceLine" id="cb42-37" data-line-number="37">minView (<span class="dt">T</span> x hs) <span class="fu">=</span> (x, mergePairs hs)</a>
<a class="sourceLine" id="cb42-38" data-line-number="38"></a>
<a class="sourceLine" id="cb42-39" data-line-number="39"><span class="ot">mergePairs ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">HVec</span> n a <span class="ot">-&gt;</span> <span class="dt">Heap</span> n a</a>
<a class="sourceLine" id="cb42-40" data-line-number="40">mergePairs <span class="dt">HNil</span> <span class="fu">=</span> <span class="dt">E</span></a>
<a class="sourceLine" id="cb42-41" data-line-number="41">mergePairs (<span class="dt">HCons</span> h <span class="dt">HNil</span>) <span class="fu">=</span> <span class="kw">case</span> plusZero (size h) <span class="kw">of</span> <span class="dt">Refl</span> <span class="ot">-&gt;</span> h</a>
<a class="sourceLine" id="cb42-42" data-line-number="42">mergePairs (<span class="dt">HCons</span> h1 (<span class="dt">HCons</span> h2 hs)) <span class="fu">=</span></a>
<a class="sourceLine" id="cb42-43" data-line-number="43">  <span class="kw">case</span> plusAssoc (size h1) (size h2) (size hs) <span class="kw">of</span></a>
<a class="sourceLine" id="cb42-44" data-line-number="44">    <span class="dt">Refl</span> <span class="ot">-&gt;</span> merge (merge h1 h2) (mergePairs hs)</a></code></pre></div>
<h3 id="leftist-heaps">Leftist Heaps</h3>
<p>The typechecker plugin makes it relatively easy to implement several other heaps: skew, Braun, etc. Youâ€™ll need one extra trick to implement a <a href="http://lambda.jstolarek.com/2014/10/weight-biased-leftist-heaps-verified-in-haskell-using-dependent-types/">leftist heap</a>, though. Letâ€™s take a look at the unverified version:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb43-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Leftist</span> a</a>
<a class="sourceLine" id="cb43-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Leaf</span></a>
<a class="sourceLine" id="cb43-3" data-line-number="3">    <span class="fu">|</span> <span class="dt">Node</span> <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">Int</span></a>
<a class="sourceLine" id="cb43-4" data-line-number="4">           a</a>
<a class="sourceLine" id="cb43-5" data-line-number="5">           (<span class="dt">Leftist</span> a)</a>
<a class="sourceLine" id="cb43-6" data-line-number="6">           (<span class="dt">Leftist</span> a)</a>
<a class="sourceLine" id="cb43-7" data-line-number="7"></a>
<a class="sourceLine" id="cb43-8" data-line-number="8"><span class="ot">rank ::</span> <span class="dt">Leftist</span> s <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb43-9" data-line-number="9">rank <span class="dt">Leaf</span>          <span class="fu">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb43-10" data-line-number="10">rank (<span class="dt">Node</span> r _ _ _) <span class="fu">=</span> r</a>
<a class="sourceLine" id="cb43-11" data-line-number="11"><span class="ot">{-# INLINE rank #-}</span></a>
<a class="sourceLine" id="cb43-12" data-line-number="12"></a>
<a class="sourceLine" id="cb43-13" data-line-number="13"><span class="ot">mergeL ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Leftist</span> a <span class="ot">-&gt;</span> <span class="dt">Leftist</span> a <span class="ot">-&gt;</span> <span class="dt">Leftist</span> a</a>
<a class="sourceLine" id="cb43-14" data-line-number="14">mergeL <span class="dt">Leaf</span> h2 <span class="fu">=</span> h2</a>
<a class="sourceLine" id="cb43-15" data-line-number="15">mergeL h1 <span class="dt">Leaf</span> <span class="fu">=</span> h1</a>
<a class="sourceLine" id="cb43-16" data-line-number="16">mergeL h1<span class="fu">@</span>(<span class="dt">Node</span> w1 p1 l1 r1) h2<span class="fu">@</span>(<span class="dt">Node</span> w2 p2 l2 r2)</a>
<a class="sourceLine" id="cb43-17" data-line-number="17">  <span class="fu">|</span> p1 <span class="fu">&lt;</span> p2 <span class="fu">=</span></a>
<a class="sourceLine" id="cb43-18" data-line-number="18">      <span class="kw">if</span> ll <span class="fu">&lt;=</span> lr</a>
<a class="sourceLine" id="cb43-19" data-line-number="19">          <span class="kw">then</span> <span class="dt">LNode</span> (w1 <span class="fu">+</span> w2) p1 l1 (mergeL r1 h2)</a>
<a class="sourceLine" id="cb43-20" data-line-number="20">          <span class="kw">else</span> <span class="dt">LNode</span> (w1 <span class="fu">+</span> w2) p1 (mergeL r1 h2) l1</a>
<a class="sourceLine" id="cb43-21" data-line-number="21">  <span class="fu">|</span> otherwise <span class="fu">=</span></a>
<a class="sourceLine" id="cb43-22" data-line-number="22">      <span class="kw">if</span> rl <span class="fu">&lt;=</span> rr</a>
<a class="sourceLine" id="cb43-23" data-line-number="23">          <span class="kw">then</span> <span class="dt">LNode</span> (w1 <span class="fu">+</span> w2) p2 l2 (mergeL r2 h1)</a>
<a class="sourceLine" id="cb43-24" data-line-number="24">          <span class="kw">else</span> <span class="dt">LNode</span> (w1 <span class="fu">+</span> w2) p2 (mergeL r2 h1) l2</a>
<a class="sourceLine" id="cb43-25" data-line-number="25">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb43-26" data-line-number="26">    ll <span class="fu">=</span> rank r1 <span class="fu">+</span> w2</a>
<a class="sourceLine" id="cb43-27" data-line-number="27">    lr <span class="fu">=</span> rank l1</a>
<a class="sourceLine" id="cb43-28" data-line-number="28">    rl <span class="fu">=</span> rank r2 <span class="fu">+</span> w1</a>
<a class="sourceLine" id="cb43-29" data-line-number="29">    rr <span class="fu">=</span> rank l2</a></code></pre></div>
<p>In a weight-biased leftist heap, the left branch in any tree must have at least as many elements as the right branch. Ideally, we would encode that in the representation of size-indexed leftist heap:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb44-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Leftist</span> n a <span class="kw">where</span></a>
<a class="sourceLine" id="cb44-2" data-line-number="2">        <span class="dt">Leaf</span><span class="ot"> ::</span> <span class="dt">Leftist</span> <span class="dv">0</span> a</a>
<a class="sourceLine" id="cb44-3" data-line-number="3">        <span class="dt">Node</span><span class="ot"> ::</span> <span class="fu">!</span>(<span class="dt">The</span> <span class="dt">Nat</span> (n <span class="fu">+</span> m <span class="fu">+</span> <span class="dv">1</span>))</a>
<a class="sourceLine" id="cb44-4" data-line-number="4">             <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb44-5" data-line-number="5">             <span class="ot">-&gt;</span> <span class="dt">Leftist</span> n a</a>
<a class="sourceLine" id="cb44-6" data-line-number="6">             <span class="ot">-&gt;</span> <span class="dt">Leftist</span> m a</a>
<a class="sourceLine" id="cb44-7" data-line-number="7">             <span class="ot">-&gt;</span> <span class="fu">!</span>(m <span class="fu">&lt;=</span> n)</a>
<a class="sourceLine" id="cb44-8" data-line-number="8">             <span class="ot">-&gt;</span> <span class="dt">Leftist</span> (n <span class="fu">+</span> m <span class="fu">+</span> <span class="dv">1</span>) a</a>
<a class="sourceLine" id="cb44-9" data-line-number="9"></a>
<a class="sourceLine" id="cb44-10" data-line-number="10"><span class="ot">rank ::</span> <span class="dt">Leftist</span> n s <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> n</a>
<a class="sourceLine" id="cb44-11" data-line-number="11">rank <span class="dt">Leaf</span>             <span class="fu">=</span> sing</a>
<a class="sourceLine" id="cb44-12" data-line-number="12">rank (<span class="dt">Node</span> r _ _ _ _) <span class="fu">=</span> r</a>
<a class="sourceLine" id="cb44-13" data-line-number="13"><span class="ot">{-# INLINE rank #-}</span></a></code></pre></div>
<p>Two problems, though: first of all, we need to be able to <em>compare</em> the sizes of two heaps, in the merge function. If we were using the type-level Peano numbers, this would be too slow. More importantly, though, we need the comparison to provide a <em>proof</em> of the ordering, so that we can use it in the resulting <code class="sourceCode haskell"><span class="dt">Node</span></code> constructor.</p>
<h3 id="integer-backed-type-level-numbers">Integer-Backed Type-Level Numbers</h3>
<p>In Agda, the Peano type is actually backed by Haskellâ€™s <code class="sourceCode haskell"><span class="dt">Integer</span></code> at runtime. This allows compile-time proofs to be written about values which are calculated efficiently. We can mimic the same thing in Haskell with a newtype wrapper <em>around</em> <code class="sourceCode haskell"><span class="dt">Integer</span></code> with a phantom <code class="sourceCode haskell"><span class="dt">Peano</span></code> parameter, if we promise to never put an integer in which has a different value to its phantom value. We can make this promise a little more trustworthy if we donâ€™t export the newtype constructor.</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb45-1" data-line-number="1"><span class="kw">newtype</span> <span class="kw">instance</span> <span class="dt">The</span> <span class="dt">Nat</span> n <span class="kw">where</span></a>
<a class="sourceLine" id="cb45-2" data-line-number="2">        <span class="dt">NatSing</span><span class="ot"> ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> n</a>
<a class="sourceLine" id="cb45-3" data-line-number="3"></a>
<a class="sourceLine" id="cb45-4" data-line-number="4"><span class="kw">instance</span> <span class="dt">KnownNat</span> n <span class="ot">=&gt;</span> <span class="dt">KnownSing</span> n <span class="kw">where</span></a>
<a class="sourceLine" id="cb45-5" data-line-number="5">    sing <span class="fu">=</span> <span class="dt">NatSing</span> <span class="fu">$</span> Prelude.fromInteger <span class="fu">$</span> natVal (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> n)</a></code></pre></div>
<p><code class="sourceCode haskell"><span class="dt">FlexibleInstances</span></code> is needed for the instance. We can also encode all the necessary arithmetic:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb46-1" data-line-number="1"><span class="kw">infixl</span> <span class="dv">6</span> <span class="fu">+.</span></a>
<a class="sourceLine" id="cb46-2" data-line-number="2"><span class="ot">(+.) ::</span> <span class="dt">The</span> <span class="dt">Nat</span> n <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> m <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> (n <span class="fu">+</span> m)</a>
<a class="sourceLine" id="cb46-3" data-line-number="3">(<span class="fu">+.</span>) <span class="fu">=</span></a>
<a class="sourceLine" id="cb46-4" data-line-number="4">    (<span class="ot">coerce ::</span> (<span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>) </a>
<a class="sourceLine" id="cb46-5" data-line-number="5">            <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> n <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> m <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> (n <span class="fu">+</span> m))</a>
<a class="sourceLine" id="cb46-6" data-line-number="6">        (<span class="fu">+</span>)</a>
<a class="sourceLine" id="cb46-7" data-line-number="7"><span class="ot">{-# INLINE (+.) #-}</span></a></code></pre></div>
<p>Finally, the compare function (<code class="sourceCode haskell"><span class="dt">ScopedTypeVariables</span></code> for this):</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb47-1" data-line-number="1">infix <span class="dv">4</span> <span class="fu">&lt;=.</span></a>
<a class="sourceLine" id="cb47-2" data-line-number="2"><span class="ot">(&lt;=.) ::</span> <span class="dt">The</span> <span class="dt">Nat</span> n <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> m <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Bool</span> (n <span class="fu">&lt;=?</span> m)</a>
<a class="sourceLine" id="cb47-3" data-line-number="3">(<span class="fu">&lt;=.</span>) (<span class="dt">NatSing</span><span class="ot"> x ::</span> <span class="dt">The</span> <span class="dt">Nat</span> n) (<span class="dt">NatSing</span><span class="ot"> y ::</span> <span class="dt">The</span> <span class="dt">Nat</span> m)</a>
<a class="sourceLine" id="cb47-4" data-line-number="4">  <span class="fu">|</span> x <span class="fu">&lt;=</span> y <span class="fu">=</span> </a>
<a class="sourceLine" id="cb47-5" data-line-number="5">      <span class="kw">case</span> (unsafeCoerce (<span class="dt">Refl</span><span class="ot"> ::</span> <span class="dt">True</span> <span class="fu">:~:</span> <span class="dt">True</span>)<span class="ot"> ::</span> (n <span class="fu">&lt;=?</span> m) <span class="fu">:~:</span> <span class="dt">True</span>) <span class="kw">of</span></a>
<a class="sourceLine" id="cb47-6" data-line-number="6">        <span class="dt">Refl</span> <span class="ot">-&gt;</span> <span class="dt">Truey</span></a>
<a class="sourceLine" id="cb47-7" data-line-number="7">  <span class="fu">|</span> otherwise <span class="fu">=</span> </a>
<a class="sourceLine" id="cb47-8" data-line-number="8">      <span class="kw">case</span> (unsafeCoerce (<span class="dt">Refl</span><span class="ot"> ::</span> <span class="dt">True</span> <span class="fu">:~:</span> <span class="dt">True</span>)<span class="ot"> ::</span> (n <span class="fu">&lt;=?</span> m) <span class="fu">:~:</span> <span class="dt">False</span>) <span class="kw">of</span></a>
<a class="sourceLine" id="cb47-9" data-line-number="9">        <span class="dt">Refl</span> <span class="ot">-&gt;</span> <span class="dt">Falsy</span></a>
<a class="sourceLine" id="cb47-10" data-line-number="10"><span class="ot">{-# INLINE (&lt;=.) #-}</span></a>
<a class="sourceLine" id="cb47-11" data-line-number="11"></a>
<a class="sourceLine" id="cb47-12" data-line-number="12"><span class="ot">totalOrder ::</span>  p n <span class="ot">-&gt;</span> q m <span class="ot">-&gt;</span> (n <span class="fu">&lt;=?</span> m) <span class="fu">:~:</span> <span class="dt">False</span> <span class="ot">-&gt;</span> (m <span class="fu">&lt;=?</span> n) <span class="fu">:~:</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb47-13" data-line-number="13">totalOrder (<span class="ot">_ ::</span> p n) (<span class="ot">_ ::</span> q m) <span class="dt">Refl</span> <span class="fu">=</span> </a>
<a class="sourceLine" id="cb47-14" data-line-number="14">    unsafeCoerce <span class="dt">Refl</span><span class="ot"> ::</span> (m <span class="fu">&lt;=?</span> n) <span class="fu">:~:</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb47-15" data-line-number="15"></a>
<a class="sourceLine" id="cb47-16" data-line-number="16"><span class="kw">type</span> x <span class="fu">&lt;=</span> y <span class="fu">=</span> (x <span class="fu">&lt;=?</span> y) <span class="fu">:~:</span> <span class="dt">True</span></a></code></pre></div>
<p>Itâ€™s worth mentioning that all of these functions are somewhat axiomatic: thereâ€™s no checking of these definitions going on, and any later proofs are only correct in terms of these functions.</p>
<p>If we want our merge function to <em>really</em> look like the non-verified version, though, weâ€™ll have to mess around with the syntax a little.</p>
<h3 id="a-dependent-if-then-else">A Dependent if-then-else</h3>
<p>When matching on a singleton, <em>within</em> the case-match, proof of the singletonâ€™s type is provided. For instance:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb48-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">IfThenElse</span> (<span class="ot">c ::</span> <span class="dt">Bool</span>) (<span class="ot">true ::</span> k) (<span class="ot">false ::</span> k)<span class="ot"> ::</span> k</a>
<a class="sourceLine" id="cb48-2" data-line-number="2">     <span class="kw">where</span></a>
<a class="sourceLine" id="cb48-3" data-line-number="3">        <span class="dt">IfThenElse</span> <span class="dt">True</span> true false <span class="fu">=</span> true</a>
<a class="sourceLine" id="cb48-4" data-line-number="4">        <span class="dt">IfThenElse</span> <span class="dt">False</span> true false <span class="fu">=</span> false</a>
<a class="sourceLine" id="cb48-5" data-line-number="5"></a>
<a class="sourceLine" id="cb48-6" data-line-number="6"><span class="ot">intOrString ::</span> <span class="dt">The</span> <span class="dt">Bool</span> cond <span class="ot">-&gt;</span> <span class="dt">IfThenElse</span> cond <span class="dt">Int</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb48-7" data-line-number="7">intOrString <span class="dt">Truey</span> <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb48-8" data-line-number="8">intOrString <span class="dt">Falsy</span> <span class="fu">=</span> <span class="st">&quot;abc&quot;</span></a></code></pre></div>
<p>In Haskell, since we can overload the if-then-else construct (with <code class="sourceCode haskell"><span class="dt">RebindableSyntax</span></code>), we can provide the same syntax, while hiding the dependent nature:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb49-1" data-line-number="1"><span class="ot">ifThenElse ::</span> <span class="dt">The</span> <span class="dt">Bool</span> c <span class="ot">-&gt;</span> (c <span class="fu">:~:</span> <span class="dt">True</span> <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (c <span class="fu">:~:</span> <span class="dt">False</span> <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb49-2" data-line-number="2">ifThenElse <span class="dt">Truey</span> t _ <span class="fu">=</span> t <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb49-3" data-line-number="3">ifThenElse <span class="dt">Falsy</span> _ f <span class="fu">=</span> f <span class="dt">Refl</span></a></code></pre></div>
<h3 id="verified-merge">Verified Merge</h3>
<p>Finally, then, we can write the implementation for merge, which looks almost <em>exactly</em> the same as the non-verified merge:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb50-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">IndexedQueue</span> <span class="dt">Leftist</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb50-2" data-line-number="2"></a>
<a class="sourceLine" id="cb50-3" data-line-number="3">    minView (<span class="dt">Node</span> _ x l r _) <span class="fu">=</span> (x, merge l r)</a>
<a class="sourceLine" id="cb50-4" data-line-number="4">    <span class="ot">{-# INLINE minView #-}</span></a>
<a class="sourceLine" id="cb50-5" data-line-number="5"></a>
<a class="sourceLine" id="cb50-6" data-line-number="6"></a>
<a class="sourceLine" id="cb50-7" data-line-number="7">    singleton x <span class="fu">=</span> <span class="dt">Node</span> sing x <span class="dt">Leaf</span> <span class="dt">Leaf</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb50-8" data-line-number="8">    <span class="ot">{-# INLINE singleton #-}</span></a>
<a class="sourceLine" id="cb50-9" data-line-number="9"></a>
<a class="sourceLine" id="cb50-10" data-line-number="10">    empty <span class="fu">=</span> <span class="dt">Leaf</span></a>
<a class="sourceLine" id="cb50-11" data-line-number="11">    <span class="ot">{-# INLINE empty #-}</span></a>
<a class="sourceLine" id="cb50-12" data-line-number="12"></a>
<a class="sourceLine" id="cb50-13" data-line-number="13">    insert <span class="fu">=</span> merge <span class="fu">.</span> singleton</a>
<a class="sourceLine" id="cb50-14" data-line-number="14">    <span class="ot">{-# INLINE insert #-}</span></a>
<a class="sourceLine" id="cb50-15" data-line-number="15"></a>
<a class="sourceLine" id="cb50-16" data-line-number="16">    minViewMay <span class="dt">Leaf</span> b _             <span class="fu">=</span> b</a>
<a class="sourceLine" id="cb50-17" data-line-number="17">    minViewMay (<span class="dt">Node</span> _ x l r _) _ f <span class="fu">=</span> f x (merge l r)</a>
<a class="sourceLine" id="cb50-18" data-line-number="18"></a>
<a class="sourceLine" id="cb50-19" data-line-number="19"><span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb50-20" data-line-number="20">         <span class="dt">MeldableIndexedQueue</span> <span class="dt">Leftist</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb50-21" data-line-number="21">    merge <span class="dt">Leaf</span> h2 <span class="fu">=</span> h2</a>
<a class="sourceLine" id="cb50-22" data-line-number="22">    merge h1 <span class="dt">Leaf</span> <span class="fu">=</span> h1</a>
<a class="sourceLine" id="cb50-23" data-line-number="23">    merge h1<span class="fu">@</span>(<span class="dt">Node</span> w1 p1 l1 r1 _) h2<span class="fu">@</span>(<span class="dt">Node</span> w2 p2 l2 r2 _)</a>
<a class="sourceLine" id="cb50-24" data-line-number="24">      <span class="fu">|</span> p1 <span class="fu">&lt;</span> p2 <span class="fu">=</span></a>
<a class="sourceLine" id="cb50-25" data-line-number="25">          <span class="kw">if</span> ll <span class="fu">&lt;=.</span> lr</a>
<a class="sourceLine" id="cb50-26" data-line-number="26">             <span class="kw">then</span> <span class="dt">Node</span> (w1 <span class="fu">+.</span> w2) p1 l1 (merge r1 h2)</a>
<a class="sourceLine" id="cb50-27" data-line-number="27">             <span class="kw">else</span> <span class="dt">Node</span> (w1 <span class="fu">+.</span> w2) p1 (merge r1 h2) l1 <span class="fu">.</span> totalOrder ll lr</a>
<a class="sourceLine" id="cb50-28" data-line-number="28">      <span class="fu">|</span> otherwise <span class="fu">=</span></a>
<a class="sourceLine" id="cb50-29" data-line-number="29">          <span class="kw">if</span> rl <span class="fu">&lt;=.</span> rr</a>
<a class="sourceLine" id="cb50-30" data-line-number="30">              <span class="kw">then</span> <span class="dt">Node</span> (w1 <span class="fu">+.</span> w2) p2 l2 (merge r2 h1)</a>
<a class="sourceLine" id="cb50-31" data-line-number="31">              <span class="kw">else</span> <span class="dt">Node</span> (w1 <span class="fu">+.</span> w2) p2 (merge r2 h1) l2 <span class="fu">.</span> totalOrder rl rr</a>
<a class="sourceLine" id="cb50-32" data-line-number="32">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb50-33" data-line-number="33">        ll <span class="fu">=</span> rank r1 <span class="fu">+.</span> w2</a>
<a class="sourceLine" id="cb50-34" data-line-number="34">        lr <span class="fu">=</span> rank l1</a>
<a class="sourceLine" id="cb50-35" data-line-number="35">        rl <span class="fu">=</span> rank r2 <span class="fu">+.</span> w1</a>
<a class="sourceLine" id="cb50-36" data-line-number="36">        rr <span class="fu">=</span> rank l2</a>
<a class="sourceLine" id="cb50-37" data-line-number="37">    <span class="ot">{-# INLINE merge #-}</span></a></code></pre></div>
<p>Whatâ€™s cool about this implementation is that it has the same performance as the non-verified version (if <code class="sourceCode haskell"><span class="dt">Integer</span></code> is swapped out for <code class="sourceCode haskell"><span class="dt">Int</span></code>, that is), and it <em>looks</em> pretty much the same. This is very close to static verification for free.</p>
<h3 id="generalizing-sort-to-parts">Generalizing Sort to Parts</h3>
<p>The <code class="sourceCode haskell"><span class="dt">Sort</span></code> type used in the original blog post can be generalized to <em>any</em> indexed container.</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb51-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Parts</span> f g a b r <span class="kw">where</span></a>
<a class="sourceLine" id="cb51-2" data-line-number="2">    <span class="dt">Parts</span><span class="ot"> ::</span> (forall n<span class="fu">.</span> g (m <span class="fu">+</span> n) b <span class="ot">-&gt;</span> (g n b, r))</a>
<a class="sourceLine" id="cb51-3" data-line-number="3">         <span class="ot">-&gt;</span> <span class="fu">!</span>(f m a)</a>
<a class="sourceLine" id="cb51-4" data-line-number="4">         <span class="ot">-&gt;</span> <span class="dt">Parts</span> f g a b r</a>
<a class="sourceLine" id="cb51-5" data-line-number="5"></a>
<a class="sourceLine" id="cb51-6" data-line-number="6"><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Parts</span> f g a b) <span class="kw">where</span></a>
<a class="sourceLine" id="cb51-7" data-line-number="7">  fmap f (<span class="dt">Parts</span> g h) <span class="fu">=</span></a>
<a class="sourceLine" id="cb51-8" data-line-number="8">    <span class="dt">Parts</span> (\h&#39; <span class="ot">-&gt;</span> <span class="kw">case</span> g h&#39; <span class="kw">of</span> (remn, r) <span class="ot">-&gt;</span> (remn, f r)) h</a>
<a class="sourceLine" id="cb51-9" data-line-number="9">  <span class="ot">{-# INLINE fmap #-}</span></a>
<a class="sourceLine" id="cb51-10" data-line-number="10"></a>
<a class="sourceLine" id="cb51-11" data-line-number="11"><span class="kw">instance</span> (<span class="dt">IndexedQueue</span> f x, <span class="dt">MeldableIndexedQueue</span> f x) <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb51-12" data-line-number="12">          <span class="dt">Applicative</span> (<span class="dt">Parts</span> f g x y) <span class="kw">where</span></a>
<a class="sourceLine" id="cb51-13" data-line-number="13">    pure x <span class="fu">=</span> <span class="dt">Parts</span> (\h <span class="ot">-&gt;</span> (h, x)) empty</a>
<a class="sourceLine" id="cb51-14" data-line-number="14">    <span class="ot">{-# INLINE pure #-}</span></a>
<a class="sourceLine" id="cb51-15" data-line-number="15"></a>
<a class="sourceLine" id="cb51-16" data-line-number="16">    (<span class="dt">Parts</span> f (<span class="ot">xs ::</span> f m x)<span class="ot"> ::</span> <span class="dt">Parts</span> f g x y (a <span class="ot">-&gt;</span> b)) <span class="fu">&lt;*&gt;</span> </a>
<a class="sourceLine" id="cb51-17" data-line-number="17">      <span class="dt">Parts</span> g (<span class="ot">ys ::</span> f n x) <span class="fu">=</span></a>
<a class="sourceLine" id="cb51-18" data-line-number="18">        <span class="dt">Parts</span> h (merge xs ys)</a>
<a class="sourceLine" id="cb51-19" data-line-number="19">        <span class="kw">where</span></a>
<a class="sourceLine" id="cb51-20" data-line-number="20"><span class="ot">          h ::</span> forall o <span class="fu">.</span> g ((m <span class="fu">+</span> n) <span class="fu">+</span> o) y <span class="ot">-&gt;</span> (g o y, b)</a>
<a class="sourceLine" id="cb51-21" data-line-number="21">          h v <span class="fu">=</span> <span class="kw">case</span> f v <span class="kw">of</span> { (v&#39;, a) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb51-22" data-line-number="22">                    <span class="kw">case</span> g v&#39; <span class="kw">of</span> { (v&#39;&#39;, b) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb51-23" data-line-number="23">                      (v&#39;&#39;, a b)}}</a>
<a class="sourceLine" id="cb51-24" data-line-number="24">    <span class="ot">{-# INLINABLE (&lt;*&gt;) #-}</span></a></code></pre></div>
<p>This version doesnâ€™t insist that you order the elements of the heap in any particular way: we could use indexed difference lists to reverse a container, or indexed lists to calculate permutations of a container, for instance.</p>
<h3 id="other-uses-for-size-indexed-heaps">Other Uses For Size-Indexed Heaps</h3>
<p>Iâ€™d be very interested to see any other uses of these indexed heaps, if anyone has any ideas. Potentially the could be used in any place where there is a need for some heap which is known to be of a certain size (a true prime sieve, for instance).</p>
<h3 id="the-library">The Library</h3>
<p>Iâ€™ve explored all of these ideas <a href="https://github.com/oisdk/type-indexed-queues">here</a>. It has implementations of all the heaps I mentioned, as well as the index-erasing type, and a size-indexed list, for reversing traversables. In the future, I might add things like a Fibonacci heap, or the optimal Brodal/Okasaki heap <span class="citation" data-cites="brodal_optimal_1996">(Brodal and Okasaki <a href="#ref-brodal_optimal_1996">1996</a>)</span>.</p>
<hr />
<div id="refs" class="references">
<div id="ref-brodal_optimal_1996">
<p>Brodal, Gerth StÃ¸lting, and Chris Okasaki. 1996. â€œOptimal Purely Functional Priority Queues.â€ <em>Journal of Functional Programming</em> 6 (6) (November): 839â€“857. doi:<a href="https://doi.org/10.1017/S095679680000201X">10.1017/S095679680000201X</a>. <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.48.973" class="uri">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.48.973</a>.</p>
</div>
<div id="ref-diatchki_improving_2015">
<p>Diatchki, Iavor S. 2015. â€œImproving Haskell Types with SMT.â€ In <em>Proceedings of the 2015 ACM SIGPLAN Symposium on Haskell</em>, 1â€“10. Haskell â€™15. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/2804302.2804307">10.1145/2804302.2804307</a>. <a href="http://yav.github.io/publications/improving-smt-types.pdf" class="uri">http://yav.github.io/publications/improving-smt-types.pdf</a>.</p>
</div>
<div id="ref-eisenberg_dependently_2012">
<p>Eisenberg, Richard A., and Stephanie Weirich. 2012. â€œDependently Typed Programming with Singletons.â€ In <em>Proceedings of the 2012 Haskell Symposium</em>, 117â€“130. Haskell â€™12. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/2364506.2364522">10.1145/2364506.2364522</a>. <a href="http://cs.brynmawr.edu/~rae/papers/2012/singletons/paper.pdf" class="uri">http://cs.brynmawr.edu/~rae/papers/2012/singletons/paper.pdf</a>.</p>
</div>
<div id="ref-fredman_pairing_1986">
<p>Fredman, Michael L., Robert Sedgewick, Daniel D. Sleator, and Robert E. Tarjan. 1986. â€œThe pairing heap: A new form of self-adjusting heap.â€ <em>Algorithmica</em> 1 (1-4) (January): 111â€“129. doi:<a href="https://doi.org/10.1007/BF01840439">10.1007/BF01840439</a>. <a href="http://www.cs.princeton.edu/courses/archive/fall09/cos521/Handouts/pairingheaps.pdf" class="uri">http://www.cs.princeton.edu/courses/archive/fall09/cos521/Handouts/pairingheaps.pdf</a>.</p>
</div>
<div id="ref-hinze_functional_1999">
<p>Hinze, Ralf. 1999. â€œFunctional Pearls: Explaining Binomial Heaps.â€ <em>Journal of Functional Programming</em> 9 (1) (January): 93â€“104. doi:<a href="https://doi.org/10.1017/S0956796899003317">10.1017/S0956796899003317</a>. <a href="http://www.cs.ox.ac.uk/ralf.hinze/publications/#J1" class="uri">http://www.cs.ox.ac.uk/ralf.hinze/publications/#J1</a>.</p>
</div>
<div id="ref-hinze_manufacturing_2001">
<p>â€”â€”â€”. 2001. â€œManufacturing datatypes.â€ <em>Journal of Functional Programming</em> 11 (5) (September): 493â€“524. doi:<a href="https://doi.org/10.1017/S095679680100404X">10.1017/S095679680100404X</a>. <a href="http://www.cs.ox.ac.uk/ralf.hinze/publications/#J6" class="uri">http://www.cs.ox.ac.uk/ralf.hinze/publications/#J6</a>.</p>
</div>
<div id="ref-okasaki_fast_1999">
<p>Okasaki, Chris. 1999. â€œFrom Fast Exponentiation to Square Matrices: An Adventure in Types.â€ In <em>Proceedings of the ACM SIGPLAN International Conference on Functional Programming (ICFPâ€™99), Paris, France, September 27-29, 1999</em>, 34:28. ACM. <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.456.357&amp;rep=rep1&amp;type=pdf" class="uri">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.456.357&amp;rep=rep1&amp;type=pdf</a>.</p>
</div>
<div id="ref-wasserman_playing_2010">
<p>Wasserman, Louis. 2010. â€œPlaying with Priority Queues.â€ <em>The Monad.Reader</em> 16 (16) (May): 37. <a href="https://themonadreader.files.wordpress.com/2010/05/issue16.pdf" class="uri">https://themonadreader.files.wordpress.com/2010/05/issue16.pdf</a>.</p>
</div>
</div>
]]></description>
    <pubDate>Sun, 23 Apr 2017 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2017-04-23-verifying-data-structures-in-haskell-lhs.html</guid>
    <dc:creator>Donnacha OisÃ­n Kidney</dc:creator>
</item>
<item>
    <title>Fun with Recursion Schemes</title>
    <link>https://doisinkidney.com/posts/2017-03-30-fun-with-recursion-schemes.html</link>
    <description><![CDATA[<div class="info">
    Posted on March 30, 2017
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Recursion%20Schemes.html">Recursion Schemes</a>
    
</div>

<h2 id="folding-algebras">Folding Algebras</h2>
<p>I saw <a href="https://www.reddit.com/r/haskell/comments/608y0l/would_this_sugar_make_sense/">this</a> post on reddit recently, and it got me thinking about recursion schemes. One of the primary motivations behind them is the reduction of boilerplate. The classic example is evaluation of arithmetic expressions:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> <span class="dt">ExprF</span> a</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">LitF</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  <span class="fu">|</span> (<span class="fu">:+:</span>) a a</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">  <span class="fu">|</span> (<span class="fu">:*:</span>) a a</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">  <span class="kw">deriving</span> <span class="dt">Functor</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="kw">type</span> <span class="dt">Expr</span> <span class="fu">=</span> <span class="dt">Fix</span> <span class="dt">ExprF</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"></a>
<a class="sourceLine" id="cb1-9" data-line-number="9"><span class="ot">eval ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10">eval <span class="fu">=</span> unfix <span class="fu">&gt;&gt;&gt;</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11">  <span class="dt">LitF</span> n <span class="ot">-&gt;</span> n</a>
<a class="sourceLine" id="cb1-12" data-line-number="12">  x <span class="fu">:+:</span> y <span class="ot">-&gt;</span> eval x <span class="fu">+</span> eval y</a>
<a class="sourceLine" id="cb1-13" data-line-number="13">  x <span class="fu">:*:</span> y <span class="ot">-&gt;</span> eval x <span class="fu">*</span> eval y</a></code></pre></div>
<p>The calls to <code class="sourceCode haskell">eval</code> are the boilerplate: this is where the main recursion scheme, <code class="sourceCode haskell">cata</code> can help.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">evalF ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">evalF <span class="fu">=</span> cata <span class="fu">$</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  <span class="dt">LitF</span> n <span class="ot">-&gt;</span> n</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">  x <span class="fu">:+:</span> y <span class="ot">-&gt;</span> x <span class="fu">+</span> y</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">  x <span class="fu">:*:</span> y <span class="ot">-&gt;</span> x <span class="fu">*</span> y</a></code></pre></div>
<p>I still feel like thereâ€™s boilerplate, though. Ideally Iâ€™d like to write this:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">evalF ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">evalF <span class="fu">=</span> cata <span class="fu">$</span> <span class="fu">???</span> <span class="fu">$</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">  <span class="dt">Lit</span> <span class="ot">-&gt;</span> id</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">  <span class="dt">Add</span> <span class="ot">-&gt;</span> (<span class="fu">+</span>)</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">  <span class="dt">Mul</span> <span class="ot">-&gt;</span> (<span class="fu">*</span>)</a></code></pre></div>
<p>The <code class="sourceCode haskell"><span class="fu">???</span></code> needs to be filled in. Itâ€™s a little tricky, though: the type of the algebra changes depending on what expression itâ€™s given. GADTs will allow us to attach types to cases:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">data</span> <span class="dt">ExprI</span> a r f <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  <span class="dt">Lit</span><span class="ot"> ::</span> <span class="dt">ExprI</span> a b (<span class="dt">Integer</span> <span class="ot">-&gt;</span> b)</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  <span class="dt">Add</span><span class="ot"> ::</span> <span class="dt">ExprI</span> a b (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b)</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">  <span class="dt">Mul</span><span class="ot"> ::</span> <span class="dt">ExprI</span> a b (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b)</a></code></pre></div>
<p>The first type parameter is the same as the first type parameter to <code class="sourceCode haskell"><span class="dt">ExprF</span></code>. The second is the output type of the algebra, and the third is the type of the fold required to produce that output type. The third type parameter <em>depends</em> on the case matched in the GADT. Using this, we can write a function which converts a fold/pattern match to a standard algebra:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">foldAlg ::</span> (forall f<span class="fu">.</span> <span class="dt">ExprI</span> a r f <span class="ot">-&gt;</span> f) <span class="ot">-&gt;</span> (<span class="dt">ExprF</span> a <span class="ot">-&gt;</span> r)</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">foldAlg f (<span class="dt">LitF</span> i)  <span class="fu">=</span> f <span class="dt">Lit</span> i</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">foldAlg f (x <span class="fu">:+:</span> y) <span class="fu">=</span> f <span class="dt">Add</span> x y</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">foldAlg f (x <span class="fu">:*:</span> y) <span class="fu">=</span> f <span class="dt">Mul</span> x y</a></code></pre></div>
<p>And finally, we can write the nice evaluation algebra:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">evalF ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">evalF <span class="fu">=</span> cata <span class="fu">$</span> foldAlg <span class="fu">$</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  <span class="dt">Lit</span> <span class="ot">-&gt;</span> id</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">  <span class="dt">Add</span> <span class="ot">-&gt;</span> (<span class="fu">+</span>)</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">  <span class="dt">Mul</span> <span class="ot">-&gt;</span> (<span class="fu">*</span>)</a></code></pre></div>
<p>I hacked together some quick template Haskell to generate the matchers over <a href="https://github.com/oisdk/pattern-folds">here</a>. It uses a class <code class="sourceCode haskell"><span class="dt">AsPatternFold</span></code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">class</span> <span class="dt">AsPatternFold</span> x f <span class="fu">|</span> x <span class="ot">-&gt;</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="ot">  foldMatch ::</span> (forall a<span class="fu">.</span> f r a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (x <span class="ot">-&gt;</span> r)</a></code></pre></div>
<p>And you generate the extra data type, with an instance, by doing this:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">makePatternFolds <span class="ch">&#39;&#39;</span><span class="dt">ExprF</span></a></code></pre></div>
<p>The code it generates can be used like this:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">evalF ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">evalF <span class="fu">=</span> cata <span class="fu">$</span> foldMatch <span class="fu">$</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  <span class="dt">LitI</span> <span class="ot">-&gt;</span> id</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">  (<span class="fu">:+|</span>) <span class="ot">-&gt;</span> (<span class="fu">+</span>)</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  (<span class="fu">:*|</span>) <span class="ot">-&gt;</span> (<span class="fu">*</span>)</a></code></pre></div>
<p>Itâ€™s terribly hacky at the moment, I may clean it up later.</p>
<h2 id="record-case">Record Case</h2>
<p>Thereâ€™s another approach to the same idea that is slightly more sensible, using record wildcards. You define a handler for you datatype (an algebra):</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">data</span> <span class="dt">ExprAlg</span> a r</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">ExprAlg</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  {<span class="ot"> litF ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> r</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">  ,<span class="ot"> (+:) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> r</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">  ,<span class="ot"> (*:) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> r }</a></code></pre></div>
<p>Then, to use it, you define how to interact between the handler and the datatype, like before. The benefit is that record wildcard syntax allows you to piggy back on the function definition syntax, like so:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">data</span> <span class="dt">ExprF</span> a</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">LitF</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  <span class="fu">|</span> (<span class="fu">:+:</span>) a a</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">  <span class="fu">|</span> (<span class="fu">:*:</span>) a a</a>
<a class="sourceLine" id="cb11-5" data-line-number="5"></a>
<a class="sourceLine" id="cb11-6" data-line-number="6">makeHandler <span class="ch">&#39;&#39;</span><span class="dt">ExprF</span></a>
<a class="sourceLine" id="cb11-7" data-line-number="7"></a>
<a class="sourceLine" id="cb11-8" data-line-number="8"><span class="ot">exprAlg ::</span> <span class="dt">ExprF</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb11-9" data-line-number="9">exprAlg <span class="fu">=</span> index <span class="dt">ExprFAlg</span> {<span class="fu">..</span>} <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-10" data-line-number="10">  litF <span class="fu">=</span> id</a>
<a class="sourceLine" id="cb11-11" data-line-number="11">  (<span class="fu">+:</span>) <span class="fu">=</span> (<span class="fu">+</span>)</a>
<a class="sourceLine" id="cb11-12" data-line-number="12">  (<span class="fu">*:</span>) <span class="fu">=</span> (<span class="fu">*</span>)</a></code></pre></div>
<p>This approach is much more principled: the <code class="sourceCode haskell">index</code> function, for example, comes from the <a href="https://hackage.haskell.org/package/adjunctions">adjunctions</a> package, from the <a href="https://hackage.haskell.org/package/adjunctions-4.3/docs/Data-Functor-Rep.html"><code class="sourceCode haskell"><span class="dt">Representable</span></code></a> class. Thatâ€™s because those algebras are actually representable functors, with their representation being the thing they match. They also conform to a whole bunch of things automatically, letting you combine them interesting ways.</p>
<h2 id="printing-expressions">Printing Expressions</h2>
<p>Properly printing expressions, with minimal parentheses, is a surprisingly difficult problem. <span class="citation" data-cites="ramsey_unparsing_1998">Ramsey (<a href="#ref-ramsey_unparsing_1998">1998</a>)</span> provides a solution of the form:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1">isParens side (<span class="dt">Assoc</span> ao po) (<span class="dt">Assoc</span> ai pi) <span class="fu">=</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">  pi <span class="fu">&lt;=</span> po <span class="fu">&amp;&amp;</span> (pi <span class="fu">/=</span> po <span class="fu">||</span> ai <span class="fu">/=</span> ao <span class="fu">||</span> ao <span class="fu">/=</span> side)</a></code></pre></div>
<p>Using this, we can write an algebra for printing expressions. It should work in the general case, not just on the expression type defined above, so we need to make another unfixed functor to describe the printing of an expression:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Side</span> <span class="fu">=</span> <span class="dt">L</span> <span class="fu">|</span> <span class="dt">R</span> <span class="kw">deriving</span> <span class="dt">Eq</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2"></a>
<a class="sourceLine" id="cb13-3" data-line-number="3"><span class="kw">data</span> <span class="dt">ShowExpr</span> t e</a>
<a class="sourceLine" id="cb13-4" data-line-number="4">  <span class="fu">=</span> <span class="dt">ShowLit</span> {<span class="ot"> _repr ::</span> t }</a>
<a class="sourceLine" id="cb13-5" data-line-number="5">  <span class="fu">|</span> <span class="dt">Prefix</span>  {<span class="ot"> _repr ::</span> t,<span class="ot"> _assoc ::</span> (<span class="dt">Int</span>,<span class="dt">Side</span>),<span class="ot"> _child  ::</span> e }</a>
<a class="sourceLine" id="cb13-6" data-line-number="6">  <span class="fu">|</span> <span class="dt">Postfix</span> {<span class="ot"> _repr ::</span> t,<span class="ot"> _assoc ::</span> (<span class="dt">Int</span>,<span class="dt">Side</span>),<span class="ot"> _child  ::</span> e }</a>
<a class="sourceLine" id="cb13-7" data-line-number="7">  <span class="fu">|</span> <span class="dt">Binary</span>  {<span class="ot"> _repr ::</span> t,<span class="ot"> _assoc ::</span> (<span class="dt">Int</span>,<span class="dt">Side</span>),<span class="ot"> _lchild ::</span> e</a>
<a class="sourceLine" id="cb13-8" data-line-number="8">                                              ,<span class="ot"> _rchild ::</span> e }</a>
<a class="sourceLine" id="cb13-9" data-line-number="9">  <span class="kw">deriving</span> <span class="dt">Functor</span></a>
<a class="sourceLine" id="cb13-10" data-line-number="10">  </a>
<a class="sourceLine" id="cb13-11" data-line-number="11">makeLenses <span class="ch">&#39;&#39;</span><span class="dt">ShowExpr</span></a></code></pre></div>
<p>The lenses are probably overkill. For printing, we need not only the precedence of the current level, but also the precedence one level below. Seems like the perfect case for a zygomorphism:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="ot">showExprAlg ::</span> <span class="dt">Semigroup</span> t</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">            <span class="ot">=&gt;</span> (t <span class="ot">-&gt;</span> t)</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">            <span class="ot">-&gt;</span> <span class="dt">ShowExpr</span> t (<span class="dt">Maybe</span> (<span class="dt">Int</span>,<span class="dt">Side</span>), t)</a>
<a class="sourceLine" id="cb14-4" data-line-number="4">            <span class="ot">-&gt;</span> t</a>
<a class="sourceLine" id="cb14-5" data-line-number="5">showExprAlg prns <span class="fu">=</span> \<span class="kw">case</span> </a>
<a class="sourceLine" id="cb14-6" data-line-number="6">    <span class="dt">ShowLit</span> t               <span class="ot">-&gt;</span>                   t</a>
<a class="sourceLine" id="cb14-7" data-line-number="7">    <span class="dt">Prefix</span>  t s       (q,y) <span class="ot">-&gt;</span>                   t <span class="fu">&lt;&gt;</span> ifPrns <span class="dt">R</span> s q y</a>
<a class="sourceLine" id="cb14-8" data-line-number="8">    <span class="dt">Postfix</span> t s (p,x)       <span class="ot">-&gt;</span> ifPrns <span class="dt">L</span> s p x <span class="fu">&lt;&gt;</span> t</a>
<a class="sourceLine" id="cb14-9" data-line-number="9">    <span class="dt">Binary</span>  t s (p,x) (q,y) <span class="ot">-&gt;</span> ifPrns <span class="dt">L</span> s p x <span class="fu">&lt;&gt;</span> t <span class="fu">&lt;&gt;</span> ifPrns <span class="dt">R</span> s q y</a>
<a class="sourceLine" id="cb14-10" data-line-number="10">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-11" data-line-number="11">    ifPrns sid (op,oa) (<span class="dt">Just</span> (ip,ia))</a>
<a class="sourceLine" id="cb14-12" data-line-number="12">      <span class="fu">|</span> ip <span class="fu">&lt;</span> op <span class="fu">||</span> ip <span class="fu">==</span> op <span class="fu">&amp;&amp;</span> (ia <span class="fu">/=</span> oa <span class="fu">||</span> sid <span class="fu">/=</span> oa) <span class="fu">=</span> prns</a>
<a class="sourceLine" id="cb14-13" data-line-number="13">    ifPrns _ _ _ <span class="fu">=</span> id</a></code></pre></div>
<p>The first argument to this algebra is the parenthesizing function. This algebra works fine for when the <code class="sourceCode haskell"><span class="dt">ShowExpr</span></code> type is already constructed:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="ot">showExpr&#39; ::</span> <span class="dt">Semigroup</span> t <span class="ot">=&gt;</span> (t <span class="ot">-&gt;</span> t) <span class="ot">-&gt;</span> <span class="dt">Fix</span> (<span class="dt">ShowExpr</span> t) <span class="ot">-&gt;</span> t</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">showExpr&#39; <span class="fu">=</span> zygo (preview assoc) <span class="fu">.</span> showExprAlg</a></code></pre></div>
<p>But we still need to construct the <code class="sourceCode haskell"><span class="dt">ShowExpr</span></code> from something else first. <code class="sourceCode haskell">hylo</code> might be a good fit:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="ot">hylo ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (f b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> f a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b</a></code></pre></div>
<p>But that performs a catamorphism after an anamorphism, and we want a zygomorphism after an anamorphism. Luckily, the <a href="https://hackage.haskell.org/package/recursion-schemes">recursion-schemes</a> library is constructed in such a way that different schemes can be stuck together relatively easily:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1">hylozygo</a>
<a class="sourceLine" id="cb17-2" data-line-number="2"><span class="ot">    ::</span> <span class="dt">Functor</span> f</a>
<a class="sourceLine" id="cb17-3" data-line-number="3">    <span class="ot">=&gt;</span> (f a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (f (a, b) <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> f c) <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb17-4" data-line-number="4">hylozygo x y z <span class="fu">=</span> ghylo (distZygo x) distAna y (fmap <span class="dt">Identity</span> <span class="fu">.</span> z)</a>
<a class="sourceLine" id="cb17-5" data-line-number="5"></a>
<a class="sourceLine" id="cb17-6" data-line-number="6"><span class="ot">showExpr ::</span> <span class="dt">Semigroup</span> t</a>
<a class="sourceLine" id="cb17-7" data-line-number="7">         <span class="ot">=&gt;</span> (t <span class="ot">-&gt;</span> t)</a>
<a class="sourceLine" id="cb17-8" data-line-number="8">         <span class="ot">-&gt;</span> (e <span class="ot">-&gt;</span> <span class="dt">ShowExpr</span> t e)</a>
<a class="sourceLine" id="cb17-9" data-line-number="9">         <span class="ot">-&gt;</span> e <span class="ot">-&gt;</span> t</a>
<a class="sourceLine" id="cb17-10" data-line-number="10">showExpr <span class="fu">=</span> hylozygo (preview assoc) <span class="fu">.</span> showExprAlg</a></code></pre></div>
<p>Letâ€™s try it out, with a right-associative operator this time to make things more difficult:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="kw">data</span> <span class="dt">ExprF</span> a</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">LitF</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3">  <span class="fu">|</span> (<span class="fu">:+:</span>) a a</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">  <span class="fu">|</span> (<span class="fu">:*:</span>) a a</a>
<a class="sourceLine" id="cb18-5" data-line-number="5">  <span class="fu">|</span> (<span class="fu">:^:</span>) a a</a>
<a class="sourceLine" id="cb18-6" data-line-number="6">  <span class="kw">deriving</span> <span class="dt">Functor</span></a>
<a class="sourceLine" id="cb18-7" data-line-number="7"></a>
<a class="sourceLine" id="cb18-8" data-line-number="8">makeHandler <span class="ch">&#39;&#39;</span><span class="dt">ExprF</span></a>
<a class="sourceLine" id="cb18-9" data-line-number="9"></a>
<a class="sourceLine" id="cb18-10" data-line-number="10"><span class="kw">newtype</span> <span class="dt">Expr</span> <span class="fu">=</span> <span class="dt">Expr</span> {<span class="ot"> runExpr ::</span> <span class="dt">ExprF</span> <span class="dt">Expr</span> }</a>
<a class="sourceLine" id="cb18-11" data-line-number="11"></a>
<a class="sourceLine" id="cb18-12" data-line-number="12"><span class="kw">instance</span> <span class="dt">Num</span> <span class="dt">Expr</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-13" data-line-number="13">  fromInteger <span class="fu">=</span> <span class="dt">Expr</span> <span class="fu">.</span> <span class="dt">LitF</span></a>
<a class="sourceLine" id="cb18-14" data-line-number="14">  x <span class="fu">+</span> y <span class="fu">=</span> <span class="dt">Expr</span> (x <span class="fu">:+:</span> y)</a>
<a class="sourceLine" id="cb18-15" data-line-number="15">  x <span class="fu">*</span> y <span class="fu">=</span> <span class="dt">Expr</span> (x <span class="fu">:*:</span> y)</a>
<a class="sourceLine" id="cb18-16" data-line-number="16">  </a>
<a class="sourceLine" id="cb18-17" data-line-number="17"><span class="kw">infixr</span> <span class="dv">8</span> <span class="fu">^*</span></a>
<a class="sourceLine" id="cb18-18" data-line-number="18"><span class="ot">(^*) ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></a>
<a class="sourceLine" id="cb18-19" data-line-number="19">x <span class="fu">^*</span> y <span class="fu">=</span> <span class="dt">Expr</span> (x <span class="fu">:^:</span> y)</a>
<a class="sourceLine" id="cb18-20" data-line-number="20"></a>
<a class="sourceLine" id="cb18-21" data-line-number="21"><span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Expr</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-22" data-line-number="22">  show <span class="fu">=</span></a>
<a class="sourceLine" id="cb18-23" data-line-number="23">    showExpr</a>
<a class="sourceLine" id="cb18-24" data-line-number="24">      (\x <span class="ot">-&gt;</span> <span class="st">&quot;(&quot;</span> <span class="fu">++</span> x <span class="fu">++</span> <span class="st">&quot;)&quot;</span>)</a>
<a class="sourceLine" id="cb18-25" data-line-number="25">      (index <span class="dt">ExprFAlg</span> {<span class="fu">..</span>} <span class="fu">.</span> runExpr)</a>
<a class="sourceLine" id="cb18-26" data-line-number="26">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-27" data-line-number="27">      litF <span class="fu">=</span> <span class="dt">ShowLit</span> <span class="fu">.</span> show</a>
<a class="sourceLine" id="cb18-28" data-line-number="28">      (<span class="fu">+:</span>) <span class="fu">=</span> <span class="dt">Binary</span> <span class="st">&quot; + &quot;</span> (<span class="dv">6</span>,<span class="dt">L</span>)</a>
<a class="sourceLine" id="cb18-29" data-line-number="29">      (<span class="fu">*:</span>) <span class="fu">=</span> <span class="dt">Binary</span> <span class="st">&quot; * &quot;</span> (<span class="dv">7</span>,<span class="dt">L</span>)</a>
<a class="sourceLine" id="cb18-30" data-line-number="30">      (<span class="fu">^:</span>) <span class="fu">=</span> <span class="dt">Binary</span> <span class="st">&quot; ^ &quot;</span> (<span class="dv">8</span>,<span class="dt">R</span>)</a></code></pre></div>
<p>Since we only specified <code class="sourceCode haskell"><span class="dt">Semigroup</span></code> in the definition of <code class="sourceCode haskell">showExpr</code>, we can use the more efficient difference-list definition of <code class="sourceCode haskell"><span class="dt">Show</span></code>:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Expr</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-2" data-line-number="2">    showsPrec _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb19-3" data-line-number="3">      appEndo <span class="fu">.</span> showExpr</a>
<a class="sourceLine" id="cb19-4" data-line-number="4">        (<span class="dt">Endo</span> <span class="fu">.</span> showParen <span class="dt">True</span> <span class="fu">.</span> appEndo)</a>
<a class="sourceLine" id="cb19-5" data-line-number="5">        (index <span class="dt">ExprFAlg</span> {<span class="fu">..</span>} <span class="fu">.</span> runExpr)</a>
<a class="sourceLine" id="cb19-6" data-line-number="6">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-7" data-line-number="7">        litF <span class="fu">=</span> <span class="dt">ShowLit</span> <span class="fu">.</span> <span class="dt">Endo</span> <span class="fu">.</span> shows</a>
<a class="sourceLine" id="cb19-8" data-line-number="8">        (<span class="fu">+:</span>) <span class="fu">=</span> <span class="dt">Binary</span> (<span class="dt">Endo</span> (<span class="st">&quot; + &quot;</span> <span class="fu">++</span>)) (<span class="dv">6</span>,<span class="dt">L</span>)</a>
<a class="sourceLine" id="cb19-9" data-line-number="9">        (<span class="fu">*:</span>) <span class="fu">=</span> <span class="dt">Binary</span> (<span class="dt">Endo</span> (<span class="st">&quot; * &quot;</span> <span class="fu">++</span>)) (<span class="dv">7</span>,<span class="dt">L</span>)</a>
<a class="sourceLine" id="cb19-10" data-line-number="10">        (<span class="fu">^:</span>) <span class="fu">=</span> <span class="dt">Binary</span> (<span class="dt">Endo</span> (<span class="st">&quot; ^ &quot;</span> <span class="fu">++</span>)) (<span class="dv">8</span>,<span class="dt">R</span>)</a>
<a class="sourceLine" id="cb19-11" data-line-number="11"></a>
<a class="sourceLine" id="cb19-12" data-line-number="12"><span class="dv">1</span> <span class="fu">^*</span> <span class="dv">2</span> <span class="fu">^*</span> <span class="dv">3</span>         <span class="co">-- 1 ^ 2 ^ 3</span></a>
<a class="sourceLine" id="cb19-13" data-line-number="13">(<span class="dv">1</span> <span class="fu">^*</span> <span class="dv">2</span>) <span class="fu">^*</span> <span class="dv">3</span>       <span class="co">-- (1 ^ 2) ^ 3</span></a>
<a class="sourceLine" id="cb19-14" data-line-number="14"><span class="dv">1</span> <span class="fu">*</span> <span class="dv">2</span> <span class="fu">+</span> <span class="dv">3</span><span class="ot">   ::</span> <span class="dt">Expr</span> <span class="co">-- 1 * 2 + 3</span></a>
<a class="sourceLine" id="cb19-15" data-line-number="15"><span class="dv">1</span> <span class="fu">*</span> (<span class="dv">2</span> <span class="fu">+</span> <span class="dv">3</span>)<span class="ot"> ::</span> <span class="dt">Expr</span> <span class="co">-- 1 * (2 + 3)</span></a></code></pre></div>
<div id="refs" class="references">
<div id="ref-ramsey_unparsing_1998">
<p>Ramsey, Norman. 1998. â€œUnparsing Expressions With Prefix and Postfix Operators.â€ <em>Softwareâ€”Practice &amp; Experience</em> 28 (12): 1327â€“1356. <a href="http://www.cs.tufts.edu/%7Enr/pubs/unparse-abstract.html">http://www.cs.tufts.edu/%7Enr/pubs/unparse-abstract.html</a>.</p>
</div>
</div>
]]></description>
    <pubDate>Thu, 30 Mar 2017 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2017-03-30-fun-with-recursion-schemes.html</guid>
    <dc:creator>Donnacha OisÃ­n Kidney</dc:creator>
</item>
<item>
    <title>Constrained Applicatives</title>
    <link>https://doisinkidney.com/posts/2017-03-08-constrained-applicatives.html</link>
    <description><![CDATA[<div class="info">
    Posted on March  8, 2017
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Applicative.html">Applicative</a>
    
</div>

<p>In Haskell restricted monads are monads which canâ€™t contain every type. <code class="sourceCode haskell"><span class="dt">Set</span></code> is a good example. If you look in the documentation for <a href="https://hackage.haskell.org/package/containers-0.5.10.1/docs/Data-Set.html">Data.Set</a> youâ€™ll see several functions which correspond to functions in the Functor/Applicative/Monad typeclass hierarchy:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1">map<span class="ot"> ::</span> <span class="dt">Ord</span> b <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Set</span> a <span class="ot">-&gt;</span> <span class="dt">Set</span> b</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="ot">singleton ::</span> a <span class="ot">-&gt;</span> <span class="dt">Set</span> a</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">foldMap<span class="ot"> ::</span> <span class="dt">Ord</span> b <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Set</span> b) <span class="ot">-&gt;</span> <span class="dt">Set</span> a <span class="ot">-&gt;</span> <span class="dt">Set</span> b <span class="co">-- specialized</span></a></code></pre></div>
<p>Unfortunately, though, <code class="sourceCode haskell"><span class="dt">Set</span></code> canâ€™t conform to <code class="sourceCode haskell"><span class="dt">Functor</span></code>, because the signature of <code class="sourceCode haskell">fmap</code> looks like this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1">fmap<span class="ot"> ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</a></code></pre></div>
<p>It doesnâ€™t have an <code class="sourceCode haskell"><span class="dt">Ord</span></code> constraint.</p>
<p>This is annoying: when using <code class="sourceCode haskell"><span class="dt">Set</span></code>, lots of things have to be imported qualified, and you have to remember the slightly different names of extra functions like <code class="sourceCode haskell">map</code>. More importantly, youâ€™ve lost the ability to write generic code over <code class="sourceCode haskell"><span class="dt">Functor</span></code> or <code class="sourceCode haskell"><span class="dt">Monad</span></code> which will work on <code class="sourceCode haskell"><span class="dt">Set</span></code>.</p>
<p>There are a number of ways to get around this problem. <a href="http://okmij.org/ftp/Haskell/set-monad.html#set-cps">Here</a>, an approach using reflection-reification is explored. These are the types involved:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">SetC</span> a <span class="fu">=</span> </a>
<a class="sourceLine" id="cb3-2" data-line-number="2">       <span class="dt">SetC</span>{<span class="ot">unSetC ::</span> forall r<span class="fu">.</span> <span class="dt">Ord</span> r <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Set</span> r) <span class="ot">-&gt;</span> <span class="dt">Set</span> r}</a>
<a class="sourceLine" id="cb3-3" data-line-number="3"></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="ot">reifySet ::</span> <span class="dt">Ord</span> r <span class="ot">=&gt;</span> <span class="dt">SetC</span> r <span class="ot">-&gt;</span> <span class="dt">Set</span> r</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">reifySet m <span class="fu">=</span> unSetC m singleton</a>
<a class="sourceLine" id="cb3-6" data-line-number="6"></a>
<a class="sourceLine" id="cb3-7" data-line-number="7"><span class="ot">reflectSet ::</span> <span class="dt">Ord</span> r <span class="ot">=&gt;</span> <span class="dt">Set</span> r <span class="ot">-&gt;</span> <span class="dt">SetC</span> r</a>
<a class="sourceLine" id="cb3-8" data-line-number="8">reflectSet s <span class="fu">=</span> <span class="dt">SetC</span> <span class="fu">$</span> \k <span class="ot">-&gt;</span> S.foldr (\x r <span class="ot">-&gt;</span> k x <span class="ot">`union`</span> r) S.empty s</a></code></pre></div>
<p><code class="sourceCode haskell"><span class="dt">SetC</span></code> is just <code class="sourceCode haskell"><span class="dt">Cont</span></code> in disguise. In fact, we can generalize this pattern, using Constraint Kinds:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">FreeT</span> c m a <span class="fu">=</span> </a>
<a class="sourceLine" id="cb4-2" data-line-number="2">       <span class="dt">FreeT</span> {<span class="ot"> runFreeT ::</span> forall r<span class="fu">.</span> c r <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m r) <span class="ot">-&gt;</span> m r}</a>
<a class="sourceLine" id="cb4-3" data-line-number="3"></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="ot">reifySet ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">FreeT</span> <span class="dt">Ord</span> <span class="dt">Set</span> a <span class="ot">-&gt;</span> <span class="dt">Set</span> a</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">reifySet m <span class="fu">=</span> runFreeT m singleton</a>
<a class="sourceLine" id="cb4-6" data-line-number="6"></a>
<a class="sourceLine" id="cb4-7" data-line-number="7"><span class="ot">reflectSet ::</span> <span class="dt">Set</span> r <span class="ot">-&gt;</span> <span class="dt">FreeT</span> <span class="dt">Ord</span> <span class="dt">Set</span> r</a>
<a class="sourceLine" id="cb4-8" data-line-number="8">reflectSet s <span class="fu">=</span> <span class="dt">FreeT</span> <span class="fu">$</span> \k <span class="ot">-&gt;</span> S.foldr (\x r <span class="ot">-&gt;</span> k x <span class="ot">`union`</span> r) S.empty s</a></code></pre></div>
<p><code class="sourceCode haskell"><span class="dt">FreeT</span></code> looks an <em>awful lot</em> like <code class="sourceCode haskell"><span class="dt">ContT</span></code> by now. The type has some other interesting applications, though. For instance, this type:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">type</span> <span class="dt">FM</span> <span class="fu">=</span> <span class="dt">FreeT</span> <span class="dt">Monoid</span> <span class="dt">Identity</span></a></code></pre></div>
<p>Is the free monoid. If we use a transformers-style type synonym, the naming becomes even nicer:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Free</span> c <span class="fu">=</span> <span class="dt">FreeT</span> c <span class="dt">Identity</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="ot">runFree ::</span> c r <span class="ot">=&gt;</span> <span class="dt">Free</span> c a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">runFree xs f <span class="fu">=</span> runIdentity (runFreeT xs (pure <span class="fu">.</span> f))</a>
<a class="sourceLine" id="cb6-5" data-line-number="5"></a>
<a class="sourceLine" id="cb6-6" data-line-number="6"><span class="kw">instance</span> <span class="dt">Foldable</span> (<span class="dt">Free</span> <span class="dt">Monoid</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-7" data-line-number="7">  foldMap <span class="fu">=</span> flip runFree</a></code></pre></div>
<p>Check out <a href="https://hackage.haskell.org/package/free-functors">this package</a> for an implementation of the non-transformer <code class="sourceCode haskell"><span class="dt">Free</span></code>.</p>
<h2 id="different-classes">Different Classes</h2>
<p>This is still unsatisfying, though. Putting annotations around your code feels inelegant. The next solution is to replace the monad class altogether with our own, and turn on <code class="sourceCode haskell"><span class="fu">-</span><span class="dt">XRebindableSyntax</span></code>. There are a few ways to design this new class. One option is to use <a href="http://okmij.org/ftp/Haskell/types.html#restricted-datatypes">multi-parameter type classes</a>. Another solution is with an associated type:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  <span class="kw">type</span> <span class="dt">Suitable</span> f<span class="ot"> a ::</span> <span class="dt">Constraint</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="ot">  fmap ::</span> <span class="dt">Suitable</span> f b <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</a></code></pre></div>
<p>This is similar to the approach taken in the <a href="https://hackage.haskell.org/package/rmonad">rmonad</a> library, except that library doesnâ€™t use constraint kinds (they werenâ€™t available when the library was made), so it has to make do with a <code class="sourceCode haskell"><span class="dt">Suitable</span></code> class. Also, the signature for <code class="sourceCode haskell">fmap</code> in rmonad is:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">fmap<span class="ot"> ::</span> (<span class="dt">Suitable</span> f a, <span class="dt">Suitable</span> f b) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</a></code></pre></div>
<p>I donâ€™t want to constrain <code class="sourceCode haskell">a</code>: I figure if you can get something <em>into</em> your monad, it <em>must</em> be suitable. And I really want to reduce the syntactic overhead of writing extra types next to your functions.</p>
<p>Thereâ€™s also the <a href="https://hackage.haskell.org/package/supermonad-0.1/docs/Control-Supermonad-Constrained.html">supermonad</a> library out there which is much more general than any of these examples: it supports indexed monads as well as constrained.</p>
<p>Anyway,<code class="sourceCode haskell"><span class="dt">Monad</span></code> is defined similarly to <code class="sourceCode haskell"><span class="dt">Functor</span></code>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Functor</span> m <span class="ot">=&gt;</span> <span class="dt">Monad</span> m <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="ot">  return ::</span> <span class="dt">Suitable</span> m a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> m a</a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="ot">  (&gt;&gt;=) ::</span> <span class="dt">Suitable</span> m b <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b</a></code></pre></div>
<p>Again, I want to minimize the use of <code class="sourceCode haskell"><span class="dt">Suitable</span></code>, so for <code class="sourceCode haskell"><span class="fu">&gt;&gt;=</span></code> thereâ€™s only a constraint on <code class="sourceCode haskell">b</code>.</p>
<p>Finally, hereâ€™s the <code class="sourceCode haskell"><span class="dt">Set</span></code> instance:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">    <span class="kw">type</span> <span class="dt">Suitable</span> <span class="dt">Set</span> a <span class="fu">=</span> <span class="dt">Ord</span> a</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">    fmap <span class="fu">=</span> Set.map</a></code></pre></div>
<h2 id="monomorphic">Monomorphic</h2>
<p>With equality constraints, you can actually make <em>monomorphic</em> containers conform to these classes (or, at least, wrappers around them).</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2"></a>
<a class="sourceLine" id="cb11-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Text</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4">  <span class="dt">Text</span><span class="ot"> ::</span> <span class="dt">Text.Text</span> <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="dt">Char</span></a>
<a class="sourceLine" id="cb11-5" data-line-number="5"></a>
<a class="sourceLine" id="cb11-6" data-line-number="6"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Text</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-7" data-line-number="7">  <span class="kw">type</span> <span class="dt">Suitable</span> <span class="dt">Text</span> a <span class="fu">=</span> a <span class="fu">~</span> <span class="dt">Char</span></a>
<a class="sourceLine" id="cb11-8" data-line-number="8">  fmap f (<span class="dt">Text</span> xs) <span class="fu">=</span> <span class="dt">Text</span> (Text.map f xs)</a></code></pre></div>
<p>This pattern can be generalized with some more GADT magic:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Monomorphic</span> xs a b <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">        <span class="dt">Monomorphic</span><span class="ot"> ::</span> (a <span class="fu">~</span> b) <span class="ot">=&gt;</span> xs <span class="ot">-&gt;</span> <span class="dt">Monomorphic</span> xs a b</a>
<a class="sourceLine" id="cb12-3" data-line-number="3"></a>
<a class="sourceLine" id="cb12-4" data-line-number="4"><span class="kw">instance</span> (<span class="dt">MonoFunctor</span> xs, a <span class="fu">~</span> <span class="dt">Element</span> xs) <span class="ot">=&gt;</span> <span class="dt">Functor</span> (<span class="dt">Monomorphic</span> xs a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5">  <span class="kw">type</span> <span class="dt">Suitable</span> (<span class="dt">Monomorphic</span> xs a) b <span class="fu">=</span> a <span class="fu">~</span> b</a>
<a class="sourceLine" id="cb12-6" data-line-number="6">  fmap f (<span class="dt">Monomorphic</span> xs) <span class="fu">=</span> <span class="dt">Monomorphic</span> (omap f xs)</a></code></pre></div>
<p>Where <code class="sourceCode haskell">omap</code> comes from the <a href="https://hackage.haskell.org/package/mono-traversable">mono-traversable</a> package. You could go a little further, to <code class="sourceCode haskell"><span class="dt">Foldable</span></code>:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">instance</span> (<span class="dt">MonoFoldable</span> xs, element <span class="fu">~</span> <span class="dt">Element</span> xs) <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">         <span class="dt">Foldable</span> (<span class="dt">Monomorphic</span> xs element) <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">    foldr f b (<span class="dt">Monomorphic</span> xs) <span class="fu">=</span> ofoldr f b xs</a>
<a class="sourceLine" id="cb13-4" data-line-number="4">    foldMap f (<span class="dt">Monomorphic</span> xs) <span class="fu">=</span> ofoldMap f xs</a>
<a class="sourceLine" id="cb13-5" data-line-number="5">    foldl&#39; f b (<span class="dt">Monomorphic</span> xs) <span class="fu">=</span> ofoldl&#39; f b xs</a>
<a class="sourceLine" id="cb13-6" data-line-number="6">    toList (<span class="dt">Monomorphic</span> xs) <span class="fu">=</span> otoList xs</a>
<a class="sourceLine" id="cb13-7" data-line-number="7">    null (<span class="dt">Monomorphic</span> xs) <span class="fu">=</span> onull xs</a>
<a class="sourceLine" id="cb13-8" data-line-number="8">    length (<span class="dt">Monomorphic</span> xs) <span class="fu">=</span> olength xs</a>
<a class="sourceLine" id="cb13-9" data-line-number="9">    foldr1 f (<span class="dt">Monomorphic</span> xs) <span class="fu">=</span> ofoldr1Ex f xs</a>
<a class="sourceLine" id="cb13-10" data-line-number="10">    elem x (<span class="dt">Monomorphic</span> xs) <span class="fu">=</span> oelem x xs</a>
<a class="sourceLine" id="cb13-11" data-line-number="11">    maximum (<span class="dt">Monomorphic</span> xs) <span class="fu">=</span> maximumEx xs</a>
<a class="sourceLine" id="cb13-12" data-line-number="12">    minimum (<span class="dt">Monomorphic</span> xs) <span class="fu">=</span> minimumEx xs</a>
<a class="sourceLine" id="cb13-13" data-line-number="13">    sum (<span class="dt">Monomorphic</span> xs) <span class="fu">=</span> osum xs</a>
<a class="sourceLine" id="cb13-14" data-line-number="14">    product (<span class="dt">Monomorphic</span> xs) <span class="fu">=</span> oproduct xs</a></code></pre></div>
<h2 id="back-to-normal">Back to normal</h2>
<p>Changing the <code class="sourceCode haskell"><span class="dt">FreeT</span></code> type above a little, we can go back to normal functors and monads, and write more general reify and reflect functions:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">FreeT</span> m a <span class="fu">=</span> </a>
<a class="sourceLine" id="cb14-2" data-line-number="2">       <span class="dt">FreeT</span> {<span class="ot"> runFreeT ::</span> forall r<span class="fu">.</span> <span class="dt">Suitable</span> m r <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m r) <span class="ot">-&gt;</span> m r}</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">       </a>
<a class="sourceLine" id="cb14-4" data-line-number="4"><span class="ot">reify ::</span> (<span class="dt">Monad</span> m, <span class="dt">Suitable</span> m a) <span class="ot">=&gt;</span> <span class="dt">FreeT</span> m a <span class="ot">-&gt;</span> m a</a>
<a class="sourceLine" id="cb14-5" data-line-number="5">reify <span class="fu">=</span> flip runFreeT return</a>
<a class="sourceLine" id="cb14-6" data-line-number="6"></a>
<a class="sourceLine" id="cb14-7" data-line-number="7"><span class="ot">reflect ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> <span class="dt">FreeT</span> m a</a>
<a class="sourceLine" id="cb14-8" data-line-number="8">reflect x <span class="fu">=</span> <span class="dt">FreeT</span> (x <span class="fu">&gt;&gt;=</span>)</a></code></pre></div>
<p>So now our types, when wrapped, can conform to the Preludeâ€™s <code class="sourceCode haskell"><span class="dt">Functor</span></code>. It would be nice if this type could be written like so:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="ot">reify ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">FreeT</span> (<span class="dt">Suitable</span> m) m a <span class="ot">-&gt;</span> m a</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">reify <span class="fu">=</span> flip runFreeT return</a>
<a class="sourceLine" id="cb15-3" data-line-number="3"></a>
<a class="sourceLine" id="cb15-4" data-line-number="4"><span class="ot">reflect ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> <span class="dt">FreeT</span> (<span class="dt">Suitable</span> m) m a</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">reflect x <span class="fu">=</span> <span class="dt">FreeT</span> (x <span class="fu">&gt;&gt;=</span>)</a></code></pre></div>
<p>But unfortunately type families cannot be partially applied.</p>
<h2 id="applicatives">Applicatives</h2>
<p>The classes above arenâ€™t very modern: theyâ€™re missing applicative. This one is tricky:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Applicative</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2"><span class="ot">  pure ::</span> <span class="dt">Suitable</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb16-3" data-line-number="3"><span class="ot">  (&lt;*&gt;) ::</span> <span class="dt">Suitable</span> f b <span class="ot">=&gt;</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</a></code></pre></div>
<p>The issue is <code class="sourceCode haskell">f (a <span class="ot">-&gt;</span> b)</code>. Thereâ€™s no <em>way</em> youâ€™re getting some type like that into <code class="sourceCode haskell"><span class="dt">Set</span></code>. This means that <code class="sourceCode haskell"><span class="fu">&lt;*&gt;</span></code> is effectively useless. No problem, you think: define <code class="sourceCode haskell">liftA2</code> instead:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Applicative</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2"><span class="ot">  pure ::</span> <span class="dt">Suitable</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb17-3" data-line-number="3"><span class="ot">  liftA2 ::</span> <span class="dt">Suitable</span> f c <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f c</a>
<a class="sourceLine" id="cb17-4" data-line-number="4"></a>
<a class="sourceLine" id="cb17-5" data-line-number="5"><span class="ot">(&lt;*&gt;) ::</span> (<span class="dt">Applicative</span> f, <span class="dt">Suitable</span> f b) <span class="ot">=&gt;</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</a>
<a class="sourceLine" id="cb17-6" data-line-number="6">(<span class="fu">&lt;*&gt;</span>) <span class="fu">=</span> liftA2 (<span class="fu">$</span>)</a></code></pre></div>
<p>Great! Now we can use it with set. However, thereâ€™s no way (that I can see) to define the other lift functions: <code class="sourceCode haskell">liftA3</code>, etc. Of course, if <code class="sourceCode haskell"><span class="fu">&gt;&gt;=</span></code> is available, itâ€™s as simple as:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1">liftA3 f xs ys zs <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2">  x <span class="ot">&lt;-</span> xs</a>
<a class="sourceLine" id="cb18-3" data-line-number="3">  y <span class="ot">&lt;-</span> ys</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">  z <span class="ot">&lt;-</span> zs</a>
<a class="sourceLine" id="cb18-5" data-line-number="5">  pure (f x y z)</a></code></pre></div>
<p>But now we canâ€™t define it for non-monadic applicatives (square matrices, ZipLists, etc.). This also forces us to use <code class="sourceCode haskell"><span class="fu">&gt;&gt;=</span></code> when <code class="sourceCode haskell"><span class="fu">&lt;*&gt;</span></code> <a href="https://simonmar.github.io/posts/2015-10-20-Fun-With-Haxl-1.html">may have been more efficient</a>.</p>
<p>The functions weâ€™re interested in defining look like this:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="ot">liftA2 ::</span> <span class="dt">Suitable</span> f c <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f c</a>
<a class="sourceLine" id="cb19-2" data-line-number="2"><span class="ot">liftA3 ::</span> <span class="dt">Suitable</span> f d <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f c <span class="ot">-&gt;</span> f d</a>
<a class="sourceLine" id="cb19-3" data-line-number="3"><span class="ot">liftA4 ::</span> <span class="dt">Suitable</span> f e <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> d <span class="ot">-&gt;</span> e) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f c <span class="ot">-&gt;</span> f d <span class="ot">-&gt;</span> f e</a></code></pre></div>
<p>Thereâ€™s a clear pattern, but no obvious way to abstract over it. Type-level shenanigans to the rescue!</p>
<p>The pattern might be expressed like this:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="ot">liftA ::</span> <span class="dt">Func</span> args <span class="ot">-&gt;</span> <span class="dt">Func</span> lifted args</a></code></pre></div>
<p>We can store these types as heterogeneous lists:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:-</span></a>
<a class="sourceLine" id="cb21-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Vect</span> xs <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-3" data-line-number="3">  <span class="dt">Nil</span><span class="ot">  ::</span> <span class="dt">Vect</span> <span class="ch">&#39;[]</span></a>
<a class="sourceLine" id="cb21-4" data-line-number="4"><span class="ot">  (:-) ::</span> x <span class="ot">-&gt;</span> <span class="dt">Vect</span> xs <span class="ot">-&gt;</span> <span class="dt">Vect</span> (x <span class="ch">&#39;: xs)</span></a>
<a class="sourceLine" id="cb21-5" data-line-number="5"></a>
<a class="sourceLine" id="cb21-6" data-line-number="6"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:*</span></a>
<a class="sourceLine" id="cb21-7" data-line-number="7"><span class="kw">data</span> <span class="dt">AppVect</span> f xs <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-8" data-line-number="8">  <span class="dt">NilA</span><span class="ot"> ::</span> <span class="dt">AppVect</span> f <span class="ch">&#39;[]</span></a>
<a class="sourceLine" id="cb21-9" data-line-number="9"><span class="ot">  (:*) ::</span> f x <span class="ot">-&gt;</span> <span class="dt">AppVect</span> f xs <span class="ot">-&gt;</span> <span class="dt">AppVect</span> f (x <span class="ch">&#39;: xs)</span></a></code></pre></div>
<p>And <code class="sourceCode haskell">liftA</code> can be represented like this:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1">liftA</a>
<a class="sourceLine" id="cb22-2" data-line-number="2"><span class="ot">    ::</span> <span class="dt">Suitable</span> f b</a>
<a class="sourceLine" id="cb22-3" data-line-number="3">    <span class="ot">=&gt;</span> (<span class="dt">Vect</span> xs <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">AppVect</span> f xs <span class="ot">-&gt;</span> f b</a>
<a class="sourceLine" id="cb22-4" data-line-number="4"></a>
<a class="sourceLine" id="cb22-5" data-line-number="5">liftA2</a>
<a class="sourceLine" id="cb22-6" data-line-number="6"><span class="ot">    ::</span> <span class="dt">Suitable</span> f c</a>
<a class="sourceLine" id="cb22-7" data-line-number="7">    <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f c</a>
<a class="sourceLine" id="cb22-8" data-line-number="8">liftA2 f xs ys <span class="fu">=</span></a>
<a class="sourceLine" id="cb22-9" data-line-number="9">    liftA</a>
<a class="sourceLine" id="cb22-10" data-line-number="10">        (\(x <span class="fu">:-</span> y <span class="fu">:-</span> <span class="dt">Nil</span>) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb22-11" data-line-number="11">              f x y)</a>
<a class="sourceLine" id="cb22-12" data-line-number="12">        (xs <span class="fu">:*</span> ys <span class="fu">:*</span> <span class="dt">NilA</span>)</a>
<a class="sourceLine" id="cb22-13" data-line-number="13"></a>
<a class="sourceLine" id="cb22-14" data-line-number="14">liftA3</a>
<a class="sourceLine" id="cb22-15" data-line-number="15"><span class="ot">    ::</span> <span class="dt">Suitable</span> f d</a>
<a class="sourceLine" id="cb22-16" data-line-number="16">    <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f c <span class="ot">-&gt;</span> f d</a>
<a class="sourceLine" id="cb22-17" data-line-number="17">liftA3 f xs ys zs <span class="fu">=</span></a>
<a class="sourceLine" id="cb22-18" data-line-number="18">    liftA</a>
<a class="sourceLine" id="cb22-19" data-line-number="19">        (\(x <span class="fu">:-</span> y <span class="fu">:-</span> z <span class="fu">:-</span> <span class="dt">Nil</span>) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb22-20" data-line-number="20">              f x y z)</a>
<a class="sourceLine" id="cb22-21" data-line-number="21">        (xs <span class="fu">:*</span> ys <span class="fu">:*</span> zs <span class="fu">:*</span> <span class="dt">NilA</span>)</a></code></pre></div>
<p>Cool! For unrestricted applicatives, we can define <code class="sourceCode haskell">liftA</code> in terms of <code class="sourceCode haskell"><span class="fu">&lt;*&gt;</span></code>:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="ot">liftAP ::</span> (<span class="dt">Prelude.Applicative</span> f) </a>
<a class="sourceLine" id="cb23-2" data-line-number="2">       <span class="ot">=&gt;</span> (<span class="dt">Vect</span> xs <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (<span class="dt">AppVect</span> f xs <span class="ot">-&gt;</span> f b)</a>
<a class="sourceLine" id="cb23-3" data-line-number="3">liftAP f <span class="dt">NilA</span> <span class="fu">=</span> Prelude.pure (f <span class="dt">Nil</span>)</a>
<a class="sourceLine" id="cb23-4" data-line-number="4">liftAP f (x <span class="fu">:*</span> <span class="dt">NilA</span>) </a>
<a class="sourceLine" id="cb23-5" data-line-number="5">  <span class="fu">=</span> Prelude.fmap (f <span class="fu">.</span> (<span class="fu">:-</span><span class="dt">Nil</span>)) x</a>
<a class="sourceLine" id="cb23-6" data-line-number="6">liftAP f (x <span class="fu">:*</span> xs) </a>
<a class="sourceLine" id="cb23-7" data-line-number="7">  <span class="fu">=</span>  ((f <span class="fu">.</span>) <span class="fu">.</span> (<span class="fu">:-</span>)) <span class="fu">Prelude.&lt;$&gt;</span> x <span class="fu">Prelude.&lt;*&gt;</span> liftAP id xs</a></code></pre></div>
<p>And for types with a monad instance, we can define it in terms of <code class="sourceCode haskell"><span class="fu">&gt;&gt;=</span></code>:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="ot">liftAM ::</span> (<span class="dt">Monad</span> f, <span class="dt">Suitable</span> f b) </a>
<a class="sourceLine" id="cb24-2" data-line-number="2">       <span class="ot">=&gt;</span> (<span class="dt">Vect</span> xs <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (<span class="dt">AppVect</span> f xs <span class="ot">-&gt;</span> f b)</a>
<a class="sourceLine" id="cb24-3" data-line-number="3">liftAM f <span class="dt">NilA</span> <span class="fu">=</span> pure (f <span class="dt">Nil</span>)</a>
<a class="sourceLine" id="cb24-4" data-line-number="4">liftAM f (x <span class="fu">:*</span> <span class="dt">NilA</span>) <span class="fu">=</span> fmap (f <span class="fu">.</span> (<span class="fu">:-</span><span class="dt">Nil</span>)) x</a>
<a class="sourceLine" id="cb24-5" data-line-number="5">liftAM f (x <span class="fu">:*</span> xs) <span class="fu">=</span> x <span class="fu">&gt;&gt;=</span> \y <span class="ot">-&gt;</span> liftAM (f <span class="fu">.</span> (y<span class="fu">:-</span>)) xs</a></code></pre></div>
<h2 id="efficiency">Efficiency</h2>
<p>This approach is <em>really</em> slow. Every function wraps up its arguments in a <code class="sourceCode haskell"><span class="dt">Vect</span></code>, and itâ€™s just generally awful.</p>
<p>What about <em>not</em> wrapping up the function? Type families can help here:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">FunType</span> (<span class="ot">xs ::</span> [<span class="fu">*</span>]) (<span class="ot">y ::</span> <span class="fu">*</span>)<span class="ot"> ::</span> <span class="fu">*</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-2" data-line-number="2">  <span class="dt">FunType</span> <span class="ch">&#39;[] y = y</span></a>
<a class="sourceLine" id="cb25-3" data-line-number="3">  <span class="dt">FunType</span> (x <span class="ch">&#39;: xs) y = x -&gt; FunType xs y</span></a></code></pre></div>
<p>It gets really difficult to define <code class="sourceCode haskell">liftA</code> using <code class="sourceCode haskell"><span class="fu">&lt;*&gt;</span></code> now, though. <code class="sourceCode haskell">liftAM</code>, on the other hand, is a breeze:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="ot">liftAM ::</span> <span class="dt">Monad</span> f <span class="ot">=&gt;</span> <span class="dt">FunType</span> xs a <span class="ot">-&gt;</span> <span class="dt">AppVect</span> f xs <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb26-2" data-line-number="2">liftAM f <span class="dt">Nil</span> <span class="fu">=</span> pure f</a>
<a class="sourceLine" id="cb26-3" data-line-number="3">liftAM f (x <span class="fu">:&lt;</span> xs) <span class="fu">=</span> x <span class="fu">&gt;&gt;=</span> \y <span class="ot">-&gt;</span> liftAM (f y) xs</a></code></pre></div>
<p>And no vector constructors on the right of the bind!</p>
<p>Still, no decent definition using <code class="sourceCode haskell"><span class="fu">&lt;*&gt;</span></code>. The problem is that weâ€™re using a cons-list to represent a functionâ€™s arguments, but <code class="sourceCode haskell"><span class="fu">&lt;*&gt;</span></code> is left-associative, so it builds up arguments as a snoc list. Lets try using a snoc-list as the type family:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="kw">infixl</span> <span class="dv">5</span> <span class="fu">:&gt;</span></a>
<a class="sourceLine" id="cb27-2" data-line-number="2"><span class="kw">data</span> <span class="dt">AppVect</span> f xs <span class="kw">where</span></a>
<a class="sourceLine" id="cb27-3" data-line-number="3">  <span class="dt">Nil</span><span class="ot"> ::</span> <span class="dt">AppVect</span> f <span class="ch">&#39;[]</span></a>
<a class="sourceLine" id="cb27-4" data-line-number="4"><span class="ot">  (:&gt;) ::</span> <span class="dt">AppVect</span> f xs <span class="ot">-&gt;</span> f x <span class="ot">-&gt;</span> <span class="dt">AppVect</span> f (x <span class="ch">&#39;: xs)</span></a>
<a class="sourceLine" id="cb27-5" data-line-number="5"></a>
<a class="sourceLine" id="cb27-6" data-line-number="6"><span class="kw">type</span> family <span class="dt">FunType</span> (<span class="ot">xs ::</span> [<span class="fu">*</span>]) (<span class="ot">y ::</span> <span class="fu">*</span>)<span class="ot"> ::</span> <span class="fu">*</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb27-7" data-line-number="7">  <span class="dt">FunType</span> <span class="ch">&#39;[] y = y</span></a>
<a class="sourceLine" id="cb27-8" data-line-number="8">  <span class="dt">FunType</span> (x <span class="ch">&#39;: xs) y = FunType xs (x -&gt; y)</span></a>
<a class="sourceLine" id="cb27-9" data-line-number="9"></a>
<a class="sourceLine" id="cb27-10" data-line-number="10">liftA</a>
<a class="sourceLine" id="cb27-11" data-line-number="11"><span class="ot">    ::</span> <span class="dt">Suitable</span> f a</a>
<a class="sourceLine" id="cb27-12" data-line-number="12">    <span class="ot">=&gt;</span> <span class="dt">FunType</span> xs a <span class="ot">-&gt;</span> <span class="dt">AppVect</span> f xs <span class="ot">-&gt;</span> f a</a></code></pre></div>
<p><code class="sourceCode haskell">liftAP</code> now gets a natural definition:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1"><span class="ot">liftAP ::</span> <span class="dt">Prelude.Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">FunType</span> xs a <span class="ot">-&gt;</span> <span class="dt">AppVect</span> f xs <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb28-2" data-line-number="2">liftAP f <span class="dt">Nil</span> <span class="fu">=</span> Prelude.pure f</a>
<a class="sourceLine" id="cb28-3" data-line-number="3">liftAP f (<span class="dt">Nil</span> <span class="fu">:&gt;</span> xs) <span class="fu">=</span> Prelude.fmap f xs</a>
<a class="sourceLine" id="cb28-4" data-line-number="4">liftAP f (ys <span class="fu">:&gt;</span> xs) <span class="fu">=</span> liftAP f ys <span class="fu">Prelude.&lt;*&gt;</span> xs</a></code></pre></div>
<p>But what about <code class="sourceCode haskell">liftAM</code>? Itâ€™s much more difficult, fundamentally because <code class="sourceCode haskell"><span class="fu">&gt;&gt;=</span></code> builds up arguments as a cons-list. To convert between the two efficiently, we need to use the trick for reversing lists efficiently: build up the reversed list as you go.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" data-line-number="1"><span class="ot">liftAM ::</span> (<span class="dt">Monad</span> f, <span class="dt">Suitable</span> f a) <span class="ot">=&gt;</span> <span class="dt">FunType</span> xs a <span class="ot">-&gt;</span> <span class="dt">AppVect</span> f xs <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb29-2" data-line-number="2">liftAM <span class="fu">=</span> go pure <span class="kw">where</span></a>
<a class="sourceLine" id="cb29-3" data-line-number="3"><span class="ot">  go ::</span> (<span class="dt">Suitable</span> f b, <span class="dt">Monad</span> f) </a>
<a class="sourceLine" id="cb29-4" data-line-number="4">     <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> <span class="dt">FunType</span> xs a <span class="ot">-&gt;</span> <span class="dt">AppVect</span> f xs <span class="ot">-&gt;</span> f b</a>
<a class="sourceLine" id="cb29-5" data-line-number="5">  go f g <span class="dt">Nil</span> <span class="fu">=</span> f g</a>
<a class="sourceLine" id="cb29-6" data-line-number="6">  go f g (xs <span class="fu">:&gt;</span> x) <span class="fu">=</span> go (\c <span class="ot">-&gt;</span> x <span class="fu">&gt;&gt;=</span> f <span class="fu">.</span> c) g xs</a></code></pre></div>
<p>Using these definitions, we can make <code class="sourceCode haskell"><span class="dt">Set</span></code>, <code class="sourceCode haskell"><span class="dt">Text</span></code>, and all the rest of them applicatives, while preserving the applicative operations. Also, from my preliminary testing, there seems to be <em>no</em> overhead in using these new definitions for <code class="sourceCode haskell"><span class="fu">&lt;*&gt;</span></code>.</p>
<h2 id="normalized-embedding">Normalized Embedding</h2>
<p>In <span class="citation" data-cites="sculthorpe_constrained-monad_2013">Sculthorpe et al. (<a href="#ref-sculthorpe_constrained-monad_2013">2013</a>)</span>, thereâ€™s discussion of this type:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="kw">data</span> <span class="dt">NM</span><span class="ot"> ::</span> (<span class="fu">*</span> <span class="ot">-&gt;</span> <span class="dt">Constraint</span>) <span class="ot">-&gt;</span> (<span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-2" data-line-number="2">  <span class="dt">Return</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">NM</span> c t a</a>
<a class="sourceLine" id="cb30-3" data-line-number="3">  <span class="dt">Bind</span><span class="ot"> ::</span> c x <span class="ot">=&gt;</span> t x <span class="ot">-&gt;</span> (x <span class="ot">-&gt;</span> <span class="dt">NM</span> c t a) <span class="ot">-&gt;</span> <span class="dt">NM</span> c t a</a></code></pre></div>
<p>This type allows constrained monads to become normal monads. It can be used for the same purpose as the <code class="sourceCode haskell"><span class="dt">FreeT</span></code> type from above. In the paper, the free type is called <code class="sourceCode haskell"><span class="dt">RCodT</span></code>.</p>
<p>One way to look at the type is as a concrete representation of the monad class, with each method being a constructor.</p>
<p>You might wonder if there are similar constructs for functor and applicative. Functor is simple:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" data-line-number="1"><span class="kw">data</span> <span class="dt">NF</span><span class="ot"> ::</span> (<span class="fu">*</span> <span class="ot">-&gt;</span> <span class="dt">Constraint</span>) <span class="ot">-&gt;</span> (<span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb31-2" data-line-number="2">  <span class="dt">FMap</span><span class="ot"> ::</span> c x <span class="ot">=&gt;</span> (x <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> t x <span class="ot">-&gt;</span> <span class="dt">NF</span> c t a</a></code></pre></div>
<p>Again, this can conform to functor (and <em>only</em> functor), and can be interpreted when the final type is <code class="sourceCode haskell"><span class="dt">Suitable</span></code>.</p>
<p>Like above, it has a continuation version, <a href="https://hackage.haskell.org/package/kan-extensions-5.0.1/docs/Data-Functor-Yoneda.html">Yoneda</a>.</p>
<p>For applicatives, though, the situation is different. In the paper, they werenâ€™t able to define a transformer for applicatives that could be interpreted in some restricted applicative. I needed one because I wanted to use <code class="sourceCode haskell"><span class="fu">-</span><span class="dt">XApplicativeDo</span></code> notation: the desugaring uses <code class="sourceCode haskell"><span class="fu">&lt;*&gt;</span></code>, not the <code class="sourceCode haskell">liftAn</code> functions, so I wanted to construct a free applicative using <code class="sourceCode haskell"><span class="fu">&lt;*&gt;</span></code>, and run it using the lift functions. What I managed to cobble to gether doesnâ€™t <em>really</em> solve the problem, but it works for <code>-XApplicativeDo</code>!</p>
<p>The key with a lot of this was realizing that <code class="sourceCode haskell"><span class="fu">&lt;*&gt;</span></code> is <em>snoc</em>, not cons. Using a <a href="https://ro-che.info/articles/2013-03-31-flavours-of-free-applicative-functors">free applicative</a>:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Free</span> f a <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-2" data-line-number="2">  <span class="dt">Pure</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Free</span> f a</a>
<a class="sourceLine" id="cb32-3" data-line-number="3">  <span class="dt">Ap</span><span class="ot"> ::</span> <span class="dt">Free</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Free</span> f b</a>
<a class="sourceLine" id="cb32-4" data-line-number="4"></a>
<a class="sourceLine" id="cb32-5" data-line-number="5"><span class="kw">instance</span> <span class="dt">Prelude.Functor</span> (<span class="dt">Free</span> f) <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-6" data-line-number="6">  fmap f (<span class="dt">Pure</span> a) <span class="fu">=</span> <span class="dt">Pure</span> (f a)</a>
<a class="sourceLine" id="cb32-7" data-line-number="7">  fmap f (<span class="dt">Ap</span> x y) <span class="fu">=</span> <span class="dt">Ap</span> ((f <span class="fu">.</span>) <span class="fu">Prelude.&lt;$&gt;</span> x) y</a>
<a class="sourceLine" id="cb32-8" data-line-number="8"></a>
<a class="sourceLine" id="cb32-9" data-line-number="9"><span class="kw">instance</span> <span class="dt">Prelude.Applicative</span> (<span class="dt">Free</span> f) <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-10" data-line-number="10">  pure <span class="fu">=</span> <span class="dt">Pure</span></a>
<a class="sourceLine" id="cb32-11" data-line-number="11">  <span class="dt">Pure</span> f <span class="fu">&lt;*&gt;</span> y <span class="fu">=</span> Prelude.fmap f y</a>
<a class="sourceLine" id="cb32-12" data-line-number="12">  <span class="dt">Ap</span> x y <span class="fu">&lt;*&gt;</span> z <span class="fu">=</span> <span class="dt">Ap</span> (flip <span class="fu">Prelude.&lt;$&gt;</span> x <span class="fu">Prelude.&lt;*&gt;</span> z) y</a></code></pre></div>
<p>This type can conform to <code class="sourceCode haskell"><span class="dt">Applicative</span></code> and <code class="sourceCode haskell"><span class="dt">Functor</span></code> no problem. And all it needs to turn back into a constrained applicative is for the outer type to be suitable:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" data-line-number="1"><span class="ot">lift ::</span> f a <span class="ot">-&gt;</span> <span class="dt">Free</span> f a</a>
<a class="sourceLine" id="cb33-2" data-line-number="2">lift <span class="fu">=</span> <span class="dt">Ap</span> (<span class="dt">Pure</span> id)</a>
<a class="sourceLine" id="cb33-3" data-line-number="3"></a>
<a class="sourceLine" id="cb33-4" data-line-number="4">lower</a>
<a class="sourceLine" id="cb33-5" data-line-number="5"><span class="ot">    ::</span> forall f a c<span class="fu">.</span></a>
<a class="sourceLine" id="cb33-6" data-line-number="6">       <span class="dt">Free</span> f a</a>
<a class="sourceLine" id="cb33-7" data-line-number="7">    <span class="ot">-&gt;</span> (forall xs<span class="fu">.</span> <span class="dt">FunType</span> xs a <span class="ot">-&gt;</span> <span class="dt">AppVect</span> f xs <span class="ot">-&gt;</span> f c)</a>
<a class="sourceLine" id="cb33-8" data-line-number="8">    <span class="ot">-&gt;</span> f c</a>
<a class="sourceLine" id="cb33-9" data-line-number="9">lower (<span class="dt">Pure</span> x) f <span class="fu">=</span> f x <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb33-10" data-line-number="10">lower (<span class="dt">Ap</span> fs<span class="ot"> x ::</span> <span class="dt">Free</span> f a) f <span class="fu">=</span></a>
<a class="sourceLine" id="cb33-11" data-line-number="11">    lower fs (\ft av <span class="ot">-&gt;</span> f ft (av <span class="fu">:&gt;</span> x))</a>
<a class="sourceLine" id="cb33-12" data-line-number="12"></a>
<a class="sourceLine" id="cb33-13" data-line-number="13">lowerConstrained</a>
<a class="sourceLine" id="cb33-14" data-line-number="14"><span class="ot">    ::</span> (<span class="dt">Constrained.Applicative</span> f, <span class="dt">Suitable</span> f a)</a>
<a class="sourceLine" id="cb33-15" data-line-number="15">    <span class="ot">=&gt;</span> <span class="dt">Free</span> f a <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb33-16" data-line-number="16">lowerConstrained x <span class="fu">=</span> lower x liftA</a></code></pre></div>
<p>Thereâ€™s probably a more efficient way to encode it, though.</p>
<div id="refs" class="references">
<div id="ref-sculthorpe_constrained-monad_2013">
<p>Sculthorpe, Neil, Jan Bracker, George Giorgidze, and Andy Gill. 2013. â€œThe Constrained-monad Problem.â€ In <em>Proceedings of the 18th ACM SIGPLAN International Conference on Functional Programming</em>, 287â€“298. ICFP â€™13. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/2500365.2500602">10.1145/2500365.2500602</a>. <a href="http://ku-fpg.github.io/files/Sculthorpe-13-ConstrainedMonad.pdf" class="uri">http://ku-fpg.github.io/files/Sculthorpe-13-ConstrainedMonad.pdf</a>.</p>
</div>
</div>
]]></description>
    <pubDate>Wed, 08 Mar 2017 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2017-03-08-constrained-applicatives.html</guid>
    <dc:creator>Donnacha OisÃ­n Kidney</dc:creator>
</item>
<item>
    <title>Semirings</title>
    <link>https://doisinkidney.com/posts/2016-11-17-semirings-lhs.html</link>
    <description><![CDATA[<div class="info">
    Posted on November 17, 2016
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Semirings.html">Semirings</a>
    
</div>

<div class="sourceCode" id="cb1"><pre class="sourceCode haskell literate hidden_source"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving, TypeFamilies #-}</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="ot">{-# LANGUAGE DeriveFunctor, DeriveFoldable, DeriveTraversable #-}</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="ot">{-# LANGUAGE PatternSynonyms, ViewPatterns, LambdaCase #-}</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="ot">{-# LANGUAGE RankNTypes, FlexibleInstances, FlexibleContexts #-}</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="ot">{-# LANGUAGE OverloadedStrings, OverloadedLists, MonadComprehensions #-}</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="kw">module</span> <span class="dt">Semirings</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"></a>
<a class="sourceLine" id="cb1-9" data-line-number="9"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map.Strict</span> <span class="kw">as</span> <span class="dt">Map</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10"><span class="kw">import</span>           <span class="dt">Data.Map.Strict</span>      (<span class="dt">Map</span>)</a>
<a class="sourceLine" id="cb1-11" data-line-number="11"><span class="kw">import</span>           <span class="dt">Data.Monoid</span>  <span class="kw">hiding</span>  (<span class="dt">Endo</span>(..))</a>
<a class="sourceLine" id="cb1-12" data-line-number="12"><span class="kw">import</span>           <span class="dt">Data.Foldable</span> <span class="kw">hiding</span> (toList)</a>
<a class="sourceLine" id="cb1-13" data-line-number="13"><span class="kw">import</span>           <span class="dt">Control.Applicative</span></a>
<a class="sourceLine" id="cb1-14" data-line-number="14"><span class="kw">import</span>           <span class="dt">Control.Arrow</span>        (first)</a>
<a class="sourceLine" id="cb1-15" data-line-number="15"><span class="kw">import</span>           <span class="dt">Control.Monad.Cont</span></a>
<a class="sourceLine" id="cb1-16" data-line-number="16"><span class="kw">import</span>           <span class="dt">Data.Functor.Identity</span></a>
<a class="sourceLine" id="cb1-17" data-line-number="17"><span class="kw">import</span>           <span class="dt">GHC.Exts</span></a>
<a class="sourceLine" id="cb1-18" data-line-number="18"><span class="kw">import</span>           <span class="dt">Data.List</span> <span class="kw">hiding</span>     (insert)</a>
<a class="sourceLine" id="cb1-19" data-line-number="19"><span class="kw">import</span>           <span class="dt">Data.Maybe</span>           (mapMaybe)</a></code></pre></div>
<p>Iâ€™ve been playing around a lot with semirings recently. A semiring is anything with addition, multiplication, zero and one. You can represent that in Haskell as:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Semiring</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="ot">  zero ::</span> a</a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="ot">  one  ::</span> a</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">  <span class="kw">infixl</span> <span class="dv">7</span> <span class="fu">&lt;.&gt;</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="ot">  (&lt;.&gt;) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">  <span class="kw">infixl</span> <span class="dv">6</span> <span class="fu">&lt;+&gt;</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7"><span class="ot">  (&lt;+&gt;) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a></code></pre></div>
<p>Itâ€™s kind of like a combination of two <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Monoid.html">monoids</a>. It has the normal monoid laws:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1">x <span class="fu">&lt;+&gt;</span> (y <span class="fu">&lt;+&gt;</span> z) <span class="fu">=</span> (x <span class="fu">&lt;+&gt;</span> y) <span class="fu">&lt;+&gt;</span> z</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">x <span class="fu">&lt;.&gt;</span> (y <span class="fu">&lt;.&gt;</span> z) <span class="fu">=</span> (x <span class="fu">&lt;.&gt;</span> y) <span class="fu">&lt;.&gt;</span> z</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">x <span class="fu">&lt;+&gt;</span> zero <span class="fu">=</span> zero <span class="fu">&lt;+&gt;</span> x <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">x <span class="fu">&lt;.&gt;</span> one  <span class="fu">=</span> one  <span class="fu">&lt;.&gt;</span> x <span class="fu">=</span> x</a></code></pre></div>
<p>And a few extra:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">x <span class="fu">&lt;+&gt;</span> y <span class="fu">=</span> y <span class="fu">&lt;+&gt;</span> x</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">x <span class="fu">&lt;.&gt;</span> (y <span class="fu">&lt;+&gt;</span> z) <span class="fu">=</span> (x <span class="fu">&lt;.&gt;</span> y) <span class="fu">&lt;+&gt;</span> (x <span class="fu">&lt;.&gt;</span> z)</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">(x <span class="fu">&lt;+&gt;</span> y) <span class="fu">&lt;.&gt;</span> z <span class="fu">=</span> (x <span class="fu">&lt;.&gt;</span> z) <span class="fu">&lt;+&gt;</span> (y <span class="fu">&lt;.&gt;</span> z)</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">zero <span class="fu">&lt;.&gt;</span> a <span class="fu">=</span> a <span class="fu">&lt;.&gt;</span> zero <span class="fu">=</span> zero</a></code></pre></div>
<p>I should note that what Iâ€™m calling a semiring here is often called a <a href="https://ncatlab.org/nlab/show/rig">rig</a>. I actually prefer the name â€œrigâ€: a rig is a ring without <strong>n</strong>egatives (cute!); whereas a <em>semi</em>ring is a rig without neutral elements, which mirrors the definition of a semigroup. The nomenclature in this area is a bit of a mess, though, so I went with the more commonly-used name for the sake of googleability.</p>
<p>At first glance, it looks quite numeric. Indeed, <a href="https://pursuit.purescript.org/packages/purescript-prelude/1.1.0/docs/Data.Semiring">PureScript</a> uses it as the basis for its numeric hierarchy. (In my experience so far, itâ€™s nicer to use than Haskellâ€™s <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Num"><code class="sourceCode haskell"><span class="dt">Num</span></code></a>)</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Semiring</span> <span class="dt">Integer</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">  zero <span class="fu">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  one  <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">  (<span class="fu">&lt;+&gt;</span>) <span class="fu">=</span> (<span class="fu">+</span>)</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">  (<span class="fu">&lt;.&gt;</span>) <span class="fu">=</span> (<span class="fu">*</span>)</a>
<a class="sourceLine" id="cb5-6" data-line-number="6"></a>
<a class="sourceLine" id="cb5-7" data-line-number="7"><span class="kw">instance</span> <span class="dt">Semiring</span> <span class="dt">Double</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8">  zero <span class="fu">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb5-9" data-line-number="9">  one  <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb5-10" data-line-number="10">  (<span class="fu">&lt;+&gt;</span>) <span class="fu">=</span> (<span class="fu">+</span>)</a>
<a class="sourceLine" id="cb5-11" data-line-number="11">  (<span class="fu">&lt;.&gt;</span>) <span class="fu">=</span> (<span class="fu">*</span>)</a></code></pre></div>
<p>However, there are far more types which can form a valid <code class="sourceCode haskell"><span class="dt">Semiring</span></code> instance than can form a valid <code class="sourceCode haskell"><span class="dt">Num</span></code> instance: the <code class="sourceCode haskell">negate</code> method, for example, excludes types representing the natural numbers:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">ChurchNat</span> <span class="fu">=</span> <span class="dt">ChurchNat</span> </a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  {<span class="ot"> runNat ::</span> forall a<span class="fu">.</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a}</a>
<a class="sourceLine" id="cb6-3" data-line-number="3"> </a>
<a class="sourceLine" id="cb6-4" data-line-number="4"><span class="kw">data</span> <span class="dt">Nat</span> <span class="fu">=</span> <span class="dt">Zero</span> <span class="fu">|</span> <span class="dt">Succ</span> <span class="dt">Nat</span></a></code></pre></div>
<p>These form perfectly sensible semirings, though:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Semiring</span> <span class="dt">ChurchNat</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  zero <span class="fu">=</span> <span class="dt">ChurchNat</span> (const id)</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  one <span class="fu">=</span> <span class="dt">ChurchNat</span> (<span class="fu">$</span>)</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">  <span class="dt">ChurchNat</span> n <span class="fu">&lt;+&gt;</span> <span class="dt">ChurchNat</span> m <span class="fu">=</span> <span class="dt">ChurchNat</span> (\f <span class="ot">-&gt;</span> n f <span class="fu">.</span> m f)</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">  <span class="dt">ChurchNat</span> n <span class="fu">&lt;.&gt;</span> <span class="dt">ChurchNat</span> m <span class="fu">=</span> <span class="dt">ChurchNat</span> (n <span class="fu">.</span> m)</a>
<a class="sourceLine" id="cb7-6" data-line-number="6"></a>
<a class="sourceLine" id="cb7-7" data-line-number="7"><span class="kw">instance</span> <span class="dt">Semiring</span> <span class="dt">Nat</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-8" data-line-number="8">  zero <span class="fu">=</span> <span class="dt">Zero</span></a>
<a class="sourceLine" id="cb7-9" data-line-number="9">  one <span class="fu">=</span> <span class="dt">Succ</span> <span class="dt">Zero</span></a>
<a class="sourceLine" id="cb7-10" data-line-number="10">  <span class="dt">Zero</span> <span class="fu">&lt;+&gt;</span> x <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb7-11" data-line-number="11">  <span class="dt">Succ</span> x <span class="fu">&lt;+&gt;</span> y <span class="fu">=</span> <span class="dt">Succ</span> (x <span class="fu">&lt;+&gt;</span> y)</a>
<a class="sourceLine" id="cb7-12" data-line-number="12">  <span class="dt">Zero</span> <span class="fu">&lt;.&gt;</span> _ <span class="fu">=</span> <span class="dt">Zero</span></a>
<a class="sourceLine" id="cb7-13" data-line-number="13">  <span class="dt">Succ</span> <span class="dt">Zero</span> <span class="fu">&lt;.&gt;</span> x <span class="fu">=</span>x</a>
<a class="sourceLine" id="cb7-14" data-line-number="14">  <span class="dt">Succ</span> x <span class="fu">&lt;.&gt;</span> y <span class="fu">=</span> y <span class="fu">&lt;+&gt;</span> (x <span class="fu">&lt;.&gt;</span> y)</a></code></pre></div>
<p>The other missing method is <code class="sourceCode haskell">fromInteger</code>, which means decidedly non-numeric types are allowed:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Semiring</span> <span class="dt">Bool</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  zero <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  one  <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">  (<span class="fu">&lt;+&gt;</span>) <span class="fu">=</span> (<span class="fu">||</span>)</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">  (<span class="fu">&lt;.&gt;</span>) <span class="fu">=</span> (<span class="fu">&amp;&amp;</span>)</a></code></pre></div>
<p>We can provide a more general definition of the <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Monoid.html#t:Sum"><code class="sourceCode haskell"><span class="dt">Sum</span></code></a> and <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Monoid.html#t:Product"><code class="sourceCode haskell"><span class="dt">Product</span></code></a> newtypes from <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Monoid.html#g:3">Data.Monoid</a>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Add</span> a <span class="fu">=</span> <span class="dt">Add</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">  {<span class="ot"> getAdd ::</span> a</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Read</span>, <span class="dt">Show</span>, <span class="dt">Semiring</span>)</a>
<a class="sourceLine" id="cb9-4" data-line-number="4"></a>
<a class="sourceLine" id="cb9-5" data-line-number="5"><span class="kw">newtype</span> <span class="dt">Mul</span> a <span class="fu">=</span> <span class="dt">Mul</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6">  {<span class="ot"> getMul ::</span> a</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Read</span>, <span class="dt">Show</span>, <span class="dt">Semiring</span>)</a>
<a class="sourceLine" id="cb9-8" data-line-number="8"></a>
<a class="sourceLine" id="cb9-9" data-line-number="9"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Add</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-10" data-line-number="10">  fmap f (<span class="dt">Add</span> x) <span class="fu">=</span> <span class="dt">Add</span> (f x)</a>
<a class="sourceLine" id="cb9-11" data-line-number="11"></a>
<a class="sourceLine" id="cb9-12" data-line-number="12"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Add</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-13" data-line-number="13">  pure <span class="fu">=</span> <span class="dt">Add</span></a>
<a class="sourceLine" id="cb9-14" data-line-number="14">  <span class="dt">Add</span> f <span class="fu">&lt;*&gt;</span> <span class="dt">Add</span> x <span class="fu">=</span> <span class="dt">Add</span> (f x)</a></code></pre></div>
<p>Iâ€™m using <code class="sourceCode haskell"><span class="dt">Add</span></code> and <code class="sourceCode haskell"><span class="dt">Mul</span></code> here to avoid name clashing.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Semiring</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Add</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">  mempty <span class="fu">=</span> <span class="dt">Add</span> zero</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  <span class="dt">Add</span> x <span class="ot">`mappend`</span> <span class="dt">Add</span> y <span class="fu">=</span> <span class="dt">Add</span> (x <span class="fu">&lt;+&gt;</span> y)</a>
<a class="sourceLine" id="cb10-4" data-line-number="4"></a>
<a class="sourceLine" id="cb10-5" data-line-number="5"><span class="kw">instance</span> <span class="dt">Semiring</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Mul</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-6" data-line-number="6">  mempty <span class="fu">=</span> <span class="dt">Mul</span> one</a>
<a class="sourceLine" id="cb10-7" data-line-number="7">  <span class="dt">Mul</span> x <span class="ot">`mappend`</span> <span class="dt">Mul</span> y <span class="fu">=</span> <span class="dt">Mul</span> (x <span class="fu">&lt;.&gt;</span> y)</a>
<a class="sourceLine" id="cb10-8" data-line-number="8">  </a>
<a class="sourceLine" id="cb10-9" data-line-number="9"><span class="ot">add ::</span> (<span class="dt">Semiring</span> a, <span class="dt">Foldable</span> f) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb10-10" data-line-number="10">add <span class="fu">=</span> getAdd <span class="fu">.</span> foldMap <span class="dt">Add</span></a>
<a class="sourceLine" id="cb10-11" data-line-number="11"></a>
<a class="sourceLine" id="cb10-12" data-line-number="12"><span class="ot">mul ::</span> (<span class="dt">Semiring</span> a, <span class="dt">Foldable</span> f) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb10-13" data-line-number="13">mul <span class="fu">=</span> getMul <span class="fu">.</span> foldMap <span class="dt">Mul</span></a></code></pre></div>
<p><code class="sourceCode haskell">add</code> and <code class="sourceCode haskell">mul</code> are equivalent to <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Foldable.html#v:sum"><code class="sourceCode haskell">sum</code></a> and <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Foldable.html#v:product"><code class="sourceCode haskell">product</code></a>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell literate prop"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1">add xs <span class="fu">==</span> sum (<span class="ot">xs ::</span> [<span class="dt">Integer</span>])</a></code></pre></div>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell literate prop"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1">mul xs <span class="fu">==</span> product (<span class="ot">xs ::</span> [<span class="dt">Integer</span>])</a></code></pre></div>
<p>But they now work with a wider array of types: non-negative numbers, as weâ€™ve seen, but specialised to <code class="sourceCode haskell"><span class="dt">Bool</span></code> we get the familiar <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Monoid.html#t:Any"><code class="sourceCode haskell"><span class="dt">Any</span></code></a> and <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Monoid.html#t:All"><code class="sourceCode haskell"><span class="dt">All</span></code></a> newtypes (and their corresponding folds).</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell literate prop"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1">add xs <span class="fu">==</span> or (<span class="ot">xs ::</span> [<span class="dt">Bool</span>])</a></code></pre></div>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell literate prop"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1">mul xs <span class="fu">==</span> and (<span class="ot">xs ::</span> [<span class="dt">Bool</span>])</a></code></pre></div>
<p>So far, nothing amazing. We avoid a little bit of code duplication, thatâ€™s all.</p>
<h2 id="a-semiring-map">A Semiring Map</h2>
<p>In older versions of Python, <a href="https://www.python.org/dev/peps/pep-0218/">there was no native set type</a>. In its place, dictionaries were used, where the values would be booleans. In a similar fashion, before the <a href="https://docs.python.org/2/library/collections.html#collections.Counter">Counter</a> type was added in 2.7, the traditional way of representing a multiset was using a dictionary where the values were integers.</p>
<p>Using semirings, both of these data structures can have the same type:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">GeneralMap</span> a b <span class="fu">=</span> <span class="dt">GeneralMap</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2">  {<span class="ot"> getMap ::</span> <span class="dt">Map</span> a b</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">  } <span class="kw">deriving</span> (<span class="dt">Functor</span>, <span class="dt">Foldable</span>, <span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>)</a></code></pre></div>
<p>If operations are defined in terms of the <code class="sourceCode haskell"><span class="dt">Semiring</span></code> class, the same code will work on a set <em>and</em> a multiset:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="ot">insert ::</span> (<span class="dt">Ord</span> a, <span class="dt">Semiring</span> b) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a b <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a b</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">insert x <span class="fu">=</span> <span class="dt">GeneralMap</span> <span class="fu">.</span> Map.insertWith (<span class="fu">&lt;+&gt;</span>) x one <span class="fu">.</span> getMap</a>
<a class="sourceLine" id="cb16-3" data-line-number="3"></a>
<a class="sourceLine" id="cb16-4" data-line-number="4"><span class="ot">delete ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a b <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a b</a>
<a class="sourceLine" id="cb16-5" data-line-number="5">delete x <span class="fu">=</span> <span class="dt">GeneralMap</span> <span class="fu">.</span> Map.delete x <span class="fu">.</span> getMap</a></code></pre></div>
<p>How to get back the dictionary-like behaviour, then? Well, operations like <code class="sourceCode haskell">lookup</code> and <code class="sourceCode haskell">assoc</code> are better suited to a <code class="sourceCode haskell"><span class="dt">Monoid</span></code> constraint, rather than <code class="sourceCode haskell"><span class="dt">Semiring</span></code>:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1">lookup<span class="ot"> ::</span> (<span class="dt">Ord</span> a, <span class="dt">Monoid</span> b) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a b <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">lookup x <span class="fu">=</span> fold <span class="fu">.</span> Map.lookup x <span class="fu">.</span> getMap</a>
<a class="sourceLine" id="cb17-3" data-line-number="3"></a>
<a class="sourceLine" id="cb17-4" data-line-number="4"><span class="ot">assoc ::</span> (<span class="dt">Ord</span> a, <span class="dt">Applicative</span> f, <span class="dt">Monoid</span> (f b)) </a>
<a class="sourceLine" id="cb17-5" data-line-number="5">      <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a (f b) <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a (f b)</a>
<a class="sourceLine" id="cb17-6" data-line-number="6">assoc k v <span class="fu">=</span> <span class="dt">GeneralMap</span> <span class="fu">.</span> Map.insertWith mappend k (pure v) <span class="fu">.</span> getMap</a></code></pre></div>
<p><code class="sourceCode haskell">lookup</code> is a function which should work on sets and multisets: however <code class="sourceCode haskell"><span class="dt">Bool</span></code> and <code class="sourceCode haskell"><span class="dt">Integer</span></code> donâ€™t have <code class="sourceCode haskell"><span class="dt">Monoid</span></code> instances. To fix this, we can use the <code class="sourceCode haskell"><span class="dt">Add</span></code> newtype from earlier. The interface for each of these data structures can now be expressed like this:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Set</span>      a   <span class="fu">=</span> <span class="dt">GeneralMap</span> a (<span class="dt">Add</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb18-2" data-line-number="2"><span class="kw">type</span> <span class="dt">MultiSet</span> a   <span class="fu">=</span> <span class="dt">GeneralMap</span> a (<span class="dt">Add</span> <span class="dt">Integer</span>)</a>
<a class="sourceLine" id="cb18-3" data-line-number="3"><span class="kw">type</span> <span class="dt">Map</span>      a b <span class="fu">=</span> <span class="dt">GeneralMap</span> a (<span class="dt">First</span> b)</a>
<a class="sourceLine" id="cb18-4" data-line-number="4"><span class="kw">type</span> <span class="dt">MultiMap</span> a b <span class="fu">=</span> <span class="dt">GeneralMap</span> a [b]</a></code></pre></div>
<p>And each of the functions on the <code class="sourceCode haskell"><span class="dt">GeneralMap</span></code> specialises like this:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="co">-- Set</span></a>
<a class="sourceLine" id="cb19-2" data-line-number="2"><span class="ot">insert ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Set</span> a <span class="ot">-&gt;</span> <span class="dt">Set</span> a</a>
<a class="sourceLine" id="cb19-3" data-line-number="3">lookup<span class="ot"> ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Set</span> a <span class="ot">-&gt;</span> <span class="dt">Add</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb19-4" data-line-number="4"><span class="ot">delete ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Set</span> a <span class="ot">-&gt;</span> <span class="dt">Set</span> a</a>
<a class="sourceLine" id="cb19-5" data-line-number="5"></a>
<a class="sourceLine" id="cb19-6" data-line-number="6"><span class="co">-- MultiSet</span></a>
<a class="sourceLine" id="cb19-7" data-line-number="7"><span class="ot">insert ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">MultiSet</span> a <span class="ot">-&gt;</span> <span class="dt">MultiSet</span> a</a>
<a class="sourceLine" id="cb19-8" data-line-number="8">lookup<span class="ot"> ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">MultiSet</span> a <span class="ot">-&gt;</span> <span class="dt">Add</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb19-9" data-line-number="9"><span class="ot">delete ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">MultiSet</span> a <span class="ot">-&gt;</span> <span class="dt">MultiSet</span> a</a>
<a class="sourceLine" id="cb19-10" data-line-number="10"></a>
<a class="sourceLine" id="cb19-11" data-line-number="11"><span class="co">-- Map</span></a>
<a class="sourceLine" id="cb19-12" data-line-number="12"><span class="ot">assoc  ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Map</span> a b <span class="ot">-&gt;</span> <span class="dt">Map</span> a b</a>
<a class="sourceLine" id="cb19-13" data-line-number="13">lookup<span class="ot"> ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Map</span> a b <span class="ot">-&gt;</span> <span class="dt">First</span> b</a>
<a class="sourceLine" id="cb19-14" data-line-number="14"><span class="ot">delete ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Map</span> a b <span class="ot">-&gt;</span> <span class="dt">Map</span> a b</a>
<a class="sourceLine" id="cb19-15" data-line-number="15"></a>
<a class="sourceLine" id="cb19-16" data-line-number="16"><span class="co">-- MultiMap</span></a>
<a class="sourceLine" id="cb19-17" data-line-number="17"><span class="ot">assoc  ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">MultiMap</span> a b <span class="ot">-&gt;</span> <span class="dt">MultiMap</span> a b</a>
<a class="sourceLine" id="cb19-18" data-line-number="18">lookup<span class="ot"> ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">MultiMap</span> a b <span class="ot">-&gt;</span> [b]</a>
<a class="sourceLine" id="cb19-19" data-line-number="19"><span class="ot">delete ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">MultiMap</span> a b <span class="ot">-&gt;</span> <span class="dt">MultiMap</span> a b</a></code></pre></div>
<p>This was actually where I first came across semirings: I was trying to avoid code duplication for a trie implementation. I wanted to get the Boom Hierarchy <span class="citation" data-cites="boom_further_1981">(<a href="#ref-boom_further_1981">1981</a>)</span> (plus maps) from the same underlying implementation.</p>
<p>It works <em>okay</em>. On the one hand, itâ€™s nice that you donâ€™t have to wrap the map type itself to get the different behaviour. Thereâ€™s only one <code class="sourceCode haskell">delete</code> function, which works on sets, maps, multisets, etc. I donâ€™t need to import the <code class="sourceCode haskell"><span class="dt">TrieSet</span></code> module qualified, to differentiate between the <em>four</em> <code class="sourceCode haskell">delete</code> functions Iâ€™ve written.</p>
<p>On the other hand, the <code class="sourceCode haskell"><span class="dt">Add</span></code> wrapper is a pain: having <code class="sourceCode haskell">lookup</code> return the wrapped values is ugly, and the <code class="sourceCode haskell"><span class="dt">Applicative</span></code> constraint is unwieldy (we only use it for <code class="sourceCode haskell">pure</code>). Both of those problems could be solved by using something like the <a href="https://hackage.haskell.org/package/newtype-0.2/docs/Control-Newtype.html#t:Newtype"><code class="sourceCode haskell"><span class="dt">Newtype</span></code></a> or <a href="https://hackage.haskell.org/package/lens-4.15.1/docs/Control-Lens-Wrapped.html#t:Wrapped"><code class="sourceCode haskell"><span class="dt">Wrapped</span></code></a> class, which provide facilities for wrapping and unwrapping, but that might be overkill.</p>
<p>While <code class="sourceCode haskell"><span class="dt">Monoid</span></code> and <code class="sourceCode haskell"><span class="dt">Semiring</span></code> can take you pretty far, even to a <code class="sourceCode haskell"><span class="dt">Monoid</span></code> instance:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="ot">fromList ::</span> (<span class="dt">Ord</span> a, <span class="dt">Semiring</span> b, <span class="dt">Foldable</span> f) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a b</a>
<a class="sourceLine" id="cb20-2" data-line-number="2">fromList <span class="fu">=</span> foldr insert (<span class="dt">GeneralMap</span> Map.empty)</a>
<a class="sourceLine" id="cb20-3" data-line-number="3"></a>
<a class="sourceLine" id="cb20-4" data-line-number="4"><span class="ot">fromAssocs ::</span> (<span class="dt">Ord</span> a, <span class="dt">Applicative</span> f, <span class="dt">Monoid</span> (f b), <span class="dt">Foldable</span> t) </a>
<a class="sourceLine" id="cb20-5" data-line-number="5">           <span class="ot">=&gt;</span> t (a, b) <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a (f b)</a>
<a class="sourceLine" id="cb20-6" data-line-number="6">fromAssocs <span class="fu">=</span> foldr (uncurry assoc) (<span class="dt">GeneralMap</span> Map.empty)</a>
<a class="sourceLine" id="cb20-7" data-line-number="7"></a>
<a class="sourceLine" id="cb20-8" data-line-number="8"><span class="kw">instance</span> (<span class="dt">Ord</span> a, <span class="dt">Monoid</span> b) <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">GeneralMap</span> a b) <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-9" data-line-number="9">  mempty <span class="fu">=</span> <span class="dt">GeneralMap</span> Map.empty</a>
<a class="sourceLine" id="cb20-10" data-line-number="10">  mappend (<span class="dt">GeneralMap</span> x) (<span class="dt">GeneralMap</span> y) <span class="fu">=</span> </a>
<a class="sourceLine" id="cb20-11" data-line-number="11">    <span class="dt">GeneralMap</span> (Map.unionWith mappend x y)</a>
<a class="sourceLine" id="cb20-12" data-line-number="12"></a>
<a class="sourceLine" id="cb20-13" data-line-number="13"><span class="ot">singleton ::</span> <span class="dt">Semiring</span> b <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a b</a>
<a class="sourceLine" id="cb20-14" data-line-number="14">singleton x <span class="fu">=</span> <span class="dt">GeneralMap</span> (Map.singleton x one)</a></code></pre></div>
<p>They seem to fall down around functions like <code class="sourceCode haskell">intersection</code>:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="ot">intersection ::</span> (<span class="dt">Ord</span> a, <span class="dt">Semiring</span> b)</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">             <span class="ot">=&gt;</span> <span class="dt">GeneralMap</span> a b <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a b <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a b</a>
<a class="sourceLine" id="cb21-3" data-line-number="3">intersection (<span class="dt">GeneralMap</span> x) (<span class="dt">GeneralMap</span> y) <span class="fu">=</span></a>
<a class="sourceLine" id="cb21-4" data-line-number="4">  <span class="dt">GeneralMap</span> (Map.intersectionWith (<span class="fu">&lt;.&gt;</span>) x y)</a></code></pre></div>
<p>It works for sets, but it doesnâ€™t make sense for multisets, and it doesnâ€™t work for maps.</p>
<p>I couldnâ€™t find a semiring for the map-like types which would give me a sensible intersection. Iâ€™m probably after a different algebraic structure.</p>
<h2 id="a-probability-semiring">A Probability Semiring</h2>
<p>While looking for a semiring to represent a valid intersection, I came across the probability semiring. Itâ€™s just the normal semiring over the rationals, with a lower bound of 0, and an upper of 1.</p>
<p>Itâ€™s useful in some cool ways: you can combine it with a list to get the probability monad <span class="citation" data-cites="erwig_functional_2006">(Erwig and Kollmansberger <a href="#ref-erwig_functional_2006">2006</a>)</span>. Thereâ€™s an example in PureScriptâ€™s <a href="https://pursuit.purescript.org/packages/purescript-distributions/">Distributions</a> package.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Prob</span> s a <span class="fu">=</span> <span class="dt">Prob</span> {<span class="ot"> runProb ::</span> [(a,s)] }</a></code></pre></div>
<p>There are some drawbacks to this representation, performance-wise. In particular, thereâ€™s a combinatorial explosion on every monadic bind. One of the strategies to reduce this explosion is to use a map:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Prob</span> s a <span class="fu">=</span> <span class="dt">Prob</span> {<span class="ot"> runProb ::</span> <span class="dt">Map</span> a s }</a></code></pre></div>
<p>Because this doesnâ€™t allow duplicate keys, it will flatten the association list on every bind. Unfortunately, the performance gain doesnâ€™t always materialize, and in some cases thereâ€™s a performance <em>loss</em> <span class="citation" data-cites="larsen_memory_2011">(Larsen <a href="#ref-larsen_memory_2011">2011</a>)</span>. Also, the <code class="sourceCode haskell"><span class="dt">Ord</span></code> constraint on the keys prevents it from conforming to <code class="sourceCode haskell"><span class="dt">Monad</span></code> (at least not without <a href="http://okmij.org/ftp/Haskell/set-monad.html">difficulty</a>).</p>
<p>Interestingly, this type is exactly the same as the <code class="sourceCode haskell"><span class="dt">GeneralMap</span></code> from before. This is a theme I kept running into, actually: the <code class="sourceCode haskell"><span class="dt">GeneralMap</span></code> type represents not just maps, multimaps, sets, multisets, but also a whole host of other data structures.</p>
<h2 id="cont">Cont</h2>
<p>Edward Kmett had an interesting blog post about â€œFree Modules and Functional Linear Functionalsâ€ <span class="citation" data-cites="kmett_modules_2011">(<a href="#ref-kmett_modules_2011">2011</a><a href="#ref-kmett_modules_2011">b</a>)</span>. In it, he talked about this type:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">0</span> <span class="fu">$*</span></a>
<a class="sourceLine" id="cb24-2" data-line-number="2"><span class="kw">newtype</span> <span class="dt">Linear</span> r a <span class="fu">=</span> <span class="dt">Linear</span> {<span class="ot"> ($*) ::</span> (a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r }</a></code></pre></div>
<p>Also known as <a href="https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Cont.html#t:Cont"><code class="sourceCode haskell"><span class="dt">Cont</span></code></a>, the continuation monad. It can encode the probability monad:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="ot">fromProbs ::</span> (<span class="dt">Semiring</span> s, <span class="dt">Applicative</span> m) <span class="ot">=&gt;</span> [(a,s)] <span class="ot">-&gt;</span> <span class="dt">ContT</span> s m a</a>
<a class="sourceLine" id="cb25-2" data-line-number="2">fromProbs xs <span class="fu">=</span> <span class="dt">ContT</span> <span class="fu">$</span> \k <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb25-3" data-line-number="3">  foldr (\(x,s) a <span class="ot">-&gt;</span> liftA2 (<span class="fu">&lt;+&gt;</span>) (fmap (s<span class="fu">&lt;.&gt;</span>) (k x)) a) (pure zero) xs</a>
<a class="sourceLine" id="cb25-4" data-line-number="4"></a>
<a class="sourceLine" id="cb25-5" data-line-number="5"><span class="ot">probOfT ::</span> (<span class="dt">Semiring</span> r, <span class="dt">Applicative</span> m) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">ContT</span> r m a <span class="ot">-&gt;</span> m r</a>
<a class="sourceLine" id="cb25-6" data-line-number="6">probOfT e c <span class="fu">=</span> runContT c (\x <span class="ot">-&gt;</span> <span class="kw">if</span> e x <span class="kw">then</span> pure one <span class="kw">else</span> pure zero)</a>
<a class="sourceLine" id="cb25-7" data-line-number="7"></a>
<a class="sourceLine" id="cb25-8" data-line-number="8"><span class="ot">probOf ::</span> <span class="dt">Semiring</span> r <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Cont</span> r a <span class="ot">-&gt;</span> r</a>
<a class="sourceLine" id="cb25-9" data-line-number="9">probOf e <span class="fu">=</span> runIdentity <span class="fu">.</span> probOfT e</a>
<a class="sourceLine" id="cb25-10" data-line-number="10"></a>
<a class="sourceLine" id="cb25-11" data-line-number="11"><span class="ot">uniform ::</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">ContT</span> <span class="dt">Double</span> m a</a>
<a class="sourceLine" id="cb25-12" data-line-number="12">uniform xs <span class="fu">=</span></a>
<a class="sourceLine" id="cb25-13" data-line-number="13">  <span class="kw">let</span> s <span class="fu">=</span> <span class="fl">1.0</span> <span class="fu">/</span> fromIntegral (length xs)</a>
<a class="sourceLine" id="cb25-14" data-line-number="14">  <span class="kw">in</span> fromProbs (map (flip (,) s) xs)</a></code></pre></div>
<p>Multiplication isnâ€™t paid for on every bind, making this (potentially) a more efficient implementation than both the map and the association list.</p>
<p>You can actually make the whole thing a semiring:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="kw">instance</span> (<span class="dt">Semiring</span> r, <span class="dt">Applicative</span> m) <span class="ot">=&gt;</span> <span class="dt">Semiring</span> (<span class="dt">ContT</span> r m a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb26-2" data-line-number="2">  one  <span class="fu">=</span> <span class="dt">ContT</span> (const (pure one))</a>
<a class="sourceLine" id="cb26-3" data-line-number="3">  zero <span class="fu">=</span> <span class="dt">ContT</span> (const (pure zero))</a>
<a class="sourceLine" id="cb26-4" data-line-number="4">  f <span class="fu">&lt;+&gt;</span> g <span class="fu">=</span> <span class="dt">ContT</span> (\k <span class="ot">-&gt;</span> liftA2 (<span class="fu">&lt;+&gt;</span>) (runContT f k) (runContT g k))</a>
<a class="sourceLine" id="cb26-5" data-line-number="5">  f <span class="fu">&lt;.&gt;</span> g <span class="fu">=</span> <span class="dt">ContT</span> (\k <span class="ot">-&gt;</span> liftA2 (<span class="fu">&lt;.&gt;</span>) (runContT f k) (runContT g k))</a></code></pre></div>
<p>Which gives you a lovely <code class="sourceCode haskell"><span class="dt">Alternative</span></code> instance:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="kw">instance</span> (<span class="dt">Semiring</span> r, <span class="dt">Applicative</span> m) <span class="ot">=&gt;</span> <span class="dt">Alternative</span> (<span class="dt">ContT</span> r m) <span class="kw">where</span></a>
<a class="sourceLine" id="cb27-2" data-line-number="2">  (<span class="fu">&lt;|&gt;</span>) <span class="fu">=</span> (<span class="fu">&lt;+&gt;</span>)</a>
<a class="sourceLine" id="cb27-3" data-line-number="3">  empty <span class="fu">=</span> zero</a></code></pre></div>
<p>This sheds some light on what was going on with the unsatisfactory <code class="sourceCode haskell">intersection</code> function on <code class="sourceCode haskell"><span class="dt">GeneralMap</span></code>: itâ€™s actually <em>multiplication</em>. If you wanted to stretch the analogy and make <code class="sourceCode haskell"><span class="dt">GeneralMap</span></code> conform to <code class="sourceCode haskell"><span class="dt">Semiring</span></code>, you could use the empty map for <code class="sourceCode haskell">zero</code>, <code class="sourceCode haskell">mappend</code> for <code class="sourceCode haskell"><span class="fu">&lt;+&gt;</span></code>, but youâ€™d run into trouble for <code class="sourceCode haskell">one</code>. <code class="sourceCode haskell">one</code> is the map where every possible key has a value of one. In other words, youâ€™d have to enumerate over every possible value for the keys. Interestingly, thereâ€™s kind of the inverse problem for Cont: while it has an easy <code class="sourceCode haskell"><span class="dt">Semiring</span></code> instance, in order to <em>inspect</em> the values you have to enumerate over all the possible keys.</p>
<p>I now have a name for the probability monad / general map / Cont thing: a <em>covector</em>.</p>
<p>I think that the transformer version of Cont has a valid interpretation, also. If I ever understand <span class="citation" data-cites="hirschowitz_modules_2010">Hirschowitz and Maggesi (<a href="#ref-hirschowitz_modules_2010">2010</a>)</span> Iâ€™ll put it into a later follow-up post.</p>
<h2 id="conditional-choice">Conditional choice</h2>
<p>As a short digression, you can beef up the <code class="sourceCode haskell"><span class="fu">&lt;|&gt;</span></code> operator a little, with something like <a href="http://zenzike.com/posts/2011-08-01-the-conditional-choice-operator">the conditional choice operator</a>:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1"><span class="kw">data</span> <span class="dt">BiWeighted</span> s <span class="fu">=</span> s <span class="fu">:|:</span> s</a>
<a class="sourceLine" id="cb28-2" data-line-number="2"><span class="kw">infixl</span> <span class="dv">8</span> <span class="fu">:|:</span></a>
<a class="sourceLine" id="cb28-3" data-line-number="3"></a>
<a class="sourceLine" id="cb28-4" data-line-number="4"><span class="ot">(|&gt;) ::</span> (<span class="dt">Applicative</span> m, <span class="dt">Semiring</span> s)</a>
<a class="sourceLine" id="cb28-5" data-line-number="5">     <span class="ot">=&gt;</span> <span class="dt">BiWeighted</span> s</a>
<a class="sourceLine" id="cb28-6" data-line-number="6">     <span class="ot">-&gt;</span> <span class="dt">ContT</span> s m a</a>
<a class="sourceLine" id="cb28-7" data-line-number="7">     <span class="ot">-&gt;</span> <span class="dt">ContT</span> s m a</a>
<a class="sourceLine" id="cb28-8" data-line-number="8">     <span class="ot">-&gt;</span> <span class="dt">ContT</span> s m a</a>
<a class="sourceLine" id="cb28-9" data-line-number="9">((lp <span class="fu">:|:</span> rp) <span class="fu">|&gt;</span> r) l <span class="fu">=</span></a>
<a class="sourceLine" id="cb28-10" data-line-number="10">  (mapContT<span class="fu">.</span>fmap<span class="fu">.</span>(<span class="fu">&lt;.&gt;</span>)) lp l <span class="fu">&lt;|&gt;</span> (mapContT<span class="fu">.</span>fmap<span class="fu">.</span>(<span class="fu">&lt;.&gt;</span>)) rp r</a>
<a class="sourceLine" id="cb28-11" data-line-number="11"><span class="co">--</span></a>
<a class="sourceLine" id="cb28-12" data-line-number="12"><span class="ot">(&lt;|) ::</span> <span class="dt">ContT</span> s m a</a>
<a class="sourceLine" id="cb28-13" data-line-number="13">     <span class="ot">-&gt;</span> (<span class="dt">ContT</span> s m a <span class="ot">-&gt;</span> <span class="dt">ContT</span> s m a)</a>
<a class="sourceLine" id="cb28-14" data-line-number="14">     <span class="ot">-&gt;</span> <span class="dt">ContT</span> s m a</a>
<a class="sourceLine" id="cb28-15" data-line-number="15">l <span class="fu">&lt;|</span> r <span class="fu">=</span> r l</a>
<a class="sourceLine" id="cb28-16" data-line-number="16"></a>
<a class="sourceLine" id="cb28-17" data-line-number="17"><span class="kw">infixr</span> <span class="dv">0</span> <span class="fu">&lt;|</span></a>
<a class="sourceLine" id="cb28-18" data-line-number="18"><span class="kw">infixr</span> <span class="dv">0</span> <span class="fu">|&gt;</span></a></code></pre></div>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" data-line-number="1">probOf (<span class="ch">&#39;a&#39;</span><span class="fu">==</span>) (uniform <span class="st">&quot;a&quot;</span> <span class="fu">&lt;|</span> <span class="fl">0.4</span> <span class="fu">:|:</span> <span class="fl">0.6</span> <span class="fu">|&gt;</span> uniform <span class="st">&quot;b&quot;</span>)</a>
<a class="sourceLine" id="cb29-2" data-line-number="2"><span class="fl">0.4</span></a></code></pre></div>
<h2 id="unleak">UnLeak</h2>
<p>If you fiddle around with the probability monad, you can break it apart in interesting ways. For instance, extracting the <code class="sourceCode haskell"><span class="dt">WriterT</span></code> monad transformer gives you:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="dt">WriterT</span> (<span class="dt">Product</span> <span class="dt">Double</span>) []</a></code></pre></div>
<p>Eric Kidd describes it as <code class="sourceCode haskell"><span class="dt">PerhapsT</span></code>: a <code class="sourceCode haskell"><span class="dt">Maybe</span></code> with attached probability in his <a href="http://www.randomhacks.net/2007/02/21/refactoring-probability-distributions/">excellent blog post</a> <span class="citation" data-cites="kidd_build_2007">(and his paper in <a href="#ref-kidd_build_2007">2007</a>)</span>.</p>
<p>Straight away, we can optimise this representation by transforming the <a href="https://mail.haskell.org/pipermail/libraries/2013-March/019528.html">leaky</a> <code class="sourceCode haskell"><span class="dt">WriterT</span></code> into a state monad:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">WeightedT</span> s m a <span class="fu">=</span> <span class="dt">WeightedT</span> </a>
<a class="sourceLine" id="cb31-2" data-line-number="2">  {<span class="ot"> getWeightedT ::</span> s <span class="ot">-&gt;</span> m (a, s)</a>
<a class="sourceLine" id="cb31-3" data-line-number="3">  } <span class="kw">deriving</span> <span class="dt">Functor</span></a>
<a class="sourceLine" id="cb31-4" data-line-number="4">  </a>
<a class="sourceLine" id="cb31-5" data-line-number="5"><span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="dt">WeightedT</span> s m) <span class="kw">where</span></a>
<a class="sourceLine" id="cb31-6" data-line-number="6">  pure x <span class="fu">=</span> <span class="dt">WeightedT</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> pure (x,s)</a>
<a class="sourceLine" id="cb31-7" data-line-number="7">  <span class="dt">WeightedT</span> fs <span class="fu">&lt;*&gt;</span> <span class="dt">WeightedT</span> xs <span class="fu">=</span> <span class="dt">WeightedT</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb31-8" data-line-number="8">    (f, p) <span class="ot">&lt;-</span> fs s</a>
<a class="sourceLine" id="cb31-9" data-line-number="9">    (x, t) <span class="ot">&lt;-</span> xs p</a>
<a class="sourceLine" id="cb31-10" data-line-number="10">    pure (f x, t)</a>
<a class="sourceLine" id="cb31-11" data-line-number="11">  </a>
<a class="sourceLine" id="cb31-12" data-line-number="12"><span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">WeightedT</span> s m) <span class="kw">where</span></a>
<a class="sourceLine" id="cb31-13" data-line-number="13">  <span class="dt">WeightedT</span> x <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">WeightedT</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb31-14" data-line-number="14">    (x, p) <span class="ot">&lt;-</span> x s</a>
<a class="sourceLine" id="cb31-15" data-line-number="15">    getWeightedT (f x) p</a></code></pre></div>
<p>Iâ€™m not sure yet, but I think this might have something to do with the isomorphism between <code class="sourceCode haskell"><span class="dt">Cont</span> ((<span class="ot">-&gt;</span>) s)</code> and <code>State s</code> <span class="citation" data-cites="kmett_free_2011">(Kmett <a href="#ref-kmett_free_2011">2011</a><a href="#ref-kmett_free_2011">a</a>)</span>.</p>
<p>You can even make it look like a normal (non-transformer) writer with some pattern synonyms:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Weighted</span> s <span class="fu">=</span> <span class="dt">WeightedT</span> s <span class="dt">Identity</span></a>
<a class="sourceLine" id="cb32-2" data-line-number="2"></a>
<a class="sourceLine" id="cb32-3" data-line-number="3">pattern <span class="dt">Weighted</span> w <span class="ot">&lt;-</span> (runIdentity <span class="fu">.</span> flip getWeightedT zero <span class="ot">-&gt;</span> w) <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-4" data-line-number="4">  <span class="dt">Weighted</span> (x,w) <span class="fu">=</span> <span class="dt">WeightedT</span> (\s <span class="ot">-&gt;</span> <span class="dt">Identity</span> (x, s <span class="fu">&lt;.&gt;</span> w) )</a></code></pre></div>
<p>And you can pretend that youâ€™ve just got a normal tuple:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" data-line-number="1"><span class="ot">half ::</span> a <span class="ot">-&gt;</span> <span class="dt">Weighted</span> <span class="dt">Double</span> a</a>
<a class="sourceLine" id="cb33-2" data-line-number="2">half x <span class="fu">=</span> <span class="dt">Weighted</span> (x, <span class="fl">0.5</span>)</a>
<a class="sourceLine" id="cb33-3" data-line-number="3"></a>
<a class="sourceLine" id="cb33-4" data-line-number="4"><span class="ot">runWeighted ::</span> <span class="dt">Semiring</span> s <span class="ot">=&gt;</span> <span class="dt">Weighted</span> s a <span class="ot">-&gt;</span> (a, s)</a>
<a class="sourceLine" id="cb33-5" data-line-number="5">runWeighted (<span class="dt">Weighted</span> w) <span class="fu">=</span> w</a>
<a class="sourceLine" id="cb33-6" data-line-number="6"></a>
<a class="sourceLine" id="cb33-7" data-line-number="7"><span class="ot">evalWeighted ::</span> <span class="dt">Semiring</span> s <span class="ot">=&gt;</span> <span class="dt">Weighted</span> s a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb33-8" data-line-number="8">evalWeighted (<span class="dt">Weighted</span> (x,_)) <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb33-9" data-line-number="9"></a>
<a class="sourceLine" id="cb33-10" data-line-number="10"><span class="ot">execWeighted ::</span> <span class="dt">Semiring</span> s <span class="ot">=&gt;</span> <span class="dt">Weighted</span> s a <span class="ot">-&gt;</span> s</a>
<a class="sourceLine" id="cb33-11" data-line-number="11">execWeighted (<span class="dt">Weighted</span> (_,s)) <span class="fu">=</span> s</a></code></pre></div>
<h2 id="free">Free</h2>
<p>Looking back at Cont, it is reminiscent of a particular encoding of the free monoid from <span class="citation" data-cites="doel_free_2015">Doel (<a href="#ref-doel_free_2015">2015</a>)</span>:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">FreeMonoid</span> a <span class="fu">=</span> <span class="dt">FreeMonoid</span></a>
<a class="sourceLine" id="cb34-2" data-line-number="2">  { forall m<span class="fu">.</span> <span class="dt">Monoid</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m) <span class="ot">-&gt;</span> m }</a></code></pre></div>
<p>So possibly covectors represent the free semiring, in some way.</p>
<p>Another encoding which looks free-ish is one of the efficient implementations of the probability monad from <span class="citation" data-cites="larsen_memory_2011">Larsen (<a href="#ref-larsen_memory_2011">2011</a>)</span>:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb35-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Dist</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb35-2" data-line-number="2">  <span class="dt">Certainly</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Dist</span> a <span class="co">-- only possible value</span></a>
<a class="sourceLine" id="cb35-3" data-line-number="3">  <span class="dt">Choice</span><span class="ot"> ::</span> <span class="dt">Probability</span> <span class="ot">-&gt;</span> <span class="dt">Dist</span> a <span class="ot">-&gt;</span> <span class="dt">Dist</span> a <span class="ot">-&gt;</span> <span class="dt">Dist</span> a</a>
<a class="sourceLine" id="cb35-4" data-line-number="4">  <span class="dt">Fmap</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Dist</span> a <span class="ot">-&gt;</span> <span class="dt">Dist</span> b</a>
<a class="sourceLine" id="cb35-5" data-line-number="5">  <span class="dt">Join</span><span class="ot"> ::</span> <span class="dt">Dist</span> (<span class="dt">Dist</span> a) <span class="ot">-&gt;</span> <span class="dt">Dist</span> a</a></code></pre></div>
<p>This looks an awful lot like a weighted <a href="https://hackage.haskell.org/package/free-4.12.4/docs/Control-Alternative-Free.html">free alternative</a>. Is it a free semiring, then?</p>
<p>Maybe. Thereâ€™s a parallel between the relationship between monoids and semirings and applicatives and <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Applicative.html#t:Alternative"><code class="sourceCode haskell"><span class="dt">Alternative</span></code></a>s <span class="citation" data-cites="rivas_monoids_2015">(Rivas, Jaskelioff, and Schrijvers <a href="#ref-rivas_monoids_2015">2015</a>)</span>. In a way, where monads are monoids in the category of endofunctors, alternatives are <em>semirings</em> in the category of endofunctors.</p>
<p>This parallel probably isnâ€™t what I first thought it was. First of all, the above paper uses near-semirings, not semirings. A near-semiring is a semiring where the requirements for left distribution of multiplication over addition and commutative addition are dropped. Secondly, the class which most mirrors near-semirings is <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Monad.html#t:MonadPlus"><code class="sourceCode haskell"><span class="dt">MonadPlus</span></code></a>, not alternative. (alternative doesnâ€™t have annihilation) Thirdly, right distribution of multiplication over addition <em>isnâ€™t</em> required <code class="sourceCode haskell"><span class="dt">MonadPlus</span></code>: itâ€™s a further law required on top of the existing laws. Fourthly, most types in the Haskell ecosystem today which conform to <code class="sourceCode haskell"><span class="dt">MonadPlus</span></code> <em>donâ€™t</em> conform to this extra law: in fact, those that do seem to be lists of some kind or another.</p>
<p>A further class is probably needed on top of the two already there, with the extra laws <span class="citation" data-cites="fischer_reinventing_2009">(called <code class="sourceCode haskell"><span class="dt">Nondet</span></code> in Fischer <a href="#ref-fischer_reinventing_2009">2009</a>)</span>.</p>
<p>An actual free near-semiring looks like this:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Free</span> f x <span class="fu">=</span> <span class="dt">Free</span> {<span class="ot"> unFree ::</span> [<span class="dt">FFree</span> f x] }</a>
<a class="sourceLine" id="cb36-2" data-line-number="2"><span class="kw">data</span> <span class="dt">FFree</span> f x <span class="fu">=</span> <span class="dt">Pure</span> x <span class="fu">|</span> <span class="dt">Con</span> (f (<span class="dt">Free</span> f x))</a></code></pre></div>
<p>Specialised to the <code class="sourceCode haskell"><span class="dt">Identity</span></code> monad, that becomes:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb37-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Forest</span> a <span class="fu">=</span> <span class="dt">Forest</span> {<span class="ot"> unForest ::</span> [<span class="dt">Tree</span> x] }</a>
<a class="sourceLine" id="cb37-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Tree</span> x <span class="fu">=</span> <span class="dt">Leaf</span> x <span class="fu">|</span> <span class="dt">Branch</span> (<span class="dt">Forest</span> x)</a></code></pre></div>
<p>De-specialised to the <a href="https://hackage.haskell.org/package/free-4.12.4/docs/Control-Monad-Trans-Free.html">free monad transformer</a>, it becomes:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb38-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">FreeT</span> f m a <span class="fu">=</span> <span class="dt">FreeT</span></a>
<a class="sourceLine" id="cb38-2" data-line-number="2">  {<span class="ot"> runFreeT ::</span> m (<span class="dt">FreeF</span> f a (<span class="dt">FreeT</span> f m a)) }</a>
<a class="sourceLine" id="cb38-3" data-line-number="3"></a>
<a class="sourceLine" id="cb38-4" data-line-number="4"><span class="kw">data</span> <span class="dt">FreeF</span> f a b</a>
<a class="sourceLine" id="cb38-5" data-line-number="5">  <span class="fu">=</span> <span class="dt">Pure</span> a</a>
<a class="sourceLine" id="cb38-6" data-line-number="6">  <span class="fu">|</span> <span class="dt">Free</span> (f b)</a>
<a class="sourceLine" id="cb38-7" data-line-number="7"></a>
<a class="sourceLine" id="cb38-8" data-line-number="8"><span class="kw">type</span> <span class="dt">FreeNearSemiring</span> f <span class="fu">=</span> <span class="dt">FreeT</span> f []</a></code></pre></div>
<p>These definitions all lend themselves to combinatorial search <span class="citation" data-cites="spivey_algebras_2009">(Spivey <a href="#ref-spivey_algebras_2009">2009</a>, <span class="citation" data-cites="fischer_reinventing_2009">@fischer_reinventing_2009</span>, <span class="citation" data-cites="piponi_monad_2009">@piponi_monad_2009</span>)</span>, with one extra operation needed: <code class="sourceCode haskell">wrap</code>.</p>
<h2 id="odds">Odds</h2>
<p>Does the <a href="/posts/2016-09-27-odds-lhs.html">odds monad</a> fit in to any of this?</p>
<p>While <code class="sourceCode haskell"><span class="dt">WriterT</span> (<span class="dt">Product</span> <span class="dt">Rational</span>) []</code> is a valid definition of the traditional probability monad, itâ€™s <em>not</em> the same as the odds monad. If you take the odds monad, and parameterize it over the weight of the tail, you get this:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb39-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Odds</span> m a <span class="fu">=</span> <span class="dt">Certain</span> a <span class="fu">|</span> <span class="dt">Choice</span> (m (a, <span class="dt">Odds</span> a))</a></code></pre></div>
<p>Which looks remarkably like <a href="http://www.haskellforall.com/2016/07/list-transformer-beginner-friendly-listt.html"><code class="sourceCode haskell"><span class="dt">ListT</span></code> done right</a>:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb40-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">ListT</span> m a <span class="fu">=</span> <span class="dt">ListT</span> {<span class="ot"> next ::</span> m (<span class="dt">Step</span> m a) }</a>
<a class="sourceLine" id="cb40-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Step</span> m a <span class="fu">=</span> <span class="dt">Cons</span> a (<span class="dt">ListT</span> m a) <span class="fu">|</span> <span class="dt">Nil</span></a></code></pre></div>
<p>That suggests a relationship between probability and odds:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb41-1" data-line-number="1"><span class="dt">WriterT</span> (<span class="dt">Product</span>  <span class="dt">Rational</span>) [] <span class="fu">=</span> <span class="dt">Probability</span></a>
<a class="sourceLine" id="cb41-2" data-line-number="2"><span class="dt">ListT</span>   (<span class="dt">Weighted</span> <span class="dt">Rational</span>)    <span class="fu">=</span> <span class="dt">Odds</span></a></code></pre></div>
<p><code class="sourceCode haskell"><span class="dt">ListT</span></code> isnâ€™t a perfect match, though: it allows empty lists. To correct this, you could use the <a href="https://hackage.haskell.org/package/free-4.12.4/docs/Control-Comonad-Cofree.html">Cofree Comonad</a>:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb42-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Cofree</span> f a <span class="fu">=</span> a <span class="fu">:&lt;</span> (f (<span class="dt">Cofree</span> f a))</a></code></pre></div>
<p>Subbing in <code class="sourceCode haskell"><span class="dt">Maybe</span></code> for <code class="sourceCode haskell">f</code>, you get a non-empty list. A <em>weighted</em> <code class="sourceCode haskell"><span class="dt">Maybe</span></code> is basically <a href="http://www.randomhacks.net/2007/02/21/refactoring-probability-distributions/"><code class="sourceCode haskell"><span class="dt">PerhapsT</span></code></a>, as was mentioned earlier.</p>
<h2 id="generalizing-semirings">Generalizing Semirings</h2>
<p>Types in haskell also form a semiring.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb43-1" data-line-number="1">(<span class="fu">&lt;.&gt;</span>) <span class="fu">=</span> (,)</a>
<a class="sourceLine" id="cb43-2" data-line-number="2">one <span class="fu">=</span> ()</a>
<a class="sourceLine" id="cb43-3" data-line-number="3"></a>
<a class="sourceLine" id="cb43-4" data-line-number="4">(<span class="fu">&lt;+&gt;</span>) <span class="fu">=</span> <span class="dt">Either</span></a>
<a class="sourceLine" id="cb43-5" data-line-number="5">zero <span class="fu">=</span> <span class="dt">Void</span></a></code></pre></div>
<p>Thereâ€™s a subset of semirings which are <a href="https://en.wikipedia.org/wiki/Semiring#Star_semirings">star semirings</a>. They have an operation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>*</mo><annotation encoding="application/x-tex">*</annotation></semantics></math> such that:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>*</mo><mo>=</mo><mn>1</mn><mo>+</mo><mi>a</mi><mi>a</mi><mo>*</mo><mo>=</mo><mn>1</mn><mo>+</mo><mi>a</mi><mo>*</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">a* = 1 + aa* = 1 + a*a</annotation></semantics></math></p>
<p>Or, as a class:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb44-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Semiring</span> a <span class="ot">=&gt;</span> <span class="dt">StarSemiring</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb44-2" data-line-number="2"><span class="ot">  star ::</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb44-3" data-line-number="3">  star x <span class="fu">=</span> one <span class="fu">&lt;+&gt;</span> plus x</a>
<a class="sourceLine" id="cb44-4" data-line-number="4"><span class="ot">  plus ::</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb44-5" data-line-number="5">  plus x <span class="fu">=</span> x <span class="fu">&lt;.&gt;</span> star x</a></code></pre></div>
<p>Using this on types, you get:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb45-1" data-line-number="1">star a <span class="fu">=</span> <span class="dt">Either</span> () (a, star a)</a></code></pre></div>
<p>Which is just a standard list! Some pseudo-haskell on alternatives will give you:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb46-1" data-line-number="1"><span class="ot">star ::</span> (<span class="dt">Alternative</span> f, <span class="dt">Monoid</span> a) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb46-2" data-line-number="2">star x <span class="fu">=</span> (x <span class="fu">&lt;.&gt;</span> star x) <span class="fu">&lt;+&gt;</span> pure mempty <span class="kw">where</span></a>
<a class="sourceLine" id="cb46-3" data-line-number="3">  (<span class="fu">&lt;.&gt;</span>) <span class="fu">=</span> liftA2 mappend</a>
<a class="sourceLine" id="cb46-4" data-line-number="4">  (<span class="fu">&lt;+&gt;</span>) <span class="fu">=</span> <span class="fu">&lt;|&gt;</span></a></code></pre></div>
<p>Also known as <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Applicative.html#v:many"><code class="sourceCode haskell">many</code></a>. (although note that this breaks all the laws)</p>
<p>The <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>*</mo><annotation encoding="application/x-tex">*</annotation></semantics></math> for rationals is defined as <span class="citation" data-cites="droste_semirings_2009">(Droste and Kuich <a href="#ref-droste_semirings_2009">2009</a>, p8)</span>:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>*</mo><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd columnalign="left"><mfrac><mn>1</mn><mrow><mn>1</mn><mo>âˆ’</mo><mi>a</mi></mrow></mfrac></mtd><mtd columnalign="left"><mspace width="1.0em"></mspace><mrow><mtext mathvariant="normal">if </mtext><mspace width="0.333em"></mspace></mrow></mtd><mtd columnalign="left"><mn>0</mn><mo>â‰¤</mo><mi>a</mi><mo>&lt;</mo><mn>1</mn><mo>,</mo></mtd></mtr><mtr><mtd columnalign="left"><mi>âˆ</mi></mtd><mtd columnalign="left"><mspace width="1.0em"></mspace><mrow><mtext mathvariant="normal">if </mtext><mspace width="0.333em"></mspace></mrow></mtd><mtd columnalign="left"><mi>a</mi><mo>â‰¥</mo><mn>1</mn><mi>.</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">a* = \begin{cases}
  \frac{1}{1 - a} &amp; \quad \text{if  } &amp; 0 \leq a \lt 1, \\
  \infty          &amp; \quad \text{if  } &amp; a \geq 1.
\end{cases}</annotation></semantics></math></p>
<p>So, combining the probability with the type-level business, the star of <code>Writer s a</code> is:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb47-1" data-line-number="1"><span class="dt">Either</span> (<span class="dv">1</span>, a) (a, s <span class="fu">/</span> (<span class="dv">1</span> <span class="fu">-</span> s), star (<span class="dt">Writer</span> s a))</a></code></pre></div>
<p>Or, to put it another way: the odds monad!</p>
<h2 id="endo">Endo</h2>
<p>An <a href="https://ncatlab.org/nlab/show/endomorphism">endomorphism</a> is a morphism from an object to itself. A less general definition (and the one <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Monoid.html#t:Endo">most often used</a> in Haskell) is a function of the type <code class="sourceCode haskell">a <span class="ot">-&gt;</span> a</code>:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb48-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Endo</span> a <span class="fu">=</span> <span class="dt">Endo</span> {<span class="ot"> appEndo ::</span> a <span class="ot">-&gt;</span> a }</a></code></pre></div>
<p>It forms a monoid under composition:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb49-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Monoid</span> (<span class="dt">Endo</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb49-2" data-line-number="2">  mempty <span class="fu">=</span> <span class="dt">Endo</span> id</a>
<a class="sourceLine" id="cb49-3" data-line-number="3">  mappend (<span class="dt">Endo</span> f) (<span class="dt">Endo</span> g) <span class="fu">=</span> <span class="dt">Endo</span> (f <span class="fu">.</span> g)</a></code></pre></div>
<p>If the underlying type is itself a commutative monoid, it also forms near-semiring:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb50-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Monoid</span> a <span class="ot">=&gt;</span> <span class="dt">Semiring</span> (<span class="dt">Endo</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb50-2" data-line-number="2">  <span class="dt">Endo</span> f <span class="fu">&lt;+&gt;</span> <span class="dt">Endo</span> g <span class="fu">=</span> <span class="dt">Endo</span> (\x <span class="ot">-&gt;</span> f x <span class="fu">&lt;&gt;</span> g x)</a>
<a class="sourceLine" id="cb50-3" data-line-number="3">  zero <span class="fu">=</span> <span class="dt">Endo</span> (const mempty)</a>
<a class="sourceLine" id="cb50-4" data-line-number="4">  one <span class="fu">=</span> <span class="dt">Endo</span> id</a>
<a class="sourceLine" id="cb50-5" data-line-number="5">  <span class="dt">Endo</span> f <span class="fu">&lt;.&gt;</span> <span class="dt">Endo</span> g <span class="fu">=</span> <span class="dt">Endo</span> (f <span class="fu">.</span> g)</a>
<a class="sourceLine" id="cb50-6" data-line-number="6">  </a>
<a class="sourceLine" id="cb50-7" data-line-number="7"><span class="kw">instance</span> (<span class="dt">Monoid</span> a, <span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">StarSemiring</span> (<span class="dt">Endo</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb50-8" data-line-number="8">  star (<span class="dt">Endo</span> f) <span class="fu">=</span> <span class="dt">Endo</span> converge <span class="kw">where</span></a>
<a class="sourceLine" id="cb50-9" data-line-number="9">    converge x <span class="fu">=</span> x <span class="fu">&lt;&gt;</span> (<span class="kw">if</span> y <span class="fu">==</span> mempty <span class="kw">then</span> y <span class="kw">else</span> converge y) <span class="kw">where</span></a>
<a class="sourceLine" id="cb50-10" data-line-number="10">      y <span class="fu">=</span> f x</a></code></pre></div>
<p>Hereâ€™s something interesting: thereâ€™s a similarity here to the semiring for church numerals. In fact, as far as I can tell, the functions are <em>exactly</em> the same when applied to endomorphisms of endomorphisms. To the extent that you could define church numerals with something as simple as this:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb51-1" data-line-number="1"><span class="kw">type</span> <span class="dt">ChurchEndoNat</span> <span class="fu">=</span> forall a<span class="fu">.</span> <span class="dt">Endo</span> (<span class="dt">Endo</span> a)</a></code></pre></div>
<p>And it works!</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb52-1" data-line-number="1">two,<span class="ot"> three ::</span> <span class="dt">ChurchEndoNat</span></a>
<a class="sourceLine" id="cb52-2" data-line-number="2">two <span class="fu">=</span> one <span class="fu">&lt;+&gt;</span> one</a>
<a class="sourceLine" id="cb52-3" data-line-number="3">three <span class="fu">=</span> one <span class="fu">&lt;+&gt;</span> two</a>
<a class="sourceLine" id="cb52-4" data-line-number="4"></a>
<a class="sourceLine" id="cb52-5" data-line-number="5"><span class="ot">unChurch ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">ChurchEndoNat</span> <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb52-6" data-line-number="6">unChurch f <span class="fu">=</span> appEndo (appEndo f (<span class="dt">Endo</span> (<span class="dv">1</span><span class="fu">+</span>))) <span class="dv">0</span></a></code></pre></div>
<div class="sourceCode" id="cb53"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell"><a class="sourceLine" id="cb53-1" data-line-number="1">unChurch (two <span class="fu">&lt;.&gt;</span> three)</a>
<a class="sourceLine" id="cb53-2" data-line-number="2"><span class="dv">6</span></a></code></pre></div>
<h2 id="regex">Regex</h2>
<p>One of the most important applications (and a source of much of the notation) is regular expressions. In fact, the free semiring looks like a haskell datatype for regular expressions:</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb54-1" data-line-number="1"><span class="kw">data</span> <span class="dt">FreeStar</span> a</a>
<a class="sourceLine" id="cb54-2" data-line-number="2"> <span class="fu">=</span> <span class="dt">Gen</span> a</a>
<a class="sourceLine" id="cb54-3" data-line-number="3"> <span class="fu">|</span> <span class="dt">Zer</span></a>
<a class="sourceLine" id="cb54-4" data-line-number="4"> <span class="fu">|</span> <span class="dt">One</span></a>
<a class="sourceLine" id="cb54-5" data-line-number="5"> <span class="fu">|</span> <span class="dt">FreeStar</span> a <span class="fu">:&lt;+&gt;</span> <span class="dt">FreeStar</span> a</a>
<a class="sourceLine" id="cb54-6" data-line-number="6"> <span class="fu">|</span> <span class="dt">FreeStar</span> a <span class="fu">:&lt;.&gt;</span> <span class="dt">FreeStar</span> a</a>
<a class="sourceLine" id="cb54-7" data-line-number="7"> <span class="fu">|</span> <span class="dt">Star</span> (<span class="dt">FreeStar</span> a)</a>
<a class="sourceLine" id="cb54-8" data-line-number="8"></a>
<a class="sourceLine" id="cb54-9" data-line-number="9"><span class="kw">instance</span> <span class="dt">Semiring</span> (<span class="dt">FreeStar</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb54-10" data-line-number="10">  (<span class="fu">&lt;+&gt;</span>) <span class="fu">=</span> (<span class="fu">:&lt;+&gt;</span>)</a>
<a class="sourceLine" id="cb54-11" data-line-number="11">  (<span class="fu">&lt;.&gt;</span>) <span class="fu">=</span> (<span class="fu">:&lt;.&gt;</span>)</a>
<a class="sourceLine" id="cb54-12" data-line-number="12">  zero <span class="fu">=</span> <span class="dt">Zer</span></a>
<a class="sourceLine" id="cb54-13" data-line-number="13">  one <span class="fu">=</span> <span class="dt">One</span></a>
<a class="sourceLine" id="cb54-14" data-line-number="14">  </a>
<a class="sourceLine" id="cb54-15" data-line-number="15"><span class="kw">instance</span> <span class="dt">StarSemiring</span> (<span class="dt">FreeStar</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb54-16" data-line-number="16">  star <span class="fu">=</span> <span class="dt">Star</span></a>
<a class="sourceLine" id="cb54-17" data-line-number="17">  </a>
<a class="sourceLine" id="cb54-18" data-line-number="18"><span class="ot">interpret ::</span> <span class="dt">StarSemiring</span> s <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> s) <span class="ot">-&gt;</span> <span class="dt">FreeStar</span> a <span class="ot">-&gt;</span> s</a>
<a class="sourceLine" id="cb54-19" data-line-number="19">interpret f <span class="fu">=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb54-20" data-line-number="20">  <span class="dt">Gen</span> x <span class="ot">-&gt;</span> f x</a>
<a class="sourceLine" id="cb54-21" data-line-number="21">  <span class="dt">Zer</span> <span class="ot">-&gt;</span> zero</a>
<a class="sourceLine" id="cb54-22" data-line-number="22">  <span class="dt">One</span> <span class="ot">-&gt;</span> one</a>
<a class="sourceLine" id="cb54-23" data-line-number="23">  l <span class="fu">:&lt;+&gt;</span> r <span class="ot">-&gt;</span> interpret f l <span class="fu">&lt;+&gt;</span> interpret f r</a>
<a class="sourceLine" id="cb54-24" data-line-number="24">  l <span class="fu">:&lt;.&gt;</span> r <span class="ot">-&gt;</span> interpret f l <span class="fu">&lt;.&gt;</span> interpret f r</a>
<a class="sourceLine" id="cb54-25" data-line-number="25">  <span class="dt">Star</span> x <span class="ot">-&gt;</span> star (interpret f x)</a></code></pre></div>
<p>Then, interpreting the regex is as simple as writing an interpreter (with some help from <code class="sourceCode haskell"><span class="dt">Endo</span></code>):</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb55-1" data-line-number="1"><span class="ot">asRegex ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> <span class="dt">FreeStar</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb55-2" data-line-number="2">asRegex fs <span class="fu">=</span> any null <span class="fu">.</span> appEndo (interpret f fs) <span class="fu">.</span> pure <span class="kw">where</span></a>
<a class="sourceLine" id="cb55-3" data-line-number="3">  f p <span class="fu">=</span> <span class="dt">Endo</span> <span class="fu">.</span> mapMaybe <span class="fu">$</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb55-4" data-line-number="4">    (x<span class="fu">:</span>xs) <span class="fu">|</span> p x <span class="ot">-&gt;</span> <span class="dt">Just</span> xs</a>
<a class="sourceLine" id="cb55-5" data-line-number="5">    _ <span class="ot">-&gt;</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb55-6" data-line-number="6"></a>
<a class="sourceLine" id="cb55-7" data-line-number="7"><span class="ot">char&#39; ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">FreeStar</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb55-8" data-line-number="8">char&#39; c <span class="fu">=</span> <span class="dt">Gen</span> (c<span class="fu">==</span>)</a></code></pre></div>
<p>Actually, you donâ€™t need the free version at all!</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb56-1" data-line-number="1"><span class="ot">runRegex ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> <span class="dt">Endo</span> [[a]] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb56-2" data-line-number="2">runRegex fs <span class="fu">=</span> any null <span class="fu">.</span> appEndo fs <span class="fu">.</span> pure</a>
<a class="sourceLine" id="cb56-3" data-line-number="3"></a>
<a class="sourceLine" id="cb56-4" data-line-number="4"><span class="ot">char ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Endo</span> [[a]]</a>
<a class="sourceLine" id="cb56-5" data-line-number="5">char c <span class="fu">=</span> <span class="dt">Endo</span> <span class="fu">.</span> mapMaybe <span class="fu">$</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb56-6" data-line-number="6">  (x<span class="fu">:</span>xs) <span class="fu">|</span> c <span class="fu">==</span> x <span class="ot">-&gt;</span> <span class="dt">Just</span> xs</a>
<a class="sourceLine" id="cb56-7" data-line-number="7">  _ <span class="ot">-&gt;</span> <span class="dt">Nothing</span>  </a></code></pre></div>
<p>With some <code class="sourceCode haskell"><span class="fu">-</span><span class="dt">XOverloadedStrings</span></code> magic, you get a pretty nice interface:</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb57-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">IsString</span> (<span class="dt">Endo</span> [<span class="dt">String</span>]) <span class="kw">where</span></a>
<a class="sourceLine" id="cb57-2" data-line-number="2">  fromString <span class="fu">=</span> mul <span class="fu">.</span> map char <span class="fu">.</span> reverse</a>
<a class="sourceLine" id="cb57-3" data-line-number="3">  </a>
<a class="sourceLine" id="cb57-4" data-line-number="4"><span class="ot">(&lt;^&gt;) ::</span> <span class="dt">Semiring</span> s <span class="ot">=&gt;</span> s <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> s</a>
<a class="sourceLine" id="cb57-5" data-line-number="5">(<span class="fu">&lt;^&gt;</span>) <span class="fu">=</span> flip (<span class="fu">&lt;.&gt;</span>)</a>
<a class="sourceLine" id="cb57-6" data-line-number="6"></a>
<a class="sourceLine" id="cb57-7" data-line-number="7"><span class="ot">greet ::</span> <span class="dt">Endo</span> [<span class="dt">String</span>]</a>
<a class="sourceLine" id="cb57-8" data-line-number="8">greet <span class="fu">=</span> <span class="st">&quot;H&quot;</span> <span class="fu">&lt;^&gt;</span> (<span class="st">&quot;a&quot;</span> <span class="fu">&lt;+&gt;</span> <span class="st">&quot;e&quot;</span>) <span class="fu">&lt;^&gt;</span> <span class="st">&quot;llo&quot;</span></a></code></pre></div>
<div class="sourceCode" id="cb58"><pre class="sourceCode haskell literate example hidden_source"><code class="sourceCode haskell"><a class="sourceLine" id="cb58-1" data-line-number="1"><span class="fu">:</span>set <span class="fu">-</span><span class="dt">XOverloadedStrings</span></a></code></pre></div>
<div class="sourceCode" id="cb59"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell"><a class="sourceLine" id="cb59-1" data-line-number="1">runRegex greet <span class="st">&quot;Hello&quot;</span></a>
<a class="sourceLine" id="cb59-2" data-line-number="2"><span class="dt">True</span></a></code></pre></div>
<div class="sourceCode" id="cb60"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell"><a class="sourceLine" id="cb60-1" data-line-number="1">runRegex greet <span class="st">&quot;Hallo&quot;</span></a>
<a class="sourceLine" id="cb60-2" data-line-number="2"><span class="dt">True</span></a></code></pre></div>
<div class="sourceCode" id="cb61"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell"><a class="sourceLine" id="cb61-1" data-line-number="1">runRegex greet <span class="st">&quot;Halo&quot;</span></a>
<a class="sourceLine" id="cb61-2" data-line-number="2"><span class="dt">False</span></a></code></pre></div>
<h2 id="efficiency">Efficiency</h2>
<p>Of course, thatâ€™s about as slow as it gets when it comes to regexes. A faster representation is a <a href="https://swtch.com/~rsc/regexp/regexp1.html">nondeterministic finite automaton</a>. One such implementation in haskell is <a href="https://github.com/Gabriel439/slides/blob/master/regex/regex.md">Gabriel Gonzalezâ€™s</a>.</p>
<p>The regex type in that example can be immediately made to conform to <code class="sourceCode haskell"><span class="dt">Semiring</span></code> and <code class="sourceCode haskell"><span class="dt">StarSemiring</span></code>. However, it might be more interesting to translate the <em>implementation</em> into using semirings. The type of a regex looks like this:</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb62-1" data-line-number="1"><span class="kw">type</span> <span class="dt">State</span> <span class="fu">=</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb62-2" data-line-number="2"></a>
<a class="sourceLine" id="cb62-3" data-line-number="3">{<span class="ot"> _startingStates         ::</span> <span class="dt">Set</span> <span class="dt">State</span></a>
<a class="sourceLine" id="cb62-4" data-line-number="4">,<span class="ot"> _transitionFunction     ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="ot">-&gt;</span> <span class="dt">Set</span> <span class="dt">State</span></a>
<a class="sourceLine" id="cb62-5" data-line-number="5">,<span class="ot"> _acceptingStates        ::</span> <span class="dt">Set</span> <span class="dt">State</span> }</a></code></pre></div>
<p>The set data structure jumps out as an opportunity to sub in arbitrary semirings.Swapping in the <code class="sourceCode haskell"><span class="dt">GeneralMap</span></code> is reasonably easy:</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb63-1" data-line-number="1"><span class="kw">type</span> <span class="dt">State</span> <span class="fu">=</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb63-2" data-line-number="2"></a>
<a class="sourceLine" id="cb63-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Regex</span> i s <span class="fu">=</span> <span class="dt">Regex</span></a>
<a class="sourceLine" id="cb63-4" data-line-number="4">  {<span class="ot"> _numberOfStates     ::</span> <span class="dt">Int</span> </a>
<a class="sourceLine" id="cb63-5" data-line-number="5">  ,<span class="ot"> _startingStates     ::</span> <span class="dt">GeneralMap</span> <span class="dt">State</span> s</a>
<a class="sourceLine" id="cb63-6" data-line-number="6">  ,<span class="ot"> _transitionFunction ::</span> i <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> <span class="dt">State</span> s</a>
<a class="sourceLine" id="cb63-7" data-line-number="7">  ,<span class="ot"> _acceptingStates    ::</span> <span class="dt">GeneralMap</span> <span class="dt">State</span> s }</a>
<a class="sourceLine" id="cb63-8" data-line-number="8"></a>
<a class="sourceLine" id="cb63-9" data-line-number="9"><span class="ot">isEnd ::</span> <span class="dt">Semiring</span> s <span class="ot">=&gt;</span> <span class="dt">Regex</span> i s <span class="ot">-&gt;</span> s</a>
<a class="sourceLine" id="cb63-10" data-line-number="10">isEnd (<span class="dt">Regex</span> _ as _ bs) <span class="fu">=</span> add (intersection as bs)</a>
<a class="sourceLine" id="cb63-11" data-line-number="11"></a>
<a class="sourceLine" id="cb63-12" data-line-number="12"><span class="ot">match ::</span> <span class="dt">Regex</span> <span class="dt">Char</span> (<span class="dt">Add</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb63-13" data-line-number="13">match r <span class="fu">=</span> getAdd <span class="fu">.</span> isEnd <span class="fu">.</span> foldl&#39; run r <span class="kw">where</span></a>
<a class="sourceLine" id="cb63-14" data-line-number="14">  run (<span class="dt">Regex</span> n (<span class="dt">GeneralMap</span> as) f bs) i <span class="fu">=</span> <span class="dt">Regex</span> n as&#39; f bs</a>
<a class="sourceLine" id="cb63-15" data-line-number="15">    <span class="kw">where</span> as&#39; <span class="fu">=</span> mconcat [ fmap (v<span class="fu">&lt;.&gt;</span>) (f i k)  <span class="fu">|</span> (k,v) <span class="ot">&lt;-</span> Map.assocs as ]</a>
<a class="sourceLine" id="cb63-16" data-line-number="16"></a>
<a class="sourceLine" id="cb63-17" data-line-number="17"></a>
<a class="sourceLine" id="cb63-18" data-line-number="18"><span class="ot">satisfy ::</span> <span class="dt">Semiring</span> s <span class="ot">=&gt;</span> (i <span class="ot">-&gt;</span> s) <span class="ot">-&gt;</span> <span class="dt">Regex</span> i (<span class="dt">Add</span> s)</a>
<a class="sourceLine" id="cb63-19" data-line-number="19">satisfy predicate <span class="fu">=</span> <span class="dt">Regex</span> <span class="dv">2</span> as f bs</a>
<a class="sourceLine" id="cb63-20" data-line-number="20">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb63-21" data-line-number="21">    as <span class="fu">=</span> singleton <span class="dv">0</span></a>
<a class="sourceLine" id="cb63-22" data-line-number="22">    bs <span class="fu">=</span> singleton <span class="dv">1</span></a>
<a class="sourceLine" id="cb63-23" data-line-number="23"></a>
<a class="sourceLine" id="cb63-24" data-line-number="24">    f i <span class="dv">0</span> <span class="fu">=</span> assoc <span class="dv">1</span> (predicate i) mempty</a>
<a class="sourceLine" id="cb63-25" data-line-number="25">    f _ _ <span class="fu">=</span> mempty</a>
<a class="sourceLine" id="cb63-26" data-line-number="26"></a>
<a class="sourceLine" id="cb63-27" data-line-number="27"><span class="ot">once ::</span> <span class="dt">Eq</span> i <span class="ot">=&gt;</span> i <span class="ot">-&gt;</span> <span class="dt">Regex</span> i (<span class="dt">Add</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb63-28" data-line-number="28">once x <span class="fu">=</span> satisfy (<span class="fu">==</span> x)</a>
<a class="sourceLine" id="cb63-29" data-line-number="29"></a>
<a class="sourceLine" id="cb63-30" data-line-number="30"><span class="ot">shift ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> <span class="dt">State</span> s <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> <span class="dt">State</span> s</a>
<a class="sourceLine" id="cb63-31" data-line-number="31">shift n <span class="fu">=</span> <span class="dt">GeneralMap</span> <span class="fu">.</span> Map.fromAscList <span class="fu">.</span> (map<span class="fu">.</span>first) (<span class="fu">+</span> n) <span class="fu">.</span> Map.toAscList <span class="fu">.</span> getMap</a>
<a class="sourceLine" id="cb63-32" data-line-number="32"></a>
<a class="sourceLine" id="cb63-33" data-line-number="33"><span class="kw">instance</span> (<span class="dt">Semiring</span> s, <span class="dt">Monoid</span> s) <span class="ot">=&gt;</span> <span class="dt">Semiring</span> (<span class="dt">Regex</span> i s) <span class="kw">where</span></a>
<a class="sourceLine" id="cb63-34" data-line-number="34"></a>
<a class="sourceLine" id="cb63-35" data-line-number="35">  one <span class="fu">=</span> <span class="dt">Regex</span> <span class="dv">1</span> (singleton <span class="dv">0</span>) (\_ _ <span class="ot">-&gt;</span> mempty) (singleton <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb63-36" data-line-number="36">  zero <span class="fu">=</span> <span class="dt">Regex</span> <span class="dv">0</span> mempty (\_ _ <span class="ot">-&gt;</span> mempty) mempty</a>
<a class="sourceLine" id="cb63-37" data-line-number="37"></a>
<a class="sourceLine" id="cb63-38" data-line-number="38">  <span class="dt">Regex</span> nL asL fL bsL <span class="fu">&lt;+&gt;</span> <span class="dt">Regex</span> nR asR fR bsR <span class="fu">=</span> <span class="dt">Regex</span> n as f bs</a>
<a class="sourceLine" id="cb63-39" data-line-number="39">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb63-40" data-line-number="40">      n  <span class="fu">=</span> nL <span class="fu">+</span> nR</a>
<a class="sourceLine" id="cb63-41" data-line-number="41">      as <span class="fu">=</span> mappend asL (shift nL asR)</a>
<a class="sourceLine" id="cb63-42" data-line-number="42">      bs <span class="fu">=</span> mappend bsL (shift nL bsR)</a>
<a class="sourceLine" id="cb63-43" data-line-number="43">      f i s <span class="fu">|</span> s <span class="fu">&lt;</span> nL    <span class="fu">=</span> fL i s</a>
<a class="sourceLine" id="cb63-44" data-line-number="44">            <span class="fu">|</span> otherwise <span class="fu">=</span> shift nL (fR i (s <span class="fu">-</span> nL))</a>
<a class="sourceLine" id="cb63-45" data-line-number="45"></a>
<a class="sourceLine" id="cb63-46" data-line-number="46">  <span class="dt">Regex</span> nL asL fL bsL <span class="fu">&lt;.&gt;</span> <span class="dt">Regex</span> nR asR fR bsR <span class="fu">=</span> <span class="dt">Regex</span> n as f bs <span class="kw">where</span></a>
<a class="sourceLine" id="cb63-47" data-line-number="47"></a>
<a class="sourceLine" id="cb63-48" data-line-number="48">    n <span class="fu">=</span> nL <span class="fu">+</span> nR</a>
<a class="sourceLine" id="cb63-49" data-line-number="49"></a>
<a class="sourceLine" id="cb63-50" data-line-number="50">    as <span class="fu">=</span> <span class="kw">let</span> ss <span class="fu">=</span> add (intersection asL bsL)</a>
<a class="sourceLine" id="cb63-51" data-line-number="51">         <span class="kw">in</span> mappend asL (fmap (ss<span class="fu">&lt;.&gt;</span>) (shift nL asR))</a>
<a class="sourceLine" id="cb63-52" data-line-number="52"></a>
<a class="sourceLine" id="cb63-53" data-line-number="53">    f i s <span class="fu">=</span></a>
<a class="sourceLine" id="cb63-54" data-line-number="54">        <span class="kw">if</span> s <span class="fu">&lt;</span> nL</a>
<a class="sourceLine" id="cb63-55" data-line-number="55">        <span class="kw">then</span> <span class="kw">let</span> ss <span class="fu">=</span> add (intersection r bsL)</a>
<a class="sourceLine" id="cb63-56" data-line-number="56">             <span class="kw">in</span> mappend r (fmap (ss<span class="fu">&lt;.&gt;</span>) (shift nL asR))</a>
<a class="sourceLine" id="cb63-57" data-line-number="57">        <span class="kw">else</span> shift nL (fR i (s <span class="fu">-</span> nL))</a>
<a class="sourceLine" id="cb63-58" data-line-number="58">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb63-59" data-line-number="59">        r <span class="fu">=</span> fL i s</a>
<a class="sourceLine" id="cb63-60" data-line-number="60">    bs <span class="fu">=</span> shift nL bsR</a>
<a class="sourceLine" id="cb63-61" data-line-number="61"></a>
<a class="sourceLine" id="cb63-62" data-line-number="62"><span class="kw">instance</span> (<span class="dt">StarSemiring</span> s, <span class="dt">Monoid</span> s) <span class="ot">=&gt;</span> <span class="dt">StarSemiring</span> (<span class="dt">Regex</span> i s) <span class="kw">where</span></a>
<a class="sourceLine" id="cb63-63" data-line-number="63">  star (<span class="dt">Regex</span> n as f bs) <span class="fu">=</span> <span class="dt">Regex</span> n as f&#39; as</a>
<a class="sourceLine" id="cb63-64" data-line-number="64">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb63-65" data-line-number="65">      f&#39; i s <span class="fu">=</span></a>
<a class="sourceLine" id="cb63-66" data-line-number="66">          <span class="kw">let</span> r <span class="fu">=</span> f i s</a>
<a class="sourceLine" id="cb63-67" data-line-number="67">              ss <span class="fu">=</span> add (intersection r bs)</a>
<a class="sourceLine" id="cb63-68" data-line-number="68">          <span class="kw">in</span> mappend r (fmap (ss<span class="fu">&lt;.&gt;</span>) as)</a>
<a class="sourceLine" id="cb63-69" data-line-number="69"></a>
<a class="sourceLine" id="cb63-70" data-line-number="70">  plus (<span class="dt">Regex</span> n as f bs) <span class="fu">=</span> <span class="dt">Regex</span> n as f&#39; bs</a>
<a class="sourceLine" id="cb63-71" data-line-number="71">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb63-72" data-line-number="72">      f&#39; i s <span class="fu">=</span></a>
<a class="sourceLine" id="cb63-73" data-line-number="73">          <span class="kw">let</span> r <span class="fu">=</span> f i s</a>
<a class="sourceLine" id="cb63-74" data-line-number="74">              ss <span class="fu">=</span> add (intersection r bs)</a>
<a class="sourceLine" id="cb63-75" data-line-number="75">          <span class="kw">in</span> mappend r (fmap (ss<span class="fu">&lt;.&gt;</span>) as)</a>
<a class="sourceLine" id="cb63-76" data-line-number="76"></a>
<a class="sourceLine" id="cb63-77" data-line-number="77"></a>
<a class="sourceLine" id="cb63-78" data-line-number="78"><span class="kw">instance</span> <span class="dt">IsString</span> (<span class="dt">Regex</span> <span class="dt">Char</span> (<span class="dt">Add</span> <span class="dt">Bool</span>)) <span class="kw">where</span></a>
<a class="sourceLine" id="cb63-79" data-line-number="79">  fromString <span class="fu">=</span> mul <span class="fu">.</span> map once</a></code></pre></div>
<p>This begins to show some of the real power of using semirings and covectors. We have a normal regular expression implementation when we use the covector over bools. Use the probability semiring, and youâ€™ve got probabilistic parsing.</p>
<p>Swap in the <a href="https://ncatlab.org/nlab/show/max-plus+algebra">tropical semiring</a>: a semiring over the reals where addition is the max function, and multiplication is addition of reals. Now youâ€™ve got a depth-first parser.</p>
<p>Thatâ€™s how you might swap in different interpretations. How about swapping in different <em>implementations</em>? Well, there might be some use to swapping in the <a href="https://en.wikipedia.org/wiki/CYK_algorithm">CYK algorithm</a>, or the Gauss-Jordan-Floyd-Warshall-McNaughton-Yamada algorithm <span class="citation" data-cites="oconnor_very_2011">(Oâ€™Connor <a href="#ref-oconnor_very_2011">2011</a>)</span>.</p>
<p>Alternatively, you can swap in the underlying data structure. Instead of a map, if you use an integer (each bit being a value, the keys being the bit position), you have a super-fast implementation (and the final implementation used in the original example). Finally, you could use a different representation of the state transfer function: a matrix.</p>
<h2 id="square-matrices">Square Matrices</h2>
<p>A square matrix can be understood as a map from pairs of indices to values. This lets us use it to represent the state transfer function. Take, for instance, a regular expression with three possible states. Its state transfer function might look like this:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">transfer</mtext><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd columnalign="left"><mn>1</mn><mspace width="1.0em"></mspace></mtd><mtd columnalign="left"><mo stretchy="false" form="prefix">{</mo><mn>2</mn><mo>,</mo><mn>3</mn><mo stretchy="false" form="postfix">}</mo></mtd></mtr><mtr><mtd columnalign="left"><mn>2</mn><mspace width="1.0em"></mspace></mtd><mtd columnalign="left"><mo stretchy="false" form="prefix">{</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo></mtd></mtr><mtr><mtd columnalign="left"><mn>3</mn><mspace width="1.0em"></mspace></mtd><mtd columnalign="left"><mi>âˆ…</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\text{transfer} = \begin{cases}
1 \quad &amp; \{ 2, 3 \} \\
2 \quad &amp; \{ 1 \} \\
3 \quad &amp; \emptyset
\end{cases}</annotation></semantics></math></p>
<p>It has the type of:</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb64-1" data-line-number="1"><span class="dt">State</span> <span class="ot">-&gt;</span> <span class="dt">Set</span> <span class="dt">State</span></a></code></pre></div>
<p>Where <code class="sourceCode haskell"><span class="dt">State</span></code> is an integer. You can represent the set as a vector, where each position is a key, and each value is whether or not that key is present:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">transfer</mtext><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd columnalign="left"><mn>1</mn><mspace width="1.0em"></mspace></mtd><mtd columnalign="left"><mn>0</mn></mtd><mtd columnalign="left"><mn>1</mn></mtd><mtd columnalign="left"><mn>1</mn></mtd></mtr><mtr><mtd columnalign="left"><mn>2</mn><mspace width="1.0em"></mspace></mtd><mtd columnalign="left"><mn>1</mn></mtd><mtd columnalign="left"><mn>0</mn></mtd><mtd columnalign="left"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="left"><mn>3</mn><mspace width="1.0em"></mspace></mtd><mtd columnalign="left"><mn>0</mn></mtd><mtd columnalign="left"><mn>0</mn></mtd><mtd columnalign="left"><mn>0</mn></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\text{transfer} = \begin{cases}
1 \quad &amp; 0 &amp; 1 &amp; 1 \\
2 \quad &amp; 1 &amp; 0 &amp; 0 \\
3 \quad &amp; 0 &amp; 0 &amp; 0 \end{cases}</annotation></semantics></math></p>
<p>Then, the matrix representation is obvious:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">transfer</mtext><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center"><mn>0</mn></mtd><mtd columnalign="center"><mn>1</mn></mtd><mtd columnalign="center"><mn>1</mn></mtd></mtr><mtr><mtd columnalign="center"><mn>1</mn></mtd><mtd columnalign="center"><mn>0</mn></mtd><mtd columnalign="center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center"><mn>0</mn></mtd><mtd columnalign="center"><mn>0</mn></mtd><mtd columnalign="center"><mn>0</mn></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\text{transfer} = \left( \begin{array}{ccc}
0 &amp; 1 &amp; 1 \\
1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 \end{array} \right)</annotation></semantics></math></p>
<p>This is the semiring of square matrices. It is, of course, yet <em>another</em> covector. The â€œkeysâ€ are the transfers: <code class="sourceCode haskell"><span class="dv">1</span> <span class="ot">-&gt;</span> <span class="dv">2</span></code> or <code class="sourceCode haskell"><span class="dv">2</span> <span class="ot">-&gt;</span> <span class="dv">3</span></code>, represented by the indices of the matrix. The â€œvaluesâ€ are whether or not that transfer is permitted.</p>
<p>The algorithms for the usual semiring operations on matrices like this are well-known and well-optimized. I havenâ€™t yet benchmarked them in Haskell using the matrix libraries, so I donâ€™t know how they compare to the other approaches. In the meantime, thereâ€™s an elegant list-based implementation in <span class="citation" data-cites="dolan_fun_2013">Dolan (<a href="#ref-dolan_fun_2013">2013</a>)</span>:</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb65-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Matrix</span> a <span class="fu">=</span> <span class="dt">Scalar</span> a</a>
<a class="sourceLine" id="cb65-2" data-line-number="2">              <span class="fu">|</span> <span class="dt">Matrix</span> [[a]]</a>
<a class="sourceLine" id="cb65-3" data-line-number="3">              </a>
<a class="sourceLine" id="cb65-4" data-line-number="4"><span class="ot">mjoin ::</span> (<span class="dt">Matrix</span> a, <span class="dt">Matrix</span> a, <span class="dt">Matrix</span> a, <span class="dt">Matrix</span> a) <span class="ot">-&gt;</span> <span class="dt">Matrix</span> a</a>
<a class="sourceLine" id="cb65-5" data-line-number="5">mjoin (<span class="dt">Matrix</span> ws, <span class="dt">Matrix</span> xs, <span class="dt">Matrix</span> ys, <span class="dt">Matrix</span> zs) <span class="fu">=</span></a>
<a class="sourceLine" id="cb65-6" data-line-number="6">  <span class="dt">Matrix</span> ((zipWith (<span class="fu">++</span>) ws xs) <span class="fu">++</span> (zipWith (<span class="fu">++</span>) ys zs))</a>
<a class="sourceLine" id="cb65-7" data-line-number="7">  </a>
<a class="sourceLine" id="cb65-8" data-line-number="8"><span class="ot">msplit ::</span> <span class="dt">Matrix</span> a <span class="ot">-&gt;</span> (<span class="dt">Matrix</span> a, <span class="dt">Matrix</span> a, <span class="dt">Matrix</span> a, <span class="dt">Matrix</span> a)</a>
<a class="sourceLine" id="cb65-9" data-line-number="9">msplit (<span class="dt">Matrix</span> (row<span class="fu">:</span>rows)) <span class="fu">=</span> </a>
<a class="sourceLine" id="cb65-10" data-line-number="10">  (<span class="dt">Matrix</span> [[first]], <span class="dt">Matrix</span> [top]</a>
<a class="sourceLine" id="cb65-11" data-line-number="11">  ,<span class="dt">Matrix</span> left,      <span class="dt">Matrix</span> rest )</a>
<a class="sourceLine" id="cb65-12" data-line-number="12">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb65-13" data-line-number="13">    (first<span class="fu">:</span>top) <span class="fu">=</span> row</a>
<a class="sourceLine" id="cb65-14" data-line-number="14">    (left,rest) <span class="fu">=</span> unzip (map (\(x<span class="fu">:</span>xs) <span class="ot">-&gt;</span> ([x],xs)) rows)</a>
<a class="sourceLine" id="cb65-15" data-line-number="15">    </a>
<a class="sourceLine" id="cb65-16" data-line-number="16"><span class="kw">instance</span> <span class="dt">Semiring</span> a <span class="ot">=&gt;</span> <span class="dt">Semiring</span> (<span class="dt">Matrix</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb65-17" data-line-number="17">  zero <span class="fu">=</span> <span class="dt">Scalar</span> zero</a>
<a class="sourceLine" id="cb65-18" data-line-number="18">  one <span class="fu">=</span> <span class="dt">Scalar</span> one</a>
<a class="sourceLine" id="cb65-19" data-line-number="19">  <span class="dt">Scalar</span> x <span class="fu">&lt;+&gt;</span> <span class="dt">Scalar</span> y <span class="fu">=</span> <span class="dt">Scalar</span> (x <span class="fu">&lt;+&gt;</span> y)</a>
<a class="sourceLine" id="cb65-20" data-line-number="20">  <span class="dt">Matrix</span> x <span class="fu">&lt;+&gt;</span> <span class="dt">Matrix</span> y <span class="fu">=</span></a>
<a class="sourceLine" id="cb65-21" data-line-number="21">    <span class="dt">Matrix</span> (zipWith (zipWith (<span class="fu">&lt;+&gt;</span>)) x y)</a>
<a class="sourceLine" id="cb65-22" data-line-number="22">  <span class="dt">Scalar</span> x <span class="fu">&lt;+&gt;</span> m <span class="fu">=</span> m <span class="fu">&lt;+&gt;</span> <span class="dt">Scalar</span> x</a>
<a class="sourceLine" id="cb65-23" data-line-number="23">  <span class="dt">Matrix</span> [[x]] <span class="fu">&lt;+&gt;</span> <span class="dt">Scalar</span> y <span class="fu">=</span> <span class="dt">Matrix</span> [[x <span class="fu">&lt;+&gt;</span> y]]</a>
<a class="sourceLine" id="cb65-24" data-line-number="24">  x <span class="fu">&lt;+&gt;</span> y <span class="fu">=</span> mjoin (first <span class="fu">&lt;+&gt;</span> y, top, left, rest <span class="fu">&lt;+&gt;</span> y)</a>
<a class="sourceLine" id="cb65-25" data-line-number="25">    <span class="kw">where</span> (first, top, left, rest) <span class="fu">=</span> msplit x</a>
<a class="sourceLine" id="cb65-26" data-line-number="26">  <span class="dt">Scalar</span> x <span class="fu">&lt;.&gt;</span> <span class="dt">Scalar</span> y <span class="fu">=</span> <span class="dt">Scalar</span> (x <span class="fu">&lt;.&gt;</span> y)</a>
<a class="sourceLine" id="cb65-27" data-line-number="27">  <span class="dt">Scalar</span> x <span class="fu">&lt;.&gt;</span> <span class="dt">Matrix</span> y <span class="fu">=</span> <span class="dt">Matrix</span> ((map<span class="fu">.</span>map) (x<span class="fu">&lt;.&gt;</span>) y)</a>
<a class="sourceLine" id="cb65-28" data-line-number="28">  <span class="dt">Matrix</span> x <span class="fu">&lt;.&gt;</span> <span class="dt">Scalar</span> y <span class="fu">=</span> <span class="dt">Matrix</span> ((map<span class="fu">.</span>map) (<span class="fu">&lt;.&gt;</span>y) x)</a>
<a class="sourceLine" id="cb65-29" data-line-number="29">  <span class="dt">Matrix</span> x <span class="fu">&lt;.&gt;</span> <span class="dt">Matrix</span> y <span class="fu">=</span> </a>
<a class="sourceLine" id="cb65-30" data-line-number="30">    <span class="dt">Matrix</span> [ [ foldl1 (<span class="fu">&lt;+&gt;</span>) (zipWith (<span class="fu">&lt;.&gt;</span>) row col) <span class="fu">|</span> col <span class="ot">&lt;-</span> cols ] </a>
<a class="sourceLine" id="cb65-31" data-line-number="31">           <span class="fu">|</span> row <span class="ot">&lt;-</span> x ] <span class="kw">where</span> cols <span class="fu">=</span> transpose y</a>
<a class="sourceLine" id="cb65-32" data-line-number="32"></a>
<a class="sourceLine" id="cb65-33" data-line-number="33"><span class="kw">instance</span> <span class="dt">StarSemiring</span> a <span class="ot">=&gt;</span> <span class="dt">StarSemiring</span> (<span class="dt">Matrix</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb65-34" data-line-number="34">  star (<span class="dt">Matrix</span> [[x]]) <span class="fu">=</span> <span class="dt">Matrix</span> [[star x]]</a>
<a class="sourceLine" id="cb65-35" data-line-number="35">  star m <span class="fu">=</span> mjoin (first&#39; <span class="fu">&lt;+&gt;</span> top&#39; <span class="fu">&lt;.&gt;</span> rest&#39; <span class="fu">&lt;.&gt;</span> left&#39;</a>
<a class="sourceLine" id="cb65-36" data-line-number="36">                 ,top&#39; <span class="fu">&lt;.&gt;</span> rest&#39;, rest&#39; <span class="fu">&lt;.&gt;</span> left&#39;, rest&#39;)</a>
<a class="sourceLine" id="cb65-37" data-line-number="37">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb65-38" data-line-number="38">      (first, top, left, rest) <span class="fu">=</span> msplit m</a>
<a class="sourceLine" id="cb65-39" data-line-number="39">      first&#39; <span class="fu">=</span> star first</a>
<a class="sourceLine" id="cb65-40" data-line-number="40">      top&#39; <span class="fu">=</span> first&#39; <span class="fu">&lt;.&gt;</span> top</a>
<a class="sourceLine" id="cb65-41" data-line-number="41">      left&#39; <span class="fu">=</span> left <span class="fu">&lt;.&gt;</span> first&#39;</a>
<a class="sourceLine" id="cb65-42" data-line-number="42">      rest&#39; <span class="fu">=</span> star (rest <span class="fu">&lt;+&gt;</span> left&#39; <span class="fu">&lt;.&gt;</span> top)</a></code></pre></div>
<h2 id="permutation-parsing">Permutation parsing</h2>
<p>A lot of the use from semirings comes from â€œattachingâ€ them to other values. Attaching a semiring to effects (in the form of an applicative) can give you <em>repetition</em> of those effects. The excellent <a href="http://hackage.haskell.org/package/ReplicateEffects">ReplicateEffects</a> library explores this concept in depth.</p>
<p>Itâ€™s based on this type:</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb66-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Replicate</span> a b</a>
<a class="sourceLine" id="cb66-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb66-3" data-line-number="3">  <span class="fu">|</span> <span class="dt">Cons</span> (<span class="dt">Maybe</span> b) (<span class="dt">Replicate</span> a (a <span class="ot">-&gt;</span> b))</a></code></pre></div>
<p>This type can be made to conform to <code class="sourceCode haskell"><span class="dt">Semiring</span></code> (and <code class="sourceCode haskell"><span class="dt">Starsemiring</span></code>, etc) trivially.</p>
<p>In the simplest case, it has the same behaviour as <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Monad.html#v:replicateM"><code class="sourceCode haskell">replicateM</code></a>. Even the more complex combinators, like <code class="sourceCode haskell">atLeast</code>, can be built on <code class="sourceCode haskell"><span class="dt">Alternative</span></code>:</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb67-1" data-line-number="1"><span class="ot">atLeast ::</span> <span class="dt">Alternative</span> f <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f [a]</a>
<a class="sourceLine" id="cb67-2" data-line-number="2">atLeast m f <span class="fu">=</span> go (max <span class="dv">0</span> m) <span class="kw">where</span></a>
<a class="sourceLine" id="cb67-3" data-line-number="3">  go <span class="dv">0</span> <span class="fu">=</span> many f</a>
<a class="sourceLine" id="cb67-4" data-line-number="4">  go n <span class="fu">=</span> liftA2 (<span class="fu">:</span>) f (go (n<span class="fu">-</span><span class="dv">1</span>))</a>
<a class="sourceLine" id="cb67-5" data-line-number="5">  </a>
<a class="sourceLine" id="cb67-6" data-line-number="6"><span class="ot">atMost ::</span> <span class="dt">Alternative</span> f <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f [a]</a>
<a class="sourceLine" id="cb67-7" data-line-number="7">atMost m f <span class="fu">=</span> go (max <span class="dv">0</span> m) <span class="kw">where</span></a>
<a class="sourceLine" id="cb67-8" data-line-number="8">  go <span class="dv">0</span> <span class="fu">=</span> pure []</a>
<a class="sourceLine" id="cb67-9" data-line-number="9">  go n <span class="fu">=</span> liftA2 (<span class="fu">:</span>) f (go (n<span class="fu">-</span><span class="dv">1</span>)) <span class="fu">&lt;|&gt;</span> pure []</a></code></pre></div>
<p>There are two main benefits over using the standard alternative implementation. First, you can choose greedy or lazy evaluation of the effects <em>after</em> the replication is built.</p>
<p>Secondly, the <em>order</em> of the effects doesnâ€™t have to be specified. This allows you to execute permutations of the effects, in a permutation parser, for instance. The permutation is totally decoupled from the declaration of the repetition (itâ€™s in a totally separate library, in fact: <a href="http://hackage.haskell.org/package/PermuteEffects">PermuteEffects</a>). Its construction is reminiscent of the <a href="https://hackage.haskell.org/package/free-4.12.4/docs/Control-Alternative-Free.html#t:AltF">free alternative</a>.</p>
<p>Having the replicate type conform to <code class="sourceCode haskell"><span class="dt">Semiring</span></code> is all well and good: what Iâ€™m interested in is seeing if its implementation is another semiring-based object in disguise. Iâ€™ll revisit this in a later post.</p>
<h2 id="algebraic-search">Algebraic Search</h2>
<p>List comprehension notation is one of my all-time favourite bits of syntactic sugar. It seems almost <em>too</em> declarative to have a reasonable implementation strategy. The vast majority of the time, it actually works in a sensible way. There are exceptions, though. Take a reasonable definition of a list of Pythagorean triples:</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb68-1" data-line-number="1">[ (x,y,z) <span class="fu">|</span> x <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span>], y <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span>], z <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span>], x<span class="fu">*</span>x <span class="fu">+</span> y<span class="fu">*</span>y <span class="fu">==</span> z<span class="fu">*</span>z ]</a></code></pre></div>
<p>This expression will diverge without yielding a single triple. It will search through every possible value for <code class="sourceCode haskell">z</code> before incrementing either <code class="sourceCode haskell">x</code> or <code class="sourceCode haskell">y</code>. Since there are infinite values for <code class="sourceCode haskell">z</code>, it will never find a triple. In other words, vanilla list comprehensions in Haskell perform depth-first search.</p>
<p>In order to express other kinds of search (either breadth-first or depth-bounded), different monads are needed. These monads are explored in <span class="citation" data-cites="fischer_reinventing_2009">Fischer (<a href="#ref-fischer_reinventing_2009">2009</a>)</span> and <span class="citation" data-cites="spivey_algebras_2009">Spivey (<a href="#ref-spivey_algebras_2009">2009</a>)</span>.</p>
<p>You can actually use the <em>exact</em> same notation as above with arbitrary alternative monads using <code class="sourceCode haskell"><span class="fu">-</span><span class="dt">XMonadComprehensions</span></code> and <code class="sourceCode haskell"><span class="fu">-</span><span class="dt">XOverloadedLists</span></code>.</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb69-1" data-line-number="1"><span class="ot">trips ::</span> ( <span class="dt">Alternative</span> m</a>
<a class="sourceLine" id="cb69-2" data-line-number="2">         , <span class="dt">Monad</span> m</a>
<a class="sourceLine" id="cb69-3" data-line-number="3">         , <span class="dt">IsList</span> (m <span class="dt">Integer</span>)</a>
<a class="sourceLine" id="cb69-4" data-line-number="4">         , <span class="dt">Enum</span> (<span class="dt">Item</span> (m <span class="dt">Integer</span>))</a>
<a class="sourceLine" id="cb69-5" data-line-number="5">         , <span class="dt">Num</span> (<span class="dt">Item</span> (m <span class="dt">Integer</span>)))</a>
<a class="sourceLine" id="cb69-6" data-line-number="6">      <span class="ot">=&gt;</span> m (<span class="dt">Integer</span>,<span class="dt">Integer</span>,<span class="dt">Integer</span>)</a>
<a class="sourceLine" id="cb69-7" data-line-number="7">trips <span class="fu">=</span> [ (x,y,z) <span class="fu">|</span> x <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span>], y <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span>], z <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span>], x<span class="fu">*</span>x <span class="fu">+</span> y<span class="fu">*</span>y <span class="fu">==</span> z<span class="fu">*</span>z ]</a></code></pre></div>
<p>So then, hereâ€™s the challenge: swap in different <code class="sourceCode haskell">m</code>s via a type annotation, and prevent <code class="sourceCode haskell">trips</code> from diverging before getting any triples.</p>
<p>As one example, hereâ€™s some code adapted from <span class="citation" data-cites="fischer_reinventing_2009">Fischer (<a href="#ref-fischer_reinventing_2009">2009</a>)</span>:</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb70-1" data-line-number="1"><span class="kw">instance</span> (<span class="dt">Monoid</span> r, <span class="dt">Applicative</span> m) <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">ContT</span> r m a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb70-2" data-line-number="2">  mempty <span class="fu">=</span> <span class="dt">ContT</span> (const (pure mempty))</a>
<a class="sourceLine" id="cb70-3" data-line-number="3">  mappend (<span class="dt">ContT</span> f) (<span class="dt">ContT</span> g) <span class="fu">=</span> <span class="dt">ContT</span> (\x <span class="ot">-&gt;</span> liftA2 mappend (f x) (g x))</a>
<a class="sourceLine" id="cb70-4" data-line-number="4">  </a>
<a class="sourceLine" id="cb70-5" data-line-number="5"><span class="kw">newtype</span> <span class="dt">List</span> a <span class="fu">=</span> <span class="dt">List</span> </a>
<a class="sourceLine" id="cb70-6" data-line-number="6">  {<span class="ot"> runList ::</span> forall m<span class="fu">.</span> <span class="dt">Monoid</span> m <span class="ot">=&gt;</span> <span class="dt">Cont</span> m a } <span class="kw">deriving</span> <span class="dt">Functor</span></a>
<a class="sourceLine" id="cb70-7" data-line-number="7"></a>
<a class="sourceLine" id="cb70-8" data-line-number="8"><span class="kw">instance</span> <span class="dt">Foldable</span> <span class="dt">List</span> <span class="kw">where</span> foldMap <span class="fu">=</span> flip (runCont<span class="fu">.</span>runList)</a>
<a class="sourceLine" id="cb70-9" data-line-number="9">  </a>
<a class="sourceLine" id="cb70-10" data-line-number="10"><span class="kw">instance</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">List</span> a) <span class="kw">where</span> show <span class="fu">=</span> show <span class="fu">.</span> foldr (<span class="fu">:</span>) []</a>
<a class="sourceLine" id="cb70-11" data-line-number="11"></a>
<a class="sourceLine" id="cb70-12" data-line-number="12"><span class="kw">instance</span> <span class="dt">Monoid</span> (<span class="dt">List</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb70-13" data-line-number="13">  mappend (<span class="dt">List</span> x) (<span class="dt">List</span> y) <span class="fu">=</span> <span class="dt">List</span> (mappend x y)</a>
<a class="sourceLine" id="cb70-14" data-line-number="14">  mempty <span class="fu">=</span> <span class="dt">List</span> mempty</a>
<a class="sourceLine" id="cb70-15" data-line-number="15">  </a>
<a class="sourceLine" id="cb70-16" data-line-number="16"><span class="kw">instance</span> <span class="dt">Monoid</span> a <span class="ot">=&gt;</span> <span class="dt">Semiring</span> (<span class="dt">List</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb70-17" data-line-number="17">  zero <span class="fu">=</span> mempty</a>
<a class="sourceLine" id="cb70-18" data-line-number="18">  (<span class="fu">&lt;+&gt;</span>) <span class="fu">=</span> mappend</a>
<a class="sourceLine" id="cb70-19" data-line-number="19">  (<span class="fu">&lt;.&gt;</span>) <span class="fu">=</span> liftA2 mappend</a>
<a class="sourceLine" id="cb70-20" data-line-number="20">  one <span class="fu">=</span> pure mempty</a>
<a class="sourceLine" id="cb70-21" data-line-number="21"></a>
<a class="sourceLine" id="cb70-22" data-line-number="22"><span class="ot">bfs ::</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb70-23" data-line-number="23">bfs <span class="fu">=</span> toList <span class="fu">.</span> fold <span class="fu">.</span> levels <span class="fu">.</span> anyOf</a>
<a class="sourceLine" id="cb70-24" data-line-number="24"></a>
<a class="sourceLine" id="cb70-25" data-line-number="25"><span class="kw">newtype</span> <span class="dt">Levels</span> a <span class="fu">=</span> <span class="dt">Levels</span> {<span class="ot"> levels ::</span> [<span class="dt">List</span> a] } <span class="kw">deriving</span> <span class="dt">Functor</span></a>
<a class="sourceLine" id="cb70-26" data-line-number="26"></a>
<a class="sourceLine" id="cb70-27" data-line-number="27"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Levels</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb70-28" data-line-number="28">  pure x <span class="fu">=</span> <span class="dt">Levels</span> [pure x]</a>
<a class="sourceLine" id="cb70-29" data-line-number="29">  <span class="dt">Levels</span> fs <span class="fu">&lt;*&gt;</span> <span class="dt">Levels</span> xs <span class="fu">=</span> <span class="dt">Levels</span> [ f <span class="fu">&lt;*&gt;</span> x <span class="fu">|</span> f <span class="ot">&lt;-</span> fs, x <span class="ot">&lt;-</span> xs ]</a>
<a class="sourceLine" id="cb70-30" data-line-number="30">  </a>
<a class="sourceLine" id="cb70-31" data-line-number="31"><span class="kw">instance</span> <span class="dt">Alternative</span> <span class="dt">Levels</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb70-32" data-line-number="32">  empty <span class="fu">=</span> <span class="dt">Levels</span> []</a>
<a class="sourceLine" id="cb70-33" data-line-number="33">  <span class="dt">Levels</span> x <span class="fu">&lt;|&gt;</span> <span class="dt">Levels</span> y <span class="fu">=</span> <span class="dt">Levels</span> (mempty <span class="fu">:</span> merge x y)</a>
<a class="sourceLine" id="cb70-34" data-line-number="34"></a>
<a class="sourceLine" id="cb70-35" data-line-number="35"><span class="kw">instance</span> <span class="dt">IsList</span> (<span class="dt">List</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb70-36" data-line-number="36">  <span class="kw">type</span> <span class="dt">Item</span> (<span class="dt">List</span> a) <span class="fu">=</span> a</a>
<a class="sourceLine" id="cb70-37" data-line-number="37">  fromList <span class="fu">=</span> anyOf</a>
<a class="sourceLine" id="cb70-38" data-line-number="38">  toList <span class="fu">=</span> foldr (<span class="fu">:</span>) []</a>
<a class="sourceLine" id="cb70-39" data-line-number="39">  </a>
<a class="sourceLine" id="cb70-40" data-line-number="40"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">List</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb70-41" data-line-number="41">  pure x <span class="fu">=</span> <span class="dt">List</span> (pure x)</a>
<a class="sourceLine" id="cb70-42" data-line-number="42">  (<span class="fu">&lt;*&gt;</span>) <span class="fu">=</span> ap</a>
<a class="sourceLine" id="cb70-43" data-line-number="43"></a>
<a class="sourceLine" id="cb70-44" data-line-number="44"><span class="kw">instance</span> <span class="dt">Alternative</span> <span class="dt">List</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb70-45" data-line-number="45">  empty <span class="fu">=</span> mempty</a>
<a class="sourceLine" id="cb70-46" data-line-number="46">  (<span class="fu">&lt;|&gt;</span>) <span class="fu">=</span> mappend</a>
<a class="sourceLine" id="cb70-47" data-line-number="47"></a>
<a class="sourceLine" id="cb70-48" data-line-number="48"><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">List</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb70-49" data-line-number="49">  x <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> foldMap f x</a>
<a class="sourceLine" id="cb70-50" data-line-number="50"></a>
<a class="sourceLine" id="cb70-51" data-line-number="51"><span class="ot">anyOf ::</span> (<span class="dt">Alternative</span> m, <span class="dt">Foldable</span> f) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> m a</a>
<a class="sourceLine" id="cb70-52" data-line-number="52">anyOf <span class="fu">=</span> getAlt <span class="fu">.</span> foldMap (<span class="dt">Alt</span> <span class="fu">.</span> pure)</a>
<a class="sourceLine" id="cb70-53" data-line-number="53"></a>
<a class="sourceLine" id="cb70-54" data-line-number="54"><span class="ot">merge ::</span> [<span class="dt">List</span> a] <span class="ot">-&gt;</span> [<span class="dt">List</span> a] <span class="ot">-&gt;</span> [<span class="dt">List</span> a]</a>
<a class="sourceLine" id="cb70-55" data-line-number="55">merge []      ys    <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb70-56" data-line-number="56">merge xs      []    <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb70-57" data-line-number="57">merge (x<span class="fu">:</span>xs) (y<span class="fu">:</span>ys) <span class="fu">=</span> mappend x y <span class="fu">:</span> merge xs ys</a></code></pre></div>
<div class="sourceCode" id="cb71"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell"><a class="sourceLine" id="cb71-1" data-line-number="1">take <span class="dv">3</span> (bfs trips)</a>
<a class="sourceLine" id="cb71-2" data-line-number="2">[(<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>),(<span class="dv">4</span>,<span class="dv">3</span>,<span class="dv">5</span>),(<span class="dv">6</span>,<span class="dv">8</span>,<span class="dv">10</span>)]</a></code></pre></div>
<p>The only relevance to semirings is the merge function. The semiring over lists is the semiring over polynomials:</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb72-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Semiring</span> a <span class="ot">=&gt;</span> <span class="dt">Semiring</span> [a] <span class="kw">where</span></a>
<a class="sourceLine" id="cb72-2" data-line-number="2">  one <span class="fu">=</span> [one]</a>
<a class="sourceLine" id="cb72-3" data-line-number="3">  zero <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb72-4" data-line-number="4">  [] <span class="fu">&lt;+&gt;</span> ys <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb72-5" data-line-number="5">  xs <span class="fu">&lt;+&gt;</span> [] <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb72-6" data-line-number="6">  (x<span class="fu">:</span>xs) <span class="fu">&lt;+&gt;</span> (y<span class="fu">:</span>ys) <span class="fu">=</span> (x <span class="fu">&lt;+&gt;</span> y) <span class="fu">:</span> (xs <span class="fu">&lt;+&gt;</span> ys)</a>
<a class="sourceLine" id="cb72-7" data-line-number="7">  [] <span class="fu">&lt;.&gt;</span> _ <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb72-8" data-line-number="8">  _ <span class="fu">&lt;.&gt;</span> [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb72-9" data-line-number="9">  (x<span class="fu">:</span>xs) <span class="fu">&lt;.&gt;</span> (y<span class="fu">:</span>ys) <span class="fu">=</span></a>
<a class="sourceLine" id="cb72-10" data-line-number="10">    (x <span class="fu">&lt;.&gt;</span> y) <span class="fu">:</span> (map (x <span class="fu">&lt;.&gt;</span>) ys <span class="fu">&lt;+&gt;</span> map (<span class="fu">&lt;.&gt;</span> y) xs <span class="fu">&lt;+&gt;</span> (xs <span class="fu">&lt;.&gt;</span> ys))</a></code></pre></div>
<p>The <code class="sourceCode haskell"><span class="fu">&lt;+&gt;</span></code> is the same as the <code class="sourceCode haskell">merge</code> function. I think the <code class="sourceCode haskell"><span class="fu">&lt;.&gt;</span></code> might be a more valid definition of the <code class="sourceCode haskell"><span class="fu">&lt;*&gt;</span></code> function, also.</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb73-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Levels</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb73-2" data-line-number="2">  pure x <span class="fu">=</span> <span class="dt">Levels</span> [pure x]</a>
<a class="sourceLine" id="cb73-3" data-line-number="3">  <span class="dt">Levels</span> [] <span class="fu">&lt;*&gt;</span> _ <span class="fu">=</span> <span class="dt">Levels</span> []</a>
<a class="sourceLine" id="cb73-4" data-line-number="4">  _ <span class="fu">&lt;*&gt;</span> <span class="dt">Levels</span> [] <span class="fu">=</span> <span class="dt">Levels</span> []</a>
<a class="sourceLine" id="cb73-5" data-line-number="5">  <span class="dt">Levels</span> (f<span class="fu">:</span>fs) <span class="fu">&lt;*&gt;</span> <span class="dt">Levels</span> (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="dt">Levels</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb73-6" data-line-number="6">    (f <span class="fu">&lt;*&gt;</span> x) <span class="fu">:</span> levels (<span class="dt">Levels</span> (fmap (f <span class="fu">&lt;*&gt;</span>) xs) </a>
<a class="sourceLine" id="cb73-7" data-line-number="7">             <span class="fu">&lt;|&gt;</span> <span class="dt">Levels</span> (fmap (<span class="fu">&lt;*&gt;</span> x) fs)</a>
<a class="sourceLine" id="cb73-8" data-line-number="8">             <span class="fu">&lt;|&gt;</span> (<span class="dt">Levels</span> fs <span class="fu">&lt;*&gt;</span> <span class="dt">Levels</span> xs))</a></code></pre></div>
<h2 id="conclusion">Conclusion</h2>
<p>Iâ€™ve only scratched the surface of this abstraction. There are several other interesting semirings: polynomials, logs, Viterbi, Åukasiewicz, languages, multisets, bidirectional parsers, etc. Hopefully Iâ€™ll eventually be able to put this stuff into a library or something. In the meantime, I definitely will write some posts on the application to context-free parsing, bidirectional parsing (I just read <span class="citation" data-cites="breitner_showcasing_2016">Breitner (<a href="#ref-breitner_showcasing_2016">2016</a>)</span>) and search.</p>
<h2 id="references" class="unnumbered">References</h2>
<div id="refs" class="references">
<div id="ref-boom_further_1981">
<p>Boom, H. J. 1981. â€œFurther thoughts on Abstracto.â€ <em>Working Paper ELC-9, IFIP WG 2.1</em>. <a href="http://www.kestrel.edu/home/people/meertens/publications/papers/Abstracto_reader.pdf" class="uri">http://www.kestrel.edu/home/people/meertens/publications/papers/Abstracto_reader.pdf</a>.</p>
</div>
<div id="ref-breitner_showcasing_2016">
<p>Breitner, Joachim. 2016. â€œShowcasing Applicative.â€ <em>Joachim Breitnerâ€™s Blog</em>. <a href="http://www.joachim-breitner.de/blog/710-Showcasing_Applicative" class="uri">http://www.joachim-breitner.de/blog/710-Showcasing_Applicative</a>.</p>
</div>
<div id="ref-doel_free_2015">
<p>Doel, Dan. 2015. â€œFree Monoids in Haskell.â€ <em>The Comonad.Reader</em>. <a href="http://comonad.com/reader/2015/free-monoids-in-haskell/" class="uri">http://comonad.com/reader/2015/free-monoids-in-haskell/</a>.</p>
</div>
<div id="ref-dolan_fun_2013">
<p>Dolan, Stephen. 2013. â€œFun with semirings: A functional pearl on the abuse of linear algebra.â€ In, 48:101. ACM Press. doi:<a href="https://doi.org/10.1145/2500365.2500613">10.1145/2500365.2500613</a>. <a href="https://www.cl.cam.ac.uk/~sd601/papers/semirings.pdf" class="uri">https://www.cl.cam.ac.uk/~sd601/papers/semirings.pdf</a>.</p>
</div>
<div id="ref-droste_semirings_2009">
<p>Droste, Manfred, and Werner Kuich. 2009. â€œSemirings and Formal Power Series.â€ In <em>Handbook of Weighted Automata</em>, ed by. Manfred Droste, Werner Kuich, and Heiko Vogler, 1:3â€“28. Monographs in Theoretical Computer Science. An EATCS Series. Berlin, Heidelberg: Springer Berlin Heidelberg. <a href="http://staff.mmcs.sfedu.ru/~ulysses/Edu/Marktoberdorf_2009/working_material/Esparsa/Kuich.%20Semirings%20and%20FPS.pdf">http://staff.mmcs.sfedu.ru/~ulysses/Edu/Marktoberdorf_2009/working_material/Esparsa/Kuich.%20Semirings%20and%20FPS.pdf</a>.</p>
</div>
<div id="ref-erwig_functional_2006">
<p>Erwig, Martin, and Steve Kollmansberger. 2006. â€œFunctional pearls: Probabilistic functional programming in Haskell.â€ <em>Journal of Functional Programming</em> 16 (1): 21â€“34. doi:<a href="https://doi.org/10.1017/S0956796805005721">10.1017/S0956796805005721</a>. <a href="http://web.engr.oregonstate.edu/~erwig/papers/abstracts.html#JFP06a" class="uri">http://web.engr.oregonstate.edu/~erwig/papers/abstracts.html#JFP06a</a>.</p>
</div>
<div id="ref-fischer_reinventing_2009">
<p>Fischer, Sebastian. 2009. â€œReinventing Haskell Backtracking.â€ In <em>Informatik 2009, Im Fokus das Leben (ATPSâ€™09)</em>. GI Edition. <a href="http://www-ps.informatik.uni-kiel.de/~sebf/data/pub/atps09.pdf" class="uri">http://www-ps.informatik.uni-kiel.de/~sebf/data/pub/atps09.pdf</a>.</p>
</div>
<div id="ref-hirschowitz_modules_2010">
<p>Hirschowitz, AndrÃ©, and Marco Maggesi. 2010. â€œModules over monads and initial semantics.â€ <em>Information and Computation</em> 208 (5). Special Issue: 14th Workshop on Logic, Language, Information and Computation (WoLLIC 2007) (May): 545â€“564. doi:<a href="https://doi.org/10.1016/j.ic.2009.07.003">10.1016/j.ic.2009.07.003</a>. <a href="https://pdfs.semanticscholar.org/3e0c/c79e8cda9246cb954da6fd8aaaa394fecdc3.pdf" class="uri">https://pdfs.semanticscholar.org/3e0c/c79e8cda9246cb954da6fd8aaaa394fecdc3.pdf</a>.</p>
</div>
<div id="ref-kidd_build_2007">
<p>Kidd, Eric. 2007. â€œBuild your own probability monads.â€ <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.129.9502&amp;rep=rep1&amp;type=pdf" class="uri">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.129.9502&amp;rep=rep1&amp;type=pdf</a>.</p>
</div>
<div id="ref-kmett_free_2011">
<p>Kmett, Edward. 2011a. â€œFree Monads for Less (Part 2 of 3): Yoneda.â€ <em>The Comonad.Reader</em>. <a href="http://comonad.com/reader/2011/free-monads-for-less-2/" class="uri">http://comonad.com/reader/2011/free-monads-for-less-2/</a>.</p>
</div>
<div id="ref-kmett_modules_2011">
<p>â€”â€”â€”. 2011b. â€œModules and Functional Linear Functionals.â€ <em>The Comonad.Reader</em>. <a href="http://comonad.com/reader/2011/free-modules-and-functional-linear-functionals/" class="uri">http://comonad.com/reader/2011/free-modules-and-functional-linear-functionals/</a>.</p>
</div>
<div id="ref-larsen_memory_2011">
<p>Larsen, Ken Friis. 2011. â€œMemory Efficient Implementation of Probability Monads.â€ <a href="http://www.diku.dk/~kflarsen/t/ProbMonad-unpublished.pdf" class="uri">http://www.diku.dk/~kflarsen/t/ProbMonad-unpublished.pdf</a>.</p>
</div>
<div id="ref-oconnor_very_2011">
<p>Oâ€™Connor, Russell. 2011. â€œA Very General Method of Computing Shortest Paths.â€ <em>Russell Oâ€™Connorâ€™s Blog</em>. <a href="http://r6.ca/blog/20110808T035622Z.html" class="uri">http://r6.ca/blog/20110808T035622Z.html</a>.</p>
</div>
<div id="ref-piponi_monad_2009">
<p>Piponi, Dan. 2009. â€œA Monad for Combinatorial Search with Heuristics.â€ <em>A Neighborhood of Infinity</em>. <a href="http://blog.sigfpe.com/2009/07/monad-for-combinatorial-search-with.html" class="uri">http://blog.sigfpe.com/2009/07/monad-for-combinatorial-search-with.html</a>.</p>
</div>
<div id="ref-rivas_monoids_2015">
<p>Rivas, Exequiel, Mauro Jaskelioff, and Tom Schrijvers. 2015. â€œFrom monoids to near-semirings: The essence of MonadPlus and Alternative.â€ In <em>Proceedings of the 17th International Symposium on Principles and Practice of Declarative Programming</em>, 196â€“207. ACM. doi:<a href="https://doi.org/10.1145/2790449.2790514">10.1145/2790449.2790514</a>. <a href="http://www.fceia.unr.edu.ar/~mauro/pubs/FromMonoidstoNearsemirings.pdf" class="uri">http://www.fceia.unr.edu.ar/~mauro/pubs/FromMonoidstoNearsemirings.pdf</a>.</p>
</div>
<div id="ref-spivey_algebras_2009">
<p>Spivey, J. Michael. 2009. â€œAlgebras for combinatorial search.â€ <em>Journal of Functional Programming</em> 19 (3-4) (July): 469â€“487. doi:<a href="https://doi.org/10.1017/S0956796809007321">10.1017/S0956796809007321</a>. <a href="https://pdfs.semanticscholar.org/db3e/373bb6e7e7837ebc524da0a25903958554ed.pdf" class="uri">https://pdfs.semanticscholar.org/db3e/373bb6e7e7837ebc524da0a25903958554ed.pdf</a>.</p>
</div>
</div>
]]></description>
    <pubDate>Thu, 17 Nov 2016 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2016-11-17-semirings-lhs.html</guid>
    <dc:creator>Donnacha OisÃ­n Kidney</dc:creator>
</item>
<item>
    <title>Probability Trees</title>
    <link>https://doisinkidney.com/posts/2016-09-30-prob-trees-lhs.html</link>
    <description><![CDATA[<div class="info">
    Posted on September 30, 2016
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Probability.html">Probability</a>
    
</div>

<div class="sourceCode" id="cb1"><pre class="sourceCode haskell literate hidden_source"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">{-# language DeriveFunctor, DeriveFoldable #-}</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="ot">{-# language PatternSynonyms, ViewPatterns #-}</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="kw">module</span> <span class="dt">ProbTree</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="kw">import</span> <span class="dt">Data.Monoid</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map.Strict</span> <span class="kw">as</span> <span class="dt">Map</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"><span class="kw">import</span> <span class="dt">Data.Map.Strict</span> (<span class="dt">Map</span>)</a>
<a class="sourceLine" id="cb1-9" data-line-number="9"><span class="kw">import</span> <span class="dt">Control.Arrow</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10"><span class="kw">import</span> <span class="dt">Data.Ratio</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11"><span class="kw">import</span> <span class="dt">Data.Foldable</span></a></code></pre></div>
<p>Previously, I tried to figure out how to make the probability monad more â€œlistyâ€. I read a little more about the topic <span class="citation" data-cites="erwig_functional_2006 kidd_build_2007">(especially Erwig and Kollmansberger <a href="#ref-erwig_functional_2006">2006</a>; and Kidd <a href="#ref-kidd_build_2007">2007</a>)</span>.</p>
<p>I then thought about what a probability monad would look like if it was based on other data structures. I feel like the standard version really wants to be:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">ProperProb</span> a <span class="fu">=</span> <span class="dt">ProperProb</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  {<span class="ot"> yes ::</span> <span class="dt">Map</span> a (<span class="dt">Product</span> <span class="dt">Rational</span>) }</a></code></pre></div>
<p>But of course a monad instance isnâ€™t allowed.</p>
<p>Similar to a map, though, is a binary tree:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">data</span> <span class="dt">BinaryTree</span> a <span class="fu">=</span> <span class="dt">Leaf</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">                  <span class="fu">|</span> <span class="dt">Node</span> (<span class="dt">BinaryTree</span> a) a (<span class="dt">BinaryTree</span> a)</a></code></pre></div>
<p>And it feels better for probability - <em>flatter</em>, somehow. Transmuting it into a probability-thing:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Odds</span> a <span class="fu">=</span> <span class="dt">Certain</span> a</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">            <span class="fu">|</span> <span class="dt">Choice</span> (<span class="dt">Odds</span> a) <span class="dt">Rational</span> (<span class="dt">Odds</span> a)</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">            <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Functor</span>, <span class="dt">Foldable</span>, <span class="dt">Show</span>)</a></code></pre></div>
<p>That looks good to me. A choice between two different branches feels more natural than a choice between a head and a tail.</p>
<p>The fold is similar to before, with an unfold for good measure:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">foldOdds ::</span> (b <span class="ot">-&gt;</span> <span class="dt">Rational</span> <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">foldOdds f b <span class="fu">=</span> r <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  r (<span class="dt">Certain</span> x) <span class="fu">=</span> b x</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">  r (<span class="dt">Choice</span> xs p ys) <span class="fu">=</span> f (r xs) p (r ys)</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">  </a>
<a class="sourceLine" id="cb5-6" data-line-number="6"><span class="ot">unfoldOdds ::</span> (b <span class="ot">-&gt;</span> <span class="dt">Either</span> a (b,<span class="dt">Rational</span>,b)) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Odds</span> a</a>
<a class="sourceLine" id="cb5-7" data-line-number="7">unfoldOdds f <span class="fu">=</span> r <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8">  r b <span class="fu">=</span> <span class="kw">case</span> f b <span class="kw">of</span></a>
<a class="sourceLine" id="cb5-9" data-line-number="9">    <span class="dt">Left</span> a <span class="ot">-&gt;</span> <span class="dt">Certain</span> a</a>
<a class="sourceLine" id="cb5-10" data-line-number="10">    <span class="dt">Right</span> (x,p,y) <span class="ot">-&gt;</span> <span class="dt">Choice</span> (r x) p (r y)</a>
<a class="sourceLine" id="cb5-11" data-line-number="11">  </a>
<a class="sourceLine" id="cb5-12" data-line-number="12"><span class="ot">fi ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb5-13" data-line-number="13">fi <span class="dt">True</span>  t _ <span class="fu">=</span> t</a>
<a class="sourceLine" id="cb5-14" data-line-number="14">fi <span class="dt">False</span> _ f <span class="fu">=</span> f</a></code></pre></div>
<p>I changed the pattern synonym a little:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="ot">unRatio ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Rational</span> <span class="ot">-&gt;</span> (a,a)</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">unRatio <span class="fu">=</span> numerator   <span class="fu">&amp;&amp;&amp;</span> denominator </a>
<a class="sourceLine" id="cb6-4" data-line-number="4">      <span class="fu">&gt;&gt;&gt;</span> fromInteger <span class="fu">***</span> fromInteger</a>
<a class="sourceLine" id="cb6-5" data-line-number="5"></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">pattern n <span class="fu">:%</span> d <span class="ot">&lt;-</span> (unRatio <span class="ot">-&gt;</span> (n,d))</a></code></pre></div>
<p>Then, the <code class="sourceCode haskell">probOf</code> function:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">probOf ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">probOf e <span class="fu">=</span> foldOdds f b <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  b x <span class="fu">=</span> fi (e <span class="fu">==</span> x) <span class="dv">1</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">  f x (n<span class="fu">:%</span>d) y <span class="fu">=</span> (x <span class="fu">*</span> n <span class="fu">+</span> y <span class="fu">*</span> d) <span class="fu">/</span> (n <span class="fu">+</span> d)</a></code></pre></div>
<p>This version doesnâ€™t have the option for short-circuiting on the first value it finds.</p>
<p>For generating from lists, you can try to evenly divide the list among each branch.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">fromListOdds ::</span> (([b], <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Integer</span>) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Odds</span> a)</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">fromListOdds fr e <span class="fu">=</span> r <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  r [] <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">  r xs <span class="fu">=</span> <span class="dt">Just</span> (unfoldOdds f (xs, length xs))</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">  f ([x],_) <span class="fu">=</span> <span class="dt">Left</span> (e x)</a>
<a class="sourceLine" id="cb8-6" data-line-number="6">  f (xs ,n) <span class="fu">=</span> <span class="dt">Right</span> ((ys,l), fr (ys,l) <span class="fu">%</span> fr (zs,r), (zs,r)) <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-7" data-line-number="7">    l <span class="fu">=</span> n <span class="ot">`div`</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8">    r <span class="fu">=</span> n <span class="fu">-</span> l</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">    (ys,zs) <span class="fu">=</span> splitAt l xs</a>
<a class="sourceLine" id="cb8-10" data-line-number="10"></a>
<a class="sourceLine" id="cb8-11" data-line-number="11"><span class="ot">equalOdds ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Odds</span> a)</a>
<a class="sourceLine" id="cb8-12" data-line-number="12">equalOdds <span class="fu">=</span> fromListOdds (fromIntegral <span class="fu">.</span> snd) id</a>
<a class="sourceLine" id="cb8-13" data-line-number="13"></a>
<a class="sourceLine" id="cb8-14" data-line-number="14"><span class="ot">fromDistrib ::</span> [(a,<span class="dt">Integer</span>)] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Odds</span> a)</a>
<a class="sourceLine" id="cb8-15" data-line-number="15">fromDistrib <span class="fu">=</span> fromListOdds (sum <span class="fu">.</span> map snd <span class="fu">.</span> fst) fst</a></code></pre></div>
<p>Whatâ€™s really nice about this version is the fact that the old <code class="sourceCode haskell">append</code> is just the <code class="sourceCode haskell"><span class="dt">Choice</span></code> constructor, leaving the instances to be really nice:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">flatten ::</span> <span class="dt">Odds</span> (<span class="dt">Odds</span> a) <span class="ot">-&gt;</span> <span class="dt">Odds</span> a</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">flatten <span class="fu">=</span> foldOdds <span class="dt">Choice</span> id</a>
<a class="sourceLine" id="cb9-3" data-line-number="3"></a>
<a class="sourceLine" id="cb9-4" data-line-number="4"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Odds</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  pure <span class="fu">=</span> <span class="dt">Certain</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6">  fs <span class="fu">&lt;*&gt;</span> xs <span class="fu">=</span> flatten (fmap (<span class="fu">&lt;$&gt;</span> xs) fs)</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">  </a>
<a class="sourceLine" id="cb9-8" data-line-number="8"><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Odds</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-9" data-line-number="9">  x <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> flatten (f <span class="fu">&lt;$&gt;</span> x)</a></code></pre></div>
<p>Finally, as a bonus, to remove duplicates:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">lcd ::</span> <span class="dt">Foldable</span> f <span class="ot">=&gt;</span> f <span class="dt">Rational</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">lcd <span class="fu">=</span> foldl&#39; (\a e <span class="ot">-&gt;</span> lcm a (denominator e)) <span class="dv">1</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3"></a>
<a class="sourceLine" id="cb10-4" data-line-number="4"><span class="ot">toDistrib ::</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> [(a,<span class="dt">Integer</span>)]</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">toDistrib <span class="fu">=</span> factorOut <span class="fu">.</span> foldOdds f b <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-6" data-line-number="6">  b x <span class="fu">=</span> [(x,<span class="dv">1</span>)]</a>
<a class="sourceLine" id="cb10-7" data-line-number="7">  f l p r <span class="fu">=</span> (map<span class="fu">.</span>fmap) (n<span class="fu">%</span>t<span class="fu">*</span>) l <span class="fu">++</span> (map<span class="fu">.</span>fmap) (d<span class="fu">%</span>t<span class="fu">*</span>) r <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-8" data-line-number="8">    n <span class="fu">=</span> numerator p</a>
<a class="sourceLine" id="cb10-9" data-line-number="9">    d <span class="fu">=</span> denominator p</a>
<a class="sourceLine" id="cb10-10" data-line-number="10">    t <span class="fu">=</span> n <span class="fu">+</span> d</a>
<a class="sourceLine" id="cb10-11" data-line-number="11">  factorOut xs <span class="fu">=</span> (map<span class="fu">.</span>fmap) (numerator <span class="fu">.</span> (lcd&#39;<span class="fu">*</span>)) xs <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-12" data-line-number="12">    lcd&#39; <span class="fu">=</span> fromIntegral <span class="fu">.</span> lcd <span class="fu">.</span> map snd <span class="fu">$</span> xs</a>
<a class="sourceLine" id="cb10-13" data-line-number="13"></a>
<a class="sourceLine" id="cb10-14" data-line-number="14"><span class="ot">counts ::</span> (<span class="dt">Ord</span> a, <span class="dt">Num</span> n) <span class="ot">=&gt;</span> [(a,n)] <span class="ot">-&gt;</span> [(a,n)]</a>
<a class="sourceLine" id="cb10-15" data-line-number="15">counts <span class="fu">=</span> </a>
<a class="sourceLine" id="cb10-16" data-line-number="16">  Map.assocs <span class="fu">.</span> </a>
<a class="sourceLine" id="cb10-17" data-line-number="17">  Map.fromListWith (<span class="fu">+</span>)</a>
<a class="sourceLine" id="cb10-18" data-line-number="18">      </a>
<a class="sourceLine" id="cb10-19" data-line-number="19"><span class="ot">compress ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Odds</span> a</a>
<a class="sourceLine" id="cb10-20" data-line-number="20">compress xs <span class="fu">=</span> <span class="kw">let</span> <span class="dt">Just</span> ys <span class="fu">=</span> (fromDistrib <span class="fu">.</span> counts <span class="fu">.</span> toDistrib) xs <span class="kw">in</span> ys</a></code></pre></div>
<p>After reading yet more on this, I found that the main issue with the monad is its performance. Two articles in particular: <span class="citation" data-cites="larsen_memory_2011">Larsen (<a href="#ref-larsen_memory_2011">2011</a>)</span>, and <span class="citation" data-cites="scibior_practical_2015">Åšcibior, Ghahramani, and Gordon (<a href="#ref-scibior_practical_2015">2015</a>)</span>, refer to a GADT implementation of the monad which maximises laziness.</p>
<h3 id="references" class="unnumbered">References</h3>
<div id="refs" class="references">
<div id="ref-erwig_functional_2006">
<p>Erwig, Martin, and Steve Kollmansberger. 2006. â€œFunctional pearls: Probabilistic functional programming in Haskell.â€ <em>Journal of Functional Programming</em> 16 (1): 21â€“34. doi:<a href="https://doi.org/10.1017/S0956796805005721">10.1017/S0956796805005721</a>.</p>
</div>
<div id="ref-kidd_build_2007">
<p>Kidd, Eric. 2007. â€œBuild your own probability monads.â€</p>
</div>
<div id="ref-larsen_memory_2011">
<p>Larsen, Ken Friis. 2011. â€œMemory Efficient Implementation of Probability Monads.â€</p>
</div>
<div id="ref-scibior_practical_2015">
<p>Åšcibior, Adam, Zoubin Ghahramani, and Andrew D. Gordon. 2015. â€œPractical Probabilistic Programming with Monads.â€ In <em>Proceedings of the 2015 ACM SIGPLAN Symposium on Haskell</em>, 50:165â€“176. Haskell â€™15. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/2804302.2804317">10.1145/2804302.2804317</a>.</p>
</div>
</div>
]]></description>
    <pubDate>Fri, 30 Sep 2016 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2016-09-30-prob-trees-lhs.html</guid>
    <dc:creator>Donnacha OisÃ­n Kidney</dc:creator>
</item>
<item>
    <title>A Different Probability Monad</title>
    <link>https://doisinkidney.com/posts/2016-09-27-odds-lhs.html</link>
    <description><![CDATA[<div class="info">
    Posted on September 27, 2016
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Probability.html">Probability</a>
    
</div>

<p>One of the more unusual monads is the â€œprobability monadâ€:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell literate hidden_source"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">{-# language PatternSynonyms, ViewPatterns #-}</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="ot">{-# language DeriveFunctor, DeriveFoldable #-}</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="ot">{-# language BangPatterns #-}</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="kw">module</span> <span class="dt">Prob</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="kw">import</span> <span class="dt">Control.Arrow</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"><span class="kw">import</span> <span class="dt">Data.Ratio</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9"><span class="kw">import</span> <span class="dt">Data.Foldable</span></a></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Probability</span> a <span class="fu">=</span> <span class="dt">Probability</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  {<span class="ot"> runProb ::</span> [(a,<span class="dt">Rational</span>)] }</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  </a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="kw">data</span> <span class="dt">Coin</span> <span class="fu">=</span> <span class="dt">Heads</span> <span class="fu">|</span> <span class="dt">Tails</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"></a>
<a class="sourceLine" id="cb2-6" data-line-number="6"><span class="ot">toss ::</span> <span class="dt">Probability</span> <span class="dt">Coin</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">toss <span class="fu">=</span> <span class="dt">Probability</span> [(<span class="dt">Heads</span>, <span class="dv">1</span> <span class="fu">%</span> <span class="dv">2</span>), (<span class="dt">Tails</span>, <span class="dv">1</span> <span class="fu">%</span> <span class="dv">2</span>)]</a></code></pre></div>
<p>Although itâ€™s a little inefficient, itâ€™s an elegant representation. Iâ€™ve written about it before <a href="2015-08-03-monty-hall.html">here</a>.</p>
<p>It has some notable deficiencies, though. For instance: the user has to constantly check that all the probabilities add up to one. Its list can be empty, which doesnâ€™t make sense. Also, individual outcomes can appear more than once in the same list.</p>
<p>A first go a fixing the problem might look something like this:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Distrib</span> a <span class="fu">=</span> <span class="dt">Distrib</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  {<span class="ot"> runDist ::</span> [(a,<span class="dt">Rational</span>)] }</a>
<a class="sourceLine" id="cb3-3" data-line-number="3"></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="ot">tossProb ::</span> <span class="dt">Distrib</span> <span class="dt">Coin</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">tossProb <span class="fu">=</span> <span class="dt">Distrib</span> [(<span class="dt">Heads</span>, <span class="dv">1</span>), (<span class="dt">Tails</span>, <span class="dv">1</span>)]</a></code></pre></div>
<p>The type is the same as before: itâ€™s the semantics which have changed. The second field of the tuples no longer have to add up to one. The list can still be empty, though, and now finding the probability of, say, the head, looks like this:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">probHead ::</span> <span class="dt">Distrib</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">probHead (<span class="dt">Distrib</span> xs<span class="fu">@</span>((_,p)<span class="fu">:</span>_)) <span class="fu">=</span> p <span class="fu">/</span> sum [ q <span class="fu">|</span> (_,q) <span class="ot">&lt;-</span> xs ]</a></code></pre></div>
<p>Infinite lists arenâ€™t possible, either.</p>
<p>One other way to look at the problem is to mimic the structure of cons-lists. Something like this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Odds</span> a <span class="fu">=</span> <span class="dt">Certainly</span> a</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">            <span class="fu">|</span> <span class="dt">Odds</span> a <span class="dt">Rational</span> (<span class="dt">Odds</span> a)</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">            <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Functor</span>, <span class="dt">Foldable</span>, <span class="dt">Show</span>)</a></code></pre></div>
<p>Here, the <code class="sourceCode haskell"><span class="dt">Odds</span></code> constructor (analogous to <code class="sourceCode haskell">(<span class="fu">:</span>)</code>) contains the betting-style odds of the head element vs. <em>the rest of the list</em>. The coin from before is represented by:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">tossOdds ::</span> <span class="dt">Odds</span> <span class="dt">Coin</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">tossOdds <span class="fu">=</span> <span class="dt">Odds</span> <span class="dt">Heads</span> (<span class="dv">1</span> <span class="fu">%</span> <span class="dv">1</span>) (<span class="dt">Certainly</span> <span class="dt">Tails</span>)</a></code></pre></div>
<p>This representation has tons of nice properties. First, letâ€™s use some pattern-synonym magic for rationals:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1">pattern<span class="ot"> (:%) ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Rational</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">pattern n <span class="fu">:%</span> d <span class="ot">&lt;-</span> (numerator <span class="fu">&amp;&amp;&amp;</span> denominator <span class="ot">-&gt;</span> (n,d)) <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  n <span class="fu">:%</span> d <span class="fu">=</span> n <span class="fu">%</span> d</a></code></pre></div>
<p>Then, finding the probability of the head element is this:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">probHeadOdds ::</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">probHeadOdds (<span class="dt">Certainly</span> _) <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">probHeadOdds (<span class="dt">Odds</span> _ (n <span class="fu">:%</span> d) _) <span class="fu">=</span> n <span class="fu">:%</span> (n <span class="fu">+</span> d)</a></code></pre></div>
<p>The representation can handle infinite lists no problem:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1">probHeadOdds (<span class="dt">Odds</span> <span class="ch">&#39;a&#39;</span> (<span class="dv">1</span> <span class="fu">:%</span> <span class="dv">1</span>) undefined)</a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="dv">1</span> <span class="fu">%</span> <span class="dv">2</span></a></code></pre></div>
<p>Taking the tail preserves semantics, also. To do some more involved manipulation, a fold helper is handy:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">foldOdds ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Rational</span> <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">foldOdds f b <span class="fu">=</span> r <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  r (<span class="dt">Certainly</span> x) <span class="fu">=</span> b x</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">  r (<span class="dt">Odds</span> x p xs) <span class="fu">=</span> f x p (r xs)</a></code></pre></div>
<p>You can use this function to find the probability of a given item:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">probOfEvent ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2">probOfEvent e <span class="fu">=</span> foldOdds f b <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  b x <span class="fu">=</span> <span class="kw">if</span> e <span class="fu">==</span> x <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4">  f x n r <span class="fu">=</span> (<span class="kw">if</span> e <span class="fu">==</span> x <span class="kw">then</span> n <span class="kw">else</span> r) <span class="fu">/</span> (n <span class="fu">+</span> <span class="dv">1</span>)</a></code></pre></div>
<p>This assumes that each item only occurs once. A function which combines multiple events might look like this:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="ot">probOf ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">probOf p <span class="fu">=</span> foldOdds f b <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">  b x <span class="fu">=</span> <span class="kw">if</span> p x <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">  f x n r <span class="fu">=</span> (<span class="kw">if</span> p x <span class="kw">then</span> r <span class="fu">+</span> n <span class="kw">else</span> r) <span class="fu">/</span> (n <span class="fu">+</span> <span class="dv">1</span>)</a></code></pre></div>
<p>Some utility functions to create <code class="sourceCode haskell"><span class="dt">Odds</span></code>:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="ot">equalOdds ::</span> <span class="dt">Foldable</span> f <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Odds</span> a)</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">equalOdds xs <span class="fu">=</span> <span class="kw">case</span> length xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">  <span class="dv">0</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4">  n <span class="ot">-&gt;</span> <span class="dt">Just</span> (foldr f undefined xs (n <span class="fu">-</span> <span class="dv">1</span>)) <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5">    f y a <span class="dv">0</span> <span class="fu">=</span> <span class="dt">Certainly</span> y</a>
<a class="sourceLine" id="cb13-6" data-line-number="6">    f y a n <span class="fu">=</span> <span class="dt">Odds</span> y (<span class="dv">1</span> <span class="fu">%</span> fromIntegral n) (a (n <span class="fu">-</span> <span class="dv">1</span>))</a>
<a class="sourceLine" id="cb13-7" data-line-number="7"></a>
<a class="sourceLine" id="cb13-8" data-line-number="8"><span class="ot">fromDistrib ::</span> [(a,<span class="dt">Integer</span>)] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Odds</span> a)</a>
<a class="sourceLine" id="cb13-9" data-line-number="9">fromDistrib [] <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb13-10" data-line-number="10">fromDistrib xs <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span> f (tot<span class="fu">*</span>lst) xs <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-11" data-line-number="11">  (tot,lst) <span class="fu">=</span> foldl&#39; (\(<span class="fu">!</span>t,_) e <span class="ot">-&gt;</span> (t<span class="fu">+</span>e,e)) (<span class="dv">0</span>,undefined) (map snd xs)</a>
<a class="sourceLine" id="cb13-12" data-line-number="12">  f _ [(x,_)] <span class="fu">=</span> <span class="dt">Certainly</span> x</a>
<a class="sourceLine" id="cb13-13" data-line-number="13">  f n ((x,p)<span class="fu">:</span>xs) <span class="fu">=</span> <span class="dt">Odds</span> x (mp <span class="fu">%</span> np) (f np xs) <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-14" data-line-number="14">    mp <span class="fu">=</span> p <span class="fu">*</span> lst</a>
<a class="sourceLine" id="cb13-15" data-line-number="15">    np <span class="fu">=</span> n <span class="fu">-</span> mp</a>
<a class="sourceLine" id="cb13-16" data-line-number="16">                  </a>
<a class="sourceLine" id="cb13-17" data-line-number="17"><span class="ot">probOfEach ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span></a>
<a class="sourceLine" id="cb13-18" data-line-number="18">probOfEach x xs <span class="fu">=</span> probOf (x<span class="fu">==</span>) xs</a>
<a class="sourceLine" id="cb13-19" data-line-number="19"></a>
<a class="sourceLine" id="cb13-20" data-line-number="20"><span class="ot">propOf ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Rational</span></a>
<a class="sourceLine" id="cb13-21" data-line-number="21">propOf _ [] <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb13-22" data-line-number="22">propOf x xs <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">.</span> uncurry (<span class="fu">%</span>) <span class="fu">$</span></a>
<a class="sourceLine" id="cb13-23" data-line-number="23">  foldl&#39; (\(<span class="fu">!</span>n,<span class="fu">!</span>m) e <span class="ot">-&gt;</span> (<span class="kw">if</span> x <span class="fu">==</span> e <span class="kw">then</span> n<span class="fu">+</span><span class="dv">1</span> <span class="kw">else</span> n, m<span class="fu">+</span><span class="dv">1</span>)) (<span class="dv">0</span>,<span class="dv">0</span>) xs</a></code></pre></div>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell literate prop"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1">propOf x xs <span class="fu">==</span> fmap (probOfEach x) (equalOdds xs)</a></code></pre></div>
<p>And finally, the instances:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="ot">append ::</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span> <span class="ot">-&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Odds</span> a</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">append <span class="fu">=</span> foldOdds f <span class="dt">Odds</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-3" data-line-number="3">  f e r a p ys <span class="fu">=</span> <span class="dt">Odds</span> e ip (a op ys) <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-4" data-line-number="4">    ip <span class="fu">=</span> p <span class="fu">*</span> r <span class="fu">/</span> (p <span class="fu">+</span> r <span class="fu">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">    op <span class="fu">=</span> p <span class="fu">/</span> (r <span class="fu">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb15-6" data-line-number="6"></a>
<a class="sourceLine" id="cb15-7" data-line-number="7"><span class="ot">flatten ::</span> <span class="dt">Odds</span> (<span class="dt">Odds</span> a) <span class="ot">-&gt;</span> <span class="dt">Odds</span> a</a>
<a class="sourceLine" id="cb15-8" data-line-number="8">flatten <span class="fu">=</span> foldOdds append id</a>
<a class="sourceLine" id="cb15-9" data-line-number="9"></a>
<a class="sourceLine" id="cb15-10" data-line-number="10"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Odds</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-11" data-line-number="11">  pure <span class="fu">=</span> <span class="dt">Certainly</span></a>
<a class="sourceLine" id="cb15-12" data-line-number="12">  fs <span class="fu">&lt;*&gt;</span> xs <span class="fu">=</span> flatten (fmap (<span class="fu">&lt;$&gt;</span> xs) fs)</a>
<a class="sourceLine" id="cb15-13" data-line-number="13">  </a>
<a class="sourceLine" id="cb15-14" data-line-number="14"><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Odds</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-15" data-line-number="15">  x <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> flatten (f <span class="fu">&lt;$&gt;</span> x)</a></code></pre></div>
]]></description>
    <pubDate>Tue, 27 Sep 2016 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2016-09-27-odds-lhs.html</guid>
    <dc:creator>Donnacha OisÃ­n Kidney</dc:creator>
</item>
<item>
    <title>Revisiting a Trie in Haskell</title>
    <link>https://doisinkidney.com/posts/2016-09-26-revisiting-trie-lhs.html</link>
    <description><![CDATA[<div class="info">
    Posted on September 26, 2016
</div>
<div class="info">
    
        Part 2 of a <a href="/series/tries.html">2-part series on tries</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Data%20Structures.html">Data Structures</a>
    
</div>

<h1 id="conforming-to-foldable">Conforming to Foldable</h1>
<p>When I ended the last post, I had a nice <code class="sourceCode haskell"><span class="dt">Trie</span></code> datatype, with plenty of functions, but I couldnâ€™t get it to conform to the standard Haskell classes. The problem was to do with the type variables in the Trie:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell literate hidden_source"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">{-# language GADTs, FlexibleInstances, TypeFamilies #-}</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="ot">{-# language DeriveFoldable, DeriveFunctor, DeriveTraversable #-}</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="ot">{-# language FunctionalDependencies, FlexibleInstances #-}</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="kw">module</span> <span class="dt">Tries</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map.Strict</span> <span class="kw">as</span> <span class="dt">Map</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"><span class="kw">import</span> <span class="dt">Data.Map.Strict</span> (<span class="dt">Map</span>)</a>
<a class="sourceLine" id="cb1-9" data-line-number="9"><span class="kw">import</span> <span class="dt">Data.Foldable</span> <span class="kw">hiding</span> (toList)</a>
<a class="sourceLine" id="cb1-10" data-line-number="10"><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (lookup)</a>
<a class="sourceLine" id="cb1-11" data-line-number="11"><span class="kw">import</span> <span class="dt">Data.Monoid</span></a>
<a class="sourceLine" id="cb1-12" data-line-number="12"><span class="kw">import</span> <span class="dt">GHC.Exts</span> (<span class="dt">IsList</span>(..))</a></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> <span class="dt">OldTrie</span> a <span class="fu">=</span> <span class="dt">OldTrie</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  {<span class="ot"> otEndHere  ::</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  ,<span class="ot"> otChildren ::</span> <span class="dt">Map</span> a (<span class="dt">OldTrie</span> a) }</a></code></pre></div>
<p>Although the type variable is <code class="sourceCode haskell">a</code>, the trie really contains <em>lists</em> of <code class="sourceCode haskell">a</code>s. At least, thatâ€™s whatâ€™s reflected in functions like <code class="sourceCode haskell">insert</code>, <code class="sourceCode haskell">member</code>, etc.:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">member ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Ord</span> a) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">OldTrie</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">member <span class="fu">=</span> foldr f otEndHere <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">  f e a <span class="fu">=</span> maybe <span class="dt">False</span> a <span class="fu">.</span> Map.lookup e <span class="fu">.</span> otChildren</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">  </a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="ot">otInsert ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Ord</span> a) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">OldTrie</span> a <span class="ot">-&gt;</span> <span class="dt">OldTrie</span> a</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">otInsert <span class="fu">=</span> foldr f b <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7">  b (<span class="dt">OldTrie</span> _ c) <span class="fu">=</span> <span class="dt">OldTrie</span> <span class="dt">True</span> c</a>
<a class="sourceLine" id="cb3-8" data-line-number="8">  f e a (<span class="dt">OldTrie</span> n c) <span class="fu">=</span> <span class="dt">OldTrie</span> n (Map.alter (<span class="dt">Just</span> <span class="fu">.</span> a <span class="fu">.</span> fold) e c)</a>
<a class="sourceLine" id="cb3-9" data-line-number="9">  </a>
<a class="sourceLine" id="cb3-10" data-line-number="10"><span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">OldTrie</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-11" data-line-number="11">  mempty <span class="fu">=</span> <span class="dt">OldTrie</span> <span class="dt">False</span> mempty</a>
<a class="sourceLine" id="cb3-12" data-line-number="12">  <span class="dt">OldTrie</span> v c <span class="ot">`mappend`</span> <span class="dt">OldTrie</span> t d <span class="fu">=</span> </a>
<a class="sourceLine" id="cb3-13" data-line-number="13">    <span class="dt">OldTrie</span> (v <span class="fu">||</span> t) (Map.unionWith (<span class="fu">&lt;&gt;</span>) c d)</a></code></pre></div>
<p>Realistically, the type which the trie contains is more like:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="dt">Foldable</span> f <span class="ot">=&gt;</span> <span class="dt">Trie</span> (f a)</a></code></pre></div>
<p>That signature strongly hints at GADTs, as was indicated by <a href="http://stackoverflow.com/questions/33469157/foldable-instance-for-a-trie-set">this stackoverflow answer</a>. The particular GADT which is applicable here is this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">data</span> <span class="dt">TrieSet</span> a <span class="kw">where</span> <span class="dt">TrieSet</span><span class="ot"> ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Map</span> a (<span class="dt">TrieSet</span> [a]) <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> [a]</a></code></pre></div>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell literate hidden_source"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">tsEndHere ::</span> <span class="dt">TrieSet</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">tsEndHere (<span class="dt">TrieSet</span> e _) <span class="fu">=</span> e</a>
<a class="sourceLine" id="cb6-3" data-line-number="3"></a>
<a class="sourceLine" id="cb6-4" data-line-number="4"><span class="ot">tsChildren ::</span> <span class="dt">TrieSet</span> [a] <span class="ot">-&gt;</span> <span class="dt">Map</span> a (<span class="dt">TrieSet</span> [a])</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">tsChildren (<span class="dt">TrieSet</span> _ c) <span class="fu">=</span> c</a>
<a class="sourceLine" id="cb6-6" data-line-number="6"></a>
<a class="sourceLine" id="cb6-7" data-line-number="7"><span class="ot">tsInsert ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Ord</span> a) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> [a] <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> [a]</a>
<a class="sourceLine" id="cb6-8" data-line-number="8">tsInsert <span class="fu">=</span> foldr f b <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-9" data-line-number="9"><span class="ot">  b ::</span> <span class="dt">TrieSet</span> [a] <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> [a]</a>
<a class="sourceLine" id="cb6-10" data-line-number="10"><span class="ot">  f ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> (<span class="dt">TrieSet</span> [a] <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> [a]) <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> [a] <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> [a]</a>
<a class="sourceLine" id="cb6-11" data-line-number="11"></a>
<a class="sourceLine" id="cb6-12" data-line-number="12">  b (<span class="dt">TrieSet</span> _ c) <span class="fu">=</span> <span class="dt">TrieSet</span> <span class="dt">True</span> c</a>
<a class="sourceLine" id="cb6-13" data-line-number="13">  f e a (<span class="dt">TrieSet</span> n c) <span class="fu">=</span> <span class="dt">TrieSet</span> n (Map.alter (<span class="dt">Just</span> <span class="fu">.</span> a <span class="fu">.</span> fold) e c)</a>
<a class="sourceLine" id="cb6-14" data-line-number="14">  </a>
<a class="sourceLine" id="cb6-15" data-line-number="15"><span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">TrieSet</span> [a]) <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-16" data-line-number="16">  mempty <span class="fu">=</span> <span class="dt">TrieSet</span> <span class="dt">False</span> Map.empty</a>
<a class="sourceLine" id="cb6-17" data-line-number="17">  <span class="dt">TrieSet</span> v c <span class="ot">`mappend`</span> <span class="dt">TrieSet</span> t d <span class="fu">=</span> </a>
<a class="sourceLine" id="cb6-18" data-line-number="18">    <span class="dt">TrieSet</span> (v <span class="fu">||</span> t) (Map.unionWith (<span class="fu">&lt;&gt;</span>) c d)</a></code></pre></div>
<p>Why lists and not a general <code class="sourceCode haskell"><span class="dt">Foldable</span></code>? Well, for the particular use I had in mind (conforming to the <code class="sourceCode haskell"><span class="dt">Foldable</span></code> typeclass), I need <code class="sourceCode haskell">(<span class="fu">:</span>)</code>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Foldable</span> <span class="dt">TrieSet</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  foldr f b (<span class="dt">TrieSet</span> e c) <span class="fu">=</span> <span class="kw">if</span> e <span class="kw">then</span> f [] r <span class="kw">else</span> r <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">    r <span class="fu">=</span> Map.foldrWithKey (flip <span class="fu">.</span> g <span class="fu">.</span> (<span class="fu">:</span>)) b c</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">    g k <span class="fu">=</span> foldr (f <span class="fu">.</span> k)</a></code></pre></div>
<p>With some more helper functions, the interface becomes pretty nice:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">TrieSet</span> [a]) <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  showsPrec d t <span class="fu">=</span> </a>
<a class="sourceLine" id="cb8-3" data-line-number="3">    showParen </a>
<a class="sourceLine" id="cb8-4" data-line-number="4">      (d <span class="fu">&gt;</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">      (showString <span class="st">&quot;fromList &quot;</span> <span class="fu">.</span> shows (foldr (<span class="fu">:</span>) [] t))</a>
<a class="sourceLine" id="cb8-6" data-line-number="6"></a>
<a class="sourceLine" id="cb8-7" data-line-number="7"><span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">IsList</span> (<span class="dt">TrieSet</span> [a]) <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8">  <span class="kw">type</span> <span class="dt">Item</span> (<span class="dt">TrieSet</span> [a]) <span class="fu">=</span> [a]</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">  fromList <span class="fu">=</span> foldr tsInsert mempty</a>
<a class="sourceLine" id="cb8-10" data-line-number="10">  toList <span class="fu">=</span> foldr (<span class="fu">:</span>) []</a></code></pre></div>
<p>The trie has the side-effect of lexicographically sorting what itâ€™s given:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell literate example hidden_source"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="fu">:</span>set <span class="fu">-</span><span class="dt">XGADTs</span></a></code></pre></div>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">fromList [<span class="st">&quot;ced&quot;</span>, <span class="st">&quot;abc&quot;</span>, <span class="st">&quot;ced&quot;</span>, <span class="st">&quot;cb&quot;</span>, <span class="st">&quot;ab&quot;</span>]<span class="ot"> ::</span> <span class="dt">TrieSet</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">fromList [<span class="st">&quot;ab&quot;</span>,<span class="st">&quot;abc&quot;</span>,<span class="st">&quot;cb&quot;</span>,<span class="st">&quot;ced&quot;</span>]</a></code></pre></div>
<h1 id="further-generalizing">Further Generalizing</h1>
<p>Most implementations of tries that Iâ€™ve seen are map-like data structures, rather than set-like. In other words, instead of holding a <code class="sourceCode haskell"><span class="dt">Bool</span></code> at the value position, it holds a <code class="sourceCode haskell"><span class="dt">Maybe</span></code> something.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Trie</span> a b <span class="fu">=</span> <span class="dt">Trie</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2">  {<span class="ot"> endHere  ::</span> b</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  ,<span class="ot"> children ::</span> <span class="dt">Map</span> a (<span class="dt">Trie</span> a b) </a>
<a class="sourceLine" id="cb11-4" data-line-number="4">  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>, <span class="dt">Functor</span>, <span class="dt">Foldable</span>, <span class="dt">Traversable</span>)</a></code></pre></div>
<p>This is a much more straightforward datatype. <code class="sourceCode haskell"><span class="dt">Foldable</span></code> can even be automatically derived.</p>
<p>However, I havenâ€™t made the <code class="sourceCode haskell">endHere</code> field a <code class="sourceCode haskell"><span class="dt">Maybe</span> a</code>. I want to be able to write something like this:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">type</span> <span class="dt">TrieSet</span> [a] <span class="fu">=</span> <span class="dt">Trie</span> a <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="kw">type</span> <span class="dt">TrieMap</span> a b <span class="fu">=</span> <span class="dt">Trie</span> a (<span class="dt">Maybe</span> b)</a></code></pre></div>
<p>And have it automatically choose the implementation of the functions I need<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>.</p>
<p>To do that, though, Iâ€™ll need to write the base functions, agnostic of the type of <code>b</code>. I <em>can</em> rely on something like <code class="sourceCode haskell"><span class="dt">Monoid</span></code>, though:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">instance</span> (<span class="dt">Ord</span> a, <span class="dt">Monoid</span> b) <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Trie</span> a b) <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">  mempty <span class="fu">=</span> <span class="dt">Trie</span> mempty Map.empty</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">  mappend (<span class="dt">Trie</span> v k) (<span class="dt">Trie</span> t l) <span class="fu">=</span> </a>
<a class="sourceLine" id="cb13-4" data-line-number="4">    <span class="dt">Trie</span> (v <span class="fu">&lt;&gt;</span> t) (Map.unionWith (<span class="fu">&lt;&gt;</span>) k l)</a></code></pre></div>
<p>In fact, quite a lot of functions naturally lend themselves to this fold + monoid style:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1">lookup<span class="ot"> ::</span> (<span class="dt">Ord</span> a, <span class="dt">Monoid</span> b, <span class="dt">Foldable</span> f) </a>
<a class="sourceLine" id="cb14-2" data-line-number="2">       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Trie</span> a b <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">lookup <span class="fu">=</span> foldr f endHere <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-4" data-line-number="4">  f e a <span class="fu">=</span> foldMap a <span class="fu">.</span> Map.lookup e <span class="fu">.</span> children</a>
<a class="sourceLine" id="cb14-5" data-line-number="5"></a>
<a class="sourceLine" id="cb14-6" data-line-number="6"><span class="ot">insert&#39; ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Ord</span> a, <span class="dt">Monoid</span> b) </a>
<a class="sourceLine" id="cb14-7" data-line-number="7">       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Trie</span> a b <span class="ot">-&gt;</span> <span class="dt">Trie</span> a b</a>
<a class="sourceLine" id="cb14-8" data-line-number="8">insert&#39; xs v <span class="fu">=</span> foldr f b xs <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-9" data-line-number="9">  b (<span class="dt">Trie</span> p c) <span class="fu">=</span> <span class="dt">Trie</span> (v <span class="fu">&lt;&gt;</span> p) c</a>
<a class="sourceLine" id="cb14-10" data-line-number="10">  f e a (<span class="dt">Trie</span> n c) <span class="fu">=</span> </a>
<a class="sourceLine" id="cb14-11" data-line-number="11">    <span class="dt">Trie</span> n (Map.alter (<span class="dt">Just</span> <span class="fu">.</span> a <span class="fu">.</span> fold) e c) </a></code></pre></div>
<p>A monoid is needed for the values, though, and neither <code class="sourceCode haskell"><span class="dt">Bool</span></code> nor <code class="sourceCode haskell"><span class="ot">âˆ€</span> a<span class="fu">.</span> <span class="dt">Maybe</span> a</code> conform to <code class="sourceCode haskell"><span class="dt">Monoid</span></code>. Looking back to the implementation of the trie-set, the <code class="sourceCode haskell">(<span class="fu">||</span>)</code> function has been replaced by <code class="sourceCode haskell">mappend</code>. There <em>is</em> a newtype wrapper in <code class="sourceCode haskell"><span class="dt">Data.Monoid</span></code> which has exactly this behaviour, though: <code class="sourceCode haskell"><span class="dt">Any</span></code>.</p>
<p>Using that, the type signatures specialize to:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="kw">type</span> <span class="dt">TrieSet</span> a <span class="fu">=</span> <span class="dt">Trie</span> a <span class="dt">Any</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2">lookup<span class="ot"> ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) </a>
<a class="sourceLine" id="cb15-3" data-line-number="3">       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> a <span class="ot">-&gt;</span> <span class="dt">Any</span></a>
<a class="sourceLine" id="cb15-4" data-line-number="4"><span class="ot">insert ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) </a>
<a class="sourceLine" id="cb15-5" data-line-number="5">       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Any</span> <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> a <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> a</a></code></pre></div>
<p>Similarly, for <code class="sourceCode haskell"><span class="dt">Maybe</span></code>, thereâ€™s both <code class="sourceCode haskell"><span class="dt">First</span></code> and <code class="sourceCode haskell"><span class="dt">Last</span></code>. They have the behaviour:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell literate prop"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="dt">First</span> (<span class="dt">Just</span> x) <span class="fu">&lt;&gt;</span> <span class="dt">First</span> (<span class="dt">Just</span> y) <span class="fu">==</span> <span class="dt">First</span> (<span class="dt">Just</span> x)</a></code></pre></div>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell literate prop"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="dt">Last</span>  (<span class="dt">Just</span> x) <span class="fu">&lt;&gt;</span> <span class="dt">Last</span>  (<span class="dt">Just</span> y) <span class="fu">==</span> <span class="dt">Last</span>  (<span class="dt">Just</span> y)</a></code></pre></div>
<p>I think it makes more sense for a value inserted into a map to overwrite whatever was there before. Since the newer value is on the left in the <code class="sourceCode haskell">mappend</code>, then, <code class="sourceCode haskell"><span class="dt">First</span></code> makes most sense.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="kw">type</span> <span class="dt">TrieMap</span> a b <span class="fu">=</span> <span class="dt">Trie</span> a (<span class="dt">First</span> b)</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">lookup<span class="ot"> ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">TrieMap</span> a b <span class="ot">-&gt;</span> <span class="dt">First</span> b</a>
<a class="sourceLine" id="cb18-3" data-line-number="3"><span class="ot">insert ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) </a>
<a class="sourceLine" id="cb18-4" data-line-number="4">       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">First</span> b <span class="ot">-&gt;</span> <span class="dt">TrieMap</span> a b <span class="ot">-&gt;</span> <span class="dt">TrieMap</span> a b</a></code></pre></div>
<p>There are some other ways that you can interpret the monoid. For instance, subbing in <code class="sourceCode haskell"><span class="dt">Sum</span> <span class="dt">Int</span></code> gives you a bag-like trie:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="kw">type</span> <span class="dt">TrieBag</span> a <span class="fu">=</span> <span class="dt">Trie</span> a (<span class="dt">Sum</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">lookup<span class="ot"> ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">TrieBag</span> a <span class="ot">-&gt;</span> <span class="dt">Sum</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb19-3" data-line-number="3"><span class="ot">insert ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) </a>
<a class="sourceLine" id="cb19-4" data-line-number="4">       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Sum</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">TrieBag</span> a <span class="ot">-&gt;</span> <span class="dt">TrieBag</span> a</a></code></pre></div>
<p>This is a set which can store multiple copies of each member. Turned the other way around, a map which stores many values for each key looks like this:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="kw">type</span> <span class="dt">TrieBin</span> a b <span class="fu">=</span> <span class="dt">Trie</span> a [b]</a>
<a class="sourceLine" id="cb20-2" data-line-number="2">lookup<span class="ot"> ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">TrieBin</span> a b <span class="ot">-&gt;</span> [b]</a>
<a class="sourceLine" id="cb20-3" data-line-number="3"><span class="ot">insert ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) </a>
<a class="sourceLine" id="cb20-4" data-line-number="4">       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> <span class="dt">TrieBin</span> a b <span class="ot">-&gt;</span> <span class="dt">TrieBin</span> a b</a></code></pre></div>
<p>This method so far isnâ€™t really satisfying, though. Really, the <code class="sourceCode haskell">insert</code> signatures should look like this:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="ot">insert ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) </a>
<a class="sourceLine" id="cb21-2" data-line-number="2">       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">TrieMap</span> a b <span class="ot">-&gt;</span> <span class="dt">TrieMap</span> a b</a>
<a class="sourceLine" id="cb21-3" data-line-number="3"><span class="ot">insert ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f)</a>
<a class="sourceLine" id="cb21-4" data-line-number="4">       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">TrieBin</span> a b <span class="ot">-&gt;</span> <span class="dt">TrieBin</span> a b</a></code></pre></div>
<p>Modifying insert slightly, you can get exactly that:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="ot">insert ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Ord</span> a, <span class="dt">Applicative</span> c, <span class="dt">Monoid</span> (c b)) </a>
<a class="sourceLine" id="cb22-2" data-line-number="2">       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Trie</span> a (c b) <span class="ot">-&gt;</span> <span class="dt">Trie</span> a (c b)</a>
<a class="sourceLine" id="cb22-3" data-line-number="3">insert xs v <span class="fu">=</span> foldr f b xs <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-4" data-line-number="4">  b (<span class="dt">Trie</span> p c) <span class="fu">=</span> <span class="dt">Trie</span> (pure v <span class="fu">&lt;&gt;</span> p) c</a>
<a class="sourceLine" id="cb22-5" data-line-number="5">  f e a (<span class="dt">Trie</span> n c) <span class="fu">=</span> <span class="dt">Trie</span> n (Map.alter (<span class="dt">Just</span> <span class="fu">.</span> a <span class="fu">.</span> fold) e c)</a></code></pre></div>
<p><code class="sourceCode haskell">pure</code> from <code class="sourceCode haskell"><span class="dt">Applicative</span></code> is needed for the â€œembeddingâ€.</p>
<p>Similarly, the â€œinsertingâ€ for the set-like types isnâ€™t really right. The value argument is out of place. This should be the signature:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="ot">add ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) </a>
<a class="sourceLine" id="cb23-2" data-line-number="2">    <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> a <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> a</a>
<a class="sourceLine" id="cb23-3" data-line-number="3"><span class="ot">add ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f)</a>
<a class="sourceLine" id="cb23-4" data-line-number="4">    <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">TrieBin</span> a <span class="ot">-&gt;</span> <span class="dt">TrieBin</span> a</a></code></pre></div>
<p>In particular, while we have an â€œemptyâ€ thing (0, False) for monoids, we need a â€œoneâ€ thing (1, True) for this function. A semiring<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a> gives this exact method:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Monoid</span> a <span class="ot">=&gt;</span> <span class="dt">Semiring</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-2" data-line-number="2"><span class="ot">  one ::</span> a</a>
<a class="sourceLine" id="cb24-3" data-line-number="3"><span class="ot">  mul ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb24-4" data-line-number="4">  </a>
<a class="sourceLine" id="cb24-5" data-line-number="5"><span class="kw">instance</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Semiring</span> (<span class="dt">Sum</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-6" data-line-number="6">  one <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb24-7" data-line-number="7">  mul <span class="fu">=</span> (<span class="fu">*</span>)</a>
<a class="sourceLine" id="cb24-8" data-line-number="8"></a>
<a class="sourceLine" id="cb24-9" data-line-number="9"><span class="kw">instance</span> <span class="dt">Semiring</span> <span class="dt">Any</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-10" data-line-number="10">  one <span class="fu">=</span> <span class="dt">Any</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb24-11" data-line-number="11">  <span class="dt">Any</span> x <span class="ot">`mul`</span> <span class="dt">Any</span> y <span class="fu">=</span> <span class="dt">Any</span> (x <span class="fu">&amp;&amp;</span> y)</a></code></pre></div>
<p>This class is kind of like a combination of both monoid wrappers for both <code class="sourceCode haskell"><span class="dt">Int</span></code> and <code class="sourceCode haskell"><span class="dt">Bool</span></code>. You could take advantage of that:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1"></a>
<a class="sourceLine" id="cb25-2" data-line-number="2"><span class="kw">class</span> (<span class="dt">Monoid</span> add, <span class="dt">Monoid</span> mult)</a>
<a class="sourceLine" id="cb25-3" data-line-number="3">  <span class="ot">=&gt;</span> <span class="dt">SemiringIso</span> a add mult <span class="fu">|</span> a <span class="ot">-&gt;</span> add, a <span class="ot">-&gt;</span> mult <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-4" data-line-number="4"><span class="ot">    toAdd    ::</span> a <span class="ot">-&gt;</span> add</a>
<a class="sourceLine" id="cb25-5" data-line-number="5"><span class="ot">    fromAdd  ::</span> add <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb25-6" data-line-number="6"><span class="ot">    toMult   ::</span> a <span class="ot">-&gt;</span> mult</a>
<a class="sourceLine" id="cb25-7" data-line-number="7"><span class="ot">    fromMult ::</span> mult <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb25-8" data-line-number="8">  </a>
<a class="sourceLine" id="cb25-9" data-line-number="9">(<span class="fu">&lt;+&gt;</span>),<span class="ot"> (&lt;.&gt;) ::</span> <span class="dt">SemiringIso</span> a add mult <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb25-10" data-line-number="10"></a>
<a class="sourceLine" id="cb25-11" data-line-number="11">x <span class="fu">&lt;+&gt;</span> y <span class="fu">=</span> fromAdd  (toAdd  x <span class="fu">&lt;&gt;</span> toAdd  y)</a>
<a class="sourceLine" id="cb25-12" data-line-number="12">x <span class="fu">&lt;.&gt;</span> y <span class="fu">=</span> fromMult (toMult x <span class="fu">&lt;&gt;</span> toMult y)</a>
<a class="sourceLine" id="cb25-13" data-line-number="13"></a>
<a class="sourceLine" id="cb25-14" data-line-number="14"><span class="kw">instance</span> <span class="dt">SemiringIso</span> <span class="dt">Int</span> (<span class="dt">Sum</span> <span class="dt">Int</span>) (<span class="dt">Product</span> <span class="dt">Int</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-15" data-line-number="15">  toAdd    <span class="fu">=</span> <span class="dt">Sum</span></a>
<a class="sourceLine" id="cb25-16" data-line-number="16">  fromAdd  <span class="fu">=</span> getSum</a>
<a class="sourceLine" id="cb25-17" data-line-number="17">  toMult   <span class="fu">=</span> <span class="dt">Product</span></a>
<a class="sourceLine" id="cb25-18" data-line-number="18">  fromMult <span class="fu">=</span> getProduct</a>
<a class="sourceLine" id="cb25-19" data-line-number="19"></a>
<a class="sourceLine" id="cb25-20" data-line-number="20"><span class="kw">instance</span> <span class="dt">SemiringIso</span> <span class="dt">Bool</span> <span class="dt">Any</span> <span class="dt">All</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-21" data-line-number="21">  toAdd    <span class="fu">=</span> <span class="dt">Any</span></a>
<a class="sourceLine" id="cb25-22" data-line-number="22">  fromAdd  <span class="fu">=</span> getAny</a>
<a class="sourceLine" id="cb25-23" data-line-number="23">  toMult   <span class="fu">=</span> <span class="dt">All</span></a>
<a class="sourceLine" id="cb25-24" data-line-number="24">  fromMult <span class="fu">=</span> getAll</a></code></pre></div>
<p>But it seems like overkill.</p>
<p>Anyway, assuming that we have the functions from <code class="sourceCode haskell"><span class="dt">Semiring</span></code>, hereâ€™s the <code>add</code> function:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="ot">add ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Ord</span> a, <span class="dt">Semiring</span> b) </a>
<a class="sourceLine" id="cb26-2" data-line-number="2">    <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Trie</span> a b <span class="ot">-&gt;</span> <span class="dt">Trie</span> a b</a>
<a class="sourceLine" id="cb26-3" data-line-number="3">add xs <span class="fu">=</span> foldr f b xs <span class="kw">where</span></a>
<a class="sourceLine" id="cb26-4" data-line-number="4">  b (<span class="dt">Trie</span> p c) <span class="fu">=</span> <span class="dt">Trie</span> (one <span class="fu">&lt;&gt;</span> p) c</a>
<a class="sourceLine" id="cb26-5" data-line-number="5">  f e a (<span class="dt">Trie</span> n c) <span class="fu">=</span> </a>
<a class="sourceLine" id="cb26-6" data-line-number="6">    <span class="dt">Trie</span> n (Map.alter (<span class="dt">Just</span> <span class="fu">.</span> a <span class="fu">.</span> fold) e c)</a></code></pre></div>
<p>Now, expressions can be built up without specifying the specific monoid implementation, and the whole behaviour can be changed with a type signature:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell literate hidden_source"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="kw">instance</span> (<span class="dt">Ord</span> a, <span class="dt">Semiring</span> b) <span class="ot">=&gt;</span> <span class="dt">IsList</span> (<span class="dt">Trie</span> a b) <span class="kw">where</span></a>
<a class="sourceLine" id="cb27-2" data-line-number="2">  <span class="kw">type</span> <span class="dt">Item</span> (<span class="dt">Trie</span> a b) <span class="fu">=</span> [a]</a>
<a class="sourceLine" id="cb27-3" data-line-number="3">  fromList <span class="fu">=</span> foldr add mempty</a>
<a class="sourceLine" id="cb27-4" data-line-number="4">  toList <span class="fu">=</span> undefined</a>
<a class="sourceLine" id="cb27-5" data-line-number="5"><span class="ot">ans ::</span> <span class="dt">Semiring</span> b <span class="ot">=&gt;</span> b</a></code></pre></div>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1">ans <span class="fu">=</span> lookup <span class="st">&quot;abc&quot;</span> (fromList [<span class="st">&quot;abc&quot;</span>, <span class="st">&quot;def&quot;</span>, <span class="st">&quot;abc&quot;</span>, <span class="st">&quot;ghi&quot;</span>])</a></code></pre></div>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" data-line-number="1"><span class="ot">ans ::</span> <span class="dt">Sum</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb29-2" data-line-number="2"><span class="dt">Sum</span> {getSum <span class="fu">=</span> <span class="dv">2</span>}</a></code></pre></div>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="ot">ans ::</span> <span class="dt">Any</span></a>
<a class="sourceLine" id="cb30-2" data-line-number="2"><span class="dt">Any</span> {getAny <span class="fu">=</span> <span class="dt">True</span>}</a></code></pre></div>
<p>Slightly fuller implementations of all of these are available <a href="https://github.com/oisdk/hstrie">here</a>.</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Kind of like <a href="https://www.youtube.com/watch?v=3U3lV5VPmOU">program inference in lieu of type inference</a><a href="#fnref1" class="footnote-back">â†©</a></p></li>
<li id="fn2"><p>This isnâ€™t really a very good definition of semiring. While Haskell doesnâ€™t have this class in base, <a href="https://github.com/purescript/purescript-prelude/blob/master/src/Data/Semiring.purs">Purescript has it in their prelude.</a><a href="#fnref2" class="footnote-back">â†©</a></p></li>
</ol>
</section>
]]></description>
    <pubDate>Mon, 26 Sep 2016 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2016-09-26-revisiting-trie-lhs.html</guid>
    <dc:creator>Donnacha OisÃ­n Kidney</dc:creator>
</item>
<item>
    <title>Lenses are Static Selectors</title>
    <link>https://doisinkidney.com/posts/2016-06-16-lenses-are-static-selectors.html</link>
    <description><![CDATA[<div class="info">
    Posted on June 16, 2016
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Swift.html">Swift</a>
    
</div>

<p>So I donâ€™t really know what <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/KeyValueCoding/Articles/KeyValueCoding.html">KVC</a> is, or much about <code class="sourceCode scala">performSelector</code> functions. <a href="http://inessential.com/2016/05/20/updating_local_objects_with_server_objec">This</a> blogpost, from Brent Simmons, let me know a little bit about why I would want to use them.</p>
<p>It centred around removing code repetition of this type:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">if</span> localObject.<span class="fu">foo</span> != serverObject.<span class="fu">foo</span> {</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  localObject.<span class="fu">foo</span> = serverObject.<span class="fu">foo</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">}</a>
<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="kw">if</span> localObject.<span class="fu">bar</span> != serverObject.<span class="fu">bar</span> {</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">  localObject.<span class="fu">bar</span> = serverObject.<span class="fu">bar</span> <span class="co">// There was an (intentional)</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">}                                    <span class="co">// bug here in the original post</span></a></code></pre></div>
<p>To clean up the code, Brent used selector methods. At first, I was a little uncomfortable with the solution. As far as I could tell, the basis of a lot of this machinery used functions with types like this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb2-1" data-line-number="1">func <span class="fu">get</span>(fromSelector: String) -&gt; AnyObject?</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">func <span class="fu">set</span>(forSelector: String) -&gt; ()</a></code></pre></div>
<p>Which <em>seems</em> to be extremely dynamic. Stringly-typed and all that. Except that there are two different things going on here. One is the dynamic stuff; the ability to get rid of types when you need to. The other, though, has <em>nothing</em> to do with types. The other idea is being able to pass around something which can access the property (or method) of an object. Letâ€™s look at the code that was being repeated:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">if</span> localObject.<span class="fu">foo</span> != serverObject.<span class="fu">foo</span> {</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  localObject.<span class="fu">foo</span> = serverObject.<span class="fu">foo</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">}</a>
<a class="sourceLine" id="cb3-4" data-line-number="4"></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="kw">if</span> localObject.<span class="fu">bar</span> != serverObject.<span class="fu">bar</span> {</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">  localObject.<span class="fu">bar</span> = serverObject.<span class="fu">bar</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7">}</a></code></pre></div>
<p>The logical, obvious thing to do here is try refactor out the common elements. In fact, the only things that <em>differ</em> between the two actions above are the <code class="sourceCode scala">foo</code> and <code class="sourceCode scala">bar</code>. It would be great to be able to write a function like this:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb4-1" data-line-number="1">func <span class="fu">checkThenUpdate</span>(selector) {</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  <span class="kw">if</span> localObject.<span class="fu">selector</span> != serverObject.<span class="fu">selector</span> {</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">    localObject.<span class="fu">selector</span> = serverObject.<span class="fu">selector</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">  }</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">}</a></code></pre></div>
<p>And then maybe a single line like this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb5-1" data-line-number="1">[foo, bar, baz].<span class="fu">forEach</span>(checkThenUpdate)</a></code></pre></div>
<p>Thatâ€™s pretty obviously better. Itâ€™s just good programming: when faced with repetition, find the repeated part, and abstract it out. Is it more <em>dynamic</em> than the repetition, though? I donâ€™t think so. All you have to figure out is an appropriate type for the selector, and you can keep all of your static checking. To me, it seems a lot like a <a href="https://hackage.haskell.org/package/lens">lens</a>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb6-1" data-line-number="1">struct Lens&lt;Whole, Part&gt; {</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  let get: Whole -&gt; Part</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  let set: (Whole, Part) -&gt; Whole</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">}</a></code></pre></div>
<p>(This is a lens similar to the ones used in the <a href="http://hackage.haskell.org/package/data-lens">data-lens</a> library, in contrast to van Laarhoven lenses, or LensFamilies. LensFamilies are used in the <a href="https://hackage.haskell.org/package/lens">lens</a> package, and they allow you to change the type of the <code class="sourceCode scala">Part</code>. Theyâ€™re also just normal functions, rather than a separate type, so you can manipulate them in a pretty standard way. Swiftâ€™s type system isnâ€™t able to model those lenses, though, unfortunately.) It has two things: a getter and a setter. The getter is pretty obvious: it takes the object, and returns the property. The setter is a little more confusing. Itâ€™s taking an object, and the new property you want to stick in to the object, and returns the object with that property updated. For instance, if we were to make a <code class="sourceCode scala">Person</code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb7-1" data-line-number="1">struct LocalPerson {</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  <span class="kw">var</span> age: Int</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  <span class="kw">var</span> name: String</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">}</a></code></pre></div>
<p>We could then have a lens for the <code class="sourceCode scala">name</code> field like this:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb8-1" data-line-number="1">let localName: Lens&lt;LocalPerson,String&gt; = <span class="fu">Lens</span>(</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  get: { p in p.<span class="fu">name</span> },</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  set: { (oldPerson,newName) in</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">    <span class="kw">var</span> newPerson = oldPerson</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">    newPerson.<span class="fu">name</span> = newName</a>
<a class="sourceLine" id="cb8-6" data-line-number="6">    <span class="kw">return</span> newPerson</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">  }</a>
<a class="sourceLine" id="cb8-8" data-line-number="8">)</a></code></pre></div>
<p>And youâ€™d use it like this:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb9-1" data-line-number="1">let caoimhe = <span class="fu">LocalPerson</span>(age: <span class="dv">46</span>, name: <span class="st">&quot;caoimhe&quot;</span>)</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">localName.<span class="fu">get</span>(caoimhe) <span class="co">// 46</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">localName.<span class="fu">set</span>(caoimhe, <span class="st">&quot;breifne&quot;</span>) <span class="co">// LocalPerson(age: 46, name: &quot;breifne&quot;)</span></a></code></pre></div>
<p>Straight away, weâ€™re able to do (something) like the <code class="sourceCode scala">checkThenUpdate</code> function:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb10-1" data-line-number="1">func checkThenUpdate</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">  &lt;A: Equatable&gt;</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  (localLens: Lens&lt;LocalPerson,A&gt;, serverLens: Lens&lt;ServerPerson,A&gt;) {</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">  let serverProp = serverLens.<span class="fu">get</span>(serverObject)</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">  <span class="kw">if</span> localLens.<span class="fu">get</span>(localObject) != serverProp {</a>
<a class="sourceLine" id="cb10-6" data-line-number="6">    localObject = localLens.<span class="fu">set</span>(localObject,serverProp)</a>
<a class="sourceLine" id="cb10-7" data-line-number="7">  }</a>
<a class="sourceLine" id="cb10-8" data-line-number="8">}</a></code></pre></div>
<p>And it could be called pretty tersely:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="fu">checkThenUpdate</span>(localName, serverLens: serverName)</a></code></pre></div>
<p>The biggest problem with this approach, obviously, is the boilerplate. In Haskell, thatâ€™s solved with Template Haskell, so the lens code is generated for you. (Iâ€™d love to see something like that in Swift) Thereâ€™s a protocol-oriented spin on lenses, also. One of the variants on lenses in Haskell are called â€œclassy-lensesâ€. Thatâ€™s where, instead of just generating a lens with the same name as the field it looks into, you generate a typeclass (protocol) for anything with that lens. In Swift, it might work something like this:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb12-1" data-line-number="1">struct Place {</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">  <span class="kw">var</span> name: String</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">}</a>
<a class="sourceLine" id="cb12-4" data-line-number="4"></a>
<a class="sourceLine" id="cb12-5" data-line-number="5"><span class="co">// Instead of just having a lens for the name field, have a whole protocol</span></a>
<a class="sourceLine" id="cb12-6" data-line-number="6"><span class="co">// for things with a name field:</span></a>
<a class="sourceLine" id="cb12-7" data-line-number="7"></a>
<a class="sourceLine" id="cb12-8" data-line-number="8">protocol HasName {</a>
<a class="sourceLine" id="cb12-9" data-line-number="9">  associatedtype Name</a>
<a class="sourceLine" id="cb12-10" data-line-number="10">  static <span class="kw">var</span> name: Lens&lt;Self,Name&gt; { get }</a>
<a class="sourceLine" id="cb12-11" data-line-number="11">  <span class="kw">var</span> name: Name { get set }</a>
<a class="sourceLine" id="cb12-12" data-line-number="12">}</a>
<a class="sourceLine" id="cb12-13" data-line-number="13"></a>
<a class="sourceLine" id="cb12-14" data-line-number="14"><span class="co">// Because the mutable property is included in the protocol, you can rely on</span></a>
<a class="sourceLine" id="cb12-15" data-line-number="15"><span class="co">// it in extensions:</span></a>
<a class="sourceLine" id="cb12-16" data-line-number="16"></a>
<a class="sourceLine" id="cb12-17" data-line-number="17">extension HasName {</a>
<a class="sourceLine" id="cb12-18" data-line-number="18">  static <span class="kw">var</span> name: Lens&lt;Self,Name&gt; {</a>
<a class="sourceLine" id="cb12-19" data-line-number="19">    <span class="kw">return</span> <span class="fu">Lens</span>(</a>
<a class="sourceLine" id="cb12-20" data-line-number="20">      get: {$<span class="fl">0.</span>name},</a>
<a class="sourceLine" id="cb12-21" data-line-number="21">      set: { (w,p) in </a>
<a class="sourceLine" id="cb12-22" data-line-number="22">        <span class="kw">var</span> n = w</a>
<a class="sourceLine" id="cb12-23" data-line-number="23">        n.<span class="fu">name</span> = p</a>
<a class="sourceLine" id="cb12-24" data-line-number="24">        <span class="kw">return</span> n</a>
<a class="sourceLine" id="cb12-25" data-line-number="25">      }</a>
<a class="sourceLine" id="cb12-26" data-line-number="26">    )</a>
<a class="sourceLine" id="cb12-27" data-line-number="27">  }</a>
<a class="sourceLine" id="cb12-28" data-line-number="28">  <span class="kw">var</span> name: Name {</a>
<a class="sourceLine" id="cb12-29" data-line-number="29">    get { <span class="kw">return</span> Self.<span class="fu">name</span>.<span class="fu">get</span>(self) }</a>
<a class="sourceLine" id="cb12-30" data-line-number="30">    set { self = Self.<span class="fu">name</span>.<span class="fu">set</span>(self,newValue) }</a>
<a class="sourceLine" id="cb12-31" data-line-number="31">  }</a>
<a class="sourceLine" id="cb12-32" data-line-number="32">}</a>
<a class="sourceLine" id="cb12-33" data-line-number="33"></a>
<a class="sourceLine" id="cb12-34" data-line-number="34"><span class="co">// This way, you can provide either the lens or the property, and you get the</span></a>
<a class="sourceLine" id="cb12-35" data-line-number="35"><span class="co">// other for free.</span></a>
<a class="sourceLine" id="cb12-36" data-line-number="36"></a>
<a class="sourceLine" id="cb12-37" data-line-number="37">extension Place: HasName {}</a>
<a class="sourceLine" id="cb12-38" data-line-number="38"></a>
<a class="sourceLine" id="cb12-39" data-line-number="39"><span class="co">// Then, you can rely on that protocol, and all of the types:</span></a>
<a class="sourceLine" id="cb12-40" data-line-number="40"></a>
<a class="sourceLine" id="cb12-41" data-line-number="41">func checkEqualOnNames</a>
<a class="sourceLine" id="cb12-42" data-line-number="42">  &lt;A,B where A: HasName, B: HasName, A.<span class="fu">Name</span>: Equatable, A.<span class="fu">Name</span> == B.<span class="fu">Name</span>&gt;</a>
<a class="sourceLine" id="cb12-43" data-line-number="43">  (x: A, _ y: B) -&gt; Bool {</a>
<a class="sourceLine" id="cb12-44" data-line-number="44">    <span class="kw">return</span> x.<span class="fu">name</span> == y.<span class="fu">name</span></a>
<a class="sourceLine" id="cb12-45" data-line-number="45">}</a></code></pre></div>
<p>This protocol lets you do a kind of static <code class="sourceCode scala">respondsToSelector</code>, with all of the types intact. Other people have spoken about the other things you can do with lenses in Swift (<a href="https://www.youtube.com/watch?v=ofjehH9f-CU">Brandon Williams - Lenses in Swift</a>), like composing them together, chaining operations, etc. (One other thing they can emulate is <a href="https://gist.github.com/erica/6794d48d917e2084d6ed">method cascading</a>) Unfortunately, in current Swift, the boilerplate makes all of this a little unpleasant. Still, theyâ€™re an interesting idea, and they show how a good type system neednâ€™t always get in the way.</p>
]]></description>
    <pubDate>Thu, 16 Jun 2016 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2016-06-16-lenses-are-static-selectors.html</guid>
    <dc:creator>Donnacha OisÃ­n Kidney</dc:creator>
</item>
<item>
    <title>Folding Two Things at Once</title>
    <link>https://doisinkidney.com/posts/2016-04-17-folding-two-at-once.html</link>
    <description><![CDATA[<div class="info">
    Posted on April 17, 2016
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Recursion%20Schemes.html">Recursion Schemes</a>
    
</div>

<p>Thereâ€™s a whole family of Haskell brainteasers surrounding one function: <code class="sourceCode haskell">foldr</code>. The general idea is to convert some function on lists which uses recursion into one that uses <code class="sourceCode haskell">foldr</code>. <code class="sourceCode haskell">map</code>, for instance:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1">map<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">map f <span class="fu">=</span> foldr (\e a <span class="ot">-&gt;</span> f e <span class="fu">:</span> a) []</a></code></pre></div>
<p>Some can get a little trickier. <code class="sourceCode haskell">dropWhile</code>, for instance. (See <a href="https://wiki.haskell.org/wikiupload/1/14/TMR-Issue6.pdf">here</a> and <a href="http://www.cs.nott.ac.uk/~pszgmh/fold.pdf">here</a> for interesting articles on that one in particular.)</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1">dropWhile<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">dropWhile p <span class="fu">=</span> fst <span class="fu">.</span> foldr f ([],[]) <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  f e <span class="fu">~</span>(xs,ys) <span class="fu">=</span> (<span class="kw">if</span> p e <span class="kw">then</span> xs <span class="kw">else</span> zs, zs) <span class="kw">where</span> zs <span class="fu">=</span> e <span class="fu">:</span> ys</a></code></pre></div>
<h2 id="zip">Zip</h2>
<p>One function which was a little harder to convert than it first seemed was <code class="sourceCode haskell">zip</code>.</p>
<p>Hereâ€™s the first (non) solution:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1">zip<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a,b)]</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">zip <span class="fu">=</span> foldr f (const []) <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">  f x xs (y<span class="fu">:</span>ys) <span class="fu">=</span> (x,y) <span class="fu">:</span> xs ys</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">  f _ _  [] <span class="fu">=</span> []</a></code></pre></div>
<p>The problem with the above isnâ€™t that it doesnâ€™t work: it does. The problem is that itâ€™s not <em>really</em> using <code class="sourceCode haskell">foldr</code>. Itâ€™s only using it on the first list: thereâ€™s still a manual uncons being performed on the second. Ideally, I would want the function to look something like this:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">zip<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a,b)]</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">zip xs ys <span class="fu">=</span> foldr f (\_ _ <span class="ot">-&gt;</span> []) xs (foldr g (const []) ys)</a></code></pre></div>
<p>The best solution I found online only dealt with <code class="sourceCode haskell"><span class="dt">Fold</span></code>s, not <code class="sourceCode haskell"><span class="dt">Foldable</span></code>s. You can read it <a href="http://okmij.org/ftp/Haskell/zip-folds.lhs">here</a>.</p>
<h2 id="recursive-types">Recursive Types</h2>
<p>Reworking the solution online for <code class="sourceCode haskell"><span class="dt">Foldable</span></code>s, the initial intuition is to have the <code class="sourceCode haskell">foldr</code> on the <code class="sourceCode haskell">ys</code> produce a function which takes an element of the <code class="sourceCode haskell">xs</code>, and returns a function which takes an element of the <code class="sourceCode haskell">xs</code>, and so on, finally returning the created list. The <em>problem</em> with that approach is the types involved:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1">zip<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a,b)]</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">zip xs <span class="fu">=</span> foldr f (const []) xs <span class="fu">.</span> foldr g (\_ _ <span class="ot">-&gt;</span> []) <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  g e2 r2 e1 r1 <span class="fu">=</span> (e1,e2) <span class="fu">:</span> (r1 r2)</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">  f e r x <span class="fu">=</span> x e r</a></code></pre></div>
<p>You get the error:</p>
<blockquote>
<p><code class="sourceCode haskell"><span class="dt">Occurs</span> check<span class="fu">:</span> cannot construct the infinite <span class="kw">type</span><span class="fu">:</span> t0 <span class="fu">~</span> a <span class="ot">-&gt;</span> (t0 <span class="ot">-&gt;</span> [(a, b)]) <span class="ot">-&gt;</span> [(a, b)]</code>.</p>
</blockquote>
<p>Haskellâ€™s typechecker doesnâ€™t allow for infinitely recursive types.</p>
<p>Youâ€™ll be familiar with this problem if youâ€™ve ever tried to encode the Y-combinator, or if youâ€™ve fiddled around with the recursion-schemes package. You might also be familiar with the solution: a <code class="sourceCode haskell"><span class="kw">newtype</span></code>, encapsulating the recursion. In this case, the <code class="sourceCode haskell"><span class="kw">newtype</span></code> looks very similar to the signature for <code class="sourceCode haskell">foldr</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">RecFold</span> a b <span class="fu">=</span> </a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  <span class="dt">RecFold</span> {<span class="ot"> runRecFold ::</span> a <span class="ot">-&gt;</span> (<span class="dt">RecFold</span> a b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b }</a></code></pre></div>
<p>Now you can insert and remove the <code class="sourceCode haskell"><span class="dt">RecFold</span></code> wrapper, helping the typechecker to understand the recursive types as it goes:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1">zip<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a,b)]</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">zip xs <span class="fu">=</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  foldr f (const []) xs <span class="fu">.</span> <span class="dt">RecFold</span> <span class="fu">.</span> foldr g (\_ _ <span class="ot">-&gt;</span> []) <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">    g e2 r2 e1 r1 <span class="fu">=</span> (e1,e2) <span class="fu">:</span> (r1 (<span class="dt">RecFold</span> r2))</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">    f e r x <span class="fu">=</span> runRecFold x e r</a></code></pre></div>
<p>As an aside, the performance characteristics of the <code class="sourceCode haskell"><span class="kw">newtype</span></code> wrapper are totally opaque to me. There may be significant improvements by using <code class="sourceCode haskell">coerce</code> from <a href="https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Coerce.html">Data.Coerce</a>, but I havenâ€™t looked into it.</p>
<h2 id="generalised-zips">Generalised Zips</h2>
<p>The immediate temptation from the function above is to generalise it. First to <code class="sourceCode haskell">zipWith</code>, obviously:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">zipWith<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [c]</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">zipWith c xs <span class="fu">=</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  foldr f (const []) xs <span class="fu">.</span> <span class="dt">RecFold</span> <span class="fu">.</span> foldr g (\_ _ <span class="ot">-&gt;</span> []) <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">    g e2 r2 e1 r1 <span class="fu">=</span> c e1 e2 <span class="fu">:</span> (r1 (<span class="dt">RecFold</span> r2))</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">    f e r x <span class="fu">=</span> runRecFold x e r</a></code></pre></div>
<p>Whatâ€™s maybe a little more interesting, though, would be a <code class="sourceCode haskell">foldr</code> on two lists. Something which folds through both at once, using a supplied combining function:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">foldr2 ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Foldable</span> g)</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">       <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> c)</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">       <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> g b <span class="ot">-&gt;</span> c</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">foldr2 c i xs <span class="fu">=</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  foldr f (const i) xs <span class="fu">.</span> <span class="dt">RecFold</span> <span class="fu">.</span> foldr g (\_ _ <span class="ot">-&gt;</span> i) <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6">    g e2 r2 e1 r1 <span class="fu">=</span> c e1 e2 (r1 (<span class="dt">RecFold</span> r2))</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">    f e r x <span class="fu">=</span> runRecFold x e r</a></code></pre></div>
<p>Of course, once you can do two, you can do three:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">foldr3 ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Foldable</span> g, <span class="dt">Foldable</span> h)</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">       <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> d <span class="ot">-&gt;</span> d)</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">       <span class="ot">-&gt;</span> d <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> g b <span class="ot">-&gt;</span> h c <span class="ot">-&gt;</span> d</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">foldr3 c i xs ys <span class="fu">=</span></a>
<a class="sourceLine" id="cb10-5" data-line-number="5">  foldr f (const i) xs <span class="fu">.</span> <span class="dt">RecFold</span> <span class="fu">.</span> foldr2 g (\_ _ <span class="ot">-&gt;</span> i) ys <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-6" data-line-number="6">    g e2 e3 r2 e1 r1 <span class="fu">=</span> c e1 e2 e3 (r1 (<span class="dt">RecFold</span> r2))</a>
<a class="sourceLine" id="cb10-7" data-line-number="7">    f e r x <span class="fu">=</span> runRecFold x e r</a></code></pre></div>
<p>And so on.</p>
<p>Thereâ€™s the added benefit that the above functions work on much more than just lists.</p>
<h2 id="catamorphisms">Catamorphisms</h2>
<p>Getting a little formal about the above functions, a <code class="sourceCode haskell">fold</code> can be described as a catamorphism. This is a name for a pattern of breaking down some recursive structure. Thereâ€™s a bunch of them in the <a href="https://hackage.haskell.org/package/recursion-schemes-4.1.2/docs/Data-Functor-Foldable.html">recursion-schemes</a> package. The question is, then: can you express the above as a kind of catamorphism? Initially, using the same techniques as before, you can:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">RecF</span> f a <span class="fu">=</span> <span class="dt">RecF</span> {<span class="ot"> unRecF ::</span> <span class="dt">Base</span> f (<span class="dt">RecF</span> f a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a }</a>
<a class="sourceLine" id="cb11-2" data-line-number="2"></a>
<a class="sourceLine" id="cb11-3" data-line-number="3"><span class="ot">zipo ::</span> (<span class="dt">Functor</span><span class="fu">.</span><span class="dt">Foldable</span> f, <span class="dt">Functor</span><span class="fu">.</span><span class="dt">Foldable</span> g)</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">     <span class="ot">=&gt;</span> (<span class="dt">Base</span> f (<span class="dt">RecF</span> g c) <span class="ot">-&gt;</span> <span class="dt">Base</span> g (<span class="dt">RecF</span> g c <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> c)</a>
<a class="sourceLine" id="cb11-5" data-line-number="5">     <span class="ot">-&gt;</span> f <span class="ot">-&gt;</span> g <span class="ot">-&gt;</span> c</a>
<a class="sourceLine" id="cb11-6" data-line-number="6">zipo alg xs ys <span class="fu">=</span> cata (flip unRecF) ys (cata (<span class="dt">RecF</span> <span class="fu">.</span> alg) xs)</a></code></pre></div>
<p>Then, coming full circle, you get a quite nice encoding of <code class="sourceCode haskell">zip</code>:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1">zip<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a,b)]</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">zip <span class="fu">=</span> zipo alg <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">  alg <span class="dt">Nil</span> _ <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb12-4" data-line-number="4">  alg _ <span class="dt">Nil</span> <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">  alg (<span class="dt">Cons</span> x xs) (<span class="dt">Cons</span> y ys) <span class="fu">=</span> (x, y) <span class="fu">:</span> ys xs</a></code></pre></div>
<p>However, the <code class="sourceCode haskell"><span class="dt">RecF</span></code> is a little ugly. In fact, itâ€™s possible to write the above without any recursive types, using the RankNTypes extension. (Itâ€™s possible that you could do the same with <code class="sourceCode haskell">foldr2</code> as well, but I havenâ€™t figured it out yet)</p>
<p>You can actually use a <code class="sourceCode haskell"><span class="kw">newtype</span></code> thatâ€™s provided by the recursion-schemes library as-is. Itâ€™s <code class="sourceCode haskell"><span class="dt">Mu</span></code>. This is required for an encoding of the Y-combinator. Itâ€™s usually presented in this form:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Mu</span> a <span class="fu">=</span> <span class="dt">Roll</span> {<span class="ot"> unroll ::</span> <span class="dt">Mu</span> a <span class="ot">-&gt;</span> a }</a></code></pre></div>
<p>However, in the recursion-schemes package, its definition looks like this:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Mu</span> f <span class="fu">=</span> <span class="dt">Mu</span> (forall a<span class="fu">.</span> (f a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a)</a></code></pre></div>
<p>No recursion! The <code class="sourceCode haskell">zipo</code> combinator above can be written using <code class="sourceCode haskell"><span class="dt">Mu</span></code> like so:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="ot">zipo ::</span> (<span class="dt">Functor</span><span class="fu">.</span><span class="dt">Foldable</span> f, <span class="dt">Functor</span><span class="fu">.</span><span class="dt">Foldable</span> g)</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">     <span class="ot">=&gt;</span> (<span class="dt">Base</span> f (<span class="dt">Mu</span> (<span class="dt">Base</span> g) <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> <span class="dt">Base</span> g (<span class="dt">Mu</span> (<span class="dt">Base</span> g)) <span class="ot">-&gt;</span> c)</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">     <span class="ot">-&gt;</span> f <span class="ot">-&gt;</span> g <span class="ot">-&gt;</span> c</a>
<a class="sourceLine" id="cb15-4" data-line-number="4">zipo alg xs <span class="fu">=</span> cata (\x <span class="ot">-&gt;</span> alg x <span class="fu">.</span> project) xs <span class="fu">.</span> refix</a></code></pre></div>
<p>And the new version of <code class="sourceCode haskell">zip</code> has a slightly more natural order of arguments:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1">zip<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a,b)]</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">zip <span class="fu">=</span> zipo alg <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3">  alg <span class="dt">Nil</span> _ <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">  alg _ <span class="dt">Nil</span> <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb16-5" data-line-number="5">  alg (<span class="dt">Cons</span> x xs) (<span class="dt">Cons</span> y ys) <span class="fu">=</span> (x,y) <span class="fu">:</span> xs ys</a></code></pre></div>
<h2 id="zipping-into">Zipping Into</h2>
<p>Thereâ€™s one more issue, though, thatâ€™s slightly tangential. A lot of the time, the attraction of rewriting functions using folds and catamorphisms is that the function becomes more general: it no longer is restricted to lists. For <code class="sourceCode haskell">zip</code>, however, thereâ€™s still a pesky list left in the signature:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1">zip<span class="ot"> ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Foldable</span> g) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> g b <span class="ot">-&gt;</span> [(a,b)]</a></code></pre></div>
<p>It would be a little nicer to be able to zip through something <em>preserving</em> the structure of one of the things being zipped through. For no reason in particular, letâ€™s assume weâ€™ll preserve the structure of the first argument. The function will have to account for the second argument running out before the first, though. A <code class="sourceCode haskell"><span class="dt">Maybe</span></code> can account for that:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="ot">zipInto ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Foldable</span> g) </a>
<a class="sourceLine" id="cb18-2" data-line-number="2">        <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b <span class="ot">-&gt;</span> c) </a>
<a class="sourceLine" id="cb18-3" data-line-number="3">        <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> g b <span class="ot">-&gt;</span> f c</a></code></pre></div>
<p>If the second argument runs out, <code class="sourceCode haskell"><span class="dt">Nothing</span></code> will be passed to the combining function.</p>
<p>Itâ€™s clear that this isnâ€™t a <em>fold</em> over the first argument, itâ€™s a <em>traversal</em>. A first go at the function uses the state monad, but restricts the second argument to a list:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="ot">zipInto ::</span> <span class="dt">Traversable</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> f c</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">zipInto c xs ys <span class="fu">=</span> evalState (traverse f xs) ys <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-3" data-line-number="3">  f x <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb19-4" data-line-number="4">    h <span class="ot">&lt;-</span> gets uncons</a>
<a class="sourceLine" id="cb19-5" data-line-number="5">    <span class="kw">case</span> h <span class="kw">of</span> </a>
<a class="sourceLine" id="cb19-6" data-line-number="6">      <span class="dt">Just</span> (y,t) <span class="ot">-&gt;</span> <span class="kw">do</span> </a>
<a class="sourceLine" id="cb19-7" data-line-number="7">        put t</a>
<a class="sourceLine" id="cb19-8" data-line-number="8">        pure (c x (<span class="dt">Just</span> y))</a>
<a class="sourceLine" id="cb19-9" data-line-number="9">      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> pure (c x <span class="dt">Nothing</span>)</a></code></pre></div>
<p>That code can be cleaned up a little:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="ot">zipInto ::</span> <span class="dt">Traversable</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> f c </a>
<a class="sourceLine" id="cb20-2" data-line-number="2">zipInto c <span class="fu">=</span> evalState <span class="fu">.</span> traverse (state <span class="fu">.</span> f <span class="fu">.</span> c) <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-3" data-line-number="3">  f x [] <span class="fu">=</span> (x <span class="dt">Nothing</span>, [])</a>
<a class="sourceLine" id="cb20-4" data-line-number="4">  f x (y<span class="fu">:</span>ys) <span class="fu">=</span> (x (<span class="dt">Just</span> y), ys)</a></code></pre></div>
<p>But really, the uncons needs to go. Another <code class="sourceCode haskell"><span class="kw">newtype</span></code> wrapper is needed, and hereâ€™s the end result:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">RecAccu</span> a b <span class="fu">=</span></a>
<a class="sourceLine" id="cb21-2" data-line-number="2">  <span class="dt">RecAccu</span> {<span class="ot"> runRecAccu ::</span> a <span class="ot">-&gt;</span> (<span class="dt">RecAccu</span> a b, b) }</a>
<a class="sourceLine" id="cb21-3" data-line-number="3">  </a>
<a class="sourceLine" id="cb21-4" data-line-number="4"><span class="ot">zipInto ::</span> (<span class="dt">Traversable</span> t, <span class="dt">Foldable</span> f)</a>
<a class="sourceLine" id="cb21-5" data-line-number="5">        <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> t c</a>
<a class="sourceLine" id="cb21-6" data-line-number="6">zipInto f xs <span class="fu">=</span></a>
<a class="sourceLine" id="cb21-7" data-line-number="7">  snd <span class="fu">.</span> flip (mapAccumL runRecAccu) xs <span class="fu">.</span> <span class="dt">RecAccu</span> <span class="fu">.</span> foldr h i <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-8" data-line-number="8">    i e <span class="fu">=</span> (<span class="dt">RecAccu</span> i, f e <span class="dt">Nothing</span>)</a>
<a class="sourceLine" id="cb21-9" data-line-number="9">    h e2 a e1 <span class="fu">=</span> (<span class="dt">RecAccu</span> a, f e1 (<span class="dt">Just</span> e2))</a></code></pre></div>
]]></description>
    <pubDate>Sun, 17 Apr 2016 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2016-04-17-folding-two-at-once.html</guid>
    <dc:creator>Donnacha OisÃ­n Kidney</dc:creator>
</item>
<item>
    <title>A Trie in Haskell</title>
    <link>https://doisinkidney.com/posts/2015-10-06-haskell-trie-lhs.html</link>
    <description><![CDATA[<div class="info">
    Posted on October  6, 2015
</div>
<div class="info">
    
        Part 1 of a <a href="/series/tries.html">2-part series on tries</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Data%20Structures.html">Data Structures</a>
    
</div>

<h2 id="basic-ops">Basic Ops</h2>
<p>A Trie is one of those data structures that I find myself writing very early on in almost every language I try to learn. Itâ€™s elegant and interesting, and easy enough to implement.</p>
<p>I usually write a version that is a set-like data structure, rather than a mapping type, for simplicityâ€™s sake. It stores sequences, in a prefix-tree structure. It has a map (dictionary) where the keys are the first element of every sequence it stores, and the values are the Tries which store the rest of the sequence. It also has a boolean tag, representing whether or not the current Trie is a Trie on which a sequence ends. Hereâ€™s what the type looks like in Haskell:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell literate hidden_source"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">module</span> <span class="dt">Trie</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map.Strict</span> <span class="kw">as</span> <span class="dt">Map</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="kw">import</span> <span class="dt">Data.Map.Strict</span> (<span class="dt">Map</span>)</a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (null)</a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="kw">import</span> <span class="dt">Data.Maybe</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="kw">import</span> <span class="dt">Control.Monad</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"><span class="kw">import</span> <span class="dt">Data.Foldable</span> (fold)</a></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Trie</span> a <span class="fu">=</span> <span class="dt">Trie</span> {<span class="ot"> endHere ::</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">                   ,<span class="ot"> getTrie ::</span> <span class="dt">Map</span> a (<span class="dt">Trie</span> a)</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">                   } <span class="kw">deriving</span> (<span class="dt">Eq</span>)</a></code></pre></div>
<p>Now, inserting into the Trie is easy. You just <code class="sourceCode haskell">uncons</code> on a list, and insert the head into the map, with the value being the tail inserted into whatever existed at that key before:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">empty ::</span> <span class="dt">Trie</span> a</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">empty <span class="fu">=</span> <span class="dt">Trie</span> <span class="dt">False</span> Map.empty</a>
<a class="sourceLine" id="cb3-3" data-line-number="3"></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="ot">insertRec ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Trie</span> a</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">insertRec [] (<span class="dt">Trie</span> _ m)     <span class="fu">=</span> <span class="dt">Trie</span> <span class="dt">True</span> m</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">insertRec (x<span class="fu">:</span>xs) (<span class="dt">Trie</span> e m) <span class="fu">=</span> </a>
<a class="sourceLine" id="cb3-7" data-line-number="7">  <span class="dt">Trie</span> e (Map.alter (<span class="dt">Just</span> <span class="fu">.</span> insertRec xs <span class="fu">.</span> fromMaybe empty) x m)</a></code></pre></div>
<p>Searching is simple, also. For the empty list, you just check if the Trie has its <code class="sourceCode haskell">endHere</code> tag set to <code class="sourceCode haskell"><span class="dt">True</span></code>, otherwise, you uncons, search the map, and query the Trie with the tail if it eas found, or just return <code class="sourceCode haskell"><span class="dt">False</span></code> if it was not:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">memberRec ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">memberRec [] (<span class="dt">Trie</span> e _)     <span class="fu">=</span> e</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">memberRec (x<span class="fu">:</span>xs) (<span class="dt">Trie</span> _ m) <span class="fu">=</span> </a>
<a class="sourceLine" id="cb4-4" data-line-number="4">  fromMaybe <span class="dt">False</span> (memberRec xs <span class="fu">&lt;$&gt;</span> Map.lookup x m)</a></code></pre></div>
<p>Hereâ€™s my problem. <em>Both</em> of those functions have the same pattern:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1">f []     <span class="fu">=</span> <span class="fu">...</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">f (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="fu">...</span></a></code></pre></div>
<p>Any good Haskeller should be <em>begging</em> for a fold at this stage. But it proved a little trickier than Iâ€™d imagined. Take <code class="sourceCode haskell">member</code>, for instance. You want to fold over a list, with the base case being the tag on the Trie:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">member ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">member <span class="fu">=</span> foldr f base <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  base <span class="fu">=</span> <span class="fu">???</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">  f e a <span class="fu">=</span> Map.lookup e <span class="fu">???</span></a></code></pre></div>
<p>Where do you get the base case from, though? You have to specify it from the beginning, but the variable youâ€™re looking for is nested deeply into the Trie. How can you look into the Trie, without traversing the list, to find the tag, <em>at the beginning of the function?</em></p>
<p>That had been my issue for a while. Every time I cam back to writing a Trie, I would see the pattern, try and write <code class="sourceCode haskell">insert</code> and <code class="sourceCode haskell">member</code> with a fold, and remember again the trouble I had had with it in the past. Recently, though, I saw a different problem, that gave me an idea for a solution.</p>
<h2 id="the-highest-order">The Highest Order</h2>
<blockquote>
<p>Rewrite <code class="sourceCode haskell">dropWhile</code> using <code class="sourceCode haskell">foldr</code></p>
</blockquote>
<p>Itâ€™s a (semi) well-known puzzle, thatâ€™s maybe a little more difficult than it seems at first. Here, for instance, was my first attempt at it:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">dropWhileWrong ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">dropWhileWrong p <span class="fu">=</span> foldr f [] <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  f e a <span class="fu">|</span> p e       <span class="fu">=</span> a</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">        <span class="fu">|</span> otherwise <span class="fu">=</span> e<span class="fu">:</span>a</a></code></pre></div>
<p>Yeah. Thatâ€™s <code class="sourceCode haskell">filter</code>, not <code class="sourceCode haskell">dropWhile</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">dropWhileWrong (<span class="fu">&lt;</span><span class="dv">5</span>) [<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">6</span>, <span class="dv">3</span>, <span class="dv">1</span>]</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">[<span class="dv">6</span>]</a></code></pre></div>
<p>Here was my final solution:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">dropWhileCount ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">dropWhileCount p l <span class="fu">=</span> drop (foldr f <span class="dv">0</span> l) l <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  f e a <span class="fu">|</span> p e       <span class="fu">=</span> a <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4">        <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dv">0</span></a></code></pre></div>
<p>After the problem I found <a href="https://wiki.haskell.org/wikiupload/1/14/TMR-Issue6.pdf">this</a> issue of The Monad Reader, which talks about the same problem. In my <code class="sourceCode haskell">drop</code> version, I had been counting the number of items to drop as I went, adding one for every element that passed the test. The corresponding version in the article had been building up <code class="sourceCode haskell">tail</code> functions, using <code class="sourceCode haskell"><span class="fu">.</span></code> to add them together:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">dropWhileTail ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">dropWhileTail p l <span class="fu">=</span> (foldr f id l) l <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  f e a <span class="fu">|</span> p e       <span class="fu">=</span> tail <span class="fu">.</span> a</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">        <span class="fu">|</span> otherwise <span class="fu">=</span> id</a></code></pre></div>
<p>A quick visit to <a href="http://pointfree.io">pointfree.io</a> can generate some monadic pointsfree magic:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">dropWhilePf ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">dropWhilePf p <span class="fu">=</span> join (foldr f id) <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  f e a <span class="fu">|</span> p e       <span class="fu">=</span> tail <span class="fu">.</span> a</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">        <span class="fu">|</span> otherwise <span class="fu">=</span> id</a></code></pre></div>
<p>Now, the final version in the article did <em>not</em> use this technique, as it was very inefficient. It used some cleverness beyond the scope of this post. The second-from-last version I quite liked, though:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="ot">dropWhileFp ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">dropWhileFp p l <span class="fu">=</span> foldr f l l <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">  f e a <span class="fu">|</span> p e       <span class="fu">=</span> tail a</a>
<a class="sourceLine" id="cb12-4" data-line-number="4">        <span class="fu">|</span> otherwise <span class="fu">=</span> l</a></code></pre></div>
<p>However, the idea of building up a function in a fold gave me an idea for adapting it to some of the Trie functions.</p>
<h2 id="folding-inwards">Folding Inwards</h2>
<p>Letâ€™s start with <code class="sourceCode haskell">member</code>. It needs to fold over a list, and generate a function which acts on a Trie:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="ot">member ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">member <span class="fu">=</span> foldr f base</a></code></pre></div>
<p>The <code class="sourceCode haskell">base</code> is the function being built up: the final part of the function chain. Each part of the function is generated based on each element of the list, and then chained with the base using <code class="sourceCode haskell"><span class="fu">.</span></code>:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1">member <span class="fu">=</span> foldr f base <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2">  f e a <span class="fu">=</span> <span class="fu">???</span> <span class="fu">.</span> a </a></code></pre></div>
<p>The base here is whatâ€™s called when the list is empty. Hereâ€™s what it looked like in the explicit recursion version:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1">member [] (<span class="dt">Trie</span> e _) <span class="fu">=</span> e</a></code></pre></div>
<p>We could simplify this by using record syntax, and <code class="sourceCode haskell">getTrie</code>:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1">member [] t <span class="fu">=</span> getTrie t</a></code></pre></div>
<p>And this has an obvious pointsfree version:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1">member [] <span class="fu">=</span> getTrie</a></code></pre></div>
<p>That fits for the base case. Itâ€™s just a function:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1">member <span class="fu">=</span> foldr f endHere <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2">  f e a <span class="fu">=</span> <span class="fu">???</span> <span class="fu">.</span> a </a></code></pre></div>
<p>Then, how to combine it. Thatâ€™s easy enough, actually. It accesses the map, searches it for the key, and calls the accumulating function on it. If itâ€™s not found in the map, just return <code class="sourceCode haskell"><span class="dt">False</span></code>. Here it is:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="ot">member ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb19-2" data-line-number="2">member <span class="fu">=</span> foldr f endHere <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-3" data-line-number="3">  f e a <span class="fu">=</span> fromMaybe <span class="dt">False</span> <span class="fu">.</span> fmap a <span class="fu">.</span> Map.lookup e <span class="fu">.</span> getTrie</a></code></pre></div>
<p>One of the other standard functions for a Trie is returning the â€œcompletionsâ€ for a given sequence. Itâ€™s a very similar function to <code class="sourceCode haskell">member</code>, actually: instead of calling <code class="sourceCode haskell">endHere</code> on the final Trie found, though, just return the Trie itself. And the thing to return if any given element of the sequence isnâ€™t found is just an empty Trie:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="ot">complete ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Trie</span> a</a>
<a class="sourceLine" id="cb20-2" data-line-number="2">complete <span class="fu">=</span> foldr f id <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-3" data-line-number="3">  f e a <span class="fu">=</span> fromMaybe empty <span class="fu">.</span> fmap a <span class="fu">.</span> Map.lookup e <span class="fu">.</span> getTrie </a></code></pre></div>
<p>In fact, you could abstract out the commonality here:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="ot">follow ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> c <span class="ot">-&gt;</span> (<span class="dt">Trie</span> a <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> c</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">follow ifMiss onEnd <span class="fu">=</span> foldr f onEnd <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-3" data-line-number="3">  f e a <span class="fu">=</span> fromMaybe ifMiss <span class="fu">.</span> fmap a <span class="fu">.</span> Map.lookup e <span class="fu">.</span> getTrie </a>
<a class="sourceLine" id="cb21-4" data-line-number="4">  </a>
<a class="sourceLine" id="cb21-5" data-line-number="5"><span class="ot">memberAbs ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb21-6" data-line-number="6">memberAbs <span class="fu">=</span> follow <span class="dt">False</span> endHere</a>
<a class="sourceLine" id="cb21-7" data-line-number="7"></a>
<a class="sourceLine" id="cb21-8" data-line-number="8"><span class="ot">completeAbs ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Trie</span> a</a>
<a class="sourceLine" id="cb21-9" data-line-number="9">completeAbs <span class="fu">=</span> follow empty id</a></code></pre></div>
<h2 id="folding-in-and-out">Folding in and out</h2>
<p><code class="sourceCode haskell">insert</code> is another deal entirely. In <code class="sourceCode haskell">member</code>, the fold was tunneling into a Trie, applying the accumulator function to successively deeper Tries, and returning a result based on the final Trie. <code class="sourceCode haskell">insert</code> needs to do the same tunneling - but the Trie returned needs to be the <em>outer</em> Trie.</p>
<p>It turns out itâ€™s not that difficult. Instead of â€œbuilding up a functionâ€ that is then applied to a Trie, here a function is â€œsentâ€ into the inner Tries. The cool thing here is that the function being sent hasnâ€™t been generated yet.</p>
<p>Hereâ€™s some more illustration of what I mean. Start off with the normal <code class="sourceCode haskell">foldr</code>:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="ot">insert ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Trie</span> a</a>
<a class="sourceLine" id="cb22-2" data-line-number="2">insert <span class="fu">=</span> foldr f (\(<span class="dt">Trie</span> _ m) <span class="ot">-&gt;</span> <span class="dt">Trie</span> <span class="dt">True</span> m)</a></code></pre></div>
<p>With the final function to be applied being one that just flips the <code class="sourceCode haskell">endHere</code> tag to <code class="sourceCode haskell"><span class="dt">True</span></code>. Then <code class="sourceCode haskell">f</code>: this is going to act <em>over</em> the map of the Trie that itâ€™s called on. Itâ€™s useful to define a function just for that:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="ot">overMap ::</span> <span class="dt">Ord</span> b </a>
<a class="sourceLine" id="cb23-2" data-line-number="2">        <span class="ot">=&gt;</span> (<span class="dt">Map.Map</span> a (<span class="dt">Trie</span> a)</a>
<a class="sourceLine" id="cb23-3" data-line-number="3">        <span class="ot">-&gt;</span> <span class="dt">Map.Map</span> b (<span class="dt">Trie</span> b))</a>
<a class="sourceLine" id="cb23-4" data-line-number="4">        <span class="ot">-&gt;</span> <span class="dt">Trie</span> a</a>
<a class="sourceLine" id="cb23-5" data-line-number="5">        <span class="ot">-&gt;</span> <span class="dt">Trie</span> b</a>
<a class="sourceLine" id="cb23-6" data-line-number="6">overMap f (<span class="dt">Trie</span> e m) <span class="fu">=</span> <span class="dt">Trie</span> e (f m)</a></code></pre></div>
<p>Then, it will look up the next element of the sequence in the Trie, and apply the accumulating function to it. (if itâ€™s not found it will provide an empty Trie instead) Simple!</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell literate hidden_source"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Trie</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-2" data-line-number="2">  mempty <span class="fu">=</span> <span class="dt">Trie</span> <span class="dt">False</span> Map.empty</a>
<a class="sourceLine" id="cb24-3" data-line-number="3">  <span class="dt">Trie</span> v k <span class="ot">`mappend`</span> <span class="dt">Trie</span> t l <span class="fu">=</span></a>
<a class="sourceLine" id="cb24-4" data-line-number="4">    <span class="dt">Trie</span> (v <span class="fu">||</span> t) (Map.unionWith mappend k l)</a></code></pre></div>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="ot">insert ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Trie</span> a</a>
<a class="sourceLine" id="cb25-2" data-line-number="2">insert <span class="fu">=</span> foldr f (\(<span class="dt">Trie</span> _ m) <span class="ot">-&gt;</span> <span class="dt">Trie</span> <span class="dt">True</span> m) <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-3" data-line-number="3">  f e a <span class="fu">=</span> </a>
<a class="sourceLine" id="cb25-4" data-line-number="4">    overMap (Map.alter (<span class="dt">Just</span> <span class="fu">.</span> a <span class="fu">.</span> fold) e)</a></code></pre></div>
<p>I think this is really cool: with just a <code class="sourceCode haskell">foldr</code>, youâ€™re burrowing into a Trie, changing it, and burrowing back out again.</p>
<h2 id="removal">Removal</h2>
<p>This is always the tricky one with a Trie. You <em>can</em> just follow a given sequence down to its tag, and flip it from on to off. But that doesnâ€™t remove the sequence itself from the Trie. So maybe you just delete the sequence - but that doesnâ€™t work either. How do you know that there are no other sequences stored below the one you were examining?</p>
<p>What you need to do is to send a function into the Trie, and have it report back as to whether or not it stores other sequences below it. So this version of <code class="sourceCode haskell">foldr</code> is going to burrow into the Trie, like <code class="sourceCode haskell">member</code>; maintain the outer Trie, like <code class="sourceCode haskell">insert</code>; but <em>also</em> send messages back up to the outer functions. Cool!</p>
<p>The way to do the â€œmessage sendingâ€ is with <code class="sourceCode haskell"><span class="dt">Maybe</span></code>. If the function you send into the Trie to delete the end of the sequence returns <code class="sourceCode haskell"><span class="dt">Nothing</span></code>, then it signifies that you can delete that member. Luckily, the <code class="sourceCode haskell">alter</code> function on <code class="sourceCode haskell"><span class="dt">Data.Map</span></code> works well with this:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="ot">alter ::</span> <span class="dt">Ord</span> k </a>
<a class="sourceLine" id="cb26-2" data-line-number="2">      <span class="ot">=&gt;</span> (<span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a)</a>
<a class="sourceLine" id="cb26-3" data-line-number="3">      <span class="ot">-&gt;</span> k</a>
<a class="sourceLine" id="cb26-4" data-line-number="4">      <span class="ot">-&gt;</span> <span class="dt">Map</span> k a</a>
<a class="sourceLine" id="cb26-5" data-line-number="5">      <span class="ot">-&gt;</span> <span class="dt">Map</span> k a</a></code></pre></div>
<p>Its first argument is a function which is given the result of looking up its <em>second</em> argument. If the function returns <code class="sourceCode haskell"><span class="dt">Nothing</span></code>, that key-value pair in the map is deleted (if it was there). If it returns <code class="sourceCode haskell"><span class="dt">Just</span></code> something, though, that key-value pair is added. In the delete function, we can chain the accumulating function with <code class="sourceCode haskell"><span class="fu">=&lt;&lt;</span></code>. This will skip the rest of the accumulation if any part of the sequence isnâ€™t found. The actual function weâ€™re chaining on is <code class="sourceCode haskell">nilIfEmpty</code>, which checks if a given Trie is empty, and returns <code class="sourceCode haskell"><span class="dt">Just</span></code> the Trie if itâ€™s not, or <code class="sourceCode haskell"><span class="dt">Nothing</span></code> otherwise.</p>
<p>Hereâ€™s the finished version:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="ot">delete ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Trie</span> a</a>
<a class="sourceLine" id="cb27-2" data-line-number="2">delete <span class="fu">=</span> (fromMaybe empty <span class="fu">.</span>) <span class="fu">.</span> foldr f i <span class="kw">where</span></a>
<a class="sourceLine" id="cb27-3" data-line-number="3">  i (<span class="dt">Trie</span> _ m) <span class="fu">|</span> Map.null m  <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb27-4" data-line-number="4">               <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Just</span> (<span class="dt">Trie</span> <span class="dt">False</span> m)</a>
<a class="sourceLine" id="cb27-5" data-line-number="5">  f e a <span class="fu">=</span> nilIfEmpty <span class="fu">.</span> overMap (Map.alter (a <span class="fu">=&lt;&lt;</span>) e) </a>
<a class="sourceLine" id="cb27-6" data-line-number="6">  </a>
<a class="sourceLine" id="cb27-7" data-line-number="7">null<span class="ot"> ::</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb27-8" data-line-number="8">null (<span class="dt">Trie</span> e m) <span class="fu">=</span> (not e) <span class="fu">&amp;&amp;</span> (Map.null m)</a>
<a class="sourceLine" id="cb27-9" data-line-number="9"></a>
<a class="sourceLine" id="cb27-10" data-line-number="10"><span class="ot">nilIfEmpty ::</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Trie</span> a)</a>
<a class="sourceLine" id="cb27-11" data-line-number="11">nilIfEmpty t <span class="fu">|</span> null t    <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb27-12" data-line-number="12">             <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Just</span> t</a></code></pre></div>
<h2 id="folding-the-foldable">Folding the Foldable</h2>
<p>So how about folding the Trie itself? Same trick: build up a function with a fold. This time, a fold over the map, not a list. And the function being built up is a cons operation. When you hit a <code class="sourceCode haskell"><span class="dt">True</span></code> tag, fire off an empty list to the built-up function, allowing it to evaluate:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1"><span class="ot">foldrTrie ::</span> ([a] <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb28-2" data-line-number="2">foldrTrie f i (<span class="dt">Trie</span> a m) <span class="fu">=</span> Map.foldrWithKey ff s m <span class="kw">where</span></a>
<a class="sourceLine" id="cb28-3" data-line-number="3">  s    <span class="fu">=</span> <span class="kw">if</span> a <span class="kw">then</span> f [] i <span class="kw">else</span> i</a>
<a class="sourceLine" id="cb28-4" data-line-number="4">  ff k <span class="fu">=</span> flip (foldrTrie <span class="fu">$</span> f <span class="fu">.</span> (k <span class="fu">:</span>))</a></code></pre></div>
<p>Unfortunately, <a href="http://stackoverflow.com/questions/33469157/foldable-instance-for-a-trie-set">itâ€™s not easy</a> to make the Trie <em>conform</em> to <code class="sourceCode haskell"><span class="dt">Foldable</span></code>. It is possible, and itâ€™s what Iâ€™m currently trying to figure out, but itâ€™s non-trivial.</p>
]]></description>
    <pubDate>Tue, 06 Oct 2015 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2015-10-06-haskell-trie-lhs.html</guid>
    <dc:creator>Donnacha OisÃ­n Kidney</dc:creator>
</item>
<item>
    <title>Faking dependent types in Swift</title>
    <link>https://doisinkidney.com/posts/2015-09-06-dependent-types.html</link>
    <description><![CDATA[<div class="info">
    Posted on September  6, 2015
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Swift.html">Swift</a>, <a href="/tags/Dependent%20Types.html">Dependent Types</a>
    
</div>

<p><a href="https://en.wikipedia.org/wiki/Dependent_type">Dependent types</a> are types â€œthat depend on valuesâ€. Say you had a function <code class="sourceCode scala">f</code> that took an integer. If you can write that function whereby it returns a value of type <code class="sourceCode scala">A</code> when that integer is even, or a type <code class="sourceCode scala">B</code> if the integer is odd, then youâ€™re working with dependent types. (I think. Iâ€™m not sure: if Iâ€™ve got it wrong <a href="https://twitter.com/oisdk">tweet me</a>.)</p>
<h2 id="dependent-pretendance">Dependent Pretendance</h2>
<p>As far as I can tell, this is not possible in Swift. All variables are statically typed, and those types must be found at compile-time. As long as youâ€™re not messing around with casting:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb1-1" data-line-number="1">struct A {}</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">struct B {}</a>
<a class="sourceLine" id="cb1-3" data-line-number="3"></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">func <span class="fu">f</span>(i: Int) -&gt; AnyObject {</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">  <span class="kw">return</span> i % <span class="dv">2</span> == <span class="dv">0</span> ? <span class="fu">A</span>() as! AnyObject : <span class="fu">B</span>() as! AnyObject</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">}</a></code></pre></div>
<p>You wonâ€™t be able to manage it.</p>
<p>Now, sum types can give you something that <em>looks</em> like dependent types:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb2-1" data-line-number="1">struct A {}</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">struct B {}</a>
<a class="sourceLine" id="cb2-3" data-line-number="3"></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">enum SumType {</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">  <span class="kw">case</span> <span class="fu">Even</span>(A), <span class="fu">Odd</span>(B)</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">}</a>
<a class="sourceLine" id="cb2-7" data-line-number="7"></a>
<a class="sourceLine" id="cb2-8" data-line-number="8">func <span class="fu">f</span>(i: Int) -&gt; SumType {</a>
<a class="sourceLine" id="cb2-9" data-line-number="9">  <span class="kw">return</span> i % <span class="dv">2</span> == <span class="dv">0</span> ? .<span class="fu">Even</span>(<span class="fu">A</span>()) : .<span class="fu">Odd</span>(<span class="fu">B</span>())</a>
<a class="sourceLine" id="cb2-10" data-line-number="10">}</a></code></pre></div>
<p>But that doesnâ€™t fit the description: the thing returned is of type <code class="sourceCode scala">SumType</code>, <em>not</em> <code class="sourceCode scala">A</code> or <code class="sourceCode scala">B</code>.</p>
<p>Thatâ€™s fine, though. As with all of these highfalutin mathematical concepts in programming, you can steal some of the cool and fun <em>patterns</em> from your Haskells and Lisps and Idrises and implement them in whatever language you want.</p>
<p>As it happens, implementing this stuff in Swift gets you even <em>further</em> away from the formal definition of dependent types. Instead of allowing types to be decided at runtime, you end up forcing even <em>more</em> resolution and computation to happen at compile-time. Take â€œnumbers-as-typesâ€, for instance:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb3-1" data-line-number="1">protocol Nat { <span class="fu">init</span>() }</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">struct Zero : Nat {}</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">protocol NonZero: Nat { typealias Pred: Nat }</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">struct Succ&lt;N : Nat&gt; : NonZero { typealias Pred = N }</a></code></pre></div>
<p>Once you encode some numbers by hand:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb4-1" data-line-number="1">typealias One   = Succ&lt;Zero&gt;</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">typealias Two   = Succ&lt;One&gt;</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">typealias Three = Succ&lt;Two&gt;</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">typealias Four  = Succ&lt;Three&gt;</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">typealias Five  = Succ&lt;Four&gt;</a>
<a class="sourceLine" id="cb4-6" data-line-number="6">typealias Six   = Succ&lt;Five&gt;</a>
<a class="sourceLine" id="cb4-7" data-line-number="7">typealias Seven = Succ&lt;Six&gt;</a>
<a class="sourceLine" id="cb4-8" data-line-number="8">typealias Eight = Succ&lt;Seven&gt;</a>
<a class="sourceLine" id="cb4-9" data-line-number="9">typealias Nine  = Succ&lt;Eight&gt;</a></code></pre></div>
<p>You get thinking about exactly <em>how much</em> computation you can achieve at compile time:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb5-1" data-line-number="1">Sum&lt;One, Two&gt;.<span class="fu">Result</span>    <span class="co">// Three</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">Comp&lt;Five, Nine&gt;.<span class="fu">Result</span> <span class="co">// LT</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">Comp&lt;Four, Four&gt;.<span class="fu">Result</span> <span class="co">// EQ</span></a></code></pre></div>
<h2 id="sum-types-divide-types-multiply-types">Sum types, divide types, multiply types</h2>
<p>What I wanted, ideally, was some basic â€œAlgebraic data typesâ€. (Today. Today was the day I made the worst pun.) I wanted to be able to add the type <code class="sourceCode scala">One</code> to the type <code class="sourceCode scala">Two</code> and get the type <code class="sourceCode scala">Three</code>. Once you can manage those, multiplication, division and all kinds of silliness are possible. I set myself some rules: all calculations must be performed at compile-time, and all calculations must work with arbitrary values.</p>
<p>Iâ€™ve not been able to manage, unfortunately. If someone could figure out how to do it, I would <a href="https://twitter.com/oisdk">love to hear it</a>. Iâ€™ve been stealing ideas from <a href="http://strictlypositive.org/faking.ps.gz">Faking It: Simulating Dependent Types in Haskell</a> mainly.</p>
<p>Hereâ€™s the kind of code that made me think it was possible:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb6-1" data-line-number="1">let ar = [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>].<span class="fu">reverse</span>()</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">let se = <span class="fu">AnySequence</span>([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>]).<span class="fu">reverse</span>()</a></code></pre></div>
<p>The types returned by those two methods are different. This is all to do with that protocol-oriented-programming business: the compiler will try to select the most specialised version of a method to use. So in the example above, since an array can just be indexed backwards, the compiler uses a method that returns a lazy <code class="sourceCode scala">ReverseRandomAccessCollection</code>. However, for the <code class="sourceCode scala">AnySequence</code>, the <code class="sourceCode scala">reverse</code> method has to create a whole new array.</p>
<p>With that in mind, we can make a protocol:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb7-1" data-line-number="1">protocol BinaryOp {</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  typealias A: Nat</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  typealias B: Nat</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">}</a></code></pre></div>
<p>Then, we can extend it, like this:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb8-1" data-line-number="1">struct EQ {}</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">extension BinaryOp where A == B {</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  typealias Result = EQ</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">}</a></code></pre></div>
<p>So far, so good! The compiler will add that method to all types that conform to the <code class="sourceCode scala">where</code> clause. So if there is a concrete type that conforms to <code>BinaryOp</code>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb9-1" data-line-number="1">struct Comp&lt;E0: Nat, E1: Nat&gt; : BinaryOp {</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">  typealias A = E0</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  typealias B = E1</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">}</a></code></pre></div>
<p>Only instances where <code class="sourceCode scala">A</code> and <code class="sourceCode scala">B</code> are equal will get the type alias:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb10-1" data-line-number="1">Comp&lt;One, One&gt;.<span class="fu">Result</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">Comp&lt;One, Two&gt;.<span class="fu">Result</span> <span class="co">// Error</span></a></code></pre></div>
<p>But thatâ€™s not ideal. We want something that returns <code class="sourceCode scala">NEQ</code> when the types are not the same. Easy enough, right?</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb11-1" data-line-number="1">struct NEQ {}</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">extension BinaryOp {</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  typealias Result = NEQ</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">}</a></code></pre></div>
<p>But thereâ€™s an error: <code class="sourceCode scala">invalid redeclaration of &#39;Result&#39;</code>. The compiler wonâ€™t allow polymorphism with typealiases. It <em>does</em> allow polymorphism with properties, though:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb12-1" data-line-number="1">extension BinaryOp {</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">  <span class="kw">var</span> r: EQ { <span class="kw">return</span> <span class="fu">EQ</span>() }</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">}</a>
<a class="sourceLine" id="cb12-4" data-line-number="4">extension BinaryOp where A == B {</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">  <span class="kw">var</span> r: NEQ { <span class="kw">return</span> <span class="fu">NEQ</span>() }</a>
<a class="sourceLine" id="cb12-6" data-line-number="6">}</a></code></pre></div>
<p>This is already a less elegant solution than the typealiases, since weâ€™re going to have to initialise things. All of the type information is available at compile-time, though, so Iâ€™ve not broken any of my rules.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb13-1" data-line-number="1">Comp&lt;One, One&gt;().<span class="fu">r</span> <span class="co">// EQ</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">Comp&lt;One, Two&gt;().<span class="fu">r</span> <span class="co">// NEQ</span></a></code></pre></div>
<p>How about something more complex? Instead of <code class="sourceCode scala">EQ</code> and <code class="sourceCode scala">NEQ</code>, maybe <code class="sourceCode scala">LT</code>, <code class="sourceCode scala">GT</code>, and <code>EQ</code>?</p>
<p>Itâ€™s hard to see how it would work. Well, hereâ€™s the base case:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb14-1" data-line-number="1">extension BinaryOp where A == B {</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">  <span class="kw">var</span> r: EQ { <span class="kw">return</span> <span class="fu">EQ</span>() }</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">}</a></code></pre></div>
<p>Then, any non-zero is bigger than zero:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb15-1" data-line-number="1">struct LT {}</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">extension BinaryOp where A == Zero, B : NonZero {</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">  <span class="kw">var</span> r: LT { <span class="kw">return</span> <span class="fu">LT</span>() }</a>
<a class="sourceLine" id="cb15-4" data-line-number="4">}</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">struct GT {}</a>
<a class="sourceLine" id="cb15-6" data-line-number="6">extension BinaryOp where A : NonZero, B == Zero {</a>
<a class="sourceLine" id="cb15-7" data-line-number="7">  <span class="kw">var</span> r: GT { <span class="kw">return</span> <span class="fu">GT</span>() }</a>
<a class="sourceLine" id="cb15-8" data-line-number="8">}</a></code></pre></div>
<p>If both <code class="sourceCode scala">A</code> and <code class="sourceCode scala">B</code> are nonzero, they should have a <code class="sourceCode scala">Pred</code> typealias, which we can use, recursively:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb16-1" data-line-number="1">extension BinaryOp where A : NonZero, B : NonZero {</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">  <span class="kw">var</span> r: ?? {</a>
<a class="sourceLine" id="cb16-3" data-line-number="3">    <span class="kw">return</span> Comp&lt;A.<span class="fu">Pred</span>, B.<span class="fu">Pred</span>&gt;().<span class="fu">r</span></a>
<a class="sourceLine" id="cb16-4" data-line-number="4">  }</a>
<a class="sourceLine" id="cb16-5" data-line-number="5">}</a></code></pre></div>
<p>This doesnâ€™t work. Iâ€™m fairly sure this is a definitive dead end. Hereâ€™s the error: <code class="sourceCode scala">ambiguous reference to member <span class="ch">&#39;r&#39;</span></code>. The problem is that that error encapsulates exactly what Iâ€™m trying to achieve: I <em>want</em> the reference to be ambiguous, so it <em>depends</em> on the types of <code class="sourceCode scala">A</code> and <code class="sourceCode scala">B</code>. Most other routes I went down hit similar roadblocks:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb17-1" data-line-number="1">protocol BinaryOp {</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">  typealias A: Nat</a>
<a class="sourceLine" id="cb17-3" data-line-number="3">  typealias B: Nat</a>
<a class="sourceLine" id="cb17-4" data-line-number="4">  typealias Result</a>
<a class="sourceLine" id="cb17-5" data-line-number="5">  <span class="kw">var</span> r: Result { get }</a>
<a class="sourceLine" id="cb17-6" data-line-number="6">}</a></code></pre></div>
<p>The idea here was that you could have various implementations of <code class="sourceCode scala">r</code>, so that the <code class="sourceCode scala">Result</code> typealias would be inferred. The problem is the compiler wants to figure out what <code class="sourceCode scala">Result</code> is when you make a type that conforms to the protocol, so every type will get the default implementation.</p>
<p>Yet more versions I tried all hit the <code class="sourceCode scala">ambiguous</code> error, which makes me think this kind of thing is fundamentally impossible in Swiftâ€™s current form.</p>
<p>So Iâ€™ve got to break one of the rules: no more arbitrary numbers.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb18-1" data-line-number="1">struct AddOne&lt;N : Nat&gt; {</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">  typealias Result = Succ&lt;N&gt;</a>
<a class="sourceLine" id="cb18-3" data-line-number="3">}</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">struct AddTwo&lt;N : Nat&gt; {</a>
<a class="sourceLine" id="cb18-5" data-line-number="5">  typealias Result = Succ&lt;AddOne&lt;N&gt;.<span class="fu">Result</span>&gt;</a>
<a class="sourceLine" id="cb18-6" data-line-number="6">}</a></code></pre></div>
<p>And so on. Or:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb19-1" data-line-number="1">extension Binary where A == B {</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">  <span class="kw">var</span> sub: Zero { <span class="kw">return</span> <span class="fu">Zero</span>() }</a>
<a class="sourceLine" id="cb19-3" data-line-number="3">  <span class="kw">var</span> com: EQ { <span class="kw">return</span> <span class="fu">EQ</span>() }</a>
<a class="sourceLine" id="cb19-4" data-line-number="4">}</a>
<a class="sourceLine" id="cb19-5" data-line-number="5">extension Binary where A == Succ&lt;B&gt; {</a>
<a class="sourceLine" id="cb19-6" data-line-number="6">  <span class="kw">var</span> sub: One { <span class="kw">return</span> <span class="fu">One</span>() }</a>
<a class="sourceLine" id="cb19-7" data-line-number="7">  <span class="kw">var</span> com: GT { <span class="kw">return</span> <span class="fu">GT</span>() }</a>
<a class="sourceLine" id="cb19-8" data-line-number="8">}</a></code></pre></div>
<p>Which can give you subtraction.</p>
<h2 id="lets-pretend-to-be-useful">Letâ€™s Pretend to be Useful</h2>
<p>All of that stuff is interesting, but very <em>very</em> far from being useful.</p>
<p>The <a href="https://bigonotetaking.wordpress.com/2015/09/04/in-which-i-misunderstand-dependent-types/">length-indexed list from the other day</a> probably is useful, though. As well as being kind of cool and safe, there are some (minor) optimisations it can do.</p>
<p>The other dependent type staple is the heterogenous list.</p>
<p>Now, this isnâ€™t just any heterogenous list: weâ€™re not writing Python here. This is a <em>statically typed</em> heterogenous list. Swift has a construct very similar to this already: a tuple!</p>
<p>But tuples arenâ€™t very extensible:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb20-1" data-line-number="1">extension Tuple where First : Comparable {...</a>
<a class="sourceLine" id="cb20-2" data-line-number="2">extension Tuple where Count == Two {...</a></code></pre></div>
<p>And you canâ€™t work with them in terms that most lists can:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb21-1" data-line-number="1">(<span class="dv">1</span>, <span class="st">&quot;a&quot;</span>, <span class="fl">2.0</span>) + (<span class="st">&quot;b&quot;</span>, <span class="dv">-3</span>)</a></code></pre></div>
<p>So thatâ€™s where another tuple type can come in. A la <a href="https://twitter.com/rob_rix/status/633262294336729088">Rob Rix</a>, we could make a right-recursive tuple, terminated by <code class="sourceCode scala">()</code>. Thereâ€™ll be one overarching protocol:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb22-1" data-line-number="1">protocol _AnyTuple : CustomStringConvertible {</a>
<a class="sourceLine" id="cb22-2" data-line-number="2">  <span class="kw">var</span> tDesc: String { get }</a>
<a class="sourceLine" id="cb22-3" data-line-number="3">  <span class="kw">var</span> count: Int { get }</a>
<a class="sourceLine" id="cb22-4" data-line-number="4">  typealias Arity : Nat</a>
<a class="sourceLine" id="cb22-5" data-line-number="5">}</a></code></pre></div>
<p>And the empty tuple:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb23-1" data-line-number="1">struct EmptyTuple {}</a>
<a class="sourceLine" id="cb23-2" data-line-number="2"></a>
<a class="sourceLine" id="cb23-3" data-line-number="3">extension EmptyTuple : _AnyTuple {</a>
<a class="sourceLine" id="cb23-4" data-line-number="4">  <span class="kw">var</span> description: String { <span class="kw">return</span> <span class="st">&quot;()&quot;</span> }</a>
<a class="sourceLine" id="cb23-5" data-line-number="5">  <span class="kw">var</span> tDesc: String { <span class="kw">return</span>  <span class="st">&quot;)&quot;</span> }</a>
<a class="sourceLine" id="cb23-6" data-line-number="6">  <span class="kw">var</span> count: Int { <span class="kw">return</span> <span class="dv">0</span> }</a>
<a class="sourceLine" id="cb23-7" data-line-number="7">  typealias Arity = Zero</a>
<a class="sourceLine" id="cb23-8" data-line-number="8">}</a></code></pre></div>
<p>The descriptions are just there to give us a pretty printout. Hereâ€™s the tuple struct:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb24-1" data-line-number="1">struct NonEmptyTuple&lt;Element, Tail : _AnyTuple&gt; { <span class="kw">var</span> (head, tail): (Element, Tail) }</a>
<a class="sourceLine" id="cb24-2" data-line-number="2"></a>
<a class="sourceLine" id="cb24-3" data-line-number="3">extension NonEmptyTuple : _AnyTuple {</a>
<a class="sourceLine" id="cb24-4" data-line-number="4">  <span class="kw">var</span> count: Int { <span class="kw">return</span> tail.<span class="fu">count</span> + <span class="dv">1</span> }</a>
<a class="sourceLine" id="cb24-5" data-line-number="5">  <span class="kw">var</span> description: String {</a>
<a class="sourceLine" id="cb24-6" data-line-number="6">    <span class="kw">return</span> <span class="st">&quot;(&quot;</span> + String(reflecting: head) + tail.<span class="fu">tDesc</span></a>
<a class="sourceLine" id="cb24-7" data-line-number="7">  }</a>
<a class="sourceLine" id="cb24-8" data-line-number="8">  <span class="kw">var</span> tDesc: String {</a>
<a class="sourceLine" id="cb24-9" data-line-number="9">    <span class="kw">return</span> <span class="st">&quot;, &quot;</span> + String(reflecting: head) + tail.<span class="fu">tDesc</span></a>
<a class="sourceLine" id="cb24-10" data-line-number="10">  }</a>
<a class="sourceLine" id="cb24-11" data-line-number="11">  typealias Arity = Succ&lt;Tail.<span class="fu">Arity</span>&gt;</a>
<a class="sourceLine" id="cb24-12" data-line-number="12">}</a></code></pre></div>
<p>Now, to build a tuple. Since itâ€™s right-recursive, it might look like this:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="dv">1</span> , <span class="st">&quot;a&quot;</span> , <span class="fl">4.0</span> , ()</a></code></pre></div>
<p>But there are two problems with that: first, the comma is not overloadable. Thatâ€™s probably a good thing. Second, it doesnâ€™t really look like a tuple.</p>
<p><a href="https://twitter.com/jckarter/status/639953308401057793">Joe Groff</a> solved the first problem (albeit by committing a mortal sin). Just use a unicode comma! The only one I could find that works has the delightful name of Hypodiastole.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb26-1" data-line-number="1">infix operator â¸’ { associativity right precedence <span class="dv">90</span> }</a></code></pre></div>
<p>Trying to find it in the character viewer each time was a pain, though. So I went with the boring vertical bar.</p>
<p>The second problem can be solved with some sneaky overloading. Hereâ€™s what these functions look like:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb27-1" data-line-number="1">infix operator | { associativity right precedence <span class="dv">90</span> }</a>
<a class="sourceLine" id="cb27-2" data-line-number="2"></a>
<a class="sourceLine" id="cb27-3" data-line-number="3">func |&lt;E, T:_AnyTuple&gt;(lhs: E, rhs: T) -&gt; NonEmptyTuple&lt;E, T&gt; {</a>
<a class="sourceLine" id="cb27-4" data-line-number="4">  <span class="kw">return</span> <span class="fu">NonEmptyTuple</span>(head: lhs, tail: rhs)</a>
<a class="sourceLine" id="cb27-5" data-line-number="5">}</a>
<a class="sourceLine" id="cb27-6" data-line-number="6"></a>
<a class="sourceLine" id="cb27-7" data-line-number="7">func |&lt;E, T&gt;(lhs: E, rhs: T) -&gt; NonEmptyTuple&lt;E, NonEmptyTuple&lt;T, EmptyTuple&gt;&gt; {</a>
<a class="sourceLine" id="cb27-8" data-line-number="8">  <span class="kw">return</span> <span class="fu">NonEmptyTuple</span>(head: lhs, tail: <span class="fu">NonEmptyTuple</span>(head: rhs, tail: <span class="fu">EmptyTuple</span>()))</a>
<a class="sourceLine" id="cb27-9" data-line-number="9">}</a></code></pre></div>
<p>We can now, finally, build a Tuple:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb28-1" data-line-number="1">(<span class="dv">1</span> | <span class="fl">2.0</span> | <span class="st">&quot;a&quot;</span> ) <span class="co">// (1, 2.0, &quot;a&quot;)</span></a></code></pre></div>
<p>One little wrinkle with protocols, though. If you try this:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb29-1" data-line-number="1">extension NonEmptyTuple where Arity == Two {...</a></code></pre></div>
<p>Thereâ€™s an error: <code class="sourceCode scala">neither <span class="kw">type</span> in same-<span class="kw">type</span> refers to a generic parameter or associated <span class="kw">type</span></code>. Generally speaking, <code class="sourceCode scala">==</code> requirements in struct extensions donâ€™t work. However, they do work on protocols. So a wrapper protocol is needed:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb30-1" data-line-number="1">protocol Tuple : _AnyTuple {</a>
<a class="sourceLine" id="cb30-2" data-line-number="2">  typealias Head</a>
<a class="sourceLine" id="cb30-3" data-line-number="3">  typealias Tail : _AnyTuple</a>
<a class="sourceLine" id="cb30-4" data-line-number="4">  typealias Arity : NonZero</a>
<a class="sourceLine" id="cb30-5" data-line-number="5">  <span class="kw">var</span> head : Head { get }</a>
<a class="sourceLine" id="cb30-6" data-line-number="6">  <span class="kw">var</span> tail : Tail { get }</a>
<a class="sourceLine" id="cb30-7" data-line-number="7">}</a>
<a class="sourceLine" id="cb30-8" data-line-number="8"></a>
<a class="sourceLine" id="cb30-9" data-line-number="9">extension NonEmptyTuple : Tuple {}</a></code></pre></div>
<p>Alright. Time to work with it.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb31-1" data-line-number="1">extension Tuple where</a>
<a class="sourceLine" id="cb31-2" data-line-number="2">  Head : IntegerArithmeticType,</a>
<a class="sourceLine" id="cb31-3" data-line-number="3">  Tail : Tuple,</a>
<a class="sourceLine" id="cb31-4" data-line-number="4">  Tail.<span class="fu">Head</span> : IntegerArithmeticType,</a>
<a class="sourceLine" id="cb31-5" data-line-number="5">  Arity == Two {</a>
<a class="sourceLine" id="cb31-6" data-line-number="6">  func <span class="fu">matSum</span>(<span class="kw">with</span>: Self) -&gt; NonEmptyTuple&lt;Head, NonEmptyTuple&lt;Tail.<span class="fu">Head</span>, EmptyTuple&gt;&gt; {</a>
<a class="sourceLine" id="cb31-7" data-line-number="7">    let a = head + <span class="kw">with</span>.<span class="fu">head</span></a>
<a class="sourceLine" id="cb31-8" data-line-number="8">    let b = tail.<span class="fu">head</span> + <span class="kw">with</span>.<span class="fu">tail</span>.<span class="fu">head</span></a>
<a class="sourceLine" id="cb31-9" data-line-number="9">    <span class="kw">return</span> (a | b)</a>
<a class="sourceLine" id="cb31-10" data-line-number="10">  }</a>
<a class="sourceLine" id="cb31-11" data-line-number="11">}</a>
<a class="sourceLine" id="cb31-12" data-line-number="12"></a>
<a class="sourceLine" id="cb31-13" data-line-number="13">(<span class="dv">1</span> | <span class="dv">4</span>).<span class="fu">matSum</span>(<span class="dv">3</span> | <span class="dv">2</span>) <span class="co">// (4, 6)</span></a></code></pre></div>
<p>The basic advantage of this heterogenous list in Swift is its extensibility: you can treat tuples of length 2 as a type, or tuples where the third element is comparable as a type, and so on.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb32-1" data-line-number="1">extension Tuple where Tail : Tuple, Tail.<span class="fu">Head</span> : Comparable {</a>
<a class="sourceLine" id="cb32-2" data-line-number="2">  func isSecondLessThan</a>
<a class="sourceLine" id="cb32-3" data-line-number="3">    &lt;T : Tuple where T.<span class="fu">Tail</span> : Tuple, T.<span class="fu">Tail</span>.<span class="fu">Head</span> == Tail.<span class="fu">Head</span>&gt;</a>
<a class="sourceLine" id="cb32-4" data-line-number="4">    (<span class="kw">with</span>: T) -&gt; Bool {</a>
<a class="sourceLine" id="cb32-5" data-line-number="5">    <span class="kw">return</span> tail.<span class="fu">head</span> &lt; <span class="kw">with</span>.<span class="fu">tail</span>.<span class="fu">head</span></a>
<a class="sourceLine" id="cb32-6" data-line-number="6">  }</a>
<a class="sourceLine" id="cb32-7" data-line-number="7">}</a>
<a class="sourceLine" id="cb32-8" data-line-number="8"></a>
<a class="sourceLine" id="cb32-9" data-line-number="9">let a = (<span class="dv">1</span> | <span class="fl">3.0</span> | <span class="st">&quot;a&quot;</span> | <span class="dv">43</span>)</a>
<a class="sourceLine" id="cb32-10" data-line-number="10">let b = (<span class="st">&quot;c&quot;</span> | <span class="fl">4.0</span> | <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb32-11" data-line-number="11"></a>
<a class="sourceLine" id="cb32-12" data-line-number="12">a.<span class="fu">isSecondLessThan</span>(b)</a></code></pre></div>
<p>Most of this stuff is madness. The custom infix unicode operator should have tipped you off to that: but itâ€™s not to say that <em>nothing</em> here is useful. Compile-time warnings are great. I think the fixed-length array works. But this tuple stuff is too hacky: it only becomes useful if there are some low-level changes to the language.</p>
<p>Whatâ€™s really useful, though, is <em>thinking</em> about types with dependency in mind. Getting familiar with what is and isnâ€™t possible to write between the <code class="sourceCode scala">where</code> and the <code class="sourceCode scala">{</code> in an extension gives you a good idea of how powerful protocols and their specialisations are.</p>
<p>For some extra reading, check out <a href="https://ghc.haskell.org/trac/ghc/wiki/DependentHaskell">DependentHaskell</a>, <a href="https://wiki.haskell.org/Heterogenous_collections">Heterogenous Collections in Haskell</a>, and <a href="http://programmers.stackexchange.com/questions/132835/is-there-a-specific-purpose-for-heterogeneous-lists">Strongly Typed Heterogenous Collections</a>. Iâ€™m muddling my way through seeing whatâ€™s possible with length-indexed lists, heterogenous lists, and numeral types <a href="https://github.com/oisdk/PretendDependSwift">over here</a>, if youâ€™re interested.</p>
]]></description>
    <pubDate>Sun, 06 Sep 2015 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2015-09-06-dependent-types.html</guid>
    <dc:creator>Donnacha OisÃ­n Kidney</dc:creator>
</item>
<item>
    <title>Using Protocols to Build a (very) Generic Deque</title>
    <link>https://doisinkidney.com/posts/2015-08-24-generic-deque.html</link>
    <description><![CDATA[<div class="info">
    Posted on August 24, 2015
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Swift.html">Swift</a>, <a href="/tags/Data%20Structures.html">Data Structures</a>
    
</div>

<p>(Download the playground to use the code and see the outputs)</p>
<p>This post is an update on a <a href="https://bigonotetaking.wordpress.com/2015/08/09/yet-another-root-of-all-evil/">previous implementation of a Deque</a>. A full implementation of this Deque is available <a href="https://github.com/oisdk/SwiftDataStructures/blob/master/SwiftDataStructures/Deque.swift">here</a>.</p>
<p>A Deque is a data structure comprised of two stacks, facing opposite directions. In this way, operations at either end of the Deque have the same complexity as operations on one end of the underlying stack. This implementation uses two arrays, with the front reversed: appending, prepending, and removal of the first and last elements are all (amortized) O(1).</p>
<p>The standard library has three <code class="sourceCode scala">Array</code> structs: <code class="sourceCode scala">Array</code>, <code class="sourceCode scala">ArraySlice</code>, and <code class="sourceCode scala">ContiguousArray</code>. They all have the same interface, with different underlying implementations. An <code class="sourceCode scala">Array</code> is a standard vector-like structure, which allows O(1) amortized appending, fast iteration, etc. A <code class="sourceCode scala">ContiguousArray</code> has stricter rules about contiguity, but itâ€™s not bridged to Objective-C.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb1-1" data-line-number="1">let array  = [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>]</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">let cArray: ContiguousArray = [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>]</a></code></pre></div>
<p>An <code class="sourceCode scala">ArraySlice</code> is a reference into an <code class="sourceCode scala">Array</code> or <code class="sourceCode scala">ContiguousArray</code>, for more efficient slicing. All the information an <code class="sourceCode scala">ArraySlice</code> contains is the beginning and end points of the slice (as well as any changes made to the slice separate from the array)</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb2-1" data-line-number="1">let slice = array[<span class="dv">0</span>..&lt;<span class="dv">6</span>]</a></code></pre></div>
<p>To replicate these semantics in a Deque requires three separate structs: one with an <code class="sourceCode scala">Array</code> as the stack, another with an <code class="sourceCode scala">ArraySlice</code> as the stack, and a third with a <code class="sourceCode scala">ContiguousArray</code>. The standard library seems to duplicate the structs, along with their methods and properties.</p>
<p>It would be much nicer to just define a protocol that represented the <em>difference</em> between the deque types: then you could just write the methods and properties once, on top of it. Something like this:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb3-1" data-line-number="1">protocol DequeType {</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  typealias Container : RangeReplaceableCollectionType, MutableSliceable</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">  <span class="kw">var</span> front: Container { get set }</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">  <span class="kw">var</span> back : Container { get set }</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">  <span class="fu">init</span>()</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">}</a></code></pre></div>
<p>Thereâ€™s one problem with this: both stacks need to be made public. It would be much nicer to hide the stacks (especially since an invariant needs to be checked and maintained on every mutation). If anyone has an idea of how to accomplish that, <a href="https://twitter.com/oisdk">tweet me</a>.</p>
<p>The first method to implement is a subscript. Indexing is difficult, because the front stack will be reversed, so the index used to get in to the Deque will need to be translated into an equivalent index in the array.</p>
<p>Any (valid) index will point into either the front or back queue, and the transformations applied to it in each case is different. If itâ€™s in the front, the end result will look like <code class="sourceCode scala">front[front.<span class="fu">endIndex</span> - <span class="dv">1</span> - i]</code>, whereas if itâ€™s in the back, it should be <code class="sourceCode scala">back[i - front.<span class="fu">endIndex</span>]</code>. Thereâ€™s nothing specified about the Containers except that theyâ€™re <code class="sourceCode scala">RangeReplaceableCollectionType</code> and <code class="sourceCode scala">MutableSliceable</code>, so the index types will have to be as generic as possible. (you could specify <code class="sourceCode scala">where Index == Int</code>, but thatâ€™s more specific than needed, and not very extensible.)</p>
<p>Both of those transformations are subtractions, an operation thatâ€™s possible on <code>RandomAccessIndexType</code>s with the <code class="sourceCode scala">advancedBy</code> method. <code class="sourceCode scala">advancedBy</code> takes the associated <code class="sourceCode scala">Distance</code> type of the <code class="sourceCode scala">RandomAccessIndexType</code>. Thatâ€™s enough information to figure out that the Dequeâ€™s index type must be the same as the Distance of the Index of the Container.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb4-1" data-line-number="1">extension DequeType {</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  typealias Index = Container.<span class="fu">Index</span>.<span class="fu">Distance</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">}</a></code></pre></div>
<p>The method that will translate an index into the relevant index in the stacks will return an enum:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb5-1" data-line-number="1">public enum IndexLocation&lt;I&gt; {</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">  <span class="kw">case</span> <span class="fu">Front</span>(I), <span class="fu">Back</span>(I)</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">}</a></code></pre></div>
<p>Then, the translate method itself:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb6-1" data-line-number="1">extension DequeType where</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  Container.<span class="fu">Index</span> : RandomAccessIndexType,</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  Container.<span class="fu">Index</span>.<span class="fu">Distance</span> : ForwardIndexType {</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">  </a>
<a class="sourceLine" id="cb6-5" data-line-number="5">  <span class="kw">private</span> func <span class="fu">translate</span>(i: Container.<span class="fu">Index</span>.<span class="fu">Distance</span>)</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">    -&gt; IndexLocation&lt;Container.<span class="fu">Index</span>&gt; {</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">    <span class="kw">return</span> i &lt; front.<span class="fu">count</span> ?</a>
<a class="sourceLine" id="cb6-8" data-line-number="8">      .<span class="fu">Front</span>(front.<span class="fu">endIndex</span>.<span class="fu">predecessor</span>().<span class="fu">advancedBy</span>(-i)) :</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">      .<span class="fu">Back</span>(back.<span class="fu">startIndex</span>.<span class="fu">advancedBy</span>(i - front.<span class="fu">count</span>))</a>
<a class="sourceLine" id="cb6-10" data-line-number="10">  }</a>
<a class="sourceLine" id="cb6-11" data-line-number="11">}</a></code></pre></div>
<p>This performs two steps: 1. Check which stack itâ€™s in. 2. Subtract in the appropriate order</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb7-1" data-line-number="1">let d: Deque = [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>] <span class="co">// [1, 2, 3 | 4, 5, 6]</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">d.<span class="fu">translate</span>(<span class="dv">0</span>) <span class="co">// Front: 2</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">d.<span class="fu">translate</span>(<span class="dv">4</span>) <span class="co">// Back: 1</span></a></code></pre></div>
<p>This means that the logic for converting distance to index is separated from the logic for actual indexing. Great! Hereâ€™s the indexing:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb8-1" data-line-number="1">extension DequeType where</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  Container.<span class="fu">Index</span> : RandomAccessIndexType,</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  Container.<span class="fu">Index</span>.<span class="fu">Distance</span> : ForwardIndexType {</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">  <span class="kw">var</span> startIndex: Container.<span class="fu">Index</span>.<span class="fu">Distance</span> { <span class="kw">return</span> <span class="dv">0</span> }</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">  <span class="kw">var</span> endIndex  : Container.<span class="fu">Index</span>.<span class="fu">Distance</span> { <span class="kw">return</span> front.<span class="fu">count</span> + back.<span class="fu">count</span> }</a>
<a class="sourceLine" id="cb8-6" data-line-number="6">  <span class="fu">subscript</span>(i: Container.<span class="fu">Index</span>.<span class="fu">Distance</span>) -&gt; Container.<span class="fu">Generator</span>.<span class="fu">Element</span> {</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">    get {</a>
<a class="sourceLine" id="cb8-8" data-line-number="8">      switch <span class="fu">translate</span>(i) {</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">      <span class="kw">case</span> let .<span class="fu">Front</span>(i): <span class="kw">return</span> front[i]</a>
<a class="sourceLine" id="cb8-10" data-line-number="10">      <span class="kw">case</span> let .<span class="fu">Back</span>(i): <span class="kw">return</span> back[i]</a>
<a class="sourceLine" id="cb8-11" data-line-number="11">      }</a>
<a class="sourceLine" id="cb8-12" data-line-number="12">    } set {</a>
<a class="sourceLine" id="cb8-13" data-line-number="13">      switch <span class="fu">translate</span>(i) {</a>
<a class="sourceLine" id="cb8-14" data-line-number="14">      <span class="kw">case</span> let .<span class="fu">Front</span>(i): front[i] = newValue</a>
<a class="sourceLine" id="cb8-15" data-line-number="15">      <span class="kw">case</span> let .<span class="fu">Back</span>(i): back[i] = newValue</a>
<a class="sourceLine" id="cb8-16" data-line-number="16">      }</a>
<a class="sourceLine" id="cb8-17" data-line-number="17">    }</a>
<a class="sourceLine" id="cb8-18" data-line-number="18">  }</a>
<a class="sourceLine" id="cb8-19" data-line-number="19">}</a></code></pre></div>
<p>This makes things much easier to test and debug.</p>
<p>Hereâ€™s where the power of protocols becomes obvious. If you go back to the original definition of <code class="sourceCode scala">DequeType</code>, you can add <code class="sourceCode scala">Indexable</code>. It may seem like now only indexable things can conform, but what happens in practice is that when <code class="sourceCode scala">Indexable</code> looks for its requirements, <em>it can use the implementations in DequeType</em>. That means that weâ€™ve just made anything that can conform to <code class="sourceCode scala">DequeType</code> indexable. Thatâ€™s awesome.</p>
<p>Next job is ranged indices. This is a good bit more complicated than the individual indices, so it definitely will benefit from being separated into a translate method:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb9-1" data-line-number="1">extension DequeType where</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">  Container.<span class="fu">Index</span> : RandomAccessIndexType,</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  Container.<span class="fu">Index</span>.<span class="fu">Distance</span> : BidirectionalIndexType {</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">  </a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  <span class="kw">private</span> func translate</a>
<a class="sourceLine" id="cb9-6" data-line-number="6">    (i: Range&lt;Container.<span class="fu">Index</span>.<span class="fu">Distance</span>&gt;)</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">    -&gt; IndexRangeLocation&lt;Container.<span class="fu">Index</span>&gt; {</a>
<a class="sourceLine" id="cb9-8" data-line-number="8">      <span class="kw">if</span> i.<span class="fu">endIndex</span> &lt;= front.<span class="fu">count</span> {</a>
<a class="sourceLine" id="cb9-9" data-line-number="9">        let s = front.<span class="fu">endIndex</span>.<span class="fu">advancedBy</span>(-i.<span class="fu">endIndex</span>)</a>
<a class="sourceLine" id="cb9-10" data-line-number="10">        <span class="kw">if</span> s == front.<span class="fu">startIndex</span> &amp;&amp; i.<span class="fu">isEmpty</span> { <span class="kw">return</span> .<span class="fu">Between</span> }</a>
<a class="sourceLine" id="cb9-11" data-line-number="11">        let e = front.<span class="fu">endIndex</span>.<span class="fu">advancedBy</span>(-i.<span class="fu">startIndex</span>)</a>
<a class="sourceLine" id="cb9-12" data-line-number="12">        <span class="kw">return</span> .<span class="fu">Front</span>(s..&lt;e)</a>
<a class="sourceLine" id="cb9-13" data-line-number="13">      }</a>
<a class="sourceLine" id="cb9-14" data-line-number="14">      <span class="kw">if</span> i.<span class="fu">startIndex</span> &gt;= front.<span class="fu">count</span> {</a>
<a class="sourceLine" id="cb9-15" data-line-number="15">        let s = back.<span class="fu">startIndex</span>.<span class="fu">advancedBy</span>(i.<span class="fu">startIndex</span> - front.<span class="fu">count</span>)</a>
<a class="sourceLine" id="cb9-16" data-line-number="16">        let e = back.<span class="fu">startIndex</span>.<span class="fu">advancedBy</span>(i.<span class="fu">endIndex</span> - front.<span class="fu">count</span>)</a>
<a class="sourceLine" id="cb9-17" data-line-number="17">        <span class="kw">return</span> .<span class="fu">Back</span>(s..&lt;e)</a>
<a class="sourceLine" id="cb9-18" data-line-number="18">      }</a>
<a class="sourceLine" id="cb9-19" data-line-number="19">      let f = front.<span class="fu">startIndex</span>..&lt;front.<span class="fu">endIndex</span>.<span class="fu">advancedBy</span>(-i.<span class="fu">startIndex</span>)</a>
<a class="sourceLine" id="cb9-20" data-line-number="20">      let b = back.<span class="fu">startIndex</span>..&lt;back.<span class="fu">startIndex</span>.<span class="fu">advancedBy</span>(i.<span class="fu">endIndex</span> - front.<span class="fu">count</span>)</a>
<a class="sourceLine" id="cb9-21" data-line-number="21">      <span class="kw">return</span> .<span class="fu">Over</span>(f, b)</a>
<a class="sourceLine" id="cb9-22" data-line-number="22">  }</a>
<a class="sourceLine" id="cb9-23" data-line-number="23">}</a>
<a class="sourceLine" id="cb9-24" data-line-number="24"></a>
<a class="sourceLine" id="cb9-25" data-line-number="25">let otherDeque: Deque = [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>] <span class="co">// [0, 1, 2 | 3, 4, 5]</span></a>
<a class="sourceLine" id="cb9-26" data-line-number="26"></a>
<a class="sourceLine" id="cb9-27" data-line-number="27">otherDeque.<span class="fu">translate</span>(<span class="dv">0</span>...<span class="dv">2</span>) <span class="co">// Front: 0..&lt;3</span></a>
<a class="sourceLine" id="cb9-28" data-line-number="28">otherDeque.<span class="fu">translate</span>(<span class="dv">4</span>...<span class="dv">5</span>) <span class="co">// Back: 1..&lt;3</span></a>
<a class="sourceLine" id="cb9-29" data-line-number="29">otherDeque.<span class="fu">translate</span>(<span class="dv">2</span>...<span class="dv">5</span>) <span class="co">// Over: 0..&lt;1, 0..&lt;3</span></a>
<a class="sourceLine" id="cb9-30" data-line-number="30">otherDeque.<span class="fu">translate</span>(<span class="dv">3</span>..&lt;<span class="dv">3</span>) <span class="co">// Between</span></a></code></pre></div>
<p>The invariant that must be maintained in the deque is this: if either stack has more than one element, the other cannot be empty. If the invariant is violated, the longer stack is reversed, and put in place of the shorter.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb10-1" data-line-number="1">public enum Balance {</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">  <span class="kw">case</span> FrontEmpty, BackEmpty, Balanced</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">}</a>
<a class="sourceLine" id="cb10-4" data-line-number="4"></a>
<a class="sourceLine" id="cb10-5" data-line-number="5">extension DequeType {</a>
<a class="sourceLine" id="cb10-6" data-line-number="6">  </a>
<a class="sourceLine" id="cb10-7" data-line-number="7">  public <span class="kw">var</span> balance: Balance {</a>
<a class="sourceLine" id="cb10-8" data-line-number="8">    <span class="fu">let</span> (f, b) = (front.<span class="fu">count</span>, back.<span class="fu">count</span>)</a>
<a class="sourceLine" id="cb10-9" data-line-number="9">    <span class="kw">if</span> f == <span class="dv">0</span> {</a>
<a class="sourceLine" id="cb10-10" data-line-number="10">      <span class="kw">if</span> b &gt; <span class="dv">1</span> {</a>
<a class="sourceLine" id="cb10-11" data-line-number="11">        <span class="kw">return</span> .<span class="fu">FrontEmpty</span></a>
<a class="sourceLine" id="cb10-12" data-line-number="12">      }</a>
<a class="sourceLine" id="cb10-13" data-line-number="13">    } <span class="kw">else</span> <span class="kw">if</span> b == <span class="dv">0</span> {</a>
<a class="sourceLine" id="cb10-14" data-line-number="14">      <span class="kw">if</span> f &gt; <span class="dv">1</span> {</a>
<a class="sourceLine" id="cb10-15" data-line-number="15">        <span class="kw">return</span> .<span class="fu">BackEmpty</span></a>
<a class="sourceLine" id="cb10-16" data-line-number="16">      }</a>
<a class="sourceLine" id="cb10-17" data-line-number="17">    }</a>
<a class="sourceLine" id="cb10-18" data-line-number="18">    <span class="kw">return</span> .<span class="fu">Balanced</span></a>
<a class="sourceLine" id="cb10-19" data-line-number="19">  }</a>
<a class="sourceLine" id="cb10-20" data-line-number="20">  </a>
<a class="sourceLine" id="cb10-21" data-line-number="21">  public <span class="kw">var</span> isBalanced: Bool {</a>
<a class="sourceLine" id="cb10-22" data-line-number="22">    <span class="kw">return</span> balance == .<span class="fu">Balanced</span></a>
<a class="sourceLine" id="cb10-23" data-line-number="23">  }</a>
<a class="sourceLine" id="cb10-24" data-line-number="24">}</a></code></pre></div>
<p>A deque is a good data structure for certain uses, especially those that require popping and appending from either end. <code class="sourceCode scala"><span class="fu">popFirst</span>()</code> and <code class="sourceCode scala"><span class="fu">popLast</span>()</code> arenâ€™t included in the standard <code class="sourceCode scala">RangeReplaceableCollectionType</code>, though, so weâ€™ll have to add our own.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb11-1" data-line-number="1">extension RangeReplaceableCollectionType where Index : BidirectionalIndexType {</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">  <span class="kw">private</span> mutating func <span class="fu">popLast</span>() -&gt; Generator.<span class="fu">Element</span>? {</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">    <span class="kw">return</span> isEmpty ? nil : <span class="fu">removeLast</span>()</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">  }</a>
<a class="sourceLine" id="cb11-5" data-line-number="5">}</a>
<a class="sourceLine" id="cb11-6" data-line-number="6"></a>
<a class="sourceLine" id="cb11-7" data-line-number="7"><span class="kw">var</span> mutableDeque: Deque = [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>]</a>
<a class="sourceLine" id="cb11-8" data-line-number="8">mutableDeque.<span class="fu">popLast</span>() <span class="co">// 5</span></a>
<a class="sourceLine" id="cb11-9" data-line-number="9">mutableDeque           <span class="co">// [0, 1, 2 | 3, 4]</span></a>
<a class="sourceLine" id="cb11-10" data-line-number="10"></a>
<a class="sourceLine" id="cb11-11" data-line-number="11">extension DequeType where Container.<span class="fu">Index</span> : BidirectionalIndexType {</a>
<a class="sourceLine" id="cb11-12" data-line-number="12">  public mutating func <span class="fu">popLast</span>() -&gt; Container.<span class="fu">Generator</span>.<span class="fu">Element</span>? {</a>
<a class="sourceLine" id="cb11-13" data-line-number="13">    <span class="kw">return</span> back.<span class="fu">popLast</span>()</a>
<a class="sourceLine" id="cb11-14" data-line-number="14">  }</a>
<a class="sourceLine" id="cb11-15" data-line-number="15">}</a></code></pre></div>
<p>The method needs to include <code class="sourceCode scala"><span class="fu">check</span>()</code>, which we can do with <code>defer</code></p>
<div class="sourceCode" id="cb12"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb12-1" data-line-number="1">mutating func <span class="fu">popLast</span>() -&gt; Container.<span class="fu">Generator</span>.<span class="fu">Element</span>? {</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">  defer { <span class="fu">check</span>() }</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">  <span class="kw">return</span> back.<span class="fu">popLast</span>()</a>
<a class="sourceLine" id="cb12-4" data-line-number="4">}</a>
<a class="sourceLine" id="cb12-5" data-line-number="5"></a>
<a class="sourceLine" id="cb12-6" data-line-number="6">mutableDeque.<span class="fu">popLast</span>() <span class="co">// 4</span></a>
<a class="sourceLine" id="cb12-7" data-line-number="7">mutableDeque           <span class="co">// [0, 1, 2 | 3]</span></a>
<a class="sourceLine" id="cb12-8" data-line-number="8">mutableDeque.<span class="fu">popLast</span>() <span class="co">// 3</span></a>
<a class="sourceLine" id="cb12-9" data-line-number="9">mutableDeque           <span class="co">// [0 | 1, 2]</span></a></code></pre></div>
<p>You also canâ€™t just pop from the back queue in <code class="sourceCode scala"><span class="fu">popLast</span>()</code>, because it may be the case that the front stack has one element left</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb13-1" data-line-number="1">mutating func <span class="fu">popLast</span>() -&gt; Container.<span class="fu">Generator</span>.<span class="fu">Element</span>? {</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">  defer { <span class="fu">check</span>() }</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">  <span class="kw">return</span> back.<span class="fu">popLast</span>() ?? front.<span class="fu">popLast</span>()</a>
<a class="sourceLine" id="cb13-4" data-line-number="4">}</a>
<a class="sourceLine" id="cb13-5" data-line-number="5"></a>
<a class="sourceLine" id="cb13-6" data-line-number="6">mutableDeque.<span class="fu">popLast</span>() <span class="co">// 2</span></a>
<a class="sourceLine" id="cb13-7" data-line-number="7">mutableDeque.<span class="fu">popLast</span>() <span class="co">// 1</span></a>
<a class="sourceLine" id="cb13-8" data-line-number="8">mutableDeque           <span class="co">// [0|]</span></a>
<a class="sourceLine" id="cb13-9" data-line-number="9">mutableDeque.<span class="fu">popLast</span>() <span class="co">// 0</span></a>
<a class="sourceLine" id="cb13-10" data-line-number="10">mutableDeque           <span class="co">// [|]</span></a>
<a class="sourceLine" id="cb13-11" data-line-number="11">mutableDeque.<span class="fu">popLast</span>() <span class="co">// nil</span></a></code></pre></div>
<p>The rest of the Deque was easy, with little to no repetition. Using protocols in this way was really surprisingly powerful: now, you can define a <code class="sourceCode scala">DequeType</code>, with full access to all of the collection methods, all the way up to <code class="sourceCode scala">RangeReplaceableCollectionType</code>, in five lines:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb14-1" data-line-number="1">public struct Deque&lt;Element&gt; : DequeType {</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">  public <span class="kw">var</span> front, back: [Element]</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">  public typealias SubSequence = DequeSlice&lt;Element&gt;</a>
<a class="sourceLine" id="cb14-4" data-line-number="4">  public <span class="fu">init</span>() { (front, back) = ([], []) }</a>
<a class="sourceLine" id="cb14-5" data-line-number="5">}</a>
<a class="sourceLine" id="cb14-6" data-line-number="6"></a>
<a class="sourceLine" id="cb14-7" data-line-number="7">public struct DequeSlice&lt;Element&gt; : DequeType {</a>
<a class="sourceLine" id="cb14-8" data-line-number="8">  public <span class="kw">var</span> front, back: ArraySlice&lt;Element&gt;</a>
<a class="sourceLine" id="cb14-9" data-line-number="9">  public typealias SubSequence = DequeSlice</a>
<a class="sourceLine" id="cb14-10" data-line-number="10">  public <span class="fu">init</span>() { (front, back) = ([], []) }</a>
<a class="sourceLine" id="cb14-11" data-line-number="11">}</a></code></pre></div>
<p>Thereâ€™s no performance hit, thereâ€™s no safety problems. I only have one version of code to test, one version to change, one version to read. Itâ€™s completely extensible: you could use any kind of stack for the front and back. Even another Deque, if you were so inclined:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb15-1" data-line-number="1">struct DequeDeque&lt;Element&gt; : DequeType {</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">  <span class="kw">var</span> front, back: Deque&lt;Element&gt;</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">  typealias SubSequence = DequeDequeSlice&lt;Element&gt;</a>
<a class="sourceLine" id="cb15-4" data-line-number="4">  <span class="fu">init</span>() { front = <span class="fu">Deque</span>(); back = <span class="fu">Deque</span>() }</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">}</a>
<a class="sourceLine" id="cb15-6" data-line-number="6"></a>
<a class="sourceLine" id="cb15-7" data-line-number="7">struct DequeDequeSlice&lt;Element&gt; : DequeType {</a>
<a class="sourceLine" id="cb15-8" data-line-number="8">  <span class="kw">var</span> front, back: DequeSlice&lt;Element&gt;</a>
<a class="sourceLine" id="cb15-9" data-line-number="9">  typealias SubSequence = DequeDequeSlice</a>
<a class="sourceLine" id="cb15-10" data-line-number="10">  <span class="fu">init</span>() { front = <span class="fu">DequeSlice</span>(); back = <span class="fu">DequeSlice</span>() }</a>
<a class="sourceLine" id="cb15-11" data-line-number="11">}</a>
<a class="sourceLine" id="cb15-12" data-line-number="12"></a>
<a class="sourceLine" id="cb15-13" data-line-number="13">let dd: DequeDeque = [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>]</a>
<a class="sourceLine" id="cb15-14" data-line-number="14">dd.<span class="fu">front</span> <span class="co">// [4 | 3, 2, 1]</span></a>
<a class="sourceLine" id="cb15-15" data-line-number="15">dd.<span class="fu">back</span>  <span class="co">// [5 | 6, 7, 8]</span></a></code></pre></div>
<p>Woo protocols!</p>
]]></description>
    <pubDate>Mon, 24 Aug 2015 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2015-08-24-generic-deque.html</guid>
    <dc:creator>Donnacha OisÃ­n Kidney</dc:creator>
</item>
<item>
    <title>A Trie in Swift</title>
    <link>https://doisinkidney.com/posts/2015-08-11-swift-trie.html</link>
    <description><![CDATA[<div class="info">
    Posted on August 11, 2015
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Swift.html">Swift</a>, <a href="/tags/Data%20Structures.html">Data Structures</a>
    
</div>

<p>If you google â€œcool data structuresâ€ youâ€™ll getÂ <a href="http://stackoverflow.com/questions/500607/what-are-the-lesser-known-but-useful-data-structures">this</a> as your first result. Itâ€™s a stackoverflow question: â€œWhat are the lesser known but useful data structures?â€. And the top answer is a Trie. I read up on them, and found out a lot of cool things about their use (as well as finding out that Iâ€™m now the kind of person who googlesÂ â€œcool data structuresâ€). So I rocked on up to my playground, and got writing.</p>
<p>A Trie is a prefix tree. Itâ€™s another recursive data structure: each Trie contains other children Tries, identifiable by their prefixes.</p>
<p>Itâ€™s a bit of a hipster data structure, not very widely used, but itâ€™s got some useful applications. Itâ€™s got set-like operations, with insertion and searching each at <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math>, where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> is the length of the sequence being searched for. A Set is the only way to go for hashable, unordered elements. But, if youâ€™ve got <em>sequences</em> of hashable elements, a Trie might be for you. (one thing to note is that Sets are hashable themselves, so if the sequences you want to store are unordered, a Set of Sets is more applicable)</p>
<figure>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/be/Trie_example.svg/1092px-Trie_example.svg.png" alt="A trie for keys" /><figcaption>A trie for keys</figcaption>
</figure>
<p>In Swift, we can do this by having every Trie contain a dictionary of prefixes and Tries. Something like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb1-1" data-line-number="1">public struct Trie&lt;Element : Hashable&gt; {</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  <span class="kw">private</span> <span class="kw">var</span> children: [Element:Trie&lt;Element&gt;]</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">}</a></code></pre></div>
<p>We donâ€™t run into the problem of structs not being allowed to be recursive here, because we donâ€™t directly store a Trie within a Trie - we store a <em>dictionary</em>, and therefore a reference to the child Tries. In this dictionary, the keys correspond to the prefixes. So how do we fill it up? Like lists, we can use the decomposition properties of generators:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb2-1" data-line-number="1">extension Trie {</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  <span class="kw">private</span> init&lt;G : GeneratorType where G.<span class="fu">Element</span> == Element&gt;(<span class="kw">var</span> gen: G) {</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">    <span class="kw">if</span> let head = gen.<span class="fu">next</span>() {</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">      children = [head:<span class="fu">Trie</span>(gen:gen)]</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">    } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">      children = [:]</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">    }</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">  }</a>
<a class="sourceLine" id="cb2-9" data-line-number="9">  public init</a>
<a class="sourceLine" id="cb2-10" data-line-number="10">    &lt;S : SequenceType where S.<span class="fu">Generator</span>.<span class="fu">Element</span> == Element&gt;</a>
<a class="sourceLine" id="cb2-11" data-line-number="11">    (_ seq: S) {</a>
<a class="sourceLine" id="cb2-12" data-line-number="12">      self.<span class="fu">init</span>(gen: seq.<span class="fu">generate</span>())</a>
<a class="sourceLine" id="cb2-13" data-line-number="13">  }</a>
<a class="sourceLine" id="cb2-14" data-line-number="14">}</a></code></pre></div>
<p>Thatâ€™s not really enough. That can store one sequence, but we need an <code class="sourceCode scala">insert</code> function. Here ya go:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb3-1" data-line-number="1">extension Trie {</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  <span class="kw">private</span> mutating func insert</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">    &lt;G : GeneratorType where G.<span class="fu">Element</span> == Element&gt;</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">    (<span class="kw">var</span> gen: G) {</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">      <span class="kw">if</span> let head = gen.<span class="fu">next</span>() {</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">        children[head]?.<span class="fu">insert</span>(gen) ?? {children[head] = <span class="fu">Trie</span>(gen: gen)}()</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">      }</a>
<a class="sourceLine" id="cb3-8" data-line-number="8">  }</a>
<a class="sourceLine" id="cb3-9" data-line-number="9">  public mutating func insert</a>
<a class="sourceLine" id="cb3-10" data-line-number="10">    &lt;S : SequenceType where S.<span class="fu">Generator</span>.<span class="fu">Element</span> == Element&gt;</a>
<a class="sourceLine" id="cb3-11" data-line-number="11">    (seq: S) {</a>
<a class="sourceLine" id="cb3-12" data-line-number="12">      <span class="fu">insert</span>(seq.<span class="fu">generate</span>())</a>
<a class="sourceLine" id="cb3-13" data-line-number="13">  }</a>
<a class="sourceLine" id="cb3-14" data-line-number="14">}</a></code></pre></div>
<p>Thereâ€™s a line in there that some may find offensive:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb4-1" data-line-number="1">children[head]?.<span class="fu">insert</span>(gen) ?? {children[head] = <span class="fu">Trie</span>(gen: gen)}()</a></code></pre></div>
<p>And, to be honest, Iâ€™m not a huge fan of it myself. Itâ€™s making use of the fact that you can call mutating methods on optionals with chaining. When you do it in this example, the optional is returned by the dictionary lookup: we then want to mutate that value, if itâ€™s there, with an insertion.</p>
<p>If itâ€™s <em>not</em> there, though, we want to add it in, so weâ€™ve got to have some way of understanding and dealing with that. We could try and extract the child Trie, like this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">if</span> let head = gen.<span class="fu">next</span>() {</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">  <span class="kw">if</span> <span class="kw">var</span> child = children[head] {</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">    child.<span class="fu">insert</span>(gen)</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">  } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">    children[head] = <span class="fu">Trie</span>(gen: gen)</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">  }</a>
<a class="sourceLine" id="cb5-7" data-line-number="7">}</a></code></pre></div>
<p>But the child there is just a copy of the actual child in the Trie we want to mutate. We could then set it back to the dictionary entry - but at this stage it feels like a lot of extra, inefficient work.</p>
<p>So, you can make use of the fact the functions which donâ€™t return anything actually <em>do</em> return something: a special value called <code class="sourceCode scala">Void</code>, or <code class="sourceCode scala">()</code>. Except that, in this case, itâ€™s <code class="sourceCode scala">()?</code> (or <code class="sourceCode scala">Optional&amp;lt;Void&amp;gt;</code>). Weâ€™re not interested in the void itself, obviously, just whether or not itâ€™s <code class="sourceCode scala">nil</code>. So, one way you could use it would be like this:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">if</span> let _ = children[head]?.<span class="fu">insert</span>(gen) { <span class="kw">return</span> }</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">children[head] = <span class="fu">Trie</span>(gen: gen)</a></code></pre></div>
<p>Or, to use <code class="sourceCode scala">guard</code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb7-1" data-line-number="1">guard let _ = children[head]?.<span class="fu">insert</span>(gen) <span class="kw">else</span> { children[head] = <span class="fu">Trie</span>(gen: gen) }</a></code></pre></div>
<p>But I think the nil coalescing operator is a little clearer, without the distraction of <code class="sourceCode scala">let</code> or <code class="sourceCode scala">_</code>.</p>
<p>This data structure, as you can see, has a very different feel to the list. For a start, itâ€™s much more mutable, with in-place mutating methods being a little easier than methods that return a new Trie. Also, laziness is pretty much out of the question: almost every imaginable useful method would involve evaluation of the entire Trie. (if anyone <em>does</em> have a useful way of thinking about Tries lazily, Iâ€™d love to hear it)</p>
<p>The contains function, the most important of them all, is here:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb8-1" data-line-number="1">extension Trie {</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  <span class="kw">private</span> func contains</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">    &lt;G : GeneratorType where G.<span class="fu">Element</span> == Element&gt;</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">    (<span class="kw">var</span> gen: G) -&gt; Bool {</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">      <span class="kw">return</span> gen.<span class="fu">next</span>().<span class="fu">map</span>{self.<span class="fu">children</span>[$<span class="dv">0</span>]?.<span class="fu">contains</span>(gen) ?? <span class="kw">false</span>} ?? <span class="kw">true</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">  }</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">  public func contains</a>
<a class="sourceLine" id="cb8-8" data-line-number="8">    &lt;S : SequenceType where S.<span class="fu">Generator</span>.<span class="fu">Element</span> == Element&gt;</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">    (seq: S) -&gt; Bool {</a>
<a class="sourceLine" id="cb8-10" data-line-number="10">      <span class="kw">return</span> <span class="fu">contains</span>(seq.<span class="fu">generate</span>())</a>
<a class="sourceLine" id="cb8-11" data-line-number="11">  }</a>
<a class="sourceLine" id="cb8-12" data-line-number="12">}</a></code></pre></div>
<p>So this uses more generators. If the generator is empty (<code class="sourceCode scala">gen.<span class="fu">next</span>()</code> returns <code class="sourceCode scala">nil</code>), then the Trie contains that sequence, as we have not yet found a dictionary without that element. Within the <code class="sourceCode scala"><span class="fu">map</span>()</code> we search for the next element from the generator. If <em>that</em> returns <code class="sourceCode scala">nil</code>, then the Trie doesnâ€™t contain that sequence. Finally, if none of that works, return whether or not the child Trie contains the rest of the generator. Letâ€™s try it out:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">var</span> jo = <span class="fu">Trie</span>([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>])</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">jo.<span class="fu">insert</span>([<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>])</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">jo.<span class="fu">insert</span>([<span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>])</a>
<a class="sourceLine" id="cb9-4" data-line-number="4"></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">jo.<span class="fu">contains</span>([<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>]) <span class="co">// true</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6">jo.<span class="fu">contains</span>([<span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">3</span>]) <span class="co">// false</span></a></code></pre></div>
<p>Thereâ€™s a catch. The <code class="sourceCode scala">contains</code> method doesnâ€™t work as weâ€™d like it to:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb10-1" data-line-number="1">jo.<span class="fu">contains</span>([<span class="dv">1</span>, <span class="dv">2</span>]) <span class="co">// true</span></a></code></pre></div>
<p>Because we return <code class="sourceCode scala"><span class="kw">true</span></code> <em>whenever</em> the generator runs out, our Trie â€œcontainsâ€ every prefix of the sequences that have been inserted. This is not what we want. One way to solve this may be to return <code class="sourceCode scala"><span class="kw">true</span></code> only if the last Trie found has no children. Something like this:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb11-1" data-line-number="1">extension Trie {</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">  <span class="kw">private</span> func contains</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">    &lt;G : GeneratorType where G.<span class="fu">Element</span> == Element&gt;</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">    (<span class="kw">var</span> gen: G) -&gt; Bool {</a>
<a class="sourceLine" id="cb11-5" data-line-number="5">      <span class="kw">return</span> gen.<span class="fu">next</span>().<span class="fu">map</span>{self.<span class="fu">children</span>[$<span class="dv">0</span>]?.<span class="fu">contains</span>(gen) ?? <span class="kw">false</span>} ?? children.<span class="fu">isEmpty</span></a>
<a class="sourceLine" id="cb11-6" data-line-number="6">  }</a>
<a class="sourceLine" id="cb11-7" data-line-number="7">}</a></code></pre></div>
<p>But this doesnâ€™t really work either. what if we did <code class="sourceCode scala">jo.<span class="fu">insert</span>([<span class="dv">1</span>, <span class="dv">2</span>])</code>? Now, if we check if the Trie contains <code class="sourceCode scala">[<span class="dv">1</span>, <span class="dv">2</span>]</code>, weâ€™ll get back <code class="sourceCode scala"><span class="kw">false</span></code>.</p>
<p>Itâ€™s time for flags. We need to add an extra variable to our Trie: a Boolean, which describes whether or not that Trie represents the end of a sequence.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb12-1" data-line-number="1">public struct Trie&lt;Element : Hashable&gt; {</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">  <span class="kw">private</span> <span class="kw">var</span> children: [Element:Trie&lt;Element&gt;]</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">  <span class="kw">private</span> <span class="kw">var</span> endHere : Bool</a>
<a class="sourceLine" id="cb12-4" data-line-number="4">}</a></code></pre></div>
<p>Weâ€™ll also need to change our <code class="sourceCode scala">insert</code> and <code class="sourceCode scala">init</code> functions, so that when the generator returns <code class="sourceCode scala">nil</code>, <code class="sourceCode scala">endHere</code> gets initialised to <code class="sourceCode scala"><span class="kw">true</span></code>.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb13-1" data-line-number="1">extension Trie {</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">  <span class="kw">private</span> init&lt;G : GeneratorType where G.<span class="fu">Element</span> == Element&gt;(<span class="kw">var</span> gen: G) {</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">    <span class="kw">if</span> let head = gen.<span class="fu">next</span>() {</a>
<a class="sourceLine" id="cb13-4" data-line-number="4">      (children, endHere) = ([head:<span class="fu">Trie</span>(gen:gen)], <span class="kw">false</span>)</a>
<a class="sourceLine" id="cb13-5" data-line-number="5">    } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb13-6" data-line-number="6">      (children, endHere) = ([:], <span class="kw">true</span>)</a>
<a class="sourceLine" id="cb13-7" data-line-number="7">    }</a>
<a class="sourceLine" id="cb13-8" data-line-number="8">  }</a>
<a class="sourceLine" id="cb13-9" data-line-number="9">}</a>
<a class="sourceLine" id="cb13-10" data-line-number="10"></a>
<a class="sourceLine" id="cb13-11" data-line-number="11">extension Trie {</a>
<a class="sourceLine" id="cb13-12" data-line-number="12">  <span class="kw">private</span> mutating func insert</a>
<a class="sourceLine" id="cb13-13" data-line-number="13">    &lt;G : GeneratorType where G.<span class="fu">Element</span> == Element&gt;</a>
<a class="sourceLine" id="cb13-14" data-line-number="14">    (<span class="kw">var</span> gen: G) {</a>
<a class="sourceLine" id="cb13-15" data-line-number="15">      <span class="kw">if</span> let head = gen.<span class="fu">next</span>() {</a>
<a class="sourceLine" id="cb13-16" data-line-number="16">        children[head]?.<span class="fu">insert</span>(gen) ?? {children[head] = <span class="fu">Trie</span>(gen: gen)}()</a>
<a class="sourceLine" id="cb13-17" data-line-number="17">      } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb13-18" data-line-number="18">        endHere = <span class="kw">true</span></a>
<a class="sourceLine" id="cb13-19" data-line-number="19">      }</a>
<a class="sourceLine" id="cb13-20" data-line-number="20">  }</a>
<a class="sourceLine" id="cb13-21" data-line-number="21">}</a></code></pre></div>
<p>And the contains function now returns <code class="sourceCode scala">endHere</code>, instead of true:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb14-1" data-line-number="1">public extension Trie {</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">  <span class="kw">private</span> func contains</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">    &lt;G : GeneratorType where G.<span class="fu">Element</span> == Element&gt;</a>
<a class="sourceLine" id="cb14-4" data-line-number="4">    (<span class="kw">var</span> gen: G) -&gt; Bool {</a>
<a class="sourceLine" id="cb14-5" data-line-number="5">      <span class="kw">return</span> gen.<span class="fu">next</span>().<span class="fu">map</span>{self.<span class="fu">children</span>[$<span class="dv">0</span>]?.<span class="fu">contains</span>(gen) ?? <span class="kw">false</span>} ?? endHere</a>
<a class="sourceLine" id="cb14-6" data-line-number="6">  }</a>
<a class="sourceLine" id="cb14-7" data-line-number="7">}</a></code></pre></div>
<p>While weâ€™re improving the <code class="sourceCode scala">contains</code> function, we could use <code class="sourceCode scala">guard</code> to make it much more readable:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb15-1" data-line-number="1">public extension Trie {</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">  <span class="kw">private</span> func contains&lt;</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">    G : GeneratorType where G.<span class="fu">Element</span> == Element</a>
<a class="sourceLine" id="cb15-4" data-line-number="4">    &gt;(<span class="kw">var</span> gen: G) -&gt; Bool {</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">      guard let head = gen.<span class="fu">next</span>() <span class="kw">else</span> { <span class="kw">return</span> endHere }</a>
<a class="sourceLine" id="cb15-6" data-line-number="6">      <span class="kw">return</span> children[head]?.<span class="fu">contains</span>(gen) ?? <span class="kw">false</span></a>
<a class="sourceLine" id="cb15-7" data-line-number="7">  }</a>
<a class="sourceLine" id="cb15-8" data-line-number="8">}</a></code></pre></div>
<p><a href="https://twitter.com/chriseidhof/status/629215881843884032">Chris Eidhof gave me this idea.</a> (Apparently thereâ€™s a Trie implementation in <a href="http://www.objc.io/books/fpinswift/">Functional Programming in Swift</a>, his book. Iâ€™ve not read it, but itâ€™s on my list. If <a href="http://www.objc.io/books/advanced-swift/">Advanced Swift</a>is anything to go by, it should be fantastic.)</p>
<p>The objective of this Trie is to replicate all of the Set methods: Union, Intersect, etc. Most of those are manageable to build from just <code class="sourceCode scala">insert</code>, <code class="sourceCode scala">init</code>, and <code class="sourceCode scala">contains</code>, but thereâ€™s one other function that comes in handy: <code class="sourceCode scala">remove</code>.</p>
<p>Remove is deceptively difficult. You could just walk to the end of your given sequence to remove, and switch <code class="sourceCode scala">endHere</code> from <code class="sourceCode scala"><span class="kw">true</span></code> to <code class="sourceCode scala"><span class="kw">false</span></code>, but thatâ€™s kind of cheating. I mean, youâ€™ll be storing the same amount of information that way after a removal. No, what you need is something that deletes branches of a tree that arenâ€™t being used any more.</p>
<p>Again, this is a little complicated. You canâ€™t just find the head of the sequence you want to remove, and then delete all children: you may be deleting other entries along with that. You <em>also</em> canâ€™t just delete when a given Trie only contains one child: that child may branch off subsequently, or it may contain prefixes for the sequence you want to remove.</p>
<p>Crucially, all of the information telling you whether or not you can delete a given entry in a given Trie will come from the <em>children</em> of that Trie. What I decided to go with was this: Iâ€™ll have some mutating method that does the work recursively. However, this method also <em>returns</em> a value, representing some important information for whatever called it. In this case, the <code class="sourceCode scala">remove</code> method would remove, as youâ€™d imagine, but it will also return a Boolean, signifying whether the Trie it was called on can be removed. Since I used the normal structure of having a private method take a generator, and then a public wrapper method take a sequence, I could have the public method just discard the Boolean.</p>
<p>Letâ€™s go through it. Hereâ€™s the signature:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="kw">private</span> mutating func remove&lt;</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">  G : GeneratorType where G.<span class="fu">Element</span> == Element</a>
<a class="sourceLine" id="cb16-3" data-line-number="3">  &gt;(<span class="kw">var</span> g: G) -&gt; Bool {</a></code></pre></div>
<p>No surprises there. Similar to the other methods. Then, get the head from the generator:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw">if</span> let head = g.<span class="fu">next</span>() {</a></code></pre></div>
<p>Within that if block is the meat of the logic, so I might skip to what happens if <code class="sourceCode scala">g.<span class="fu">next</span>()</code> returns <code class="sourceCode scala">nil</code> for the start:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="kw">private</span> mutating func remove&lt;</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">  G : GeneratorType where G.<span class="fu">Element</span> == Element</a>
<a class="sourceLine" id="cb18-3" data-line-number="3">  &gt;(<span class="kw">var</span> g: G) -&gt; Bool {</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">    <span class="kw">if</span> let head = g.<span class="fu">next</span>() {...}</a>
<a class="sourceLine" id="cb18-5" data-line-number="5">    endHere = <span class="kw">false</span></a>
<a class="sourceLine" id="cb18-6" data-line-number="6">    <span class="kw">return</span> children.<span class="fu">isEmpty</span></a>
<a class="sourceLine" id="cb18-7" data-line-number="7">}</a></code></pre></div>
<p>So the sequence being removed has ended. That means that whatever Trie youâ€™re on should have its <code class="sourceCode scala">endHere</code> set to <code class="sourceCode scala"><span class="kw">false</span></code>. To the user of the Trie, thatâ€™s all that matters: from now on, if the contains method on that Trie is used with that sequence, it will return false.</p>
<p>However, to find out if you can delete the data itself, it returns <code class="sourceCode scala">children.<span class="fu">isEmpty</span></code>. If it has no children, it does not hold any other sequences or information, so it can be deleted.</p>
<p>Now for inside the if block:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb19-1" data-line-number="1">guard children[head]?.<span class="fu">remove</span>(g) == <span class="kw">true</span> <span class="kw">else</span> { <span class="kw">return</span> <span class="kw">false</span> }</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">children.<span class="fu">removeValueForKey</span>(head)</a>
<a class="sourceLine" id="cb19-3" data-line-number="3"><span class="kw">return</span> !endHere &amp;&amp; children.<span class="fu">isEmpty</span></a></code></pre></div>
<p>So it calls <code class="sourceCode scala">remove</code> on the child Trie corresponding to <code class="sourceCode scala">head</code>. That guard statement will fail for two distinct reasons: if <code class="sourceCode scala">children</code> doesnâ€™t contain <code class="sourceCode scala">head</code>, then the sequence being removed wasnâ€™t in the Trie in the first place. The method will then return false, so that no removal or mutation is done.</p>
<p>If it <em>does</em> contain <code class="sourceCode scala">head</code>, but the Bool returned from the remove method is <code class="sourceCode scala"><span class="kw">false</span></code>, that means that its <em>child</em> is not removable, so it is also not removable, so it should return <code class="sourceCode scala"><span class="kw">false</span></code>.</p>
<p>Otherwise, it will remove that member (<code class="sourceCode scala">children.<span class="fu">removeValueForKey</span>(head)</code>). Then, the Trie can decide whether or not it itself is removable: <code class="sourceCode scala"><span class="kw">return</span> !endHere &amp;amp;&amp;amp; children.<span class="fu">isEmpty</span></code>. If the <code class="sourceCode scala">endHere</code> is set to true, then it is the end of some sequence: it is not removable. Otherwise, itâ€™s removable if it has no children. Hereâ€™s the whole thing, with its public version:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb20-1" data-line-number="1">extension Trie {</a>
<a class="sourceLine" id="cb20-2" data-line-number="2">  <span class="kw">private</span> mutating func remove&lt;</a>
<a class="sourceLine" id="cb20-3" data-line-number="3">    G : GeneratorType where G.<span class="fu">Element</span> == Element</a>
<a class="sourceLine" id="cb20-4" data-line-number="4">    &gt;(<span class="kw">var</span> g: G) -&gt; Bool { <span class="co">// Return value signifies whether or not it can be removed</span></a>
<a class="sourceLine" id="cb20-5" data-line-number="5">      <span class="kw">if</span> let head = g.<span class="fu">next</span>() {</a>
<a class="sourceLine" id="cb20-6" data-line-number="6">        guard children[head]?.<span class="fu">remove</span>(g) == <span class="kw">true</span> <span class="kw">else</span> { <span class="kw">return</span> <span class="kw">false</span> }</a>
<a class="sourceLine" id="cb20-7" data-line-number="7">        children.<span class="fu">removeValueForKey</span>(head)</a>
<a class="sourceLine" id="cb20-8" data-line-number="8">        <span class="kw">return</span> !endHere &amp;&amp; children.<span class="fu">isEmpty</span></a>
<a class="sourceLine" id="cb20-9" data-line-number="9">      }</a>
<a class="sourceLine" id="cb20-10" data-line-number="10">      endHere = <span class="kw">false</span></a>
<a class="sourceLine" id="cb20-11" data-line-number="11">      <span class="kw">return</span> children.<span class="fu">isEmpty</span></a>
<a class="sourceLine" id="cb20-12" data-line-number="12">  }</a>
<a class="sourceLine" id="cb20-13" data-line-number="13">  public mutating func remove&lt;</a>
<a class="sourceLine" id="cb20-14" data-line-number="14">    S : SequenceType where S.<span class="fu">Generator</span>.<span class="fu">Element</span> == Element</a>
<a class="sourceLine" id="cb20-15" data-line-number="15">    &gt;(seq: S) {</a>
<a class="sourceLine" id="cb20-16" data-line-number="16">      <span class="fu">remove</span>(seq.<span class="fu">generate</span>())</a>
<a class="sourceLine" id="cb20-17" data-line-number="17">  }</a>
<a class="sourceLine" id="cb20-18" data-line-number="18">}</a></code></pre></div>
<p>That was a little heavy. And kind of ugly. Letâ€™s lighten things up for a second, with one of the loveliest <code class="sourceCode scala">count</code> properties Iâ€™ve seen:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb21-1" data-line-number="1">extension Trie {</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">  public <span class="kw">var</span> count: Int {</a>
<a class="sourceLine" id="cb21-3" data-line-number="3">    <span class="kw">return</span> children.<span class="fu">values</span>.<span class="fu">reduce</span>(endHere ? <span class="dv">1</span> : <span class="dv">0</span>) { $<span class="dv">0</span> + $<span class="fl">1.</span>count }</a>
<a class="sourceLine" id="cb21-4" data-line-number="4">  }</a>
<a class="sourceLine" id="cb21-5" data-line-number="5">}</a></code></pre></div>
<p>All itâ€™s really doing is counting the instances of a <code class="sourceCode scala"><span class="kw">true</span></code> <code class="sourceCode scala">endHere</code>. If the current Trie is an end, then it knows that it adds one to the count (<code class="sourceCode scala">endHere ? <span class="dv">1</span> : <span class="dv">0</span></code>), and it adds that to the sum of the counts of its children.</p>
<p>Now then. <code class="sourceCode scala">SequenceType</code>. <a href="http://airspeedvelocity.net/2015/07/22/a-persistent-tree-using-indirect-enums-in-swift/">Getting tree-like structures to conform to <code class="sourceCode scala">SequenceType</code> is a bit of a pain</a>, mainly because of their recursiveness. Getting a linear representation is easy enough:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb22-1" data-line-number="1">extension Trie {</a>
<a class="sourceLine" id="cb22-2" data-line-number="2">  public <span class="kw">var</span> contents: [[Element]] {</a>
<a class="sourceLine" id="cb22-3" data-line-number="3">    <span class="kw">return</span> children.<span class="fu">flatMap</span> {</a>
<a class="sourceLine" id="cb22-4" data-line-number="4">      (head: Element, child: Trie&lt;Element&gt;) -&gt; [[Element]] in</a>
<a class="sourceLine" id="cb22-5" data-line-number="5">      child.<span class="fu">contents</span>.<span class="fu">map</span> { [head] + $<span class="dv">0</span> } + (child.<span class="fu">endHere</span> ? [[head]] : [])</a>
<a class="sourceLine" id="cb22-6" data-line-number="6">    }</a>
<a class="sourceLine" id="cb22-7" data-line-number="7">  }</a>
<a class="sourceLine" id="cb22-8" data-line-number="8">}</a></code></pre></div>
<p>And then you could just return the generate method from that for your Trieâ€™s generate method.</p>
<p>The problem is that itâ€™s not very proper: youâ€™re translating your data structure into another data structure just to iterate through it. What you really want is something that generates each element on demand.</p>
<p>But it gets ugly quick. Youâ€™ve got to do a lot of stuff by hand which it isnâ€™t nice to do by hand, and youâ€™ve got to employ some dirty tricks (like using closures as a kind of homemade <code class="sourceCode scala">indirect</code>). At any rate, here it is:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb23-1" data-line-number="1">public struct TrieGenerator&lt;Element : Hashable&gt; : GeneratorType {</a>
<a class="sourceLine" id="cb23-2" data-line-number="2">  <span class="kw">private</span> <span class="kw">var</span> children: DictionaryGenerator&lt;Element, Trie&lt;Element&gt;&gt;</a>
<a class="sourceLine" id="cb23-3" data-line-number="3">  <span class="kw">private</span> <span class="kw">var</span> curHead : Element?</a>
<a class="sourceLine" id="cb23-4" data-line-number="4">  <span class="kw">private</span> <span class="kw">var</span> curEnd  : Bool = <span class="kw">false</span></a>
<a class="sourceLine" id="cb23-5" data-line-number="5">  <span class="kw">private</span> <span class="kw">var</span> innerGen: (() -&gt; [Element]?)?</a>
<a class="sourceLine" id="cb23-6" data-line-number="6">  <span class="kw">private</span> mutating func <span class="fu">update</span>() {</a>
<a class="sourceLine" id="cb23-7" data-line-number="7">    guard <span class="fu">let</span> (head, child) = children.<span class="fu">next</span>() <span class="kw">else</span> { innerGen = nil; <span class="kw">return</span> }</a>
<a class="sourceLine" id="cb23-8" data-line-number="8">    curHead = head</a>
<a class="sourceLine" id="cb23-9" data-line-number="9">    <span class="kw">var</span> g = child.<span class="fu">generate</span>()</a>
<a class="sourceLine" id="cb23-10" data-line-number="10">    innerGen = {g.<span class="fu">next</span>()}</a>
<a class="sourceLine" id="cb23-11" data-line-number="11">    curEnd = child.<span class="fu">endHere</span></a>
<a class="sourceLine" id="cb23-12" data-line-number="12">  }</a>
<a class="sourceLine" id="cb23-13" data-line-number="13">  public mutating func <span class="fu">next</span>() -&gt; [Element]? {</a>
<a class="sourceLine" id="cb23-14" data-line-number="14">    <span class="kw">for</span> ; innerGen != nil; <span class="fu">update</span>() {</a>
<a class="sourceLine" id="cb23-15" data-line-number="15">      <span class="kw">if</span> let next = innerGen!() {</a>
<a class="sourceLine" id="cb23-16" data-line-number="16">        <span class="kw">return</span> [curHead!] + next</a>
<a class="sourceLine" id="cb23-17" data-line-number="17">      } <span class="kw">else</span> <span class="kw">if</span> curEnd {</a>
<a class="sourceLine" id="cb23-18" data-line-number="18">        curEnd = <span class="kw">false</span></a>
<a class="sourceLine" id="cb23-19" data-line-number="19">        <span class="kw">return</span> [curHead!]</a>
<a class="sourceLine" id="cb23-20" data-line-number="20">      }</a>
<a class="sourceLine" id="cb23-21" data-line-number="21">    }</a>
<a class="sourceLine" id="cb23-22" data-line-number="22">    <span class="kw">return</span> nil</a>
<a class="sourceLine" id="cb23-23" data-line-number="23">  }</a>
<a class="sourceLine" id="cb23-24" data-line-number="24">  <span class="kw">private</span> <span class="fu">init</span>(_ from: Trie&lt;Element&gt;) {</a>
<a class="sourceLine" id="cb23-25" data-line-number="25">    children = from.<span class="fu">children</span>.<span class="fu">generate</span>()</a>
<a class="sourceLine" id="cb23-26" data-line-number="26">    <span class="fu">update</span>()</a>
<a class="sourceLine" id="cb23-27" data-line-number="27">  }</a>
<a class="sourceLine" id="cb23-28" data-line-number="28">}</a></code></pre></div>
<p>Itâ€™s got a similar logic to the lazy flatMap I did from a while ago.</p>
<p>The code is all available <a href="https://github.com/oisdk/SwiftTrie">here</a>,Â as a playground, or <a href="https://github.com/oisdk/SwiftSequence">here</a>,Â in SwiftSequence, where itâ€™s accompanied by some tests.</p>
]]></description>
    <pubDate>Tue, 11 Aug 2015 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2015-08-11-swift-trie.html</guid>
    <dc:creator>Donnacha OisÃ­n Kidney</dc:creator>
</item>
<item>
    <title>Monty Hall</title>
    <link>https://doisinkidney.com/posts/2015-08-03-monty-hall.html</link>
    <description><![CDATA[<div class="info">
    Posted on August  3, 2015
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Swift.html">Swift</a>, <a href="/tags/Probability.html">Probability</a>
    
</div>

<p>The Monty Hall problem is a great example of how counter-intuitive probability can sometimes be. It goes something like this: say youâ€™re on a gameshow, with the chance to win a car. Youâ€™re shown three doors, and the car is behind one, goats behind the other two. You pick a door, say the leftmost, but then the host of the gameshow stops you before itâ€™s opened. He opens one of the two doors you didnâ€™t pick, revealing a goat. He then asks you if youâ€™d like to change your decision. So? Do you?</p>
<p>Perhaps surprisingly, you <em>should</em> change your decision. Your chances of winning a car go from 1/3 to 2/3.</p>
<p>If youâ€™ve not thought for a while about the problem, the answer above might sound instinctively wrong. A few <a href="http://www.thomashanning.com/swift-playground-the-monty-hall-problem/">blog posts</a> over the past few weeks have made an effort to put some concrete numbers to the statistics, running simulations of each possibility, and counting up the amount of wins and losses.</p>
<p>I was still a little unsatisfied, though. I mean, showing me the actual numbers is fine, but Iâ€™d like something a little more <em>proof</em>-y. You can get close with a diagram:</p>
<p><img src="/images/monty-hall-tree.png" /></p>
<p>Which makes it pretty clear whatâ€™s going on: since the host <em>has</em> to show a goat when he opens a door, if youâ€™ve picked a goat, then the only door left after the host opens one is the car. That means that if you switch and pick a goat, you <em>have</em> to win. So if you decide to switch, then what you want to do is pick a <em>goat</em> first, and the chances of that are 2/3.</p>
<p>It would be far cooler if you could get some representation of that diagram in code, though.</p>
<p>Turns out we can! In Swift and Haskell (Iâ€™m branching out) you can represent probability in a list-like structure, with each element of the list being a tuple of some value and that valueâ€™s probability. All the probabilities in the list itself should add up to one. Hereâ€™s what it looks like in Swift:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb1-1" data-line-number="1">struct Prob&lt;Element&gt; {</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  <span class="kw">private</span> let contents: [(Element, Double)]</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">}</a></code></pre></div>
<p>and Haskell:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Prob</span> a <span class="fu">=</span> <span class="dt">Prob</span> {<span class="ot"> getProb ::</span> [(a,<span class="dt">Rational</span>)] } <span class="kw">deriving</span> <span class="dt">Show</span>  </a></code></pre></div>
<p>Being a list kind of thing, ideally youâ€™d want to be able to transform the elements, with a map kind of thing:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb3-1" data-line-number="1">extension Prob {</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  func fmap&lt;T&gt;(f: Element -&gt; T) -&gt; Prob&lt;T&gt; {</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">    <span class="kw">return</span> Prob&lt;T&gt;(contents.<span class="fu">map</span> { (v,p) <span class="fu">in</span> (<span class="fu">f</span>(v), p) })</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">  }</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">}</a></code></pre></div>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Prob</span> <span class="kw">where</span>  </a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  fmap f (<span class="dt">Prob</span> xs) <span class="fu">=</span> <span class="dt">Prob</span> [(f x,p)<span class="fu">|</span>(x,p) <span class="ot">&lt;-</span> xs]</a></code></pre></div>
<p>So far, though, the probability information is kind of superfluous. Thereâ€™s not even a decent way to generate it. How about we get it from a list, where we assume all things in the list have equal chances of happening:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb5-1" data-line-number="1">extension CollectionType where Index.<span class="fu">Distance</span> == Int {</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">  <span class="kw">var</span> equalProbs: Prob&lt;Generator.<span class="fu">Element</span>&gt; {</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">    let p = <span class="fl">1.0</span> / Double(count)</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">    <span class="kw">return</span> Prob&lt;Generator.<span class="fu">Element</span>&gt;(map { v <span class="fu">in</span> (v,p) })</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">  }</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">}</a></code></pre></div>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">equalProbs ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Prob</span> a</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">equalProbs x <span class="fu">=</span> <span class="dt">Prob</span> <span class="fu">$</span> map (flip (,) (<span class="dv">1</span><span class="fu">%</span>n))  x</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  <span class="kw">where</span> n <span class="fu">=</span> fromIntegral (length x)</a></code></pre></div>
<p>Which is <em>fine</em>, I suppose, but still not very interesting. What we want is the idea of â€œbranchingâ€ - like in the diagram. â€œIf event A happens, then event B has X chance of happening, and event C has Y chance of happeningâ€.</p>
<p>The normal rules of probability apply: the <em>overall</em> probability of B happening is equal to the probability of A multiplied by X. You could have several layers of branching from B and C onwards, with this multiplication happening at each stage.</p>
<p>You could represent this in code with a function <code>f</code>, which takes an event (A) and returns a new bunch of probabilities (B and C). Then, to get the overall probability of each, youâ€™d have to <em>flatten</em> it. What you want, then, is a function that travels over a list of events and their probabilities, applying <code>f</code> to each, and flattening the result, by <em>multiplying</em> the probabilities of the inner lists by the probability of the event which generated it.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb7-1" data-line-number="1">extension Prob {</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  func flatMap&lt;T&gt;(f: Element -&gt; Prob&lt;T&gt;) -&gt; Prob&lt;T&gt; {</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">    <span class="kw">return</span> Prob&lt;T&gt;(contents.<span class="fu">flatMap</span> { (v,p) in</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">      <span class="fu">f</span>(v).<span class="fu">contents</span>.<span class="fu">map</span> { (x,ip) <span class="fu">in</span> (x,p*ip) }</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">    })</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">  }</a>
<a class="sourceLine" id="cb7-7" data-line-number="7">}</a></code></pre></div>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Prob</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  return <span class="fu">=</span> pure</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  <span class="dt">Prob</span> xs <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> </a>
<a class="sourceLine" id="cb8-4" data-line-number="4">    <span class="dt">Prob</span> [(y,px<span class="fu">*</span>py)<span class="fu">|</span>(x,px) <span class="ot">&lt;-</span> xs, (y,py) <span class="ot">&lt;-</span> getProb(f x)]</a></code></pre></div>
<p>Hey look! The M-word. Never mind that. Anywayâ€¦</p>
<p>Now we have enough tools to stimulate some basic probabilities. Letâ€™s say youâ€™re playing a game, which begins with a coin flip. If you get heads on the coin flip, it confers some advantage, and you have a 70% chance of winning. Otherwise, youâ€™ve a 50% chance.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb9-1" data-line-number="1">enum Coin: String   { <span class="kw">case</span> H, T }</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">enum Result: String { <span class="kw">case</span> Win, Lose }</a>
<a class="sourceLine" id="cb9-3" data-line-number="3"></a>
<a class="sourceLine" id="cb9-4" data-line-number="4">func <span class="fu">play</span>(c: Coin) -&gt; Prob&lt;Result&gt; {</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  switch c {</a>
<a class="sourceLine" id="cb9-6" data-line-number="6">  <span class="kw">case</span> .<span class="fu">H</span>: <span class="kw">return</span> <span class="fu">Prob</span>([(.<span class="fu">Win</span>,<span class="fl">0.7</span>),(.<span class="fu">Lose</span>,<span class="fl">0.3</span>)])</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">  <span class="kw">case</span> .<span class="fu">T</span>: <span class="kw">return</span> [.<span class="fu">Win</span>,.<span class="fu">Lose</span>].<span class="fu">equalProbs</span></a>
<a class="sourceLine" id="cb9-8" data-line-number="8">  }</a>
<a class="sourceLine" id="cb9-9" data-line-number="9">}</a>
<a class="sourceLine" id="cb9-10" data-line-number="10"></a>
<a class="sourceLine" id="cb9-11" data-line-number="11">[Coin.<span class="fu">H</span>,.<span class="fu">T</span>]</a>
<a class="sourceLine" id="cb9-12" data-line-number="12">  .<span class="fu">equalProbs</span></a>
<a class="sourceLine" id="cb9-13" data-line-number="13">  .<span class="fu">flatMap</span>(play)</a>
<a class="sourceLine" id="cb9-14" data-line-number="14"></a>
<a class="sourceLine" id="cb9-15" data-line-number="15"><span class="co">// 0.35: Result.Win</span></a>
<a class="sourceLine" id="cb9-16" data-line-number="16"><span class="co">// 0.15: Result.Lose</span></a>
<a class="sourceLine" id="cb9-17" data-line-number="17"><span class="co">// 0.25: Result.Win</span></a>
<a class="sourceLine" id="cb9-18" data-line-number="18"><span class="co">// 0.25: Result.Lose</span></a></code></pre></div>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Coin</span>   <span class="fu">=</span> <span class="dt">H</span> <span class="fu">|</span> <span class="dt">T</span> <span class="kw">deriving</span> <span class="dt">Show</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Result</span> <span class="fu">=</span> <span class="dt">Win</span> <span class="fu">|</span> <span class="dt">Lose</span> <span class="kw">deriving</span> <span class="dt">Show</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3"></a>
<a class="sourceLine" id="cb10-4" data-line-number="4"><span class="kw">let</span> play <span class="dt">H</span> <span class="fu">=</span> <span class="dt">Prob</span> [(<span class="dt">Win</span>,<span class="dv">7</span><span class="fu">%</span><span class="dv">10</span>),(<span class="dt">Lose</span>,<span class="dv">3</span><span class="fu">%</span><span class="dv">10</span>)]</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">    play <span class="dt">T</span> <span class="fu">=</span> equalProbs [<span class="dt">Win</span>,<span class="dt">Lose</span>]</a>
<a class="sourceLine" id="cb10-6" data-line-number="6"></a>
<a class="sourceLine" id="cb10-7" data-line-number="7">equalProbs [<span class="dt">H</span>,<span class="dt">T</span>] <span class="fu">&gt;&gt;=</span> play</a></code></pre></div>
<p>Thereâ€™s an obvious problem: duplicates. We need some way to <em>combine</em> the results by adding their probabilities together. To be honest, this was the least interesting part, so Iâ€™ll just dump the code here:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb11-1" data-line-number="1">public enum Ordering { <span class="kw">case</span> LT, EQ, GT }</a>
<a class="sourceLine" id="cb11-2" data-line-number="2"></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">extension SequenceType {</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">  <span class="kw">private</span> typealias A = Generator.<span class="fu">Element</span></a>
<a class="sourceLine" id="cb11-5" data-line-number="5">  public func <span class="fu">mergeBy</span>( comp: (A, A) -&gt; Ordering</a>
<a class="sourceLine" id="cb11-6" data-line-number="6">                     , _ merge: (A, A) -&gt; A) -&gt; [A] {</a>
<a class="sourceLine" id="cb11-7" data-line-number="7">    <span class="kw">var</span> result: [A] = []</a>
<a class="sourceLine" id="cb11-8" data-line-number="8">    <span class="kw">for</span> h in <span class="fu">sort</span>({ e in <span class="fu">comp</span>(e) == .<span class="fu">LT</span> }) {</a>
<a class="sourceLine" id="cb11-9" data-line-number="9">      <span class="kw">if</span> <span class="kw">case</span> .<span class="fu">EQ</span>? = result.<span class="fu">last</span>.<span class="fu">map</span>({e in <span class="fu">comp</span>(h,e)}) {</a>
<a class="sourceLine" id="cb11-10" data-line-number="10">        result.<span class="fu">append</span>(<span class="fu">merge</span>(result.<span class="fu">removeLast</span>(),h))</a>
<a class="sourceLine" id="cb11-11" data-line-number="11">      } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb11-12" data-line-number="12">        result.<span class="fu">append</span>(h)</a>
<a class="sourceLine" id="cb11-13" data-line-number="13">      }</a>
<a class="sourceLine" id="cb11-14" data-line-number="14">    }</a>
<a class="sourceLine" id="cb11-15" data-line-number="15">    <span class="kw">return</span> result</a>
<a class="sourceLine" id="cb11-16" data-line-number="16">  }</a>
<a class="sourceLine" id="cb11-17" data-line-number="17">}</a>
<a class="sourceLine" id="cb11-18" data-line-number="18"></a>
<a class="sourceLine" id="cb11-19" data-line-number="19">extension Prob {</a>
<a class="sourceLine" id="cb11-20" data-line-number="20">  public func mergeProbs</a>
<a class="sourceLine" id="cb11-21" data-line-number="21">    (comp: (Element,Element) -&gt; Ordering) -&gt; Prob {</a>
<a class="sourceLine" id="cb11-22" data-line-number="22">      <span class="kw">return</span> <span class="fu">Prob</span>(contents:</a>
<a class="sourceLine" id="cb11-23" data-line-number="23">        contents.<span class="fu">mergeBy</span>( {(a,b) in <span class="fu">comp</span>(a<span class="fl">.0</span>,b<span class="fl">.0</span>)}</a>
<a class="sourceLine" id="cb11-24" data-line-number="24">                        , {(a,b) <span class="fu">in</span> (a<span class="fl">.0</span>,a<span class="fl">.1</span>+b<span class="fl">.1</span>)})</a>
<a class="sourceLine" id="cb11-25" data-line-number="25">    )</a>
<a class="sourceLine" id="cb11-26" data-line-number="26">  }</a>
<a class="sourceLine" id="cb11-27" data-line-number="27">}</a></code></pre></div>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="ot">eqing ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Ordering</span>) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">eqing c <span class="fu">=</span> (\a b <span class="ot">-&gt;</span> <span class="kw">case</span> c a b <span class="kw">of</span> <span class="dt">EQ</span> <span class="ot">-&gt;</span> <span class="dt">True</span> </a>
<a class="sourceLine" id="cb12-3" data-line-number="3">                                 _  <span class="ot">-&gt;</span> <span class="dt">False</span>)</a>
<a class="sourceLine" id="cb12-4" data-line-number="4"></a>
<a class="sourceLine" id="cb12-5" data-line-number="5"><span class="ot">mergeBy ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Ordering</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb12-6" data-line-number="6">mergeBy m c <span class="fu">=</span> (foldl1&#39; m <span class="fu">&lt;$&gt;</span>) <span class="fu">.</span> groupBy (eqing c) <span class="fu">.</span> sortBy c</a>
<a class="sourceLine" id="cb12-7" data-line-number="7"></a>
<a class="sourceLine" id="cb12-8" data-line-number="8"><span class="ot">mergeProbs ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Prob</span> a <span class="ot">-&gt;</span> <span class="dt">Prob</span> a</a>
<a class="sourceLine" id="cb12-9" data-line-number="9">mergeProbs <span class="fu">=</span></a>
<a class="sourceLine" id="cb12-10" data-line-number="10">  <span class="dt">Prob</span> <span class="fu">.</span> mergeBy (fmap <span class="fu">.</span> (<span class="fu">+</span>) <span class="fu">.</span> snd) (comparing fst) <span class="fu">.</span> getProb</a></code></pre></div>
<p>Now we get some nicer probabilities, though:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb13-1" data-line-number="1">func <span class="fu">comp</span>(a: Result, b:Result) -&gt; Ordering {</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">  <span class="fu">switch</span> (a,b) {</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">  <span class="kw">case</span> (.<span class="fu">Win</span>,.<span class="fu">Win</span>),(.<span class="fu">Lose</span>,.<span class="fu">Lose</span>): <span class="kw">return</span> .<span class="fu">EQ</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4">  <span class="kw">case</span> (.<span class="fu">Lose</span>,.<span class="fu">Win</span>): <span class="kw">return</span> .<span class="fu">LT</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5">  <span class="kw">case</span> (.<span class="fu">Win</span>,.<span class="fu">Lose</span>): <span class="kw">return</span> .<span class="fu">GT</span></a>
<a class="sourceLine" id="cb13-6" data-line-number="6">  }</a>
<a class="sourceLine" id="cb13-7" data-line-number="7">}</a>
<a class="sourceLine" id="cb13-8" data-line-number="8"></a>
<a class="sourceLine" id="cb13-9" data-line-number="9">[Coin.<span class="fu">H</span>,.<span class="fu">T</span>]</a>
<a class="sourceLine" id="cb13-10" data-line-number="10">  .<span class="fu">equalProbs</span></a>
<a class="sourceLine" id="cb13-11" data-line-number="11">  .<span class="fu">flatMap</span>(play)</a>
<a class="sourceLine" id="cb13-12" data-line-number="12">  .<span class="fu">mergeProbs</span>(comp)</a>
<a class="sourceLine" id="cb13-13" data-line-number="13"></a>
<a class="sourceLine" id="cb13-14" data-line-number="14"><span class="co">// 0.4: Result.Lose</span></a>
<a class="sourceLine" id="cb13-15" data-line-number="15"><span class="co">// 0.6: Result.Win</span></a></code></pre></div>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Ord</span> <span class="dt">Result</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2">  compare <span class="dt">Win</span> <span class="dt">Lose</span> <span class="fu">=</span> <span class="dt">GT</span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3">  compare <span class="dt">Lose</span> <span class="dt">Win</span> <span class="fu">=</span> <span class="dt">LT</span></a>
<a class="sourceLine" id="cb14-4" data-line-number="4">  compare _    _   <span class="fu">=</span> <span class="dt">EQ</span></a>
<a class="sourceLine" id="cb14-5" data-line-number="5">  </a>
<a class="sourceLine" id="cb14-6" data-line-number="6">mergeProbs ( equalProbs [<span class="dt">H</span>,<span class="dt">T</span>] <span class="fu">&gt;&gt;=</span> play )</a></code></pre></div>
<p>And you can see what effect a loaded coin would have on your chances:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="fu">Prob</span>([(Coin.<span class="fu">H</span>,<span class="fl">0.7</span>),(.<span class="fu">T</span>,<span class="fl">0.3</span>)])</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">  .<span class="fu">flatMap</span>(play)</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">  .<span class="fu">mergeProbs</span>(comp)</a>
<a class="sourceLine" id="cb15-4" data-line-number="4"></a>
<a class="sourceLine" id="cb15-5" data-line-number="5"><span class="co">// 0.36: Result.Lose</span></a>
<a class="sourceLine" id="cb15-6" data-line-number="6"><span class="co">// 0.64: Result.Win</span></a></code></pre></div>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1">mergeProbs ( <span class="dt">Prob</span> [(<span class="dt">H</span>,<span class="dv">7</span><span class="fu">%</span><span class="dv">10</span>),(<span class="dt">T</span>,<span class="dv">3</span><span class="fu">%</span><span class="dv">10</span>)] <span class="fu">&gt;&gt;=</span> play )</a></code></pre></div>
<p>So how does this apply to Monty Hall? Well, weâ€™ve actually done most of the work already. Weâ€™ll represent the doors as an Int, and the choice by an enum.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb17-1" data-line-number="1">public enum Choice { <span class="kw">case</span> Switch, Stick }</a></code></pre></div>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Choice</span> <span class="fu">=</span> <span class="dt">Switch</span> <span class="fu">|</span> <span class="dt">Stick</span></a></code></pre></div>
<p>Then, a <code class="sourceCode scala">chances</code> function. The logic here is a bit dense. First of all, if youâ€™re going to stick, it doesnâ€™t matter how many doors the host opens: your chance of getting a car is <code>1/n</code>, where <code>n</code> is the number of doors. However, if youâ€™re going to switch, two things need to happen: you need to <em>not</em> pick the car on your first choice, <em>and</em> you need to pick the car on your second choice. The chance of picking the car on your second choice (if the one you picked on your first choice <em>wasnâ€™t</em> the car) is the one over the number of doors, minus the number of doors the host opens, minus one.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb19-1" data-line-number="1">public func <span class="fu">chances</span>(n: Int, _ p: Int, _ c: Choice)(_ d: Int)</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">  -&gt; Prob&lt;Bool&gt; {</a>
<a class="sourceLine" id="cb19-3" data-line-number="3">    switch c {</a>
<a class="sourceLine" id="cb19-4" data-line-number="4">    <span class="kw">case</span> .<span class="fu">Stick</span> : <span class="kw">return</span> (<span class="dv">1</span>...<span class="fu">n</span>).<span class="fu">equalProbs</span>.<span class="fu">fmap</span>(==d)</a>
<a class="sourceLine" id="cb19-5" data-line-number="5">    <span class="kw">case</span> .<span class="fu">Switch</span>:</a>
<a class="sourceLine" id="cb19-6" data-line-number="6">      let notFirst = <span class="fu">chances</span>(n,p,.<span class="fu">Stick</span>)(d).<span class="fu">fmap</span>(!)</a>
<a class="sourceLine" id="cb19-7" data-line-number="7">      let second =</a>
<a class="sourceLine" id="cb19-8" data-line-number="8">        <span class="fu">Repeat</span>(count: (n-p)-<span class="dv">2</span>, repeatedValue: <span class="kw">false</span>) + [<span class="kw">true</span>]</a>
<a class="sourceLine" id="cb19-9" data-line-number="9">      <span class="kw">return</span> notFirst.<span class="fu">flatMap</span> { f in </a>
<a class="sourceLine" id="cb19-10" data-line-number="10">        second.<span class="fu">equalProbs</span>.<span class="fu">fmap</span> { s in f &amp;&amp; s } </a>
<a class="sourceLine" id="cb19-11" data-line-number="11">      }</a>
<a class="sourceLine" id="cb19-12" data-line-number="12">  }</a>
<a class="sourceLine" id="cb19-13" data-line-number="13">}</a></code></pre></div>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="ot">chances ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Choice</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Prob</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2">chances n _ <span class="dt">Stick</span>  d <span class="fu">=</span> fmap (<span class="fu">==</span>d) (equalProbs [<span class="dv">1</span><span class="fu">..</span>n])</a>
<a class="sourceLine" id="cb20-3" data-line-number="3">chances n p <span class="dt">Switch</span> d <span class="fu">=</span> </a>
<a class="sourceLine" id="cb20-4" data-line-number="4">  (<span class="fu">&amp;&amp;</span>) <span class="fu">.</span> not          <span class="fu">&lt;$&gt;</span></a>
<a class="sourceLine" id="cb20-5" data-line-number="5">  chances n p <span class="dt">Stick</span> d <span class="fu">&lt;*&gt;</span></a>
<a class="sourceLine" id="cb20-6" data-line-number="6">  (equalProbs <span class="fu">$</span> <span class="dt">True</span> <span class="fu">:</span> replicate (n<span class="fu">-</span>p<span class="fu">-</span><span class="dv">2</span>) <span class="dt">False</span>)</a></code></pre></div>
<p>Finally, the <code>chanceOfCar</code> function:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb21-1" data-line-number="1">public func chanceOfCar</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">  (n: Int, _ p: Int, _ s: Choice)</a>
<a class="sourceLine" id="cb21-3" data-line-number="3">  -&gt; Prob&lt;Bool&gt; {</a>
<a class="sourceLine" id="cb21-4" data-line-number="4">    <span class="kw">return</span> (<span class="dv">1</span>...<span class="fu">n</span>)</a>
<a class="sourceLine" id="cb21-5" data-line-number="5">      .<span class="fu">equalProbs</span></a>
<a class="sourceLine" id="cb21-6" data-line-number="6">      .<span class="fu">flatMap</span>(<span class="fu">chances</span>(n,p,s))</a>
<a class="sourceLine" id="cb21-7" data-line-number="7">      .<span class="fu">mergeProbs</span>(comp)</a>
<a class="sourceLine" id="cb21-8" data-line-number="8">}</a></code></pre></div>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="ot">chanceOfCar ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Choice</span> <span class="ot">-&gt;</span> <span class="dt">Prob</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb22-2" data-line-number="2">chanceOfCar n p s <span class="fu">=</span> mergeProbs <span class="fu">$</span></a>
<a class="sourceLine" id="cb22-3" data-line-number="3">                    equalProbs [<span class="dv">1</span><span class="fu">..</span>n] <span class="fu">&gt;&gt;=</span> </a>
<a class="sourceLine" id="cb22-4" data-line-number="4">                    chances n p s</a></code></pre></div>
<p>Which returns, as youâ€™d expect, 1/3 chance of car if you stick, and 2/3 if you switch.</p>
<p>One of the final cool things you can do with this is change the number of doors, and the number of doors the host opens, and see what happens:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="fu">chanceOfCar</span>(<span class="dv">6</span>, <span class="dv">2</span>, .<span class="fu">Switch</span>) </a>
<a class="sourceLine" id="cb23-2" data-line-number="2"><span class="co">// 0.833333333333334: false, 0.166666666666667: true</span></a></code></pre></div>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1">chanceOfCar <span class="dv">8</span> <span class="dv">3</span> <span class="dt">Switch</span> <span class="fu">//</span> <span class="dv">7</span> <span class="fu">%</span> <span class="dv">32</span></a></code></pre></div>
<p>The advantage gets less and less, but never goes away.</p>
<p>If you check out the <a href="https://en.wikipedia.org/wiki/Monty_Hall_problem#N_doors">Wikipedia</a> entry on the problem, the formula for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>N</mi><annotation encoding="application/x-tex">N</annotation></semantics></math>-doors is given: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mrow><mi>N</mi><mo>âˆ’</mo><mn>1</mn></mrow><mrow><mi>N</mi><mo stretchy="false" form="prefix">(</mo><mi>N</mi><mo>âˆ’</mo><mi>p</mi><mo>âˆ’</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow></mfrac><annotation encoding="application/x-tex">\frac{Nâˆ’1}{N(Nâˆ’pâˆ’1)}</annotation></semantics></math>.</p>
<p>We can plug that straight in to our versions, to see if theyâ€™re correct:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="kw">let</span> sample <span class="fu">=</span> [(n,p)<span class="fu">|</span> n <span class="ot">&lt;-</span> [<span class="dv">3</span><span class="fu">..</span><span class="dv">20</span>], p <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span>(n<span class="fu">-</span><span class="dv">2</span>)]] </a>
<a class="sourceLine" id="cb25-2" data-line-number="2"><span class="kw">let</span> expect <span class="fu">=</span> fmap frmla sample</a>
<a class="sourceLine" id="cb25-3" data-line-number="3">             <span class="kw">where</span><span class="ot"> frmla ::</span> (<span class="dt">Integer</span>,<span class="dt">Integer</span>) <span class="ot">-&gt;</span> <span class="dt">Rational</span></a>
<a class="sourceLine" id="cb25-4" data-line-number="4">                   frmla (n,p) <span class="fu">=</span> (n <span class="fu">-</span> <span class="dv">1</span>)<span class="fu">%</span>(n<span class="fu">*</span>(n<span class="fu">-</span>p<span class="fu">-</span><span class="dv">1</span>))</a>
<a class="sourceLine" id="cb25-5" data-line-number="5"></a>
<a class="sourceLine" id="cb25-6" data-line-number="6"><span class="kw">let</span> actual <span class="fu">=</span> fmap t sample <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-7" data-line-number="7">  t (n,p) <span class="fu">=</span> truePrb <span class="fu">$</span> getProb <span class="fu">$</span> chanceOfCar n p <span class="dt">Switch</span></a>
<a class="sourceLine" id="cb25-8" data-line-number="8">  truePrb <span class="fu">=</span> fromJust <span class="fu">.</span> (fmap snd) <span class="fu">.</span> (find fst)</a>
<a class="sourceLine" id="cb25-9" data-line-number="9"></a>
<a class="sourceLine" id="cb25-10" data-line-number="10">expect <span class="fu">==</span> actual</a></code></pre></div>
<p>And it works! (I didnâ€™t try the Swift version, because of floating-point inaccuracies)</p>
<p>You can see the code used <a href="https://github.com/oisdk/Monty-Hall">here</a>.</p>
]]></description>
    <pubDate>Mon, 03 Aug 2015 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2015-08-03-monty-hall.html</guid>
    <dc:creator>Donnacha OisÃ­n Kidney</dc:creator>
</item>
<item>
    <title>Deques, Queues, and Lists in Swift with Indirect</title>
    <link>https://doisinkidney.com/posts/2015-07-29-swift-queues.html</link>
    <description><![CDATA[<div class="info">
    Posted on July 29, 2015
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Swift.html">Swift</a>, <a href="/tags/Data%20Structures.html">Data Structures</a>
    
</div>

<p>Recursive enums have finally arrived. Woo! The first thing to do with these is to make a recursive list:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb1-1" data-line-number="1">public enum List&lt;Element&gt; {</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  <span class="kw">case</span> Nil</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  indirect <span class="kw">case</span> <span class="fu">Cons</span>(head: Element, tail: List&lt;Element&gt;)</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">}</a></code></pre></div>
<p>The <code class="sourceCode scala">head</code> stores the element, and <code class="sourceCode scala">tail</code> is a reference to the rest of the list. As you can imagine, getting at the <code class="sourceCode scala">head</code> is pretty easy, while accessing elements further along is more difficult. Thereâ€™s a common pattern for dealing with these recursive structures: if you have a function that performs some transformation on a list, it will take the <code class="sourceCode scala">head</code>, perform that transformation on it, and then call itself recursively on the <code class="sourceCode scala">tail</code>. If itâ€™s given an empty list, it returns an empty list. For instance, hereâ€™s the <code class="sourceCode haskell">map</code> function, defined in Haskell:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1">map _ []     <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">map f (x<span class="fu">:</span>xs) <span class="fu">=</span> f x <span class="fu">:</span> map f xs</a></code></pre></div>
<p>The two lines are analogous to a switch statement in Swift. The parameters for <code class="sourceCode haskell">map</code> are a transformation function and a list. So, the first line has <code class="sourceCode haskell">_</code> (wildcard) for the function, and <code class="sourceCode haskell">[]</code> (empty) for the list, meaning it will match any function and an empty list. It returns an empty list.</p>
<p>The second line matches a function (which it assigns the name <code class="sourceCode scala">f</code>) and then decomposes the list itâ€™s given into a head (<code class="sourceCode scala">x</code>) and tail (<code class="sourceCode scala">xs</code>). It then calls <code class="sourceCode scala">f</code> on the head, and prepends (the <code class="sourceCode scala">:</code> operator is prepends, also called â€œconsâ€ by convention) the result to itself called recursively on the tail.</p>
<p>With switch statements and the <code class="sourceCode scala">indirect</code> keyword, weâ€™re getting pretty close to that level of brevity (terseness?) in Swift:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb3-1" data-line-number="1">extension List {</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  public func map&lt;T&gt;(@noescape transform: Element -&gt; T) -&gt; List&lt;T&gt; {</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">    switch self {</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">    <span class="kw">case</span> .<span class="fu">Nil</span>: <span class="kw">return</span> .<span class="fu">Nil</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">    <span class="kw">case</span> let .<span class="fu">Cons</span>(head, tail): <span class="kw">return</span></a>
<a class="sourceLine" id="cb3-6" data-line-number="6">      .<span class="fu">Cons</span>(head: <span class="fu">transform</span>(head), tail: tail.<span class="fu">map</span>(transform))</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">    }</a>
<a class="sourceLine" id="cb3-8" data-line-number="8">  }</a>
<a class="sourceLine" id="cb3-9" data-line-number="9">}</a></code></pre></div>
<p>We can define our own â€œconsâ€, to clean it up a little. Weâ€™re not allowed to use <code class="sourceCode scala">:</code>, so I went with <code class="sourceCode scala">|&gt;</code>, which is, in my mind, reasonably representative of â€œconsâ€.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb4-1" data-line-number="1">infix operator |&gt; {</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  associativity right</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  precedence <span class="dv">100</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">}</a>
<a class="sourceLine" id="cb4-5" data-line-number="5"></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">public func |&gt; &lt;T&gt;(lhs: T, rhs: List&lt;T&gt;) -&gt; List&lt;T&gt; {</a>
<a class="sourceLine" id="cb4-7" data-line-number="7">  <span class="kw">return</span> .<span class="fu">Cons</span>(head: lhs, tail: rhs)</a>
<a class="sourceLine" id="cb4-8" data-line-number="8">}</a>
<a class="sourceLine" id="cb4-9" data-line-number="9"></a>
<a class="sourceLine" id="cb4-10" data-line-number="10">extension List {</a>
<a class="sourceLine" id="cb4-11" data-line-number="11">  public func map&lt;T&gt;(@noescape transform: Element -&gt; T) -&gt; List&lt;T&gt; {</a>
<a class="sourceLine" id="cb4-12" data-line-number="12">    switch self {</a>
<a class="sourceLine" id="cb4-13" data-line-number="13">    <span class="kw">case</span> .<span class="fu">Nil</span>: <span class="kw">return</span> .<span class="fu">Nil</span></a>
<a class="sourceLine" id="cb4-14" data-line-number="14">    <span class="kw">case</span> let .<span class="fu">Cons</span>(head, tail):</a>
<a class="sourceLine" id="cb4-15" data-line-number="15">      <span class="kw">return</span> <span class="fu">transform</span>(head) |&gt; tail.<span class="fu">map</span>(transform)</a>
<a class="sourceLine" id="cb4-16" data-line-number="16">    }</a>
<a class="sourceLine" id="cb4-17" data-line-number="17">  }</a>
<a class="sourceLine" id="cb4-18" data-line-number="18">}</a></code></pre></div>
<p>Pretty soon you can start doing some elegant and exciting things with lists. The recursive pattern is <em>very</em> well suited to higher-order functions and other FP staples. Take, for instance, the <code class="sourceCode scala">reduce</code> function:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb5-1" data-line-number="1">extension List {</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">  public func reduce&lt;T&gt;(initial: T, @noescape combine: (T, Element) -&gt; T) -&gt; T {</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">    switch self {</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">    <span class="kw">case</span> .<span class="fu">Nil</span>: <span class="kw">return</span> initial</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">    <span class="kw">case</span> let .<span class="fu">Cons</span>(h, t):</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">      <span class="kw">return</span> t.<span class="fu">reduce</span>(<span class="fu">combine</span>(initial, h), combine: combine)</a>
<a class="sourceLine" id="cb5-7" data-line-number="7">    }</a>
<a class="sourceLine" id="cb5-8" data-line-number="8">  }</a>
<a class="sourceLine" id="cb5-9" data-line-number="9">}</a></code></pre></div>
<p>Or a transposing function:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb6-1" data-line-number="1">func transpose&lt;T&gt;(mat: List&lt;List&lt;T&gt;&gt;) -&gt; List&lt;List&lt;T&gt;&gt; {</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  switch mat {</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  <span class="kw">case</span> let .<span class="fu">Cons</span>(x, xs) where x.<span class="fu">isEmpty</span>: <span class="kw">return</span> <span class="fu">transpose</span>(xs)</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">  <span class="kw">case</span> let .<span class="fu">Cons</span>(.<span class="fu">Cons</span>(x, xs), xss):</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">    <span class="kw">return</span> (x |&gt; xss.<span class="fu">flatMap</span>{$<span class="fl">0.f</span>irst}) |&gt;</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">      <span class="fu">transpose</span>(xs |&gt; xss.<span class="fu">map</span>{$<span class="fl">0.</span>tail})</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">  default: <span class="kw">return</span> .<span class="fu">Nil</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">  }</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">}</a>
<a class="sourceLine" id="cb6-10" data-line-number="10"></a>
<a class="sourceLine" id="cb6-11" data-line-number="11">let jo: List&lt;List&lt;Int&gt;&gt; = [[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>], [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>], [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]]</a>
<a class="sourceLine" id="cb6-12" data-line-number="12"><span class="fu">transpose</span>(jo) <span class="co">// [[1, 1, 1], [2, 2, 2], [3, 3, 3]]</span></a></code></pre></div>
<p>You can do <code class="sourceCode scala">foldr</code>, which is like <code class="sourceCode scala">reduce</code>, but works in reverse:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb7-1" data-line-number="1">extension List {</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  func foldr&lt;T&gt;(initial: T, @noescape combine: (element: Element, accumulator: T) -&gt; T) -&gt; T {</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">    switch self {</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">    <span class="kw">case</span> .<span class="fu">Nil</span>: <span class="kw">return</span> initial</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">    <span class="kw">case</span> let .<span class="fu">Cons</span>(x, xs):</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">      <span class="kw">return</span> <span class="fu">combine</span>(</a>
<a class="sourceLine" id="cb7-7" data-line-number="7">        element: x,</a>
<a class="sourceLine" id="cb7-8" data-line-number="8">        accumulator: xs.<span class="fu">foldr</span>(initial, combine: combine)</a>
<a class="sourceLine" id="cb7-9" data-line-number="9">      )</a>
<a class="sourceLine" id="cb7-10" data-line-number="10">    }</a>
<a class="sourceLine" id="cb7-11" data-line-number="11">  }</a>
<a class="sourceLine" id="cb7-12" data-line-number="12">}</a></code></pre></div>
<p>Using <code class="sourceCode scala">foldr</code>, you can get all of the non-empty subsequences of a list:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb8-1" data-line-number="1">extension List {</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  <span class="kw">var</span> subsequences: List&lt;List&lt;Element&gt;&gt; {</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">    switch self {</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">    <span class="kw">case</span> .<span class="fu">Nil</span>: <span class="kw">return</span> .<span class="fu">Nil</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5">    <span class="kw">case</span> let .<span class="fu">Cons</span>(x, xs):</a>
<a class="sourceLine" id="cb8-6" data-line-number="6">      <span class="kw">return</span> [x] |&gt; xs.<span class="fu">subsequences</span>.<span class="fu">foldr</span>([]) {</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">        (ys, r) in ys |&gt; (x |&gt; ys) |&gt; r</a>
<a class="sourceLine" id="cb8-8" data-line-number="8">      }</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">    }</a>
<a class="sourceLine" id="cb8-10" data-line-number="10">  }</a>
<a class="sourceLine" id="cb8-11" data-line-number="11">}</a>
<a class="sourceLine" id="cb8-12" data-line-number="12">let jo: List = [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]</a>
<a class="sourceLine" id="cb8-13" data-line-number="13">jo.<span class="fu">subsequences</span> <span class="co">// [[1], [2], [1, 2], [1, 3], [2, 3], [1, 2, 3]]</span></a></code></pre></div>
<p>(these examples are all translated from the Haskell standard library) Lists are extremely fun, and some functions you would have found yourself writing on 10-15 lines can be got into 2-3. To get a better feel for playing around with lists, itâ€™s useful to have them conform to some protocols that make them easier to work with in a playground.</p>
<p>For instance, making a list currently looks like this:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb9-1" data-line-number="1">let jo: List = <span class="dv">1</span> |&gt; <span class="dv">2</span> |&gt; <span class="dv">3</span> |&gt; .<span class="fu">Nil</span></a></code></pre></div>
<p>Which is fine, and better than:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb10-1" data-line-number="1">let jo: List = .<span class="fu">Cons</span>(head: <span class="dv">1</span>, tail: .<span class="fu">Cons</span>(head: <span class="dv">2</span>, tail: .<span class="fu">Cons</span>(head: <span class="dv">3</span>, tail: .<span class="fu">Nil</span>)))</a></code></pre></div>
<p>but still not fantastic. The obvious next step is making <code class="sourceCode scala">List</code> <code class="sourceCode scala">ArrayLiteralConvertible</code>, but thereâ€™s a small catch. We donâ€™t have an <code class="sourceCode scala">append</code> function for lists (yet). So we canâ€™t, off the bat, do something like this:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb11-1" data-line-number="1">extension List : ArrayLiteralConvertible {</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">  public <span class="fu">init</span>(arrayLiteral: Element...) {</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">    <span class="kw">var</span> ret: List&lt;Element&gt; = .<span class="fu">Nil</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4">    <span class="kw">for</span> el in arrayLiteral { ret.<span class="fu">append</span>(el) }</a>
<a class="sourceLine" id="cb11-5" data-line-number="5">    self = ret</a>
<a class="sourceLine" id="cb11-6" data-line-number="6">  }</a>
<a class="sourceLine" id="cb11-7" data-line-number="7">}</a></code></pre></div>
<p>And nor do I think weâ€™d want to. Operations on the end of lists are slow: you have to walk along the entire list every time.</p>
<p>We could <em>reverse</em> the sequence we want to turn into a list, and prepend as we go. Butâ€¦ thatâ€™s inefficient too. Sure, <code class="sourceCode scala">Array</code>s are fast to reverse, but other sequences arenâ€™t. For those that canâ€™t be reversed lazily, youâ€™re storing an extra sequence in memory unnecessarily.</p>
<p>But thereâ€™s something that we can use: generators. In Swift, generators are like super-imperative, crazy-unsafe recursive lists. When you can the <code class="sourceCode scala"><span class="fu">next</span>()</code> method on a generator, you get the â€œheadâ€ back. Crucially, though: <em>the generator is left with the tail</em>. Making use of this fact too often will lead to bugs, but if we wrap it up in <code class="sourceCode scala"><span class="kw">private</span></code>, itâ€™s a perfect fit:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb12-1" data-line-number="1">extension List {</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">  <span class="kw">private</span> init&lt;G : GeneratorType where G.<span class="fu">Element</span> == Element&gt;(<span class="kw">var</span> gen: G) {</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">    <span class="kw">if</span> let head = gen.<span class="fu">next</span>() {</a>
<a class="sourceLine" id="cb12-4" data-line-number="4">      self = head |&gt; List(gen: gen)</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">    } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb12-6" data-line-number="6">      self = .<span class="fu">Nil</span></a>
<a class="sourceLine" id="cb12-7" data-line-number="7">    }</a>
<a class="sourceLine" id="cb12-8" data-line-number="8">  }</a>
<a class="sourceLine" id="cb12-9" data-line-number="9">}</a></code></pre></div>
<p>The potential bug here is kind of interesting. If, instead of an infix operator for cons, weâ€™d had a method on <code class="sourceCode scala">List</code> that did the same thing:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb13-1" data-line-number="1">extension List {</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">  public func <span class="fu">prepended</span>(<span class="kw">with</span>: Element) -&gt; List&lt;Element&gt; {</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">    <span class="kw">return</span> .<span class="fu">Cons</span>(head: <span class="kw">with</span>, tail: self)</a>
<a class="sourceLine" id="cb13-4" data-line-number="4">  }</a>
<a class="sourceLine" id="cb13-5" data-line-number="5">}</a></code></pre></div>
<p>Weâ€™d be able to curry that function in a <code class="sourceCode scala"><span class="fu">map</span>()</code>, and get an <code class="sourceCode scala">init</code> function thatâ€™s very pretty:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb14-1" data-line-number="1">extension List {</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">  <span class="kw">private</span> init&lt;G : GeneratorType where G.<span class="fu">Element</span> == Element&gt;(<span class="kw">var</span> g: G) {</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">    self = g.<span class="fu">next</span>().<span class="fu">map</span>(List(g: g).<span class="fu">prepended</span>) ?? .<span class="fu">Nil</span></a>
<a class="sourceLine" id="cb14-4" data-line-number="4">  }</a>
<a class="sourceLine" id="cb14-5" data-line-number="5">}</a></code></pre></div>
<p>But it wonâ€™t run. Since the recursive call to the function is curried, itâ€™s resolved before the <code class="sourceCode scala">g.<span class="fu">next</span>()</code> part. Which means that, regardless of whether <code class="sourceCode scala">g</code> returns <code class="sourceCode scala">nil</code> or not, the call will be made, causing an infinite loop of sadness. To fix it, you have to make the order of operations clear: <em>do not</em> make a recursive call if <code class="sourceCode scala">g.<span class="fu">next</span>()</code> returns <code class="sourceCode scala">nil</code>.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb15-1" data-line-number="1">extension List {</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">  <span class="kw">private</span> init&lt;G : GeneratorType where G.<span class="fu">Element</span> == Element&gt;(<span class="kw">var</span> gen: G) {</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">    <span class="kw">if</span> let head = gen.<span class="fu">next</span>() {</a>
<a class="sourceLine" id="cb15-4" data-line-number="4">      self = head |&gt; List(gen: gen)</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">    } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb15-6" data-line-number="6">      self = .<span class="fu">Nil</span></a>
<a class="sourceLine" id="cb15-7" data-line-number="7">    }</a>
<a class="sourceLine" id="cb15-8" data-line-number="8">  }</a>
<a class="sourceLine" id="cb15-9" data-line-number="9">  public init&lt;S : SequenceType where S.<span class="fu">Generator</span>.<span class="fu">Element</span> == Element&gt;(_ seq: S) {</a>
<a class="sourceLine" id="cb15-10" data-line-number="10">    self = List(gen: seq.<span class="fu">generate</span>())</a>
<a class="sourceLine" id="cb15-11" data-line-number="11">  }</a>
<a class="sourceLine" id="cb15-12" data-line-number="12">}</a>
<a class="sourceLine" id="cb15-13" data-line-number="13"></a>
<a class="sourceLine" id="cb15-14" data-line-number="14">extension List : ArrayLiteralConvertible {</a>
<a class="sourceLine" id="cb15-15" data-line-number="15">  public <span class="fu">init</span>(arrayLiteral: Element...) {</a>
<a class="sourceLine" id="cb15-16" data-line-number="16">    self = List(arrayLiteral.<span class="fu">generate</span>())</a>
<a class="sourceLine" id="cb15-17" data-line-number="17">  }</a>
<a class="sourceLine" id="cb15-18" data-line-number="18">}</a></code></pre></div>
<p>This all makes it easy to initialise a list. Being able to <em>see</em> the list and its contents is also important. Currently, weâ€™ve got this mess:</p>
<p><img class="aligncenter size-full wp-image-404" src="https://bigonotetaking.files.wordpress.com/2015/07/screen-shot-2015-07-29-at-12-12-56.png" alt="Screen Shot 2015-07-29 at 12.12.56" width="660" height="39" /></p>
<p>When what we really want is a comma-separated list of the contents. We also probably want some demarcation at either end, so itâ€™s easier to recognise nested lists. Iâ€™m not sure what the best demarcation would be: ideally it should be different to an Arrayâ€™s square brackets, but not confusing either. I went with <code class="sourceCode scala">[:</code> and <code class="sourceCode scala">:]</code> in the end, though Iâ€™m not terribly happy about it:</p>
<p><img class="aligncenter size-full wp-image-406" src="https://bigonotetaking.files.wordpress.com/2015/07/screen-shot-2015-07-29-at-12-27-53.png" alt="Screen Shot 2015-07-29 at 12.27.53" width="522" height="32" /></p>
<p>To get that printout on the right-hand-side of your playground, you need to make your typeÂ <code class="sourceCode scala">CustomDebugStringConvertible</code>. Thereâ€™s one one interesting problem with this: how do you know the contents of your list are printable? You canâ€™t extend your struct to have conditional conformance, like this:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb16-1" data-line-number="1">extension List (where Element : CustomDebugStringConvertible) : CustomDebugStringConvertible {...</a></code></pre></div>
<p>However, you canâ€™t just get a string representation of something that doesnâ€™t have one. Luckily, <code class="sourceCode scala">String</code> has an initialiser that takes <em>anything</em>. It uses runtime reflection to do so. Hereâ€™s what the extension ends up looking like:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb17-1" data-line-number="1">extension List : CustomDebugStringConvertible {</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">  public <span class="kw">var</span> debugDescription: String {</a>
<a class="sourceLine" id="cb17-3" data-line-number="3">    return<span class="st">&quot;[:&quot;</span> + <span class="st">&quot;, &quot;</span>.<span class="fu">join</span>(map{String(reflecting: $<span class="dv">0</span>)}) + <span class="st">&quot;:]&quot;</span></a>
<a class="sourceLine" id="cb17-4" data-line-number="4">  }</a>
<a class="sourceLine" id="cb17-5" data-line-number="5">}</a></code></pre></div>
<p>To use the <code class="sourceCode scala"><span class="fu">join</span>()</code> function, of course, <code class="sourceCode scala">List</code> needs to conform to <code class="sourceCode scala">SequenceType</code>. Weâ€™ll need some generator that swaps out the current <code class="sourceCode scala">List</code> struct on each iteration, and returns the head. You <em>could</em> just use <code class="sourceCode scala">anyGenerator</code> but, since itâ€™s a class, itâ€™s significantly slower than defining a new struct.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb18-1" data-line-number="1">public struct ListGenerator&lt;Element&gt; : GeneratorType, SequenceType {</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">  <span class="kw">private</span> <span class="kw">var</span> list: List&lt;Element&gt;</a>
<a class="sourceLine" id="cb18-3" data-line-number="3">  public mutating func <span class="fu">next</span>() -&gt; Element? {</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">    switch list {</a>
<a class="sourceLine" id="cb18-5" data-line-number="5">    <span class="kw">case</span> .<span class="fu">Nil</span>: <span class="kw">return</span> nil</a>
<a class="sourceLine" id="cb18-6" data-line-number="6">    <span class="kw">case</span> let .<span class="fu">Cons</span>(head, tail):</a>
<a class="sourceLine" id="cb18-7" data-line-number="7">      list = tail</a>
<a class="sourceLine" id="cb18-8" data-line-number="8">      <span class="kw">return</span> head</a>
<a class="sourceLine" id="cb18-9" data-line-number="9">    }</a>
<a class="sourceLine" id="cb18-10" data-line-number="10">  }</a>
<a class="sourceLine" id="cb18-11" data-line-number="11">  public func <span class="fu">generate</span>() -&gt; ListGenerator { <span class="kw">return</span> self }</a>
<a class="sourceLine" id="cb18-12" data-line-number="12">}</a>
<a class="sourceLine" id="cb18-13" data-line-number="13"></a>
<a class="sourceLine" id="cb18-14" data-line-number="14">extension List : SequenceType {</a>
<a class="sourceLine" id="cb18-15" data-line-number="15">  public func <span class="fu">generate</span>() -&gt; ListGenerator&lt;Element&gt; {</a>
<a class="sourceLine" id="cb18-16" data-line-number="16">    <span class="kw">return</span> <span class="fu">ListGenerator</span>(list: self)</a>
<a class="sourceLine" id="cb18-17" data-line-number="17">  }</a>
<a class="sourceLine" id="cb18-18" data-line-number="18">}</a></code></pre></div>
<p>And youâ€™ve got a <code class="sourceCode scala">SequenceType</code> thatâ€™s normal-looking and easy to work with.</p>
<h3 id="laziness">Laziness</h3>
<p>Iâ€™m not sure if this is entirely relevant here, but I <em>do</em> like laziness, so I thought Iâ€™d make a version of <code class="sourceCode scala">List</code> that was lazy. It turns out itâ€™s easy to do: in fact, it was possible before <code class="sourceCode scala">indirect</code> enums. So, starting with the standard <code class="sourceCode scala">List</code> definition:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb19-1" data-line-number="1">public enum LazyList&lt;Element&gt; {</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">  <span class="kw">case</span> Nil</a>
<a class="sourceLine" id="cb19-3" data-line-number="3">  indirect <span class="kw">case</span> <span class="fu">Cons</span>(head: Element, tail: LazyList&lt;Element&gt;)</a>
<a class="sourceLine" id="cb19-4" data-line-number="4">}</a></code></pre></div>
<p>Letâ€™s make it lazy. The main idea would be to defer the resolution of <code class="sourceCode scala">tail</code>. What we really want is for tail to be a function that <em>returns</em> a list, rather than a list itself.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb20-1" data-line-number="1">public enum LazyList&lt;Element&gt; {</a>
<a class="sourceLine" id="cb20-2" data-line-number="2">  <span class="kw">case</span> Nil</a>
<a class="sourceLine" id="cb20-3" data-line-number="3">  <span class="kw">case</span> <span class="fu">Cons</span>(head: Element, tail: () -&gt; LazyList&lt;Element&gt;)</a>
<a class="sourceLine" id="cb20-4" data-line-number="4">}</a></code></pre></div>
<p>This is the reason that <code class="sourceCode scala">indirect</code> isnâ€™t needed: because tail isnâ€™t a list, all thatâ€™s stored in the enum is the reference to the function. This is what <code class="sourceCode scala">indirect</code> does automatically, or what the <code class="sourceCode scala">Box</code> struct did manually.</p>
<p>There are some more wrinkles with laziness. For instance, our old infix operator wonâ€™t work:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb21-1" data-line-number="1">public func |&gt; &lt;T&gt;(lhs: T, rhs: LazyList&lt;T&gt;) -&gt; LazyList&lt;T&gt; {</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">  <span class="kw">return</span> .<span class="fu">Cons</span>(head: lhs, tail: rhs)</a>
<a class="sourceLine" id="cb21-3" data-line-number="3">}</a></code></pre></div>
<p>Again, because tail is meant to be a function that returns a list, not a list itself. This <em>would</em> work, but not in the way we intend it:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb22-1" data-line-number="1">public func |&gt; &lt;T&gt;(lhs: T, rhs: LazyList&lt;T&gt;) -&gt; LazyList&lt;T&gt; {</a>
<a class="sourceLine" id="cb22-2" data-line-number="2">  <span class="kw">return</span> .<span class="fu">Cons</span>(head: lhs, tail: {rhs})</a>
<a class="sourceLine" id="cb22-3" data-line-number="3">}</a></code></pre></div>
<p>Whateverâ€™s to the right-hand-side of the operator will get resolved, and <em>then</em> put into the closure, which we donâ€™t want. For instance, this:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb23-1" data-line-number="1">func <span class="fu">printAndGiveList</span>() -&gt; LazyList&lt;Int&gt; {</a>
<a class="sourceLine" id="cb23-2" data-line-number="2">  <span class="fu">print</span>(<span class="dv">2</span>)</a>
<a class="sourceLine" id="cb23-3" data-line-number="3">  <span class="kw">return</span> .<span class="fu">Nil</span></a>
<a class="sourceLine" id="cb23-4" data-line-number="4">}</a>
<a class="sourceLine" id="cb23-5" data-line-number="5"></a>
<a class="sourceLine" id="cb23-6" data-line-number="6"><span class="dv">2</span> |&gt; <span class="dv">1</span> |&gt; <span class="fu">printAndGiveList</span>()</a></code></pre></div>
<p>Will give you a â€œ<code class="sourceCode scala">LazyList</code>â€, but 2 gets printed, meaning that itâ€™s not <em>really</em> behaving lazily.</p>
<p><code class="sourceCode scala">@autoclosure</code> to the rescue! This is a little annotation you put before your parameters that can let you decide when to evaluate the argument.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb24-1" data-line-number="1">public func |&gt; &lt;T&gt;(lhs: T, @<span class="fu">autoclosure</span>(escaping) rhs: () -&gt; LazyList&lt;T&gt;) -&gt; LazyList&lt;T&gt; {</a>
<a class="sourceLine" id="cb24-2" data-line-number="2">  <span class="kw">return</span> .<span class="fu">Cons</span>(head: lhs, tail: rhs)</a>
<a class="sourceLine" id="cb24-3" data-line-number="3">}</a></code></pre></div>
<p>The <code class="sourceCode scala">escaping</code> in the brackets is needed to signify that the closure will last longer than the lifetime of the scope it is declared in. If you test this new version with the <code class="sourceCode scala"><span class="fu">printAndGiveList</span>()</code> function, youâ€™ll see that 2 does <em>not</em> get printed. In fact, the behaviour of this operator lets us use a lot of the same code from the strict list, <em>without</em> the strictness. (The generator initialiser, for instance: the same code, if used to initialise a lazy list, will work. In fact, if the underlying sequence that the generator comes from is lazy, <em>that laziness is maintained in the lazy list</em>. Thatâ€™s pretty cool.)</p>
<p>Thereâ€™s an interesting point to be made, here. The usual definition for a lazy programming language is one in which functions do not evaluate their arguments until they need to. In contrast, eager languages evaluate function arguments before the body of the function. This kind of makes it seem that you could treat Swift as a totally lazy languageâ€¦</p>
<p>At any rate, this new-and-improved operator works exactly as we want it. Itâ€™s properly lazy. The rest is easy: every time <code class="sourceCode scala">tail</code> was used in <code class="sourceCode scala">List</code>, replace it with <code class="sourceCode scala"><span class="fu">tail</span>()</code>.</p>
<h3 id="the-deque">The Deque</h3>
<p>Lists are useful. They let you operate on their first element in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math> time, which makes a lot of sense, since you often find yourself starting there.</p>
<p>Theyâ€™ve got some disadvantages, though: for one, to get to the nth element, you have to walk along n elements in the list. So while operations of the <em>start</em> are fast, operations on the end are painfully slow. And forget about efficient indexing.</p>
<p>This is where a Deque comes in. When you need to operate on two ends of a collection, a Deque is what you want to be using. Removal of the first and last element, prepending, and appending are all <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math>.</p>
<p>Itâ€™s made up of two lists: one for the front half, and one, in reverse, for the back half. With that information weâ€™ve enough to get a definition down:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb25-1" data-line-number="1">public struct Deque&lt;Element&gt; {</a>
<a class="sourceLine" id="cb25-2" data-line-number="2">  <span class="kw">private</span> <span class="kw">var</span> front, back: List&lt;Element&gt;</a>
<a class="sourceLine" id="cb25-3" data-line-number="3">}</a></code></pre></div>
<p>Youâ€™ve got to do similar things that you did to the list to get an easy-to-work-with struct. <code class="sourceCode scala">CustomDebugStringConvertible</code>, <code class="sourceCode scala">ArrayLiteralConvertible</code>, etc. Itâ€™s not tremendously interesting, so here it is:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb26-1" data-line-number="1">extension Deque : CustomDebugStringConvertible {</a>
<a class="sourceLine" id="cb26-2" data-line-number="2">  public <span class="kw">var</span> debugDescription: String {</a>
<a class="sourceLine" id="cb26-3" data-line-number="3">    <span class="kw">return</span></a>
<a class="sourceLine" id="cb26-4" data-line-number="4">      <span class="st">&quot;, &quot;</span>.<span class="fu">join</span>(front.<span class="fu">map</span>{String(reflecting: $<span class="dv">0</span>)}) +</a>
<a class="sourceLine" id="cb26-5" data-line-number="5">      <span class="st">&quot; | &quot;</span> +</a>
<a class="sourceLine" id="cb26-6" data-line-number="6">      <span class="st">&quot;, &quot;</span>.<span class="fu">join</span>(back.<span class="fu">reverse</span>().<span class="fu">map</span>{String(reflecting: $<span class="dv">0</span>)})</a>
<a class="sourceLine" id="cb26-7" data-line-number="7">  }</a>
<a class="sourceLine" id="cb26-8" data-line-number="8">}</a>
<a class="sourceLine" id="cb26-9" data-line-number="9"></a>
<a class="sourceLine" id="cb26-10" data-line-number="10">extension Deque {</a>
<a class="sourceLine" id="cb26-11" data-line-number="11">  public <span class="fu">init</span>(array: [Element]) {</a>
<a class="sourceLine" id="cb26-12" data-line-number="12">    let half = array.<span class="fu">endIndex</span> / <span class="dv">2</span></a>
<a class="sourceLine" id="cb26-13" data-line-number="13">    front = List(array[<span class="dv">0</span>..&lt;half])</a>
<a class="sourceLine" id="cb26-14" data-line-number="14">    back = List(array[half..&lt;array.<span class="fu">endIndex</span>].<span class="fu">reverse</span>())</a>
<a class="sourceLine" id="cb26-15" data-line-number="15">  }</a>
<a class="sourceLine" id="cb26-16" data-line-number="16">}</a>
<a class="sourceLine" id="cb26-17" data-line-number="17"></a>
<a class="sourceLine" id="cb26-18" data-line-number="18">extension Deque : ArrayLiteralConvertible {</a>
<a class="sourceLine" id="cb26-19" data-line-number="19">  public <span class="fu">init</span>(arrayLiteral: Element...) {</a>
<a class="sourceLine" id="cb26-20" data-line-number="20">    self.<span class="fu">init</span>(array: arrayLiteral)</a>
<a class="sourceLine" id="cb26-21" data-line-number="21">  }</a>
<a class="sourceLine" id="cb26-22" data-line-number="22">}</a>
<a class="sourceLine" id="cb26-23" data-line-number="23"></a>
<a class="sourceLine" id="cb26-24" data-line-number="24">extension Deque {</a>
<a class="sourceLine" id="cb26-25" data-line-number="25">  public init&lt;S : SequenceType where S.<span class="fu">Generator</span>.<span class="fu">Element</span> == Element&gt;(_ seq: S) {</a>
<a class="sourceLine" id="cb26-26" data-line-number="26">    self.<span class="fu">init</span>(array: Array(seq))</a>
<a class="sourceLine" id="cb26-27" data-line-number="27">  }</a>
<a class="sourceLine" id="cb26-28" data-line-number="28">}</a></code></pre></div>
<p>The debug output puts a <code class="sourceCode scala">|</code> between the two lists:</p>
<p><img class="aligncenter size-full wp-image-395" src="https://bigonotetaking.files.wordpress.com/2015/07/screen-shot-2015-07-28-at-21-32-44.png" alt="Screen Shot 2015-07-28 at 21.32.44" width="660" height="29" /></p>
<p>This makes it clear how the performance characteristics come about: because the second half is a reversed list, all of the operations on the end of the Deque are operations on the beginning of a list. And thatâ€™s where lists are fast.</p>
<p>But thereâ€™s an obvious issue. Say we take that list, and start removing the first element from it:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb27-1" data-line-number="1">let a = an.<span class="fu">tail</span> <span class="co">// 2, 3 | 4, 5, 6</span></a>
<a class="sourceLine" id="cb27-2" data-line-number="2">let b = a.<span class="fu">tail</span>  <span class="co">// 3 | 4, 5, 6</span></a>
<a class="sourceLine" id="cb27-3" data-line-number="3">let c = b.<span class="fu">tail</span>  <span class="co">// | 4, 5, 6</span></a>
<a class="sourceLine" id="cb27-4" data-line-number="4">let d = c.<span class="fu">tail</span>  <span class="co">// ?????</span></a></code></pre></div>
<p>The front will end up being empty. The solution to this is the second important element to a Deque. It needs an invariant: if its number of elements is greater than one, neither the front list nor the back will be empty. When the invariant gets violated, it needs to fix it. We can check that the invariant has been upheld with a <code class="sourceCode scala">switch</code> statement:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb28-1" data-line-number="1">extension Deque {</a>
<a class="sourceLine" id="cb28-2" data-line-number="2">  <span class="kw">private</span> mutating func <span class="fu">check</span>() {</a>
<a class="sourceLine" id="cb28-3" data-line-number="3">    <span class="fu">switch</span> (front, back) {</a>
<a class="sourceLine" id="cb28-4" data-line-number="4">    <span class="kw">case</span> (.<span class="fu">Nil</span>, let .<span class="fu">Cons</span>(head, tail)) where !tail.<span class="fu">isEmpty</span>: <span class="fu">fix</span>()</a>
<a class="sourceLine" id="cb28-5" data-line-number="5">    <span class="kw">case</span> (let .<span class="fu">Cons</span>(head, tail), .<span class="fu">Nil</span>) where !tail.<span class="fu">isEmpty</span>: <span class="fu">fix</span>()</a>
<a class="sourceLine" id="cb28-6" data-line-number="6">    default:</a>
<a class="sourceLine" id="cb28-7" data-line-number="7">      <span class="kw">return</span></a>
<a class="sourceLine" id="cb28-8" data-line-number="8">    }</a>
<a class="sourceLine" id="cb28-9" data-line-number="9">  }</a>
<a class="sourceLine" id="cb28-10" data-line-number="10">}</a></code></pre></div>
<p>The first case is the front is empty, and the back has more than one element, and the second case is the back is empty, and the front has more than one element. To fix it, just chop off the tail of the non-empty list, reverse it, and assign it to the empty list:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb29-1" data-line-number="1">extension Deque {</a>
<a class="sourceLine" id="cb29-2" data-line-number="2">  <span class="kw">private</span> mutating func <span class="fu">check</span>() {</a>
<a class="sourceLine" id="cb29-3" data-line-number="3">    <span class="fu">switch</span> (front, back) {</a>
<a class="sourceLine" id="cb29-4" data-line-number="4">    <span class="kw">case</span> (.<span class="fu">Nil</span>, let .<span class="fu">Cons</span>(head, tail)) where !tail.<span class="fu">isEmpty</span>:</a>
<a class="sourceLine" id="cb29-5" data-line-number="5">      (front, back) = (tail.<span class="fu">reverse</span>(), [head])</a>
<a class="sourceLine" id="cb29-6" data-line-number="6">    <span class="kw">case</span> (let .<span class="fu">Cons</span>(head, tail), .<span class="fu">Nil</span>) where !tail.<span class="fu">isEmpty</span>:</a>
<a class="sourceLine" id="cb29-7" data-line-number="7">      (back, front) = (tail.<span class="fu">reverse</span>(), [head])</a>
<a class="sourceLine" id="cb29-8" data-line-number="8">    default:</a>
<a class="sourceLine" id="cb29-9" data-line-number="9">      <span class="kw">return</span></a>
<a class="sourceLine" id="cb29-10" data-line-number="10">    }</a>
<a class="sourceLine" id="cb29-11" data-line-number="11">  }</a>
<a class="sourceLine" id="cb29-12" data-line-number="12">}</a></code></pre></div>
<p>Now, wherever we have a mutating method that may cause a violation of the invariant, this <code class="sourceCode scala">check</code> is called. One particularly cool way to do this is by using <code class="sourceCode scala">didSet</code>:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb30-1" data-line-number="1">public struct Deque&lt;Element&gt; {</a>
<a class="sourceLine" id="cb30-2" data-line-number="2">  <span class="kw">private</span> <span class="kw">var</span> front: List&lt;Element&gt; { didSet { <span class="fu">check</span>() } }</a>
<a class="sourceLine" id="cb30-3" data-line-number="3">  <span class="kw">private</span> <span class="kw">var</span> back : List&lt;Element&gt; { didSet { <span class="fu">check</span>() } }</a>
<a class="sourceLine" id="cb30-4" data-line-number="4">}</a></code></pre></div>
<p>This will call <code class="sourceCode scala"><span class="fu">check</span>()</code> whenever either list is mutated, ensuring you canâ€™t forget. If a <em>new</em> Deque is initialised, though, it wonâ€™t be called. I donâ€™t trust myself to remember the <code class="sourceCode scala"><span class="fu">check</span>()</code> on every init, so we can put it into the initialiser:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb31-1" data-line-number="1">  <span class="kw">private</span> <span class="fu">init</span>(_ front: List&lt;Element&gt;, _ back: List&lt;Element&gt;) {</a>
<a class="sourceLine" id="cb31-2" data-line-number="2">    (self.<span class="fu">front</span>, self.<span class="fu">back</span>) = (front, back)</a>
<a class="sourceLine" id="cb31-3" data-line-number="3">    <span class="fu">check</span>()</a>
<a class="sourceLine" id="cb31-4" data-line-number="4">  }</a></code></pre></div>
<p>This is the only initialiser so far, so itâ€™s the only one Iâ€™m allowed to call. However, there may be some cases where I <em>know</em> that the front and back are balanced. So I want a separate initialiser for those, for efficiencyâ€™s sake. But itâ€™s got to be called <code class="sourceCode scala">init</code> no matter what, so how can I specify that I want to use the non-checking initialiser, over the checking one? I could have a function called something like <code class="sourceCode scala">initialiseFromBalanced</code> that returns a Deque, but I donâ€™t like that. You couldÂ use labelled arguments. <a href="http://ericasadun.com/2015/06/01/swift-safe-array-indexing-my-favorite-thing-of-the-new-week/">Erica Sadun has a cool post on using them with subscripts</a>, and hereâ€™s what it would look like with <code class="sourceCode scala">init</code>:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb32-1" data-line-number="1">extension Deque {</a>
<a class="sourceLine" id="cb32-2" data-line-number="2">  <span class="kw">private</span> <span class="fu">init</span>(balancedFront: List&lt;Element&gt;, balancedBack: List&lt;Element&gt;) {</a>
<a class="sourceLine" id="cb32-3" data-line-number="3">    (front, back) = (balancedFront, balancedBack)</a>
<a class="sourceLine" id="cb32-4" data-line-number="4">  }</a>
<a class="sourceLine" id="cb32-5" data-line-number="5">}</a></code></pre></div>
<p>So now we have a default initialiser that automatically balances the Deque, and a specialised one that takes two lists already balanced.</p>
<p>There is an extra function on lists in the <code class="sourceCode scala"><span class="fu">check</span>()</code> function: <code class="sourceCode scala"><span class="fu">reverse</span>()</code>. There are a load of different ways to do it. If youâ€™re in the mood for golf:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb33-1" data-line-number="1">let joanne: List = [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>]</a>
<a class="sourceLine" id="cb33-2" data-line-number="2">joanne.<span class="fu">reduce</span>(.<span class="fu">Nil</span>) { $<span class="dv">1</span> |&gt; $<span class="dv">0</span> } <span class="co">// 6, 5, 4, 3, 2, 1</span></a></code></pre></div>
<p>Or, if youâ€™d like to keep it recursive:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb34-1" data-line-number="1">extension List {</a>
<a class="sourceLine" id="cb34-2" data-line-number="2">  <span class="kw">private</span> func <span class="fu">reverse</span>(other: List&lt;Element&gt;) -&gt; List&lt;Element&gt; {</a>
<a class="sourceLine" id="cb34-3" data-line-number="3">    switch self {</a>
<a class="sourceLine" id="cb34-4" data-line-number="4">    <span class="kw">case</span> .<span class="fu">Nil</span>: <span class="kw">return</span> other</a>
<a class="sourceLine" id="cb34-5" data-line-number="5">    <span class="kw">case</span> let .<span class="fu">Cons</span>(head, tail): <span class="kw">return</span> tail.<span class="fu">reverse</span>(head |&gt; other)</a>
<a class="sourceLine" id="cb34-6" data-line-number="6">    }</a>
<a class="sourceLine" id="cb34-7" data-line-number="7">  }</a>
<a class="sourceLine" id="cb34-8" data-line-number="8">  public func <span class="fu">reverse</span>() -&gt; List&lt;Element&gt; {</a>
<a class="sourceLine" id="cb34-9" data-line-number="9">    <span class="kw">return</span> <span class="fu">reverse</span>(.<span class="fu">Nil</span>)</a>
<a class="sourceLine" id="cb34-10" data-line-number="10">  }</a>
<a class="sourceLine" id="cb34-11" data-line-number="11">}</a></code></pre></div>
<p>Obviously, you want to avoid this operation as much as possible. Weâ€™ll have to bear that in mind when weâ€™re adding other functions.</p>
<p>So what kind of operations do we want on Deques? Well, <code class="sourceCode scala"><span class="fu">removeFirst</span>()</code> and <code class="sourceCode scala"><span class="fu">removeLast</span>()</code> would be a start:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb35-1" data-line-number="1">extension Deque {</a>
<a class="sourceLine" id="cb35-2" data-line-number="2">  public mutating func <span class="fu">removeFirst</span>() -&gt; Element {</a>
<a class="sourceLine" id="cb35-3" data-line-number="3">    <span class="kw">return</span> front.<span class="fu">removeFirst</span>()</a>
<a class="sourceLine" id="cb35-4" data-line-number="4">  }</a>
<a class="sourceLine" id="cb35-5" data-line-number="5">  public mutating func <span class="fu">removeLast</span>() -&gt; Element {</a>
<a class="sourceLine" id="cb35-6" data-line-number="6">    <span class="kw">return</span> back.<span class="fu">removeFirst</span>()</a>
<a class="sourceLine" id="cb35-7" data-line-number="7">  }</a>
<a class="sourceLine" id="cb35-8" data-line-number="8">}</a></code></pre></div>
<p>And the function on lists:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb36-1" data-line-number="1">extension List {</a>
<a class="sourceLine" id="cb36-2" data-line-number="2">  public mutating func <span class="fu">removeFirst</span>() -&gt; Element {</a>
<a class="sourceLine" id="cb36-3" data-line-number="3">    switch self {</a>
<a class="sourceLine" id="cb36-4" data-line-number="4">    <span class="kw">case</span> .<span class="fu">Nil</span>: <span class="fu">fatalError</span>(<span class="st">&quot;Cannot call removeFirst() on an empty list&quot;</span>)</a>
<a class="sourceLine" id="cb36-5" data-line-number="5">    <span class="kw">case</span> let .<span class="fu">Cons</span>(head, tail):</a>
<a class="sourceLine" id="cb36-6" data-line-number="6">      self = tail</a>
<a class="sourceLine" id="cb36-7" data-line-number="7">      <span class="kw">return</span> head</a>
<a class="sourceLine" id="cb36-8" data-line-number="8">    }</a>
<a class="sourceLine" id="cb36-9" data-line-number="9">  }</a>
<a class="sourceLine" id="cb36-10" data-line-number="10">}</a></code></pre></div>
<p>The other functions are easy enough to figure out: <code class="sourceCode scala"><span class="fu">dropFirst</span>()</code>, <code class="sourceCode scala"><span class="fu">dropLast</span>()</code>, etc. And, since it conforms to <code class="sourceCode scala">SequenceType</code>, it gets all of the sequence methods from the standard library, as well. However, those methods are designed for other kinds of sequences - <code class="sourceCode scala">Array</code>s, <code class="sourceCode scala">String.<span class="fu">CharacterView</span></code>s, etc. There are <em>much</em> more efficient ways to do most of them. <code class="sourceCode scala">reverse</code>, for instance, is just this:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb37-1" data-line-number="1">extension Deque {</a>
<a class="sourceLine" id="cb37-2" data-line-number="2">  public func <span class="fu">reverse</span>() -&gt; Deque&lt;Element&gt; {</a>
<a class="sourceLine" id="cb37-3" data-line-number="3">    <span class="kw">return</span> <span class="fu">Deque</span>(balancedFront: back, balancedBack: front)</a>
<a class="sourceLine" id="cb37-4" data-line-number="4">  }</a>
<a class="sourceLine" id="cb37-5" data-line-number="5">}</a></code></pre></div>
<p>(Since reverse canâ€™t change the number of elements in either list, we can use the initialiser that takes a balanced front and back.) Other methods like <code class="sourceCode scala"><span class="fu">map</span>()</code>, <code class="sourceCode scala"><span class="fu">filter</span>()</code>, etc., will just give you back an array. If we wanted to keep the Deque, weâ€™d have to convert it back, which involves reversing, which is expensive. So we should do our own methods for those:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb38-1" data-line-number="1">extension Deque {</a>
<a class="sourceLine" id="cb38-2" data-line-number="2">  public func map&lt;T&gt;(@noescape transform: Element -&gt; T) -&gt; Deque&lt;T&gt; {</a>
<a class="sourceLine" id="cb38-3" data-line-number="3">    <span class="kw">return</span> Deque&lt;T&gt;(</a>
<a class="sourceLine" id="cb38-4" data-line-number="4">      balancedFront: front.<span class="fu">map</span>(transform),</a>
<a class="sourceLine" id="cb38-5" data-line-number="5">      balancedBack : back .<span class="fu">map</span>(transform)</a>
<a class="sourceLine" id="cb38-6" data-line-number="6">    )</a>
<a class="sourceLine" id="cb38-7" data-line-number="7">  }</a>
<a class="sourceLine" id="cb38-8" data-line-number="8">}</a>
<a class="sourceLine" id="cb38-9" data-line-number="9"></a>
<a class="sourceLine" id="cb38-10" data-line-number="10">extension Deque {</a>
<a class="sourceLine" id="cb38-11" data-line-number="11">  public func <span class="fu">filter</span>(@noescape includeElement: Element -&gt; Bool) -&gt; Deque&lt;Element&gt; {</a>
<a class="sourceLine" id="cb38-12" data-line-number="12">    <span class="kw">return</span> <span class="fu">Deque</span>(front.<span class="fu">filter</span>(includeElement), back.<span class="fu">filter</span>(includeElement))</a>
<a class="sourceLine" id="cb38-13" data-line-number="13">  }</a>
<a class="sourceLine" id="cb38-14" data-line-number="14">}</a></code></pre></div>
<p><code class="sourceCode scala"><span class="fu">filter</span>()</code> changes the number of elements in each list, which could cause violation of the invariant. So we use the unlabelled initialiser, which automatically <code class="sourceCode scala"><span class="fu">check</span>()</code>s.</p>
<p>Notice that we donâ€™t have to do any reversing here. This is a huge efficiency gain, but youâ€™ve got to bear in mind that weâ€™re assuming the order of execution of the closures for <code class="sourceCode scala">filter</code> and <code class="sourceCode scala">map</code> donâ€™t matter. ThisÂ isnâ€™t always the case. Take this function, which is supposed to skip two elements of a sequence:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb39-1" data-line-number="1"><span class="kw">var</span> i = <span class="dv">0</span></a>
<a class="sourceLine" id="cb39-2" data-line-number="2">[Int](<span class="dv">1</span>...<span class="dv">10</span>).<span class="fu">filter</span> { _ in i++ % <span class="dv">3</span> == <span class="dv">0</span> } <span class="co">// [1, 4, 7, 10]</span></a></code></pre></div>
<p>It wonâ€™t work for a Deque:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb40-1" data-line-number="1"><span class="fu">Deque</span>(<span class="dv">1</span>...<span class="dv">10</span>).<span class="fu">filter</span> { _ in i++ % <span class="dv">3</span> == <span class="dv">0</span> } <span class="co">// 1, 4 | 6, 9</span></a></code></pre></div>
<p>Thereâ€™s been talk of a <code class="sourceCode scala">@pure</code> attribute. The idea is this: put it before your function or closure name, and the compiler will verify that it has no side effects. It can only use its arguments as variables, or call other <code class="sourceCode scala">@pure</code> functions. It would be very useful here, as it wouldnâ€™t allow the <code class="sourceCode scala">i</code> to be used by <code class="sourceCode scala">filter</code>. Without it, youâ€™ll probably just have to mention in the docs that the order of execution is not knowable.</p>
<p>For completenessâ€™ sake, there are also <code class="sourceCode scala"><span class="fu">flatMap</span>()</code>s for the Deque, implemented in a similar fashion to the functions above:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb41-1" data-line-number="1">extension Deque {</a>
<a class="sourceLine" id="cb41-2" data-line-number="2">  public func flatMap&lt;T&gt;(@noescape transform: Element -&gt; Deque&lt;T&gt;) -&gt; Deque&lt;T&gt; {</a>
<a class="sourceLine" id="cb41-3" data-line-number="3">    <span class="kw">return</span> Deque&lt;T&gt;(</a>
<a class="sourceLine" id="cb41-4" data-line-number="4">      front.<span class="fu">flatMap</span>{List(<span class="fu">transform</span>($<span class="dv">0</span>))},</a>
<a class="sourceLine" id="cb41-5" data-line-number="5">      back .<span class="fu">flatMap</span>{List(<span class="fu">transform</span>($<span class="dv">0</span>).<span class="fu">reverse</span>())}</a>
<a class="sourceLine" id="cb41-6" data-line-number="6">    )</a>
<a class="sourceLine" id="cb41-7" data-line-number="7">  }</a>
<a class="sourceLine" id="cb41-8" data-line-number="8"></a>
<a class="sourceLine" id="cb41-9" data-line-number="9">  public func flatMap&lt;T&gt;(@noescape transform: Element -&gt; T?) -&gt; Deque&lt;T&gt; {</a>
<a class="sourceLine" id="cb41-10" data-line-number="10">    <span class="kw">return</span> Deque&lt;T&gt;(</a>
<a class="sourceLine" id="cb41-11" data-line-number="11">      front.<span class="fu">flatMap</span>(transform),</a>
<a class="sourceLine" id="cb41-12" data-line-number="12">      back .<span class="fu">flatMap</span>(transform)</a>
<a class="sourceLine" id="cb41-13" data-line-number="13">    )</a>
<a class="sourceLine" id="cb41-14" data-line-number="14">  }</a>
<a class="sourceLine" id="cb41-15" data-line-number="15">}</a></code></pre></div>
<p>All of this code is available as a playground, <a href="https://github.com/oisdk/Deques-Queues-and-Lists-in-Swift-with-indirect">here</a>. These two structs are also implemented a little more fully in <a href="https://github.com/oisdk/SwiftSequence">SwiftSequence</a>.</p>
<p>Since the only real constitutive part of the Deque is a list, itâ€™s probably possible to implement it lazily, by just substituting in <code class="sourceCode scala">LazyList</code>s. Or, if you were feeling adventurous, you could have one of the lists lazy, and one strict. This isnâ€™t as crazy as it sounds: <code class="sourceCode scala"><span class="fu">reverse</span>()</code> can <em>only</em> be performed eagerly, since the entire list needs to be walked to get to the last element. So the front and back lists have different functions (slightly). Also, because of the lazy initialisation of <code class="sourceCode scala">LazyList</code>, swapping between lazy and strict neednâ€™t be very expensive. Iâ€™ll leave it up to someone else to try, though.</p>
]]></description>
    <pubDate>Wed, 29 Jul 2015 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2015-07-29-swift-queues.html</guid>
    <dc:creator>Donnacha OisÃ­n Kidney</dc:creator>
</item>
<item>
    <title>A Strategy for Swift Protocols</title>
    <link>https://doisinkidney.com/posts/2015-07-17-swift-protocols-a-strategy.html</link>
    <description><![CDATA[<div class="info">
    Posted on July 17, 2015
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Swift.html">Swift</a>
    
</div>

<h3 id="a-misguided-over-simplified-strategy">A Misguided, Over-Simplified Strategy</h3>
<h1 id="it-makes-sense-to-me-so">It Makes Sense to Me, soâ€¦</h1>
<p>So Iâ€™ve been drinking the Protocol-Oriented-Programming gatorade for a while now. Iâ€™ve taken it to the extreme a little: you wonâ€™t find a class in pretty much any of my code these days. So, before I pull it back a little, I thought Iâ€™d put down my strategy so far for how to handle these protocol things.</p>
<p>To give you an idea of where Iâ€™m coming from: I never really understood object-oriented programming. It never clicked with me. I mean, I know the basic ideas, but they were never internalised. On the other hand, functional programmingÂ was a breeze (by comparison). I should be clear: by FP I donâ€™t really meanÂ monads or functors or applicative functors and monoids and commands and arrows and lenses and flux capacitors. I think everyone has a relatively difficult time wrapping their heads around that stuff.</p>
<p>I mean theÂ <em>patterns</em> you see in FP. Pure functions - of course - but other things, also. Things that arenâ€™t strictly FP, but just tend to be found among the FP: type classes, currying, immutability, declarative-ness, laziness, higher-order functions. Contrast that to the patterns you find in OOP: the delegate pattern, class inheritance, single-dependancy whatnot (I canâ€™t even name them because Iâ€™m sure Iâ€™m mixing up and misunderstanding them).</p>
<p>Now, there are probably good reasons why I understand FP a little easier than OOP (or I think I do). OOP was what I saw first: when I began coding, it was in OOP. By the time I tried to understand, say, higher-order functions, I had already gotten my head around functions, types, variables, etc. Whereas when I first read â€œPython is anÂ <em>object-oriented</em> programming languageâ€, I had written my first hello world a few weeks before.</p>
<p>On top of that, Iâ€™m a hobbyist - I donâ€™t like making things that really work, because thatâ€™s annoying. I amÂ <em>very good</em> at finding you Fibonacci numbers. I donâ€™t need to know about state, or IO, so Iâ€™m perfectly fine in the clean, pleasant world of FP (or semi-FP).</p>
<p>So what about protocols, then? Well, now that you know what kind of person youâ€™re listening to, it might make sense when I say this: protocols areÂ <em>awesome</em>. They makeÂ <em>so much</em> sense. I canâ€™t believe we were ever doing things any other way.</p>
<p>Are protocols FP? Kind of. The first implementation of something protocol-like was probably in Haskell, with type classes. But OOP had a very similar system soon after, in the form of generics. And Dave Abrahams, who works on Swift, was the main guy for templates in C++ for a long time.Â Theyâ€™re not FP in the traditional sense, but theyÂ <em>are</em>Â FP in the sense that I understand it: theyâ€™re a certain kind of style/technique. And they fit right in with the rest of the styles and techniques of FP.</p>
<h1 id="how-to-do-it">How to do it</h1>
<p>Anyway, I should get to my strategy for using them. Hereâ€™s my ridiculously oversimplified (mis)understanding of how you should see them: protocols describeÂ <em>abilities</em> andÂ <em>talents</em>. God thatâ€™s pretentious. Lemme try again: a protocol represents something a typeÂ <em>can</em>Â do, andÂ <em>how well</em> it can do it. Thatâ€™s a bit better.</p>
<p>Letâ€™s look to the standard library for our examples here. Say you want to make a method that emulates Pythonâ€™s slicing, where you can hop over elements of a sequence. Something like:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb1-1" data-line-number="1">public extension SequenceType {</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  func <span class="fu">hop</span>(n: Int) -&gt; [Generator.<span class="fu">Element</span>] {</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">    <span class="kw">var</span> i = n - <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">    <span class="kw">return</span> self.<span class="fu">filter</span> {</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">      _ -&gt; Bool in</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">      <span class="kw">if</span> ++i == n {</a>
<a class="sourceLine" id="cb1-7" data-line-number="7">        i = <span class="dv">0</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">        <span class="kw">return</span> <span class="kw">true</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9">      } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb1-10" data-line-number="10">        <span class="kw">return</span> <span class="kw">false</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11">      }</a>
<a class="sourceLine" id="cb1-12" data-line-number="12">    }</a>
<a class="sourceLine" id="cb1-13" data-line-number="13">  }</a>
<a class="sourceLine" id="cb1-14" data-line-number="14">}</a>
<a class="sourceLine" id="cb1-15" data-line-number="15">[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>].<span class="fu">hop</span>(<span class="dv">2</span>) <span class="co">// [1, 3, 5]</span></a></code></pre></div>
<p>Weâ€™re in protocol-land right away: <code class="sourceCode scala">SequenceType</code>. This is an â€œabilityâ€. The method exists on everything with theÂ <em>ability</em> to act like a sequence. That means arrays, sets, dictionaries, strings. Actually, a better example of the â€œabilityâ€ would be this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb2-1" data-line-number="1">extension IntegerArithmeticType {</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  func <span class="dt">double</span>() -&gt; Self {</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">    <span class="kw">return</span> self + self</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">  }</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">}</a>
<a class="sourceLine" id="cb2-6" data-line-number="6"></a>
<a class="sourceLine" id="cb2-7" data-line-number="7"><span class="fl">2.</span><span class="dt">double</span>() <span class="co">// 4</span></a></code></pre></div>
<p>Goodness gracious thatâ€™s contrived. But anyway, you get the idea. Anything that can do integer arithmetic gets that method.</p>
<p>Now, back to the hop method. Maybe itâ€™s very expensive to actually retrieve every intermediate element and then discard it - thatâ€™s what filter is doing, after all. Why not just do an index lookup?</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb3-1" data-line-number="1">public extension CollectionType {</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  func <span class="fu">hop</span>(n: Index.<span class="fu">Distance</span>) -&gt; [Generator.<span class="fu">Element</span>] {</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">    </a>
<a class="sourceLine" id="cb3-4" data-line-number="4">    <span class="kw">var</span> ar: [Generator.<span class="fu">Element</span>] = []</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">    </a>
<a class="sourceLine" id="cb3-6" data-line-number="6">    <span class="kw">for</span> <span class="kw">var</span> i = startIndex; </a>
<a class="sourceLine" id="cb3-7" data-line-number="7">        indices.<span class="fu">contains</span>(i); </a>
<a class="sourceLine" id="cb3-8" data-line-number="8">        i = <span class="fu">advance</span>(i, n) {</a>
<a class="sourceLine" id="cb3-9" data-line-number="9">          ar.<span class="fu">append</span>(self[i])</a>
<a class="sourceLine" id="cb3-10" data-line-number="10">    }</a>
<a class="sourceLine" id="cb3-11" data-line-number="11">    </a>
<a class="sourceLine" id="cb3-12" data-line-number="12">    <span class="kw">return</span> ar</a>
<a class="sourceLine" id="cb3-13" data-line-number="13">  }</a>
<a class="sourceLine" id="cb3-14" data-line-number="14">}</a></code></pre></div>
<p>There we go! Everything canÂ <em>do</em> the hop method, but <code class="sourceCode scala">CollectionType</code>s can do itÂ <em>well</em>. In fact, some <code class="sourceCode scala">CollectionType</code>s can do it very well indeed:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb4-1" data-line-number="1">public extension CollectionType where Index : RandomAccessIndexType {  </a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  func <span class="fu">hop</span>(n: Index.<span class="fu">Stride</span>) -&gt; [Generator.<span class="fu">Element</span>] {</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">    <span class="kw">return</span> <span class="fu">stride</span>(from: startIndex, to: endIndex, by: n).<span class="fu">map</span>{self[$<span class="dv">0</span>]}</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">  }</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">}</a></code></pre></div>
<p>You see this kind of thing all around the standard library, but most prominently with the index types. If something is able to do something, it gets the bare-bones, inefficient implementation. Then, for types with all the bells and whistles, you get the clever, blazing-fast version. And to the user, all you see is some easy-looking <code class="sourceCode scala"><span class="fu">indexOf</span>()</code> function.</p>
<p>So hereâ€™s how I think you should be doing your APIs: if at all possible, write your function as a method. Write the most bare-bones, slow version of it you possibly can that still makes sense. Then, specialise where it suits.</p>
<p>(I realise now that I may have just described a design pattern that was very obvious to everyone but me. Ah, well)</p>
<h1 id="the-why">The Why</h1>
<p>There are pretty major advantages to this. Your two other options are generally class inheritance, or global functions with generics. <a href="https://developer.apple.com/videos/wwdc/2015/?id=408">The best video from WWDC</a>Â talks about class inheritance, so Iâ€™ll stay away from that. In contrast to global functions, here are the advantages:</p>
<h2 id="more-discoverable">More discoverable</h2>
<p>Hit dot after whatever thing youâ€™re interested in, and the little list of available goodies pops up. Itâ€™s also easy to find in the documentation (what kind of methods do I have on sequences? vs.Â Right, hereâ€™s the page for the global functions, cmd-f â€œSequenceâ€â€¦ hmm, <code class="sourceCode scala">indexOf</code> isnâ€™t hereâ€¦)</p>
<h2 id="function-compositionish">Function composition(ish)</h2>
<p>We currently have this:</p>
<pre><code>g(f(x))</code></pre>
<p>Now, if we were in Haskell-land, you could write:</p>
<pre><code>(g . f) x</code></pre>
<p>But weâ€™re not. However, if f is a method on x, and g is a method on whatever if returned by f, you can have:</p>
<pre><code>x.f().g()</code></pre>
<p>Maybe a bit of a bad example, but <a href="http://airspeedvelocity.net/2015/06/23/protocol-extensions-and-the-death-of-the-pipe-forward-operator/">combine that with <code class="sourceCode scala">flatMap</code> and laziness and youâ€™ve got some handsome-looking, powerful functions right there.</a></p>
<h2 id="easy-to-build-hierarchies">Easy-to-build hierarchies</h2>
<p>I find myself often getting a bit philosophical around all of these protocols (â€œyeah, but what does itÂ <em>mean</em> to be <code class="sourceCode scala">IntegerLiteralConvertible</code>? I mean, arenâ€™t weÂ <em>all</em>Â <code class="sourceCode scala">IntegerLiteralConvertible</code>, in a way?â€, â€œWoahâ€). I see places where I can extend a previous method to things I hadnâ€™t even thought of applying it to. And with the quicklook, and the way the documentation is structured, none of this stuff becomes complicated.</p>
<p>Obviously this is a little bit of a straw man - there are some obvious cases where protocol extensions donâ€™t make a lot of sense. Having â€œdoubleâ€ as an extension on <code class="sourceCode scala">IntegerArithmeticType</code> is sheer silliness - but I think something like <code class="sourceCode scala"><span class="fu">sqrt</span>()</code> would be odd, as well. If only because it decreases readability, Iâ€™m not sure that those kinds of things are good ideas. At the end of the day, youâ€™re a reasonable, intelligent person, and you know where this stuff works. Just have it knocking around in your brain, so when you come across something that doesnâ€™t workÂ <em>quite right</em>, youâ€™ll have protocol extensions as one of your other options.</p>
<p>If you want to see an example of protocols taken to the nth degree, the examples Iâ€™ve had here are taken from my library, <a href="https://github.com/oisdk/SwiftSequence">SwiftSequence</a>.</p>
<p>If youâ€™ve kept reading this far, Iâ€™m going to Iâ€™m going to really test your patience with this next bit:</p>
<h1 id="what-do-i-want">What do I want?</h1>
<h2 id="beef-up-some-of-the-meta-language">Beef up some of the meta-language</h2>
<p>You know the tiny little meta-language for protocol extensions? The one that exists between the angle brackets, after the where?</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb8-1" data-line-number="1"></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">extension SomeProtocol <span class="fu">where</span> (This bit) {...</a>
<a class="sourceLine" id="cb8-3" data-line-number="3"></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">func f&lt;T : SomeProtocol <span class="fu">where</span> (This bit, also)...</a></code></pre></div>
<p>That needs to get more powerful. Swift is big on doing loads of stuff at compile-time, and that little meta-language is effectively a script that runs as your code compiles. When itâ€™s between the angle brackets itâ€™s ugly, and it seems like too small a place for a lot of code, but if you start doing anything complex with it, you hit its limits quickly. Say you want to write a recursive function that works with slices. This is the absolute minimum in the angle brackets you need:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb9-1" data-line-number="1">&lt;  </a>
<a class="sourceLine" id="cb9-2" data-line-number="2">  S : Sliceable where S.<span class="fu">SubSlice</span> : Sliceable,  </a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  S.<span class="fu">SubSlice</span>.<span class="fu">Generator</span>.<span class="fu">Element</span> == S.<span class="fu">Generator</span>.<span class="fu">Element</span>,  </a>
<a class="sourceLine" id="cb9-4" data-line-number="4">  S.<span class="fu">SubSlice</span>.<span class="fu">SubSlice</span> == S.<span class="fu">SubSlice</span>  </a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  &gt;</a></code></pre></div>
<p>And if you need anything complex, wellâ€¦</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb10-1" data-line-number="1">func bSearch&lt;</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">  S : Sliceable where S.<span class="fu">SubSlice</span> : Sliceable,</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  S.<span class="fu">SubSlice</span>.<span class="fu">Generator</span>.<span class="fu">Element</span> == S.<span class="fu">Generator</span>.<span class="fu">Element</span>,</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">  S.<span class="fu">SubSlice</span>.<span class="fu">SubSlice</span> == S.<span class="fu">SubSlice</span>,</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">  S.<span class="fu">Generator</span>.<span class="fu">Element</span> : Comparable,</a>
<a class="sourceLine" id="cb10-6" data-line-number="6">  S.<span class="fu">Index</span> : IntegerArithmeticType,</a>
<a class="sourceLine" id="cb10-7" data-line-number="7">  S.<span class="fu">Index</span> : IntegerLiteralConvertible,</a>
<a class="sourceLine" id="cb10-8" data-line-number="8">  S.<span class="fu">SubSlice</span>.<span class="fu">Index</span> == S.<span class="fu">Index</span></a>
<a class="sourceLine" id="cb10-9" data-line-number="9">  &gt;(el: S.<span class="fu">Generator</span>.<span class="fu">Element</span>, list: S) -&gt; S.<span class="fu">Generator</span>.<span class="fu">Element</span>? {</a>
<a class="sourceLine" id="cb10-10" data-line-number="10"></a>
<a class="sourceLine" id="cb10-11" data-line-number="11">    <span class="kw">if</span> list.<span class="fu">isEmpty</span> { <span class="kw">return</span> nil }</a>
<a class="sourceLine" id="cb10-12" data-line-number="12"></a>
<a class="sourceLine" id="cb10-13" data-line-number="13">    let midInd = list.<span class="fu">endIndex</span> / <span class="dv">2</span></a>
<a class="sourceLine" id="cb10-14" data-line-number="14"></a>
<a class="sourceLine" id="cb10-15" data-line-number="15">    let midEl: S.<span class="fu">Generator</span>.<span class="fu">Element</span> = list[midInd] </a>
<a class="sourceLine" id="cb10-16" data-line-number="16">    <span class="co">// type inference giving me some bugs here</span></a>
<a class="sourceLine" id="cb10-17" data-line-number="17"></a>
<a class="sourceLine" id="cb10-18" data-line-number="18">    <span class="kw">if</span> midEl == el {</a>
<a class="sourceLine" id="cb10-19" data-line-number="19">      <span class="kw">return</span> el</a>
<a class="sourceLine" id="cb10-20" data-line-number="20">    }</a>
<a class="sourceLine" id="cb10-21" data-line-number="21"></a>
<a class="sourceLine" id="cb10-22" data-line-number="22">    <span class="kw">return</span> midEl &lt; el ?</a>
<a class="sourceLine" id="cb10-23" data-line-number="23">      <span class="fu">bSearch</span>(el, list: list[midInd+<span class="dv">1</span>..&lt;list.<span class="fu">endIndex</span>]) :</a>
<a class="sourceLine" id="cb10-24" data-line-number="24">      <span class="fu">bSearch</span>(el, list: list[<span class="dv">0</span>..&lt;midInd])</a>
<a class="sourceLine" id="cb10-25" data-line-number="25">}</a></code></pre></div>
<p>Yeah. And itâ€™s only going to get more and more complex: with every new beta, more functions become methods. This protocol business is going to cause more and more function signatures to end up looking like that. With that in mind, two things, in particular, need to go into the meta-language:</p>
<ul>
<li><p>A way to summarise all of those protocols into one. Like, I should be able to declare a protocol thatâ€™s just other protocols put together:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb11-1" data-line-number="1">protocol RecursiveSliceable:</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">  Sliceable where SubSlice : Sliceable,</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  SubSlice.<span class="fu">Generator</span>.<span class="fu">Element</span> == Generator.<span class="fu">Element</span>,</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">  SubSlice.<span class="fu">SubSlice</span> == SubSlice</a>
<a class="sourceLine" id="cb11-5" data-line-number="5"></a>
<a class="sourceLine" id="cb11-6" data-line-number="6">protocol RecursiveSliceableIntegerIndices:</a>
<a class="sourceLine" id="cb11-7" data-line-number="7">  RecursiveSliceable where</a>
<a class="sourceLine" id="cb11-8" data-line-number="8">  Index : IntegerArithmeticType,</a>
<a class="sourceLine" id="cb11-9" data-line-number="9">  Index : IntegerLiteralConvertible,</a>
<a class="sourceLine" id="cb11-10" data-line-number="10">  SubSlice.<span class="fu">Index</span> == Index</a>
<a class="sourceLine" id="cb11-11" data-line-number="11"></a>
<a class="sourceLine" id="cb11-12" data-line-number="12">func bSearch&lt;</a>
<a class="sourceLine" id="cb11-13" data-line-number="13">  S : RecursiveSliceableIntegerIndices where</a>
<a class="sourceLine" id="cb11-14" data-line-number="14">  S.<span class="fu">Generator</span>.<span class="fu">Element</span> : Comparable</a>
<a class="sourceLine" id="cb11-15" data-line-number="15">  &gt;(seq: S)...</a></code></pre></div></li>
<li><p>Support for expressions, statements and whatnot, all of which get evaluated at compile-time.</p></li>
</ul>
<h2 id="more-pop-in-the-standard-library">More POP in the Standard Library</h2>
<p>The standard library, at the moment, still has not fully crossed over to the protocol way of doing things. Itâ€™s probably more to do with resource pressure than anything else, but Iâ€™m worried that some areas may not get the full protocol treatment. Iâ€™m talking about sequences. Currently, there are structsÂ like <code class="sourceCode scala">AnySequence</code>, which represent the old, dark days of Swift 1.2. In itsÂ description:</p>
<blockquote>
<p>A type-erased sequence.</p>
</blockquote>
<blockquote>
<p>Forwards operations to an arbitrary underlying sequence having the sameÂ <code>Element</code>Â type, hiding the specifics of the underlyingÂ <code class="sourceCode scala">SequenceType</code>.</p>
</blockquote>
<p>Thatâ€™s no good. You shouldnâ€™t have to erase types - your methods and functions should act on <code class="sourceCode scala">SequenceType</code>, regardless of which <code class="sourceCode scala">SequenceType</code> it is. Iâ€™m not suggesting you should get rid of that struct - itâ€™s trivial to come up with cases where itâ€™s needed - Iâ€™m saying you shouldnâ€™t be using it if you donâ€™t have to. And in one particular area of the Swift standard library, they use structs where (I feel) they should be using protocols: <code class="sourceCode scala">LazySequence</code>. Itâ€™s a wrapper struct, mainly used for functional-style methods like <code class="sourceCode scala">map</code> and <code class="sourceCode scala">filter</code> that can act lazily.Â <em>Why isnâ€™t it a protocol</em>?! Currently, the lazy versions of <code class="sourceCode scala">map</code> and <code class="sourceCode scala">filter</code> are defined as methods on <code class="sourceCode scala">LazySequence</code>. What they return is a <code class="sourceCode scala">MapSequenceView</code> <em>wrapped</em> in <code class="sourceCode scala">LazySequence</code>. That way, you can chain map and filter, keeping things lazy. But why not make <code class="sourceCode scala">LazySequenceType</code> a protocol, and have <code class="sourceCode scala">MapSequenceView</code> conform to it? Thereâ€™s more - <code class="sourceCode scala">LazyRandomAccessCollection</code>, <code class="sourceCode scala">LazyForwardCollection</code>, etc.Â <em>These should all be protocols</em>. Itâ€™s a nightmare to try and deal with these things: if you want to write a lazy method on a sequence, you have to write one for <code class="sourceCode scala">LazySequence</code>, then one for <code class="sourceCode scala">LazyForwardCollection</code>, and so on. It would be so much easier to have.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb12-1" data-line-number="1">extension LazySequenceType where </a>
<a class="sourceLine" id="cb12-2" data-line-number="2">  Self: CollectionType, </a>
<a class="sourceLine" id="cb12-3" data-line-number="3">  Index: RandomAccessIndexType</a></code></pre></div>
<p>I really donâ€™t know why itâ€™s not this way. Again, the Swift team may wellÂ <em>want</em> to do it, but just hasnâ€™t got round to it. I hope so. A very optimistic voice in my mindÂ does keep whispering, though: â€œ<em>theyâ€™re just waiting for recursive enums, so they can introduce lazy listsâ€¦ theyâ€™ve been working on a whole load of lazy sequence functionsâ€¦ pattern matchingâ€¦ unconsâ€¦</em>â€</p>
]]></description>
    <pubDate>Fri, 17 Jul 2015 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2015-07-17-swift-protocols-a-strategy.html</guid>
    <dc:creator>Donnacha OisÃ­n Kidney</dc:creator>
</item>

    </channel>
</rss>
