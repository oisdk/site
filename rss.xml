<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>Donnacha Ois√≠n Kidney's Blog</title>
        <link>https://doisinkidney.com</link>
        <description><![CDATA[Mainly writing about programming]]></description>
        <atom:link href="https://doisinkidney.com/rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Wed, 08 May 2019 00:00:00 UT</lastBuildDate>
        <item>
    <title>Some Tricks for List Manipulation</title>
    <link>https://doisinkidney.com/posts/2019-05-08-list-manipulation-tricks.html</link>
    <description><![CDATA[<div class="info">
    Posted on May  8, 2019
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<p>This post is a collection of some of the tricks I‚Äôve learned for manipulating lists in Haskell. Each one starts with a puzzle: you should try the puzzle yourself before seeing the solution!</p>
<h1 id="the-tortoise-and-the-hare">The Tortoise and the Hare</h1>
<blockquote>
<p>How can you split a list in half, in one pass, without taking its length?</p>
</blockquote>
<p>This first one is a relatively well-known trick, but it occasionally comes in handy, so I thought I‚Äôd mention it. The naive way is as follows:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1">splitHalf xs <span class="fu">=</span> splitAt (length xs <span class="ot">`div`</span> <span class="dv">2</span>) xs</a></code></pre></div>
<p>But it‚Äôs unsatisfying: we have to traverse the list twice, and we‚Äôre taking its length (which is almost always a bad idea). Instead, we use the following function:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">splitHalf ::</span> [a] <span class="ot">-&gt;</span> ([a],[a])</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">splitHalf xs <span class="fu">=</span> go xs xs</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">    go (y<span class="fu">:</span>ys) (_<span class="fu">:</span>_<span class="fu">:</span>zs) <span class="fu">=</span> first (y<span class="fu">:</span>) (go ys zs)</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">    go ys _ <span class="fu">=</span> ([],ys)</a></code></pre></div>
<p>The ‚Äútortoise and the hare‚Äù is the two arguments to <code>go</code>: it traverses the second one twice as fast, so when it hits the end, we know that the first list must be halfway done.</p>
<h1 id="there-and-back-again">There and Back Again</h1>
<blockquote>
<p>Given two lists, <code>xs</code> and <code>ys</code>, write a function which zips <code>xs</code> with the <em>reverse</em> of <code>ys</code> (in one pass).</p>
</blockquote>
<p>There‚Äôs a lovely paper <span class="citation" data-cites="danvy_there_2005">(Danvy and Goldberg <a href="#ref-danvy_there_2005">2005</a>)</span> which goes though a number of tricks for how to do certain list manipulations ‚Äúin reverse‚Äù. Their technique is known as ‚Äúthere and back again‚Äù. However, I‚Äôd like to describe a different way to get to the same technique, using folds.</p>
<p>Whenever I need to do some list manipulation in reverse (i.e., I need the input list to be reversed), I first see if I can rewrite the function as a fold, and then just switch out <code>foldr</code> for <code>foldl</code>.</p>
<p>For our puzzle here, we need to first write <code>zip</code> as a fold:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1">zip<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a,b)]</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">zip <span class="fu">=</span> foldr f b</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">    f x k (y<span class="fu">:</span>ys) <span class="fu">=</span> (x,y) <span class="fu">:</span> k ys</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">    f x k [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">    b _ <span class="fu">=</span> []</a></code></pre></div>
<p>If that looks complex, or difficult to write, don‚Äôt worry! There‚Äôs a systematic way to get to the above definition from the normal version of <code>zip</code>. First, let‚Äôs start with a normal <code>zip</code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">zip<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a,b)]</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">zip [] ys <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">zip xs [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">zip (x<span class="fu">:</span>xs) (y<span class="fu">:</span>ys) <span class="fu">=</span> (x,y) <span class="fu">:</span> zip xs ys</a></code></pre></div>
<p>Then, we need to turn it into a case-tree, where the first branch is on the list we want to fold over. In other words, we want the function to look like this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1">zip xs <span class="fu">=</span> <span class="kw">case</span> xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">  <span class="fu">???</span></a></code></pre></div>
<p>To figure out the cases, we factor out the cases in the original function. Since the second clause (<code>zip xs [] = []</code>) is only reachable when <code>xs /= []</code>, it‚Äôs effectively a case for the <code>x:xs</code> branch.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1">zip<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a,b)]</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">zip xs <span class="fu">=</span> <span class="kw">case</span> xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">    [] <span class="ot">-&gt;</span> \_ <span class="ot">-&gt;</span> []</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">    x<span class="fu">:</span>xs <span class="ot">-&gt;</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">        [] <span class="ot">-&gt;</span> []</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">        y<span class="fu">:</span>ys <span class="ot">-&gt;</span> (x,y) <span class="fu">:</span> zip xs ys</a></code></pre></div>
<p>Now, we rewrite the different cases to be auxiliary functions:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1">zip<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a,b)]</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">zip xs <span class="fu">=</span> <span class="kw">case</span> xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">    [] <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">    x<span class="fu">:</span>xs <span class="ot">-&gt;</span> f x xs</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6">    b <span class="fu">=</span> \_ <span class="ot">-&gt;</span> []</a>
<a class="sourceLine" id="cb7-7" data-line-number="7">    f <span class="fu">=</span> \x xs <span class="ot">-&gt;</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb7-8" data-line-number="8">        [] <span class="ot">-&gt;</span> []</a>
<a class="sourceLine" id="cb7-9" data-line-number="9">        y<span class="fu">:</span>ys <span class="ot">-&gt;</span> (x,y) <span class="fu">:</span> zip xs ys</a></code></pre></div>
<p>And finally, we <em>refactor</em> the recursive call to the first case expression.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">zip<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a,b)]</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">zip xs <span class="fu">=</span> <span class="kw">case</span> xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">    [] <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">    x<span class="fu">:</span>xs <span class="ot">-&gt;</span> f x (zip xs)</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">    b <span class="fu">=</span> \_ <span class="ot">-&gt;</span> []</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">    f <span class="fu">=</span> \x xs <span class="ot">-&gt;</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8">        [] <span class="ot">-&gt;</span> []</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">        y<span class="fu">:</span>ys <span class="ot">-&gt;</span> (x,y) <span class="fu">:</span> xs ys</a></code></pre></div>
<p>Then those two auxiliary functions are what you pass to <code>foldr</code>!</p>
<p>So, to reverse it, we simply take wherever we wrote <code>foldr f b</code>, and replace it with <code>foldl (flip f) b</code>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">zipRev ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a,b)]</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">zipRev <span class="fu">=</span> foldl (flip f) b</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4">    f x k (y<span class="fu">:</span>ys) <span class="fu">=</span> (x,y) <span class="fu">:</span> k ys</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">    f x k [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb9-6" data-line-number="6">    b _ <span class="fu">=</span> []</a></code></pre></div>
<p>Of course, we‚Äôre reversing the wrong list here. Fixing that is simple:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">zipRev ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a,b)]</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">zipRev <span class="fu">=</span> flip (foldl (flip f) b)</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4">    f y k (x<span class="fu">:</span>xs) <span class="fu">=</span> (x,y) <span class="fu">:</span> k xs</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">    f y k [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb10-6" data-line-number="6">    b _ <span class="fu">=</span> []</a></code></pre></div>
<h1 id="maintaining-laziness">Maintaining Laziness</h1>
<blockquote>
<p>Rewrite the above function without using continuations.</p>
</blockquote>
<p><code>zipRev</code>, as written above, actually uses <em>continuation-passing style</em>. In most languages (including standard ML, which was the one used in <span class="citation" data-cites="danvy_there_2005">Danvy and Goldberg (<a href="#ref-danvy_there_2005">2005</a>)</span>), this is pretty much equivalent to a direct-style implementation (modulo some performance weirdness). In a lazy language like Haskell, though, continuation-passing style often makes things unnecessarily strict.</p>
<p>Consider the church-encoded pairs:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Pair</span> a b</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Pair</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">    {<span class="ot"> runPair ::</span> forall c<span class="fu">.</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> c</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">    }</a>
<a class="sourceLine" id="cb11-5" data-line-number="5">    </a>
<a class="sourceLine" id="cb11-6" data-line-number="6"><span class="ot">firstC ::</span> (a <span class="ot">-&gt;</span> a&#39;) <span class="ot">-&gt;</span> <span class="dt">Pair</span> a b <span class="ot">-&gt;</span> <span class="dt">Pair</span> a&#39; b</a>
<a class="sourceLine" id="cb11-7" data-line-number="7">firstC f p <span class="fu">=</span> <span class="dt">Pair</span> (\k <span class="ot">-&gt;</span> runPair p (k <span class="fu">.</span> f))</a>
<a class="sourceLine" id="cb11-8" data-line-number="8"></a>
<a class="sourceLine" id="cb11-9" data-line-number="9"><span class="ot">firstD ::</span> (a <span class="ot">-&gt;</span> a&#39;) <span class="ot">-&gt;</span> (a, b) <span class="ot">-&gt;</span> (a&#39;, b)</a>
<a class="sourceLine" id="cb11-10" data-line-number="10">firstD f <span class="fu">~</span>(x,y) <span class="fu">=</span> (f x, y)</a>
<a class="sourceLine" id="cb11-11" data-line-number="11"></a>
<a class="sourceLine" id="cb11-12" data-line-number="12"><span class="ot">fstD ::</span> (a, b) <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb11-13" data-line-number="13">fstD <span class="fu">~</span>(x,y) <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb11-14" data-line-number="14"></a>
<a class="sourceLine" id="cb11-15" data-line-number="15"><span class="ot">fstC ::</span> <span class="dt">Pair</span> a b <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb11-16" data-line-number="16">fstC p <span class="fu">=</span> runPair p const</a>
<a class="sourceLine" id="cb11-17" data-line-number="17"></a>
<a class="sourceLine" id="cb11-18" data-line-number="18"><span class="fu">&gt;&gt;&gt;</span> fstC (firstC (const ()) undefined)</a>
<a class="sourceLine" id="cb11-19" data-line-number="19">undefined</a>
<a class="sourceLine" id="cb11-20" data-line-number="20"></a>
<a class="sourceLine" id="cb11-21" data-line-number="21"><span class="fu">&gt;&gt;&gt;</span> fstD (firstD (const ()) undefined)</a>
<a class="sourceLine" id="cb11-22" data-line-number="22">()</a></code></pre></div>
<p>So it‚Äôs sometimes worth trying to avoid continuations if there is a fast direct-style solution. (alternatively, continuations can give you extra strictness when you <em>do</em> want it)</p>
<p>First, I‚Äôm going to write a different version of <code>zipRev</code>, which folds on the first list, not the second.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1">zipRev xs ys <span class="fu">=</span> foldl f (\_ r <span class="ot">-&gt;</span> r) xs ys []</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">    f k x (y<span class="fu">:</span>ys) r <span class="fu">=</span> k ys ((x,y)<span class="fu">:</span>r)</a></code></pre></div>
<p>Then, we inline the definition of <code>foldl</code>:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1">zipRev xs ys <span class="fu">=</span> foldr f id xs (\_ r <span class="ot">-&gt;</span> r) ys []</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">    f x k c <span class="fu">=</span> k (\(y<span class="fu">:</span>ys) r <span class="ot">-&gt;</span> c ys ((x,y)<span class="fu">:</span>r)) </a></code></pre></div>
<p>Then, as a hint, we tuple up the two accumulating parameters:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1">zipRev xs ys <span class="fu">=</span> foldr f id xs snd (ys,[])</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3">    f x k c <span class="fu">=</span> k (\((y<span class="fu">:</span>ys),r) <span class="ot">-&gt;</span> c (ys,(x,y)<span class="fu">:</span>r)) </a></code></pre></div>
<p>What we can see here is that we have two continuations stacked on top of each other. When this happens, they can often ‚Äúcancel out‚Äù, like so:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1">zipRev xs ys <span class="fu">=</span> snd (foldr f (ys,[]) xs)</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-3" data-line-number="3">    f x (y<span class="fu">:</span>ys,r) <span class="fu">=</span> (ys,(x,y)<span class="fu">:</span>r)</a></code></pre></div>
<p>And we have our direct-style implementation!</p>
<h1 id="manual-fusion">Manual Fusion</h1>
<blockquote>
<p>Detect that a list is a palindrome, in one pass.</p>
</blockquote>
<p>We now know a good way to split a list in two, and a good way to zip a list with its reverse. We can <em>combine</em> the two to get a program that checks if a list is a palindrome. Here‚Äôs a first attempt:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1">isPal xs <span class="fu">=</span> all (uncurry (<span class="fu">==</span>)) (uncurry zipRev (splitHalf xs))</a></code></pre></div>
<p>But this is doing <em>three</em> passes!</p>
<p>To get around it, we can manually do some fusion. Fusion is a technique where we can spot scenarios like the following:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1">foldr f b (x <span class="fu">:</span> y <span class="fu">:</span> [])</a></code></pre></div>
<p>And translate them into a version without a list:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1">x <span class="ot">`f`</span> (y <span class="ot">`f`</span> b)</a></code></pre></div>
<p>The trick is making sure that the consumer is written as a fold, and then we just put its <code>f</code> and <code>b</code> in place of the <code>:</code> and <code>[]</code> in the producer.</p>
<p>So, when we inline the definition of <code>splitHalf</code> into <code>zipRev</code>, we get the following:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="ot">zipRevHalf ::</span> [a] <span class="ot">-&gt;</span> [(a,a)]</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">zipRevHalf xs <span class="fu">=</span> snd (go xs xs)</a>
<a class="sourceLine" id="cb19-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-4" data-line-number="4">    go (y<span class="fu">:</span>ys) (_<span class="fu">:</span>_<span class="fu">:</span>zs) <span class="fu">=</span> f y (go ys zs)</a>
<a class="sourceLine" id="cb19-5" data-line-number="5">    go (_<span class="fu">:</span>ys) [_]      <span class="fu">=</span> (ys,[])</a>
<a class="sourceLine" id="cb19-6" data-line-number="6">    go ys []           <span class="fu">=</span> (ys,[])</a>
<a class="sourceLine" id="cb19-7" data-line-number="7"></a>
<a class="sourceLine" id="cb19-8" data-line-number="8">    f x (y<span class="fu">:</span>ys,r) <span class="fu">=</span> (ys,(x,y)<span class="fu">:</span>r)</a>
<a class="sourceLine" id="cb19-9" data-line-number="9"></a>
<a class="sourceLine" id="cb19-10" data-line-number="10">isPal xs <span class="fu">=</span> all (uncurry (<span class="fu">==</span>)) (zipRevHalf xs)</a></code></pre></div>
<p>(adding a special case for odd-length lists)</p>
<p>Finally, the <code>all (uncurry (==))</code> is implemented as a fold also. So we can fuse it with the rest of the definitions:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="ot">isPal ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2">isPal xs <span class="fu">=</span> snd (go xs xs)</a>
<a class="sourceLine" id="cb20-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-4" data-line-number="4">    go (y<span class="fu">:</span>ys) (_<span class="fu">:</span>_<span class="fu">:</span>zs) <span class="fu">=</span> f y (go ys zs)</a>
<a class="sourceLine" id="cb20-5" data-line-number="5">    go (_<span class="fu">:</span>ys) [_]      <span class="fu">=</span> (ys,<span class="dt">True</span>)</a>
<a class="sourceLine" id="cb20-6" data-line-number="6">    go ys     []       <span class="fu">=</span> (ys,<span class="dt">True</span>)</a>
<a class="sourceLine" id="cb20-7" data-line-number="7">    </a>
<a class="sourceLine" id="cb20-8" data-line-number="8">    f x (y<span class="fu">:</span>ys,r) <span class="fu">=</span> (ys,(x <span class="fu">==</span> y) <span class="fu">&amp;&amp;</span> r)</a></code></pre></div>
<p>You may have spotted the writer monad over <code>All</code> there. Indeed, we can rewrite it to use the monadic bind:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="ot">isPal ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb21-2" data-line-number="2">isPal xs <span class="fu">=</span> getAll (fst (go xs xs)) <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-3" data-line-number="3">  go (y<span class="fu">:</span>ys) (_<span class="fu">:</span>_<span class="fu">:</span>zs) <span class="fu">=</span> f y <span class="fu">=&lt;&lt;</span> go ys zs</a>
<a class="sourceLine" id="cb21-4" data-line-number="4">  go (_<span class="fu">:</span>ys) [_]      <span class="fu">=</span> pure ys</a>
<a class="sourceLine" id="cb21-5" data-line-number="5">  go ys     []       <span class="fu">=</span> pure ys</a>
<a class="sourceLine" id="cb21-6" data-line-number="6">  </a>
<a class="sourceLine" id="cb21-7" data-line-number="7">  f y (z<span class="fu">:</span>zs) <span class="fu">=</span> (<span class="dt">All</span> (y <span class="fu">==</span> z), zs)</a></code></pre></div>
<h1 id="eliminating-multiple-passes-with-laziness">Eliminating Multiple Passes with Laziness</h1>
<blockquote>
<p>Construct a Braun tree from a list in linear time.</p>
</blockquote>
<p>This is also a very well-known trick <span class="citation" data-cites="bird_using_1984">(Bird <a href="#ref-bird_using_1984">1984</a>)</span>, but today I‚Äôm going to use it to write a function for constructing Braun trees.</p>
<p>A Braun tree is a peculiar structure. It‚Äôs a binary tree, where adjacent branches can differ in size by only 1. When used as an array, it has <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math> lookup times. It‚Äôs enumerated like so:</p>
<pre><code>     ‚îå‚îÄ7
   ‚îå3‚î§
   ‚îÇ ‚îî11
 ‚îå1‚î§
 ‚îÇ ‚îÇ ‚îå‚îÄ9
 ‚îÇ ‚îî5‚î§
 ‚îÇ   ‚îî13
0‚î§
 ‚îÇ   ‚îå‚îÄ8
 ‚îÇ ‚îå4‚î§
 ‚îÇ ‚îÇ ‚îî12
 ‚îî2‚î§
   ‚îÇ ‚îå10
   ‚îî6‚î§
     ‚îî14</code></pre>
<p>The objective is to construct a tree from a list in linear time, in the order defined above. <span class="citation" data-cites="okasaki_three_1997">Okasaki (<a href="#ref-okasaki_three_1997">1997</a>)</span> observed that, from the list:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1">[<span class="dv">0</span><span class="fu">..</span><span class="dv">14</span>]</a></code></pre></div>
<p>Each level in the tree is constructed from chucks of powers of two. In other words:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1">[[<span class="dv">0</span>],[<span class="dv">1</span>,<span class="dv">2</span>],[<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>],[<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>,<span class="dv">11</span>,<span class="dv">12</span>,<span class="dv">13</span>,<span class="dv">14</span>]]</a></code></pre></div>
<p>From this, we can write the following function:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1">rows k [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb25-2" data-line-number="2">rows k xs <span class="fu">=</span> (k , take k xs) <span class="fu">:</span> rows (<span class="dv">2</span><span class="fu">*</span>k) (drop k xs)</a>
<a class="sourceLine" id="cb25-3" data-line-number="3"></a>
<a class="sourceLine" id="cb25-4" data-line-number="4">build (k,xs) ts <span class="fu">=</span> zipWith3 <span class="dt">Node</span> xs ts1 ts2</a>
<a class="sourceLine" id="cb25-5" data-line-number="5">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-6" data-line-number="6">    (ts1,ts2) <span class="fu">=</span> splitAt k (ts <span class="fu">++</span> repeat <span class="dt">Leaf</span>)</a>
<a class="sourceLine" id="cb25-7" data-line-number="7">    </a>
<a class="sourceLine" id="cb25-8" data-line-number="8">fromList <span class="fu">=</span> head <span class="fu">.</span> foldr build [<span class="dt">Leaf</span>] <span class="fu">.</span> rows <span class="dv">1</span></a></code></pre></div>
<p>The first place we‚Äôll look to eliminate a pass is the <code>build</code> function. It combines two rows by splitting the second in half, and zipping it with the first.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> build (<span class="dv">3</span>, [x1,x2,x3]) [y1,y2,y3,y4,y5,y6]</a>
<a class="sourceLine" id="cb26-2" data-line-number="2">[(x1,y1,y4),(x2,y2,y5),(x3,y3,y6)]</a></code></pre></div>
<p>We don‚Äôt need to store the length of the first list, though, as we are only using it to split the second, and we can do <em>that</em> at the same time as the zipping.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="ot">zipUntil ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> ([c],[b])</a>
<a class="sourceLine" id="cb27-2" data-line-number="2">zipUntil _ [] ys <span class="fu">=</span> ([],ys)</a>
<a class="sourceLine" id="cb27-3" data-line-number="3">zipUntil f (x<span class="fu">:</span>xs) (y<span class="fu">:</span>ys) <span class="fu">=</span> first (f x y<span class="fu">:</span>) (zipUntil f xs ys)</a>
<a class="sourceLine" id="cb27-4" data-line-number="4"></a>
<a class="sourceLine" id="cb27-5" data-line-number="5"><span class="fu">&gt;&gt;&gt;</span> zipUntil (,) [<span class="dv">1</span>,<span class="dv">2</span>] <span class="st">&quot;abc&quot;</span></a>
<a class="sourceLine" id="cb27-6" data-line-number="6">([(<span class="dv">1</span>,<span class="ch">&#39;a&#39;</span>),(<span class="dv">2</span>,<span class="ch">&#39;b&#39;</span>)],<span class="st">&quot;c&quot;</span>)</a></code></pre></div>
<p>Using this function in <code>build</code> looks like the following:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1">build (k,xs) ts <span class="fu">=</span> zipWith (<span class="fu">$</span>) ys ts2</a>
<a class="sourceLine" id="cb28-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb28-3" data-line-number="3">    (ys,ts2) <span class="fu">=</span> zipUntil <span class="dt">Node</span> xs (ts <span class="fu">++</span> repeat <span class="dt">Leaf</span>)</a></code></pre></div>
<p>That top-level <code>zipWith</code> is <em>also</em> unnecessary, though. If we make the program circular, we can produce <code>ts2</code> as we consume it, making the whole thing single-pass.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" data-line-number="1">build xs ts <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb29-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb29-3" data-line-number="3">    (ys,ts2) <span class="fu">=</span> zip3Node xs (ts <span class="fu">++</span> repeat <span class="dt">Leaf</span>) ts2</a>
<a class="sourceLine" id="cb29-4" data-line-number="4">    zip3Node (x<span class="fu">:</span>xs) (y<span class="fu">:</span>ys) <span class="fu">~</span>(z<span class="fu">:</span>zs) <span class="fu">=</span> first (<span class="dt">Node</span> x y z<span class="fu">:</span>) (zip3Node xs ys zs) </a>
<a class="sourceLine" id="cb29-5" data-line-number="5">    zip3Node [] ys _ <span class="fu">=</span> ([], ys)</a></code></pre></div>
<p>That <code>zip3Node</code> is a good candidate for rewriting as a fold, also, making the whole thing look like this:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" data-line-number="1">rows k [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb30-2" data-line-number="2">rows k xs <span class="fu">=</span> take k xs <span class="fu">:</span> rows (<span class="dv">2</span><span class="fu">*</span>k) (drop k xs)</a>
<a class="sourceLine" id="cb30-3" data-line-number="3"></a>
<a class="sourceLine" id="cb30-4" data-line-number="4">build xs ts <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb30-5" data-line-number="5">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-6" data-line-number="6">    (ys,zs) <span class="fu">=</span> foldr f b xs ts zs</a>
<a class="sourceLine" id="cb30-7" data-line-number="7">    f x xs (y<span class="fu">:</span>ys) <span class="fu">~</span>(z<span class="fu">:</span>zs) <span class="fu">=</span> first (<span class="dt">Node</span> x y z<span class="fu">:</span>) (xs ys zs) </a>
<a class="sourceLine" id="cb30-8" data-line-number="8">    b ys _ <span class="fu">=</span> ([],ys)</a>
<a class="sourceLine" id="cb30-9" data-line-number="9">    </a>
<a class="sourceLine" id="cb30-10" data-line-number="10">fromList <span class="fu">=</span> head <span class="fu">.</span> foldr build (repeat <span class="dt">Leaf</span>) <span class="fu">.</span> rows <span class="dv">1</span></a></code></pre></div>
<p>To fuse all of those definitions, we first will need to rewrite <code>rows</code> as a fold:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" data-line-number="1">rows xs <span class="fu">=</span> uncurry (<span class="fu">:</span>) (foldr f b xs <span class="dv">1</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb31-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb31-3" data-line-number="3">    b _ _ <span class="fu">=</span> ([],[])</a>
<a class="sourceLine" id="cb31-4" data-line-number="4">    f x k <span class="dv">0</span> j <span class="fu">=</span> ([], uncurry (<span class="fu">:</span>) (f x k j (j<span class="fu">*</span><span class="dv">2</span>)))</a>
<a class="sourceLine" id="cb31-5" data-line-number="5">    f x k i j <span class="fu">=</span> first (x<span class="fu">:</span>) (k (i<span class="fu">-</span><span class="dv">1</span>) j)</a></code></pre></div>
<p>Once we have everything as a fold, the rest of the transformation is pretty mechanical. At the end of it all, we get the following linear-time function for constructing a Braun tree from a list:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" data-line-number="1"><span class="ot">fromList ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb32-2" data-line-number="2">fromList xs <span class="fu">=</span> head (l (foldr f b xs <span class="dv">1</span> <span class="dv">2</span>))</a>
<a class="sourceLine" id="cb32-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-4" data-line-number="4">    b _ _ ys zs <span class="fu">=</span> (repeat <span class="dt">Leaf</span>, (repeat <span class="dt">Leaf</span>, ys))</a>
<a class="sourceLine" id="cb32-5" data-line-number="5">    </a>
<a class="sourceLine" id="cb32-6" data-line-number="6">    l k <span class="fu">=</span> <span class="kw">let</span> (xs, ys) <span class="fu">=</span> uncurry k ys <span class="kw">in</span> xs</a>
<a class="sourceLine" id="cb32-7" data-line-number="7">    </a>
<a class="sourceLine" id="cb32-8" data-line-number="8">    f x k <span class="dv">0</span> j ys zs           <span class="fu">=</span> ([], (l (f x k j (j<span class="fu">*</span><span class="dv">2</span>)), ys))</a>
<a class="sourceLine" id="cb32-9" data-line-number="9">    f x k i j <span class="fu">~</span>(y<span class="fu">:</span>ys) <span class="fu">~</span>(z<span class="fu">:</span>zs) <span class="fu">=</span> first (<span class="dt">Node</span> x y z<span class="fu">:</span>) (k (i<span class="fu">-</span><span class="dv">1</span>) j ys zs)</a></code></pre></div>
<h1 id="references" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-bird_using_1984">
<p>Bird, R. S. 1984. ‚ÄúUsing Circular Programs to Eliminate Multiple Traversals of Data.‚Äù <em>Acta Inf.</em> 21 (3) (October): 239‚Äì250. doi:<a href="https://doi.org/10.1007/BF00264249">10.1007/BF00264249</a>. <a href="http://dx.doi.org/10.1007/BF00264249" class="uri">http://dx.doi.org/10.1007/BF00264249</a>.</p>
</div>
<div id="ref-danvy_there_2005">
<p>Danvy, Olivier, and Mayer Goldberg. 2005. ‚ÄúThere and Back Again.‚Äù <em>BRICS Report Series</em> 12 (3). doi:<a href="https://doi.org/10.7146/brics.v12i3.21869">10.7146/brics.v12i3.21869</a>. <a href="https://tidsskrift.dk/brics/article/view/21869" class="uri">https://tidsskrift.dk/brics/article/view/21869</a>.</p>
</div>
<div id="ref-okasaki_three_1997">
<p>Okasaki, Chris. 1997. ‚ÄúThree Algorithms on Braun Trees.‚Äù <em>Journal of Functional Programming</em> 7 (6) (November): 661‚Äì666. doi:<a href="https://doi.org/10.1017/S0956796897002876">10.1017/S0956796897002876</a>. <a href="https://www.eecs.northwestern.edu/~robby/courses/395-495-2013-fall/three-algorithms-on-braun-trees.pdf" class="uri">https://www.eecs.northwestern.edu/~robby/courses/395-495-2013-fall/three-algorithms-on-braun-trees.pdf</a>.</p>
</div>
</div>
]]></description>
    <pubDate>Wed, 08 May 2019 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2019-05-08-list-manipulation-tricks.html</guid>
    <dc:creator>Donnacha Ois√≠n Kidney</dc:creator>
</item>
<item>
    <title>Probability Monads in Cubical Agda</title>
    <link>https://doisinkidney.com/posts/2019-04-17-cubical-probability.html</link>
    <description><![CDATA[<div class="info">
    Posted on April 17, 2019
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Agda.html">Agda</a>, <a href="/tags/Probability.html">Probability</a>
    
</div>

<p><a href="https://agda.readthedocs.io/en/latest/language/cubical.html">Cubical Agda</a> has just come out, and I‚Äôve been playing around with it for a bit. There‚Äôs a bunch of info out there on the theory of cubical types, and Homotopy Type Theory more generally (cubical type theory is kind of like an ‚Äúimplementation‚Äù of Homotopy type theory), but I wanted to make a post demonstrating cubical Agda in practice, and one of its cool uses from a programming perspective.</p>
<h1 id="so-what-is-cubical-agda">So What is Cubical Agda?</h1>
<p>I don‚Äôt really know! Cubical type theory is quite complex (even for a type theory), and I‚Äôm not nearly qualified to properly explain it. In lieu of a proper first-principles explanation, then, I‚Äôll try and give a few examples of how it differs from normal Agda, before moving on to the main example of this post.</p>
<details>
<summary>Imports</summary>
<pre class="Agda"><a id="920" class="Symbol">{-#</a> <a id="924" class="Keyword">OPTIONS</a> <a id="932" class="Pragma">--cubical</a> <a id="942" class="Symbol">#-}</a>

<a id="947" class="Keyword">open</a> <a id="952" class="Keyword">import</a> <a id="959" href="../code/probability/ProbabilityModule.Semirings.html" class="Module">ProbabilityModule.Semirings</a>

<a id="988" class="Keyword">module</a> <a id="995" href="" class="Module">ProbabilityModule.Monad</a> <a id="1019" class="Symbol">{</a><a id="1020" href="#1020" class="Bound">s</a><a id="1021" class="Symbol">}</a> <a id="1023" class="Symbol">(</a><a id="1024" href="#1024" class="Bound">rng</a> <a id="1028" class="Symbol">:</a> <a id="1030" href="../code/probability/ProbabilityModule.Semirings.html#125" class="Record">Semiring</a> <a id="1039" href="#1020" class="Bound">s</a><a id="1040" class="Symbol">)</a> <a id="1042" class="Keyword">where</a>

<a id="1049" class="Keyword">open</a> <a id="1054" class="Keyword">import</a> <a id="1061" href="../code/probability/Cubical.Core.Everything.html" class="Module">Cubical.Core.Everything</a>
<a id="1085" class="Keyword">open</a> <a id="1090" class="Keyword">import</a> <a id="1097" href="../code/probability/Cubical.Relation.Everything.html" class="Module">Cubical.Relation.Everything</a>
<a id="1125" class="Keyword">open</a> <a id="1130" class="Keyword">import</a> <a id="1137" href="../code/probability/Cubical.Foundations.Prelude.html" class="Module">Cubical.Foundations.Prelude</a> <a id="1165" class="Keyword">hiding</a> <a id="1172" class="Symbol">(</a><a id="1173" href="../code/probability/Cubical.Foundations.Prelude.html#2539" class="Function Operator">_‚â°‚ü®_‚ü©_</a><a id="1179" class="Symbol">)</a> <a id="1181" class="Keyword">renaming</a> <a id="1190" class="Symbol">(</a><a id="1191" href="../code/probability/Cubical.Foundations.Prelude.html#1674" class="Function Operator">_‚àô_</a> <a id="1195" class="Symbol">to</a> <a id="1198" href="../code/probability/Cubical.Foundations.Prelude.html#1674" class="Function Operator">_Õæ_</a><a id="1201" class="Symbol">)</a>
<a id="1203" class="Keyword">open</a> <a id="1208" class="Keyword">import</a> <a id="1215" href="../code/probability/Cubical.HITs.SetTruncation.html" class="Module">Cubical.HITs.SetTruncation</a>
<a id="1242" class="Keyword">open</a> <a id="1247" class="Keyword">import</a> <a id="1254" href="../code/probability/ProbabilityModule.Utils.html" class="Module">ProbabilityModule.Utils</a>
</pre>
</details>
<dl>
<dt>Extensionality</dt>
<dd>One of the big annoyances in standard Agda is that we can‚Äôt prove the following:
<pre class="Agda"><a id="extensionality"></a><a id="1407" href="#1407" class="Function">extensionality</a> <a id="1422" class="Symbol">:</a> <a id="1424" class="Symbol">‚àÄ</a> <a id="1426" class="Symbol">{</a><a id="1427" href="#1427" class="Bound">f</a> <a id="1429" href="#1429" class="Bound">g</a> <a id="1431" class="Symbol">:</a> <a id="1433" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="1435" class="Symbol">‚Üí</a> <a id="1437" href="../code/probability/ProbabilityModule.Utils.html#206" class="Generalizable">B</a><a id="1438" class="Symbol">}</a>
           <a id="1455" class="Symbol">‚Üí</a> <a id="1457" class="Symbol">(‚àÄ</a> <a id="1460" href="#1460" class="Bound">x</a> <a id="1462" class="Symbol">‚Üí</a> <a id="1464" href="#1427" class="Bound">f</a> <a id="1466" href="#1460" class="Bound">x</a> <a id="1468" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">‚â°</a> <a id="1470" href="#1429" class="Bound">g</a> <a id="1472" href="#1460" class="Bound">x</a><a id="1473" class="Symbol">)</a>
           <a id="1490" class="Symbol">‚Üí</a> <a id="1492" href="#1427" class="Bound">f</a> <a id="1494" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">‚â°</a> <a id="1496" href="#1429" class="Bound">g</a>
</pre>
It‚Äôs emblematic of a wider problem in Agda: we can‚Äôt say ‚Äútwo things are equal if they always behave the same‚Äù. Infinite types, for instance (like streams) are often only equal via bisimulation: we can‚Äôt translate this into normal equality in standard Agda. Cubical type theory, though, has a different notion of ‚Äúequality‚Äù, which allow a wide variety of things (including bisimulations and extensional proofs) to be translated into a proper equality
<pre class="Agda"><a id="1989" href="#1407" class="Function">extensionality</a> <a id="2004" class="Symbol">=</a> <a id="2006" href="../code/probability/Cubical.Foundations.Prelude.html#4401" class="Function">funExt</a>
</pre>
</dd>
<dt>Isomorphisms</dt>
<dd>One of these such things we can promote to a ‚Äúproper equality‚Äù is an isomorphism. In the <a href="https://github.com/agda/cubical">cubical repo</a> this is used to <a href="https://github.com/agda/cubical/blob/8391a4835b3d2478e9394c6c3ec7e6fff42ede62/Cubical/Data/BinNat/BinNat.agda">prove things about binary numbers</a>: by proving that there‚Äôs an isomorphism between the Peano numbers and binary numbers, they can lift any properties on the Peano numbers to the binary numbers.
</dd>
</dl>
<p>So those are two useful examples, but the <em>most</em> interesting use I‚Äôve seen so far is the following:</p>
<h1 id="higher-inductive-types">Higher Inductive Types</h1>
Higher Inductive Types are an extension of normal inductive types, like the list:
<pre class="Agda"><a id="2741" class="Keyword">module</a> <a id="NormalList"></a><a id="2748" href="#2748" class="Module">NormalList</a> <a id="2759" class="Keyword">where</a>
 <a id="2766" class="Keyword">data</a> <a id="NormalList.List"></a><a id="2771" href="#2771" class="Datatype">List</a> <a id="2776" class="Symbol">{</a><a id="2777" href="#2777" class="Bound">a</a><a id="2778" class="Symbol">}</a> <a id="2780" class="Symbol">(</a><a id="2781" href="#2781" class="Bound">A</a> <a id="2783" class="Symbol">:</a> <a id="2785" class="PrimitiveType">Set</a> <a id="2789" href="#2777" class="Bound">a</a><a id="2790" class="Symbol">)</a> <a id="2792" class="Symbol">:</a> <a id="2794" class="PrimitiveType">Set</a> <a id="2798" href="#2777" class="Bound">a</a> <a id="2800" class="Keyword">where</a>
   <a id="NormalList.List.[]"></a><a id="2809" href="#2809" class="InductiveConstructor">[]</a> <a id="2812" class="Symbol">:</a> <a id="2814" href="#2771" class="Datatype">List</a> <a id="2819" href="#2781" class="Bound">A</a>
   <a id="NormalList.List._‚à∑_"></a><a id="2824" href="#2824" class="InductiveConstructor Operator">_‚à∑_</a> <a id="2828" class="Symbol">:</a> <a id="2830" href="#2781" class="Bound">A</a> <a id="2832" class="Symbol">‚Üí</a> <a id="2834" href="#2771" class="Datatype">List</a> <a id="2839" href="#2781" class="Bound">A</a> <a id="2841" class="Symbol">‚Üí</a> <a id="2843" href="#2771" class="Datatype">List</a> <a id="2848" href="#2781" class="Bound">A</a>
</pre>
<p>They allow us to add new equations to a type, as well as constructors. To demonstrate what this means, as well as why you‚Äôd want it, I‚Äôm going to talk about free objects.</p>
<p>Very informally, a free object on some algebra is the <em>minimal</em> type which satisfies the laws of the algebra. Lists, for instance, are the free monoid. They satisfy all of the monoid laws (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>‚Ä¢</mo><annotation encoding="application/x-tex">\bullet</annotation></semantics></math> is <code>++</code> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>œµ</mi><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math> is <code>[]</code>):</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>‚Ä¢</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo><mo>‚Ä¢</mo><mi>z</mi><mo>=</mo><mi>x</mi><mo>‚Ä¢</mo><mo stretchy="false" form="prefix">(</mo><mi>y</mi><mo>‚Ä¢</mo><mi>z</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(x \bullet y) \bullet z = x \bullet (y \bullet z)</annotation></semantics></math> <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>‚Ä¢</mo><mi>œµ</mi><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">x \bullet \epsilon = x</annotation></semantics></math> <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>œµ</mi><mo>‚Ä¢</mo><mi>x</mi><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">\epsilon \bullet x = x</annotation></semantics></math></p>
<p>But <em>nothing else</em>. That means they don‚Äôt satisfy any extra laws (like, for example, commutativity), and they don‚Äôt have any extra structure they don‚Äôt need.</p>
<p>How did we get to the definition of lists from the monoid laws, though? It doesn‚Äôt look anything like them. It would be nice if there was some systematic way to construct the corresponding free object given the laws of an algebra. Unfortunately, in normal Agda, this isn‚Äôt possible. Consider, for instance, if we added the commutativity law to the algebra: <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>‚Ä¢</mo><mi>y</mi><mo>=</mo><mi>y</mi><mo>‚Ä¢</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">x \bullet y = y \bullet x</annotation></semantics></math> Not only is it not obvious how we‚Äôd write the corresponding free object, it‚Äôs actually <em>not possible</em> in normal Agda!</p>
<p>This kind of problem comes up a lot: we have a type, and we want it to obey just <em>one more</em> equation, but there is no inductive type which does so. Higher Inductive Types solve the problem in quite a straightforward way. So we want lists to satisfy another equation? Well, just add it to the definition!</p>
<pre class="Agda"><a id="4347" class="Keyword">module</a> <a id="OddList"></a><a id="4354" href="#4354" class="Module">OddList</a> <a id="4362" class="Keyword">where</a>
 <a id="4369" class="Keyword">mutual</a>
  <a id="4378" class="Keyword">data</a> <a id="OddList.List"></a><a id="4383" href="#4383" class="Datatype">List</a> <a id="4388" class="Symbol">{</a><a id="4389" href="#4389" class="Bound">a</a><a id="4390" class="Symbol">}</a> <a id="4392" class="Symbol">(</a><a id="4393" href="#4393" class="Bound">A</a> <a id="4395" class="Symbol">:</a> <a id="4397" class="PrimitiveType">Set</a> <a id="4401" href="#4389" class="Bound">a</a><a id="4402" class="Symbol">)</a> <a id="4404" class="Symbol">:</a> <a id="4406" class="PrimitiveType">Set</a> <a id="4410" href="#4389" class="Bound">a</a> <a id="4412" class="Keyword">where</a>
    <a id="OddList.List.[]"></a><a id="4422" href="#4422" class="InductiveConstructor">[]</a> <a id="4425" class="Symbol">:</a> <a id="4427" href="#4383" class="Datatype">List</a> <a id="4432" href="#4393" class="Bound">A</a>
    <a id="OddList.List._‚à∑_"></a><a id="4438" href="#4438" class="InductiveConstructor Operator">_‚à∑_</a> <a id="4442" class="Symbol">:</a> <a id="4444" href="#4393" class="Bound">A</a> <a id="4446" class="Symbol">‚Üí</a> <a id="4448" href="#4383" class="Datatype">List</a> <a id="4453" href="#4393" class="Bound">A</a> <a id="4455" class="Symbol">‚Üí</a> <a id="4457" href="#4383" class="Datatype">List</a> <a id="4462" href="#4393" class="Bound">A</a>
    <a id="OddList.List.comm"></a><a id="4468" href="#4468" class="InductiveConstructor">comm</a> <a id="4473" class="Symbol">:</a> <a id="4475" class="Symbol">‚àÄ</a> <a id="4477" href="#4477" class="Bound">xs</a> <a id="4480" href="#4480" class="Bound">ys</a> <a id="4483" class="Symbol">‚Üí</a> <a id="4485" href="#4477" class="Bound">xs</a> <a id="4488" href="#4518" class="Postulate Operator">++</a> <a id="4491" href="#4480" class="Bound">ys</a> <a id="4494" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">‚â°</a> <a id="4496" href="#4480" class="Bound">ys</a> <a id="4499" href="#4518" class="Postulate Operator">++</a> <a id="4502" href="#4477" class="Bound">xs</a>

  <a id="4508" class="Keyword">postulate</a> <a id="OddList._++_"></a><a id="4518" href="#4518" class="Postulate Operator">_++_</a> <a id="4523" class="Symbol">:</a> <a id="4525" href="#4383" class="Datatype">List</a> <a id="4530" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="4532" class="Symbol">‚Üí</a> <a id="4534" href="#4383" class="Datatype">List</a> <a id="4539" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="4541" class="Symbol">‚Üí</a> <a id="4543" href="#4383" class="Datatype">List</a> <a id="4548" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a>
</pre>
Now, when we write a function that processes lists, Agda will check that the function behaves the same on <code>xs ++ ys</code> and <code>ys ++ xs</code>. As an example, here‚Äôs how you might define the free monoid as a HIT:
<pre class="Agda"><a id="4765" class="Keyword">data</a> <a id="FreeMonoid"></a><a id="4770" href="#4770" class="Datatype">FreeMonoid</a> <a id="4781" class="Symbol">{</a><a id="4782" href="#4782" class="Bound">a</a><a id="4783" class="Symbol">}</a> <a id="4785" class="Symbol">(</a><a id="4786" href="#4786" class="Bound">A</a> <a id="4788" class="Symbol">:</a> <a id="4790" class="PrimitiveType">Set</a> <a id="4794" href="#4782" class="Bound">a</a><a id="4795" class="Symbol">)</a> <a id="4797" class="Symbol">:</a> <a id="4799" class="PrimitiveType">Set</a> <a id="4803" href="#4782" class="Bound">a</a> <a id="4805" class="Keyword">where</a>
  <a id="FreeMonoid.[_]"></a><a id="4813" href="#4813" class="InductiveConstructor Operator">[_]</a> <a id="4817" class="Symbol">:</a> <a id="4819" href="#4786" class="Bound">A</a> <a id="4821" class="Symbol">‚Üí</a> <a id="4823" href="#4770" class="Datatype">FreeMonoid</a> <a id="4834" href="#4786" class="Bound">A</a>
  <a id="FreeMonoid._‚àô_"></a><a id="4838" href="#4838" class="InductiveConstructor Operator">_‚àô_</a> <a id="4842" class="Symbol">:</a> <a id="4844" href="#4770" class="Datatype">FreeMonoid</a> <a id="4855" href="#4786" class="Bound">A</a> <a id="4857" class="Symbol">‚Üí</a> <a id="4859" href="#4770" class="Datatype">FreeMonoid</a> <a id="4870" href="#4786" class="Bound">A</a> <a id="4872" class="Symbol">‚Üí</a> <a id="4874" href="#4770" class="Datatype">FreeMonoid</a> <a id="4885" href="#4786" class="Bound">A</a>
  <a id="FreeMonoid.Œµ"></a><a id="4889" href="#4889" class="InductiveConstructor">Œµ</a> <a id="4891" class="Symbol">:</a> <a id="4893" href="#4770" class="Datatype">FreeMonoid</a> <a id="4904" href="#4786" class="Bound">A</a>
  <a id="FreeMonoid.‚àôŒµ"></a><a id="4908" href="#4908" class="InductiveConstructor">‚àôŒµ</a> <a id="4911" class="Symbol">:</a> <a id="4913" class="Symbol">‚àÄ</a> <a id="4915" href="#4915" class="Bound">x</a> <a id="4917" class="Symbol">‚Üí</a> <a id="4919" href="#4915" class="Bound">x</a> <a id="4921" href="#4838" class="InductiveConstructor Operator">‚àô</a> <a id="4923" href="#4889" class="InductiveConstructor">Œµ</a> <a id="4925" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">‚â°</a> <a id="4927" href="#4915" class="Bound">x</a>
  <a id="FreeMonoid.Œµ‚àô"></a><a id="4931" href="#4931" class="InductiveConstructor">Œµ‚àô</a> <a id="4934" class="Symbol">:</a> <a id="4936" class="Symbol">‚àÄ</a> <a id="4938" href="#4938" class="Bound">x</a> <a id="4940" class="Symbol">‚Üí</a> <a id="4942" href="#4889" class="InductiveConstructor">Œµ</a> <a id="4944" href="#4838" class="InductiveConstructor Operator">‚àô</a> <a id="4946" href="#4938" class="Bound">x</a> <a id="4948" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">‚â°</a> <a id="4950" href="#4938" class="Bound">x</a>
  <a id="FreeMonoid.assoc"></a><a id="4954" href="#4954" class="InductiveConstructor">assoc</a> <a id="4960" class="Symbol">:</a> <a id="4962" class="Symbol">‚àÄ</a> <a id="4964" href="#4964" class="Bound">x</a> <a id="4966" href="#4966" class="Bound">y</a> <a id="4968" href="#4968" class="Bound">z</a> <a id="4970" class="Symbol">‚Üí</a> <a id="4972" class="Symbol">(</a><a id="4973" href="#4964" class="Bound">x</a> <a id="4975" href="#4838" class="InductiveConstructor Operator">‚àô</a> <a id="4977" href="#4966" class="Bound">y</a><a id="4978" class="Symbol">)</a> <a id="4980" href="#4838" class="InductiveConstructor Operator">‚àô</a> <a id="4982" href="#4968" class="Bound">z</a> <a id="4984" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">‚â°</a> <a id="4986" href="#4964" class="Bound">x</a> <a id="4988" href="#4838" class="InductiveConstructor Operator">‚àô</a> <a id="4990" class="Symbol">(</a><a id="4991" href="#4966" class="Bound">y</a> <a id="4993" href="#4838" class="InductiveConstructor Operator">‚àô</a> <a id="4995" href="#4968" class="Bound">z</a><a id="4996" class="Symbol">)</a>
</pre>
<p>It‚Äôs quite a satisfying definition, and very easy to see how we got to it from the monoid laws.</p>
Now, when we write functions, we have to prove that those functions themselves also obey the monoid laws. For instance, here‚Äôs how we would take the length:
<pre class="Agda"><a id="5265" class="Keyword">module</a> <a id="Length"></a><a id="5272" href="#5272" class="Module">Length</a> <a id="5279" class="Keyword">where</a>
  <a id="5287" class="Keyword">open</a> <a id="5292" class="Keyword">import</a> <a id="5299" href="../code/probability/ProbabilityModule.Semirings.Nat.html" class="Module">ProbabilityModule.Semirings.Nat</a>
  <a id="5333" class="Keyword">open</a> <a id="5338" href="../code/probability/ProbabilityModule.Semirings.html#125" class="Module">Semiring</a> <a id="5347" href="../code/probability/ProbabilityModule.Semirings.Nat.html#1820" class="Function">+-*-ùïä</a>

  <a id="Length.length"></a><a id="5356" href="#5356" class="Function">length</a> <a id="5363" class="Symbol">:</a> <a id="5365" href="#4770" class="Datatype">FreeMonoid</a> <a id="5376" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="5378" class="Symbol">‚Üí</a> <a id="5380" href="Agda.Builtin.Nat.html#165" class="Datatype">‚Ñï</a>
  <a id="5384" href="#5356" class="Function">length</a> <a id="5391" href="#4813" class="InductiveConstructor Operator">[</a> <a id="5393" href="#5393" class="Bound">x</a> <a id="5395" href="#4813" class="InductiveConstructor Operator">]</a> <a id="5397" class="Symbol">=</a> <a id="5399" class="Number">1</a>
  <a id="5403" href="#5356" class="Function">length</a> <a id="5410" class="Symbol">(</a><a id="5411" href="#5411" class="Bound">xs</a> <a id="5414" href="#4838" class="InductiveConstructor Operator">‚àô</a> <a id="5416" href="#5416" class="Bound">ys</a><a id="5418" class="Symbol">)</a> <a id="5420" class="Symbol">=</a> <a id="5422" href="#5356" class="Function">length</a> <a id="5429" href="#5411" class="Bound">xs</a> <a id="5432" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Function Operator">+</a> <a id="5434" href="#5356" class="Function">length</a> <a id="5441" href="#5416" class="Bound">ys</a>
  <a id="5446" href="#5356" class="Function">length</a> <a id="5453" href="#4889" class="InductiveConstructor">Œµ</a> <a id="5455" class="Symbol">=</a> <a id="5457" class="Number">0</a>
  <a id="5461" href="#5356" class="Function">length</a> <a id="5468" class="Symbol">(</a><a id="5469" href="#4908" class="InductiveConstructor">‚àôŒµ</a> <a id="5472" href="#5472" class="Bound">xs</a> <a id="5475" href="#5475" class="Bound">i</a><a id="5476" class="Symbol">)</a> <a id="5478" class="Symbol">=</a> <a id="5480" href="../code/probability/ProbabilityModule.Semirings.html#660" class="Function">+0</a> <a id="5483" class="Symbol">(</a><a id="5484" href="#5356" class="Function">length</a> <a id="5491" href="#5472" class="Bound">xs</a><a id="5493" class="Symbol">)</a> <a id="5495" href="#5475" class="Bound">i</a>
  <a id="5499" href="#5356" class="Function">length</a> <a id="5506" class="Symbol">(</a><a id="5507" href="#4931" class="InductiveConstructor">Œµ‚àô</a> <a id="5510" href="#5510" class="Bound">xs</a> <a id="5513" href="#5513" class="Bound">i</a><a id="5514" class="Symbol">)</a> <a id="5516" class="Symbol">=</a> <a id="5518" href="../code/probability/ProbabilityModule.Semirings.html#430" class="Function">0+</a> <a id="5521" class="Symbol">(</a><a id="5522" href="#5356" class="Function">length</a> <a id="5529" href="#5510" class="Bound">xs</a><a id="5531" class="Symbol">)</a> <a id="5533" href="#5513" class="Bound">i</a>
  <a id="5537" href="#5356" class="Function">length</a> <a id="5544" class="Symbol">(</a><a id="5545" href="#4954" class="InductiveConstructor">assoc</a> <a id="5551" href="#5551" class="Bound">xs</a> <a id="5554" href="#5554" class="Bound">ys</a> <a id="5557" href="#5557" class="Bound">zs</a> <a id="5560" href="#5560" class="Bound">i</a><a id="5561" class="Symbol">)</a> <a id="5563" class="Symbol">=</a> <a id="5565" href="../code/probability/ProbabilityModule.Semirings.html#276" class="Function">+-assoc</a> <a id="5573" class="Symbol">(</a><a id="5574" href="#5356" class="Function">length</a> <a id="5581" href="#5551" class="Bound">xs</a><a id="5583" class="Symbol">)</a> <a id="5585" class="Symbol">(</a><a id="5586" href="#5356" class="Function">length</a> <a id="5593" href="#5554" class="Bound">ys</a><a id="5595" class="Symbol">)</a> <a id="5597" class="Symbol">(</a><a id="5598" href="#5356" class="Function">length</a> <a id="5605" href="#5557" class="Bound">zs</a><a id="5607" class="Symbol">)</a> <a id="5609" href="#5560" class="Bound">i</a>
</pre>
<p>The first three clauses are the actual function: they deal with the three normal constructors of the type. The next three clauses prove that those previous clauses obey the equalities defined on the type.</p>
<p>With the preliminary stuff out of the way, let‚Äôs get on to the type I wanted to talk about:</p>
<h1 id="probability">Probability</h1>
<p>First things first, let‚Äôs remember the classic definition of the probability monad:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Prob</span> a <span class="fu">=</span> <span class="dt">Prob</span> {<span class="ot"> runProb ::</span> [(a, <span class="dt">Rational</span>)] }</a></code></pre></div>
<p>Definitionally speaking, this doesn‚Äôt really represent what we‚Äôre talking about. For instance, the following two things express the same distribution, but have different representations:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="dt">Prob</span> [(<span class="dt">True</span>, <span class="dv">1</span> <span class="fu">/</span> <span class="dv">4</span>), (<span class="dt">True</span>, <span class="dv">1</span> <span class="fu">/</span> <span class="dv">4</span>), (<span class="dt">False</span>, <span class="dv">1</span> <span class="fu">/</span> <span class="dv">2</span>)]</a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="dt">Prob</span> [(<span class="dt">True</span> , <span class="dv">1</span> <span class="fu">/</span> <span class="dv">2</span>), (<span class="dt">False</span>, <span class="dv">1</span> <span class="fu">/</span> <span class="dv">2</span>)]</a></code></pre></div>
<p>So it‚Äôs the perfect candidate for an extra equality clause like we had above.</p>
<p>Second, in an effort to generalise, we won‚Äôt deal specifically with <code>Rational</code>, and instead we‚Äôll use any semiring. After all of that, we get the following definition:</p>
<pre class="Agda"><a id="6634" class="Keyword">open</a> <a id="6639" href="../code/probability/ProbabilityModule.Semirings.html#125" class="Module">Semiring</a> <a id="6648" href="#1024" class="Bound">rng</a>

<a id="6653" class="Keyword">module</a> <a id="Initial"></a><a id="6660" href="#6660" class="Module">Initial</a> <a id="6668" class="Keyword">where</a>
 <a id="6675" class="Keyword">infixr</a> <a id="6682" class="Number">5</a> <a id="6684" href="#6746" class="InductiveConstructor Operator">_&amp;_‚à∑_</a>
 <a id="6691" class="Keyword">data</a> <a id="Initial.ùí´"></a><a id="6696" href="#6696" class="Datatype">ùí´</a> <a id="6698" class="Symbol">(</a><a id="6699" href="#6699" class="Bound">A</a> <a id="6701" class="Symbol">:</a> <a id="6703" class="PrimitiveType">Set</a> <a id="6707" href="../code/probability/ProbabilityModule.Utils.html#178" class="Generalizable">a</a><a id="6708" class="Symbol">)</a> <a id="6710" class="Symbol">:</a> <a id="6712" class="PrimitiveType">Set</a> <a id="6716" class="Symbol">(</a><a id="6717" href="#6707" class="Bound">a</a> <a id="6719" href="../code/probability/ProbabilityModule.Utils.html#242" class="Function Operator">‚äî</a> <a id="6721" href="#1020" class="Bound">s</a><a id="6722" class="Symbol">)</a> <a id="6724" class="Keyword">where</a>
   <a id="Initial.ùí´.[]"></a><a id="6733" href="#6733" class="InductiveConstructor">[]</a>  <a id="6737" class="Symbol">:</a> <a id="6739" href="#6696" class="Datatype">ùí´</a> <a id="6741" href="#6699" class="Bound">A</a>
   <a id="Initial.ùí´._&amp;_‚à∑_"></a><a id="6746" href="#6746" class="InductiveConstructor Operator">_&amp;_‚à∑_</a> <a id="6752" class="Symbol">:</a> <a id="6754" class="Symbol">(</a><a id="6755" href="#6755" class="Bound">p</a> <a id="6757" class="Symbol">:</a> <a id="6759" href="../code/probability/ProbabilityModule.Semirings.html#200" class="Field">R</a><a id="6760" class="Symbol">)</a> <a id="6762" class="Symbol">‚Üí</a> <a id="6764" class="Symbol">(</a><a id="6765" href="#6765" class="Bound">x</a> <a id="6767" class="Symbol">:</a> <a id="6769" href="#6699" class="Bound">A</a><a id="6770" class="Symbol">)</a> <a id="6772" class="Symbol">‚Üí</a> <a id="6774" href="#6696" class="Datatype">ùí´</a> <a id="6776" href="#6699" class="Bound">A</a> <a id="6778" class="Symbol">‚Üí</a> <a id="6780" href="#6696" class="Datatype">ùí´</a> <a id="6782" href="#6699" class="Bound">A</a>
   <a id="Initial.ùí´.dup"></a><a id="6787" href="#6787" class="InductiveConstructor">dup</a> <a id="6791" class="Symbol">:</a> <a id="6793" class="Symbol">‚àÄ</a> <a id="6795" href="#6795" class="Bound">p</a> <a id="6797" href="#6797" class="Bound">q</a> <a id="6799" href="#6799" class="Bound">x</a> <a id="6801" href="#6801" class="Bound">xs</a> <a id="6804" class="Symbol">‚Üí</a> <a id="6806" href="#6795" class="Bound">p</a> <a id="6808" href="#6746" class="InductiveConstructor Operator">&amp;</a> <a id="6810" href="#6799" class="Bound">x</a> <a id="6812" href="#6746" class="InductiveConstructor Operator">‚à∑</a> <a id="6814" href="#6797" class="Bound">q</a> <a id="6816" href="#6746" class="InductiveConstructor Operator">&amp;</a> <a id="6818" href="#6799" class="Bound">x</a> <a id="6820" href="#6746" class="InductiveConstructor Operator">‚à∑</a> <a id="6822" href="#6801" class="Bound">xs</a> <a id="6825" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">‚â°</a> <a id="6827" href="#6795" class="Bound">p</a> <a id="6829" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="6831" href="#6797" class="Bound">q</a> <a id="6833" href="#6746" class="InductiveConstructor Operator">&amp;</a> <a id="6835" href="#6799" class="Bound">x</a> <a id="6837" href="#6746" class="InductiveConstructor Operator">‚à∑</a> <a id="6839" href="#6801" class="Bound">xs</a>
   <a id="Initial.ùí´.com"></a><a id="6845" href="#6845" class="InductiveConstructor">com</a> <a id="6849" class="Symbol">:</a> <a id="6851" class="Symbol">‚àÄ</a> <a id="6853" href="#6853" class="Bound">p</a> <a id="6855" href="#6855" class="Bound">x</a> <a id="6857" href="#6857" class="Bound">q</a> <a id="6859" href="#6859" class="Bound">y</a> <a id="6861" href="#6861" class="Bound">xs</a> <a id="6864" class="Symbol">‚Üí</a> <a id="6866" href="#6853" class="Bound">p</a> <a id="6868" href="#6746" class="InductiveConstructor Operator">&amp;</a> <a id="6870" href="#6855" class="Bound">x</a> <a id="6872" href="#6746" class="InductiveConstructor Operator">‚à∑</a> <a id="6874" href="#6857" class="Bound">q</a> <a id="6876" href="#6746" class="InductiveConstructor Operator">&amp;</a> <a id="6878" href="#6859" class="Bound">y</a> <a id="6880" href="#6746" class="InductiveConstructor Operator">‚à∑</a> <a id="6882" href="#6861" class="Bound">xs</a> <a id="6885" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">‚â°</a> <a id="6887" href="#6857" class="Bound">q</a> <a id="6889" href="#6746" class="InductiveConstructor Operator">&amp;</a> <a id="6891" href="#6859" class="Bound">y</a> <a id="6893" href="#6746" class="InductiveConstructor Operator">‚à∑</a> <a id="6895" href="#6853" class="Bound">p</a> <a id="6897" href="#6746" class="InductiveConstructor Operator">&amp;</a> <a id="6899" href="#6855" class="Bound">x</a> <a id="6901" href="#6746" class="InductiveConstructor Operator">‚à∑</a> <a id="6903" href="#6861" class="Bound">xs</a>
   <a id="Initial.ùí´.del"></a><a id="6909" href="#6909" class="InductiveConstructor">del</a> <a id="6913" class="Symbol">:</a> <a id="6915" class="Symbol">‚àÄ</a> <a id="6917" href="#6917" class="Bound">x</a> <a id="6919" href="#6919" class="Bound">xs</a> <a id="6922" class="Symbol">‚Üí</a> <a id="6924" href="../code/probability/ProbabilityModule.Semirings.html#254" class="Field">0#</a> <a id="6927" href="#6746" class="InductiveConstructor Operator">&amp;</a> <a id="6929" href="#6917" class="Bound">x</a> <a id="6931" href="#6746" class="InductiveConstructor Operator">‚à∑</a> <a id="6933" href="#6919" class="Bound">xs</a> <a id="6936" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">‚â°</a> <a id="6938" href="#6919" class="Bound">xs</a>
</pre>
<p>The three extra conditions are pretty sensible: the first removes duplicates, the second makes things commutative, and the third removes impossible events.</p>
<p>Let‚Äôs get to writing some functions, then:</p>
<pre class="Agda"> <a id="Initial.‚à´"></a><a id="7156" href="#7156" class="Function">‚à´</a> <a id="7158" class="Symbol">:</a> <a id="7160" class="Symbol">(</a><a id="7161" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="7163" class="Symbol">‚Üí</a> <a id="7165" href="../code/probability/ProbabilityModule.Semirings.html#200" class="Field">R</a><a id="7166" class="Symbol">)</a> <a id="7168" class="Symbol">‚Üí</a> <a id="7170" href="#6696" class="Datatype">ùí´</a> <a id="7172" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="7174" class="Symbol">‚Üí</a> <a id="7176" href="../code/probability/ProbabilityModule.Semirings.html#200" class="Field">R</a>
 <a id="7179" href="#7156" class="Function">‚à´</a> <a id="7181" href="#7181" class="Bound">f</a> <a id="7183" href="#6733" class="InductiveConstructor">[]</a> <a id="7186" class="Symbol">=</a> <a id="7188" href="../code/probability/ProbabilityModule.Semirings.html#254" class="Field">0#</a>
 <a id="7192" href="#7156" class="Function">‚à´</a> <a id="7194" href="#7194" class="Bound">f</a> <a id="7196" class="Symbol">(</a><a id="7197" href="#7197" class="Bound">p</a> <a id="7199" href="#6746" class="InductiveConstructor Operator">&amp;</a> <a id="7201" href="#7201" class="Bound">x</a> <a id="7203" href="#6746" class="InductiveConstructor Operator">‚à∑</a> <a id="7205" href="#7205" class="Bound">xs</a><a id="7207" class="Symbol">)</a> <a id="7209" class="Symbol">=</a> <a id="7211" href="#7197" class="Bound">p</a> <a id="7213" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="7215" href="#7194" class="Bound">f</a> <a id="7217" href="#7201" class="Bound">x</a> <a id="7219" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="7221" href="#7156" class="Function">‚à´</a> <a id="7223" href="#7194" class="Bound">f</a> <a id="7225" href="#7205" class="Bound">xs</a>
 <a id="7229" href="#7156" class="Function">‚à´</a> <a id="7231" href="#7231" class="Bound">f</a> <a id="7233" class="Symbol">(</a><a id="7234" href="#6787" class="InductiveConstructor">dup</a> <a id="7238" href="#7238" class="Bound">p</a> <a id="7240" href="#7240" class="Bound">q</a> <a id="7242" href="#7242" class="Bound">x</a> <a id="7244" href="#7244" class="Bound">xs</a> <a id="7247" href="#7247" class="Bound">i</a><a id="7248" class="Symbol">)</a> <a id="7250" class="Symbol">=</a> <a id="7252" href="../code/probability/ProbabilityModule.Utils.html#645" class="Function Operator">begin[</a> <a id="7259" href="#7247" class="Bound">i</a> <a id="7261" href="../code/probability/ProbabilityModule.Utils.html#645" class="Function Operator">]</a>
   <a id="7266" href="#7238" class="Bound">p</a> <a id="7268" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="7270" href="#7231" class="Bound">f</a> <a id="7272" href="#7242" class="Bound">x</a> <a id="7274" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="7276" class="Symbol">(</a><a id="7277" href="#7240" class="Bound">q</a> <a id="7279" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="7281" href="#7231" class="Bound">f</a> <a id="7283" href="#7242" class="Bound">x</a> <a id="7285" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="7287" href="#7156" class="Function">‚à´</a> <a id="7289" href="#7231" class="Bound">f</a> <a id="7291" href="#7244" class="Bound">xs</a><a id="7293" class="Symbol">)</a> <a id="7295" href="../code/probability/ProbabilityModule.Utils.html#295" class="Function">‚â°Àò‚ü®</a> <a id="7299" href="../code/probability/ProbabilityModule.Semirings.html#276" class="Field">+-assoc</a> <a id="7307" class="Symbol">(</a><a id="7308" href="#7238" class="Bound">p</a> <a id="7310" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="7312" href="#7231" class="Bound">f</a> <a id="7314" href="#7242" class="Bound">x</a><a id="7315" class="Symbol">)</a> <a id="7317" class="Symbol">(</a><a id="7318" href="#7240" class="Bound">q</a> <a id="7320" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="7322" href="#7231" class="Bound">f</a> <a id="7324" href="#7242" class="Bound">x</a><a id="7325" class="Symbol">)</a> <a id="7327" class="Symbol">(</a><a id="7328" href="#7156" class="Function">‚à´</a> <a id="7330" href="#7231" class="Bound">f</a> <a id="7332" href="#7244" class="Bound">xs</a><a id="7334" class="Symbol">)</a> <a id="7336" href="../code/probability/ProbabilityModule.Utils.html#295" class="Function">‚ü©</a>
   <a id="7341" class="Symbol">(</a><a id="7342" href="#7238" class="Bound">p</a> <a id="7344" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="7346" href="#7231" class="Bound">f</a> <a id="7348" href="#7242" class="Bound">x</a> <a id="7350" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="7352" href="#7240" class="Bound">q</a> <a id="7354" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="7356" href="#7231" class="Bound">f</a> <a id="7358" href="#7242" class="Bound">x</a><a id="7359" class="Symbol">)</a> <a id="7361" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="7363" href="#7156" class="Function">‚à´</a> <a id="7365" href="#7231" class="Bound">f</a> <a id="7367" href="#7244" class="Bound">xs</a> <a id="7370" href="../code/probability/ProbabilityModule.Utils.html#295" class="Function">‚â°Àò‚ü®</a> <a id="7374" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="7379" class="Symbol">(</a><a id="7380" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">_+</a> <a id="7383" href="#7156" class="Function">‚à´</a> <a id="7385" href="#7231" class="Bound">f</a> <a id="7387" href="#7244" class="Bound">xs</a><a id="7389" class="Symbol">)</a> <a id="7391" class="Symbol">(</a><a id="7392" href="../code/probability/ProbabilityModule.Semirings.html#592" class="Field">‚ü®+‚ü©*</a> <a id="7397" href="#7238" class="Bound">p</a> <a id="7399" href="#7240" class="Bound">q</a> <a id="7401" class="Symbol">(</a><a id="7402" href="#7231" class="Bound">f</a> <a id="7404" href="#7242" class="Bound">x</a><a id="7405" class="Symbol">))</a>  <a id="7409" href="../code/probability/ProbabilityModule.Utils.html#295" class="Function">‚ü©</a>
   <a id="7414" class="Symbol">(</a><a id="7415" href="#7238" class="Bound">p</a> <a id="7417" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="7419" href="#7240" class="Bound">q</a><a id="7420" class="Symbol">)</a> <a id="7422" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="7424" href="#7231" class="Bound">f</a> <a id="7426" href="#7242" class="Bound">x</a> <a id="7428" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="7430" href="#7156" class="Function">‚à´</a> <a id="7432" href="#7231" class="Bound">f</a> <a id="7434" href="#7244" class="Bound">xs</a> <a id="7437" href="../code/probability/Cubical.Foundations.Prelude.html#2745" class="Function Operator">‚àé</a>
 <a id="7440" href="#7156" class="Function">‚à´</a> <a id="7442" href="#7442" class="Bound">f</a> <a id="7444" class="Symbol">(</a><a id="7445" href="#6845" class="InductiveConstructor">com</a> <a id="7449" href="#7449" class="Bound">p</a> <a id="7451" href="#7451" class="Bound">x</a> <a id="7453" href="#7453" class="Bound">q</a> <a id="7455" href="#7455" class="Bound">y</a> <a id="7457" href="#7457" class="Bound">xs</a> <a id="7460" href="#7460" class="Bound">i</a><a id="7461" class="Symbol">)</a> <a id="7463" class="Symbol">=</a> <a id="7465" href="../code/probability/ProbabilityModule.Utils.html#645" class="Function Operator">begin[</a> <a id="7472" href="#7460" class="Bound">i</a> <a id="7474" href="../code/probability/ProbabilityModule.Utils.html#645" class="Function Operator">]</a>
   <a id="7479" href="#7449" class="Bound">p</a> <a id="7481" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="7483" href="#7442" class="Bound">f</a> <a id="7485" href="#7451" class="Bound">x</a> <a id="7487" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="7489" class="Symbol">(</a><a id="7490" href="#7453" class="Bound">q</a> <a id="7492" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="7494" href="#7442" class="Bound">f</a> <a id="7496" href="#7455" class="Bound">y</a> <a id="7498" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="7500" href="#7156" class="Function">‚à´</a> <a id="7502" href="#7442" class="Bound">f</a> <a id="7504" href="#7457" class="Bound">xs</a><a id="7506" class="Symbol">)</a> <a id="7508" href="../code/probability/ProbabilityModule.Utils.html#295" class="Function">‚â°Àò‚ü®</a> <a id="7512" href="../code/probability/ProbabilityModule.Semirings.html#276" class="Field">+-assoc</a> <a id="7520" class="Symbol">(</a><a id="7521" href="#7449" class="Bound">p</a> <a id="7523" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="7525" href="#7442" class="Bound">f</a> <a id="7527" href="#7451" class="Bound">x</a><a id="7528" class="Symbol">)</a> <a id="7530" class="Symbol">(</a><a id="7531" href="#7453" class="Bound">q</a> <a id="7533" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="7535" href="#7442" class="Bound">f</a> <a id="7537" href="#7455" class="Bound">y</a><a id="7538" class="Symbol">)</a> <a id="7540" class="Symbol">(</a><a id="7541" href="#7156" class="Function">‚à´</a> <a id="7543" href="#7442" class="Bound">f</a> <a id="7545" href="#7457" class="Bound">xs</a><a id="7547" class="Symbol">)</a> <a id="7549" href="../code/probability/ProbabilityModule.Utils.html#295" class="Function">‚ü©</a>
   <a id="7554" href="#7449" class="Bound">p</a> <a id="7556" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="7558" href="#7442" class="Bound">f</a> <a id="7560" href="#7451" class="Bound">x</a> <a id="7562" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="7564" href="#7453" class="Bound">q</a> <a id="7566" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="7568" href="#7442" class="Bound">f</a> <a id="7570" href="#7455" class="Bound">y</a> <a id="7572" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="7574" href="#7156" class="Function">‚à´</a> <a id="7576" href="#7442" class="Bound">f</a> <a id="7578" href="#7457" class="Bound">xs</a>   <a id="7583" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚â°‚ü®</a> <a id="7586" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="7591" class="Symbol">(</a><a id="7592" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">_+</a> <a id="7595" href="#7156" class="Function">‚à´</a> <a id="7597" href="#7442" class="Bound">f</a> <a id="7599" href="#7457" class="Bound">xs</a><a id="7601" class="Symbol">)</a> <a id="7603" class="Symbol">(</a><a id="7604" href="../code/probability/ProbabilityModule.Semirings.html#508" class="Field">+-comm</a> <a id="7611" class="Symbol">(</a><a id="7612" href="#7449" class="Bound">p</a> <a id="7614" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="7616" href="#7442" class="Bound">f</a> <a id="7618" href="#7451" class="Bound">x</a><a id="7619" class="Symbol">)</a> <a id="7621" class="Symbol">(</a><a id="7622" href="#7453" class="Bound">q</a> <a id="7624" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="7626" href="#7442" class="Bound">f</a> <a id="7628" href="#7455" class="Bound">y</a><a id="7629" class="Symbol">))</a> <a id="7632" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚ü©</a>
   <a id="7637" href="#7453" class="Bound">q</a> <a id="7639" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="7641" href="#7442" class="Bound">f</a> <a id="7643" href="#7455" class="Bound">y</a> <a id="7645" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="7647" href="#7449" class="Bound">p</a> <a id="7649" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="7651" href="#7442" class="Bound">f</a> <a id="7653" href="#7451" class="Bound">x</a> <a id="7655" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="7657" href="#7156" class="Function">‚à´</a> <a id="7659" href="#7442" class="Bound">f</a> <a id="7661" href="#7457" class="Bound">xs</a>   <a id="7666" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚â°‚ü®</a> <a id="7669" href="../code/probability/ProbabilityModule.Semirings.html#276" class="Field">+-assoc</a> <a id="7677" class="Symbol">(</a><a id="7678" href="#7453" class="Bound">q</a> <a id="7680" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="7682" href="#7442" class="Bound">f</a> <a id="7684" href="#7455" class="Bound">y</a><a id="7685" class="Symbol">)</a> <a id="7687" class="Symbol">(</a><a id="7688" href="#7449" class="Bound">p</a> <a id="7690" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="7692" href="#7442" class="Bound">f</a> <a id="7694" href="#7451" class="Bound">x</a><a id="7695" class="Symbol">)</a> <a id="7697" class="Symbol">(</a><a id="7698" href="#7156" class="Function">‚à´</a> <a id="7700" href="#7442" class="Bound">f</a> <a id="7702" href="#7457" class="Bound">xs</a><a id="7704" class="Symbol">)</a> <a id="7706" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚ü©</a>
   <a id="7711" href="#7453" class="Bound">q</a> <a id="7713" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="7715" href="#7442" class="Bound">f</a> <a id="7717" href="#7455" class="Bound">y</a> <a id="7719" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="7721" class="Symbol">(</a><a id="7722" href="#7449" class="Bound">p</a> <a id="7724" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="7726" href="#7442" class="Bound">f</a> <a id="7728" href="#7451" class="Bound">x</a> <a id="7730" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="7732" href="#7156" class="Function">‚à´</a> <a id="7734" href="#7442" class="Bound">f</a> <a id="7736" href="#7457" class="Bound">xs</a><a id="7738" class="Symbol">)</a> <a id="7740" href="../code/probability/Cubical.Foundations.Prelude.html#2745" class="Function Operator">‚àé</a>
 <a id="7743" href="#7156" class="Function">‚à´</a> <a id="7745" href="#7745" class="Bound">f</a> <a id="7747" class="Symbol">(</a><a id="7748" href="#6909" class="InductiveConstructor">del</a> <a id="7752" href="#7752" class="Bound">x</a> <a id="7754" href="#7754" class="Bound">xs</a> <a id="7757" href="#7757" class="Bound">i</a><a id="7758" class="Symbol">)</a> <a id="7760" class="Symbol">=</a> <a id="7762" href="../code/probability/ProbabilityModule.Utils.html#645" class="Function Operator">begin[</a> <a id="7769" href="#7757" class="Bound">i</a> <a id="7771" href="../code/probability/ProbabilityModule.Utils.html#645" class="Function Operator">]</a>
   <a id="7776" href="../code/probability/ProbabilityModule.Semirings.html#254" class="Field">0#</a> <a id="7779" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="7781" href="#7745" class="Bound">f</a> <a id="7783" href="#7752" class="Bound">x</a> <a id="7785" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="7787" href="#7156" class="Function">‚à´</a> <a id="7789" href="#7745" class="Bound">f</a> <a id="7791" href="#7754" class="Bound">xs</a> <a id="7794" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚â°‚ü®</a> <a id="7797" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="7802" class="Symbol">(</a><a id="7803" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">_+</a> <a id="7806" href="#7156" class="Function">‚à´</a> <a id="7808" href="#7745" class="Bound">f</a> <a id="7810" href="#7754" class="Bound">xs</a><a id="7812" class="Symbol">)</a> <a id="7814" class="Symbol">(</a><a id="7815" href="../code/probability/ProbabilityModule.Semirings.html#403" class="Field">0*</a> <a id="7818" class="Symbol">(</a><a id="7819" href="#7745" class="Bound">f</a> <a id="7821" href="#7752" class="Bound">x</a><a id="7822" class="Symbol">))</a> <a id="7825" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚ü©</a>
   <a id="7830" href="../code/probability/ProbabilityModule.Semirings.html#254" class="Field">0#</a> <a id="7833" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="7835" href="#7156" class="Function">‚à´</a> <a id="7837" href="#7745" class="Bound">f</a> <a id="7839" href="#7754" class="Bound">xs</a>       <a id="7848" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚â°‚ü®</a> <a id="7851" href="../code/probability/ProbabilityModule.Semirings.html#430" class="Field">0+</a> <a id="7854" class="Symbol">(</a><a id="7855" href="#7156" class="Function">‚à´</a> <a id="7857" href="#7745" class="Bound">f</a> <a id="7859" href="#7754" class="Bound">xs</a><a id="7861" class="Symbol">)</a> <a id="7863" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚ü©</a>
   <a id="7868" href="#7156" class="Function">‚à´</a> <a id="7870" href="#7745" class="Bound">f</a> <a id="7872" href="#7754" class="Bound">xs</a> <a id="7875" href="../code/probability/Cubical.Foundations.Prelude.html#2745" class="Function Operator">‚àé</a>
</pre>
<p>This is much more involved than the free monoid function, but the principle is the same: we first write the actual function (on the first three lines), and then we show that the function doesn‚Äôt care about the ‚Äúrewrite rules‚Äù we have in the next three clauses.</p>
<p>Before going any further, we will have to amend the definition a little. The problem is that if we tried to prove something about any function on our <code>ùí´</code> type, we‚Äôd have to prove equalities <em>between equalities</em> as well. I‚Äôm sure that this is possible, but it‚Äôs very annoying, so I‚Äôm going to use a technique I saw in <a href="https://github.com/L-TChen/FiniteSets">this repository</a>. We add another rule to our type, stating that all equalities on the type are themselves equal. The new definition looks like this:</p>
<pre class="Agda"><a id="8659" class="Keyword">infixr</a> <a id="8666" class="Number">5</a> <a id="8668" href="#8727" class="InductiveConstructor Operator">_&amp;_‚à∑_</a>
<a id="8674" class="Keyword">data</a> <a id="ùí´"></a><a id="8679" href="#8679" class="Datatype">ùí´</a> <a id="8681" class="Symbol">(</a><a id="8682" href="#8682" class="Bound">A</a> <a id="8684" class="Symbol">:</a> <a id="8686" class="PrimitiveType">Set</a> <a id="8690" href="../code/probability/ProbabilityModule.Utils.html#178" class="Generalizable">a</a><a id="8691" class="Symbol">)</a> <a id="8693" class="Symbol">:</a> <a id="8695" class="PrimitiveType">Set</a> <a id="8699" class="Symbol">(</a><a id="8700" href="#8690" class="Bound">a</a> <a id="8702" href="../code/probability/ProbabilityModule.Utils.html#242" class="Function Operator">‚äî</a> <a id="8704" href="#1020" class="Bound">s</a><a id="8705" class="Symbol">)</a> <a id="8707" class="Keyword">where</a>
  <a id="ùí´.[]"></a><a id="8715" href="#8715" class="InductiveConstructor">[]</a>  <a id="8719" class="Symbol">:</a> <a id="8721" href="#8679" class="Datatype">ùí´</a> <a id="8723" href="#8682" class="Bound">A</a>
  <a id="ùí´._&amp;_‚à∑_"></a><a id="8727" href="#8727" class="InductiveConstructor Operator">_&amp;_‚à∑_</a> <a id="8733" class="Symbol">:</a> <a id="8735" class="Symbol">(</a><a id="8736" href="#8736" class="Bound">p</a> <a id="8738" class="Symbol">:</a> <a id="8740" href="../code/probability/ProbabilityModule.Semirings.html#200" class="Field">R</a><a id="8741" class="Symbol">)</a> <a id="8743" class="Symbol">‚Üí</a> <a id="8745" class="Symbol">(</a><a id="8746" href="#8746" class="Bound">x</a> <a id="8748" class="Symbol">:</a> <a id="8750" href="#8682" class="Bound">A</a><a id="8751" class="Symbol">)</a> <a id="8753" class="Symbol">‚Üí</a> <a id="8755" href="#8679" class="Datatype">ùí´</a> <a id="8757" href="#8682" class="Bound">A</a> <a id="8759" class="Symbol">‚Üí</a> <a id="8761" href="#8679" class="Datatype">ùí´</a> <a id="8763" href="#8682" class="Bound">A</a>
  <a id="ùí´.dup"></a><a id="8767" href="#8767" class="InductiveConstructor">dup</a> <a id="8771" class="Symbol">:</a> <a id="8773" class="Symbol">‚àÄ</a> <a id="8775" href="#8775" class="Bound">p</a> <a id="8777" href="#8777" class="Bound">q</a> <a id="8779" href="#8779" class="Bound">x</a> <a id="8781" href="#8781" class="Bound">xs</a> <a id="8784" class="Symbol">‚Üí</a> <a id="8786" href="#8775" class="Bound">p</a> <a id="8788" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="8790" href="#8779" class="Bound">x</a> <a id="8792" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="8794" href="#8777" class="Bound">q</a> <a id="8796" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="8798" href="#8779" class="Bound">x</a> <a id="8800" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="8802" href="#8781" class="Bound">xs</a> <a id="8805" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">‚â°</a> <a id="8807" href="#8775" class="Bound">p</a> <a id="8809" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="8811" href="#8777" class="Bound">q</a> <a id="8813" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="8815" href="#8779" class="Bound">x</a> <a id="8817" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="8819" href="#8781" class="Bound">xs</a>
  <a id="ùí´.com"></a><a id="8824" href="#8824" class="InductiveConstructor">com</a> <a id="8828" class="Symbol">:</a> <a id="8830" class="Symbol">‚àÄ</a> <a id="8832" href="#8832" class="Bound">p</a> <a id="8834" href="#8834" class="Bound">x</a> <a id="8836" href="#8836" class="Bound">q</a> <a id="8838" href="#8838" class="Bound">y</a> <a id="8840" href="#8840" class="Bound">xs</a> <a id="8843" class="Symbol">‚Üí</a> <a id="8845" href="#8832" class="Bound">p</a> <a id="8847" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="8849" href="#8834" class="Bound">x</a> <a id="8851" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="8853" href="#8836" class="Bound">q</a> <a id="8855" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="8857" href="#8838" class="Bound">y</a> <a id="8859" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="8861" href="#8840" class="Bound">xs</a> <a id="8864" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">‚â°</a> <a id="8866" href="#8836" class="Bound">q</a> <a id="8868" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="8870" href="#8838" class="Bound">y</a> <a id="8872" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="8874" href="#8832" class="Bound">p</a> <a id="8876" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="8878" href="#8834" class="Bound">x</a> <a id="8880" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="8882" href="#8840" class="Bound">xs</a>
  <a id="ùí´.del"></a><a id="8887" href="#8887" class="InductiveConstructor">del</a> <a id="8891" class="Symbol">:</a> <a id="8893" class="Symbol">‚àÄ</a> <a id="8895" href="#8895" class="Bound">x</a> <a id="8897" href="#8897" class="Bound">xs</a> <a id="8900" class="Symbol">‚Üí</a> <a id="8902" href="../code/probability/ProbabilityModule.Semirings.html#254" class="Field">0#</a> <a id="8905" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="8907" href="#8895" class="Bound">x</a> <a id="8909" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="8911" href="#8897" class="Bound">xs</a> <a id="8914" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">‚â°</a> <a id="8916" href="#8897" class="Bound">xs</a>
  <a id="ùí´.trunc"></a><a id="8921" href="#8921" class="InductiveConstructor">trunc</a> <a id="8927" class="Symbol">:</a> <a id="8929" href="../code/probability/Cubical.Foundations.Prelude.html#5455" class="Function">isSet</a> <a id="8935" class="Symbol">(</a><a id="8936" href="#8679" class="Datatype">ùí´</a> <a id="8938" href="#8682" class="Bound">A</a><a id="8939" class="Symbol">)</a>
</pre>
<h1 id="eliminators">Eliminators</h1>
<p>Unfortunately, after adding that case we have to deal with it explicitly in every pattern-match on <code>ùí´</code>. We can get around it by writing an eliminator for the type which deals with it itself. Eliminators are often irritating to work with, though: we give up the nice pattern-matching syntax we get when we program directly. It‚Äôs a bit like having to rely on church encoding everywhere.</p>
<p>However, we can get back some pattern-like syntax if we use <em>copatterns</em>. Here‚Äôs an example of what I mean, for folds on lists:</p>
<pre class="Agda"><a id="9484" class="Keyword">module</a> <a id="ListElim"></a><a id="9491" href="#9491" class="Module">ListElim</a> <a id="9500" class="Keyword">where</a>
 <a id="9507" class="Keyword">open</a> <a id="9512" href="#2748" class="Module">NormalList</a>
 <a id="9524" class="Keyword">open</a> <a id="9529" class="Keyword">import</a> <a id="9536" href="../code/probability/ProbabilityModule.Semirings.Nat.html" class="Module">ProbabilityModule.Semirings.Nat</a>
 <a id="9569" class="Keyword">open</a> <a id="9574" href="../code/probability/ProbabilityModule.Semirings.html#125" class="Module">Semiring</a> <a id="9583" href="../code/probability/ProbabilityModule.Semirings.Nat.html#1820" class="Function">+-*-ùïä</a> <a id="9589" class="Keyword">renaming</a> <a id="9598" class="Symbol">(</a>_+_ <a id="9603" class="Symbol">to</a> _‚Ñï+_<a id="9610" class="Symbol">)</a>

 <a id="9614" class="Keyword">record</a> <a id="ListElim.[_‚Ü¶_]"></a><a id="9621" href="#9621" class="Record Operator">[_‚Ü¶_]</a> <a id="9627" class="Symbol">(</a><a id="9628" href="#9628" class="Bound">A</a> <a id="9630" class="Symbol">:</a> <a id="9632" class="PrimitiveType">Set</a> <a id="9636" href="../code/probability/ProbabilityModule.Utils.html#178" class="Generalizable">a</a><a id="9637" class="Symbol">)</a> <a id="9639" class="Symbol">(</a><a id="9640" href="#9640" class="Bound">B</a> <a id="9642" class="Symbol">:</a> <a id="9644" class="PrimitiveType">Set</a> <a id="9648" href="../code/probability/ProbabilityModule.Utils.html#180" class="Generalizable">b</a><a id="9649" class="Symbol">)</a> <a id="9651" class="Symbol">:</a> <a id="9653" class="PrimitiveType">Set</a> <a id="9657" class="Symbol">(</a><a id="9658" href="#9636" class="Bound">a</a> <a id="9660" href="../code/probability/ProbabilityModule.Utils.html#242" class="Function Operator">‚äî</a> <a id="9662" href="#9648" class="Bound">b</a><a id="9663" class="Symbol">)</a> <a id="9665" class="Keyword">where</a>
   <a id="9674" class="Keyword">field</a>
     <a id="ListElim.[_‚Ü¶_].[_][]"></a><a id="9685" href="#9685" class="Field Operator">[_][]</a> <a id="9691" class="Symbol">:</a> <a id="9693" href="#9640" class="Bound">B</a>
     <a id="ListElim.[_‚Ü¶_].[_]_‚à∑_"></a><a id="9700" href="#9700" class="Field Operator">[_]_‚à∑_</a> <a id="9707" class="Symbol">:</a> <a id="9709" href="#9628" class="Bound">A</a> <a id="9711" class="Symbol">‚Üí</a> <a id="9713" href="#9640" class="Bound">B</a> <a id="9715" class="Symbol">‚Üí</a> <a id="9717" href="#9640" class="Bound">B</a>
   <a id="ListElim.[_‚Ü¶_].[_]‚Üì"></a><a id="9722" href="#9722" class="Function Operator">[_]‚Üì</a> <a id="9727" class="Symbol">:</a> <a id="9729" href="#2771" class="Datatype">List</a> <a id="9734" href="#9628" class="Bound">A</a> <a id="9736" class="Symbol">‚Üí</a> <a id="9738" href="#9640" class="Bound">B</a>
   <a id="9743" href="#9722" class="Function Operator">[</a> <a id="9745" href="#2809" class="InductiveConstructor">[]</a> <a id="9748" href="#9722" class="Function Operator">]‚Üì</a> <a id="9751" class="Symbol">=</a> <a id="9753" href="#9685" class="Field Operator">[_][]</a>
   <a id="9762" href="#9722" class="Function Operator">[</a> <a id="9764" href="#9764" class="Bound">x</a> <a id="9766" href="#2824" class="InductiveConstructor Operator">‚à∑</a> <a id="9768" href="#9768" class="Bound">xs</a> <a id="9771" href="#9722" class="Function Operator">]‚Üì</a> <a id="9774" class="Symbol">=</a> <a id="9776" href="#9700" class="Field Operator">[_]_‚à∑_</a> <a id="9783" href="#9764" class="Bound">x</a> <a id="9785" href="#9722" class="Function Operator">[</a> <a id="9787" href="#9768" class="Bound">xs</a> <a id="9790" href="#9722" class="Function Operator">]‚Üì</a>
 <a id="9794" class="Keyword">open</a> <a id="9799" href="#9621" class="Module Operator">[_‚Ü¶_]</a>
 
 <a id="ListElim.sum-alg"></a><a id="9808" href="#9808" class="Function">sum-alg</a> <a id="9816" class="Symbol">:</a> <a id="9818" href="#9621" class="Record Operator">[</a> <a id="9820" href="Agda.Builtin.Nat.html#165" class="Datatype">‚Ñï</a> <a id="9822" href="#9621" class="Record Operator">‚Ü¶</a> <a id="9824" href="Agda.Builtin.Nat.html#165" class="Datatype">‚Ñï</a> <a id="9826" href="#9621" class="Record Operator">]</a>
 <a id="9829" href="#9685" class="Field Operator">[</a> <a id="9831" href="#9808" class="Function">sum-alg</a> <a id="9839" href="#9685" class="Field Operator">][]</a> <a id="9843" class="Symbol">=</a> <a id="9845" class="Number">0</a>
 <a id="9848" href="#9700" class="Field Operator">[</a> <a id="9850" href="#9808" class="Function">sum-alg</a> <a id="9858" href="#9700" class="Field Operator">]</a> <a id="9860" href="#9860" class="Bound">x</a> <a id="9862" href="#9700" class="Field Operator">‚à∑</a> <a id="9864" href="#9864" class="Bound">xs</a> <a id="9867" class="Symbol">=</a> <a id="9869" href="#9860" class="Bound">x</a> <a id="9871" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Function Operator">‚Ñï+</a> <a id="9874" href="#9864" class="Bound">xs</a>
 
 <a id="ListElim.sum"></a><a id="9880" href="#9880" class="Function">sum</a> <a id="9884" class="Symbol">:</a> <a id="9886" href="#2771" class="Datatype">List</a> <a id="9891" href="Agda.Builtin.Nat.html#165" class="Datatype">‚Ñï</a> <a id="9893" class="Symbol">‚Üí</a> <a id="9895" href="Agda.Builtin.Nat.html#165" class="Datatype">‚Ñï</a>
 <a id="9898" href="#9880" class="Function">sum</a> <a id="9902" class="Symbol">=</a> <a id="9904" href="#9722" class="Function Operator">[</a> <a id="9906" href="#9808" class="Function">sum-alg</a> <a id="9914" href="#9722" class="Function Operator">]‚Üì</a>
</pre>
<p>For the probability monad, there‚Äôs an eliminator for the whole thing, and eliminator for propositional proofs, and a normal eliminator for folding. Their definitions are quite long, but mechanical.</p>
<details>
<summary>Eliminator Definitions</summary>
<pre class="Agda"><a id="10181" class="Keyword">record</a> <a id="‚üÖ_‚Üù_‚üÜ"></a><a id="10188" href="#10188" class="Record Operator">‚üÖ_‚Üù_‚üÜ</a> <a id="10194" class="Symbol">{</a><a id="10195" href="#10195" class="Bound">a</a> <a id="10197" href="#10197" class="Bound">‚Ñì</a><a id="10198" class="Symbol">}</a> <a id="10200" class="Symbol">(</a><a id="10201" href="#10201" class="Bound">A</a> <a id="10203" class="Symbol">:</a> <a id="10205" class="PrimitiveType">Set</a> <a id="10209" href="#10195" class="Bound">a</a><a id="10210" class="Symbol">)</a> <a id="10212" class="Symbol">(</a><a id="10213" href="#10213" class="Bound">P</a> <a id="10215" class="Symbol">:</a> <a id="10217" href="#8679" class="Datatype">ùí´</a> <a id="10219" href="#10201" class="Bound">A</a> <a id="10221" class="Symbol">‚Üí</a> <a id="10223" class="PrimitiveType">Set</a> <a id="10227" href="#10197" class="Bound">‚Ñì</a><a id="10228" class="Symbol">)</a> <a id="10230" class="Symbol">:</a> <a id="10232" class="PrimitiveType">Set</a> <a id="10236" class="Symbol">(</a><a id="10237" href="#10195" class="Bound">a</a> <a id="10239" href="../code/probability/ProbabilityModule.Utils.html#242" class="Function Operator">‚äî</a> <a id="10241" href="#10197" class="Bound">‚Ñì</a> <a id="10243" href="../code/probability/ProbabilityModule.Utils.html#242" class="Function Operator">‚äî</a> <a id="10245" href="#1020" class="Bound">s</a><a id="10246" class="Symbol">)</a> <a id="10248" class="Keyword">where</a>
  <a id="10256" class="Keyword">constructor</a> <a id="‚üÖ_‚Üù_‚üÜ.elim"></a><a id="10268" href="#10268" class="InductiveConstructor">elim</a>
  <a id="10275" class="Keyword">field</a>
    <a id="‚üÖ_‚Üù_‚üÜ.‚üÖ_‚üÜ-set"></a><a id="10285" href="#10285" class="Field Operator">‚üÖ_‚üÜ-set</a> <a id="10293" class="Symbol">:</a> <a id="10295" class="Symbol">‚àÄ</a> <a id="10297" class="Symbol">{</a><a id="10298" href="#10298" class="Bound">xs</a><a id="10300" class="Symbol">}</a> <a id="10302" class="Symbol">‚Üí</a> <a id="10304" href="../code/probability/Cubical.Foundations.Prelude.html#5455" class="Function">isSet</a> <a id="10310" class="Symbol">(</a><a id="10311" href="#10213" class="Bound">P</a> <a id="10313" href="#10298" class="Bound">xs</a><a id="10315" class="Symbol">)</a>
    <a id="‚üÖ_‚Üù_‚üÜ.‚üÖ_‚üÜ[]"></a><a id="10321" href="#10321" class="Field Operator">‚üÖ_‚üÜ[]</a> <a id="10327" class="Symbol">:</a> <a id="10329" href="#10213" class="Bound">P</a> <a id="10331" href="#8715" class="InductiveConstructor">[]</a>
    <a id="‚üÖ_‚Üù_‚üÜ.‚üÖ_‚üÜ_&amp;_‚à∑_"></a><a id="10338" href="#10338" class="Field Operator">‚üÖ_‚üÜ_&amp;_‚à∑_</a> <a id="10347" class="Symbol">:</a> <a id="10349" class="Symbol">‚àÄ</a> <a id="10351" href="#10351" class="Bound">p</a> <a id="10353" href="#10353" class="Bound">x</a> <a id="10355" href="#10355" class="Bound">xs</a> <a id="10358" class="Symbol">‚Üí</a> <a id="10360" href="#10213" class="Bound">P</a> <a id="10362" href="#10355" class="Bound">xs</a> <a id="10365" class="Symbol">‚Üí</a> <a id="10367" href="#10213" class="Bound">P</a> <a id="10369" class="Symbol">(</a><a id="10370" href="#10351" class="Bound">p</a> <a id="10372" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="10374" href="#10353" class="Bound">x</a> <a id="10376" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="10378" href="#10355" class="Bound">xs</a><a id="10380" class="Symbol">)</a>
  <a id="10384" class="Keyword">private</a> <a id="‚üÖ_‚Üù_‚üÜ.z"></a><a id="10392" href="#10392" class="Function">z</a> <a id="10394" class="Symbol">=</a> <a id="10396" href="#10321" class="Field Operator">‚üÖ_‚üÜ[]</a><a id="10401" class="Symbol">;</a> <a id="‚üÖ_‚Üù_‚üÜ.f"></a><a id="10403" href="#10403" class="Function">f</a> <a id="10405" class="Symbol">=</a> <a id="10407" href="#10338" class="Field Operator">‚üÖ_‚üÜ_&amp;_‚à∑_</a>
  <a id="10418" class="Keyword">field</a>
    <a id="‚üÖ_‚Üù_‚üÜ.‚üÖ_‚üÜ-dup"></a><a id="10428" href="#10428" class="Field Operator">‚üÖ_‚üÜ-dup</a> <a id="10436" class="Symbol">:</a> <a id="10438" class="Symbol">(‚àÄ</a> <a id="10441" href="#10441" class="Bound">p</a> <a id="10443" href="#10443" class="Bound">q</a> <a id="10445" href="#10445" class="Bound">x</a> <a id="10447" href="#10447" class="Bound">xs</a> <a id="10450" href="#10450" class="Bound">pxs</a> <a id="10454" class="Symbol">‚Üí</a> <a id="10456" href="Agda.Builtin.Cubical.Path.html#162" class="Postulate">PathP</a> <a id="10462" class="Symbol">(Œª</a> <a id="10465" href="#10465" class="Bound">i</a> <a id="10467" class="Symbol">‚Üí</a> <a id="10469" href="#10213" class="Bound">P</a> <a id="10471" class="Symbol">(</a><a id="10472" href="#8767" class="InductiveConstructor">dup</a> <a id="10476" href="#10441" class="Bound">p</a> <a id="10478" href="#10443" class="Bound">q</a> <a id="10480" href="#10445" class="Bound">x</a> <a id="10482" href="#10447" class="Bound">xs</a> <a id="10485" href="#10465" class="Bound">i</a><a id="10486" class="Symbol">))</a>
              <a id="10503" class="Symbol">(</a><a id="10504" href="#10403" class="Function">f</a> <a id="10506" href="#10441" class="Bound">p</a> <a id="10508" href="#10445" class="Bound">x</a> <a id="10510" class="Symbol">(</a><a id="10511" href="#10443" class="Bound">q</a> <a id="10513" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="10515" href="#10445" class="Bound">x</a> <a id="10517" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="10519" href="#10447" class="Bound">xs</a><a id="10521" class="Symbol">)</a> <a id="10523" class="Symbol">(</a><a id="10524" href="#10403" class="Function">f</a> <a id="10526" href="#10443" class="Bound">q</a> <a id="10528" href="#10445" class="Bound">x</a> <a id="10530" href="#10447" class="Bound">xs</a> <a id="10533" href="#10450" class="Bound">pxs</a><a id="10536" class="Symbol">))</a> <a id="10539" class="Symbol">(</a><a id="10540" href="#10403" class="Function">f</a> <a id="10542" class="Symbol">(</a><a id="10543" href="#10441" class="Bound">p</a> <a id="10545" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="10547" href="#10443" class="Bound">q</a><a id="10548" class="Symbol">)</a> <a id="10550" href="#10445" class="Bound">x</a> <a id="10552" href="#10447" class="Bound">xs</a> <a id="10555" href="#10450" class="Bound">pxs</a><a id="10558" class="Symbol">))</a>
    <a id="‚üÖ_‚Üù_‚üÜ.‚üÖ_‚üÜ-com"></a><a id="10565" href="#10565" class="Field Operator">‚üÖ_‚üÜ-com</a> <a id="10573" class="Symbol">:</a> <a id="10575" class="Symbol">(‚àÄ</a> <a id="10578" href="#10578" class="Bound">p</a> <a id="10580" href="#10580" class="Bound">x</a> <a id="10582" href="#10582" class="Bound">q</a> <a id="10584" href="#10584" class="Bound">y</a> <a id="10586" href="#10586" class="Bound">xs</a> <a id="10589" href="#10589" class="Bound">pxs</a> <a id="10593" class="Symbol">‚Üí</a> <a id="10595" href="Agda.Builtin.Cubical.Path.html#162" class="Postulate">PathP</a> <a id="10601" class="Symbol">(Œª</a> <a id="10604" href="#10604" class="Bound">i</a> <a id="10606" class="Symbol">‚Üí</a> <a id="10608" href="#10213" class="Bound">P</a> <a id="10610" class="Symbol">(</a><a id="10611" href="#8824" class="InductiveConstructor">com</a> <a id="10615" href="#10578" class="Bound">p</a> <a id="10617" href="#10580" class="Bound">x</a> <a id="10619" href="#10582" class="Bound">q</a> <a id="10621" href="#10584" class="Bound">y</a> <a id="10623" href="#10586" class="Bound">xs</a> <a id="10626" href="#10604" class="Bound">i</a><a id="10627" class="Symbol">))</a>
              <a id="10644" class="Symbol">(</a><a id="10645" href="#10403" class="Function">f</a> <a id="10647" href="#10578" class="Bound">p</a> <a id="10649" href="#10580" class="Bound">x</a> <a id="10651" class="Symbol">(</a><a id="10652" href="#10582" class="Bound">q</a> <a id="10654" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="10656" href="#10584" class="Bound">y</a> <a id="10658" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="10660" href="#10586" class="Bound">xs</a><a id="10662" class="Symbol">)</a> <a id="10664" class="Symbol">(</a><a id="10665" href="#10403" class="Function">f</a> <a id="10667" href="#10582" class="Bound">q</a> <a id="10669" href="#10584" class="Bound">y</a> <a id="10671" href="#10586" class="Bound">xs</a> <a id="10674" href="#10589" class="Bound">pxs</a><a id="10677" class="Symbol">))</a> <a id="10680" class="Symbol">(</a><a id="10681" href="#10403" class="Function">f</a> <a id="10683" href="#10582" class="Bound">q</a> <a id="10685" href="#10584" class="Bound">y</a> <a id="10687" class="Symbol">(</a><a id="10688" href="#10578" class="Bound">p</a> <a id="10690" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="10692" href="#10580" class="Bound">x</a> <a id="10694" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="10696" href="#10586" class="Bound">xs</a><a id="10698" class="Symbol">)</a> <a id="10700" class="Symbol">(</a><a id="10701" href="#10403" class="Function">f</a> <a id="10703" href="#10578" class="Bound">p</a> <a id="10705" href="#10580" class="Bound">x</a> <a id="10707" href="#10586" class="Bound">xs</a> <a id="10710" href="#10589" class="Bound">pxs</a><a id="10713" class="Symbol">)))</a>
    <a id="‚üÖ_‚Üù_‚üÜ.‚üÖ_‚üÜ-del"></a><a id="10721" href="#10721" class="Field Operator">‚üÖ_‚üÜ-del</a> <a id="10729" class="Symbol">:</a> <a id="10731" class="Symbol">(‚àÄ</a> <a id="10734" href="#10734" class="Bound">x</a> <a id="10736" href="#10736" class="Bound">xs</a> <a id="10739" href="#10739" class="Bound">pxs</a> <a id="10743" class="Symbol">‚Üí</a> <a id="10745" href="Agda.Builtin.Cubical.Path.html#162" class="Postulate">PathP</a> <a id="10751" class="Symbol">(Œª</a> <a id="10754" href="#10754" class="Bound">i</a> <a id="10756" class="Symbol">‚Üí</a> <a id="10758" href="#10213" class="Bound">P</a> <a id="10760" class="Symbol">(</a><a id="10761" href="#8887" class="InductiveConstructor">del</a> <a id="10765" href="#10734" class="Bound">x</a> <a id="10767" href="#10736" class="Bound">xs</a> <a id="10770" href="#10754" class="Bound">i</a><a id="10771" class="Symbol">))</a>
              <a id="10788" class="Symbol">(</a><a id="10789" href="#10403" class="Function">f</a> <a id="10791" href="../code/probability/ProbabilityModule.Semirings.html#254" class="Field">0#</a> <a id="10794" href="#10734" class="Bound">x</a> <a id="10796" href="#10736" class="Bound">xs</a> <a id="10799" href="#10739" class="Bound">pxs</a><a id="10802" class="Symbol">)</a> <a id="10804" href="#10739" class="Bound">pxs</a><a id="10807" class="Symbol">)</a>
  <a id="‚üÖ_‚Üù_‚üÜ.‚üÖ_‚üÜ‚áì"></a><a id="10811" href="#10811" class="Function Operator">‚üÖ_‚üÜ‚áì</a> <a id="10816" class="Symbol">:</a> <a id="10818" class="Symbol">(</a><a id="10819" href="#10819" class="Bound">xs</a> <a id="10822" class="Symbol">:</a> <a id="10824" href="#8679" class="Datatype">ùí´</a> <a id="10826" href="#10201" class="Bound">A</a><a id="10827" class="Symbol">)</a> <a id="10829" class="Symbol">‚Üí</a> <a id="10831" href="#10213" class="Bound">P</a> <a id="10833" href="#10819" class="Bound">xs</a>
  <a id="10838" href="#10811" class="Function Operator">‚üÖ</a> <a id="10840" href="#8715" class="InductiveConstructor">[]</a> <a id="10843" href="#10811" class="Function Operator">‚üÜ‚áì</a> <a id="10846" class="Symbol">=</a> <a id="10848" href="#10392" class="Function">z</a>
  <a id="10852" href="#10811" class="Function Operator">‚üÖ</a> <a id="10854" href="#10854" class="Bound">p</a> <a id="10856" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="10858" href="#10858" class="Bound">x</a> <a id="10860" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="10862" href="#10862" class="Bound">xs</a> <a id="10865" href="#10811" class="Function Operator">‚üÜ‚áì</a> <a id="10868" class="Symbol">=</a> <a id="10870" href="#10403" class="Function">f</a> <a id="10872" href="#10854" class="Bound">p</a> <a id="10874" href="#10858" class="Bound">x</a> <a id="10876" href="#10862" class="Bound">xs</a> <a id="10879" href="#10811" class="Function Operator">‚üÖ</a> <a id="10881" href="#10862" class="Bound">xs</a> <a id="10884" href="#10811" class="Function Operator">‚üÜ‚áì</a>
  <a id="10889" href="#10811" class="Function Operator">‚üÖ</a> <a id="10891" href="#8767" class="InductiveConstructor">dup</a> <a id="10895" href="#10895" class="Bound">p</a> <a id="10897" href="#10897" class="Bound">q</a> <a id="10899" href="#10899" class="Bound">x</a> <a id="10901" href="#10901" class="Bound">xs</a> <a id="10904" href="#10904" class="Bound">i</a> <a id="10906" href="#10811" class="Function Operator">‚üÜ‚áì</a> <a id="10909" class="Symbol">=</a> <a id="10911" href="#10428" class="Field Operator">‚üÖ_‚üÜ-dup</a> <a id="10919" href="#10895" class="Bound">p</a> <a id="10921" href="#10897" class="Bound">q</a> <a id="10923" href="#10899" class="Bound">x</a> <a id="10925" href="#10901" class="Bound">xs</a> <a id="10928" href="#10811" class="Function Operator">‚üÖ</a> <a id="10930" href="#10901" class="Bound">xs</a> <a id="10933" href="#10811" class="Function Operator">‚üÜ‚áì</a> <a id="10936" href="#10904" class="Bound">i</a>
  <a id="10940" href="#10811" class="Function Operator">‚üÖ</a> <a id="10942" href="#8824" class="InductiveConstructor">com</a> <a id="10946" href="#10946" class="Bound">p</a> <a id="10948" href="#10948" class="Bound">x</a> <a id="10950" href="#10950" class="Bound">q</a> <a id="10952" href="#10952" class="Bound">y</a> <a id="10954" href="#10954" class="Bound">xs</a> <a id="10957" href="#10957" class="Bound">i</a> <a id="10959" href="#10811" class="Function Operator">‚üÜ‚áì</a> <a id="10962" class="Symbol">=</a> <a id="10964" href="#10565" class="Field Operator">‚üÖ_‚üÜ-com</a> <a id="10972" href="#10946" class="Bound">p</a> <a id="10974" href="#10948" class="Bound">x</a> <a id="10976" href="#10950" class="Bound">q</a> <a id="10978" href="#10952" class="Bound">y</a> <a id="10980" href="#10954" class="Bound">xs</a> <a id="10983" href="#10811" class="Function Operator">‚üÖ</a> <a id="10985" href="#10954" class="Bound">xs</a> <a id="10988" href="#10811" class="Function Operator">‚üÜ‚áì</a> <a id="10991" href="#10957" class="Bound">i</a>
  <a id="10995" href="#10811" class="Function Operator">‚üÖ</a> <a id="10997" href="#8887" class="InductiveConstructor">del</a> <a id="11001" href="#11001" class="Bound">x</a> <a id="11003" href="#11003" class="Bound">xs</a> <a id="11006" href="#11006" class="Bound">i</a> <a id="11008" href="#10811" class="Function Operator">‚üÜ‚áì</a> <a id="11011" class="Symbol">=</a> <a id="11013" href="#10721" class="Field Operator">‚üÖ_‚üÜ-del</a> <a id="11021" href="#11001" class="Bound">x</a> <a id="11023" href="#11003" class="Bound">xs</a> <a id="11026" href="#10811" class="Function Operator">‚üÖ</a> <a id="11028" href="#11003" class="Bound">xs</a> <a id="11031" href="#10811" class="Function Operator">‚üÜ‚áì</a> <a id="11034" href="#11006" class="Bound">i</a>
  <a id="11038" href="#10811" class="Function Operator">‚üÖ</a> <a id="11040" href="#8921" class="InductiveConstructor">trunc</a> <a id="11046" href="#11046" class="Bound">xs</a> <a id="11049" href="#11049" class="Bound">ys</a> <a id="11052" href="#11052" class="Bound">p</a> <a id="11054" href="#11054" class="Bound">q</a> <a id="11056" href="#11056" class="Bound">i</a> <a id="11058" href="#11058" class="Bound">j</a> <a id="11060" href="#10811" class="Function Operator">‚üÜ‚áì</a> <a id="11063" class="Symbol">=</a>
    <a id="11069" href="../code/probability/Cubical.HITs.SetTruncation.Properties.html#434" class="Function">elimSquash‚ÇÄ</a> <a id="11081" class="Symbol">(Œª</a> <a id="11084" href="#11084" class="Bound">xs</a> <a id="11087" class="Symbol">‚Üí</a> <a id="11089" href="#10285" class="Field Operator">‚üÖ_‚üÜ-set</a> <a id="11097" class="Symbol">{</a><a id="11098" href="#11084" class="Bound">xs</a><a id="11100" class="Symbol">})</a> <a id="11103" class="Symbol">(</a><a id="11104" href="#8921" class="InductiveConstructor">trunc</a> <a id="11110" href="#11046" class="Bound">xs</a> <a id="11113" href="#11049" class="Bound">ys</a> <a id="11116" href="#11052" class="Bound">p</a> <a id="11118" href="#11054" class="Bound">q</a><a id="11119" class="Symbol">)</a> <a id="11121" href="#10811" class="Function Operator">‚üÖ</a> <a id="11123" href="#11046" class="Bound">xs</a> <a id="11126" href="#10811" class="Function Operator">‚üÜ‚áì</a> <a id="11129" href="#10811" class="Function Operator">‚üÖ</a> <a id="11131" href="#11049" class="Bound">ys</a> <a id="11134" href="#10811" class="Function Operator">‚üÜ‚áì</a> <a id="11137" class="Symbol">(</a><a id="11138" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="11143" href="#10811" class="Function Operator">‚üÖ_‚üÜ‚áì</a> <a id="11148" href="#11052" class="Bound">p</a><a id="11149" class="Symbol">)</a> <a id="11151" class="Symbol">(</a><a id="11152" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="11157" href="#10811" class="Function Operator">‚üÖ_‚üÜ‚áì</a> <a id="11162" href="#11054" class="Bound">q</a><a id="11163" class="Symbol">)</a> <a id="11165" href="#11056" class="Bound">i</a> <a id="11167" href="#11058" class="Bound">j</a>

<a id="11170" class="Keyword">open</a> <a id="11175" href="#10188" class="Module Operator">‚üÖ_‚Üù_‚üÜ</a> <a id="11181" class="Keyword">public</a>
<a id="elim-syntax"></a><a id="11188" href="#11188" class="Function">elim-syntax</a> <a id="11200" class="Symbol">:</a> <a id="11202" class="Symbol">‚àÄ</a> <a id="11204" class="Symbol">{</a><a id="11205" href="#11205" class="Bound">a</a> <a id="11207" href="#11207" class="Bound">‚Ñì</a><a id="11208" class="Symbol">}</a> <a id="11210" class="Symbol">‚Üí</a> <a id="11212" class="Symbol">(</a><a id="11213" href="#11213" class="Bound">A</a> <a id="11215" class="Symbol">:</a> <a id="11217" class="PrimitiveType">Set</a> <a id="11221" href="#11205" class="Bound">a</a><a id="11222" class="Symbol">)</a> <a id="11224" class="Symbol">‚Üí</a> <a id="11226" class="Symbol">(</a><a id="11227" href="#8679" class="Datatype">ùí´</a> <a id="11229" href="#11213" class="Bound">A</a> <a id="11231" class="Symbol">‚Üí</a> <a id="11233" class="PrimitiveType">Set</a> <a id="11237" href="#11207" class="Bound">‚Ñì</a><a id="11238" class="Symbol">)</a> <a id="11240" class="Symbol">‚Üí</a> <a id="11242" class="PrimitiveType">Set</a> <a id="11246" class="Symbol">(</a><a id="11247" href="#11205" class="Bound">a</a> <a id="11249" href="../code/probability/ProbabilityModule.Utils.html#242" class="Function Operator">‚äî</a> <a id="11251" href="#11207" class="Bound">‚Ñì</a> <a id="11253" href="../code/probability/ProbabilityModule.Utils.html#242" class="Function Operator">‚äî</a> <a id="11255" href="#1020" class="Bound">s</a><a id="11256" class="Symbol">)</a>
<a id="11258" href="#11188" class="Function">elim-syntax</a> <a id="11270" class="Symbol">=</a> <a id="11272" href="#10188" class="Record Operator">‚üÖ_‚Üù_‚üÜ</a>

<a id="11279" class="Keyword">syntax</a> <a id="11286" href="#11188" class="Function">elim-syntax</a> <a id="11298" class="Bound">A</a> <a id="11300" class="Symbol">(Œª</a> <a id="11303" class="Bound">xs</a> <a id="11306" class="Symbol">‚Üí</a> <a id="11308" class="Bound">Pxs</a><a id="11311" class="Symbol">)</a> <a id="11313" class="Symbol">=</a> <a id="11315" class="Function">[</a> <a id="11317" class="Bound">xs</a> <a id="11320" class="Function">‚ààùí´</a> <a id="11323" class="Bound">A</a> <a id="11325" class="Function">‚Üù</a> <a id="11327" class="Bound">Pxs</a> <a id="11331" class="Function">]</a>

<a id="11334" class="Keyword">record</a> <a id="‚ü¶_‚áí_‚üß"></a><a id="11341" href="#11341" class="Record Operator">‚ü¶_‚áí_‚üß</a> <a id="11347" class="Symbol">{</a><a id="11348" href="#11348" class="Bound">a</a> <a id="11350" href="#11350" class="Bound">‚Ñì</a><a id="11351" class="Symbol">}</a> <a id="11353" class="Symbol">(</a><a id="11354" href="#11354" class="Bound">A</a> <a id="11356" class="Symbol">:</a> <a id="11358" class="PrimitiveType">Set</a> <a id="11362" href="#11348" class="Bound">a</a><a id="11363" class="Symbol">)</a> <a id="11365" class="Symbol">(</a><a id="11366" href="#11366" class="Bound">P</a> <a id="11368" class="Symbol">:</a> <a id="11370" href="#8679" class="Datatype">ùí´</a> <a id="11372" href="#11354" class="Bound">A</a> <a id="11374" class="Symbol">‚Üí</a> <a id="11376" class="PrimitiveType">Set</a> <a id="11380" href="#11350" class="Bound">‚Ñì</a><a id="11381" class="Symbol">)</a> <a id="11383" class="Symbol">:</a> <a id="11385" class="PrimitiveType">Set</a> <a id="11389" class="Symbol">(</a><a id="11390" href="#11348" class="Bound">a</a> <a id="11392" href="../code/probability/ProbabilityModule.Utils.html#242" class="Function Operator">‚äî</a> <a id="11394" href="#11350" class="Bound">‚Ñì</a> <a id="11396" href="../code/probability/ProbabilityModule.Utils.html#242" class="Function Operator">‚äî</a> <a id="11398" href="#1020" class="Bound">s</a><a id="11399" class="Symbol">)</a> <a id="11401" class="Keyword">where</a>
  <a id="11409" class="Keyword">constructor</a> <a id="‚ü¶_‚áí_‚üß.elim-prop"></a><a id="11421" href="#11421" class="InductiveConstructor">elim-prop</a>
  <a id="11433" class="Keyword">field</a>
    <a id="‚ü¶_‚áí_‚üß.‚ü¶_‚üß-prop"></a><a id="11443" href="#11443" class="Field Operator">‚ü¶_‚üß-prop</a> <a id="11452" class="Symbol">:</a> <a id="11454" class="Symbol">‚àÄ</a> <a id="11456" class="Symbol">{</a><a id="11457" href="#11457" class="Bound">xs</a><a id="11459" class="Symbol">}</a> <a id="11461" class="Symbol">‚Üí</a> <a id="11463" href="../code/probability/Cubical.Foundations.Prelude.html#5402" class="Function">isProp</a> <a id="11470" class="Symbol">(</a><a id="11471" href="#11366" class="Bound">P</a> <a id="11473" href="#11457" class="Bound">xs</a><a id="11475" class="Symbol">)</a>
    <a id="‚ü¶_‚áí_‚üß.‚ü¶_‚üß[]"></a><a id="11481" href="#11481" class="Field Operator">‚ü¶_‚üß[]</a> <a id="11487" class="Symbol">:</a> <a id="11489" href="#11366" class="Bound">P</a> <a id="11491" href="#8715" class="InductiveConstructor">[]</a>
    <a id="‚ü¶_‚áí_‚üß.‚ü¶_‚üß_&amp;_‚à∑_‚ü®_‚ü©"></a><a id="11498" href="#11498" class="Field Operator">‚ü¶_‚üß_&amp;_‚à∑_‚ü®_‚ü©</a> <a id="11510" class="Symbol">:</a> <a id="11512" class="Symbol">‚àÄ</a> <a id="11514" href="#11514" class="Bound">p</a> <a id="11516" href="#11516" class="Bound">x</a> <a id="11518" href="#11518" class="Bound">xs</a> <a id="11521" class="Symbol">‚Üí</a> <a id="11523" href="#11366" class="Bound">P</a> <a id="11525" href="#11518" class="Bound">xs</a> <a id="11528" class="Symbol">‚Üí</a> <a id="11530" href="#11366" class="Bound">P</a> <a id="11532" class="Symbol">(</a><a id="11533" href="#11514" class="Bound">p</a> <a id="11535" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="11537" href="#11516" class="Bound">x</a> <a id="11539" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="11541" href="#11518" class="Bound">xs</a><a id="11543" class="Symbol">)</a>
  <a id="11547" class="Keyword">private</a> <a id="‚ü¶_‚áí_‚üß.z"></a><a id="11555" href="#11555" class="Function">z</a> <a id="11557" class="Symbol">=</a> <a id="11559" href="#11481" class="Field Operator">‚ü¶_‚üß[]</a><a id="11564" class="Symbol">;</a> <a id="‚ü¶_‚áí_‚üß.f"></a><a id="11566" href="#11566" class="Function">f</a> <a id="11568" class="Symbol">=</a> <a id="11570" href="#11498" class="Field Operator">‚ü¶_‚üß_&amp;_‚à∑_‚ü®_‚ü©</a>
  <a id="‚ü¶_‚áí_‚üß.‚ü¶_‚üß‚áë"></a><a id="11584" href="#11584" class="Function Operator">‚ü¶_‚üß‚áë</a> <a id="11589" class="Symbol">=</a> <a id="11591" href="#10268" class="InductiveConstructor">elim</a>
          <a id="11606" class="Symbol">(</a><a id="11607" href="../code/probability/Cubical.Foundations.Prelude.html#6576" class="Function">isProp‚ÜíisSet</a> <a id="11620" href="#11443" class="Field Operator">‚ü¶_‚üß-prop</a><a id="11628" class="Symbol">)</a>
          <a id="11640" href="#11555" class="Function">z</a> <a id="11642" href="#11566" class="Function">f</a>
          <a id="11654" class="Symbol">(Œª</a> <a id="11657" href="#11657" class="Bound">p</a> <a id="11659" href="#11659" class="Bound">q</a> <a id="11661" href="#11661" class="Bound">x</a> <a id="11663" href="#11663" class="Bound">xs</a> <a id="11666" href="#11666" class="Bound">pxs</a> <a id="11670" class="Symbol">‚Üí</a>
            <a id="11684" href="../code/probability/Cubical.Foundations.Prelude.html#5003" class="Function">toPathP</a> <a id="11692" class="Symbol">(</a><a id="11693" href="#11443" class="Field Operator">‚ü¶_‚üß-prop</a> <a id="11702" class="Symbol">(</a><a id="11703" href="Agda.Primitive.Cubical.html#1279" class="Primitive">transp</a> <a id="11710" class="Symbol">(Œª</a> <a id="11713" href="#11713" class="Bound">i</a> <a id="11715" class="Symbol">‚Üí</a> <a id="11717" href="#11366" class="Bound">P</a> <a id="11719" class="Symbol">(</a><a id="11720" href="#8767" class="InductiveConstructor">dup</a> <a id="11724" href="#11657" class="Bound">p</a> <a id="11726" href="#11659" class="Bound">q</a> <a id="11728" href="#11661" class="Bound">x</a> <a id="11730" href="#11663" class="Bound">xs</a> <a id="11733" href="#11713" class="Bound">i</a><a id="11734" class="Symbol">))</a>
            <a id="11749" href="Agda.Primitive.Cubical.html#128" class="InductiveConstructor">i0</a>
            <a id="11764" class="Symbol">(</a><a id="11765" href="#11566" class="Function">f</a> <a id="11767" href="#11657" class="Bound">p</a> <a id="11769" href="#11661" class="Bound">x</a> <a id="11771" class="Symbol">(</a><a id="11772" href="#11659" class="Bound">q</a> <a id="11774" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="11776" href="#11661" class="Bound">x</a> <a id="11778" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="11780" href="#11663" class="Bound">xs</a><a id="11782" class="Symbol">)</a> <a id="11784" class="Symbol">(</a><a id="11785" href="#11566" class="Function">f</a> <a id="11787" href="#11659" class="Bound">q</a> <a id="11789" href="#11661" class="Bound">x</a> <a id="11791" href="#11663" class="Bound">xs</a> <a id="11794" href="#11666" class="Bound">pxs</a><a id="11797" class="Symbol">)))</a> <a id="11801" class="Symbol">(</a><a id="11802" href="#11566" class="Function">f</a> <a id="11804" class="Symbol">(</a><a id="11805" href="#11657" class="Bound">p</a> <a id="11807" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="11809" href="#11659" class="Bound">q</a><a id="11810" class="Symbol">)</a> <a id="11812" href="#11661" class="Bound">x</a> <a id="11814" href="#11663" class="Bound">xs</a> <a id="11817" href="#11666" class="Bound">pxs</a><a id="11820" class="Symbol">)</a> <a id="11822" class="Symbol">))</a>
          <a id="11835" class="Symbol">(Œª</a> <a id="11838" href="#11838" class="Bound">p</a> <a id="11840" href="#11840" class="Bound">x</a> <a id="11842" href="#11842" class="Bound">q</a> <a id="11844" href="#11844" class="Bound">y</a> <a id="11846" href="#11846" class="Bound">xs</a> <a id="11849" href="#11849" class="Bound">pxs</a> <a id="11853" class="Symbol">‚Üí</a> <a id="11855" href="../code/probability/Cubical.Foundations.Prelude.html#5003" class="Function">toPathP</a> <a id="11863" class="Symbol">(</a><a id="11864" href="#11443" class="Field Operator">‚ü¶_‚üß-prop</a> <a id="11873" class="Symbol">(</a><a id="11874" href="Agda.Primitive.Cubical.html#1279" class="Primitive">transp</a> <a id="11881" class="Symbol">(Œª</a> <a id="11884" href="#11884" class="Bound">i</a> <a id="11886" class="Symbol">‚Üí</a> <a id="11888" href="#11366" class="Bound">P</a> <a id="11890" class="Symbol">(</a><a id="11891" href="#8824" class="InductiveConstructor">com</a> <a id="11895" href="#11838" class="Bound">p</a> <a id="11897" href="#11840" class="Bound">x</a> <a id="11899" href="#11842" class="Bound">q</a> <a id="11901" href="#11844" class="Bound">y</a> <a id="11903" href="#11846" class="Bound">xs</a> <a id="11906" href="#11884" class="Bound">i</a><a id="11907" class="Symbol">))</a> <a id="11910" href="Agda.Primitive.Cubical.html#128" class="InductiveConstructor">i0</a>
            <a id="11925" class="Symbol">(</a><a id="11926" href="#11566" class="Function">f</a> <a id="11928" href="#11838" class="Bound">p</a> <a id="11930" href="#11840" class="Bound">x</a> <a id="11932" class="Symbol">(</a><a id="11933" href="#11842" class="Bound">q</a> <a id="11935" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="11937" href="#11844" class="Bound">y</a> <a id="11939" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="11941" href="#11846" class="Bound">xs</a><a id="11943" class="Symbol">)</a> <a id="11945" class="Symbol">(</a><a id="11946" href="#11566" class="Function">f</a> <a id="11948" href="#11842" class="Bound">q</a> <a id="11950" href="#11844" class="Bound">y</a> <a id="11952" href="#11846" class="Bound">xs</a> <a id="11955" href="#11849" class="Bound">pxs</a><a id="11958" class="Symbol">)))</a> <a id="11962" class="Symbol">(</a><a id="11963" href="#11566" class="Function">f</a> <a id="11965" href="#11842" class="Bound">q</a> <a id="11967" href="#11844" class="Bound">y</a> <a id="11969" class="Symbol">(</a><a id="11970" href="#11838" class="Bound">p</a> <a id="11972" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="11974" href="#11840" class="Bound">x</a> <a id="11976" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="11978" href="#11846" class="Bound">xs</a><a id="11980" class="Symbol">)</a> <a id="11982" class="Symbol">(</a><a id="11983" href="#11566" class="Function">f</a> <a id="11985" href="#11838" class="Bound">p</a> <a id="11987" href="#11840" class="Bound">x</a> <a id="11989" href="#11846" class="Bound">xs</a> <a id="11992" href="#11849" class="Bound">pxs</a><a id="11995" class="Symbol">))))</a>
            <a id="12012" class="Symbol">Œª</a> <a id="12014" href="#12014" class="Bound">x</a> <a id="12016" href="#12016" class="Bound">xs</a> <a id="12019" href="#12019" class="Bound">pxs</a> <a id="12023" class="Symbol">‚Üí</a> <a id="12025" href="../code/probability/Cubical.Foundations.Prelude.html#5003" class="Function">toPathP</a> <a id="12033" class="Symbol">(</a><a id="12034" href="#11443" class="Field Operator">‚ü¶_‚üß-prop</a> <a id="12043" class="Symbol">(</a><a id="12044" href="Agda.Primitive.Cubical.html#1279" class="Primitive">transp</a> <a id="12051" class="Symbol">(Œª</a> <a id="12054" href="#12054" class="Bound">i</a> <a id="12056" class="Symbol">‚Üí</a> <a id="12058" href="#11366" class="Bound">P</a> <a id="12060" class="Symbol">(</a><a id="12061" href="#8887" class="InductiveConstructor">del</a> <a id="12065" href="#12014" class="Bound">x</a> <a id="12067" href="#12016" class="Bound">xs</a> <a id="12070" href="#12054" class="Bound">i</a><a id="12071" class="Symbol">))</a> <a id="12074" href="Agda.Primitive.Cubical.html#128" class="InductiveConstructor">i0</a> <a id="12077" class="Symbol">((</a><a id="12079" href="#11566" class="Function">f</a> <a id="12081" href="../code/probability/ProbabilityModule.Semirings.html#254" class="Field">0#</a> <a id="12084" href="#12014" class="Bound">x</a> <a id="12086" href="#12016" class="Bound">xs</a> <a id="12089" href="#12019" class="Bound">pxs</a><a id="12092" class="Symbol">)))</a> <a id="12096" href="#12019" class="Bound">pxs</a><a id="12099" class="Symbol">)</a>
  <a id="‚ü¶_‚áí_‚üß.‚ü¶_‚üß‚áì"></a><a id="12103" href="#12103" class="Function Operator">‚ü¶_‚üß‚áì</a> <a id="12108" class="Symbol">=</a> <a id="12110" href="#10811" class="Function Operator">‚üÖ</a> <a id="12112" href="#11584" class="Function Operator">‚ü¶_‚üß‚áë</a> <a id="12117" href="#10811" class="Function Operator">‚üÜ‚áì</a>

<a id="12121" class="Keyword">open</a> <a id="12126" href="#11341" class="Module Operator">‚ü¶_‚áí_‚üß</a> <a id="12132" class="Keyword">public</a>
<a id="elim-prop-syntax"></a><a id="12139" href="#12139" class="Function">elim-prop-syntax</a> <a id="12156" class="Symbol">:</a> <a id="12158" class="Symbol">‚àÄ</a> <a id="12160" class="Symbol">{</a><a id="12161" href="#12161" class="Bound">a</a> <a id="12163" href="#12163" class="Bound">‚Ñì</a><a id="12164" class="Symbol">}</a> <a id="12166" class="Symbol">‚Üí</a> <a id="12168" class="Symbol">(</a><a id="12169" href="#12169" class="Bound">A</a> <a id="12171" class="Symbol">:</a> <a id="12173" class="PrimitiveType">Set</a> <a id="12177" href="#12161" class="Bound">a</a><a id="12178" class="Symbol">)</a> <a id="12180" class="Symbol">‚Üí</a> <a id="12182" class="Symbol">(</a><a id="12183" href="#8679" class="Datatype">ùí´</a> <a id="12185" href="#12169" class="Bound">A</a> <a id="12187" class="Symbol">‚Üí</a> <a id="12189" class="PrimitiveType">Set</a> <a id="12193" href="#12163" class="Bound">‚Ñì</a><a id="12194" class="Symbol">)</a> <a id="12196" class="Symbol">‚Üí</a> <a id="12198" class="PrimitiveType">Set</a> <a id="12202" class="Symbol">(</a><a id="12203" href="#12161" class="Bound">a</a> <a id="12205" href="../code/probability/ProbabilityModule.Utils.html#242" class="Function Operator">‚äî</a> <a id="12207" href="#12163" class="Bound">‚Ñì</a> <a id="12209" href="../code/probability/ProbabilityModule.Utils.html#242" class="Function Operator">‚äî</a> <a id="12211" href="#1020" class="Bound">s</a><a id="12212" class="Symbol">)</a>
<a id="12214" href="#12139" class="Function">elim-prop-syntax</a> <a id="12231" class="Symbol">=</a> <a id="12233" href="#11341" class="Record Operator">‚ü¶_‚áí_‚üß</a>

<a id="12240" class="Keyword">syntax</a> <a id="12247" href="#12139" class="Function">elim-prop-syntax</a> <a id="12264" class="Bound">A</a> <a id="12266" class="Symbol">(Œª</a> <a id="12269" class="Bound">xs</a> <a id="12272" class="Symbol">‚Üí</a> <a id="12274" class="Bound">Pxs</a><a id="12277" class="Symbol">)</a> <a id="12279" class="Symbol">=</a> <a id="12281" class="Function">‚ü¶</a> <a id="12283" class="Bound">xs</a> <a id="12286" class="Function">‚ààùí´</a> <a id="12289" class="Bound">A</a> <a id="12291" class="Function">‚áí</a> <a id="12293" class="Bound">Pxs</a> <a id="12297" class="Function">‚üß</a>

<a id="12300" class="Keyword">record</a> <a id="[_‚Ü¶_]"></a><a id="12307" href="#12307" class="Record Operator">[_‚Ü¶_]</a> <a id="12313" class="Symbol">{</a><a id="12314" href="#12314" class="Bound">a</a> <a id="12316" href="#12316" class="Bound">b</a><a id="12317" class="Symbol">}</a> <a id="12319" class="Symbol">(</a><a id="12320" href="#12320" class="Bound">A</a> <a id="12322" class="Symbol">:</a> <a id="12324" class="PrimitiveType">Set</a> <a id="12328" href="#12314" class="Bound">a</a><a id="12329" class="Symbol">)</a> <a id="12331" class="Symbol">(</a><a id="12332" href="#12332" class="Bound">B</a> <a id="12334" class="Symbol">:</a> <a id="12336" class="PrimitiveType">Set</a> <a id="12340" href="#12316" class="Bound">b</a><a id="12341" class="Symbol">)</a> <a id="12343" class="Symbol">:</a> <a id="12345" class="PrimitiveType">Set</a> <a id="12349" class="Symbol">(</a><a id="12350" href="#12314" class="Bound">a</a> <a id="12352" href="../code/probability/ProbabilityModule.Utils.html#242" class="Function Operator">‚äî</a> <a id="12354" href="#12316" class="Bound">b</a> <a id="12356" href="../code/probability/ProbabilityModule.Utils.html#242" class="Function Operator">‚äî</a> <a id="12358" href="#1020" class="Bound">s</a><a id="12359" class="Symbol">)</a> <a id="12361" class="Keyword">where</a>
  <a id="12369" class="Keyword">constructor</a> <a id="[_‚Ü¶_].rec"></a><a id="12381" href="#12381" class="InductiveConstructor">rec</a>
  <a id="12387" class="Keyword">field</a>
    <a id="[_‚Ü¶_].[_]-set"></a><a id="12397" href="#12397" class="Field Operator">[_]-set</a>  <a id="12406" class="Symbol">:</a> <a id="12408" href="../code/probability/Cubical.Foundations.Prelude.html#5455" class="Function">isSet</a> <a id="12414" href="#12332" class="Bound">B</a>
    <a id="[_‚Ü¶_].[_]_&amp;_‚à∑_"></a><a id="12420" href="#12420" class="Field Operator">[_]_&amp;_‚à∑_</a> <a id="12429" class="Symbol">:</a> <a id="12431" href="../code/probability/ProbabilityModule.Semirings.html#200" class="Field">R</a> <a id="12433" class="Symbol">‚Üí</a> <a id="12435" href="#12320" class="Bound">A</a> <a id="12437" class="Symbol">‚Üí</a> <a id="12439" href="#12332" class="Bound">B</a> <a id="12441" class="Symbol">‚Üí</a> <a id="12443" href="#12332" class="Bound">B</a>
    <a id="[_‚Ü¶_].[_][]"></a><a id="12449" href="#12449" class="Field Operator">[_][]</a>    <a id="12458" class="Symbol">:</a> <a id="12460" href="#12332" class="Bound">B</a>
  <a id="12464" class="Keyword">private</a> <a id="[_‚Ü¶_].f"></a><a id="12472" href="#12472" class="Function">f</a> <a id="12474" class="Symbol">=</a> <a id="12476" href="#12420" class="Field Operator">[_]_&amp;_‚à∑_</a><a id="12484" class="Symbol">;</a> <a id="[_‚Ü¶_].z"></a><a id="12486" href="#12486" class="Function">z</a> <a id="12488" class="Symbol">=</a> <a id="12490" href="#12449" class="Field Operator">[_][]</a>
  <a id="12498" class="Keyword">field</a>
    <a id="[_‚Ü¶_].[_]-dup"></a><a id="12508" href="#12508" class="Field Operator">[_]-dup</a>  <a id="12517" class="Symbol">:</a> <a id="12519" class="Symbol">‚àÄ</a> <a id="12521" href="#12521" class="Bound">p</a> <a id="12523" href="#12523" class="Bound">q</a> <a id="12525" href="#12525" class="Bound">x</a> <a id="12527" href="#12527" class="Bound">xs</a> <a id="12530" class="Symbol">‚Üí</a> <a id="12532" href="#12472" class="Function">f</a> <a id="12534" href="#12521" class="Bound">p</a> <a id="12536" href="#12525" class="Bound">x</a> <a id="12538" class="Symbol">(</a><a id="12539" href="#12472" class="Function">f</a> <a id="12541" href="#12523" class="Bound">q</a> <a id="12543" href="#12525" class="Bound">x</a> <a id="12545" href="#12527" class="Bound">xs</a><a id="12547" class="Symbol">)</a> <a id="12549" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">‚â°</a> <a id="12551" href="#12472" class="Function">f</a> <a id="12553" class="Symbol">(</a><a id="12554" href="#12521" class="Bound">p</a> <a id="12556" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="12558" href="#12523" class="Bound">q</a><a id="12559" class="Symbol">)</a> <a id="12561" href="#12525" class="Bound">x</a> <a id="12563" href="#12527" class="Bound">xs</a>
    <a id="[_‚Ü¶_].[_]-com"></a><a id="12570" href="#12570" class="Field Operator">[_]-com</a> <a id="12578" class="Symbol">:</a> <a id="12580" class="Symbol">‚àÄ</a> <a id="12582" href="#12582" class="Bound">p</a> <a id="12584" href="#12584" class="Bound">x</a> <a id="12586" href="#12586" class="Bound">q</a> <a id="12588" href="#12588" class="Bound">y</a> <a id="12590" href="#12590" class="Bound">xs</a> <a id="12593" class="Symbol">‚Üí</a> <a id="12595" href="#12472" class="Function">f</a> <a id="12597" href="#12582" class="Bound">p</a> <a id="12599" href="#12584" class="Bound">x</a> <a id="12601" class="Symbol">(</a><a id="12602" href="#12472" class="Function">f</a> <a id="12604" href="#12586" class="Bound">q</a> <a id="12606" href="#12588" class="Bound">y</a> <a id="12608" href="#12590" class="Bound">xs</a><a id="12610" class="Symbol">)</a> <a id="12612" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">‚â°</a> <a id="12614" href="#12472" class="Function">f</a> <a id="12616" href="#12586" class="Bound">q</a> <a id="12618" href="#12588" class="Bound">y</a> <a id="12620" class="Symbol">(</a><a id="12621" href="#12472" class="Function">f</a> <a id="12623" href="#12582" class="Bound">p</a> <a id="12625" href="#12584" class="Bound">x</a> <a id="12627" href="#12590" class="Bound">xs</a><a id="12629" class="Symbol">)</a>
    <a id="[_‚Ü¶_].[_]-del"></a><a id="12635" href="#12635" class="Field Operator">[_]-del</a> <a id="12643" class="Symbol">:</a> <a id="12645" class="Symbol">‚àÄ</a> <a id="12647" href="#12647" class="Bound">x</a> <a id="12649" href="#12649" class="Bound">xs</a> <a id="12652" class="Symbol">‚Üí</a> <a id="12654" href="#12472" class="Function">f</a> <a id="12656" href="../code/probability/ProbabilityModule.Semirings.html#254" class="Field">0#</a> <a id="12659" href="#12647" class="Bound">x</a> <a id="12661" href="#12649" class="Bound">xs</a> <a id="12664" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">‚â°</a> <a id="12666" href="#12649" class="Bound">xs</a>
  <a id="[_‚Ü¶_].[_]‚áë"></a><a id="12671" href="#12671" class="Function Operator">[_]‚áë</a> <a id="12676" class="Symbol">=</a> <a id="12678" href="#10268" class="InductiveConstructor">elim</a>
            <a id="12695" href="#12397" class="Field Operator">[_]-set</a>
            <a id="12715" href="#12486" class="Function">z</a>
            <a id="12729" class="Symbol">(Œª</a> <a id="12732" href="#12732" class="Bound">p</a> <a id="12734" href="#12734" class="Bound">x</a> <a id="12736" href="#12736" class="Bound">_</a> <a id="12738" href="#12738" class="Bound">xs</a> <a id="12741" class="Symbol">‚Üí</a> <a id="12743" href="#12472" class="Function">f</a> <a id="12745" href="#12732" class="Bound">p</a> <a id="12747" href="#12734" class="Bound">x</a> <a id="12749" href="#12738" class="Bound">xs</a><a id="12751" class="Symbol">)</a>
            <a id="12765" class="Symbol">(Œª</a> <a id="12768" href="#12768" class="Bound">p</a> <a id="12770" href="#12770" class="Bound">q</a> <a id="12772" href="#12772" class="Bound">x</a> <a id="12774" href="#12774" class="Bound">xs</a> <a id="12777" class="Symbol">‚Üí</a> <a id="12779" href="#12508" class="Field Operator">[_]-dup</a> <a id="12787" href="#12768" class="Bound">p</a> <a id="12789" href="#12770" class="Bound">q</a> <a id="12791" href="#12772" class="Bound">x</a><a id="12792" class="Symbol">)</a>
            <a id="12806" class="Symbol">(Œª</a> <a id="12809" href="#12809" class="Bound">p</a> <a id="12811" href="#12811" class="Bound">x</a> <a id="12813" href="#12813" class="Bound">q</a> <a id="12815" href="#12815" class="Bound">y</a> <a id="12817" href="#12817" class="Bound">xs</a> <a id="12820" class="Symbol">‚Üí</a> <a id="12822" href="#12570" class="Field Operator">[_]-com</a> <a id="12830" href="#12809" class="Bound">p</a> <a id="12832" href="#12811" class="Bound">x</a> <a id="12834" href="#12813" class="Bound">q</a> <a id="12836" href="#12815" class="Bound">y</a><a id="12837" class="Symbol">)</a>
            <a id="12851" class="Symbol">(Œª</a> <a id="12854" href="#12854" class="Bound">x</a> <a id="12856" href="#12856" class="Bound">xs</a> <a id="12859" class="Symbol">‚Üí</a> <a id="12861" href="#12635" class="Field Operator">[_]-del</a> <a id="12869" href="#12854" class="Bound">x</a><a id="12870" class="Symbol">)</a>
  <a id="[_‚Ü¶_].[_]‚Üì"></a><a id="12874" href="#12874" class="Function Operator">[_]‚Üì</a> <a id="12879" class="Symbol">=</a> <a id="12881" href="#10811" class="Function Operator">‚üÖ</a> <a id="12883" href="#12671" class="Function Operator">[_]‚áë</a> <a id="12888" href="#10811" class="Function Operator">‚üÜ‚áì</a>
<a id="12891" class="Keyword">open</a> <a id="12896" href="#12307" class="Module Operator">[_‚Ü¶_]</a> <a id="12902" class="Keyword">public</a>
</pre>
</details>
<p>Here‚Äôs one in action, to define <code>map</code>:</p>
<pre class="Agda"><a id="map"></a><a id="12972" href="#12972" class="Function">map</a> <a id="12976" class="Symbol">:</a> <a id="12978" class="Symbol">(</a><a id="12979" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="12981" class="Symbol">‚Üí</a> <a id="12983" href="../code/probability/ProbabilityModule.Utils.html#206" class="Generalizable">B</a><a id="12984" class="Symbol">)</a> <a id="12986" class="Symbol">‚Üí</a> <a id="12988" href="#8679" class="Datatype">ùí´</a> <a id="12990" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="12992" class="Symbol">‚Üí</a> <a id="12994" href="#8679" class="Datatype">ùí´</a> <a id="12996" href="../code/probability/ProbabilityModule.Utils.html#206" class="Generalizable">B</a>
<a id="12998" href="#12972" class="Function">map</a> <a id="13002" class="Symbol">=</a> <a id="13004" class="Symbol">Œª</a> <a id="13006" href="#13006" class="Bound">f</a> <a id="13008" class="Symbol">‚Üí</a> <a id="13010" href="#12874" class="Function Operator">[</a> <a id="13012" href="#13043" class="Function">map‚Ä≤</a> <a id="13017" href="#13006" class="Bound">f</a> <a id="13019" href="#12874" class="Function Operator">]‚Üì</a>
  <a id="13024" class="Keyword">module</a> <a id="Map"></a><a id="13031" href="#13031" class="Module">Map</a> <a id="13035" class="Keyword">where</a>
  <a id="Map.map‚Ä≤"></a><a id="13043" href="#13043" class="Function">map‚Ä≤</a> <a id="13048" class="Symbol">:</a> <a id="13050" class="Symbol">(</a><a id="13051" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="13053" class="Symbol">‚Üí</a> <a id="13055" href="../code/probability/ProbabilityModule.Utils.html#206" class="Generalizable">B</a><a id="13056" class="Symbol">)</a> <a id="13058" class="Symbol">‚Üí</a> <a id="13060" href="#12307" class="Record Operator">[</a> <a id="13062" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="13064" href="#12307" class="Record Operator">‚Ü¶</a> <a id="13066" href="#8679" class="Datatype">ùí´</a> <a id="13068" href="../code/probability/ProbabilityModule.Utils.html#206" class="Generalizable">B</a> <a id="13070" href="#12307" class="Record Operator">]</a>
  <a id="13074" href="#12420" class="Field Operator">[</a> <a id="13076" href="#13043" class="Function">map‚Ä≤</a> <a id="13081" href="#13081" class="Bound">f</a> <a id="13083" href="#12420" class="Field Operator">]</a> <a id="13085" href="#13085" class="Bound">p</a> <a id="13087" href="#12420" class="Field Operator">&amp;</a> <a id="13089" href="#13089" class="Bound">x</a> <a id="13091" href="#12420" class="Field Operator">‚à∑</a> <a id="13093" href="#13093" class="Bound">xs</a> <a id="13096" class="Symbol">=</a> <a id="13098" href="#13085" class="Bound">p</a> <a id="13100" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="13102" href="#13081" class="Bound">f</a> <a id="13104" href="#13089" class="Bound">x</a> <a id="13106" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="13108" href="#13093" class="Bound">xs</a>
  <a id="13113" href="#12449" class="Field Operator">[</a> <a id="13115" href="#13043" class="Function">map‚Ä≤</a> <a id="13120" href="#13120" class="Bound">f</a> <a id="13122" href="#12449" class="Field Operator">][]</a> <a id="13126" class="Symbol">=</a> <a id="13128" href="#8715" class="InductiveConstructor">[]</a>
  <a id="13133" href="#12397" class="Field Operator">[</a> <a id="13135" href="#13043" class="Function">map‚Ä≤</a> <a id="13140" href="#13140" class="Bound">f</a> <a id="13142" href="#12397" class="Field Operator">]-set</a> <a id="13148" class="Symbol">=</a> <a id="13150" href="#8921" class="InductiveConstructor">trunc</a>
  <a id="13158" href="#12508" class="Field Operator">[</a> <a id="13160" href="#13043" class="Function">map‚Ä≤</a> <a id="13165" href="#13165" class="Bound">f</a> <a id="13167" href="#12508" class="Field Operator">]-dup</a> <a id="13173" href="#13173" class="Bound">p</a> <a id="13175" href="#13175" class="Bound">q</a> <a id="13177" href="#13177" class="Bound">x</a> <a id="13179" href="#13179" class="Bound">xs</a> <a id="13182" class="Symbol">=</a> <a id="13184" href="#8767" class="InductiveConstructor">dup</a> <a id="13188" href="#13173" class="Bound">p</a> <a id="13190" href="#13175" class="Bound">q</a> <a id="13192" class="Symbol">(</a><a id="13193" href="#13165" class="Bound">f</a> <a id="13195" href="#13177" class="Bound">x</a><a id="13196" class="Symbol">)</a> <a id="13198" href="#13179" class="Bound">xs</a>
  <a id="13203" href="#12570" class="Field Operator">[</a> <a id="13205" href="#13043" class="Function">map‚Ä≤</a> <a id="13210" href="#13210" class="Bound">f</a> <a id="13212" href="#12570" class="Field Operator">]-com</a> <a id="13218" href="#13218" class="Bound">p</a> <a id="13220" href="#13220" class="Bound">x</a> <a id="13222" href="#13222" class="Bound">q</a> <a id="13224" href="#13224" class="Bound">y</a> <a id="13226" href="#13226" class="Bound">xs</a> <a id="13229" class="Symbol">=</a> <a id="13231" href="#8824" class="InductiveConstructor">com</a> <a id="13235" href="#13218" class="Bound">p</a> <a id="13237" class="Symbol">(</a><a id="13238" href="#13210" class="Bound">f</a> <a id="13240" href="#13220" class="Bound">x</a><a id="13241" class="Symbol">)</a> <a id="13243" href="#13222" class="Bound">q</a> <a id="13245" class="Symbol">(</a><a id="13246" href="#13210" class="Bound">f</a> <a id="13248" href="#13224" class="Bound">y</a><a id="13249" class="Symbol">)</a> <a id="13251" href="#13226" class="Bound">xs</a>
  <a id="13256" href="#12635" class="Field Operator">[</a> <a id="13258" href="#13043" class="Function">map‚Ä≤</a> <a id="13263" href="#13263" class="Bound">f</a> <a id="13265" href="#12635" class="Field Operator">]-del</a> <a id="13271" href="#13271" class="Bound">x</a> <a id="13273" href="#13273" class="Bound">xs</a> <a id="13276" class="Symbol">=</a> <a id="13278" href="#8887" class="InductiveConstructor">del</a> <a id="13282" class="Symbol">(</a><a id="13283" href="#13263" class="Bound">f</a> <a id="13285" href="#13271" class="Bound">x</a><a id="13286" class="Symbol">)</a> <a id="13288" href="#13273" class="Bound">xs</a>
</pre>
<p>And here‚Äôs how we‚Äôd define union, and then prove that it‚Äôs associative:</p>
<pre class="Agda"><a id="13377" class="Keyword">infixr</a> <a id="13384" class="Number">5</a> <a id="13386" href="#13390" class="Function Operator">_‚à™_</a>
<a id="_‚à™_"></a><a id="13390" href="#13390" class="Function Operator">_‚à™_</a> <a id="13394" class="Symbol">:</a> <a id="13396" href="#8679" class="Datatype">ùí´</a> <a id="13398" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="13400" class="Symbol">‚Üí</a> <a id="13402" href="#8679" class="Datatype">ùí´</a> <a id="13404" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="13406" class="Symbol">‚Üí</a> <a id="13408" href="#8679" class="Datatype">ùí´</a> <a id="13410" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a>
<a id="13412" href="#13390" class="Function Operator">_‚à™_</a> <a id="13416" class="Symbol">=</a> <a id="13418" class="Symbol">Œª</a> <a id="13420" href="#13420" class="Bound">xs</a> <a id="13423" href="#13423" class="Bound">ys</a> <a id="13426" class="Symbol">‚Üí</a> <a id="13428" href="#12874" class="Function Operator">[</a> <a id="13430" href="#13468" class="Function">union</a> <a id="13436" href="#13423" class="Bound">ys</a> <a id="13439" href="#12874" class="Function Operator">]‚Üì</a> <a id="13442" href="#13420" class="Bound">xs</a>
  <a id="13447" class="Keyword">module</a> <a id="Union"></a><a id="13454" href="#13454" class="Module">Union</a> <a id="13460" class="Keyword">where</a>
  <a id="Union.union"></a><a id="13468" href="#13468" class="Function">union</a> <a id="13474" class="Symbol">:</a> <a id="13476" href="#8679" class="Datatype">ùí´</a> <a id="13478" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="13480" class="Symbol">‚Üí</a> <a id="13482" href="#12307" class="Record Operator">[</a> <a id="13484" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="13486" href="#12307" class="Record Operator">‚Ü¶</a> <a id="13488" href="#8679" class="Datatype">ùí´</a> <a id="13490" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="13492" href="#12307" class="Record Operator">]</a>
  <a id="13496" href="#12397" class="Field Operator">[</a> <a id="13498" href="#13468" class="Function">union</a> <a id="13504" href="#13504" class="Bound">ys</a> <a id="13507" href="#12397" class="Field Operator">]-set</a> <a id="13513" class="Symbol">=</a> <a id="13515" href="#8921" class="InductiveConstructor">trunc</a>
  <a id="13523" href="#12420" class="Field Operator">[</a> <a id="13525" href="#13468" class="Function">union</a> <a id="13531" href="#13531" class="Bound">ys</a> <a id="13534" href="#12420" class="Field Operator">]</a> <a id="13536" href="#13536" class="Bound">p</a> <a id="13538" href="#12420" class="Field Operator">&amp;</a> <a id="13540" href="#13540" class="Bound">x</a> <a id="13542" href="#12420" class="Field Operator">‚à∑</a> <a id="13544" href="#13544" class="Bound">xs</a> <a id="13547" class="Symbol">=</a> <a id="13549" href="#13536" class="Bound">p</a> <a id="13551" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="13553" href="#13540" class="Bound">x</a> <a id="13555" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="13557" href="#13544" class="Bound">xs</a>
  <a id="13562" href="#12449" class="Field Operator">[</a> <a id="13564" href="#13468" class="Function">union</a> <a id="13570" href="#13570" class="Bound">ys</a> <a id="13573" href="#12449" class="Field Operator">][]</a> <a id="13577" class="Symbol">=</a> <a id="13579" href="#13570" class="Bound">ys</a>
  <a id="13584" href="#12508" class="Field Operator">[</a> <a id="13586" href="#13468" class="Function">union</a> <a id="13592" href="#13592" class="Bound">ys</a> <a id="13595" href="#12508" class="Field Operator">]-dup</a> <a id="13601" class="Symbol">=</a> <a id="13603" href="#8767" class="InductiveConstructor">dup</a>
  <a id="13609" href="#12570" class="Field Operator">[</a> <a id="13611" href="#13468" class="Function">union</a> <a id="13617" href="#13617" class="Bound">ys</a> <a id="13620" href="#12570" class="Field Operator">]-com</a> <a id="13626" class="Symbol">=</a> <a id="13628" href="#8824" class="InductiveConstructor">com</a>
  <a id="13634" href="#12635" class="Field Operator">[</a> <a id="13636" href="#13468" class="Function">union</a> <a id="13642" href="#13642" class="Bound">ys</a> <a id="13645" href="#12635" class="Field Operator">]-del</a> <a id="13651" class="Symbol">=</a> <a id="13653" href="#8887" class="InductiveConstructor">del</a>

<a id="‚à™-assoc"></a><a id="13658" href="#13658" class="Function">‚à™-assoc</a> <a id="13666" class="Symbol">:</a> <a id="13668" class="Symbol">(</a><a id="13669" href="#13669" class="Bound">xs</a> <a id="13672" href="#13672" class="Bound">ys</a> <a id="13675" href="#13675" class="Bound">zs</a> <a id="13678" class="Symbol">:</a> <a id="13680" href="#8679" class="Datatype">ùí´</a> <a id="13682" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a><a id="13683" class="Symbol">)</a> <a id="13685" class="Symbol">‚Üí</a> <a id="13687" href="#13669" class="Bound">xs</a> <a id="13690" href="#13390" class="Function Operator">‚à™</a> <a id="13692" class="Symbol">(</a><a id="13693" href="#13672" class="Bound">ys</a> <a id="13696" href="#13390" class="Function Operator">‚à™</a> <a id="13698" href="#13675" class="Bound">zs</a><a id="13700" class="Symbol">)</a> <a id="13702" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">‚â°</a> <a id="13704" class="Symbol">(</a><a id="13705" href="#13669" class="Bound">xs</a> <a id="13708" href="#13390" class="Function Operator">‚à™</a> <a id="13710" href="#13672" class="Bound">ys</a><a id="13712" class="Symbol">)</a> <a id="13714" href="#13390" class="Function Operator">‚à™</a> <a id="13716" href="#13675" class="Bound">zs</a>
<a id="13719" href="#13658" class="Function">‚à™-assoc</a> <a id="13727" class="Symbol">=</a> <a id="13729" class="Symbol">Œª</a> <a id="13731" href="#13731" class="Bound">xs</a> <a id="13734" href="#13734" class="Bound">ys</a> <a id="13737" href="#13737" class="Bound">zs</a> <a id="13740" class="Symbol">‚Üí</a> <a id="13742" href="#12103" class="Function Operator">‚ü¶</a> <a id="13744" href="#13789" class="Function">‚à™-assoc‚Ä≤</a> <a id="13753" href="#13734" class="Bound">ys</a> <a id="13756" href="#13737" class="Bound">zs</a> <a id="13759" href="#12103" class="Function Operator">‚üß‚áì</a> <a id="13762" href="#13731" class="Bound">xs</a>
  <a id="13767" class="Keyword">module</a> <a id="UAssoc"></a><a id="13774" href="#13774" class="Module">UAssoc</a> <a id="13781" class="Keyword">where</a>
  <a id="UAssoc.‚à™-assoc‚Ä≤"></a><a id="13789" href="#13789" class="Function">‚à™-assoc‚Ä≤</a> <a id="13798" class="Symbol">:</a> <a id="13800" class="Symbol">‚àÄ</a> <a id="13802" href="#13802" class="Bound">ys</a> <a id="13805" href="#13805" class="Bound">zs</a> <a id="13808" class="Symbol">‚Üí</a> <a id="13810" href="#12139" class="Function">‚ü¶</a> <a id="13812" href="#13812" class="Bound">xs</a> <a id="13815" href="#12139" class="Function">‚ààùí´</a> <a id="13818" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="13820" href="#12139" class="Function">‚áí</a> <a id="13822" href="#13812" class="Bound">xs</a> <a id="13825" href="#13390" class="Function Operator">‚à™</a> <a id="13827" class="Symbol">(</a><a id="13828" href="#13802" class="Bound">ys</a> <a id="13831" href="#13390" class="Function Operator">‚à™</a> <a id="13833" href="#13805" class="Bound">zs</a><a id="13835" class="Symbol">)</a> <a id="13837" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">‚â°</a> <a id="13839" class="Symbol">(</a><a id="13840" href="#13812" class="Bound">xs</a> <a id="13843" href="#13390" class="Function Operator">‚à™</a> <a id="13845" href="#13802" class="Bound">ys</a><a id="13847" class="Symbol">)</a> <a id="13849" href="#13390" class="Function Operator">‚à™</a> <a id="13851" href="#13805" class="Bound">zs</a> <a id="13854" href="#12139" class="Function">‚üß</a>
  <a id="13858" href="#11443" class="Field Operator">‚ü¶</a> <a id="13860" href="#13789" class="Function">‚à™-assoc‚Ä≤</a> <a id="13869" href="#13869" class="Bound">ys</a> <a id="13872" href="#13872" class="Bound">zs</a> <a id="13875" href="#11443" class="Field Operator">‚üß-prop</a> <a id="13882" class="Symbol">=</a> <a id="13884" href="#8921" class="InductiveConstructor">trunc</a> <a id="13890" class="Symbol">_</a> <a id="13892" class="Symbol">_</a>
  <a id="13896" href="#11481" class="Field Operator">‚ü¶</a> <a id="13898" href="#13789" class="Function">‚à™-assoc‚Ä≤</a> <a id="13907" href="#13907" class="Bound">ys</a> <a id="13910" href="#13910" class="Bound">zs</a> <a id="13913" href="#11481" class="Field Operator">‚üß[]</a> <a id="13917" class="Symbol">=</a> <a id="13919" href="../code/probability/Cubical.Foundations.Prelude.html#827" class="Function">refl</a>
  <a id="13926" href="#11498" class="Field Operator">‚ü¶</a> <a id="13928" href="#13789" class="Function">‚à™-assoc‚Ä≤</a> <a id="13937" href="#13937" class="Bound">ys</a> <a id="13940" href="#13940" class="Bound">zs</a> <a id="13943" href="#11498" class="Field Operator">‚üß</a> <a id="13945" href="#13945" class="Bound">p</a> <a id="13947" href="#11498" class="Field Operator">&amp;</a> <a id="13949" href="#13949" class="Bound">x</a> <a id="13951" href="#11498" class="Field Operator">‚à∑</a> <a id="13953" href="#13953" class="Bound">xs</a> <a id="13956" href="#11498" class="Field Operator">‚ü®</a> <a id="13958" href="#13958" class="Bound">P</a> <a id="13960" href="#11498" class="Field Operator">‚ü©</a> <a id="13962" class="Symbol">=</a> <a id="13964" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="13969" class="Symbol">(</a><a id="13970" href="#13945" class="Bound">p</a> <a id="13972" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="13974" href="#13949" class="Bound">x</a> <a id="13976" href="#8727" class="InductiveConstructor Operator">‚à∑_</a><a id="13978" class="Symbol">)</a> <a id="13980" href="#13958" class="Bound">P</a>
</pre>
<p>There‚Äôs a lot more stuff here that I won‚Äôt bore you with.</p>
<details>
<summary>Boring Stuff</summary>
<pre class="Agda"><a id="14096" class="Keyword">infixl</a> <a id="14103" class="Number">7</a> <a id="14105" href="#14109" class="Function Operator">_‚ãä_</a>
<a id="_‚ãä_"></a><a id="14109" href="#14109" class="Function Operator">_‚ãä_</a> <a id="14113" class="Symbol">:</a> <a id="14115" href="../code/probability/ProbabilityModule.Semirings.html#200" class="Field">R</a> <a id="14117" class="Symbol">‚Üí</a> <a id="14119" href="#8679" class="Datatype">ùí´</a> <a id="14121" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="14123" class="Symbol">‚Üí</a> <a id="14125" href="#8679" class="Datatype">ùí´</a> <a id="14127" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a>
<a id="14129" href="#14109" class="Function Operator">_‚ãä_</a> <a id="14133" class="Symbol">=</a> <a id="14135" class="Symbol">Œª</a> <a id="14137" href="#14137" class="Bound">p</a> <a id="14139" class="Symbol">‚Üí</a> <a id="14141" href="#12874" class="Function Operator">[</a> <a id="14143" href="#14137" class="Bound">p</a> <a id="14145" href="#14173" class="Function Operator">‚ãä‚Ä≤</a> <a id="14148" href="#12874" class="Function Operator">]‚Üì</a>
  <a id="14153" class="Keyword">module</a> <a id="Cond"></a><a id="14160" href="#14160" class="Module">Cond</a> <a id="14165" class="Keyword">where</a>
  <a id="Cond._‚ãä‚Ä≤"></a><a id="14173" href="#14173" class="Function Operator">_‚ãä‚Ä≤</a> <a id="14177" class="Symbol">:</a> <a id="14179" href="../code/probability/ProbabilityModule.Semirings.html#200" class="Field">R</a> <a id="14181" class="Symbol">‚Üí</a> <a id="14183" href="#12307" class="Record Operator">[</a> <a id="14185" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="14187" href="#12307" class="Record Operator">‚Ü¶</a> <a id="14189" href="#8679" class="Datatype">ùí´</a> <a id="14191" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="14193" href="#12307" class="Record Operator">]</a>
  <a id="14197" href="#12397" class="Field Operator">[</a> <a id="14199" href="#14199" class="Bound">p</a> <a id="14201" href="#14173" class="Function Operator">‚ãä‚Ä≤</a> <a id="14204" href="#12397" class="Field Operator">]-set</a> <a id="14210" class="Symbol">=</a> <a id="14212" href="#8921" class="InductiveConstructor">trunc</a>
  <a id="14220" href="#12449" class="Field Operator">[</a> <a id="14222" href="#14222" class="Bound">p</a> <a id="14224" href="#14173" class="Function Operator">‚ãä‚Ä≤</a> <a id="14227" href="#12449" class="Field Operator">][]</a> <a id="14231" class="Symbol">=</a> <a id="14233" href="#8715" class="InductiveConstructor">[]</a>
  <a id="14238" href="#12420" class="Field Operator">[</a> <a id="14240" href="#14240" class="Bound">p</a> <a id="14242" href="#14173" class="Function Operator">‚ãä‚Ä≤</a> <a id="14245" href="#12420" class="Field Operator">]</a> <a id="14247" href="#14247" class="Bound">q</a> <a id="14249" href="#12420" class="Field Operator">&amp;</a> <a id="14251" href="#14251" class="Bound">x</a> <a id="14253" href="#12420" class="Field Operator">‚à∑</a> <a id="14255" href="#14255" class="Bound">xs</a> <a id="14258" class="Symbol">=</a> <a id="14260" href="#14240" class="Bound">p</a> <a id="14262" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="14264" href="#14247" class="Bound">q</a> <a id="14266" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="14268" href="#14251" class="Bound">x</a> <a id="14270" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="14272" href="#14255" class="Bound">xs</a>
  <a id="14277" href="#12570" class="Field Operator">[</a> <a id="14279" href="#14279" class="Bound">p</a> <a id="14281" href="#14173" class="Function Operator">‚ãä‚Ä≤</a> <a id="14284" href="#12570" class="Field Operator">]-com</a> <a id="14290" href="#14290" class="Bound">q</a> <a id="14292" href="#14292" class="Bound">x</a> <a id="14294" href="#14294" class="Bound">r</a> <a id="14296" href="#14296" class="Bound">y</a> <a id="14298" href="#14298" class="Bound">xs</a> <a id="14301" class="Symbol">=</a> <a id="14303" href="#8824" class="InductiveConstructor">com</a> <a id="14307" class="Symbol">(</a><a id="14308" href="#14279" class="Bound">p</a> <a id="14310" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="14312" href="#14290" class="Bound">q</a><a id="14313" class="Symbol">)</a> <a id="14315" href="#14292" class="Bound">x</a> <a id="14317" class="Symbol">(</a><a id="14318" href="#14279" class="Bound">p</a> <a id="14320" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="14322" href="#14294" class="Bound">r</a><a id="14323" class="Symbol">)</a> <a id="14325" href="#14296" class="Bound">y</a> <a id="14327" href="#14298" class="Bound">xs</a>
  <a id="14332" href="#12508" class="Field Operator">[</a> <a id="14334" href="#14334" class="Bound">p</a> <a id="14336" href="#14173" class="Function Operator">‚ãä‚Ä≤</a> <a id="14339" href="#12508" class="Field Operator">]-dup</a> <a id="14345" href="#14345" class="Bound">q</a> <a id="14347" href="#14347" class="Bound">r</a> <a id="14349" href="#14349" class="Bound">x</a> <a id="14351" href="#14351" class="Bound">xs</a> <a id="14354" class="Symbol">=</a>
    <a id="14360" href="#14334" class="Bound">p</a> <a id="14362" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="14364" href="#14345" class="Bound">q</a> <a id="14366" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="14368" href="#14349" class="Bound">x</a> <a id="14370" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="14372" href="#14334" class="Bound">p</a> <a id="14374" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="14376" href="#14347" class="Bound">r</a> <a id="14378" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="14380" href="#14349" class="Bound">x</a> <a id="14382" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="14384" href="#14351" class="Bound">xs</a> <a id="14387" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚â°‚ü®</a> <a id="14390" href="#8767" class="InductiveConstructor">dup</a> <a id="14394" class="Symbol">(</a><a id="14395" href="#14334" class="Bound">p</a> <a id="14397" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="14399" href="#14345" class="Bound">q</a><a id="14400" class="Symbol">)</a> <a id="14402" class="Symbol">(</a><a id="14403" href="#14334" class="Bound">p</a> <a id="14405" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="14407" href="#14347" class="Bound">r</a><a id="14408" class="Symbol">)</a> <a id="14410" href="#14349" class="Bound">x</a> <a id="14412" href="#14351" class="Bound">xs</a> <a id="14415" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚ü©</a>
    <a id="14421" href="#14334" class="Bound">p</a> <a id="14423" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="14425" href="#14345" class="Bound">q</a> <a id="14427" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="14429" href="#14334" class="Bound">p</a> <a id="14431" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="14433" href="#14347" class="Bound">r</a> <a id="14435" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="14437" href="#14349" class="Bound">x</a> <a id="14439" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="14441" href="#14351" class="Bound">xs</a>     <a id="14448" href="../code/probability/ProbabilityModule.Utils.html#295" class="Function">‚â°Àò‚ü®</a> <a id="14452" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="14457" class="Symbol">(</a><a id="14458" href="#8727" class="InductiveConstructor Operator">_&amp;</a> <a id="14461" href="#14349" class="Bound">x</a> <a id="14463" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="14465" href="#14351" class="Bound">xs</a><a id="14467" class="Symbol">)</a> <a id="14469" class="Symbol">(</a><a id="14470" href="../code/probability/ProbabilityModule.Semirings.html#543" class="Field">*‚ü®+‚ü©</a> <a id="14475" href="#14334" class="Bound">p</a> <a id="14477" href="#14345" class="Bound">q</a> <a id="14479" href="#14347" class="Bound">r</a><a id="14480" class="Symbol">)</a> <a id="14482" href="../code/probability/ProbabilityModule.Utils.html#295" class="Function">‚ü©</a>
    <a id="14488" href="#14334" class="Bound">p</a> <a id="14490" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="14492" class="Symbol">(</a><a id="14493" href="#14345" class="Bound">q</a> <a id="14495" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="14497" href="#14347" class="Bound">r</a><a id="14498" class="Symbol">)</a> <a id="14500" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="14502" href="#14349" class="Bound">x</a> <a id="14504" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="14506" href="#14351" class="Bound">xs</a>       <a id="14515" href="../code/probability/Cubical.Foundations.Prelude.html#2745" class="Function Operator">‚àé</a>
  <a id="14519" href="#12635" class="Field Operator">[</a> <a id="14521" href="#14521" class="Bound">p</a> <a id="14523" href="#14173" class="Function Operator">‚ãä‚Ä≤</a> <a id="14526" href="#12635" class="Field Operator">]-del</a> <a id="14532" href="#14532" class="Bound">x</a> <a id="14534" href="#14534" class="Bound">xs</a> <a id="14537" class="Symbol">=</a>
    <a id="14543" href="#14521" class="Bound">p</a> <a id="14545" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="14547" href="../code/probability/ProbabilityModule.Semirings.html#254" class="Field">0#</a> <a id="14550" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="14552" href="#14532" class="Bound">x</a> <a id="14554" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="14556" href="#14534" class="Bound">xs</a> <a id="14559" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚â°‚ü®</a> <a id="14562" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="14567" class="Symbol">(</a><a id="14568" href="#8727" class="InductiveConstructor Operator">_&amp;</a> <a id="14571" href="#14532" class="Bound">x</a> <a id="14573" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="14575" href="#14534" class="Bound">xs</a><a id="14577" class="Symbol">)</a> <a id="14579" class="Symbol">(</a><a id="14580" href="../code/probability/ProbabilityModule.Semirings.html#376" class="Field">*0</a> <a id="14583" href="#14521" class="Bound">p</a><a id="14584" class="Symbol">)</a> <a id="14586" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚ü©</a>
    <a id="14592" href="../code/probability/ProbabilityModule.Semirings.html#254" class="Field">0#</a> <a id="14595" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="14597" href="#14532" class="Bound">x</a> <a id="14599" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="14601" href="#14534" class="Bound">xs</a>     <a id="14608" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚â°‚ü®</a> <a id="14611" href="#8887" class="InductiveConstructor">del</a> <a id="14615" href="#14532" class="Bound">x</a> <a id="14617" href="#14534" class="Bound">xs</a> <a id="14620" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚ü©</a>
    <a id="14626" href="#14534" class="Bound">xs</a>              <a id="14642" href="../code/probability/Cubical.Foundations.Prelude.html#2745" class="Function Operator">‚àé</a>

<a id="‚à´"></a><a id="14645" href="#14645" class="Function">‚à´</a> <a id="14647" class="Symbol">:</a> <a id="14649" class="Symbol">(</a><a id="14650" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="14652" class="Symbol">‚Üí</a> <a id="14654" href="../code/probability/ProbabilityModule.Semirings.html#200" class="Field">R</a><a id="14655" class="Symbol">)</a> <a id="14657" class="Symbol">‚Üí</a> <a id="14659" href="#8679" class="Datatype">ùí´</a> <a id="14661" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="14663" class="Symbol">‚Üí</a> <a id="14665" href="../code/probability/ProbabilityModule.Semirings.html#200" class="Field">R</a>
<a id="14667" href="#14645" class="Function">‚à´</a> <a id="14669" class="Symbol">=</a> <a id="14671" class="Symbol">Œª</a> <a id="14673" href="#14673" class="Bound">f</a> <a id="14675" class="Symbol">‚Üí</a> <a id="14677" href="#12874" class="Function Operator">[</a> <a id="14679" href="#14711" class="Function">‚à´‚Ä≤</a> <a id="14682" href="#14673" class="Bound">f</a> <a id="14684" href="#12874" class="Function Operator">]‚Üì</a>
  <a id="14689" class="Keyword">module</a> <a id="Expect"></a><a id="14696" href="#14696" class="Module">Expect</a> <a id="14703" class="Keyword">where</a>
  <a id="Expect.‚à´‚Ä≤"></a><a id="14711" href="#14711" class="Function">‚à´‚Ä≤</a> <a id="14714" class="Symbol">:</a> <a id="14716" class="Symbol">(</a><a id="14717" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="14719" class="Symbol">‚Üí</a> <a id="14721" href="../code/probability/ProbabilityModule.Semirings.html#200" class="Field">R</a><a id="14722" class="Symbol">)</a> <a id="14724" class="Symbol">‚Üí</a> <a id="14726" href="#12307" class="Record Operator">[</a> <a id="14728" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="14730" href="#12307" class="Record Operator">‚Ü¶</a> <a id="14732" href="../code/probability/ProbabilityModule.Semirings.html#200" class="Field">R</a> <a id="14734" href="#12307" class="Record Operator">]</a>
  <a id="14738" href="#12397" class="Field Operator">[</a> <a id="14740" href="#14711" class="Function">‚à´‚Ä≤</a> <a id="14743" href="#14743" class="Bound">f</a> <a id="14745" href="#12397" class="Field Operator">]-set</a> <a id="14751" class="Symbol">=</a> <a id="14753" href="../code/probability/ProbabilityModule.Semirings.html#641" class="Field">sIsSet</a>
  <a id="14762" href="#12420" class="Field Operator">[</a> <a id="14764" href="#14711" class="Function">‚à´‚Ä≤</a> <a id="14767" href="#14767" class="Bound">f</a> <a id="14769" href="#12420" class="Field Operator">]</a> <a id="14771" href="#14771" class="Bound">p</a> <a id="14773" href="#12420" class="Field Operator">&amp;</a> <a id="14775" href="#14775" class="Bound">x</a> <a id="14777" href="#12420" class="Field Operator">‚à∑</a> <a id="14779" href="#14779" class="Bound">xs</a> <a id="14782" class="Symbol">=</a> <a id="14784" href="#14771" class="Bound">p</a> <a id="14786" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="14788" href="#14767" class="Bound">f</a> <a id="14790" href="#14775" class="Bound">x</a> <a id="14792" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="14794" href="#14779" class="Bound">xs</a>
  <a id="14799" href="#12449" class="Field Operator">[</a> <a id="14801" href="#14711" class="Function">‚à´‚Ä≤</a> <a id="14804" href="#14804" class="Bound">f</a> <a id="14806" href="#12449" class="Field Operator">][]</a> <a id="14810" class="Symbol">=</a> <a id="14812" href="../code/probability/ProbabilityModule.Semirings.html#254" class="Field">0#</a>
  <a id="14817" href="#12508" class="Field Operator">[</a> <a id="14819" href="#14711" class="Function">‚à´‚Ä≤</a> <a id="14822" href="#14822" class="Bound">f</a> <a id="14824" href="#12508" class="Field Operator">]-dup</a> <a id="14830" href="#14830" class="Bound">p</a> <a id="14832" href="#14832" class="Bound">q</a> <a id="14834" href="#14834" class="Bound">x</a> <a id="14836" href="#14836" class="Bound">xs</a> <a id="14839" class="Symbol">=</a>
    <a id="14845" href="#14830" class="Bound">p</a> <a id="14847" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="14849" href="#14822" class="Bound">f</a> <a id="14851" href="#14834" class="Bound">x</a> <a id="14853" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="14855" class="Symbol">(</a><a id="14856" href="#14832" class="Bound">q</a> <a id="14858" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="14860" href="#14822" class="Bound">f</a> <a id="14862" href="#14834" class="Bound">x</a> <a id="14864" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="14866" href="#14836" class="Bound">xs</a><a id="14868" class="Symbol">)</a> <a id="14870" href="../code/probability/ProbabilityModule.Utils.html#295" class="Function">‚â°Àò‚ü®</a> <a id="14874" href="../code/probability/ProbabilityModule.Semirings.html#276" class="Field">+-assoc</a> <a id="14882" class="Symbol">(</a><a id="14883" href="#14830" class="Bound">p</a> <a id="14885" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="14887" href="#14822" class="Bound">f</a> <a id="14889" href="#14834" class="Bound">x</a><a id="14890" class="Symbol">)</a> <a id="14892" class="Symbol">(</a><a id="14893" href="#14832" class="Bound">q</a> <a id="14895" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="14897" href="#14822" class="Bound">f</a> <a id="14899" href="#14834" class="Bound">x</a><a id="14900" class="Symbol">)</a> <a id="14902" href="#14836" class="Bound">xs</a> <a id="14905" href="../code/probability/ProbabilityModule.Utils.html#295" class="Function">‚ü©</a>
    <a id="14911" class="Symbol">(</a><a id="14912" href="#14830" class="Bound">p</a> <a id="14914" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="14916" href="#14822" class="Bound">f</a> <a id="14918" href="#14834" class="Bound">x</a> <a id="14920" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="14922" href="#14832" class="Bound">q</a> <a id="14924" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="14926" href="#14822" class="Bound">f</a> <a id="14928" href="#14834" class="Bound">x</a><a id="14929" class="Symbol">)</a> <a id="14931" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="14933" href="#14836" class="Bound">xs</a> <a id="14936" href="../code/probability/ProbabilityModule.Utils.html#295" class="Function">‚â°Àò‚ü®</a> <a id="14940" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="14945" class="Symbol">(</a><a id="14946" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">_+</a> <a id="14949" href="#14836" class="Bound">xs</a><a id="14951" class="Symbol">)</a> <a id="14953" class="Symbol">(</a><a id="14954" href="../code/probability/ProbabilityModule.Semirings.html#592" class="Field">‚ü®+‚ü©*</a> <a id="14959" href="#14830" class="Bound">p</a> <a id="14961" href="#14832" class="Bound">q</a> <a id="14963" class="Symbol">(</a><a id="14964" href="#14822" class="Bound">f</a> <a id="14966" href="#14834" class="Bound">x</a><a id="14967" class="Symbol">))</a> <a id="14970" href="../code/probability/ProbabilityModule.Utils.html#295" class="Function">‚ü©</a>
    <a id="14976" class="Symbol">(</a><a id="14977" href="#14830" class="Bound">p</a> <a id="14979" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="14981" href="#14832" class="Bound">q</a><a id="14982" class="Symbol">)</a> <a id="14984" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="14986" href="#14822" class="Bound">f</a> <a id="14988" href="#14834" class="Bound">x</a> <a id="14990" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="14992" href="#14836" class="Bound">xs</a> <a id="14995" href="../code/probability/Cubical.Foundations.Prelude.html#2745" class="Function Operator">‚àé</a>
  <a id="14999" href="#12570" class="Field Operator">[</a> <a id="15001" href="#14711" class="Function">‚à´‚Ä≤</a> <a id="15004" href="#15004" class="Bound">f</a> <a id="15006" href="#12570" class="Field Operator">]-com</a> <a id="15012" href="#15012" class="Bound">p</a> <a id="15014" href="#15014" class="Bound">x</a> <a id="15016" href="#15016" class="Bound">q</a> <a id="15018" href="#15018" class="Bound">y</a> <a id="15020" href="#15020" class="Bound">xs</a> <a id="15023" class="Symbol">=</a>
    <a id="15029" href="#15012" class="Bound">p</a> <a id="15031" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="15033" href="#15004" class="Bound">f</a> <a id="15035" href="#15014" class="Bound">x</a> <a id="15037" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="15039" class="Symbol">(</a><a id="15040" href="#15016" class="Bound">q</a> <a id="15042" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="15044" href="#15004" class="Bound">f</a> <a id="15046" href="#15018" class="Bound">y</a> <a id="15048" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="15050" href="#15020" class="Bound">xs</a><a id="15052" class="Symbol">)</a> <a id="15054" href="../code/probability/ProbabilityModule.Utils.html#295" class="Function">‚â°Àò‚ü®</a> <a id="15058" href="../code/probability/ProbabilityModule.Semirings.html#276" class="Field">+-assoc</a> <a id="15066" class="Symbol">(</a><a id="15067" href="#15012" class="Bound">p</a> <a id="15069" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="15071" href="#15004" class="Bound">f</a> <a id="15073" href="#15014" class="Bound">x</a><a id="15074" class="Symbol">)</a> <a id="15076" class="Symbol">(</a><a id="15077" href="#15016" class="Bound">q</a> <a id="15079" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="15081" href="#15004" class="Bound">f</a> <a id="15083" href="#15018" class="Bound">y</a><a id="15084" class="Symbol">)</a> <a id="15086" class="Symbol">(</a><a id="15087" href="#15020" class="Bound">xs</a><a id="15089" class="Symbol">)</a> <a id="15091" href="../code/probability/ProbabilityModule.Utils.html#295" class="Function">‚ü©</a>
    <a id="15097" href="#15012" class="Bound">p</a> <a id="15099" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="15101" href="#15004" class="Bound">f</a> <a id="15103" href="#15014" class="Bound">x</a> <a id="15105" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="15107" href="#15016" class="Bound">q</a> <a id="15109" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="15111" href="#15004" class="Bound">f</a> <a id="15113" href="#15018" class="Bound">y</a> <a id="15115" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="15117" href="#15020" class="Bound">xs</a>   <a id="15122" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚â°‚ü®</a> <a id="15125" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="15130" class="Symbol">(</a><a id="15131" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">_+</a> <a id="15134" href="#15020" class="Bound">xs</a><a id="15136" class="Symbol">)</a> <a id="15138" class="Symbol">(</a><a id="15139" href="../code/probability/ProbabilityModule.Semirings.html#508" class="Field">+-comm</a> <a id="15146" class="Symbol">(</a><a id="15147" href="#15012" class="Bound">p</a> <a id="15149" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="15151" href="#15004" class="Bound">f</a> <a id="15153" href="#15014" class="Bound">x</a><a id="15154" class="Symbol">)</a> <a id="15156" class="Symbol">(</a><a id="15157" href="#15016" class="Bound">q</a> <a id="15159" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="15161" href="#15004" class="Bound">f</a> <a id="15163" href="#15018" class="Bound">y</a><a id="15164" class="Symbol">))</a> <a id="15167" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚ü©</a>
    <a id="15173" href="#15016" class="Bound">q</a> <a id="15175" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="15177" href="#15004" class="Bound">f</a> <a id="15179" href="#15018" class="Bound">y</a> <a id="15181" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="15183" href="#15012" class="Bound">p</a> <a id="15185" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="15187" href="#15004" class="Bound">f</a> <a id="15189" href="#15014" class="Bound">x</a> <a id="15191" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="15193" href="#15020" class="Bound">xs</a>   <a id="15198" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚â°‚ü®</a> <a id="15201" href="../code/probability/ProbabilityModule.Semirings.html#276" class="Field">+-assoc</a> <a id="15209" class="Symbol">(</a><a id="15210" href="#15016" class="Bound">q</a> <a id="15212" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="15214" href="#15004" class="Bound">f</a> <a id="15216" href="#15018" class="Bound">y</a><a id="15217" class="Symbol">)</a> <a id="15219" class="Symbol">(</a><a id="15220" href="#15012" class="Bound">p</a> <a id="15222" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="15224" href="#15004" class="Bound">f</a> <a id="15226" href="#15014" class="Bound">x</a><a id="15227" class="Symbol">)</a> <a id="15229" class="Symbol">(</a><a id="15230" href="#15020" class="Bound">xs</a><a id="15232" class="Symbol">)</a> <a id="15234" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚ü©</a>
    <a id="15240" href="#15016" class="Bound">q</a> <a id="15242" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="15244" href="#15004" class="Bound">f</a> <a id="15246" href="#15018" class="Bound">y</a> <a id="15248" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="15250" class="Symbol">(</a><a id="15251" href="#15012" class="Bound">p</a> <a id="15253" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="15255" href="#15004" class="Bound">f</a> <a id="15257" href="#15014" class="Bound">x</a> <a id="15259" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="15261" href="#15020" class="Bound">xs</a><a id="15263" class="Symbol">)</a> <a id="15265" href="../code/probability/Cubical.Foundations.Prelude.html#2745" class="Function Operator">‚àé</a>
  <a id="15269" href="#12635" class="Field Operator">[</a> <a id="15271" href="#14711" class="Function">‚à´‚Ä≤</a> <a id="15274" href="#15274" class="Bound">f</a> <a id="15276" href="#12635" class="Field Operator">]-del</a> <a id="15282" href="#15282" class="Bound">x</a> <a id="15284" href="#15284" class="Bound">xs</a> <a id="15287" class="Symbol">=</a>
    <a id="15293" href="../code/probability/ProbabilityModule.Semirings.html#254" class="Field">0#</a> <a id="15296" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="15298" href="#15274" class="Bound">f</a> <a id="15300" href="#15282" class="Bound">x</a> <a id="15302" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="15304" href="#15284" class="Bound">xs</a> <a id="15307" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚â°‚ü®</a> <a id="15310" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="15315" class="Symbol">(</a><a id="15316" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">_+</a> <a id="15319" href="#15284" class="Bound">xs</a><a id="15321" class="Symbol">)</a> <a id="15323" class="Symbol">(</a><a id="15324" href="../code/probability/ProbabilityModule.Semirings.html#403" class="Field">0*</a> <a id="15327" class="Symbol">(</a><a id="15328" href="#15274" class="Bound">f</a> <a id="15330" href="#15282" class="Bound">x</a><a id="15331" class="Symbol">))</a> <a id="15334" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚ü©</a>
    <a id="15340" href="../code/probability/ProbabilityModule.Semirings.html#254" class="Field">0#</a> <a id="15343" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="15345" href="#15284" class="Bound">xs</a>       <a id="15354" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚â°‚ü®</a> <a id="15357" href="../code/probability/ProbabilityModule.Semirings.html#430" class="Field">0+</a> <a id="15360" class="Symbol">(</a><a id="15361" href="#15284" class="Bound">xs</a><a id="15363" class="Symbol">)</a> <a id="15365" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚ü©</a>
    <a id="15371" href="#15284" class="Bound">xs</a>            <a id="15385" href="../code/probability/Cubical.Foundations.Prelude.html#2745" class="Function Operator">‚àé</a>

<a id="15388" class="Keyword">syntax</a> <a id="15395" href="#14645" class="Function">‚à´</a> <a id="15397" class="Symbol">(Œª</a> <a id="15400" class="Bound">x</a> <a id="15402" class="Symbol">‚Üí</a> <a id="15404" class="Bound">e</a><a id="15405" class="Symbol">)</a> <a id="15407" class="Symbol">=</a> <a id="15409" class="Function">‚à´</a> <a id="15411" class="Bound">e</a> <a id="15413" class="Function">ùëë</a> <a id="15415" class="Bound">x</a>

<a id="pure"></a><a id="15418" href="#15418" class="Function">pure</a> <a id="15423" class="Symbol">:</a> <a id="15425" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="15427" class="Symbol">‚Üí</a> <a id="15429" href="#8679" class="Datatype">ùí´</a> <a id="15431" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a>
<a id="15433" href="#15418" class="Function">pure</a> <a id="15438" href="#15438" class="Bound">x</a> <a id="15440" class="Symbol">=</a> <a id="15442" href="../code/probability/ProbabilityModule.Semirings.html#265" class="Field">1#</a> <a id="15445" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="15447" href="#15438" class="Bound">x</a> <a id="15449" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="15451" href="#8715" class="InductiveConstructor">[]</a>

<a id="‚à™-cons"></a><a id="15455" href="#15455" class="Function">‚à™-cons</a> <a id="15462" class="Symbol">:</a> <a id="15464" class="Symbol">‚àÄ</a> <a id="15466" href="#15466" class="Bound">p</a> <a id="15468" class="Symbol">(</a><a id="15469" href="#15469" class="Bound">x</a> <a id="15471" class="Symbol">:</a> <a id="15473" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a><a id="15474" class="Symbol">)</a> <a id="15476" href="#15476" class="Bound">xs</a> <a id="15479" href="#15479" class="Bound">ys</a> <a id="15482" class="Symbol">‚Üí</a> <a id="15484" href="#15476" class="Bound">xs</a> <a id="15487" href="#13390" class="Function Operator">‚à™</a> <a id="15489" href="#15466" class="Bound">p</a> <a id="15491" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="15493" href="#15469" class="Bound">x</a> <a id="15495" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="15497" href="#15479" class="Bound">ys</a> <a id="15500" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">‚â°</a> <a id="15502" href="#15466" class="Bound">p</a> <a id="15504" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="15506" href="#15469" class="Bound">x</a> <a id="15508" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="15510" href="#15476" class="Bound">xs</a> <a id="15513" href="#13390" class="Function Operator">‚à™</a> <a id="15515" href="#15479" class="Bound">ys</a>
<a id="15518" href="#15455" class="Function">‚à™-cons</a> <a id="15525" class="Symbol">=</a> <a id="15527" class="Symbol">Œª</a> <a id="15529" href="#15529" class="Bound">p</a> <a id="15531" href="#15531" class="Bound">x</a> <a id="15533" href="#15533" class="Bound">xs</a> <a id="15536" href="#15536" class="Bound">ys</a> <a id="15539" class="Symbol">‚Üí</a> <a id="15541" href="#12103" class="Function Operator">‚ü¶</a> <a id="15543" href="#15587" class="Function">‚à™-cons‚Ä≤</a> <a id="15551" href="#15529" class="Bound">p</a> <a id="15553" href="#15531" class="Bound">x</a> <a id="15555" href="#15536" class="Bound">ys</a> <a id="15558" href="#12103" class="Function Operator">‚üß‚áì</a> <a id="15561" href="#15533" class="Bound">xs</a>
  <a id="15566" class="Keyword">module</a> <a id="UCons"></a><a id="15573" href="#15573" class="Module">UCons</a> <a id="15579" class="Keyword">where</a>
  <a id="UCons.‚à™-cons‚Ä≤"></a><a id="15587" href="#15587" class="Function">‚à™-cons‚Ä≤</a> <a id="15595" class="Symbol">:</a> <a id="15597" class="Symbol">‚àÄ</a> <a id="15599" href="#15599" class="Bound">p</a> <a id="15601" href="#15601" class="Bound">x</a> <a id="15603" href="#15603" class="Bound">ys</a> <a id="15606" class="Symbol">‚Üí</a> <a id="15608" href="#12139" class="Function">‚ü¶</a> <a id="15610" href="#15610" class="Bound">xs</a> <a id="15613" href="#12139" class="Function">‚ààùí´</a> <a id="15616" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="15618" href="#12139" class="Function">‚áí</a> <a id="15620" href="#15610" class="Bound">xs</a> <a id="15623" href="#13390" class="Function Operator">‚à™</a> <a id="15625" href="#15599" class="Bound">p</a> <a id="15627" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="15629" href="#15601" class="Bound">x</a> <a id="15631" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="15633" href="#15603" class="Bound">ys</a> <a id="15636" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">‚â°</a> <a id="15638" href="#15599" class="Bound">p</a> <a id="15640" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="15642" href="#15601" class="Bound">x</a> <a id="15644" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="15646" href="#15610" class="Bound">xs</a> <a id="15649" href="#13390" class="Function Operator">‚à™</a> <a id="15651" href="#15603" class="Bound">ys</a> <a id="15654" href="#12139" class="Function">‚üß</a>
  <a id="15658" href="#11443" class="Field Operator">‚ü¶</a> <a id="15660" href="#15587" class="Function">‚à™-cons‚Ä≤</a> <a id="15668" href="#15668" class="Bound">p</a> <a id="15670" href="#15670" class="Bound">x</a> <a id="15672" href="#15672" class="Bound">ys</a> <a id="15675" href="#11443" class="Field Operator">‚üß-prop</a> <a id="15682" class="Symbol">=</a> <a id="15684" href="#8921" class="InductiveConstructor">trunc</a> <a id="15690" class="Symbol">_</a> <a id="15692" class="Symbol">_</a>
  <a id="15696" href="#11481" class="Field Operator">‚ü¶</a> <a id="15698" href="#15587" class="Function">‚à™-cons‚Ä≤</a> <a id="15706" href="#15706" class="Bound">p</a> <a id="15708" href="#15708" class="Bound">x</a> <a id="15710" href="#15710" class="Bound">ys</a> <a id="15713" href="#11481" class="Field Operator">‚üß[]</a> <a id="15717" class="Symbol">=</a> <a id="15719" href="../code/probability/Cubical.Foundations.Prelude.html#827" class="Function">refl</a>
  <a id="15726" href="#11498" class="Field Operator">‚ü¶</a> <a id="15728" href="#15587" class="Function">‚à™-cons‚Ä≤</a> <a id="15736" href="#15736" class="Bound">p</a> <a id="15738" href="#15738" class="Bound">x</a> <a id="15740" href="#15740" class="Bound">ys</a> <a id="15743" href="#11498" class="Field Operator">‚üß</a> <a id="15745" href="#15745" class="Bound">r</a> <a id="15747" href="#11498" class="Field Operator">&amp;</a> <a id="15749" href="#15749" class="Bound">y</a> <a id="15751" href="#11498" class="Field Operator">‚à∑</a> <a id="15753" href="#15753" class="Bound">xs</a> <a id="15756" href="#11498" class="Field Operator">‚ü®</a> <a id="15758" href="#15758" class="Bound">P</a> <a id="15760" href="#11498" class="Field Operator">‚ü©</a> <a id="15762" class="Symbol">=</a> <a id="15764" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="15769" class="Symbol">(</a><a id="15770" href="#15745" class="Bound">r</a> <a id="15772" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="15774" href="#15749" class="Bound">y</a> <a id="15776" href="#8727" class="InductiveConstructor Operator">‚à∑_</a><a id="15778" class="Symbol">)</a> <a id="15780" href="#15758" class="Bound">P</a> <a id="15782" href="../code/probability/Cubical.Foundations.Prelude.html#1674" class="Function Operator">Õæ</a> <a id="15784" href="#8824" class="InductiveConstructor">com</a> <a id="15788" href="#15745" class="Bound">r</a> <a id="15790" href="#15749" class="Bound">y</a> <a id="15792" href="#15736" class="Bound">p</a> <a id="15794" href="#15738" class="Bound">x</a> <a id="15796" class="Symbol">(</a><a id="15797" href="#15753" class="Bound">xs</a> <a id="15800" href="#13390" class="Function Operator">‚à™</a> <a id="15802" href="#15740" class="Bound">ys</a><a id="15804" class="Symbol">)</a>

<a id="‚ãä-distrib ≥"></a><a id="15807" href="#15807" class="Function">‚ãä-distrib ≥</a> <a id="15818" class="Symbol">:</a> <a id="15820" class="Symbol">‚àÄ</a> <a id="15822" href="#15822" class="Bound">p</a> <a id="15824" href="#15824" class="Bound">q</a> <a id="15826" class="Symbol">‚Üí</a> <a id="15828" class="Symbol">(</a><a id="15829" href="#15829" class="Bound">xs</a> <a id="15832" class="Symbol">:</a> <a id="15834" href="#8679" class="Datatype">ùí´</a> <a id="15836" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a><a id="15837" class="Symbol">)</a> <a id="15839" class="Symbol">‚Üí</a> <a id="15841" href="#15822" class="Bound">p</a> <a id="15843" href="#14109" class="Function Operator">‚ãä</a> <a id="15845" href="#15829" class="Bound">xs</a> <a id="15848" href="#13390" class="Function Operator">‚à™</a> <a id="15850" href="#15824" class="Bound">q</a> <a id="15852" href="#14109" class="Function Operator">‚ãä</a> <a id="15854" href="#15829" class="Bound">xs</a> <a id="15857" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">‚â°</a> <a id="15859" class="Symbol">(</a><a id="15860" href="#15822" class="Bound">p</a> <a id="15862" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="15864" href="#15824" class="Bound">q</a><a id="15865" class="Symbol">)</a> <a id="15867" href="#14109" class="Function Operator">‚ãä</a> <a id="15869" href="#15829" class="Bound">xs</a>
<a id="15872" href="#15807" class="Function">‚ãä-distrib ≥</a> <a id="15883" class="Symbol">=</a> <a id="15885" class="Symbol">Œª</a> <a id="15887" href="#15887" class="Bound">p</a> <a id="15889" href="#15889" class="Bound">q</a> <a id="15891" class="Symbol">‚Üí</a> <a id="15893" href="#12103" class="Function Operator">‚ü¶</a> <a id="15895" href="#15940" class="Function">‚ãä-distrib ≥‚Ä≤</a> <a id="15907" href="#15887" class="Bound">p</a> <a id="15909" href="#15889" class="Bound">q</a> <a id="15911" href="#12103" class="Function Operator">‚üß‚áì</a>
  <a id="15916" class="Keyword">module</a> <a id="JDistrib"></a><a id="15923" href="#15923" class="Module">JDistrib</a> <a id="15932" class="Keyword">where</a>
  <a id="JDistrib.‚ãä-distrib ≥‚Ä≤"></a><a id="15940" href="#15940" class="Function">‚ãä-distrib ≥‚Ä≤</a> <a id="15952" class="Symbol">:</a> <a id="15954" class="Symbol">‚àÄ</a> <a id="15956" href="#15956" class="Bound">p</a> <a id="15958" href="#15958" class="Bound">q</a> <a id="15960" class="Symbol">‚Üí</a> <a id="15962" href="#12139" class="Function">‚ü¶</a> <a id="15964" href="#15964" class="Bound">xs</a> <a id="15967" href="#12139" class="Function">‚ààùí´</a> <a id="15970" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="15972" href="#12139" class="Function">‚áí</a> <a id="15974" href="#15956" class="Bound">p</a> <a id="15976" href="#14109" class="Function Operator">‚ãä</a> <a id="15978" href="#15964" class="Bound">xs</a> <a id="15981" href="#13390" class="Function Operator">‚à™</a> <a id="15983" href="#15958" class="Bound">q</a> <a id="15985" href="#14109" class="Function Operator">‚ãä</a> <a id="15987" href="#15964" class="Bound">xs</a> <a id="15990" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">‚â°</a> <a id="15992" class="Symbol">(</a><a id="15993" href="#15956" class="Bound">p</a> <a id="15995" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="15997" href="#15958" class="Bound">q</a><a id="15998" class="Symbol">)</a> <a id="16000" href="#14109" class="Function Operator">‚ãä</a> <a id="16002" href="#15964" class="Bound">xs</a> <a id="16005" href="#12139" class="Function">‚üß</a>
  <a id="16009" href="#11443" class="Field Operator">‚ü¶</a> <a id="16011" href="#15940" class="Function">‚ãä-distrib ≥‚Ä≤</a> <a id="16023" href="#16023" class="Bound">p</a> <a id="16025" href="#16025" class="Bound">q</a> <a id="16027" href="#11443" class="Field Operator">‚üß-prop</a> <a id="16034" class="Symbol">=</a> <a id="16036" href="#8921" class="InductiveConstructor">trunc</a> <a id="16042" class="Symbol">_</a> <a id="16044" class="Symbol">_</a>
  <a id="16048" href="#11481" class="Field Operator">‚ü¶</a> <a id="16050" href="#15940" class="Function">‚ãä-distrib ≥‚Ä≤</a> <a id="16062" href="#16062" class="Bound">p</a> <a id="16064" href="#16064" class="Bound">q</a> <a id="16066" href="#11481" class="Field Operator">‚üß[]</a> <a id="16070" class="Symbol">=</a> <a id="16072" href="../code/probability/Cubical.Foundations.Prelude.html#827" class="Function">refl</a>
  <a id="16079" href="#11498" class="Field Operator">‚ü¶</a> <a id="16081" href="#15940" class="Function">‚ãä-distrib ≥‚Ä≤</a> <a id="16093" href="#16093" class="Bound">p</a> <a id="16095" href="#16095" class="Bound">q</a> <a id="16097" href="#11498" class="Field Operator">‚üß</a> <a id="16099" href="#16099" class="Bound">r</a> <a id="16101" href="#11498" class="Field Operator">&amp;</a> <a id="16103" href="#16103" class="Bound">x</a> <a id="16105" href="#11498" class="Field Operator">‚à∑</a> <a id="16107" href="#16107" class="Bound">xs</a> <a id="16110" href="#11498" class="Field Operator">‚ü®</a> <a id="16112" href="#16112" class="Bound">P</a> <a id="16114" href="#11498" class="Field Operator">‚ü©</a> <a id="16116" class="Symbol">=</a>
    <a id="16122" href="#16093" class="Bound">p</a> <a id="16124" href="#14109" class="Function Operator">‚ãä</a> <a id="16126" class="Symbol">(</a><a id="16127" href="#16099" class="Bound">r</a> <a id="16129" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="16131" href="#16103" class="Bound">x</a> <a id="16133" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="16135" href="#16107" class="Bound">xs</a><a id="16137" class="Symbol">)</a> <a id="16139" href="#13390" class="Function Operator">‚à™</a> <a id="16141" href="#16095" class="Bound">q</a> <a id="16143" href="#14109" class="Function Operator">‚ãä</a> <a id="16145" class="Symbol">(</a><a id="16146" href="#16099" class="Bound">r</a> <a id="16148" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="16150" href="#16103" class="Bound">x</a> <a id="16152" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="16154" href="#16107" class="Bound">xs</a><a id="16156" class="Symbol">)</a>   <a id="16160" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚â°‚ü®</a> <a id="16163" href="#15455" class="Function">‚à™-cons</a> <a id="16170" class="Symbol">(</a><a id="16171" href="#16095" class="Bound">q</a> <a id="16173" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="16175" href="#16099" class="Bound">r</a><a id="16176" class="Symbol">)</a> <a id="16178" href="#16103" class="Bound">x</a> <a id="16180" class="Symbol">(</a><a id="16181" href="#16093" class="Bound">p</a> <a id="16183" href="#14109" class="Function Operator">‚ãä</a> <a id="16185" class="Symbol">(</a><a id="16186" href="#16099" class="Bound">r</a> <a id="16188" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="16190" href="#16103" class="Bound">x</a> <a id="16192" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="16194" href="#16107" class="Bound">xs</a><a id="16196" class="Symbol">))</a> <a id="16199" class="Symbol">(</a><a id="16200" href="#16095" class="Bound">q</a> <a id="16202" href="#14109" class="Function Operator">‚ãä</a> <a id="16204" href="#16107" class="Bound">xs</a><a id="16206" class="Symbol">)</a>  <a id="16209" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚ü©</a>
    <a id="16215" href="#16095" class="Bound">q</a> <a id="16217" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="16219" href="#16099" class="Bound">r</a> <a id="16221" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="16223" href="#16103" class="Bound">x</a> <a id="16225" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="16227" href="#16093" class="Bound">p</a> <a id="16229" href="#14109" class="Function Operator">‚ãä</a> <a id="16231" class="Symbol">(</a><a id="16232" href="#16099" class="Bound">r</a> <a id="16234" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="16236" href="#16103" class="Bound">x</a> <a id="16238" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="16240" href="#16107" class="Bound">xs</a><a id="16242" class="Symbol">)</a> <a id="16244" href="#13390" class="Function Operator">‚à™</a> <a id="16246" href="#16095" class="Bound">q</a> <a id="16248" href="#14109" class="Function Operator">‚ãä</a> <a id="16250" href="#16107" class="Bound">xs</a> <a id="16253" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚â°‚ü®</a> <a id="16256" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="16261" class="Symbol">(</a><a id="16262" href="#13390" class="Function Operator">_‚à™</a> <a id="16265" href="#16095" class="Bound">q</a> <a id="16267" href="#14109" class="Function Operator">‚ãä</a> <a id="16269" href="#16107" class="Bound">xs</a><a id="16271" class="Symbol">)</a> <a id="16273" class="Symbol">(</a><a id="16274" href="#8767" class="InductiveConstructor">dup</a> <a id="16278" class="Symbol">(</a><a id="16279" href="#16095" class="Bound">q</a> <a id="16281" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="16283" href="#16099" class="Bound">r</a><a id="16284" class="Symbol">)</a> <a id="16286" class="Symbol">(</a><a id="16287" href="#16093" class="Bound">p</a> <a id="16289" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="16291" href="#16099" class="Bound">r</a><a id="16292" class="Symbol">)</a> <a id="16294" href="#16103" class="Bound">x</a> <a id="16296" class="Symbol">(</a><a id="16297" href="#16093" class="Bound">p</a> <a id="16299" href="#14109" class="Function Operator">‚ãä</a> <a id="16301" href="#16107" class="Bound">xs</a><a id="16303" class="Symbol">))</a> <a id="16306" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚ü©</a>
    <a id="16312" href="#16095" class="Bound">q</a> <a id="16314" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="16316" href="#16099" class="Bound">r</a> <a id="16318" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="16320" href="#16093" class="Bound">p</a> <a id="16322" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="16324" href="#16099" class="Bound">r</a> <a id="16326" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="16328" href="#16103" class="Bound">x</a> <a id="16330" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="16332" href="#16093" class="Bound">p</a> <a id="16334" href="#14109" class="Function Operator">‚ãä</a> <a id="16336" href="#16107" class="Bound">xs</a> <a id="16339" href="#13390" class="Function Operator">‚à™</a> <a id="16341" href="#16095" class="Bound">q</a> <a id="16343" href="#14109" class="Function Operator">‚ãä</a> <a id="16345" href="#16107" class="Bound">xs</a>   <a id="16350" href="../code/probability/ProbabilityModule.Utils.html#295" class="Function">‚â°Àò‚ü®</a> <a id="16354" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="16359" class="Symbol">(</a><a id="16360" href="#8727" class="InductiveConstructor Operator">_&amp;</a> <a id="16363" href="#16103" class="Bound">x</a> <a id="16365" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="16367" class="Symbol">(</a><a id="16368" href="#16093" class="Bound">p</a> <a id="16370" href="#14109" class="Function Operator">‚ãä</a> <a id="16372" href="#16107" class="Bound">xs</a> <a id="16375" href="#13390" class="Function Operator">‚à™</a> <a id="16377" href="#16095" class="Bound">q</a> <a id="16379" href="#14109" class="Function Operator">‚ãä</a> <a id="16381" href="#16107" class="Bound">xs</a><a id="16383" class="Symbol">))</a> <a id="16386" class="Symbol">(</a><a id="16387" href="../code/probability/ProbabilityModule.Semirings.html#592" class="Field">‚ü®+‚ü©*</a> <a id="16392" href="#16095" class="Bound">q</a> <a id="16394" href="#16093" class="Bound">p</a> <a id="16396" href="#16099" class="Bound">r</a><a id="16397" class="Symbol">)</a> <a id="16399" href="../code/probability/ProbabilityModule.Utils.html#295" class="Function">‚ü©</a>
    <a id="16405" class="Symbol">(</a><a id="16406" href="#16095" class="Bound">q</a> <a id="16408" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="16410" href="#16093" class="Bound">p</a><a id="16411" class="Symbol">)</a> <a id="16413" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="16415" href="#16099" class="Bound">r</a> <a id="16417" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="16419" href="#16103" class="Bound">x</a> <a id="16421" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="16423" href="#16093" class="Bound">p</a> <a id="16425" href="#14109" class="Function Operator">‚ãä</a> <a id="16427" href="#16107" class="Bound">xs</a> <a id="16430" href="#13390" class="Function Operator">‚à™</a> <a id="16432" href="#16095" class="Bound">q</a> <a id="16434" href="#14109" class="Function Operator">‚ãä</a> <a id="16436" href="#16107" class="Bound">xs</a>     <a id="16443" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚â°‚ü®</a> <a id="16446" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="16451" class="Symbol">((</a><a id="16453" href="#16095" class="Bound">q</a> <a id="16455" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="16457" href="#16093" class="Bound">p</a><a id="16458" class="Symbol">)</a> <a id="16460" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="16462" href="#16099" class="Bound">r</a> <a id="16464" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="16466" href="#16103" class="Bound">x</a> <a id="16468" href="#8727" class="InductiveConstructor Operator">‚à∑_</a><a id="16470" class="Symbol">)</a> <a id="16472" href="#16112" class="Bound">P</a> <a id="16474" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚ü©</a>
    <a id="16480" class="Symbol">(</a><a id="16481" href="#16095" class="Bound">q</a> <a id="16483" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="16485" href="#16093" class="Bound">p</a><a id="16486" class="Symbol">)</a> <a id="16488" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="16490" href="#16099" class="Bound">r</a> <a id="16492" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="16494" href="#16103" class="Bound">x</a> <a id="16496" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="16498" class="Symbol">(</a><a id="16499" href="#16093" class="Bound">p</a> <a id="16501" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="16503" href="#16095" class="Bound">q</a><a id="16504" class="Symbol">)</a> <a id="16506" href="#14109" class="Function Operator">‚ãä</a> <a id="16508" href="#16107" class="Bound">xs</a>        <a id="16518" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚â°‚ü®</a> <a id="16521" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="16526" class="Symbol">(Œª</a> <a id="16529" href="#16529" class="Bound">pq</a> <a id="16532" class="Symbol">‚Üí</a> <a id="16534" href="#16529" class="Bound">pq</a> <a id="16537" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="16539" href="#16099" class="Bound">r</a> <a id="16541" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="16543" href="#16103" class="Bound">x</a> <a id="16545" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="16547" class="Symbol">(</a><a id="16548" href="#16093" class="Bound">p</a> <a id="16550" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="16552" href="#16095" class="Bound">q</a><a id="16553" class="Symbol">)</a> <a id="16555" href="#14109" class="Function Operator">‚ãä</a> <a id="16557" href="#16107" class="Bound">xs</a><a id="16559" class="Symbol">)</a> <a id="16561" class="Symbol">(</a><a id="16562" href="../code/probability/ProbabilityModule.Semirings.html#508" class="Field">+-comm</a> <a id="16569" href="#16095" class="Bound">q</a> <a id="16571" href="#16093" class="Bound">p</a><a id="16572" class="Symbol">)</a> <a id="16574" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚ü©</a>
    <a id="16580" class="Symbol">(</a><a id="16581" href="#16093" class="Bound">p</a> <a id="16583" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="16585" href="#16095" class="Bound">q</a><a id="16586" class="Symbol">)</a> <a id="16588" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="16590" href="#16099" class="Bound">r</a> <a id="16592" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="16594" href="#16103" class="Bound">x</a> <a id="16596" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="16598" class="Symbol">(</a><a id="16599" href="#16093" class="Bound">p</a> <a id="16601" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="16603" href="#16095" class="Bound">q</a><a id="16604" class="Symbol">)</a> <a id="16606" href="#14109" class="Function Operator">‚ãä</a> <a id="16608" href="#16107" class="Bound">xs</a>        <a id="16618" href="../code/probability/ProbabilityModule.Utils.html#572" class="Function Operator">‚â°‚ü®‚ü©</a>
    <a id="16626" href="#14109" class="Function Operator">_‚ãä_</a> <a id="16630" class="Symbol">(</a><a id="16631" href="#16093" class="Bound">p</a> <a id="16633" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="16635" href="#16095" class="Bound">q</a><a id="16636" class="Symbol">)</a> <a id="16638" class="Symbol">(</a><a id="16639" href="#16099" class="Bound">r</a> <a id="16641" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="16643" href="#16103" class="Bound">x</a> <a id="16645" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="16647" href="#16107" class="Bound">xs</a><a id="16649" class="Symbol">)</a> <a id="16651" href="../code/probability/Cubical.Foundations.Prelude.html#2745" class="Function Operator">‚àé</a>

<a id="‚ãä-distribÀ°"></a><a id="16654" href="#16654" class="Function">‚ãä-distribÀ°</a> <a id="16665" class="Symbol">:</a> <a id="16667" class="Symbol">‚àÄ</a> <a id="16669" href="#16669" class="Bound">p</a> <a id="16671" class="Symbol">‚Üí</a> <a id="16673" class="Symbol">(</a><a id="16674" href="#16674" class="Bound">xs</a> <a id="16677" href="#16677" class="Bound">ys</a> <a id="16680" class="Symbol">:</a> <a id="16682" href="#8679" class="Datatype">ùí´</a> <a id="16684" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a><a id="16685" class="Symbol">)</a> <a id="16687" class="Symbol">‚Üí</a> <a id="16689" href="#16669" class="Bound">p</a> <a id="16691" href="#14109" class="Function Operator">‚ãä</a> <a id="16693" href="#16674" class="Bound">xs</a> <a id="16696" href="#13390" class="Function Operator">‚à™</a> <a id="16698" href="#16669" class="Bound">p</a> <a id="16700" href="#14109" class="Function Operator">‚ãä</a> <a id="16702" href="#16677" class="Bound">ys</a> <a id="16705" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">‚â°</a> <a id="16707" href="#16669" class="Bound">p</a> <a id="16709" href="#14109" class="Function Operator">‚ãä</a> <a id="16711" class="Symbol">(</a><a id="16712" href="#16674" class="Bound">xs</a> <a id="16715" href="#13390" class="Function Operator">‚à™</a> <a id="16717" href="#16677" class="Bound">ys</a><a id="16719" class="Symbol">)</a>
<a id="16721" href="#16654" class="Function">‚ãä-distribÀ°</a> <a id="16732" class="Symbol">=</a> <a id="16734" class="Symbol">Œª</a> <a id="16736" href="#16736" class="Bound">p</a> <a id="16738" href="#16738" class="Bound">xs</a> <a id="16741" href="#16741" class="Bound">ys</a> <a id="16744" class="Symbol">‚Üí</a> <a id="16746" href="#12103" class="Function Operator">‚ü¶</a> <a id="16748" href="#16798" class="Function">‚ãä-distribÀ°‚Ä≤</a> <a id="16760" href="#16736" class="Bound">p</a> <a id="16762" href="#16741" class="Bound">ys</a> <a id="16765" href="#12103" class="Function Operator">‚üß‚áì</a> <a id="16768" href="#16738" class="Bound">xs</a>
  <a id="16773" class="Keyword">module</a> <a id="JDistribL"></a><a id="16780" href="#16780" class="Module">JDistribL</a> <a id="16790" class="Keyword">where</a>
  <a id="JDistribL.‚ãä-distribÀ°‚Ä≤"></a><a id="16798" href="#16798" class="Function">‚ãä-distribÀ°‚Ä≤</a> <a id="16810" class="Symbol">:</a> <a id="16812" class="Symbol">‚àÄ</a> <a id="16814" href="#16814" class="Bound">p</a> <a id="16816" href="#16816" class="Bound">ys</a> <a id="16819" class="Symbol">‚Üí</a> <a id="16821" href="#12139" class="Function">‚ü¶</a> <a id="16823" href="#16823" class="Bound">xs</a> <a id="16826" href="#12139" class="Function">‚ààùí´</a> <a id="16829" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="16831" href="#12139" class="Function">‚áí</a> <a id="16833" href="#16814" class="Bound">p</a> <a id="16835" href="#14109" class="Function Operator">‚ãä</a> <a id="16837" href="#16823" class="Bound">xs</a> <a id="16840" href="#13390" class="Function Operator">‚à™</a> <a id="16842" href="#16814" class="Bound">p</a> <a id="16844" href="#14109" class="Function Operator">‚ãä</a> <a id="16846" href="#16816" class="Bound">ys</a> <a id="16849" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">‚â°</a> <a id="16851" href="#16814" class="Bound">p</a> <a id="16853" href="#14109" class="Function Operator">‚ãä</a> <a id="16855" class="Symbol">(</a><a id="16856" href="#16823" class="Bound">xs</a> <a id="16859" href="#13390" class="Function Operator">‚à™</a> <a id="16861" href="#16816" class="Bound">ys</a><a id="16863" class="Symbol">)</a> <a id="16865" href="#12139" class="Function">‚üß</a>
  <a id="16869" href="#11443" class="Field Operator">‚ü¶</a> <a id="16871" href="#16798" class="Function">‚ãä-distribÀ°‚Ä≤</a> <a id="16883" href="#16883" class="Bound">p</a> <a id="16885" href="#16885" class="Bound">ys</a> <a id="16888" href="#11443" class="Field Operator">‚üß-prop</a> <a id="16895" class="Symbol">=</a> <a id="16897" href="#8921" class="InductiveConstructor">trunc</a> <a id="16903" class="Symbol">_</a> <a id="16905" class="Symbol">_</a>
  <a id="16909" href="#11481" class="Field Operator">‚ü¶</a> <a id="16911" href="#16798" class="Function">‚ãä-distribÀ°‚Ä≤</a> <a id="16923" href="#16923" class="Bound">p</a> <a id="16925" href="#16925" class="Bound">ys</a> <a id="16928" href="#11481" class="Field Operator">‚üß[]</a> <a id="16932" class="Symbol">=</a> <a id="16934" href="../code/probability/Cubical.Foundations.Prelude.html#827" class="Function">refl</a>
  <a id="16941" href="#11498" class="Field Operator">‚ü¶</a> <a id="16943" href="#16798" class="Function">‚ãä-distribÀ°‚Ä≤</a> <a id="16955" href="#16955" class="Bound">p</a> <a id="16957" href="#16957" class="Bound">ys</a> <a id="16960" href="#11498" class="Field Operator">‚üß</a> <a id="16962" href="#16962" class="Bound">q</a> <a id="16964" href="#11498" class="Field Operator">&amp;</a> <a id="16966" href="#16966" class="Bound">x</a> <a id="16968" href="#11498" class="Field Operator">‚à∑</a> <a id="16970" href="#16970" class="Bound">xs</a> <a id="16973" href="#11498" class="Field Operator">‚ü®</a> <a id="16975" href="#16975" class="Bound">P</a> <a id="16977" href="#11498" class="Field Operator">‚ü©</a> <a id="16979" class="Symbol">=</a>
    <a id="16985" href="#16955" class="Bound">p</a> <a id="16987" href="#14109" class="Function Operator">‚ãä</a> <a id="16989" class="Symbol">(</a><a id="16990" href="#16962" class="Bound">q</a> <a id="16992" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="16994" href="#16966" class="Bound">x</a> <a id="16996" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="16998" href="#16970" class="Bound">xs</a><a id="17000" class="Symbol">)</a> <a id="17002" href="#13390" class="Function Operator">‚à™</a> <a id="17004" href="#16955" class="Bound">p</a> <a id="17006" href="#14109" class="Function Operator">‚ãä</a> <a id="17008" href="#16957" class="Bound">ys</a> <a id="17011" href="../code/probability/ProbabilityModule.Utils.html#572" class="Function Operator">‚â°‚ü®‚ü©</a>
    <a id="17019" href="#16955" class="Bound">p</a> <a id="17021" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="17023" href="#16962" class="Bound">q</a> <a id="17025" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="17027" href="#16966" class="Bound">x</a> <a id="17029" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="17031" href="#16955" class="Bound">p</a> <a id="17033" href="#14109" class="Function Operator">‚ãä</a> <a id="17035" href="#16970" class="Bound">xs</a> <a id="17038" href="#13390" class="Function Operator">‚à™</a> <a id="17040" href="#16955" class="Bound">p</a> <a id="17042" href="#14109" class="Function Operator">‚ãä</a> <a id="17044" href="#16957" class="Bound">ys</a> <a id="17047" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚â°‚ü®</a> <a id="17050" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="17055" class="Symbol">(</a><a id="17056" href="#16955" class="Bound">p</a> <a id="17058" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="17060" href="#16962" class="Bound">q</a> <a id="17062" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="17064" href="#16966" class="Bound">x</a> <a id="17066" href="#8727" class="InductiveConstructor Operator">‚à∑_</a><a id="17068" class="Symbol">)</a> <a id="17070" href="#16975" class="Bound">P</a> <a id="17072" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚ü©</a>
    <a id="17078" href="#16955" class="Bound">p</a> <a id="17080" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="17082" href="#16962" class="Bound">q</a> <a id="17084" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="17086" href="#16966" class="Bound">x</a> <a id="17088" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="17090" href="#16955" class="Bound">p</a> <a id="17092" href="#14109" class="Function Operator">‚ãä</a> <a id="17094" class="Symbol">(</a><a id="17095" href="#16970" class="Bound">xs</a> <a id="17098" href="#13390" class="Function Operator">‚à™</a> <a id="17100" href="#16957" class="Bound">ys</a><a id="17102" class="Symbol">)</a> <a id="17104" href="../code/probability/ProbabilityModule.Utils.html#572" class="Function Operator">‚â°‚ü®‚ü©</a>
    <a id="17112" href="#16955" class="Bound">p</a> <a id="17114" href="#14109" class="Function Operator">‚ãä</a> <a id="17116" class="Symbol">((</a><a id="17118" href="#16962" class="Bound">q</a> <a id="17120" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="17122" href="#16966" class="Bound">x</a> <a id="17124" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="17126" href="#16970" class="Bound">xs</a><a id="17128" class="Symbol">)</a> <a id="17130" href="#13390" class="Function Operator">‚à™</a> <a id="17132" href="#16957" class="Bound">ys</a><a id="17134" class="Symbol">)</a> <a id="17136" href="../code/probability/Cubical.Foundations.Prelude.html#2745" class="Function Operator">‚àé</a>


<a id="‚à™-id ≥"></a><a id="17140" href="#17140" class="Function">‚à™-id ≥</a> <a id="17146" class="Symbol">:</a> <a id="17148" class="Symbol">(</a><a id="17149" href="#17149" class="Bound">xs</a> <a id="17152" class="Symbol">:</a> <a id="17154" href="#8679" class="Datatype">ùí´</a> <a id="17156" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a><a id="17157" class="Symbol">)</a> <a id="17159" class="Symbol">‚Üí</a> <a id="17161" href="#17149" class="Bound">xs</a> <a id="17164" href="#13390" class="Function Operator">‚à™</a> <a id="17166" href="#8715" class="InductiveConstructor">[]</a> <a id="17169" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">‚â°</a> <a id="17171" href="#17149" class="Bound">xs</a>
<a id="17174" href="#17140" class="Function">‚à™-id ≥</a> <a id="17180" class="Symbol">=</a> <a id="17182" href="#12103" class="Function Operator">‚ü¶</a> <a id="17184" href="#17216" class="Function">‚à™-id ≥‚Ä≤</a> <a id="17191" href="#12103" class="Function Operator">‚üß‚áì</a>
  <a id="17196" class="Keyword">module</a> <a id="UIdR"></a><a id="17203" href="#17203" class="Module">UIdR</a> <a id="17208" class="Keyword">where</a>
  <a id="UIdR.‚à™-id ≥‚Ä≤"></a><a id="17216" href="#17216" class="Function">‚à™-id ≥‚Ä≤</a> <a id="17223" class="Symbol">:</a> <a id="17225" href="#12139" class="Function">‚ü¶</a> <a id="17227" href="#17227" class="Bound">xs</a> <a id="17230" href="#12139" class="Function">‚ààùí´</a> <a id="17233" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="17235" href="#12139" class="Function">‚áí</a> <a id="17237" href="#17227" class="Bound">xs</a> <a id="17240" href="#13390" class="Function Operator">‚à™</a> <a id="17242" href="#8715" class="InductiveConstructor">[]</a> <a id="17245" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">‚â°</a> <a id="17247" href="#17227" class="Bound">xs</a> <a id="17250" href="#12139" class="Function">‚üß</a>
  <a id="17254" href="#11443" class="Field Operator">‚ü¶</a> <a id="17256" href="#17216" class="Function">‚à™-id ≥‚Ä≤</a> <a id="17263" href="#11443" class="Field Operator">‚üß-prop</a> <a id="17270" class="Symbol">=</a> <a id="17272" href="#8921" class="InductiveConstructor">trunc</a> <a id="17278" class="Symbol">_</a> <a id="17280" class="Symbol">_</a>
  <a id="17284" href="#11481" class="Field Operator">‚ü¶</a> <a id="17286" href="#17216" class="Function">‚à™-id ≥‚Ä≤</a> <a id="17293" href="#11481" class="Field Operator">‚üß[]</a> <a id="17297" class="Symbol">=</a> <a id="17299" href="../code/probability/Cubical.Foundations.Prelude.html#827" class="Function">refl</a>
  <a id="17306" href="#11498" class="Field Operator">‚ü¶</a> <a id="17308" href="#17216" class="Function">‚à™-id ≥‚Ä≤</a> <a id="17315" href="#11498" class="Field Operator">‚üß</a> <a id="17317" href="#17317" class="Bound">p</a> <a id="17319" href="#11498" class="Field Operator">&amp;</a> <a id="17321" href="#17321" class="Bound">x</a> <a id="17323" href="#11498" class="Field Operator">‚à∑</a> <a id="17325" href="#17325" class="Bound">xs</a> <a id="17328" href="#11498" class="Field Operator">‚ü®</a> <a id="17330" href="#17330" class="Bound">P</a> <a id="17332" href="#11498" class="Field Operator">‚ü©</a> <a id="17334" class="Symbol">=</a> <a id="17336" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="17341" class="Symbol">(</a><a id="17342" href="#17317" class="Bound">p</a> <a id="17344" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="17346" href="#17321" class="Bound">x</a> <a id="17348" href="#8727" class="InductiveConstructor Operator">‚à∑_</a><a id="17350" class="Symbol">)</a> <a id="17352" href="#17330" class="Bound">P</a>

<a id="‚à™-comm"></a><a id="17355" href="#17355" class="Function">‚à™-comm</a> <a id="17362" class="Symbol">:</a> <a id="17364" class="Symbol">(</a><a id="17365" href="#17365" class="Bound">xs</a> <a id="17368" href="#17368" class="Bound">ys</a> <a id="17371" class="Symbol">:</a> <a id="17373" href="#8679" class="Datatype">ùí´</a> <a id="17375" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a><a id="17376" class="Symbol">)</a> <a id="17378" class="Symbol">‚Üí</a> <a id="17380" href="#17365" class="Bound">xs</a> <a id="17383" href="#13390" class="Function Operator">‚à™</a> <a id="17385" href="#17368" class="Bound">ys</a> <a id="17388" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">‚â°</a> <a id="17390" href="#17368" class="Bound">ys</a> <a id="17393" href="#13390" class="Function Operator">‚à™</a> <a id="17395" href="#17365" class="Bound">xs</a>
<a id="17398" href="#17355" class="Function">‚à™-comm</a> <a id="17405" class="Symbol">=</a> <a id="17407" class="Symbol">Œª</a> <a id="17409" href="#17409" class="Bound">xs</a> <a id="17412" href="#17412" class="Bound">ys</a> <a id="17415" class="Symbol">‚Üí</a> <a id="17417" href="#12103" class="Function Operator">‚ü¶</a> <a id="17419" href="#17459" class="Function">‚à™-comm‚Ä≤</a> <a id="17427" href="#17412" class="Bound">ys</a> <a id="17430" href="#12103" class="Function Operator">‚üß‚áì</a> <a id="17433" href="#17409" class="Bound">xs</a>
  <a id="17438" class="Keyword">module</a> <a id="UComm"></a><a id="17445" href="#17445" class="Module">UComm</a> <a id="17451" class="Keyword">where</a>
  <a id="UComm.‚à™-comm‚Ä≤"></a><a id="17459" href="#17459" class="Function">‚à™-comm‚Ä≤</a> <a id="17467" class="Symbol">:</a> <a id="17469" class="Symbol">‚àÄ</a> <a id="17471" href="#17471" class="Bound">ys</a> <a id="17474" class="Symbol">‚Üí</a> <a id="17476" href="#12139" class="Function">‚ü¶</a> <a id="17478" href="#17478" class="Bound">xs</a> <a id="17481" href="#12139" class="Function">‚ààùí´</a> <a id="17484" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="17486" href="#12139" class="Function">‚áí</a> <a id="17488" href="#17478" class="Bound">xs</a> <a id="17491" href="#13390" class="Function Operator">‚à™</a> <a id="17493" href="#17471" class="Bound">ys</a> <a id="17496" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">‚â°</a> <a id="17498" href="#17471" class="Bound">ys</a> <a id="17501" href="#13390" class="Function Operator">‚à™</a> <a id="17503" href="#17478" class="Bound">xs</a> <a id="17506" href="#12139" class="Function">‚üß</a>
  <a id="17510" href="#11443" class="Field Operator">‚ü¶</a> <a id="17512" href="#17459" class="Function">‚à™-comm‚Ä≤</a> <a id="17520" href="#17520" class="Bound">ys</a> <a id="17523" href="#11443" class="Field Operator">‚üß-prop</a> <a id="17530" class="Symbol">=</a> <a id="17532" href="#8921" class="InductiveConstructor">trunc</a> <a id="17538" class="Symbol">_</a> <a id="17540" class="Symbol">_</a>
  <a id="17544" href="#11481" class="Field Operator">‚ü¶</a> <a id="17546" href="#17459" class="Function">‚à™-comm‚Ä≤</a> <a id="17554" href="#17554" class="Bound">ys</a> <a id="17557" href="#11481" class="Field Operator">‚üß[]</a> <a id="17561" class="Symbol">=</a> <a id="17563" href="../code/probability/Cubical.Foundations.Prelude.html#864" class="Function">sym</a> <a id="17567" class="Symbol">(</a><a id="17568" href="#17140" class="Function">‚à™-id ≥</a> <a id="17574" href="#17554" class="Bound">ys</a><a id="17576" class="Symbol">)</a>
  <a id="17580" href="#11498" class="Field Operator">‚ü¶</a> <a id="17582" href="#17459" class="Function">‚à™-comm‚Ä≤</a> <a id="17590" href="#17590" class="Bound">ys</a> <a id="17593" href="#11498" class="Field Operator">‚üß</a> <a id="17595" href="#17595" class="Bound">p</a> <a id="17597" href="#11498" class="Field Operator">&amp;</a> <a id="17599" href="#17599" class="Bound">x</a> <a id="17601" href="#11498" class="Field Operator">‚à∑</a> <a id="17603" href="#17603" class="Bound">xs</a> <a id="17606" href="#11498" class="Field Operator">‚ü®</a> <a id="17608" href="#17608" class="Bound">P</a> <a id="17610" href="#11498" class="Field Operator">‚ü©</a> <a id="17612" class="Symbol">=</a> <a id="17614" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="17619" class="Symbol">(</a><a id="17620" href="#17595" class="Bound">p</a> <a id="17622" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="17624" href="#17599" class="Bound">x</a> <a id="17626" href="#8727" class="InductiveConstructor Operator">‚à∑_</a><a id="17628" class="Symbol">)</a> <a id="17630" href="#17608" class="Bound">P</a> <a id="17632" href="../code/probability/Cubical.Foundations.Prelude.html#1674" class="Function Operator">Õæ</a> <a id="17634" href="../code/probability/Cubical.Foundations.Prelude.html#864" class="Function">sym</a> <a id="17638" class="Symbol">(</a><a id="17639" href="#15455" class="Function">‚à™-cons</a> <a id="17646" href="#17595" class="Bound">p</a> <a id="17648" href="#17599" class="Bound">x</a> <a id="17650" href="#17590" class="Bound">ys</a> <a id="17653" href="#17603" class="Bound">xs</a><a id="17655" class="Symbol">)</a>

<a id="0‚ãä"></a><a id="17658" href="#17658" class="Function">0‚ãä</a> <a id="17661" class="Symbol">:</a> <a id="17663" class="Symbol">(</a><a id="17664" href="#17664" class="Bound">xs</a> <a id="17667" class="Symbol">:</a> <a id="17669" href="#8679" class="Datatype">ùí´</a> <a id="17671" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a><a id="17672" class="Symbol">)</a> <a id="17674" class="Symbol">‚Üí</a> <a id="17676" href="../code/probability/ProbabilityModule.Semirings.html#254" class="Field">0#</a> <a id="17679" href="#14109" class="Function Operator">‚ãä</a> <a id="17681" href="#17664" class="Bound">xs</a> <a id="17684" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">‚â°</a> <a id="17686" href="#8715" class="InductiveConstructor">[]</a>
<a id="17689" href="#17658" class="Function">0‚ãä</a> <a id="17692" class="Symbol">=</a> <a id="17694" href="#12103" class="Function Operator">‚ü¶</a> <a id="17696" href="#17726" class="Function">0‚ãä‚Ä≤</a> <a id="17700" href="#12103" class="Function Operator">‚üß‚áì</a>
  <a id="17705" class="Keyword">module</a> <a id="ZeroJ"></a><a id="17712" href="#17712" class="Module">ZeroJ</a> <a id="17718" class="Keyword">where</a>
  <a id="ZeroJ.0‚ãä‚Ä≤"></a><a id="17726" href="#17726" class="Function">0‚ãä‚Ä≤</a> <a id="17730" class="Symbol">:</a> <a id="17732" href="#12139" class="Function">‚ü¶</a> <a id="17734" href="#17734" class="Bound">xs</a> <a id="17737" href="#12139" class="Function">‚ààùí´</a> <a id="17740" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="17742" href="#12139" class="Function">‚áí</a> <a id="17744" href="../code/probability/ProbabilityModule.Semirings.html#254" class="Field">0#</a> <a id="17747" href="#14109" class="Function Operator">‚ãä</a> <a id="17749" href="#17734" class="Bound">xs</a> <a id="17752" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">‚â°</a> <a id="17754" href="#8715" class="InductiveConstructor">[]</a> <a id="17757" href="#12139" class="Function">‚üß</a>
  <a id="17761" href="#11443" class="Field Operator">‚ü¶</a> <a id="17763" href="#17726" class="Function">0‚ãä‚Ä≤</a> <a id="17767" href="#11443" class="Field Operator">‚üß-prop</a> <a id="17774" class="Symbol">=</a> <a id="17776" href="#8921" class="InductiveConstructor">trunc</a> <a id="17782" class="Symbol">_</a> <a id="17784" class="Symbol">_</a>
  <a id="17788" href="#11481" class="Field Operator">‚ü¶</a> <a id="17790" href="#17726" class="Function">0‚ãä‚Ä≤</a> <a id="17794" href="#11481" class="Field Operator">‚üß[]</a> <a id="17798" class="Symbol">=</a> <a id="17800" href="../code/probability/Cubical.Foundations.Prelude.html#827" class="Function">refl</a>
  <a id="17807" href="#11498" class="Field Operator">‚ü¶</a> <a id="17809" href="#17726" class="Function">0‚ãä‚Ä≤</a> <a id="17813" href="#11498" class="Field Operator">‚üß</a> <a id="17815" href="#17815" class="Bound">p</a> <a id="17817" href="#11498" class="Field Operator">&amp;</a> <a id="17819" href="#17819" class="Bound">x</a> <a id="17821" href="#11498" class="Field Operator">‚à∑</a> <a id="17823" href="#17823" class="Bound">xs</a> <a id="17826" href="#11498" class="Field Operator">‚ü®</a> <a id="17828" href="#17828" class="Bound">P</a> <a id="17830" href="#11498" class="Field Operator">‚ü©</a> <a id="17832" class="Symbol">=</a>
    <a id="17838" href="../code/probability/ProbabilityModule.Semirings.html#254" class="Field">0#</a> <a id="17841" href="#14109" class="Function Operator">‚ãä</a> <a id="17843" class="Symbol">(</a><a id="17844" href="#17815" class="Bound">p</a> <a id="17846" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="17848" href="#17819" class="Bound">x</a> <a id="17850" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="17852" href="#17823" class="Bound">xs</a><a id="17854" class="Symbol">)</a>    <a id="17859" href="../code/probability/ProbabilityModule.Utils.html#572" class="Function Operator">‚â°‚ü®‚ü©</a>
    <a id="17867" href="../code/probability/ProbabilityModule.Semirings.html#254" class="Field">0#</a> <a id="17870" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="17872" href="#17815" class="Bound">p</a> <a id="17874" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="17876" href="#17819" class="Bound">x</a> <a id="17878" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="17880" href="../code/probability/ProbabilityModule.Semirings.html#254" class="Field">0#</a> <a id="17883" href="#14109" class="Function Operator">‚ãä</a> <a id="17885" href="#17823" class="Bound">xs</a> <a id="17888" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚â°‚ü®</a> <a id="17891" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="17896" class="Symbol">(</a><a id="17897" href="#8727" class="InductiveConstructor Operator">_&amp;</a> <a id="17900" href="#17819" class="Bound">x</a> <a id="17902" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="17904" href="../code/probability/ProbabilityModule.Semirings.html#254" class="Field">0#</a> <a id="17907" href="#14109" class="Function Operator">‚ãä</a> <a id="17909" href="#17823" class="Bound">xs</a><a id="17911" class="Symbol">)</a> <a id="17913" class="Symbol">(</a><a id="17914" href="../code/probability/ProbabilityModule.Semirings.html#403" class="Field">0*</a> <a id="17917" href="#17815" class="Bound">p</a><a id="17918" class="Symbol">)</a> <a id="17920" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚ü©</a>
    <a id="17926" href="../code/probability/ProbabilityModule.Semirings.html#254" class="Field">0#</a> <a id="17929" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="17931" href="#17819" class="Bound">x</a> <a id="17933" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="17935" href="../code/probability/ProbabilityModule.Semirings.html#254" class="Field">0#</a> <a id="17938" href="#14109" class="Function Operator">‚ãä</a> <a id="17940" href="#17823" class="Bound">xs</a>     <a id="17947" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚â°‚ü®</a> <a id="17950" href="#8887" class="InductiveConstructor">del</a> <a id="17954" href="#17819" class="Bound">x</a> <a id="17956" class="Symbol">(</a><a id="17957" href="../code/probability/ProbabilityModule.Semirings.html#254" class="Field">0#</a> <a id="17960" href="#14109" class="Function Operator">‚ãä</a> <a id="17962" href="#17823" class="Bound">xs</a><a id="17964" class="Symbol">)</a> <a id="17966" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚ü©</a>
    <a id="17972" href="../code/probability/ProbabilityModule.Semirings.html#254" class="Field">0#</a> <a id="17975" href="#14109" class="Function Operator">‚ãä</a> <a id="17977" href="#17823" class="Bound">xs</a>              <a id="17993" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚â°‚ü®</a> <a id="17996" href="#17828" class="Bound">P</a> <a id="17998" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚ü©</a>
    <a id="18004" href="#8715" class="InductiveConstructor">[]</a> <a id="18007" href="../code/probability/Cubical.Foundations.Prelude.html#2745" class="Function Operator">‚àé</a>
</pre>
</details>
<p>However, I <em>can</em> demonstrate the monadic bind:</p>
<pre class="Agda"><a id="_&gt;&gt;=_"></a><a id="18081" href="#18081" class="Function Operator">_&gt;&gt;=_</a> <a id="18087" class="Symbol">:</a> <a id="18089" href="#8679" class="Datatype">ùí´</a> <a id="18091" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="18093" class="Symbol">‚Üí</a> <a id="18095" class="Symbol">(</a><a id="18096" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="18098" class="Symbol">‚Üí</a> <a id="18100" href="#8679" class="Datatype">ùí´</a> <a id="18102" href="../code/probability/ProbabilityModule.Utils.html#206" class="Generalizable">B</a><a id="18103" class="Symbol">)</a> <a id="18105" class="Symbol">‚Üí</a> <a id="18107" href="#8679" class="Datatype">ùí´</a> <a id="18109" href="../code/probability/ProbabilityModule.Utils.html#206" class="Generalizable">B</a>
<a id="18111" href="#18111" class="Bound">xs</a> <a id="18114" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="18118" href="#18118" class="Bound">f</a> <a id="18120" class="Symbol">=</a> <a id="18122" href="#12874" class="Function Operator">[</a> <a id="18124" href="#18118" class="Bound">f</a> <a id="18126" href="#18158" class="Function Operator">=&lt;&lt;</a> <a id="18130" href="#12874" class="Function Operator">]‚Üì</a> <a id="18133" href="#18111" class="Bound">xs</a>
  <a id="18138" class="Keyword">module</a> <a id="Bind"></a><a id="18145" href="#18145" class="Module">Bind</a> <a id="18150" class="Keyword">where</a>
  <a id="Bind._=&lt;&lt;"></a><a id="18158" href="#18158" class="Function Operator">_=&lt;&lt;</a> <a id="18163" class="Symbol">:</a> <a id="18165" class="Symbol">(</a><a id="18166" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="18168" class="Symbol">‚Üí</a> <a id="18170" href="#8679" class="Datatype">ùí´</a> <a id="18172" href="../code/probability/ProbabilityModule.Utils.html#206" class="Generalizable">B</a><a id="18173" class="Symbol">)</a> <a id="18175" class="Symbol">‚Üí</a> <a id="18177" href="#12307" class="Record Operator">[</a> <a id="18179" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="18181" href="#12307" class="Record Operator">‚Ü¶</a> <a id="18183" href="#8679" class="Datatype">ùí´</a> <a id="18185" href="../code/probability/ProbabilityModule.Utils.html#206" class="Generalizable">B</a> <a id="18187" href="#12307" class="Record Operator">]</a>
  <a id="18191" href="#12420" class="Field Operator">[</a> <a id="18193" href="#18193" class="Bound">f</a> <a id="18195" href="#18158" class="Function Operator">=&lt;&lt;</a> <a id="18199" href="#12420" class="Field Operator">]</a> <a id="18201" href="#18201" class="Bound">p</a> <a id="18203" href="#12420" class="Field Operator">&amp;</a> <a id="18205" href="#18205" class="Bound">x</a> <a id="18207" href="#12420" class="Field Operator">‚à∑</a> <a id="18209" href="#18209" class="Bound">xs</a> <a id="18212" class="Symbol">=</a> <a id="18214" href="#18201" class="Bound">p</a> <a id="18216" href="#14109" class="Function Operator">‚ãä</a> <a id="18218" class="Symbol">(</a><a id="18219" href="#18193" class="Bound">f</a> <a id="18221" href="#18205" class="Bound">x</a><a id="18222" class="Symbol">)</a> <a id="18224" href="#13390" class="Function Operator">‚à™</a> <a id="18226" href="#18209" class="Bound">xs</a>
  <a id="18231" href="#12449" class="Field Operator">[</a> <a id="18233" href="#18233" class="Bound">f</a> <a id="18235" href="#18158" class="Function Operator">=&lt;&lt;</a> <a id="18239" href="#12449" class="Field Operator">][]</a> <a id="18243" class="Symbol">=</a> <a id="18245" href="#8715" class="InductiveConstructor">[]</a>
  <a id="18250" href="#12397" class="Field Operator">[</a> <a id="18252" href="#18252" class="Bound">f</a> <a id="18254" href="#18158" class="Function Operator">=&lt;&lt;</a> <a id="18258" href="#12397" class="Field Operator">]-set</a> <a id="18264" class="Symbol">=</a> <a id="18266" href="#8921" class="InductiveConstructor">trunc</a>
  <a id="18274" href="#12635" class="Field Operator">[</a> <a id="18276" href="#18276" class="Bound">f</a> <a id="18278" href="#18158" class="Function Operator">=&lt;&lt;</a> <a id="18282" href="#12635" class="Field Operator">]-del</a> <a id="18288" href="#18288" class="Bound">x</a> <a id="18290" href="#18290" class="Bound">xs</a> <a id="18293" class="Symbol">=</a> <a id="18295" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="18300" class="Symbol">(</a><a id="18301" href="#13390" class="Function Operator">_‚à™</a> <a id="18304" href="#18290" class="Bound">xs</a><a id="18306" class="Symbol">)</a> <a id="18308" class="Symbol">(</a><a id="18309" href="#17658" class="Function">0‚ãä</a> <a id="18312" class="Symbol">(</a><a id="18313" href="#18276" class="Bound">f</a> <a id="18315" href="#18288" class="Bound">x</a><a id="18316" class="Symbol">))</a>
  <a id="18321" href="#12508" class="Field Operator">[</a> <a id="18323" href="#18323" class="Bound">f</a> <a id="18325" href="#18158" class="Function Operator">=&lt;&lt;</a> <a id="18329" href="#12508" class="Field Operator">]-dup</a> <a id="18335" href="#18335" class="Bound">p</a> <a id="18337" href="#18337" class="Bound">q</a> <a id="18339" href="#18339" class="Bound">x</a> <a id="18341" href="#18341" class="Bound">xs</a> <a id="18344" class="Symbol">=</a>
    <a id="18350" href="#18335" class="Bound">p</a> <a id="18352" href="#14109" class="Function Operator">‚ãä</a> <a id="18354" class="Symbol">(</a><a id="18355" href="#18323" class="Bound">f</a> <a id="18357" href="#18339" class="Bound">x</a><a id="18358" class="Symbol">)</a> <a id="18360" href="#13390" class="Function Operator">‚à™</a> <a id="18362" href="#18337" class="Bound">q</a> <a id="18364" href="#14109" class="Function Operator">‚ãä</a> <a id="18366" class="Symbol">(</a><a id="18367" href="#18323" class="Bound">f</a> <a id="18369" href="#18339" class="Bound">x</a><a id="18370" class="Symbol">)</a> <a id="18372" href="#13390" class="Function Operator">‚à™</a> <a id="18374" href="#18341" class="Bound">xs</a>   <a id="18379" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚â°‚ü®</a> <a id="18382" href="#13658" class="Function">‚à™-assoc</a> <a id="18390" class="Symbol">(</a><a id="18391" href="#18335" class="Bound">p</a> <a id="18393" href="#14109" class="Function Operator">‚ãä</a> <a id="18395" href="#18323" class="Bound">f</a> <a id="18397" href="#18339" class="Bound">x</a><a id="18398" class="Symbol">)</a> <a id="18400" class="Symbol">(</a><a id="18401" href="#18337" class="Bound">q</a> <a id="18403" href="#14109" class="Function Operator">‚ãä</a> <a id="18405" href="#18323" class="Bound">f</a> <a id="18407" href="#18339" class="Bound">x</a><a id="18408" class="Symbol">)</a> <a id="18410" href="#18341" class="Bound">xs</a> <a id="18413" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚ü©</a>
    <a id="18419" class="Symbol">(</a><a id="18420" href="#18335" class="Bound">p</a> <a id="18422" href="#14109" class="Function Operator">‚ãä</a> <a id="18424" class="Symbol">(</a><a id="18425" href="#18323" class="Bound">f</a> <a id="18427" href="#18339" class="Bound">x</a><a id="18428" class="Symbol">)</a> <a id="18430" href="#13390" class="Function Operator">‚à™</a> <a id="18432" href="#18337" class="Bound">q</a> <a id="18434" href="#14109" class="Function Operator">‚ãä</a> <a id="18436" class="Symbol">(</a><a id="18437" href="#18323" class="Bound">f</a> <a id="18439" href="#18339" class="Bound">x</a><a id="18440" class="Symbol">))</a> <a id="18443" href="#13390" class="Function Operator">‚à™</a> <a id="18445" href="#18341" class="Bound">xs</a> <a id="18448" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚â°‚ü®</a> <a id="18451" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="18456" class="Symbol">(</a><a id="18457" href="#13390" class="Function Operator">_‚à™</a> <a id="18460" href="#18341" class="Bound">xs</a><a id="18462" class="Symbol">)</a> <a id="18464" class="Symbol">(</a><a id="18465" href="#15807" class="Function">‚ãä-distrib ≥</a> <a id="18476" href="#18335" class="Bound">p</a> <a id="18478" href="#18337" class="Bound">q</a> <a id="18480" class="Symbol">(</a><a id="18481" href="#18323" class="Bound">f</a> <a id="18483" href="#18339" class="Bound">x</a><a id="18484" class="Symbol">)</a> <a id="18486" class="Symbol">)</a> <a id="18488" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚ü©</a>
    <a id="18494" href="#14109" class="Function Operator">_‚ãä_</a> <a id="18498" class="Symbol">(</a><a id="18499" href="#18335" class="Bound">p</a> <a id="18501" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="18503" href="#18337" class="Bound">q</a><a id="18504" class="Symbol">)</a> <a id="18506" class="Symbol">(</a><a id="18507" href="#18323" class="Bound">f</a> <a id="18509" href="#18339" class="Bound">x</a><a id="18510" class="Symbol">)</a> <a id="18512" href="#13390" class="Function Operator">‚à™</a> <a id="18514" href="#18341" class="Bound">xs</a> <a id="18517" href="../code/probability/Cubical.Foundations.Prelude.html#2745" class="Function Operator">‚àé</a>
  <a id="18521" href="#12570" class="Field Operator">[</a> <a id="18523" href="#18523" class="Bound">f</a> <a id="18525" href="#18158" class="Function Operator">=&lt;&lt;</a> <a id="18529" href="#12570" class="Field Operator">]-com</a> <a id="18535" href="#18535" class="Bound">p</a> <a id="18537" href="#18537" class="Bound">x</a> <a id="18539" href="#18539" class="Bound">q</a> <a id="18541" href="#18541" class="Bound">y</a> <a id="18543" href="#18543" class="Bound">xs</a> <a id="18546" class="Symbol">=</a>
    <a id="18552" href="#18535" class="Bound">p</a> <a id="18554" href="#14109" class="Function Operator">‚ãä</a> <a id="18556" class="Symbol">(</a><a id="18557" href="#18523" class="Bound">f</a> <a id="18559" href="#18537" class="Bound">x</a><a id="18560" class="Symbol">)</a> <a id="18562" href="#13390" class="Function Operator">‚à™</a> <a id="18564" href="#18539" class="Bound">q</a> <a id="18566" href="#14109" class="Function Operator">‚ãä</a> <a id="18568" class="Symbol">(</a><a id="18569" href="#18523" class="Bound">f</a> <a id="18571" href="#18541" class="Bound">y</a><a id="18572" class="Symbol">)</a> <a id="18574" href="#13390" class="Function Operator">‚à™</a> <a id="18576" href="#18543" class="Bound">xs</a>   <a id="18581" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚â°‚ü®</a> <a id="18584" href="#13658" class="Function">‚à™-assoc</a> <a id="18592" class="Symbol">(</a><a id="18593" href="#18535" class="Bound">p</a> <a id="18595" href="#14109" class="Function Operator">‚ãä</a> <a id="18597" href="#18523" class="Bound">f</a> <a id="18599" href="#18537" class="Bound">x</a><a id="18600" class="Symbol">)</a> <a id="18602" class="Symbol">(</a><a id="18603" href="#18539" class="Bound">q</a> <a id="18605" href="#14109" class="Function Operator">‚ãä</a> <a id="18607" href="#18523" class="Bound">f</a> <a id="18609" href="#18541" class="Bound">y</a><a id="18610" class="Symbol">)</a> <a id="18612" href="#18543" class="Bound">xs</a> <a id="18615" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚ü©</a>
    <a id="18621" class="Symbol">(</a><a id="18622" href="#18535" class="Bound">p</a> <a id="18624" href="#14109" class="Function Operator">‚ãä</a> <a id="18626" class="Symbol">(</a><a id="18627" href="#18523" class="Bound">f</a> <a id="18629" href="#18537" class="Bound">x</a><a id="18630" class="Symbol">)</a> <a id="18632" href="#13390" class="Function Operator">‚à™</a> <a id="18634" href="#18539" class="Bound">q</a> <a id="18636" href="#14109" class="Function Operator">‚ãä</a> <a id="18638" class="Symbol">(</a><a id="18639" href="#18523" class="Bound">f</a> <a id="18641" href="#18541" class="Bound">y</a><a id="18642" class="Symbol">))</a> <a id="18645" href="#13390" class="Function Operator">‚à™</a> <a id="18647" href="#18543" class="Bound">xs</a> <a id="18650" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚â°‚ü®</a> <a id="18653" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="18658" class="Symbol">(</a><a id="18659" href="#13390" class="Function Operator">_‚à™</a> <a id="18662" href="#18543" class="Bound">xs</a><a id="18664" class="Symbol">)</a> <a id="18666" class="Symbol">(</a><a id="18667" href="#17355" class="Function">‚à™-comm</a> <a id="18674" class="Symbol">(</a><a id="18675" href="#18535" class="Bound">p</a> <a id="18677" href="#14109" class="Function Operator">‚ãä</a> <a id="18679" href="#18523" class="Bound">f</a> <a id="18681" href="#18537" class="Bound">x</a><a id="18682" class="Symbol">)</a> <a id="18684" class="Symbol">(</a><a id="18685" href="#18539" class="Bound">q</a> <a id="18687" href="#14109" class="Function Operator">‚ãä</a> <a id="18689" href="#18523" class="Bound">f</a> <a id="18691" href="#18541" class="Bound">y</a><a id="18692" class="Symbol">))</a> <a id="18695" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚ü©</a>
    <a id="18701" class="Symbol">(</a><a id="18702" href="#18539" class="Bound">q</a> <a id="18704" href="#14109" class="Function Operator">‚ãä</a> <a id="18706" class="Symbol">(</a><a id="18707" href="#18523" class="Bound">f</a> <a id="18709" href="#18541" class="Bound">y</a><a id="18710" class="Symbol">)</a> <a id="18712" href="#13390" class="Function Operator">‚à™</a> <a id="18714" href="#18535" class="Bound">p</a> <a id="18716" href="#14109" class="Function Operator">‚ãä</a> <a id="18718" class="Symbol">(</a><a id="18719" href="#18523" class="Bound">f</a> <a id="18721" href="#18537" class="Bound">x</a><a id="18722" class="Symbol">))</a> <a id="18725" href="#13390" class="Function Operator">‚à™</a> <a id="18727" href="#18543" class="Bound">xs</a> <a id="18730" href="../code/probability/ProbabilityModule.Utils.html#295" class="Function">‚â°Àò‚ü®</a> <a id="18734" href="#13658" class="Function">‚à™-assoc</a> <a id="18742" class="Symbol">(</a><a id="18743" href="#18539" class="Bound">q</a> <a id="18745" href="#14109" class="Function Operator">‚ãä</a> <a id="18747" href="#18523" class="Bound">f</a> <a id="18749" href="#18541" class="Bound">y</a><a id="18750" class="Symbol">)</a> <a id="18752" class="Symbol">(</a><a id="18753" href="#18535" class="Bound">p</a> <a id="18755" href="#14109" class="Function Operator">‚ãä</a> <a id="18757" href="#18523" class="Bound">f</a> <a id="18759" href="#18537" class="Bound">x</a><a id="18760" class="Symbol">)</a> <a id="18762" href="#18543" class="Bound">xs</a> <a id="18765" href="../code/probability/ProbabilityModule.Utils.html#295" class="Function">‚ü©</a>
    <a id="18771" href="#18539" class="Bound">q</a> <a id="18773" href="#14109" class="Function Operator">‚ãä</a> <a id="18775" class="Symbol">(</a><a id="18776" href="#18523" class="Bound">f</a> <a id="18778" href="#18541" class="Bound">y</a><a id="18779" class="Symbol">)</a> <a id="18781" href="#13390" class="Function Operator">‚à™</a> <a id="18783" href="#18535" class="Bound">p</a> <a id="18785" href="#14109" class="Function Operator">‚ãä</a> <a id="18787" class="Symbol">(</a><a id="18788" href="#18523" class="Bound">f</a> <a id="18790" href="#18537" class="Bound">x</a><a id="18791" class="Symbol">)</a> <a id="18793" href="#13390" class="Function Operator">‚à™</a> <a id="18795" href="#18543" class="Bound">xs</a> <a id="18798" href="../code/probability/Cubical.Foundations.Prelude.html#2745" class="Function Operator">‚àé</a>
</pre>
<p>And we can prove the monad laws, also:</p>
<details>
<p><summary>Proofs of Monad Laws</summary></p>
<pre class="Agda"><a id="1‚ãä"></a><a id="18904" href="#18904" class="Function">1‚ãä</a> <a id="18907" class="Symbol">:</a> <a id="18909" class="Symbol">(</a><a id="18910" href="#18910" class="Bound">xs</a> <a id="18913" class="Symbol">:</a> <a id="18915" href="#8679" class="Datatype">ùí´</a> <a id="18917" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a><a id="18918" class="Symbol">)</a> <a id="18920" class="Symbol">‚Üí</a> <a id="18922" href="../code/probability/ProbabilityModule.Semirings.html#265" class="Field">1#</a> <a id="18925" href="#14109" class="Function Operator">‚ãä</a> <a id="18927" href="#18910" class="Bound">xs</a> <a id="18930" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">‚â°</a> <a id="18932" href="#18910" class="Bound">xs</a>
<a id="18935" href="#18904" class="Function">1‚ãä</a> <a id="18938" class="Symbol">=</a> <a id="18940" href="#12103" class="Function Operator">‚ü¶</a> <a id="18942" href="#18974" class="Function">1‚ãä‚Ä≤</a> <a id="18946" href="#12103" class="Function Operator">‚üß‚áì</a>
  <a id="18951" class="Keyword">module</a> <a id="OneJoin"></a><a id="18958" href="#18958" class="Module">OneJoin</a> <a id="18966" class="Keyword">where</a>
  <a id="OneJoin.1‚ãä‚Ä≤"></a><a id="18974" href="#18974" class="Function">1‚ãä‚Ä≤</a> <a id="18978" class="Symbol">:</a> <a id="18980" href="#12139" class="Function">‚ü¶</a> <a id="18982" href="#18982" class="Bound">xs</a> <a id="18985" href="#12139" class="Function">‚ààùí´</a> <a id="18988" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="18990" href="#12139" class="Function">‚áí</a> <a id="18992" href="../code/probability/ProbabilityModule.Semirings.html#265" class="Field">1#</a> <a id="18995" href="#14109" class="Function Operator">‚ãä</a> <a id="18997" href="#18982" class="Bound">xs</a> <a id="19000" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">‚â°</a> <a id="19002" href="#18982" class="Bound">xs</a> <a id="19005" href="#12139" class="Function">‚üß</a>
  <a id="19009" href="#11443" class="Field Operator">‚ü¶</a> <a id="19011" href="#18974" class="Function">1‚ãä‚Ä≤</a> <a id="19015" href="#11443" class="Field Operator">‚üß-prop</a> <a id="19022" class="Symbol">=</a> <a id="19024" href="#8921" class="InductiveConstructor">trunc</a> <a id="19030" class="Symbol">_</a> <a id="19032" class="Symbol">_</a>
  <a id="19036" href="#11481" class="Field Operator">‚ü¶</a> <a id="19038" href="#18974" class="Function">1‚ãä‚Ä≤</a> <a id="19042" href="#11481" class="Field Operator">‚üß[]</a> <a id="19046" class="Symbol">=</a> <a id="19048" href="../code/probability/Cubical.Foundations.Prelude.html#827" class="Function">refl</a>
  <a id="19055" href="#11498" class="Field Operator">‚ü¶</a> <a id="19057" href="#18974" class="Function">1‚ãä‚Ä≤</a> <a id="19061" href="#11498" class="Field Operator">‚üß</a> <a id="19063" href="#19063" class="Bound">p</a> <a id="19065" href="#11498" class="Field Operator">&amp;</a> <a id="19067" href="#19067" class="Bound">x</a> <a id="19069" href="#11498" class="Field Operator">‚à∑</a> <a id="19071" href="#19071" class="Bound">xs</a> <a id="19074" href="#11498" class="Field Operator">‚ü®</a> <a id="19076" href="#19076" class="Bound">P</a> <a id="19078" href="#11498" class="Field Operator">‚ü©</a> <a id="19080" class="Symbol">=</a>
    <a id="19086" href="../code/probability/ProbabilityModule.Semirings.html#265" class="Field">1#</a> <a id="19089" href="#14109" class="Function Operator">‚ãä</a> <a id="19091" class="Symbol">(</a><a id="19092" href="#19063" class="Bound">p</a> <a id="19094" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="19096" href="#19067" class="Bound">x</a> <a id="19098" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="19100" href="#19071" class="Bound">xs</a><a id="19102" class="Symbol">)</a> <a id="19104" href="../code/probability/ProbabilityModule.Utils.html#572" class="Function Operator">‚â°‚ü®‚ü©</a>
    <a id="19112" href="../code/probability/ProbabilityModule.Semirings.html#265" class="Field">1#</a> <a id="19115" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="19117" href="#19063" class="Bound">p</a> <a id="19119" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="19121" href="#19067" class="Bound">x</a> <a id="19123" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="19125" href="../code/probability/ProbabilityModule.Semirings.html#265" class="Field">1#</a> <a id="19128" href="#14109" class="Function Operator">‚ãä</a> <a id="19130" href="#19071" class="Bound">xs</a> <a id="19133" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚â°‚ü®</a> <a id="19136" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="19141" class="Symbol">(</a><a id="19142" href="#8727" class="InductiveConstructor Operator">_&amp;</a> <a id="19145" href="#19067" class="Bound">x</a> <a id="19147" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="19149" href="../code/probability/ProbabilityModule.Semirings.html#265" class="Field">1#</a> <a id="19152" href="#14109" class="Function Operator">‚ãä</a> <a id="19154" href="#19071" class="Bound">xs</a><a id="19156" class="Symbol">)</a> <a id="19158" class="Symbol">(</a><a id="19159" href="../code/probability/ProbabilityModule.Semirings.html#482" class="Field">1*</a> <a id="19162" href="#19063" class="Bound">p</a><a id="19163" class="Symbol">)</a> <a id="19165" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚ü©</a>
    <a id="19171" href="#19063" class="Bound">p</a> <a id="19173" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="19175" href="#19067" class="Bound">x</a> <a id="19177" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="19179" href="../code/probability/ProbabilityModule.Semirings.html#265" class="Field">1#</a> <a id="19182" href="#14109" class="Function Operator">‚ãä</a> <a id="19184" href="#19071" class="Bound">xs</a> <a id="19187" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚â°‚ü®</a> <a id="19190" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="19195" class="Symbol">(</a><a id="19196" href="#19063" class="Bound">p</a> <a id="19198" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="19200" href="#19067" class="Bound">x</a> <a id="19202" href="#8727" class="InductiveConstructor Operator">‚à∑_</a><a id="19204" class="Symbol">)</a> <a id="19206" href="#19076" class="Bound">P</a> <a id="19208" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚ü©</a>
    <a id="19214" href="#19063" class="Bound">p</a> <a id="19216" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="19218" href="#19067" class="Bound">x</a> <a id="19220" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="19222" href="#19071" class="Bound">xs</a> <a id="19225" href="../code/probability/Cubical.Foundations.Prelude.html#2745" class="Function Operator">‚àé</a>

<a id="&gt;&gt;=-distrib"></a><a id="19228" href="#19228" class="Function">&gt;&gt;=-distrib</a> <a id="19240" class="Symbol">:</a> <a id="19242" class="Symbol">(</a><a id="19243" href="#19243" class="Bound">xs</a> <a id="19246" href="#19246" class="Bound">ys</a> <a id="19249" class="Symbol">:</a> <a id="19251" href="#8679" class="Datatype">ùí´</a> <a id="19253" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a><a id="19254" class="Symbol">)</a> <a id="19256" class="Symbol">(</a><a id="19257" href="#19257" class="Bound">g</a> <a id="19259" class="Symbol">:</a> <a id="19261" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="19263" class="Symbol">‚Üí</a> <a id="19265" href="#8679" class="Datatype">ùí´</a> <a id="19267" href="../code/probability/ProbabilityModule.Utils.html#206" class="Generalizable">B</a><a id="19268" class="Symbol">)</a> <a id="19270" class="Symbol">‚Üí</a> <a id="19272" class="Symbol">(</a><a id="19273" href="#19243" class="Bound">xs</a> <a id="19276" href="#13390" class="Function Operator">‚à™</a> <a id="19278" href="#19246" class="Bound">ys</a><a id="19280" class="Symbol">)</a> <a id="19282" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="19286" href="#19257" class="Bound">g</a> <a id="19288" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">‚â°</a> <a id="19290" class="Symbol">(</a><a id="19291" href="#19243" class="Bound">xs</a> <a id="19294" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="19298" href="#19257" class="Bound">g</a><a id="19299" class="Symbol">)</a> <a id="19301" href="#13390" class="Function Operator">‚à™</a> <a id="19303" class="Symbol">(</a><a id="19304" href="#19246" class="Bound">ys</a> <a id="19307" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="19311" href="#19257" class="Bound">g</a><a id="19312" class="Symbol">)</a>
<a id="19314" href="#19228" class="Function">&gt;&gt;=-distrib</a> <a id="19326" class="Symbol">=</a> <a id="19328" class="Symbol">Œª</a> <a id="19330" href="#19330" class="Bound">xs</a> <a id="19333" href="#19333" class="Bound">ys</a> <a id="19336" href="#19336" class="Bound">g</a> <a id="19338" class="Symbol">‚Üí</a> <a id="19340" href="#12103" class="Function Operator">‚ü¶</a> <a id="19342" href="#19395" class="Function">&gt;&gt;=-distrib‚Ä≤</a> <a id="19355" href="#19333" class="Bound">ys</a> <a id="19358" href="#19336" class="Bound">g</a> <a id="19360" href="#12103" class="Function Operator">‚üß‚áì</a> <a id="19363" href="#19330" class="Bound">xs</a>
  <a id="19368" class="Keyword">module</a> <a id="BindDistrib"></a><a id="19375" href="#19375" class="Module">BindDistrib</a> <a id="19387" class="Keyword">where</a>
  <a id="BindDistrib.&gt;&gt;=-distrib‚Ä≤"></a><a id="19395" href="#19395" class="Function">&gt;&gt;=-distrib‚Ä≤</a> <a id="19408" class="Symbol">:</a> <a id="19410" class="Symbol">(</a><a id="19411" href="#19411" class="Bound">ys</a> <a id="19414" class="Symbol">:</a> <a id="19416" href="#8679" class="Datatype">ùí´</a> <a id="19418" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a><a id="19419" class="Symbol">)</a> <a id="19421" class="Symbol">(</a><a id="19422" href="#19422" class="Bound">g</a> <a id="19424" class="Symbol">:</a> <a id="19426" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="19428" class="Symbol">‚Üí</a> <a id="19430" href="#8679" class="Datatype">ùí´</a> <a id="19432" href="../code/probability/ProbabilityModule.Utils.html#206" class="Generalizable">B</a><a id="19433" class="Symbol">)</a> <a id="19435" class="Symbol">‚Üí</a> <a id="19437" href="#12139" class="Function">‚ü¶</a> <a id="19439" href="#19439" class="Bound">xs</a> <a id="19442" href="#12139" class="Function">‚ààùí´</a> <a id="19445" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="19447" href="#12139" class="Function">‚áí</a> <a id="19449" class="Symbol">((</a><a id="19451" href="#19439" class="Bound">xs</a> <a id="19454" href="#13390" class="Function Operator">‚à™</a> <a id="19456" href="#19411" class="Bound">ys</a><a id="19458" class="Symbol">)</a> <a id="19460" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="19464" href="#19422" class="Bound">g</a><a id="19465" class="Symbol">)</a> <a id="19467" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">‚â°</a> <a id="19469" class="Symbol">(</a><a id="19470" href="#19439" class="Bound">xs</a> <a id="19473" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="19477" href="#19422" class="Bound">g</a><a id="19478" class="Symbol">)</a> <a id="19480" href="#13390" class="Function Operator">‚à™</a> <a id="19482" class="Symbol">(</a><a id="19483" href="#19411" class="Bound">ys</a> <a id="19486" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="19490" href="#19422" class="Bound">g</a><a id="19491" class="Symbol">)</a> <a id="19493" href="#12139" class="Function">‚üß</a>
  <a id="19497" href="#11443" class="Field Operator">‚ü¶</a> <a id="19499" href="#19395" class="Function">&gt;&gt;=-distrib‚Ä≤</a> <a id="19512" href="#19512" class="Bound">ys</a> <a id="19515" href="#19515" class="Bound">g</a> <a id="19517" href="#11443" class="Field Operator">‚üß-prop</a> <a id="19524" class="Symbol">=</a> <a id="19526" href="#8921" class="InductiveConstructor">trunc</a> <a id="19532" class="Symbol">_</a> <a id="19534" class="Symbol">_</a>
  <a id="19538" href="#11481" class="Field Operator">‚ü¶</a> <a id="19540" href="#19395" class="Function">&gt;&gt;=-distrib‚Ä≤</a> <a id="19553" href="#19553" class="Bound">ys</a> <a id="19556" href="#19556" class="Bound">g</a> <a id="19558" href="#11481" class="Field Operator">‚üß[]</a> <a id="19562" class="Symbol">=</a> <a id="19564" href="../code/probability/Cubical.Foundations.Prelude.html#827" class="Function">refl</a>
  <a id="19571" href="#11498" class="Field Operator">‚ü¶</a> <a id="19573" href="#19395" class="Function">&gt;&gt;=-distrib‚Ä≤</a> <a id="19586" href="#19586" class="Bound">ys</a> <a id="19589" href="#19589" class="Bound">g</a> <a id="19591" href="#11498" class="Field Operator">‚üß</a> <a id="19593" href="#19593" class="Bound">p</a> <a id="19595" href="#11498" class="Field Operator">&amp;</a> <a id="19597" href="#19597" class="Bound">x</a> <a id="19599" href="#11498" class="Field Operator">‚à∑</a> <a id="19601" href="#19601" class="Bound">xs</a> <a id="19604" href="#11498" class="Field Operator">‚ü®</a> <a id="19606" href="#19606" class="Bound">P</a> <a id="19608" href="#11498" class="Field Operator">‚ü©</a> <a id="19610" class="Symbol">=</a>
    <a id="19616" class="Symbol">(((</a><a id="19619" href="#19593" class="Bound">p</a> <a id="19621" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="19623" href="#19597" class="Bound">x</a> <a id="19625" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="19627" href="#19601" class="Bound">xs</a><a id="19629" class="Symbol">)</a> <a id="19631" href="#13390" class="Function Operator">‚à™</a> <a id="19633" href="#19586" class="Bound">ys</a><a id="19635" class="Symbol">)</a> <a id="19637" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="19641" href="#19589" class="Bound">g</a><a id="19642" class="Symbol">)</a> <a id="19644" href="../code/probability/ProbabilityModule.Utils.html#572" class="Function Operator">‚â°‚ü®‚ü©</a>
    <a id="19652" class="Symbol">(</a><a id="19653" href="#19593" class="Bound">p</a> <a id="19655" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="19657" href="#19597" class="Bound">x</a> <a id="19659" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="19661" href="#19601" class="Bound">xs</a> <a id="19664" href="#13390" class="Function Operator">‚à™</a> <a id="19666" href="#19586" class="Bound">ys</a><a id="19668" class="Symbol">)</a> <a id="19670" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="19674" href="#19589" class="Bound">g</a> <a id="19676" href="../code/probability/ProbabilityModule.Utils.html#572" class="Function Operator">‚â°‚ü®‚ü©</a>
    <a id="19684" href="#19593" class="Bound">p</a> <a id="19686" href="#14109" class="Function Operator">‚ãä</a> <a id="19688" href="#19589" class="Bound">g</a> <a id="19690" href="#19597" class="Bound">x</a> <a id="19692" href="#13390" class="Function Operator">‚à™</a> <a id="19694" class="Symbol">((</a><a id="19696" href="#19601" class="Bound">xs</a> <a id="19699" href="#13390" class="Function Operator">‚à™</a> <a id="19701" href="#19586" class="Bound">ys</a><a id="19703" class="Symbol">)</a> <a id="19705" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="19709" href="#19589" class="Bound">g</a><a id="19710" class="Symbol">)</a> <a id="19712" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚â°‚ü®</a> <a id="19715" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="19720" class="Symbol">(</a><a id="19721" href="#19593" class="Bound">p</a> <a id="19723" href="#14109" class="Function Operator">‚ãä</a> <a id="19725" href="#19589" class="Bound">g</a> <a id="19727" href="#19597" class="Bound">x</a> <a id="19729" href="#13390" class="Function Operator">‚à™_</a><a id="19731" class="Symbol">)</a> <a id="19733" href="#19606" class="Bound">P</a> <a id="19735" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚ü©</a>
    <a id="19741" href="#19593" class="Bound">p</a> <a id="19743" href="#14109" class="Function Operator">‚ãä</a> <a id="19745" href="#19589" class="Bound">g</a> <a id="19747" href="#19597" class="Bound">x</a> <a id="19749" href="#13390" class="Function Operator">‚à™</a> <a id="19751" class="Symbol">((</a><a id="19753" href="#19601" class="Bound">xs</a> <a id="19756" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="19760" href="#19589" class="Bound">g</a><a id="19761" class="Symbol">)</a> <a id="19763" href="#13390" class="Function Operator">‚à™</a> <a id="19765" class="Symbol">(</a><a id="19766" href="#19586" class="Bound">ys</a> <a id="19769" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="19773" href="#19589" class="Bound">g</a><a id="19774" class="Symbol">))</a> <a id="19777" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚â°‚ü®</a> <a id="19780" href="#13658" class="Function">‚à™-assoc</a> <a id="19788" class="Symbol">(</a><a id="19789" href="#19593" class="Bound">p</a> <a id="19791" href="#14109" class="Function Operator">‚ãä</a> <a id="19793" href="#19589" class="Bound">g</a> <a id="19795" href="#19597" class="Bound">x</a><a id="19796" class="Symbol">)</a> <a id="19798" class="Symbol">(</a><a id="19799" href="#19601" class="Bound">xs</a> <a id="19802" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="19806" href="#19589" class="Bound">g</a><a id="19807" class="Symbol">)</a> <a id="19809" class="Symbol">(</a><a id="19810" href="#19586" class="Bound">ys</a> <a id="19813" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="19817" href="#19589" class="Bound">g</a><a id="19818" class="Symbol">)</a> <a id="19820" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚ü©</a>
    <a id="19826" class="Symbol">(</a><a id="19827" href="#19593" class="Bound">p</a> <a id="19829" href="#14109" class="Function Operator">‚ãä</a> <a id="19831" href="#19589" class="Bound">g</a> <a id="19833" href="#19597" class="Bound">x</a> <a id="19835" href="#13390" class="Function Operator">‚à™</a> <a id="19837" class="Symbol">(</a><a id="19838" href="#19601" class="Bound">xs</a> <a id="19841" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="19845" href="#19589" class="Bound">g</a><a id="19846" class="Symbol">))</a> <a id="19849" href="#13390" class="Function Operator">‚à™</a> <a id="19851" class="Symbol">(</a><a id="19852" href="#19586" class="Bound">ys</a> <a id="19855" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="19859" href="#19589" class="Bound">g</a><a id="19860" class="Symbol">)</a> <a id="19862" href="../code/probability/ProbabilityModule.Utils.html#572" class="Function Operator">‚â°‚ü®‚ü©</a>
    <a id="19870" class="Symbol">((</a><a id="19872" href="#19593" class="Bound">p</a> <a id="19874" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="19876" href="#19597" class="Bound">x</a> <a id="19878" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="19880" href="#19601" class="Bound">xs</a><a id="19882" class="Symbol">)</a> <a id="19884" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="19888" href="#19589" class="Bound">g</a><a id="19889" class="Symbol">)</a> <a id="19891" href="#13390" class="Function Operator">‚à™</a> <a id="19893" class="Symbol">(</a><a id="19894" href="#19586" class="Bound">ys</a> <a id="19897" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="19901" href="#19589" class="Bound">g</a><a id="19902" class="Symbol">)</a> <a id="19904" href="../code/probability/Cubical.Foundations.Prelude.html#2745" class="Function Operator">‚àé</a>

<a id="*-assoc-‚ãä"></a><a id="19907" href="#19907" class="Function">*-assoc-‚ãä</a> <a id="19917" class="Symbol">:</a> <a id="19919" class="Symbol">‚àÄ</a> <a id="19921" href="#19921" class="Bound">p</a> <a id="19923" href="#19923" class="Bound">q</a> <a id="19925" class="Symbol">(</a><a id="19926" href="#19926" class="Bound">xs</a> <a id="19929" class="Symbol">:</a> <a id="19931" href="#8679" class="Datatype">ùí´</a> <a id="19933" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a><a id="19934" class="Symbol">)</a> <a id="19936" class="Symbol">‚Üí</a> <a id="19938" class="Symbol">(</a><a id="19939" href="#19921" class="Bound">p</a> <a id="19941" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="19943" href="#19923" class="Bound">q</a><a id="19944" class="Symbol">)</a> <a id="19946" href="#14109" class="Function Operator">‚ãä</a> <a id="19948" href="#19926" class="Bound">xs</a> <a id="19951" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">‚â°</a> <a id="19953" href="#19921" class="Bound">p</a> <a id="19955" href="#14109" class="Function Operator">‚ãä</a> <a id="19957" class="Symbol">(</a><a id="19958" href="#19923" class="Bound">q</a> <a id="19960" href="#14109" class="Function Operator">‚ãä</a> <a id="19962" href="#19926" class="Bound">xs</a><a id="19964" class="Symbol">)</a>
<a id="19966" href="#19907" class="Function">*-assoc-‚ãä</a> <a id="19976" class="Symbol">=</a> <a id="19978" class="Symbol">Œª</a> <a id="19980" href="#19980" class="Bound">p</a> <a id="19982" href="#19982" class="Bound">q</a> <a id="19984" class="Symbol">‚Üí</a> <a id="19986" href="#12103" class="Function Operator">‚ü¶</a> <a id="19988" href="#20031" class="Function">*-assoc-‚ãä‚Ä≤</a> <a id="19999" href="#19980" class="Bound">p</a> <a id="20001" href="#19982" class="Bound">q</a> <a id="20003" href="#12103" class="Function Operator">‚üß‚áì</a>
  <a id="20008" class="Keyword">module</a> <a id="MAssocJ"></a><a id="20015" href="#20015" class="Module">MAssocJ</a> <a id="20023" class="Keyword">where</a>
  <a id="MAssocJ.*-assoc-‚ãä‚Ä≤"></a><a id="20031" href="#20031" class="Function">*-assoc-‚ãä‚Ä≤</a> <a id="20042" class="Symbol">:</a> <a id="20044" class="Symbol">‚àÄ</a> <a id="20046" href="#20046" class="Bound">p</a> <a id="20048" href="#20048" class="Bound">q</a> <a id="20050" class="Symbol">‚Üí</a> <a id="20052" href="#12139" class="Function">‚ü¶</a> <a id="20054" href="#20054" class="Bound">xs</a> <a id="20057" href="#12139" class="Function">‚ààùí´</a> <a id="20060" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="20062" href="#12139" class="Function">‚áí</a> <a id="20064" class="Symbol">(</a><a id="20065" href="#20046" class="Bound">p</a> <a id="20067" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="20069" href="#20048" class="Bound">q</a><a id="20070" class="Symbol">)</a> <a id="20072" href="#14109" class="Function Operator">‚ãä</a> <a id="20074" href="#20054" class="Bound">xs</a> <a id="20077" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">‚â°</a> <a id="20079" href="#20046" class="Bound">p</a> <a id="20081" href="#14109" class="Function Operator">‚ãä</a> <a id="20083" class="Symbol">(</a><a id="20084" href="#20048" class="Bound">q</a> <a id="20086" href="#14109" class="Function Operator">‚ãä</a> <a id="20088" href="#20054" class="Bound">xs</a><a id="20090" class="Symbol">)</a> <a id="20092" href="#12139" class="Function">‚üß</a>
  <a id="20096" href="#11443" class="Field Operator">‚ü¶</a> <a id="20098" href="#20031" class="Function">*-assoc-‚ãä‚Ä≤</a> <a id="20109" href="#20109" class="Bound">p</a> <a id="20111" href="#20111" class="Bound">q</a> <a id="20113" href="#11443" class="Field Operator">‚üß-prop</a> <a id="20120" class="Symbol">=</a> <a id="20122" href="#8921" class="InductiveConstructor">trunc</a> <a id="20128" class="Symbol">_</a> <a id="20130" class="Symbol">_</a>
  <a id="20134" href="#11481" class="Field Operator">‚ü¶</a> <a id="20136" href="#20031" class="Function">*-assoc-‚ãä‚Ä≤</a> <a id="20147" href="#20147" class="Bound">p</a> <a id="20149" href="#20149" class="Bound">q</a> <a id="20151" href="#11481" class="Field Operator">‚üß[]</a> <a id="20155" class="Symbol">=</a> <a id="20157" href="../code/probability/Cubical.Foundations.Prelude.html#827" class="Function">refl</a>
  <a id="20164" href="#11498" class="Field Operator">‚ü¶</a> <a id="20166" href="#20031" class="Function">*-assoc-‚ãä‚Ä≤</a> <a id="20177" href="#20177" class="Bound">p</a> <a id="20179" href="#20179" class="Bound">q</a> <a id="20181" href="#11498" class="Field Operator">‚üß</a> <a id="20183" href="#20183" class="Bound">r</a> <a id="20185" href="#11498" class="Field Operator">&amp;</a> <a id="20187" href="#20187" class="Bound">x</a> <a id="20189" href="#11498" class="Field Operator">‚à∑</a> <a id="20191" href="#20191" class="Bound">xs</a> <a id="20194" href="#11498" class="Field Operator">‚ü®</a> <a id="20196" href="#20196" class="Bound">P</a> <a id="20198" href="#11498" class="Field Operator">‚ü©</a> <a id="20200" class="Symbol">=</a>
    <a id="20206" href="#20177" class="Bound">p</a> <a id="20208" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="20210" href="#20179" class="Bound">q</a> <a id="20212" href="#14109" class="Function Operator">‚ãä</a> <a id="20214" class="Symbol">(</a><a id="20215" href="#20183" class="Bound">r</a> <a id="20217" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="20219" href="#20187" class="Bound">x</a> <a id="20221" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="20223" href="#20191" class="Bound">xs</a><a id="20225" class="Symbol">)</a> <a id="20227" href="../code/probability/ProbabilityModule.Utils.html#572" class="Function Operator">‚â°‚ü®‚ü©</a>
    <a id="20235" href="#20177" class="Bound">p</a> <a id="20237" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="20239" href="#20179" class="Bound">q</a> <a id="20241" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="20243" href="#20183" class="Bound">r</a> <a id="20245" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="20247" href="#20187" class="Bound">x</a> <a id="20249" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="20251" class="Symbol">(</a><a id="20252" href="#20177" class="Bound">p</a> <a id="20254" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="20256" href="#20179" class="Bound">q</a> <a id="20258" href="#14109" class="Function Operator">‚ãä</a> <a id="20260" href="#20191" class="Bound">xs</a><a id="20262" class="Symbol">)</a> <a id="20264" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚â°‚ü®</a> <a id="20267" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="20272" class="Symbol">(</a><a id="20273" href="#8727" class="InductiveConstructor Operator">_&amp;</a> <a id="20276" href="#20187" class="Bound">x</a> <a id="20278" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="20280" class="Symbol">(</a><a id="20281" href="#20177" class="Bound">p</a> <a id="20283" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="20285" href="#20179" class="Bound">q</a> <a id="20287" href="#14109" class="Function Operator">‚ãä</a> <a id="20289" href="#20191" class="Bound">xs</a><a id="20291" class="Symbol">))</a> <a id="20294" class="Symbol">(</a><a id="20295" href="../code/probability/ProbabilityModule.Semirings.html#326" class="Field">*-assoc</a> <a id="20303" href="#20177" class="Bound">p</a> <a id="20305" href="#20179" class="Bound">q</a> <a id="20307" href="#20183" class="Bound">r</a><a id="20308" class="Symbol">)</a> <a id="20310" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚ü©</a>
    <a id="20316" href="#20177" class="Bound">p</a> <a id="20318" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="20320" class="Symbol">(</a><a id="20321" href="#20179" class="Bound">q</a> <a id="20323" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="20325" href="#20183" class="Bound">r</a><a id="20326" class="Symbol">)</a> <a id="20328" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="20330" href="#20187" class="Bound">x</a> <a id="20332" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="20334" class="Symbol">(</a><a id="20335" href="#20177" class="Bound">p</a> <a id="20337" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="20339" href="#20179" class="Bound">q</a> <a id="20341" href="#14109" class="Function Operator">‚ãä</a> <a id="20343" href="#20191" class="Bound">xs</a><a id="20345" class="Symbol">)</a> <a id="20347" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚â°‚ü®</a> <a id="20350" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="20355" class="Symbol">(</a><a id="20356" href="#20177" class="Bound">p</a> <a id="20358" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="20360" class="Symbol">(</a><a id="20361" href="#20179" class="Bound">q</a> <a id="20363" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="20365" href="#20183" class="Bound">r</a><a id="20366" class="Symbol">)</a> <a id="20368" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="20370" href="#20187" class="Bound">x</a> <a id="20372" href="#8727" class="InductiveConstructor Operator">‚à∑_</a><a id="20374" class="Symbol">)</a> <a id="20376" href="#20196" class="Bound">P</a> <a id="20378" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚ü©</a>
    <a id="20384" href="#20177" class="Bound">p</a> <a id="20386" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="20388" class="Symbol">(</a><a id="20389" href="#20179" class="Bound">q</a> <a id="20391" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="20393" href="#20183" class="Bound">r</a><a id="20394" class="Symbol">)</a> <a id="20396" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="20398" href="#20187" class="Bound">x</a> <a id="20400" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="20402" class="Symbol">(</a><a id="20403" href="#20177" class="Bound">p</a> <a id="20405" href="#14109" class="Function Operator">‚ãä</a> <a id="20407" class="Symbol">(</a><a id="20408" href="#20179" class="Bound">q</a> <a id="20410" href="#14109" class="Function Operator">‚ãä</a> <a id="20412" href="#20191" class="Bound">xs</a><a id="20414" class="Symbol">))</a> <a id="20417" href="../code/probability/ProbabilityModule.Utils.html#572" class="Function Operator">‚â°‚ü®‚ü©</a>
    <a id="20425" href="#20177" class="Bound">p</a> <a id="20427" href="#14109" class="Function Operator">‚ãä</a> <a id="20429" class="Symbol">(</a><a id="20430" href="#20179" class="Bound">q</a> <a id="20432" href="#14109" class="Function Operator">‚ãä</a> <a id="20434" class="Symbol">(</a><a id="20435" href="#20183" class="Bound">r</a> <a id="20437" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="20439" href="#20187" class="Bound">x</a> <a id="20441" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="20443" href="#20191" class="Bound">xs</a><a id="20445" class="Symbol">))</a> <a id="20448" href="../code/probability/Cubical.Foundations.Prelude.html#2745" class="Function Operator">‚àé</a>

<a id="‚ãä-assoc-&gt;&gt;="></a><a id="20451" href="#20451" class="Function">‚ãä-assoc-&gt;&gt;=</a> <a id="20463" class="Symbol">:</a> <a id="20465" class="Symbol">‚àÄ</a> <a id="20467" href="#20467" class="Bound">p</a> <a id="20469" class="Symbol">(</a><a id="20470" href="#20470" class="Bound">xs</a> <a id="20473" class="Symbol">:</a> <a id="20475" href="#8679" class="Datatype">ùí´</a> <a id="20477" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a><a id="20478" class="Symbol">)</a> <a id="20480" class="Symbol">(</a><a id="20481" href="#20481" class="Bound">f</a> <a id="20483" class="Symbol">:</a> <a id="20485" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="20487" class="Symbol">‚Üí</a> <a id="20489" href="#8679" class="Datatype">ùí´</a> <a id="20491" href="../code/probability/ProbabilityModule.Utils.html#206" class="Generalizable">B</a><a id="20492" class="Symbol">)</a> <a id="20494" class="Symbol">‚Üí</a> <a id="20496" class="Symbol">(</a><a id="20497" href="#20467" class="Bound">p</a> <a id="20499" href="#14109" class="Function Operator">‚ãä</a> <a id="20501" href="#20470" class="Bound">xs</a><a id="20503" class="Symbol">)</a> <a id="20505" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="20509" href="#20481" class="Bound">f</a> <a id="20511" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">‚â°</a> <a id="20513" href="#20467" class="Bound">p</a> <a id="20515" href="#14109" class="Function Operator">‚ãä</a> <a id="20517" class="Symbol">(</a><a id="20518" href="#20470" class="Bound">xs</a> <a id="20521" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="20525" href="#20481" class="Bound">f</a><a id="20526" class="Symbol">)</a>
<a id="20528" href="#20451" class="Function">‚ãä-assoc-&gt;&gt;=</a> <a id="20540" class="Symbol">=</a> <a id="20542" class="Symbol">Œª</a> <a id="20544" href="#20544" class="Bound">p</a> <a id="20546" href="#20546" class="Bound">xs</a> <a id="20549" href="#20549" class="Bound">f</a> <a id="20551" class="Symbol">‚Üí</a> <a id="20553" href="#12103" class="Function Operator">‚ü¶</a> <a id="20555" href="#20605" class="Function">‚ãä-assoc-&gt;&gt;=‚Ä≤</a> <a id="20568" href="#20544" class="Bound">p</a> <a id="20570" href="#20549" class="Bound">f</a> <a id="20572" href="#12103" class="Function Operator">‚üß‚áì</a> <a id="20575" href="#20546" class="Bound">xs</a>
  <a id="20580" class="Keyword">module</a> <a id="JDistribB"></a><a id="20587" href="#20587" class="Module">JDistribB</a> <a id="20597" class="Keyword">where</a>
  <a id="JDistribB.‚ãä-assoc-&gt;&gt;=‚Ä≤"></a><a id="20605" href="#20605" class="Function">‚ãä-assoc-&gt;&gt;=‚Ä≤</a> <a id="20618" class="Symbol">:</a> <a id="20620" class="Symbol">‚àÄ</a> <a id="20622" href="#20622" class="Bound">p</a> <a id="20624" class="Symbol">(</a><a id="20625" href="#20625" class="Bound">f</a> <a id="20627" class="Symbol">:</a> <a id="20629" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="20631" class="Symbol">‚Üí</a> <a id="20633" href="#8679" class="Datatype">ùí´</a> <a id="20635" href="../code/probability/ProbabilityModule.Utils.html#206" class="Generalizable">B</a><a id="20636" class="Symbol">)</a> <a id="20638" class="Symbol">‚Üí</a> <a id="20640" href="#12139" class="Function">‚ü¶</a> <a id="20642" href="#20642" class="Bound">xs</a> <a id="20645" href="#12139" class="Function">‚ààùí´</a> <a id="20648" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="20650" href="#12139" class="Function">‚áí</a> <a id="20652" class="Symbol">(</a><a id="20653" href="#20622" class="Bound">p</a> <a id="20655" href="#14109" class="Function Operator">‚ãä</a> <a id="20657" href="#20642" class="Bound">xs</a><a id="20659" class="Symbol">)</a> <a id="20661" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="20665" href="#20625" class="Bound">f</a> <a id="20667" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">‚â°</a> <a id="20669" href="#20622" class="Bound">p</a> <a id="20671" href="#14109" class="Function Operator">‚ãä</a> <a id="20673" class="Symbol">(</a><a id="20674" href="#20642" class="Bound">xs</a> <a id="20677" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="20681" href="#20625" class="Bound">f</a><a id="20682" class="Symbol">)</a> <a id="20684" href="#12139" class="Function">‚üß</a>
  <a id="20688" href="#11443" class="Field Operator">‚ü¶</a> <a id="20690" href="#20605" class="Function">‚ãä-assoc-&gt;&gt;=‚Ä≤</a> <a id="20703" href="#20703" class="Bound">p</a> <a id="20705" href="#20705" class="Bound">f</a> <a id="20707" href="#11443" class="Field Operator">‚üß-prop</a> <a id="20714" class="Symbol">=</a> <a id="20716" href="#8921" class="InductiveConstructor">trunc</a> <a id="20722" class="Symbol">_</a> <a id="20724" class="Symbol">_</a>
  <a id="20728" href="#11481" class="Field Operator">‚ü¶</a> <a id="20730" href="#20605" class="Function">‚ãä-assoc-&gt;&gt;=‚Ä≤</a> <a id="20743" href="#20743" class="Bound">p</a> <a id="20745" href="#20745" class="Bound">f</a> <a id="20747" href="#11481" class="Field Operator">‚üß[]</a> <a id="20751" class="Symbol">=</a> <a id="20753" href="../code/probability/Cubical.Foundations.Prelude.html#827" class="Function">refl</a>
  <a id="20760" href="#11498" class="Field Operator">‚ü¶</a> <a id="20762" href="#20605" class="Function">‚ãä-assoc-&gt;&gt;=‚Ä≤</a> <a id="20775" href="#20775" class="Bound">p</a> <a id="20777" href="#20777" class="Bound">f</a> <a id="20779" href="#11498" class="Field Operator">‚üß</a> <a id="20781" href="#20781" class="Bound">q</a> <a id="20783" href="#11498" class="Field Operator">&amp;</a> <a id="20785" href="#20785" class="Bound">x</a> <a id="20787" href="#11498" class="Field Operator">‚à∑</a> <a id="20789" href="#20789" class="Bound">xs</a> <a id="20792" href="#11498" class="Field Operator">‚ü®</a> <a id="20794" href="#20794" class="Bound">P</a> <a id="20796" href="#11498" class="Field Operator">‚ü©</a> <a id="20798" class="Symbol">=</a>
    <a id="20804" class="Symbol">(</a><a id="20805" href="#20775" class="Bound">p</a> <a id="20807" href="#14109" class="Function Operator">‚ãä</a> <a id="20809" class="Symbol">(</a><a id="20810" href="#20781" class="Bound">q</a> <a id="20812" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="20814" href="#20785" class="Bound">x</a> <a id="20816" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="20818" href="#20789" class="Bound">xs</a><a id="20820" class="Symbol">))</a> <a id="20823" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="20827" href="#20777" class="Bound">f</a> <a id="20829" href="../code/probability/ProbabilityModule.Utils.html#572" class="Function Operator">‚â°‚ü®‚ü©</a>
    <a id="20837" class="Symbol">(</a><a id="20838" href="#20775" class="Bound">p</a> <a id="20840" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="20842" href="#20781" class="Bound">q</a> <a id="20844" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="20846" href="#20785" class="Bound">x</a> <a id="20848" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="20850" href="#20775" class="Bound">p</a> <a id="20852" href="#14109" class="Function Operator">‚ãä</a> <a id="20854" href="#20789" class="Bound">xs</a><a id="20856" class="Symbol">)</a> <a id="20858" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="20862" href="#20777" class="Bound">f</a> <a id="20864" href="../code/probability/ProbabilityModule.Utils.html#572" class="Function Operator">‚â°‚ü®‚ü©</a>
    <a id="20872" class="Symbol">((</a><a id="20874" href="#20775" class="Bound">p</a> <a id="20876" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="20878" href="#20781" class="Bound">q</a><a id="20879" class="Symbol">)</a> <a id="20881" href="#14109" class="Function Operator">‚ãä</a> <a id="20883" href="#20777" class="Bound">f</a> <a id="20885" href="#20785" class="Bound">x</a><a id="20886" class="Symbol">)</a> <a id="20888" href="#13390" class="Function Operator">‚à™</a> <a id="20890" class="Symbol">((</a><a id="20892" href="#20775" class="Bound">p</a> <a id="20894" href="#14109" class="Function Operator">‚ãä</a> <a id="20896" href="#20789" class="Bound">xs</a><a id="20898" class="Symbol">)</a> <a id="20900" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="20904" href="#20777" class="Bound">f</a><a id="20905" class="Symbol">)</a> <a id="20907" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚â°‚ü®</a> <a id="20910" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="20915" class="Symbol">(((</a><a id="20918" href="#20775" class="Bound">p</a> <a id="20920" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="20922" href="#20781" class="Bound">q</a><a id="20923" class="Symbol">)</a> <a id="20925" href="#14109" class="Function Operator">‚ãä</a> <a id="20927" href="#20777" class="Bound">f</a> <a id="20929" href="#20785" class="Bound">x</a><a id="20930" class="Symbol">)</a> <a id="20932" href="#13390" class="Function Operator">‚à™_</a><a id="20934" class="Symbol">)</a> <a id="20936" href="#20794" class="Bound">P</a> <a id="20938" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚ü©</a>
    <a id="20944" class="Symbol">((</a><a id="20946" href="#20775" class="Bound">p</a> <a id="20948" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="20950" href="#20781" class="Bound">q</a><a id="20951" class="Symbol">)</a> <a id="20953" href="#14109" class="Function Operator">‚ãä</a> <a id="20955" href="#20777" class="Bound">f</a> <a id="20957" href="#20785" class="Bound">x</a><a id="20958" class="Symbol">)</a> <a id="20960" href="#13390" class="Function Operator">‚à™</a> <a id="20962" class="Symbol">(</a><a id="20963" href="#20775" class="Bound">p</a> <a id="20965" href="#14109" class="Function Operator">‚ãä</a> <a id="20967" class="Symbol">(</a><a id="20968" href="#20789" class="Bound">xs</a> <a id="20971" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="20975" href="#20777" class="Bound">f</a><a id="20976" class="Symbol">))</a> <a id="20979" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚â°‚ü®</a> <a id="20982" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="20987" class="Symbol">(</a><a id="20988" href="#13390" class="Function Operator">_‚à™</a> <a id="20991" class="Symbol">(</a><a id="20992" href="#20775" class="Bound">p</a> <a id="20994" href="#14109" class="Function Operator">‚ãä</a> <a id="20996" class="Symbol">(</a><a id="20997" href="#20789" class="Bound">xs</a> <a id="21000" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="21004" href="#20777" class="Bound">f</a><a id="21005" class="Symbol">)))</a> <a id="21009" class="Symbol">(</a><a id="21010" href="#19907" class="Function">*-assoc-‚ãä</a> <a id="21020" href="#20775" class="Bound">p</a> <a id="21022" href="#20781" class="Bound">q</a> <a id="21024" class="Symbol">(</a><a id="21025" href="#20777" class="Bound">f</a> <a id="21027" href="#20785" class="Bound">x</a><a id="21028" class="Symbol">))</a> <a id="21031" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚ü©</a>
    <a id="21037" class="Symbol">(</a><a id="21038" href="#20775" class="Bound">p</a> <a id="21040" href="#14109" class="Function Operator">‚ãä</a> <a id="21042" class="Symbol">(</a><a id="21043" href="#20781" class="Bound">q</a> <a id="21045" href="#14109" class="Function Operator">‚ãä</a> <a id="21047" href="#20777" class="Bound">f</a> <a id="21049" href="#20785" class="Bound">x</a><a id="21050" class="Symbol">))</a> <a id="21053" href="#13390" class="Function Operator">‚à™</a> <a id="21055" class="Symbol">(</a><a id="21056" href="#20775" class="Bound">p</a> <a id="21058" href="#14109" class="Function Operator">‚ãä</a> <a id="21060" class="Symbol">(</a><a id="21061" href="#20789" class="Bound">xs</a> <a id="21064" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="21068" href="#20777" class="Bound">f</a><a id="21069" class="Symbol">))</a> <a id="21072" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚â°‚ü®</a> <a id="21075" href="#16654" class="Function">‚ãä-distribÀ°</a> <a id="21086" href="#20775" class="Bound">p</a> <a id="21088" class="Symbol">(</a><a id="21089" href="#20781" class="Bound">q</a> <a id="21091" href="#14109" class="Function Operator">‚ãä</a> <a id="21093" href="#20777" class="Bound">f</a> <a id="21095" href="#20785" class="Bound">x</a><a id="21096" class="Symbol">)</a> <a id="21098" class="Symbol">(</a><a id="21099" href="#20789" class="Bound">xs</a> <a id="21102" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="21106" href="#20777" class="Bound">f</a><a id="21107" class="Symbol">)</a> <a id="21109" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚ü©</a>
    <a id="21115" href="#20775" class="Bound">p</a> <a id="21117" href="#14109" class="Function Operator">‚ãä</a> <a id="21119" class="Symbol">((</a><a id="21121" href="#20781" class="Bound">q</a> <a id="21123" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="21125" href="#20785" class="Bound">x</a> <a id="21127" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="21129" href="#20789" class="Bound">xs</a><a id="21131" class="Symbol">)</a> <a id="21133" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="21137" href="#20777" class="Bound">f</a><a id="21138" class="Symbol">)</a> <a id="21140" href="../code/probability/Cubical.Foundations.Prelude.html#2745" class="Function Operator">‚àé</a>

<a id="&gt;&gt;=-idÀ°"></a><a id="21143" href="#21143" class="Function">&gt;&gt;=-idÀ°</a> <a id="21151" class="Symbol">:</a> <a id="21153" class="Symbol">(</a><a id="21154" href="#21154" class="Bound">x</a> <a id="21156" class="Symbol">:</a> <a id="21158" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a><a id="21159" class="Symbol">)</a> <a id="21161" class="Symbol">‚Üí</a> <a id="21163" class="Symbol">(</a><a id="21164" href="#21164" class="Bound">f</a> <a id="21166" class="Symbol">:</a> <a id="21168" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="21170" class="Symbol">‚Üí</a> <a id="21172" href="#8679" class="Datatype">ùí´</a> <a id="21174" href="../code/probability/ProbabilityModule.Utils.html#206" class="Generalizable">B</a><a id="21175" class="Symbol">)</a>
      <a id="21183" class="Symbol">‚Üí</a> <a id="21185" class="Symbol">(</a><a id="21186" href="#15418" class="Function">pure</a> <a id="21191" href="#21154" class="Bound">x</a> <a id="21193" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="21197" href="#21164" class="Bound">f</a><a id="21198" class="Symbol">)</a> <a id="21200" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">‚â°</a> <a id="21202" href="#21164" class="Bound">f</a> <a id="21204" href="#21154" class="Bound">x</a>
<a id="21206" href="#21143" class="Function">&gt;&gt;=-idÀ°</a> <a id="21214" href="#21214" class="Bound">x</a> <a id="21216" href="#21216" class="Bound">f</a> <a id="21218" class="Symbol">=</a>
  <a id="21222" href="#15418" class="Function">pure</a> <a id="21227" href="#21214" class="Bound">x</a> <a id="21229" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="21233" href="#21216" class="Bound">f</a> <a id="21235" href="../code/probability/ProbabilityModule.Utils.html#572" class="Function Operator">‚â°‚ü®‚ü©</a>
  <a id="21241" class="Symbol">(</a><a id="21242" href="../code/probability/ProbabilityModule.Semirings.html#265" class="Field">1#</a> <a id="21245" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="21247" href="#21214" class="Bound">x</a> <a id="21249" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="21251" href="#8715" class="InductiveConstructor">[]</a><a id="21253" class="Symbol">)</a> <a id="21255" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="21259" href="#21216" class="Bound">f</a> <a id="21261" href="../code/probability/ProbabilityModule.Utils.html#572" class="Function Operator">‚â°‚ü®‚ü©</a>
  <a id="21267" href="../code/probability/ProbabilityModule.Semirings.html#265" class="Field">1#</a> <a id="21270" href="#14109" class="Function Operator">‚ãä</a> <a id="21272" href="#21216" class="Bound">f</a> <a id="21274" href="#21214" class="Bound">x</a> <a id="21276" href="#13390" class="Function Operator">‚à™</a> <a id="21278" href="#8715" class="InductiveConstructor">[]</a> <a id="21281" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="21285" href="#21216" class="Bound">f</a> <a id="21287" href="../code/probability/ProbabilityModule.Utils.html#572" class="Function Operator">‚â°‚ü®‚ü©</a>
  <a id="21293" href="../code/probability/ProbabilityModule.Semirings.html#265" class="Field">1#</a> <a id="21296" href="#14109" class="Function Operator">‚ãä</a> <a id="21298" href="#21216" class="Bound">f</a> <a id="21300" href="#21214" class="Bound">x</a> <a id="21302" href="#13390" class="Function Operator">‚à™</a> <a id="21304" href="#8715" class="InductiveConstructor">[]</a> <a id="21307" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚â°‚ü®</a> <a id="21310" href="#17140" class="Function">‚à™-id ≥</a> <a id="21316" class="Symbol">(</a><a id="21317" href="../code/probability/ProbabilityModule.Semirings.html#265" class="Field">1#</a> <a id="21320" href="#14109" class="Function Operator">‚ãä</a> <a id="21322" href="#21216" class="Bound">f</a> <a id="21324" href="#21214" class="Bound">x</a><a id="21325" class="Symbol">)</a> <a id="21327" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚ü©</a>
  <a id="21331" href="../code/probability/ProbabilityModule.Semirings.html#265" class="Field">1#</a> <a id="21334" href="#14109" class="Function Operator">‚ãä</a> <a id="21336" href="#21216" class="Bound">f</a> <a id="21338" href="#21214" class="Bound">x</a> <a id="21340" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚â°‚ü®</a> <a id="21343" href="#18904" class="Function">1‚ãä</a> <a id="21346" class="Symbol">(</a><a id="21347" href="#21216" class="Bound">f</a> <a id="21349" href="#21214" class="Bound">x</a><a id="21350" class="Symbol">)</a> <a id="21352" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚ü©</a>
  <a id="21356" href="#21216" class="Bound">f</a> <a id="21358" href="#21214" class="Bound">x</a> <a id="21360" href="../code/probability/Cubical.Foundations.Prelude.html#2745" class="Function Operator">‚àé</a>

<a id="&gt;&gt;=-id ≥"></a><a id="21363" href="#21363" class="Function">&gt;&gt;=-id ≥</a> <a id="21371" class="Symbol">:</a> <a id="21373" class="Symbol">(</a><a id="21374" href="#21374" class="Bound">xs</a> <a id="21377" class="Symbol">:</a> <a id="21379" href="#8679" class="Datatype">ùí´</a> <a id="21381" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a><a id="21382" class="Symbol">)</a> <a id="21384" class="Symbol">‚Üí</a> <a id="21386" href="#21374" class="Bound">xs</a> <a id="21389" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="21393" href="#15418" class="Function">pure</a> <a id="21398" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">‚â°</a> <a id="21400" href="#21374" class="Bound">xs</a>
<a id="21403" href="#21363" class="Function">&gt;&gt;=-id ≥</a> <a id="21411" class="Symbol">=</a> <a id="21413" href="#12103" class="Function Operator">‚ü¶</a> <a id="21415" href="#21449" class="Function">&gt;&gt;=-id ≥‚Ä≤</a> <a id="21424" href="#12103" class="Function Operator">‚üß‚áì</a>
  <a id="21429" class="Keyword">module</a> <a id="Law1"></a><a id="21436" href="#21436" class="Module">Law1</a> <a id="21441" class="Keyword">where</a>
  <a id="Law1.&gt;&gt;=-id ≥‚Ä≤"></a><a id="21449" href="#21449" class="Function">&gt;&gt;=-id ≥‚Ä≤</a> <a id="21458" class="Symbol">:</a> <a id="21460" href="#12139" class="Function">‚ü¶</a> <a id="21462" href="#21462" class="Bound">xs</a> <a id="21465" href="#12139" class="Function">‚ààùí´</a> <a id="21468" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="21470" href="#12139" class="Function">‚áí</a> <a id="21472" href="#21462" class="Bound">xs</a> <a id="21475" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="21479" href="#15418" class="Function">pure</a> <a id="21484" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">‚â°</a> <a id="21486" href="#21462" class="Bound">xs</a> <a id="21489" href="#12139" class="Function">‚üß</a>
  <a id="21493" href="#11443" class="Field Operator">‚ü¶</a> <a id="21495" href="#21449" class="Function">&gt;&gt;=-id ≥‚Ä≤</a> <a id="21504" href="#11443" class="Field Operator">‚üß-prop</a> <a id="21511" class="Symbol">=</a> <a id="21513" href="#8921" class="InductiveConstructor">trunc</a> <a id="21519" class="Symbol">_</a> <a id="21521" class="Symbol">_</a>
  <a id="21525" href="#11481" class="Field Operator">‚ü¶</a> <a id="21527" href="#21449" class="Function">&gt;&gt;=-id ≥‚Ä≤</a> <a id="21536" href="#11481" class="Field Operator">‚üß[]</a> <a id="21540" class="Symbol">=</a> <a id="21542" href="../code/probability/Cubical.Foundations.Prelude.html#827" class="Function">refl</a>
  <a id="21549" href="#11498" class="Field Operator">‚ü¶</a> <a id="21551" href="#21449" class="Function">&gt;&gt;=-id ≥‚Ä≤</a> <a id="21560" href="#11498" class="Field Operator">‚üß</a> <a id="21562" href="#21562" class="Bound">p</a> <a id="21564" href="#11498" class="Field Operator">&amp;</a> <a id="21566" href="#21566" class="Bound">x</a> <a id="21568" href="#11498" class="Field Operator">‚à∑</a> <a id="21570" href="#21570" class="Bound">xs</a> <a id="21573" href="#11498" class="Field Operator">‚ü®</a> <a id="21575" href="#21575" class="Bound">P</a> <a id="21577" href="#11498" class="Field Operator">‚ü©</a> <a id="21579" class="Symbol">=</a>
    <a id="21585" class="Symbol">((</a><a id="21587" href="#21562" class="Bound">p</a> <a id="21589" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="21591" href="#21566" class="Bound">x</a> <a id="21593" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="21595" href="#21570" class="Bound">xs</a><a id="21597" class="Symbol">)</a> <a id="21599" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="21603" href="#15418" class="Function">pure</a><a id="21607" class="Symbol">)</a> <a id="21609" href="../code/probability/ProbabilityModule.Utils.html#572" class="Function Operator">‚â°‚ü®‚ü©</a>
    <a id="21617" href="#21562" class="Bound">p</a> <a id="21619" href="#14109" class="Function Operator">‚ãä</a> <a id="21621" class="Symbol">(</a><a id="21622" href="#15418" class="Function">pure</a> <a id="21627" href="#21566" class="Bound">x</a><a id="21628" class="Symbol">)</a> <a id="21630" href="#13390" class="Function Operator">‚à™</a> <a id="21632" class="Symbol">(</a><a id="21633" href="#21570" class="Bound">xs</a> <a id="21636" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="21640" href="#15418" class="Function">pure</a><a id="21644" class="Symbol">)</a> <a id="21646" href="../code/probability/ProbabilityModule.Utils.html#572" class="Function Operator">‚â°‚ü®‚ü©</a>
    <a id="21654" href="#21562" class="Bound">p</a> <a id="21656" href="#14109" class="Function Operator">‚ãä</a> <a id="21658" class="Symbol">(</a><a id="21659" href="../code/probability/ProbabilityModule.Semirings.html#265" class="Field">1#</a> <a id="21662" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="21664" href="#21566" class="Bound">x</a> <a id="21666" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="21668" href="#8715" class="InductiveConstructor">[]</a><a id="21670" class="Symbol">)</a> <a id="21672" href="#13390" class="Function Operator">‚à™</a> <a id="21674" class="Symbol">(</a><a id="21675" href="#21570" class="Bound">xs</a> <a id="21678" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="21682" href="#15418" class="Function">pure</a><a id="21686" class="Symbol">)</a> <a id="21688" href="../code/probability/ProbabilityModule.Utils.html#572" class="Function Operator">‚â°‚ü®‚ü©</a>
    <a id="21696" href="#21562" class="Bound">p</a> <a id="21698" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="21700" href="../code/probability/ProbabilityModule.Semirings.html#265" class="Field">1#</a> <a id="21703" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="21705" href="#21566" class="Bound">x</a> <a id="21707" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="21709" href="#8715" class="InductiveConstructor">[]</a> <a id="21712" href="#13390" class="Function Operator">‚à™</a> <a id="21714" class="Symbol">(</a><a id="21715" href="#21570" class="Bound">xs</a> <a id="21718" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="21722" href="#15418" class="Function">pure</a><a id="21726" class="Symbol">)</a> <a id="21728" href="../code/probability/ProbabilityModule.Utils.html#572" class="Function Operator">‚â°‚ü®‚ü©</a>
    <a id="21736" href="#21562" class="Bound">p</a> <a id="21738" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="21740" href="../code/probability/ProbabilityModule.Semirings.html#265" class="Field">1#</a> <a id="21743" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="21745" href="#21566" class="Bound">x</a> <a id="21747" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="21749" class="Symbol">(</a><a id="21750" href="#21570" class="Bound">xs</a> <a id="21753" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="21757" href="#15418" class="Function">pure</a><a id="21761" class="Symbol">)</a> <a id="21763" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚â°‚ü®</a> <a id="21766" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="21771" class="Symbol">(</a><a id="21772" href="#8727" class="InductiveConstructor Operator">_&amp;</a> <a id="21775" href="#21566" class="Bound">x</a> <a id="21777" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="21779" class="Symbol">(</a><a id="21780" href="#21570" class="Bound">xs</a> <a id="21783" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="21787" href="#15418" class="Function">pure</a><a id="21791" class="Symbol">))</a> <a id="21794" class="Symbol">(</a><a id="21795" href="../code/probability/ProbabilityModule.Semirings.html#456" class="Field">*1</a> <a id="21798" href="#21562" class="Bound">p</a><a id="21799" class="Symbol">)</a> <a id="21801" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚ü©</a>
    <a id="21807" href="#21562" class="Bound">p</a> <a id="21809" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="21811" href="#21566" class="Bound">x</a> <a id="21813" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="21815" href="#21570" class="Bound">xs</a> <a id="21818" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="21822" href="#15418" class="Function">pure</a> <a id="21827" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚â°‚ü®</a> <a id="21830" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="21835" class="Symbol">(</a><a id="21836" href="#21562" class="Bound">p</a> <a id="21838" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="21840" href="#21566" class="Bound">x</a> <a id="21842" href="#8727" class="InductiveConstructor Operator">‚à∑_</a><a id="21844" class="Symbol">)</a> <a id="21846" href="#21575" class="Bound">P</a> <a id="21848" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚ü©</a>
    <a id="21854" href="#21562" class="Bound">p</a> <a id="21856" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="21858" href="#21566" class="Bound">x</a> <a id="21860" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="21862" href="#21570" class="Bound">xs</a> <a id="21865" href="../code/probability/Cubical.Foundations.Prelude.html#2745" class="Function Operator">‚àé</a>

<a id="&gt;&gt;=-assoc"></a><a id="21868" href="#21868" class="Function">&gt;&gt;=-assoc</a> <a id="21878" class="Symbol">:</a> <a id="21880" class="Symbol">(</a><a id="21881" href="#21881" class="Bound">xs</a> <a id="21884" class="Symbol">:</a> <a id="21886" href="#8679" class="Datatype">ùí´</a> <a id="21888" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a><a id="21889" class="Symbol">)</a> <a id="21891" class="Symbol">‚Üí</a> <a id="21893" class="Symbol">(</a><a id="21894" href="#21894" class="Bound">f</a> <a id="21896" class="Symbol">:</a> <a id="21898" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="21900" class="Symbol">‚Üí</a> <a id="21902" href="#8679" class="Datatype">ùí´</a> <a id="21904" href="../code/probability/ProbabilityModule.Utils.html#206" class="Generalizable">B</a><a id="21905" class="Symbol">)</a> <a id="21907" class="Symbol">‚Üí</a> <a id="21909" class="Symbol">(</a><a id="21910" href="#21910" class="Bound">g</a> <a id="21912" class="Symbol">:</a> <a id="21914" href="../code/probability/ProbabilityModule.Utils.html#206" class="Generalizable">B</a> <a id="21916" class="Symbol">‚Üí</a> <a id="21918" href="#8679" class="Datatype">ùí´</a> <a id="21920" href="../code/probability/ProbabilityModule.Utils.html#218" class="Generalizable">C</a><a id="21921" class="Symbol">)</a>
      <a id="21929" class="Symbol">‚Üí</a> <a id="21931" class="Symbol">((</a><a id="21933" href="#21881" class="Bound">xs</a> <a id="21936" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="21940" href="#21894" class="Bound">f</a><a id="21941" class="Symbol">)</a> <a id="21943" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="21947" href="#21910" class="Bound">g</a><a id="21948" class="Symbol">)</a> <a id="21950" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">‚â°</a> <a id="21952" href="#21881" class="Bound">xs</a> <a id="21955" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="21959" class="Symbol">(Œª</a> <a id="21962" href="#21962" class="Bound">x</a> <a id="21964" class="Symbol">‚Üí</a> <a id="21966" href="#21894" class="Bound">f</a> <a id="21968" href="#21962" class="Bound">x</a> <a id="21970" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="21974" href="#21910" class="Bound">g</a><a id="21975" class="Symbol">)</a>
<a id="21977" href="#21868" class="Function">&gt;&gt;=-assoc</a> <a id="21987" class="Symbol">=</a> <a id="21989" class="Symbol">Œª</a> <a id="21991" href="#21991" class="Bound">xs</a> <a id="21994" href="#21994" class="Bound">f</a> <a id="21996" href="#21996" class="Bound">g</a> <a id="21998" class="Symbol">‚Üí</a> <a id="22000" href="#12103" class="Function Operator">‚ü¶</a> <a id="22002" href="#22045" class="Function">&gt;&gt;=-assoc‚Ä≤</a> <a id="22013" href="#21994" class="Bound">f</a> <a id="22015" href="#21996" class="Bound">g</a> <a id="22017" href="#12103" class="Function Operator">‚üß‚áì</a> <a id="22020" href="#21991" class="Bound">xs</a>
  <a id="22025" class="Keyword">module</a> <a id="Law3"></a><a id="22032" href="#22032" class="Module">Law3</a> <a id="22037" class="Keyword">where</a>
  <a id="Law3.&gt;&gt;=-assoc‚Ä≤"></a><a id="22045" href="#22045" class="Function">&gt;&gt;=-assoc‚Ä≤</a> <a id="22056" class="Symbol">:</a> <a id="22058" class="Symbol">(</a><a id="22059" href="#22059" class="Bound">f</a> <a id="22061" class="Symbol">:</a> <a id="22063" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="22065" class="Symbol">‚Üí</a> <a id="22067" href="#8679" class="Datatype">ùí´</a> <a id="22069" href="../code/probability/ProbabilityModule.Utils.html#206" class="Generalizable">B</a><a id="22070" class="Symbol">)</a> <a id="22072" class="Symbol">‚Üí</a> <a id="22074" class="Symbol">(</a><a id="22075" href="#22075" class="Bound">g</a> <a id="22077" class="Symbol">:</a> <a id="22079" href="../code/probability/ProbabilityModule.Utils.html#206" class="Generalizable">B</a> <a id="22081" class="Symbol">‚Üí</a> <a id="22083" href="#8679" class="Datatype">ùí´</a> <a id="22085" href="../code/probability/ProbabilityModule.Utils.html#218" class="Generalizable">C</a><a id="22086" class="Symbol">)</a> <a id="22088" class="Symbol">‚Üí</a> <a id="22090" href="#12139" class="Function">‚ü¶</a> <a id="22092" href="#22092" class="Bound">xs</a> <a id="22095" href="#12139" class="Function">‚ààùí´</a> <a id="22098" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="22100" href="#12139" class="Function">‚áí</a> <a id="22102" class="Symbol">((</a><a id="22104" href="#22092" class="Bound">xs</a> <a id="22107" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="22111" href="#22059" class="Bound">f</a><a id="22112" class="Symbol">)</a> <a id="22114" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="22118" href="#22075" class="Bound">g</a><a id="22119" class="Symbol">)</a> <a id="22121" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">‚â°</a> <a id="22123" href="#22092" class="Bound">xs</a> <a id="22126" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="22130" class="Symbol">(Œª</a> <a id="22133" href="#22133" class="Bound">x</a> <a id="22135" class="Symbol">‚Üí</a> <a id="22137" href="#22059" class="Bound">f</a> <a id="22139" href="#22133" class="Bound">x</a> <a id="22141" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="22145" href="#22075" class="Bound">g</a><a id="22146" class="Symbol">)</a> <a id="22148" href="#12139" class="Function">‚üß</a>
  <a id="22152" href="#11443" class="Field Operator">‚ü¶</a> <a id="22154" href="#22045" class="Function">&gt;&gt;=-assoc‚Ä≤</a> <a id="22165" href="#22165" class="Bound">f</a> <a id="22167" href="#22167" class="Bound">g</a> <a id="22169" href="#11443" class="Field Operator">‚üß-prop</a> <a id="22176" class="Symbol">=</a> <a id="22178" href="#8921" class="InductiveConstructor">trunc</a> <a id="22184" class="Symbol">_</a> <a id="22186" class="Symbol">_</a>
  <a id="22190" href="#11481" class="Field Operator">‚ü¶</a> <a id="22192" href="#22045" class="Function">&gt;&gt;=-assoc‚Ä≤</a> <a id="22203" href="#22203" class="Bound">f</a> <a id="22205" href="#22205" class="Bound">g</a> <a id="22207" href="#11481" class="Field Operator">‚üß[]</a> <a id="22211" class="Symbol">=</a> <a id="22213" href="../code/probability/Cubical.Foundations.Prelude.html#827" class="Function">refl</a>
  <a id="22220" href="#11498" class="Field Operator">‚ü¶</a> <a id="22222" href="#22045" class="Function">&gt;&gt;=-assoc‚Ä≤</a> <a id="22233" href="#22233" class="Bound">f</a> <a id="22235" href="#22235" class="Bound">g</a> <a id="22237" href="#11498" class="Field Operator">‚üß</a> <a id="22239" href="#22239" class="Bound">p</a> <a id="22241" href="#11498" class="Field Operator">&amp;</a> <a id="22243" href="#22243" class="Bound">x</a> <a id="22245" href="#11498" class="Field Operator">‚à∑</a> <a id="22247" href="#22247" class="Bound">xs</a> <a id="22250" href="#11498" class="Field Operator">‚ü®</a> <a id="22252" href="#22252" class="Bound">P</a> <a id="22254" href="#11498" class="Field Operator">‚ü©</a> <a id="22256" class="Symbol">=</a>
    <a id="22262" class="Symbol">(((</a><a id="22265" href="#22239" class="Bound">p</a> <a id="22267" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="22269" href="#22243" class="Bound">x</a> <a id="22271" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="22273" href="#22247" class="Bound">xs</a><a id="22275" class="Symbol">)</a> <a id="22277" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="22281" href="#22233" class="Bound">f</a><a id="22282" class="Symbol">)</a> <a id="22284" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="22288" href="#22235" class="Bound">g</a><a id="22289" class="Symbol">)</a> <a id="22291" href="../code/probability/ProbabilityModule.Utils.html#572" class="Function Operator">‚â°‚ü®‚ü©</a>
    <a id="22299" class="Symbol">((</a><a id="22301" href="#22239" class="Bound">p</a> <a id="22303" href="#14109" class="Function Operator">‚ãä</a> <a id="22305" href="#22233" class="Bound">f</a> <a id="22307" href="#22243" class="Bound">x</a> <a id="22309" href="#13390" class="Function Operator">‚à™</a> <a id="22311" class="Symbol">(</a><a id="22312" href="#22247" class="Bound">xs</a> <a id="22315" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="22319" href="#22233" class="Bound">f</a><a id="22320" class="Symbol">))</a> <a id="22323" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="22327" href="#22235" class="Bound">g</a><a id="22328" class="Symbol">)</a> <a id="22330" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚â°‚ü®</a> <a id="22333" href="#19228" class="Function">&gt;&gt;=-distrib</a> <a id="22345" class="Symbol">(</a><a id="22346" href="#22239" class="Bound">p</a> <a id="22348" href="#14109" class="Function Operator">‚ãä</a> <a id="22350" href="#22233" class="Bound">f</a> <a id="22352" href="#22243" class="Bound">x</a><a id="22353" class="Symbol">)</a> <a id="22355" class="Symbol">(</a><a id="22356" href="#22247" class="Bound">xs</a> <a id="22359" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="22363" href="#22233" class="Bound">f</a><a id="22364" class="Symbol">)</a> <a id="22366" href="#22235" class="Bound">g</a> <a id="22368" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚ü©</a>
    <a id="22374" class="Symbol">((</a><a id="22376" href="#22239" class="Bound">p</a> <a id="22378" href="#14109" class="Function Operator">‚ãä</a> <a id="22380" href="#22233" class="Bound">f</a> <a id="22382" href="#22243" class="Bound">x</a><a id="22383" class="Symbol">)</a> <a id="22385" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="22389" href="#22235" class="Bound">g</a><a id="22390" class="Symbol">)</a> <a id="22392" href="#13390" class="Function Operator">‚à™</a> <a id="22394" class="Symbol">((</a><a id="22396" href="#22247" class="Bound">xs</a> <a id="22399" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="22403" href="#22233" class="Bound">f</a><a id="22404" class="Symbol">)</a> <a id="22406" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="22410" href="#22235" class="Bound">g</a><a id="22411" class="Symbol">)</a> <a id="22413" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚â°‚ü®</a> <a id="22416" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="22421" class="Symbol">((</a><a id="22423" href="#22239" class="Bound">p</a> <a id="22425" href="#14109" class="Function Operator">‚ãä</a> <a id="22427" href="#22233" class="Bound">f</a> <a id="22429" href="#22243" class="Bound">x</a><a id="22430" class="Symbol">)</a> <a id="22432" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="22436" href="#22235" class="Bound">g</a> <a id="22438" href="#13390" class="Function Operator">‚à™_</a><a id="22440" class="Symbol">)</a> <a id="22442" href="#22252" class="Bound">P</a> <a id="22444" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚ü©</a>
    <a id="22450" class="Symbol">((</a><a id="22452" href="#22239" class="Bound">p</a> <a id="22454" href="#14109" class="Function Operator">‚ãä</a> <a id="22456" href="#22233" class="Bound">f</a> <a id="22458" href="#22243" class="Bound">x</a><a id="22459" class="Symbol">)</a> <a id="22461" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="22465" href="#22235" class="Bound">g</a><a id="22466" class="Symbol">)</a> <a id="22468" href="#13390" class="Function Operator">‚à™</a> <a id="22470" class="Symbol">(</a><a id="22471" href="#22247" class="Bound">xs</a> <a id="22474" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="22478" class="Symbol">(Œª</a> <a id="22481" href="#22481" class="Bound">y</a> <a id="22483" class="Symbol">‚Üí</a> <a id="22485" href="#22233" class="Bound">f</a> <a id="22487" href="#22481" class="Bound">y</a> <a id="22489" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="22493" href="#22235" class="Bound">g</a><a id="22494" class="Symbol">))</a> <a id="22497" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚â°‚ü®</a> <a id="22500" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="22505" class="Symbol">(</a><a id="22506" href="#13390" class="Function Operator">_‚à™</a> <a id="22509" class="Symbol">(</a><a id="22510" href="#22247" class="Bound">xs</a> <a id="22513" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="22517" class="Symbol">(Œª</a> <a id="22520" href="#22520" class="Bound">y</a> <a id="22522" class="Symbol">‚Üí</a> <a id="22524" href="#22233" class="Bound">f</a> <a id="22526" href="#22520" class="Bound">y</a> <a id="22528" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="22532" href="#22235" class="Bound">g</a><a id="22533" class="Symbol">)))</a> <a id="22537" class="Symbol">(</a><a id="22538" href="#20451" class="Function">‚ãä-assoc-&gt;&gt;=</a> <a id="22550" href="#22239" class="Bound">p</a> <a id="22552" class="Symbol">(</a><a id="22553" href="#22233" class="Bound">f</a> <a id="22555" href="#22243" class="Bound">x</a><a id="22556" class="Symbol">)</a> <a id="22558" href="#22235" class="Bound">g</a><a id="22559" class="Symbol">)</a> <a id="22561" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">‚ü©</a>
    <a id="22567" href="#22239" class="Bound">p</a> <a id="22569" href="#14109" class="Function Operator">‚ãä</a> <a id="22571" class="Symbol">(</a><a id="22572" href="#22233" class="Bound">f</a> <a id="22574" href="#22243" class="Bound">x</a> <a id="22576" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="22580" href="#22235" class="Bound">g</a><a id="22581" class="Symbol">)</a> <a id="22583" href="#13390" class="Function Operator">‚à™</a> <a id="22585" class="Symbol">(</a><a id="22586" href="#22247" class="Bound">xs</a> <a id="22589" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="22593" class="Symbol">(Œª</a> <a id="22596" href="#22596" class="Bound">y</a> <a id="22598" class="Symbol">‚Üí</a> <a id="22600" href="#22233" class="Bound">f</a> <a id="22602" href="#22596" class="Bound">y</a> <a id="22604" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="22608" href="#22235" class="Bound">g</a><a id="22609" class="Symbol">))</a> <a id="22612" href="../code/probability/ProbabilityModule.Utils.html#572" class="Function Operator">‚â°‚ü®‚ü©</a>
    <a id="22620" class="Symbol">((</a><a id="22622" href="#22239" class="Bound">p</a> <a id="22624" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="22626" href="#22243" class="Bound">x</a> <a id="22628" href="#8727" class="InductiveConstructor Operator">‚à∑</a> <a id="22630" href="#22247" class="Bound">xs</a><a id="22632" class="Symbol">)</a> <a id="22634" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="22638" class="Symbol">(Œª</a> <a id="22641" href="#22641" class="Bound">y</a> <a id="22643" class="Symbol">‚Üí</a> <a id="22645" href="#22233" class="Bound">f</a> <a id="22647" href="#22641" class="Bound">y</a> <a id="22649" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="22653" href="#22235" class="Bound">g</a><a id="22654" class="Symbol">))</a> <a id="22657" href="../code/probability/Cubical.Foundations.Prelude.html#2745" class="Function Operator">‚àé</a>
</pre>
</details>
<h1 id="conclusion">Conclusion</h1>
<p>I‚Äôve really enjoyed working with cubical Agda so far, and the proofs above were a pleasure to write. I think I can use the above definition to get a workable differential privacy monad, also.</p>
<p>Anyway, all the code is available <a href="https://oisdk.github.io/agda-cubical-probability/Probability.html">here</a>.</p>
]]></description>
    <pubDate>Wed, 17 Apr 2019 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2019-04-17-cubical-probability.html</guid>
    <dc:creator>Donnacha Ois√≠n Kidney</dc:creator>
</item>
<item>
    <title>Permutations By Sorting</title>
    <link>https://doisinkidney.com/posts/2019-03-24-permutations-by-sorting.html</link>
    <description><![CDATA[<div class="info">
    Posted on March 24, 2019
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Agda.html">Agda</a>
    
</div>

<p>A naive‚Äîand wrong‚Äîway to shuffle a list is to assign each element in the list a random number, and then sort it. It might not be immediately obvious why: <span class="citation" data-cites="kiselyov_provably_2002">Kiselyov (<a href="#ref-kiselyov_provably_2002">2002</a>)</span> has a good explanation as to the problem. One way to think about it is like this: choosing <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> random numbers each in the range <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">[0,n)</annotation></semantics></math> has <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>n</mi><mi>n</mi></msup><annotation encoding="application/x-tex">n^n</annotation></semantics></math> possible outcomes, whereas there are <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>!</mi></mrow><annotation encoding="application/x-tex">n!</annotation></semantics></math> permutations. Since these don‚Äôt necessarily divide evenly into each other, you‚Äôre going to have some bias.</p>
<h1 id="factorial-numbers">Factorial Numbers</h1>
<p>The first part of the fix is to figure out a way to get some random data that has only <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>!</mi></mrow><annotation encoding="application/x-tex">n!</annotation></semantics></math> possible values. The trick here will be to mimic the structure of a factorial itself: taking <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">n = 5</annotation></semantics></math>, the previous technique would have yielded:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn><mo>√ó</mo><mn>5</mn><mo>√ó</mo><mn>5</mn><mo>√ó</mo><mn>5</mn><mo>√ó</mo><mn>5</mn><mo>=</mo><msup><mn>5</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">5 \times 5 \times 5 \times 5 \times 5 = 5^5</annotation></semantics></math></p>
<p>possible values. But we want:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn><mo>√ó</mo><mn>4</mn><mo>√ó</mo><mn>3</mn><mo>√ó</mo><mn>2</mn><mo>√ó</mo><mn>1</mn><mo>=</mo><mn>5</mn><mi>!</mi></mrow><annotation encoding="application/x-tex">5 \times 4 \times 3 \times 2 \times 1 = 5!</annotation></semantics></math></p>
<p>The solution is simple, then! Simply decrement the range by one for each position in the output list. In Haskell:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">nums ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> [<span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">nums <span class="dv">0</span> <span class="fu">=</span> pure []</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">nums n <span class="fu">=</span> (<span class="fu">:</span>) <span class="fu">&lt;$&gt;</span> randomR (<span class="dv">0</span>,n) <span class="fu">&lt;*&gt;</span> nums (n<span class="fu">-</span><span class="dv">1</span>)</a></code></pre></div>
<p>As an aside, what we‚Äôve done here is constructed a list of digits in the <a href="https://en.wikipedia.org/wiki/Factorial_number_system">factorial number system</a>.</p>
<h1 id="sorts">Sorts</h1>
<p>Unfortunately, while we‚Äôve figured out a way to get properly distributed random data, we can‚Äôt yet sort it to shuffle our list. If we look at the 6 factorial numbers generated for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">n = 5</annotation></semantics></math>, we can see the problem:</p>
<pre><code>000
010
100
110
200
210</code></pre>
<p>Different values in the list will produce the same sort: <code>100</code> and <code>200</code>, for instance.</p>
<h1 id="lehmer-codes">Lehmer Codes</h1>
<p>We need a way to map the numbers above to a particular permutations: that‚Äôs precisely the problem solved by <a href="https://en.wikipedia.org/wiki/Lehmer_code">Lehmer codes</a>. For the numbers <code>110</code>, we can think of each digit as the relative position to put that item from the string into. Some Haskell code might make it clear:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">insert ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">insert <span class="dv">0</span> x xs <span class="fu">=</span> x <span class="fu">:</span> xs</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">insert i x (y<span class="fu">:</span>ys) <span class="fu">=</span> y <span class="fu">:</span> insert (i<span class="fu">-</span><span class="dv">1</span>) x ys</a>
<a class="sourceLine" id="cb3-4" data-line-number="4"></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="ot">shuffle ::</span> [a] <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">shuffle xs ys <span class="fu">=</span> foldr (uncurry insert) [] (zip ys xs)</a></code></pre></div>
<p>And we can step through its execution:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">shuffle <span class="st">&quot;abc&quot;</span> [<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>]</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">foldr (uncurry insert) [] [(<span class="dv">1</span>,<span class="ch">&#39;a&#39;</span>),(<span class="dv">1</span>,<span class="ch">&#39;b&#39;</span>),(<span class="dv">0</span>,<span class="ch">&#39;c&#39;</span>)]</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">insert <span class="dv">1</span> <span class="ch">&#39;a&#39;</span> (insert <span class="dv">1</span> <span class="ch">&#39;b&#39;</span> (insert <span class="dv">0</span> <span class="ch">&#39;c&#39;</span> []))</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">insert <span class="dv">1</span> <span class="ch">&#39;a&#39;</span> (insert <span class="dv">1</span> <span class="ch">&#39;b&#39;</span> <span class="st">&quot;c&quot;</span>)</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">insert <span class="dv">1</span> <span class="ch">&#39;a&#39;</span> <span class="st">&quot;cb&quot;</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6"><span class="ch">&#39;c&#39;</span> <span class="fu">:</span> insert <span class="dv">0</span> <span class="ch">&#39;a&#39;</span> <span class="st">&quot;b&quot;</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7"><span class="st">&quot;cab&quot;</span></a></code></pre></div>
<h1 id="dualities-of-sorts">Dualities of Sorts</h1>
<p>Notice the similarity of the function above to a standard insertion sort:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">insert ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">insert x [] <span class="fu">=</span> x <span class="fu">:</span> xs</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">insert x (y<span class="fu">:</span>ys)</a>
<a class="sourceLine" id="cb5-4" data-line-number="4"> <span class="fu">|</span> x <span class="fu">&lt;=</span> y <span class="fu">=</span> x <span class="fu">:</span> y <span class="fu">:</span> ys</a>
<a class="sourceLine" id="cb5-5" data-line-number="5"> <span class="fu">|</span> otherwise <span class="fu">=</span> y <span class="fu">:</span> insert x ys</a>
<a class="sourceLine" id="cb5-6" data-line-number="6"></a>
<a class="sourceLine" id="cb5-7" data-line-number="7"><span class="ot">insertSort ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb5-8" data-line-number="8">insertSort <span class="fu">=</span> foldr insert []</a></code></pre></div>
<p>The ‚Äúcomparison‚Äù is a little strange‚Äîwe have to take into account relative position‚Äîbut the shape is almost identical. Once I spot something like that, my first thought is to see if the relationship extends to a better <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n \log n)</annotation></semantics></math> sort, but there‚Äôs something else I‚Äôd like to look at first.</p>
<p>‚ÄúA Duality of Sorts‚Äù <span class="citation" data-cites="hinze_duality_2013">(Hinze, Magalh√£es, and Wu <a href="#ref-hinze_duality_2013">2013</a>)</span> is a paper based on the interesting symmetry between insertion sort and selection sort <span class="citation" data-cites="haran_sorting_2016">(There‚Äôs also a video of Graham Hutton explaining the idea; Haran <a href="#ref-haran_sorting_2016">2016</a>)</span>.</p>
<p>With that paper in mind, can we rewrite <code>shuffle</code> as a selection-based algorithm? We can indeed!</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">pop ::</span> [(<span class="dt">Int</span>,a)] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, [(<span class="dt">Int</span>,a)])</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">pop [] <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">pop ((<span class="dv">0</span>,x)<span class="fu">:</span>xs) <span class="fu">=</span> <span class="dt">Just</span> (x, xs)</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">pop ((i,x)<span class="fu">:</span>xs) <span class="fu">=</span> (fmap<span class="fu">.</span>fmap) ((i<span class="fu">-</span><span class="dv">1</span>,x)<span class="fu">:</span>) (pop xs)</a>
<a class="sourceLine" id="cb6-5" data-line-number="5"></a>
<a class="sourceLine" id="cb6-6" data-line-number="6"><span class="ot">shuffle ::</span> [a] <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">shuffle xs ys <span class="fu">=</span> unfoldr pop (zip ys xs)</a></code></pre></div>
<p>While the symmetry is pleasing, the paper details how to make the relationship explicit, using the same function for both selection and insertion sort:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1">swop <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">swop (<span class="dt">Cons</span> a (x , <span class="dt">Nil</span>)) <span class="fu">=</span> <span class="dt">Cons</span> a (<span class="dt">Left</span> x)</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">swop (<span class="dt">Cons</span> a (x , <span class="dt">Cons</span> b x&#39;))</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">  <span class="fu">|</span> fst a <span class="fu">==</span> <span class="dv">0</span> <span class="fu">=</span> <span class="dt">Cons</span> a (<span class="dt">Left</span> x)</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">  <span class="fu">|</span> otherwise  <span class="fu">=</span> <span class="dt">Cons</span> b (<span class="dt">Right</span> (<span class="dt">Cons</span> (first pred a) x&#39;))</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">  </a>
<a class="sourceLine" id="cb7-7" data-line-number="7"><span class="ot">ishuffle ::</span> [(<span class="dt">Int</span>,a)] <span class="ot">-&gt;</span> [(<span class="dt">Int</span>,a)]</a>
<a class="sourceLine" id="cb7-8" data-line-number="8">ishuffle <span class="fu">=</span> cata (apo (swop <span class="fu">.</span> fmap (id <span class="fu">&amp;&amp;&amp;</span> project)))</a>
<a class="sourceLine" id="cb7-9" data-line-number="9"></a>
<a class="sourceLine" id="cb7-10" data-line-number="10"><span class="ot">sshuffle ::</span> [(<span class="dt">Int</span>,a)] <span class="ot">-&gt;</span> [(<span class="dt">Int</span>,a)]</a>
<a class="sourceLine" id="cb7-11" data-line-number="11">sshuffle <span class="fu">=</span> ana (para (fmap (id <span class="fu">|||</span> embed) <span class="fu">.</span> swop))</a></code></pre></div>
<h1 id="improved-efficiency">Improved Efficiency</h1>
<p>So now we have to upgrade our sorts: in the paper, merge sort is the more efficient sort chosen, similarly to what I chose <a href="2018-12-21-balancing-scans.html#random-shuffles">previously</a>.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">merge [] ys <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">merge xs [] <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">merge ((x,i)<span class="fu">:</span>xs) ((y,j)<span class="fu">:</span>ys)</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">  <span class="fu">|</span> i <span class="fu">&lt;=</span> j    <span class="fu">=</span> (x,i) <span class="fu">:</span> merge xs ((y,j<span class="fu">-</span>i)<span class="fu">:</span>ys)</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">  <span class="fu">|</span> otherwise <span class="fu">=</span> (y,j) <span class="fu">:</span> merge ((x,i<span class="fu">-</span>j<span class="fu">-</span><span class="dv">1</span>)<span class="fu">:</span>xs) ys</a>
<a class="sourceLine" id="cb8-6" data-line-number="6">  </a>
<a class="sourceLine" id="cb8-7" data-line-number="7"><span class="ot">treeFold ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb8-8" data-line-number="8">treeFold f <span class="fu">=</span> go</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-10" data-line-number="10">    go x [] <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb8-11" data-line-number="11">    go a (b<span class="fu">:</span>l) <span class="fu">=</span> go (f a b) (pairMap l)</a>
<a class="sourceLine" id="cb8-12" data-line-number="12">    pairMap (x<span class="fu">:</span>y<span class="fu">:</span>rest) <span class="fu">=</span> f x y <span class="fu">:</span> pairMap rest</a>
<a class="sourceLine" id="cb8-13" data-line-number="13">    pairMap xs <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb8-14" data-line-number="14">    </a>
<a class="sourceLine" id="cb8-15" data-line-number="15">shuffle xs inds <span class="fu">=</span> map fst <span class="fu">$</span> treeFold merge [] <span class="fu">$</span> map pure <span class="fu">$</span> zip xs inds</a></code></pre></div>
<p>However, I feel like merge sort is an upgrade of <em>insertion</em> sort, not selection sort. Indeed, if you do the ‚Äúsplit‚Äù step of merge sort badly, i.e.¬†by splitting very unevenly, merge sort in fact <em>becomes</em> insertion sort!</p>
<p>So there‚Äôs a missing bit of this table:</p>
<table>
<thead>
<tr class="header">
<th></th>
<th style="text-align: center;">Insertion</th>
<th style="text-align: center;">Selection</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n^2)</annotation></semantics></math></td>
<td style="text-align: center;">Insertion sort</td>
<td style="text-align: center;">Selection sort</td>
</tr>
<tr class="even">
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n \log n)</annotation></semantics></math></td>
<td style="text-align: center;">Merge sort</td>
<td style="text-align: center;">???</td>
</tr>
</tbody>
</table>
<p>I think it‚Äôs clear that quicksort is the algorithm that fits in there: again, done badly it degrades to selection sort (if you intentionally pick the pivot to be the worst element possible, i.e.¬†the smallest element).</p>
<p>There are more symmetries: merge sort splits the lists using their structure, and merges them using the ordering of the elements. Quicksort is the opposite, merging by concatenation, but splitting using order. Finally, in merge sort adjacent elements are in the correct order after the recursive call, but the two sides of the split are not. Again, quicksort is precisely the opposite: adjacent elements have not been compared (<em>before</em> the recursive call), but the two sides of the split are correctly ordered.</p>
<p>Anyway, I haven‚Äôt yet formalised this duality (and I don‚Äôt know if I can), but we <em>can</em> use it to produce a quicksort-based shuffle algorithm:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1">partition <span class="fu">=</span> foldr f (const ([],[]))</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">    f (y,j) ys i</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">      <span class="fu">|</span> i <span class="fu">&lt;=</span> j    <span class="fu">=</span> fmap  ((y,j<span class="fu">-</span>i)<span class="fu">:</span>) (ys i)</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">      <span class="fu">|</span> otherwise <span class="fu">=</span> first ((y,j)<span class="fu">:</span>) (ys (i<span class="fu">-</span><span class="dv">1</span>))</a>
<a class="sourceLine" id="cb9-6" data-line-number="6">      </a>
<a class="sourceLine" id="cb9-7" data-line-number="7"><span class="ot">shuffle ::</span> [a] <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb9-8" data-line-number="8">shuffle xs ys <span class="fu">=</span> go (zip xs ys)</a>
<a class="sourceLine" id="cb9-9" data-line-number="9">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-10" data-line-number="10">    go [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb9-11" data-line-number="11">    go ((x,i)<span class="fu">:</span>xs) <span class="fu">=</span> <span class="kw">case</span> partition xs i <span class="kw">of</span></a>
<a class="sourceLine" id="cb9-12" data-line-number="12">        (ls,rs) <span class="ot">-&gt;</span> go ls <span class="fu">++</span> [x] <span class="fu">++</span> go rs</a></code></pre></div>
<p>That‚Äôs all for this post! The algorithms can all be translated into Agda or Idris: I‚Äôm currently working on a way to represent permutations that isn‚Äôt <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n^2)</annotation></semantics></math> using them. If I figure out a way to properly dualise quicksort and merge sort I‚Äôll do a small write up as well <span class="citation" data-cites="hinze_sorting_2012">(I‚Äôm currently working my way through Hinze et al. <a href="#ref-hinze_sorting_2012">2012</a> for ideas)</span>. Finally, I‚Äôd like to explore some other sorting algorithms as permutation algorithms: sorting networks seem especially related to ‚Äúpermutations by swapping‚Äù.</p>
<h1 id="references" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-haran_sorting_2016">
<p>Haran, Brady. 2016. ‚ÄúSorting Secret.‚Äù <a href="https://www.youtube.com/watch?v=pcJHkWwjNl4" class="uri">https://www.youtube.com/watch?v=pcJHkWwjNl4</a>.</p>
</div>
<div id="ref-hinze_sorting_2012">
<p>Hinze, Ralf, Daniel W.H. James, Thomas Harper, Nicolas Wu, and Jos√© Pedro Magalh√£es. 2012. ‚ÄúSorting with bialgebras and distributive laws.‚Äù In <em>Proceedings of the 8th ACM SIGPLAN workshop on Generic programming - WGP ‚Äô12</em>, 69. Copenhagen, Denmark: ACM Press. doi:<a href="https://doi.org/10.1145/2364394.2364405">10.1145/2364394.2364405</a>.</p>
</div>
<div id="ref-hinze_duality_2013">
<p>Hinze, Ralf, Jos√© Pedro Magalh√£es, and Nicolas Wu. 2013. ‚ÄúA Duality of Sorts.‚Äù In <em>The Beauty of Functional Code: Essays Dedicated to Rinus Plasmeijer on the Occasion of His 61st Birthday</em>, ed by. Peter Achten and Pieter Koopman, 151‚Äì167. Lecture Notes in Computer Science. Berlin, Heidelberg: Springer Berlin Heidelberg. doi:<a href="https://doi.org/10.1007/978-3-642-40355-2_11">10.1007/978-3-642-40355-2_11</a>.</p>
</div>
<div id="ref-kiselyov_provably_2002">
<p>Kiselyov, Oleg. 2002. ‚ÄúProvably perfect random shuffling and its pure functional implementations.‚Äù <em>http://okmij.org</em>. <a href="http://okmij.org/ftp/Haskell/AlgorithmsH.html#perfect-shuffle" class="uri">http://okmij.org/ftp/Haskell/AlgorithmsH.html#perfect-shuffle</a>.</p>
</div>
</div>
]]></description>
    <pubDate>Sun, 24 Mar 2019 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2019-03-24-permutations-by-sorting.html</guid>
    <dc:creator>Donnacha Ois√≠n Kidney</dc:creator>
</item>
<item>
    <title>Lazy Binary Numbers</title>
    <link>https://doisinkidney.com/posts/2019-03-21-binary-logic-search.html</link>
    <description><![CDATA[<div class="info">
    Posted on March 21, 2019
</div>
<div class="info">
    
        Part 1 of a <a href="/series/Binary%20Numbers.html">1-part series on Binary Numbers</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Agda.html">Agda</a>, <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<h1 id="number-representations">Number Representations</h1>
<p>When working with numbers in Agda, we usually use the following definition:</p>
<style>
.column {
    float: left;
    width: 50%;
}
.row:after {
    content: "";
    display: table;
    clear: both;
}
</style>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> <span class="dt">N</span> <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">|</span> <span class="dt">S</span> <span class="dt">N</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>)</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">instance</span> <span class="dt">Num</span> <span class="dt">N</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">    <span class="dt">Z</span> <span class="fu">+</span> n <span class="fu">=</span> n</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">    <span class="dt">S</span> n <span class="fu">+</span> m <span class="fu">=</span> <span class="dt">S</span> (n <span class="fu">+</span> m)</a>
<a class="sourceLine" id="cb1-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">    <span class="dt">Z</span> <span class="fu">*</span> m <span class="fu">=</span> <span class="dt">Z</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">    <span class="dt">S</span> n <span class="fu">*</span> m <span class="fu">=</span> m <span class="fu">+</span> n <span class="fu">*</span> m</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb2"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> ‚Ñï <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  zero <span class="ot">:</span> ‚Ñï</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  suc <span class="ot">:</span> ‚Ñï <span class="ot">‚Üí</span> ‚Ñï</a>
<a class="sourceLine" id="cb2-4" data-line-number="4"></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="ot">_</span>+<span class="ot">_</span> <span class="ot">:</span> ‚Ñï <span class="ot">‚Üí</span> ‚Ñï <span class="ot">‚Üí</span> ‚Ñï</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">zero  + y <span class="ot">=</span> y</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">suc x + y <span class="ot">=</span> suc <span class="ot">(</span>x + y<span class="ot">)</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8"></a>
<a class="sourceLine" id="cb2-9" data-line-number="9"><span class="ot">_</span>*<span class="ot">_</span> <span class="ot">:</span> ‚Ñï <span class="ot">‚Üí</span> ‚Ñï <span class="ot">‚Üí</span> ‚Ñï</a>
<a class="sourceLine" id="cb2-10" data-line-number="10">zero  * y <span class="ot">=</span> zero</a>
<a class="sourceLine" id="cb2-11" data-line-number="11">suc x * y <span class="ot">=</span> y + <span class="ot">(</span>x * y<span class="ot">)</span></a></code></pre></div>
</div>
</div>
<div class="row">
<div class="column">
<p>Haskell</p>
</div>
<div class="column">
<p>Agda</p>
</div>
</div>
<p>In Haskell it‚Äôs less common, for obvious reasons:</p>
<table>
<thead>
<tr class="header">
<th>Operation</th>
<th>Complexity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>+</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n + m</annotation></semantics></math></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n)</annotation></semantics></math></td>
</tr>
<tr class="even">
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>√ó</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n \times m</annotation></semantics></math></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mi>m</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(nm)</annotation></semantics></math></td>
</tr>
</tbody>
</table>
<p>Why use them at all, then? Well, in Agda, we need them so we can <em>prove</em> things about the natural numbers. Machine-level integers are fast, but they‚Äôre opaque: their implementation isn‚Äôt written in Agda, and therefore it‚Äôs not available for the compiler to reason about.</p>
<p>In Haskell, they occasionally find uses due to their <em>laziness</em>. This can help in Agda as well. By lazy here I mean that operations on them don‚Äôt have to inspect the full structure before giving some output.</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> <span class="dt">Z</span> <span class="fu">&lt;</span> <span class="dt">S</span> undefined</a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="dt">True</span></a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb4"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb4-1" data-line-number="1">*-zeroÀ° <span class="ot">:</span> <span class="ot">‚àÄ</span> x <span class="ot">‚Üí</span> zero * x ‚â° zero</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">*-zeroÀ° x <span class="ot">=</span> refl</a></code></pre></div>
</div>
</div>
<p>In Haskell, as we can see, this lets us run computations without scrutinising some arguments. Agda benefits similarly: here it lets the compiler see more ‚Äúobvious‚Äù facts that it may have missed otherwise.</p>
<p>It‚Äôs not <em>completely</em> lazy, though. In particular, it tends to be left-biased:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> undefined <span class="fu">*</span> <span class="dt">Z</span> <span class="fu">==</span> <span class="dt">Z</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="fu">**</span> <span class="dt">Exception</span><span class="fu">:</span> Prelude.undefined</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb6"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb6-1" data-line-number="1">*-zero ≥ <span class="ot">:</span> <span class="ot">‚àÄ</span> x <span class="ot">‚Üí</span> x * zero ‚â° zero</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">*-zero ≥ x <span class="ot">=</span> refl</a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="co">-- x * zero != zero of type ‚Ñï</span></a></code></pre></div>
</div>
</div>
<p>Like Boolean short-circuiting operators, operations on Peano numbers will usually have to scrutinise the left-hand-side argument quite a bit before giving an output.</p>
<p>So, Peano numbers are good because:</p>
<ol>
<li>We can prove things about them.</li>
<li>They‚Äôre lazy.</li>
</ol>
<p>In this post, I‚Äôm going to look at some other number representations that maintain these two desirable properties, while improving on the efficiency somewhat.</p>
<h2 id="list-of-bits-binary">List-of-Bits-Binary</h2>
<p>The first option for an improved representation is binary numbers. We can represent binary numbers as a list of bits:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Bit</span> <span class="fu">=</span> <span class="dt">O</span> <span class="fu">|</span> <span class="dt">I</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>, <span class="dt">Ord</span>)</a>
<a class="sourceLine" id="cb7-2" data-line-number="2"></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="kw">type</span> <span class="dt">B</span> <span class="fu">=</span> [<span class="dt">Bit</span>]</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb8"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">data</span> Bit <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span> O I <span class="ot">:</span> Bit</a>
<a class="sourceLine" id="cb8-2" data-line-number="2"></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">ùîπ <span class="ot">:</span> <span class="dt">Set</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">ùîπ <span class="ot">=</span> List Bit</a></code></pre></div>
</div>
</div>
<p>As we‚Äôre using these to represent natural numbers, we‚Äôll need to define a way to convert between them:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">eval ::</span> <span class="dt">B</span> <span class="ot">-&gt;</span> <span class="dt">N</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">eval <span class="fu">=</span> foldr f <span class="dt">Z</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4">    f <span class="dt">O</span> xs <span class="fu">=</span> xs <span class="fu">+</span> xs</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">    f <span class="dt">I</span> xs <span class="fu">=</span> <span class="dt">S</span> (xs <span class="fu">+</span> xs)</a>
<a class="sourceLine" id="cb9-6" data-line-number="6"></a>
<a class="sourceLine" id="cb9-7" data-line-number="7"><span class="ot">inc ::</span> <span class="dt">B</span> <span class="ot">-&gt;</span> <span class="dt">B</span></a>
<a class="sourceLine" id="cb9-8" data-line-number="8">inc [] <span class="fu">=</span> [<span class="dt">I</span>]</a>
<a class="sourceLine" id="cb9-9" data-line-number="9">inc (<span class="dt">O</span><span class="fu">:</span>xs) <span class="fu">=</span> <span class="dt">I</span> <span class="fu">:</span> xs</a>
<a class="sourceLine" id="cb9-10" data-line-number="10">inc (<span class="dt">I</span><span class="fu">:</span>xs) <span class="fu">=</span> <span class="dt">O</span> <span class="fu">:</span> inc xs</a>
<a class="sourceLine" id="cb9-11" data-line-number="11"></a>
<a class="sourceLine" id="cb9-12" data-line-number="12"><span class="ot">fromN ::</span> <span class="dt">N</span> <span class="ot">-&gt;</span> <span class="dt">B</span></a>
<a class="sourceLine" id="cb9-13" data-line-number="13">fromN <span class="dt">Z</span> <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb9-14" data-line-number="14">fromN (<span class="dt">S</span> n) <span class="fu">=</span> inc (fromN n)</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb10"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb10-1" data-line-number="1">‚ü¶<span class="ot">_</span>‚áì‚üß <span class="ot">:</span> ùîπ <span class="ot">‚Üí</span> ‚Ñï</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">‚ü¶<span class="ot">_</span>‚áì‚üß <span class="ot">=</span> foldr <span class="ot">(Œª</span> <span class="ot">{</span> O xs <span class="ot">‚Üí</span> xs + xs</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">                <span class="ot">;</span> I xs <span class="ot">‚Üí</span> suc <span class="ot">(</span>xs + xs<span class="ot">)</span> <span class="ot">})</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4">             zero</a>
<a class="sourceLine" id="cb10-5" data-line-number="5"></a>
<a class="sourceLine" id="cb10-6" data-line-number="6">inc <span class="ot">:</span> ùîπ <span class="ot">‚Üí</span> ùîπ</a>
<a class="sourceLine" id="cb10-7" data-line-number="7">inc [] <span class="ot">=</span> I ‚à∑ []</a>
<a class="sourceLine" id="cb10-8" data-line-number="8">inc <span class="ot">(</span>O ‚à∑ xs<span class="ot">)</span> <span class="ot">=</span> I ‚à∑ xs</a>
<a class="sourceLine" id="cb10-9" data-line-number="9">inc <span class="ot">(</span>I ‚à∑ xs<span class="ot">)</span> <span class="ot">=</span> O ‚à∑ inc xs</a>
<a class="sourceLine" id="cb10-10" data-line-number="10"></a>
<a class="sourceLine" id="cb10-11" data-line-number="11">‚ü¶<span class="ot">_</span>‚áë‚üß <span class="ot">:</span> ‚Ñï <span class="ot">‚Üí</span> ùîπ</a>
<a class="sourceLine" id="cb10-12" data-line-number="12">‚ü¶ zero  ‚áë‚üß <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb10-13" data-line-number="13">‚ü¶ suc n ‚áë‚üß <span class="ot">=</span> inc ‚ü¶ n ‚áë‚üß</a></code></pre></div>
</div>
</div>
<p>And here we run into our first problem: redundancy. There are multiple ways to represent the same number according to the semantics defined above. We can actually prove this in Agda:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb11-1" data-line-number="1">redundant <span class="ot">:</span> ‚àÉ‚ÇÇ <span class="ot">Œª</span> x y <span class="ot">‚Üí</span> x ‚â¢ y √ó ‚ü¶ x ‚áì‚üß ‚â° ‚ü¶ y ‚áì‚üß</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">redundant <span class="ot">=</span> [] , O ‚à∑ [] , <span class="ot">(Œª</span> <span class="ot">())</span> , refl</a></code></pre></div>
<p>In English: ‚ÄúThere are two binary numbers which are not the same, but which do evaluate to the same natural number‚Äù. (This proof was actually automatically filled in for me after writing the signature)</p>
<p>This represents a huge problem for proofs. It means that even simple things like <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>√ó</mo><mn>0</mn><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x \times 0 = 0</annotation></semantics></math> aren‚Äôt true, depending on how multiplication is implemented. On to our next option:</p>
<h2 id="list-of-gaps-binary">List-of-Gaps-Binary</h2>
<p>Instead of looking at the bits directly, let‚Äôs think about a binary number as a list of chunks of 0s, each followed by a 1. In this way, we simply <em>can‚Äôt</em> have trailing zeroes, because the definition implies that every number other than 0 ends in 1.</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Gap</span> <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">|</span> <span class="dt">S</span> <span class="dt">Gap</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="kw">type</span> <span class="dt">B</span> <span class="fu">=</span> [<span class="dt">Gap</span>]</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb13"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb13-1" data-line-number="1">ùîπ <span class="ot">:</span> <span class="dt">Set</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">ùîπ <span class="ot">=</span> List ‚Ñï</a></code></pre></div>
</div>
</div>
<p>This guarantees a unique representation. As in the representation above, it has much improved time complexities for the familiar operations:</p>
<table>
<thead>
<tr class="header">
<th>Operation</th>
<th>Complexity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>+</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n + m</annotation></semantics></math></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><msub><mo>log</mo><mn>2</mn></msub><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log_2 n)</annotation></semantics></math></td>
</tr>
<tr class="even">
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>√ó</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n \times m</annotation></semantics></math></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><msub><mo>log</mo><mn>2</mn></msub><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log_2 (n + m))</annotation></semantics></math></td>
</tr>
</tbody>
</table>
<p>Encoding the zeroes as gaps also makes multiplication much faster in certain cases: multiplying by a high power of 2 is a constant-time operation, for instance.</p>
<p>It does have one disadvantage, and it‚Äôs to do with the increment function:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="ot">inc ::</span> <span class="dt">B</span> <span class="ot">-&gt;</span> <span class="dt">B</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2">inc <span class="fu">=</span> uncurry (flip (<span class="fu">:</span>)) <span class="fu">.</span> inc&#39;</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-4" data-line-number="4">    inc&#39; [] <span class="fu">=</span> ([], <span class="dt">Z</span>)</a>
<a class="sourceLine" id="cb14-5" data-line-number="5">    inc&#39; (x<span class="fu">:</span>xs) <span class="fu">=</span> inc&#39;&#39; x xs</a>
<a class="sourceLine" id="cb14-6" data-line-number="6">    </a>
<a class="sourceLine" id="cb14-7" data-line-number="7">    inc&#39;&#39; <span class="dt">Z</span> ns <span class="fu">=</span> fmap <span class="dt">S</span> (inc&#39; ns)</a>
<a class="sourceLine" id="cb14-8" data-line-number="8">    inc&#39;&#39; (<span class="dt">S</span> n) ns <span class="fu">=</span> (n<span class="fu">:</span>ns,<span class="dt">Z</span>)</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb15"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb15-1" data-line-number="1">ùîπ‚Å∫ <span class="ot">:</span> <span class="dt">Set</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2">ùîπ‚Å∫ <span class="ot">=</span> ‚Ñï √ó ùîπ</a>
<a class="sourceLine" id="cb15-3" data-line-number="3"></a>
<a class="sourceLine" id="cb15-4" data-line-number="4">inc <span class="ot">:</span> ùîπ <span class="ot">‚Üí</span> ùîπ</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">inc <span class="ot">=</span> uncurry <span class="ot">_</span>‚à∑<span class="ot">_</span> ‚àò inc‚Ä≤</a>
<a class="sourceLine" id="cb15-6" data-line-number="6">  <span class="kw">module</span> Inc <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-7" data-line-number="7">  <span class="kw">mutual</span></a>
<a class="sourceLine" id="cb15-8" data-line-number="8">    inc‚Ä≤ <span class="ot">:</span> ùîπ <span class="ot">‚Üí</span> ùîπ‚Å∫</a>
<a class="sourceLine" id="cb15-9" data-line-number="9">    inc‚Ä≤ [] <span class="ot">=</span> <span class="dv">0</span> , []</a>
<a class="sourceLine" id="cb15-10" data-line-number="10">    inc‚Ä≤ <span class="ot">(</span>x ‚à∑ xs<span class="ot">)</span> <span class="ot">=</span> inc‚Ä≥ x xs</a>
<a class="sourceLine" id="cb15-11" data-line-number="11"></a>
<a class="sourceLine" id="cb15-12" data-line-number="12">    inc‚Ä≥ <span class="ot">:</span> ‚Ñï <span class="ot">‚Üí</span> ùîπ <span class="ot">‚Üí</span> ùîπ‚Å∫</a>
<a class="sourceLine" id="cb15-13" data-line-number="13">    inc‚Ä≥ zero ns <span class="ot">=</span> map‚ÇÅ suc <span class="ot">(</span>inc‚Ä≤ ns<span class="ot">)</span></a>
<a class="sourceLine" id="cb15-14" data-line-number="14">    inc‚Ä≥ <span class="ot">(</span>suc n<span class="ot">)</span> ns <span class="ot">=</span> <span class="dv">0</span> , n ‚à∑ ns</a></code></pre></div>
</div>
</div>
<p>With all of their problems, Peano numbers performed this operation in constant time. The above implementation is only <em>amortised</em> constant-time, though, with a worst case of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><msub><mo>log</mo><mn>2</mn></msub><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log_2 n)</annotation></semantics></math> (same as the list-of-bits version). There are a number of ways to remedy this, the most famous being:</p>
<h2 id="skew-binary">Skew Binary</h2>
<p>This encoding has three digits: 0, 1, and 2. To guarantee a unique representation, we add the condition that there can be at most one 2 in the number, which must be the first non-zero digit if it‚Äôs present.</p>
<p>To represent this we‚Äôll encode ‚Äúgaps‚Äù, as before, with the condition that if the second gap is 0 it <em>actually</em> represents a 2 digit in the preceding position. That weirdness out of the way, we are rewarded with an <code>inc</code> implementation which is clearly <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math>.</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="ot">inc ::</span> <span class="dt">B</span> <span class="ot">-&gt;</span> <span class="dt">B</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2">inc [] <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">:</span> []</a>
<a class="sourceLine" id="cb16-3" data-line-number="3">inc (x<span class="fu">:</span>[]) <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">:</span> x <span class="fu">:</span> []</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">inc (x  <span class="fu">:</span> <span class="dt">Z</span> <span class="fu">:</span> xs) <span class="fu">=</span> <span class="dt">S</span> x <span class="fu">:</span> xs</a>
<a class="sourceLine" id="cb16-5" data-line-number="5">inc (x1 <span class="fu">:</span> <span class="dt">S</span> x2 <span class="fu">:</span> xs) <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">:</span> x1 <span class="fu">:</span> x2 <span class="fu">:</span> xs</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb17"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb17-1" data-line-number="1">inc <span class="ot">:</span> ùîπ <span class="ot">‚Üí</span> ùîπ</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">inc [] <span class="ot">=</span> <span class="dv">0</span> ‚à∑ []</a>
<a class="sourceLine" id="cb17-3" data-line-number="3">inc <span class="ot">(</span>x ‚à∑ []<span class="ot">)</span> <span class="ot">=</span> <span class="dv">0</span> ‚à∑ x ‚à∑ []</a>
<a class="sourceLine" id="cb17-4" data-line-number="4">inc <span class="ot">(</span>x‚ÇÅ ‚à∑ zero ‚à∑ xs<span class="ot">)</span> <span class="ot">=</span> suc x‚ÇÅ ‚à∑ xs</a>
<a class="sourceLine" id="cb17-5" data-line-number="5">inc <span class="ot">(</span>x‚ÇÅ ‚à∑ suc x‚ÇÇ ‚à∑ xs<span class="ot">)</span> <span class="ot">=</span> <span class="dv">0</span> ‚à∑ x‚ÇÅ ‚à∑ x‚ÇÇ ‚à∑ xs</a></code></pre></div>
</div>
</div>
<p>Unfortunately, though, we‚Äôve lost the other efficiencies! Addition and multiplication have no easy or direct encoding in this system, so we have to convert back and forth between this and regular binary to perform them.</p>
<h2 id="list-of-segments-binary">List-of-Segments-Binary</h2>
<p>The key problem with incrementing in the normal binary system is that it can cascade: when we hit a long string of 1s, all the 1s become 0 followed by a single 1. We can turn this problem to our advantage if we use a representation which encodes both 1s and 0s as strings of gaps. We‚Äôll have to use a couple more tricks to ensure a unique representation, but all in all this is what we have (switching to just Agda now):</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="kw">data</span> 0‚â§<span class="ot">_</span> <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2">  0‚ÇÇ  <span class="ot">:</span> 0‚â§ A</a>
<a class="sourceLine" id="cb18-3" data-line-number="3">  0&lt;<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">‚Üí</span> 0‚â§ A</a>
<a class="sourceLine" id="cb18-4" data-line-number="4"></a>
<a class="sourceLine" id="cb18-5" data-line-number="5"><span class="kw">mutual</span></a>
<a class="sourceLine" id="cb18-6" data-line-number="6">  <span class="kw">record</span> ùîπ‚ÇÄ <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-7" data-line-number="7">    <span class="kw">constructor</span> <span class="ot">_</span>0&amp;<span class="ot">_</span></a>
<a class="sourceLine" id="cb18-8" data-line-number="8">    <span class="kw">inductive</span></a>
<a class="sourceLine" id="cb18-9" data-line-number="9">    <span class="kw">field</span></a>
<a class="sourceLine" id="cb18-10" data-line-number="10">      H‚ÇÄ <span class="ot">:</span> ‚Ñï</a>
<a class="sourceLine" id="cb18-11" data-line-number="11">      T‚ÇÄ <span class="ot">:</span> ùîπ‚ÇÅ</a>
<a class="sourceLine" id="cb18-12" data-line-number="12"></a>
<a class="sourceLine" id="cb18-13" data-line-number="13">  <span class="kw">record</span> ùîπ‚ÇÅ <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-14" data-line-number="14">    <span class="kw">constructor</span> <span class="ot">_</span>1&amp;<span class="ot">_</span></a>
<a class="sourceLine" id="cb18-15" data-line-number="15">    <span class="kw">inductive</span></a>
<a class="sourceLine" id="cb18-16" data-line-number="16">    <span class="kw">field</span></a>
<a class="sourceLine" id="cb18-17" data-line-number="17">      H‚ÇÅ <span class="ot">:</span> ‚Ñï</a>
<a class="sourceLine" id="cb18-18" data-line-number="18">      T‚ÇÅ <span class="ot">:</span> 0‚â§  ùîπ‚ÇÄ</a>
<a class="sourceLine" id="cb18-19" data-line-number="19"><span class="kw">open</span> ùîπ‚ÇÄ <span class="kw">public</span></a>
<a class="sourceLine" id="cb18-20" data-line-number="20"><span class="kw">open</span> ùîπ‚ÇÅ <span class="kw">public</span></a>
<a class="sourceLine" id="cb18-21" data-line-number="21"></a>
<a class="sourceLine" id="cb18-22" data-line-number="22"><span class="kw">data</span> ùîπ‚Å∫ <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-23" data-line-number="23">  B‚ÇÄ<span class="ot">_</span> <span class="ot">:</span> ùîπ‚ÇÄ <span class="ot">‚Üí</span> ùîπ‚Å∫</a>
<a class="sourceLine" id="cb18-24" data-line-number="24">  B‚ÇÅ<span class="ot">_</span> <span class="ot">:</span> ùîπ‚ÇÅ <span class="ot">‚Üí</span> ùîπ‚Å∫</a>
<a class="sourceLine" id="cb18-25" data-line-number="25"></a>
<a class="sourceLine" id="cb18-26" data-line-number="26">ùîπ <span class="ot">:</span> <span class="dt">Set</span></a>
<a class="sourceLine" id="cb18-27" data-line-number="27">ùîπ <span class="ot">=</span> 0‚â§ ùîπ‚Å∫</a>
<a class="sourceLine" id="cb18-28" data-line-number="28"></a>
<a class="sourceLine" id="cb18-29" data-line-number="29">inc‚Å∫ <span class="ot">:</span> ùîπ <span class="ot">‚Üí</span> ùîπ‚Å∫</a>
<a class="sourceLine" id="cb18-30" data-line-number="30">inc‚Å∫ 0‚ÇÇ                               <span class="ot">=</span>      B‚ÇÅ <span class="dv">0</span>     1&amp; 0‚ÇÇ</a>
<a class="sourceLine" id="cb18-31" data-line-number="31">inc‚Å∫ <span class="ot">(</span>0&lt; B‚ÇÄ zero  0&amp; y 1&amp; xs        <span class="ot">)</span> <span class="ot">=</span>      B‚ÇÅ suc y 1&amp; xs</a>
<a class="sourceLine" id="cb18-32" data-line-number="32">inc‚Å∫ <span class="ot">(</span>0&lt; B‚ÇÄ suc x 0&amp; y 1&amp; xs        <span class="ot">)</span> <span class="ot">=</span>      B‚ÇÅ <span class="dv">0</span>     1&amp; 0&lt; x 0&amp; y 1&amp; xs</a>
<a class="sourceLine" id="cb18-33" data-line-number="33">inc‚Å∫ <span class="ot">(</span>0&lt; B‚ÇÅ x 1&amp; 0‚ÇÇ                 <span class="ot">)</span> <span class="ot">=</span> B‚ÇÄ x 0&amp; <span class="dv">0</span>     1&amp; 0‚ÇÇ</a>
<a class="sourceLine" id="cb18-34" data-line-number="34">inc‚Å∫ <span class="ot">(</span>0&lt; B‚ÇÅ x 1&amp; 0&lt; zero  0&amp; z 1&amp; xs<span class="ot">)</span> <span class="ot">=</span> B‚ÇÄ x 0&amp; suc z 1&amp; xs</a>
<a class="sourceLine" id="cb18-35" data-line-number="35">inc‚Å∫ <span class="ot">(</span>0&lt; B‚ÇÅ x 1&amp; 0&lt; suc y 0&amp; z 1&amp; xs<span class="ot">)</span> <span class="ot">=</span> B‚ÇÄ x 0&amp; <span class="dv">0</span>     1&amp; 0&lt; y 0&amp; z 1&amp; xs</a>
<a class="sourceLine" id="cb18-36" data-line-number="36"></a>
<a class="sourceLine" id="cb18-37" data-line-number="37">inc <span class="ot">:</span> ùîπ <span class="ot">‚Üí</span> ùîπ</a>
<a class="sourceLine" id="cb18-38" data-line-number="38">inc x <span class="ot">=</span> 0&lt; inc‚Å∫ x</a></code></pre></div>
<p>Perfect! Increments are obviously <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math>, and we‚Äôve guaranteed a unique representation.</p>
<p>I‚Äôve been working on this type for a couple of days, and you can see my code <a href="https://github.com/oisdk/agda-binary/">here</a>. So far, I‚Äôve done the following:</p>
<dl>
<dt>Defined <code>inc</code>, addition, and multiplication</dt>
<dd><p>These were a little tricky to get right (<a href="https://github.com/oisdk/agda-binary/blob/master/Data/Binary/Operations/Addition.agda#L9">addition is particularly hairy</a>), but they‚Äôre all there, and maximally lazy.</p>
</dd>
<dt>Proved Homomorphism</dt>
<dd><p>For each one of the functions, you want them to correspond precisely to the equivalent functions on Peano numbers. Proving that fact amounts to filling in definitions for the following:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb19-1" data-line-number="1">inc-homo <span class="ot">:</span> <span class="ot">‚àÄ</span> x <span class="ot">‚Üí</span> ‚ü¶ inc x ‚áì‚üß ‚â° suc ‚ü¶ x ‚áì‚üß</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">+-homo <span class="ot">:</span> <span class="ot">‚àÄ</span> x y <span class="ot">‚Üí</span> ‚ü¶ x + y ‚áì‚üß ‚â° ‚ü¶ x ‚áì‚üß + ‚ü¶ y ‚áì‚üß</a>
<a class="sourceLine" id="cb19-3" data-line-number="3">*-homo <span class="ot">:</span> <span class="ot">‚àÄ</span> x y <span class="ot">‚Üí</span> ‚ü¶ x * y ‚áì‚üß ‚â° ‚ü¶ x ‚áì‚üß * ‚ü¶ y ‚áì‚üß</a></code></pre></div>
</dd>
<dt>Proved Bijection</dt>
<dd><p>As we went to so much trouble, it‚Äôs important to prove that these numbers form a one-to-one correspondence with the Peano numbers. As well as that, once done, we can use it to prove facts about the homomorphic functions above, by reusing any proofs about the same functions on Peano numbers. For instance, here is a proof of commutativity of addition:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb20-1" data-line-number="1">+-comm <span class="ot">:</span> <span class="ot">‚àÄ</span> x y <span class="ot">‚Üí</span> x + y ‚â° y + x</a>
<a class="sourceLine" id="cb20-2" data-line-number="2">+-comm x y <span class="ot">=</span> injective <span class="ot">(</span>+-homo x y ‚ü® trans ‚ü©</a>
<a class="sourceLine" id="cb20-3" data-line-number="3">                        ‚Ñï<span class="ot">.</span>+-comm ‚ü¶ x ‚áì‚üß ‚ü¶ y ‚áì‚üß ‚ü® trans ‚ü©</a>
<a class="sourceLine" id="cb20-4" data-line-number="4">                        sym <span class="ot">(</span>+-homo y x<span class="ot">))</span></a></code></pre></div>
</dd>
</dl>
<h1 id="applications">Applications</h1>
<p>So now that we have our nice number representation, what can we do with it? One use is as a general-purpose number type in Agda: it represents a good balance between speed and ‚Äúproofiness‚Äù, and Coq uses a similar type in its standard library.</p>
<p>There are other, more unusual uses of such a type, though.</p>
<h2 id="data-structures">Data Structures</h2>
<p>It‚Äôs a well-known technique to build a data structure out of some number representation <span class="citation" data-cites="hinze_numerical_1998">(Hinze <a href="#ref-hinze_numerical_1998">1998</a>)</span>: in fact, all of the representations above are explored in Okasaki <span class="citation" data-cites="okasaki_purely_1999">(<a href="#ref-okasaki_purely_1999">1999</a>, chap. 9.2)</span>.</p>
<h2 id="logic-programming">Logic Programming</h2>
<p>Logic programming languages like Prolog let us write programs in a backwards kind of way. We say what the output looks like, and the unifier will figure out the set of inputs that generates it.</p>
<p>In Haskell, we have a very rough approximation of a similar system: the list monad.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="ot">pyth ::</span> [(<span class="dt">Int</span>,<span class="dt">Int</span>,<span class="dt">Int</span>)]</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">pyth <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb21-3" data-line-number="3">  x <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>]</a>
<a class="sourceLine" id="cb21-4" data-line-number="4">  y <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>]</a>
<a class="sourceLine" id="cb21-5" data-line-number="5">  z <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>]</a>
<a class="sourceLine" id="cb21-6" data-line-number="6">  guard (x<span class="fu">*</span>x <span class="fu">+</span> y<span class="fu">*</span>y <span class="fu">==</span> z<span class="fu">*</span>z)</a>
<a class="sourceLine" id="cb21-7" data-line-number="7">  return (x,y,z)</a></code></pre></div>
<p>There are tons of inefficiencies in the above code: for us, though, we can look at one: the number representation. In the equation:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup><mo>=</mo><msup><mi>z</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">x^2 + y^2 = z^2</annotation></semantics></math></p>
<p>If we know that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math> are both odd, then <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math> must be even. If the calculation of the equation is expensive, this is precisely the kind of shortcut we‚Äôd want to take advantage of. Luckily, our binary numbers do just that: it is enough to scrutinise just the first bits of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math> in order to determine the first bit of the output.</p>
<p>After seeing that example, you may be thinking that lazy evaluation is a perfect fit for logic programming. You‚Äôre not alone! Curry <span class="citation" data-cites="Hanus16Curry">(Hanus (ed.) <a href="#ref-Hanus16Curry">2016</a>)</span> is a lazy, functional logic programming language, with a similar syntax to Haskell. It also uses lazy binary numbers to optimise testing.</p>
<h2 id="lazy-predicates">Lazy Predicates</h2>
<p>In order for queries to be performed efficiently on binary numbers, we will also need a way to describe lazy <em>predicates</em> on them. A lot of these predicates are more easily expressible on the list-of-bits representation above, so we‚Äôll be working with that representation for this bit. Not to worry, though: we can convert from the segmented representation into the list-of-bits, and <a href="https://github.com/oisdk/agda-binary/blob/fb89ba5ae3b2aa0cb95301da42c8dbf27048181b/Data/Binary/Bits.agda#L52">we can prove that the conversion is injective</a>:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb22-1" data-line-number="1">toBits-injective <span class="ot">:</span> <span class="ot">‚àÄ</span> xs ys <span class="ot">‚Üí</span> toBits xs ‚â° toBits ys <span class="ot">‚Üí</span> xs ‚â° ys</a></code></pre></div>
<p>Here‚Äôs the curious problem: since our binary numbers are expressed least-significant-bit-first, we have to go to the end before knowing which is bigger. Luckily, we can use one of my favourite Haskell tricks, involving the ordering monoid:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="kw">data</span> Ordering <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-2" data-line-number="2">  lt eq gt <span class="ot">:</span> Ordering</a>
<a class="sourceLine" id="cb23-3" data-line-number="3"></a>
<a class="sourceLine" id="cb23-4" data-line-number="4"><span class="ot">_</span>‚àô<span class="ot">_</span> <span class="ot">:</span> Ordering <span class="ot">‚Üí</span> Ordering <span class="ot">‚Üí</span> Ordering</a>
<a class="sourceLine" id="cb23-5" data-line-number="5">lt ‚àô y <span class="ot">=</span> lt</a>
<a class="sourceLine" id="cb23-6" data-line-number="6">eq ‚àô y <span class="ot">=</span> y</a>
<a class="sourceLine" id="cb23-7" data-line-number="7">gt ‚àô y <span class="ot">=</span> gt</a>
<a class="sourceLine" id="cb23-8" data-line-number="8"></a>
<a class="sourceLine" id="cb23-9" data-line-number="9">cmpBit <span class="ot">:</span> Bit <span class="ot">‚Üí</span> Bit <span class="ot">‚Üí</span> Ordering</a>
<a class="sourceLine" id="cb23-10" data-line-number="10">cmpBit O O <span class="ot">=</span> eq</a>
<a class="sourceLine" id="cb23-11" data-line-number="11">cmpBit O I <span class="ot">=</span> lt</a>
<a class="sourceLine" id="cb23-12" data-line-number="12">cmpBit I O <span class="ot">=</span> gt</a>
<a class="sourceLine" id="cb23-13" data-line-number="13">cmpBit I I <span class="ot">=</span> eq</a>
<a class="sourceLine" id="cb23-14" data-line-number="14"></a>
<a class="sourceLine" id="cb23-15" data-line-number="15">compare <span class="ot">:</span> Bits <span class="ot">‚Üí</span> Bits <span class="ot">‚Üí</span> Ordering</a>
<a class="sourceLine" id="cb23-16" data-line-number="16">compare [] [] <span class="ot">=</span> eq</a>
<a class="sourceLine" id="cb23-17" data-line-number="17">compare [] <span class="ot">(_</span> ‚à∑ <span class="ot">_)</span> <span class="ot">=</span> lt</a>
<a class="sourceLine" id="cb23-18" data-line-number="18">compare <span class="ot">(_</span> ‚à∑ <span class="ot">_)</span> [] <span class="ot">=</span> gt</a>
<a class="sourceLine" id="cb23-19" data-line-number="19">compare <span class="ot">(</span>x ‚à∑ xs<span class="ot">)</span> <span class="ot">(</span>y ‚à∑ ys<span class="ot">)</span> <span class="ot">=</span> compare xs ys ‚àô cmpBit x y</a></code></pre></div>
<p>Thanks to laziness, this function first compares the length of the lists, and then does a lexicographical comparison in reverse only if the lengths are the same. This is exactly what we want for our numbers.</p>
<h1 id="future-posts">Future Posts</h1>
<p>That‚Äôs all I have for now, but I‚Äôm interested to formalise the laziness of these numbers in Agda. Usually that‚Äôs done with coinduction: I would also like to see the relationship with exact real arithmetic.</p>
<p>I wonder if it can be combined with <span class="citation" data-cites="oconnor_applications_2016">O‚ÄôConnor (<a href="#ref-oconnor_applications_2016">2016</a>)</span> to get some efficient proof search algorithms, or with <span class="citation" data-cites="escardo_seemingly_2014">Escardo (<a href="#ref-escardo_seemingly_2014">2014</a>)</span> to get more efficient exhaustive search.</p>
<h1 id="references" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-escardo_seemingly_2014">
<p>Escardo, Martin. 2014. ‚ÄúSeemingly impossible constructive proofs | Mathematics and Computation.‚Äù <em>Mathematics and Computation</em>. <a href="http://math.andrej.com/2014/05/08/seemingly-impossible-proofs/" class="uri">http://math.andrej.com/2014/05/08/seemingly-impossible-proofs/</a>.</p>
</div>
<div id="ref-Hanus16Curry">
<p>Hanus (ed.), M. 2016. <em>Curry: An Integrated Functional Logic Language (Vers. 0.9.0)</em>. Available at http://www.curry-language.org. <a href="https://www-ps.informatik.uni-kiel.de/currywiki/" class="uri">https://www-ps.informatik.uni-kiel.de/currywiki/</a>.</p>
</div>
<div id="ref-hinze_numerical_1998">
<p>Hinze, Ralf. 1998. <em>Numerical Representations as Higher-Order Nested Datatypes</em>. Institut f√ºr Informatik III, Universit√§t Bonn. <a href="http://www.cs.ox.ac.uk/ralf.hinze/publications/\#R5" class="uri">http://www.cs.ox.ac.uk/ralf.hinze/publications/\#R5</a>.</p>
</div>
<div id="ref-oconnor_applications_2016">
<p>O‚ÄôConnor, Liam. 2016. ‚ÄúApplications of Applicative Proof Search.‚Äù In <em>Proceedings of the 1st International Workshop on Type-Driven Development</em>, 43‚Äì55. TyDe 2016. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/2976022.2976030">10.1145/2976022.2976030</a>. <a href="http://doi.acm.org/10.1145/2976022.2976030" class="uri">http://doi.acm.org/10.1145/2976022.2976030</a>.</p>
</div>
<div id="ref-okasaki_purely_1999">
<p>Okasaki, Chris. 1999. <em>Purely Functional Data Structures</em>. Cambridge University Press.</p>
</div>
</div>
]]></description>
    <pubDate>Thu, 21 Mar 2019 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2019-03-21-binary-logic-search.html</guid>
    <dc:creator>Donnacha Ois√≠n Kidney</dc:creator>
</item>
<item>
    <title>More Agda Tips</title>
    <link>https://doisinkidney.com/posts/2019-03-14-more-agda-tips.html</link>
    <description><![CDATA[<div class="info">
    Posted on March 14, 2019
</div>
<div class="info">
    
        Part 2 of a <a href="/series/Agda%20Tips.html">2-part series on Agda Tips</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Agda.html">Agda</a>
    
</div>

<h1 id="literate-agda">Literate Agda</h1>
<p>For including Agda code in LaTeX files, Agda‚Äôs built-in literate programming support is a great tool. It typesets code well, and ensures that it typechecks which can help avoid typos.</p>
<h3 id="embedding-agda-code-in-latex">Embedding Agda Code in LaTeX</h3>
<p>I write the LaTeX document in one file, and the Agda code in another <code>.lagda</code> file. Using the <a href="https://ctan.org/pkg/catchfilebetweentags?lang=en">catchfilebetweentags</a> LaTeX package, I can then embed snippets of the Agda code into the LaTeX document. For instance, in a file named <code>Lists.lagda</code> I can have the following:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb1-1" data-line-number="1">%&lt;*head-type&gt;</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="ot">\</span>begin<span class="ot">{</span>code<span class="ot">}</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">head <span class="ot">:</span> List A <span class="ot">‚Üí</span> Maybe A</a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="ot">\</span>end<span class="ot">{</span>code<span class="ot">}</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5">%&lt;/head-type&gt;</a>
<a class="sourceLine" id="cb1-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="ot">\</span>begin<span class="ot">{</span>code<span class="ot">}</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">head [] <span class="ot">=</span> nothing</a>
<a class="sourceLine" id="cb1-9" data-line-number="9">head <span class="ot">(</span>x ‚à∑ xs<span class="ot">)</span> <span class="ot">=</span> just x</a>
<a class="sourceLine" id="cb1-10" data-line-number="10"><span class="ot">\</span>end<span class="ot">{</span>code<span class="ot">}</span></a></code></pre></div>
<p>Then, after compiling the Agda file with <code>agda --latex --output-dir=. Lists.lagda</code>, I can embed the snippet <code>head : List A ‚Üí Maybe A</code> into the TeX file like so:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode latex"><code class="sourceCode latex"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="fu">\ExecuteMetaData</span>[Lists.tex]{head-type}</a></code></pre></div>
<h3 id="dealing-with-unicode">Dealing with Unicode</h3>
<p>Most Agda source code will be Unicode-heavy, which doesn‚Äôt work well in LaTeX. There are a few different ways to deal with this: you could use XeTeX, which handles Unicode better, for instance. I found it easier to use the <a href="https://ctan.org/pkg/ucs?lang=en">ucs</a> package, and write a declaration for each Unicode character as I came across it. For the <code>‚à∑</code> character above, for instance, you can write:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode latex"><code class="sourceCode latex"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="bu">\usepackage</span>{<span class="ex">ucs</span>}</a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="fu">\DeclareUnicodeCharacter</span>{8759}{<span class="ss">\ensuremath{</span><span class="sc">\squaredots</span><span class="ss">}</span>}</a></code></pre></div>
<h3 id="live-reloading">Live Reloading</h3>
<p>For plain LaTeX code, I use <a href="http://spacemacs.org/">Spacemacs</a> and <a href="https://skim-app.sourceforge.io/">Skim</a> to get live reloading. When I save the LaTeX source code, the Skim window refreshes and jumps to the point my editing cursor is at. I use elisp code from <a href="https://mssun.me/blog/spacemacs-and-latex.html">this</a> blog post.</p>
<p>For Agda code, live reloading gets a little trickier. If I edit an Agda source file, the LaTeX won‚Äôt automatically recompile it. However, based on <a href="https://tex.stackexchange.com/questions/142540/configuring-latexmk-to-use-a-preprocessor-lhs2tex">this</a> stack exchange answer, you can put the following <code>.latexmkrc</code> file in the same directory as your <code>.lagda</code> files and your <code>.tex</code> file:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode perl"><code class="sourceCode perl"><a class="sourceLine" id="cb4-1" data-line-number="1">add_cus_dep(<span class="kw">&#39;</span><span class="st">lagda</span><span class="kw">&#39;</span>,<span class="kw">&#39;</span><span class="st">tex</span><span class="kw">&#39;</span>,<span class="dv">0</span>,<span class="kw">&#39;</span><span class="st">lagda2tex</span><span class="kw">&#39;</span>);</a>
<a class="sourceLine" id="cb4-2" data-line-number="2"></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="kw">sub </span><span class="fu">lagda2tex</span> {</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">    <span class="kw">my</span> <span class="dt">$base</span> = <span class="fu">shift</span> <span class="dt">@_</span>;</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">    <span class="kw">return</span> <span class="fu">system</span>(<span class="kw">&#39;</span><span class="st">agda</span><span class="kw">&#39;</span>, <span class="kw">&#39;</span><span class="st">--latex</span><span class="kw">&#39;</span>, <span class="kw">&#39;</span><span class="st">--latex-dir=.</span><span class="kw">&#39;</span>, <span class="kw">&quot;</span><span class="dt">$base</span><span class="st">.lagda</span><span class="kw">&quot;</span>);</a>
<a class="sourceLine" id="cb4-6" data-line-number="6">}</a></code></pre></div>
<p>This will recompile the literate Agda files whenever they‚Äôre changed. Unfortunately, it doesn‚Äôt automate it the <em>first</em> time you do it: it needs to see the <code>.tex</code> files to see the dependency. You can fix this yourself, by running <code>agda --latex --output-dir=.</code> when you add a new <code>.lagda</code> file (just once, after that the automation will take over), or you can use a script like the following:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="co">#!/bin/bash</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="fu">find</span> . -type f -name <span class="st">&#39;*.lagda&#39;</span> <span class="kw">|</span> <span class="kw">while</span> <span class="bu">read</span> -r <span class="va">code</span> ; <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">    <span class="va">dir=$(</span><span class="fu">dirname</span> <span class="st">&quot;</span><span class="va">$code</span><span class="st">&quot;</span><span class="va">)</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">    <span class="va">file=$(</span><span class="fu">basename</span> <span class="st">&quot;</span><span class="va">$code</span><span class="st">&quot;</span> .lagda<span class="va">)</span>.tex</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">    <span class="kw">if</span><span class="bu"> [</span> <span class="ot">!</span> <span class="ot">-e</span> <span class="st">&quot;</span><span class="va">$dir</span><span class="st">/</span><span class="va">$file</span><span class="st">&quot;</span><span class="bu"> ]</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6">    <span class="kw">then</span></a>
<a class="sourceLine" id="cb5-7" data-line-number="7">        <span class="ex">agda</span> --latex --latex-dir=. <span class="st">&quot;</span><span class="va">$code</span><span class="st">&quot;</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8">    <span class="kw">fi</span></a>
<a class="sourceLine" id="cb5-9" data-line-number="9"><span class="kw">done</span></a></code></pre></div>
<p>This will compile any <code>.lagda</code> file it finds that <em>doesn‚Äôt</em> have a corresponding <code>.tex</code> file (so it won‚Äôt slow things down). Then call that script on the first line of your <code>.latexmkrc</code>, like so:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode perl"><code class="sourceCode perl"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="fu">system</span>(<span class="kw">&quot;</span><span class="st">bash ./init-missing-lagda.sh</span><span class="kw">&quot;</span>);</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">add_cus_dep(<span class="kw">&#39;</span><span class="st">lagda</span><span class="kw">&#39;</span>,<span class="kw">&#39;</span><span class="st">tex</span><span class="kw">&#39;</span>,<span class="dv">0</span>,<span class="kw">&#39;</span><span class="st">lagda2tex</span><span class="kw">&#39;</span>);</a>
<a class="sourceLine" id="cb6-3" data-line-number="3"></a>
<a class="sourceLine" id="cb6-4" data-line-number="4"><span class="kw">sub </span><span class="fu">lagda2tex</span> {</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">    <span class="kw">my</span> <span class="dt">$base</span> = <span class="fu">shift</span> <span class="dt">@_</span>;</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">    <span class="kw">return</span> <span class="fu">system</span>(<span class="kw">&#39;</span><span class="st">agda</span><span class="kw">&#39;</span>, <span class="kw">&#39;</span><span class="st">--latex</span><span class="kw">&#39;</span>, <span class="kw">&#39;</span><span class="st">--latex-dir=.</span><span class="kw">&#39;</span>, <span class="kw">&quot;</span><span class="dt">$base</span><span class="st">.lagda</span><span class="kw">&quot;</span>);</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">}</a></code></pre></div>
<h1 id="flags-for-debugging">Flags for Debugging</h1>
<p>There are a number of undocumented flags you can pass to Agda which are absolutely invaluable when it comes to debugging. One of them <a href="http://oleg.fi/gists/posts/2018-08-29-agda-termination-checker.html">can tell you more about termination checking</a>, another reports on type checking (<code>tc</code>), another for profiling (<code>profile</code>), and so on. Set the verbosity level (<code>agda -v 100</code>) to get more or less info.</p>
<h1 id="type-checking-order">Type Checking Order</h1>
<p>Agda does type checking from left to right. This isn‚Äôt always desired: as an example, if we want to annotate a value with its type, we can use the following function:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb7-1" data-line-number="1">the <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">)</span> <span class="ot">‚Üí</span> A <span class="ot">‚Üí</span> A</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">the <span class="ot">_</span> x <span class="ot">=</span> x</a>
<a class="sourceLine" id="cb7-3" data-line-number="3"></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">example <span class="ot">:</span> <span class="ot">_</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5">example <span class="ot">=</span> the ‚Ñï <span class="dv">3</span></a></code></pre></div>
<p>Coming from Haskell, though, this is the wrong way around. We usually prefer to write something like <code>3 :: Int</code>. We can‚Äôt write that as a simple function in Agda, though, so we instead use a syntax declaration:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">syntax</span> the ty x <span class="ot">=</span> x ‚à∑ ty</a>
<a class="sourceLine" id="cb8-2" data-line-number="2"></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">example <span class="ot">:</span> <span class="ot">_</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">example <span class="ot">=</span> <span class="dv">3</span> ‚à∑ ‚Ñï</a></code></pre></div>
<p>Changing the order of type checking can also <a href="https://github.com/agda/agda-stdlib/issues/622#issue-411010875">speed up typechecking in some cases</a>. There‚Äôs more information about syntax declarations in <a href="https://agda.readthedocs.io/en/latest/language/syntax-declarations.html">Agda‚Äôs documentation</a>.</p>
]]></description>
    <pubDate>Thu, 14 Mar 2019 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2019-03-14-more-agda-tips.html</guid>
    <dc:creator>Donnacha Ois√≠n Kidney</dc:creator>
</item>
<item>
    <title>Finger Trees in Agda</title>
    <link>https://doisinkidney.com/posts/2019-02-25-agda-fingertrees.html</link>
    <description><![CDATA[<div class="info">
    Posted on February 25, 2019
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Agda.html">Agda</a>
    
</div>

<hr />
<h2 id="this-post-is-available-with-clickable-code-here"><a href="https://oisdk.github.io/agda-indexed-fingertree/Data.FingerTree.html">This Post is Available With Clickable Code Here</a></h2>
<p>This whole post is written with clickable identifiers and ascii art at the above link. I also provide the normal version below in case there are any problems rendering.</p>
<hr />
<p>As I have talked about <a href="/posts/2019-01-15-binomial-urn.html">previously</a>, a large class of divide-and conquer algorithms rely on ‚Äúgood‚Äù partitioning for the divide step. If you then want to make the algorithms incremental, you keep all of those partitions (with their summaries) in some ‚Äúgood‚Äù arrangement <span class="citation" data-cites="mu_queueing_2016">(Mu, Chiang, and Lyu <a href="#ref-mu_queueing_2016">2016</a>)</span>. Several common data structures are designed around this principle: binomial heaps, for instance, store partitions of size <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mi>n</mi></msup><annotation encoding="application/x-tex">2^n</annotation></semantics></math>. Different ways of storing partitions favours different use cases: switch from a binomial heap to a skew binomial, for instance, and you get constant-time <code>cons</code>.</p>
<p>The standout data structure in this area is Hinze and Paterson‚Äôs finger tree <span class="citation" data-cites="Hinze-Paterson:FingerTree">(Hinze and Paterson <a href="#ref-Hinze-Paterson:FingerTree">2006</a>)</span>. It caches summaries in a pretty amazing way, allowing for (amortised) <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math> <code>cons</code> and <code>snoc</code> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math> <code>split</code> and <code>append</code>. These features allow it to be used for a huge variety of things: <a href="http://hackage.haskell.org/package/containers-0.6.0.1/docs/Data-Sequence.html">Data.Sequence</a> uses it as a random-access sequence, but it can also work as a priority queue, a search tree, a priority search tree <span class="citation" data-cites="hinze_simple_2001">(Hinze <a href="#ref-hinze_simple_2001">2001</a>)</span>, an interval tree, an order statistic tree‚Ä¶</p>
<p>All of these applications solely rely on an underlying monoid. As a result, I thought it would be a great data structure to implement in Agda, so that you‚Äôd get all of the other data structures with minimal effort <span class="citation" data-cites="sozeau_program-ing_2007">(similar thinking motivated a Coq implementation; Sozeau <a href="#ref-sozeau_program-ing_2007">2007</a>)</span>.</p>
<h1 id="scope-of-the-verification">Scope of the Verification</h1>
<p>There would be no real point to implementing a finger tree in Agda if we didn‚Äôt also prove some things about it. The scope of the proofs I‚Äôve done so far are intrinsic proofs of the summaries in the tree. In other words, the type of <code>cons</code> is as follows:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb1-1" data-line-number="1">cons <span class="ot">:</span> <span class="ot">‚àÄ</span> x <span class="ot">{</span>xs<span class="ot">}</span> <span class="ot">‚Üí</span> Tree xs <span class="ot">‚Üí</span> Tree <span class="ot">(</span>Œº x ‚àô xs<span class="ot">)</span></a></code></pre></div>
<p>This is enough to prove things about the derived data structures (like the correctness of sorting if it‚Äôs used as a priority queue), but it‚Äôs worth pointing out what I <em>haven‚Äôt</em> proved (yet):</p>
<ol>
<li>Invariants on the structure (‚Äúsafe‚Äù and ‚Äúunsafe‚Äù digits and so on).</li>
<li>The time complexity or performance of any operations.</li>
</ol>
<p>To be honest, I‚Äôm not even sure that my current implementation is correct in these regards! I‚Äôll probably have a go at proving them in the future <span class="citation" data-cites="danielsson_lightweight_2008">(possibly using Danielsson <a href="#ref-danielsson_lightweight_2008">2008</a>)</span>.</p>
<h1 id="monoids-and-proofs">Monoids and Proofs</h1>
<p>The bad news is that finger trees are a relatively complex data structure, and we‚Äôre going to need a <em>lot</em> of proofs to write a verified version. The good news is that monoids (in contrast to rings) are extremely easy to prove automatically. In this project, I used reflection to do so, but I think it should be possible to do with instance resolution also.</p>
<h1 id="measures">Measures</h1>
<p>First things first, we need a way to talk about the summaries of elements we‚Äôre interested in. This is captured by the following record type:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">record</span> œÉ <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">(</span>Œ£ <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">(</span>a ‚äî r<span class="ot">)</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  <span class="kw">field</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">    Œº <span class="ot">:</span> Œ£ <span class="ot">‚Üí</span> ùì°</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">    </a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="kw">open</span> œÉ ‚¶É <span class="ot">...</span> ‚¶Ñ</a></code></pre></div>
<p><code>ùì°</code> is the type of the summaries, and <code>Œº</code> means ‚Äúsummarise‚Äù. The silly symbols are used for brevity: we‚Äôre going to be using this thing everywhere, so it‚Äôs important to keep it short. Here‚Äôs an example instance for lists:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb3-1" data-line-number="1">instance</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  œÉ-List <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">{</span>Œ£ <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">‚Üí</span> ‚¶É <span class="ot">_</span> <span class="ot">:</span> œÉ Œ£ ‚¶Ñ <span class="ot">‚Üí</span> œÉ <span class="ot">(</span>List Œ£<span class="ot">)</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">  Œº ‚¶É œÉ-List ‚¶Ñ <span class="ot">=</span> List<span class="ot">.</span>foldr <span class="ot">(_</span>‚àô<span class="ot">_</span> ‚àò Œº<span class="ot">)</span> Œµ</a></code></pre></div>
<h1 id="working-with-setoids">Working With Setoids</h1>
<p>As I mentioned, the tree is going to be verified intrinsically. In other word its type will look something like this:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb4-1" data-line-number="1">Tree <span class="ot">:</span> ùì° <span class="ot">‚Üí</span> <span class="dt">Set</span></a></code></pre></div>
<p>But before running off to define that the obvious way, I should mention that I made the annoying decision to use a setoid (rather than propositional equality) based monoid. This means that we don‚Äôt get substitution, making the obvious definition untenable.</p>
<p>I figured out a solution to the problem, but I‚Äôm not sure if I‚Äôm happy with it. That‚Äôs actually the main motivation for writing this post: I‚Äôm curious if other people have better techniques for this kind of thing.</p>
<p>To clarify: ‚Äúthis kind of thing‚Äù is writing intrinsic (correct-by-construction) proofs when a setoid is involved. Intrinsic proofs usually lend themselves to elegance: to prove that <code>map</code> preserves a vector‚Äôs length, for instance, basically requires no proof at all:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb5-1" data-line-number="1">map <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>a b n<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">{</span>B <span class="ot">:</span> <span class="dt">Set</span> b<span class="ot">}</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">    <span class="ot">‚Üí</span> <span class="ot">(</span>A <span class="ot">‚Üí</span> B<span class="ot">)</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">    <span class="ot">‚Üí</span> Vec A n</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">    <span class="ot">‚Üí</span> Vec B n</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">map f [] <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">map f <span class="ot">(</span>x ‚à∑ xs<span class="ot">)</span> <span class="ot">=</span> f x ‚à∑ map f xs</a></code></pre></div>
<p>But that‚Äôs because pattern matching works well with propositional equality: in the first clause, <code>n</code> is set to <code>0</code> automatically. If we were working with setoid equality, we‚Äôd instead maybe get a proof that <code>n ‚âà 0</code>, and we‚Äôd have to figure a way to work that into the types.</p>
<h1 id="fibres">Fibres</h1>
<p>The first part of the solution is to define a wrapper type which stores information about the size of the thing it contains:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">record</span> Œº‚ü®<span class="ot">_</span>‚ü©‚âà<span class="ot">_</span> <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">(</span>Œ£ <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">)</span> ‚¶É <span class="ot">_</span> <span class="ot">:</span> œÉ Œ£ ‚¶Ñ <span class="ot">(</span>ùìÇ <span class="ot">:</span> ùì°<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">(</span>a ‚äî r ‚äî m<span class="ot">)</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  <span class="kw">constructor</span> <span class="ot">_</span>‚áë[<span class="ot">_</span>]</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  <span class="kw">field</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">    ùì¢ <span class="ot">:</span> Œ£</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">    ùíª <span class="ot">:</span> Œº ùì¢ ‚âà ùìÇ</a></code></pre></div>
<p>Technically speaking, I think this is known as a ‚Äúfibre‚Äù. <code>Œº‚ü® Œ£ ‚ü©‚âà ùìÇ</code> means ‚ÄúThere exists a <code>Œ£</code> such that <code>Œº Œ£ ‚âà ùìÇ</code>‚Äù. Next, we‚Äôll need some combinators to work with:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">infixl</span> <span class="dv">2</span> <span class="ot">_</span>‚âà[<span class="ot">_</span>]</a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="ot">_</span>‚âà[<span class="ot">_</span>] <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">{</span>Œ£ <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> ‚¶É <span class="ot">_</span> <span class="ot">:</span> œÉ Œ£ ‚¶Ñ <span class="ot">{</span>x <span class="ot">:</span> ùì°<span class="ot">}</span> <span class="ot">‚Üí</span> Œº‚ü® Œ£ ‚ü©‚âà x <span class="ot">‚Üí</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>y<span class="ot">}</span> <span class="ot">‚Üí</span> x ‚âà y <span class="ot">‚Üí</span> Œº‚ü® Œ£ ‚ü©‚âà y</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">ùì¢ <span class="ot">(</span>xs ‚âà[ y‚âàz ]<span class="ot">)</span> <span class="ot">=</span> ùì¢ xs</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">ùíª <span class="ot">(</span>xs ‚âà[ y‚âàz ]<span class="ot">)</span> <span class="ot">=</span> trans <span class="ot">(</span>ùíª xs<span class="ot">)</span> y‚âàz</a></code></pre></div>
<p>This makes it possible to ‚Äúrewrite‚Äù the summary, given a proof of equivalence.</p>
<h1 id="do-notation">Do Notation</h1>
<p>The wrapper on its own isn‚Äôt enough to save us from hundreds of lines of proofs. Once you do computation on its contents, you still need to join it up with its original proof of equivalence. In other words, you‚Äôll need to drill into the return type of a function, find the place you used the relevant type variable, and apply the relevant proof from the type above. This can really clutter proofs. Instead, we can use Agda‚Äôs new support for do notation to try and get a cleaner notation for everything. Here‚Äôs a big block of code:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">infixl</span> <span class="dv">2</span> arg-syntax</a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="kw">record</span> Arg <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">(</span>Œ£ <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">)</span> ‚¶É <span class="ot">_</span> <span class="ot">:</span> œÉ Œ£ ‚¶Ñ <span class="ot">(</span>ùìÇ <span class="ot">:</span> ùì°<span class="ot">)</span> <span class="ot">(</span>f <span class="ot">:</span> ùì° <span class="ot">‚Üí</span> ùì°<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">(</span>m ‚äî r ‚äî a<span class="ot">)</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  <span class="kw">constructor</span> arg-syntax</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">  <span class="kw">field</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5">    ‚ü®f‚ü© <span class="ot">:</span> Congruent‚ÇÅ f</a>
<a class="sourceLine" id="cb8-6" data-line-number="6">    arg <span class="ot">:</span> Œº‚ü® Œ£ ‚ü©‚âà ùìÇ</a>
<a class="sourceLine" id="cb8-7" data-line-number="7"><span class="kw">open</span> Arg</a>
<a class="sourceLine" id="cb8-8" data-line-number="8"></a>
<a class="sourceLine" id="cb8-9" data-line-number="9"><span class="kw">syntax</span> arg-syntax <span class="ot">(Œª</span> sz <span class="ot">‚Üí</span> e‚ÇÅ<span class="ot">)</span> xs <span class="ot">=</span> xs [ e‚ÇÅ ‚üø sz ]</a>
<a class="sourceLine" id="cb8-10" data-line-number="10"></a>
<a class="sourceLine" id="cb8-11" data-line-number="11"><span class="kw">infixl</span> <span class="dv">1</span> <span class="ot">_</span>&gt;&gt;=<span class="ot">_</span></a>
<a class="sourceLine" id="cb8-12" data-line-number="12"><span class="ot">_</span>&gt;&gt;=<span class="ot">_</span> <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>a b<span class="ot">}</span> <span class="ot">{</span>Œ£‚ÇÅ <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">{</span>Œ£‚ÇÇ <span class="ot">:</span> <span class="dt">Set</span> b<span class="ot">}</span> ‚¶É <span class="ot">_</span> <span class="ot">:</span> œÉ Œ£‚ÇÅ ‚¶Ñ ‚¶É <span class="ot">_</span> <span class="ot">:</span> œÉ Œ£‚ÇÇ ‚¶Ñ <span class="ot">{</span>ùìÇ f<span class="ot">}</span></a>
<a class="sourceLine" id="cb8-13" data-line-number="13">      <span class="ot">‚Üí</span> Arg Œ£‚ÇÅ ùìÇ f</a>
<a class="sourceLine" id="cb8-14" data-line-number="14">      <span class="ot">‚Üí</span> <span class="ot">((</span>x <span class="ot">:</span> Œ£‚ÇÅ<span class="ot">)</span> <span class="ot">‚Üí</span> ‚¶É x‚âà <span class="ot">:</span> Œº x ‚âà ùìÇ ‚¶Ñ <span class="ot">‚Üí</span> Œº‚ü® Œ£‚ÇÇ ‚ü©‚âà f <span class="ot">(</span>Œº x<span class="ot">))</span></a>
<a class="sourceLine" id="cb8-15" data-line-number="15">      <span class="ot">‚Üí</span> Œº‚ü® Œ£‚ÇÇ ‚ü©‚âà f ùìÇ</a>
<a class="sourceLine" id="cb8-16" data-line-number="16">arg-syntax cng xs &gt;&gt;= k <span class="ot">=</span> k <span class="ot">(</span>ùì¢ xs<span class="ot">)</span> ‚¶É ùíª xs ‚¶Ñ ‚âà[ cng <span class="ot">(</span>ùíª xs<span class="ot">)</span> ]</a></code></pre></div>
<p>First, we define a wrapper for types parameterised by their summary, with a way to lift an underlying equality up into some expression <code>f</code>. The <code>&gt;&gt;=</code> operator just connects up all of the relevant bits. An example is what‚Äôs needed:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb9-1" data-line-number="1">listToTree <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">{</span>Œ£ <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> ‚¶É <span class="ot">_</span> <span class="ot">:</span> œÉ Œ£ ‚¶Ñ <span class="ot">‚Üí</span> <span class="ot">(</span>xs <span class="ot">:</span> List Œ£<span class="ot">)</span> <span class="ot">‚Üí</span> Œº‚ü® Tree Œ£ ‚ü©‚âà Œº xs</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">listToTree [] <span class="ot">=</span> empty ‚áë</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">listToTree <span class="ot">(</span>x ‚à∑ xs<span class="ot">)</span> <span class="ot">=</span> [ ‚Ñ≥ ‚ÜØ ]‚âà do</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">  ys ‚Üê listToTree xs [ Œº x ‚àô&gt; s ‚üø s ]</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  x ‚óÇ ys</a></code></pre></div>
<p>The first line is the base case, nothing interesting going on there. The second line begins the do-notation, but first applies <code>[ ‚Ñ≥ ‚ÜØ ]‚âà</code>: this calls the automated solver. The second line makes the recursive call, and with the syntax:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb10-1" data-line-number="1">[ Œº x ‚àô&gt; s ‚üø s ]</a></code></pre></div>
<p>It tells us where the size of the bound variable will end up in the outer expression.</p>
<div id="refs" class="references">
<div id="ref-danielsson_lightweight_2008">
<p>Danielsson, Nils Anders. 2008. ‚ÄúLightweight Semiformal Time Complexity Analysis for Purely Functional Data Structures.‚Äù In <em>Proceedings of the 35th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</em>, 133‚Äì144. POPL ‚Äô08. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/1328438.1328457">10.1145/1328438.1328457</a>.</p>
</div>
<div id="ref-hinze_simple_2001">
<p>Hinze, Ralf. 2001. ‚ÄúA Simple Implementation Technique for Priority Search Queues.‚Äù In <em>Proceedings of the 2001 International Conference on Functional Programming</em>, 110‚Äì121. ACM Press. doi:<a href="https://doi.org/10.1145/507635.507650">10.1145/507635.507650</a>.</p>
</div>
<div id="ref-Hinze-Paterson:FingerTree">
<p>Hinze, Ralf, and Ross Paterson. 2006. ‚ÄúFinger Trees: A Simple General-purpose Data Structure.‚Äù <em>Journal of Functional Programming</em> 16 (2): 197‚Äì217.</p>
</div>
<div id="ref-mu_queueing_2016">
<p>Mu, Shin-Cheng, Yu-Hsi Chiang, and Yu-Han Lyu. 2016. ‚ÄúQueueing and Glueing for Optimal Partitioning (Functional Pearl).‚Äù In <em>Proceedings of the 21st ACM SIGPLAN International Conference on Functional Programming</em>, 158‚Äì167. ICFP 2016. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/2951913.2951923">10.1145/2951913.2951923</a>.</p>
</div>
<div id="ref-sozeau_program-ing_2007">
<p>Sozeau, Matthieu. 2007. ‚ÄúProgram-ing Finger Trees in Coq.‚Äù In <em>Proceedings of the 12th ACM SIGPLAN International Conference on Functional Programming</em>, 13‚Äì24. ICFP ‚Äô07. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/1291151.1291156">10.1145/1291151.1291156</a>.</p>
</div>
</div>
]]></description>
    <pubDate>Mon, 25 Feb 2019 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2019-02-25-agda-fingertrees.html</guid>
    <dc:creator>Donnacha Ois√≠n Kidney</dc:creator>
</item>
<item>
    <title>A New Ring Solver for Agda</title>
    <link>https://doisinkidney.com/posts/2019-01-25-agda-ring-solver.html</link>
    <description><![CDATA[<div class="info">
    Posted on January 25, 2019
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Agda.html">Agda</a>
    
</div>

<p>I‚Äôm finally a the point where I feel like I can make the project I‚Äôve been working on for the past few months public: <a href="https://oisdk.github.io/agda-ring-solver/README.html">A Ring Solver for Agda</a>. The focus of the project is ergonomics and ease-of-use: hopefully the interface to the solver is simpler and more friendly than the one that‚Äôs already there. It can do step-by-step solutions (like Wolfram Alpha). It‚Äôs also asymptotically faster than the old solver (and actually faster! The usual optimizations you might apply don‚Äôt actually work here, so this bit definitely took the most work).</p>
<p>Anyway, this work is all for my undergrad final year project, but I‚Äôm hoping to submit it to a conference or something in the next few weeks.</p>
]]></description>
    <pubDate>Fri, 25 Jan 2019 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2019-01-25-agda-ring-solver.html</guid>
    <dc:creator>Donnacha Ois√≠n Kidney</dc:creator>
</item>
<item>
    <title>A Binomial Urn</title>
    <link>https://doisinkidney.com/posts/2019-01-15-binomial-urn.html</link>
    <description><![CDATA[<div class="info">
    Posted on January 15, 2019
</div>
<div class="info">
    
        Part 3 of a <a href="/series/Balanced%20Folds.html">3-part series on Balanced Folds</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<p>When we started the series, we wanted to find a ‚Äúbetter‚Äù fold: one that was more balanced than either <code>foldl</code> or <code>foldr</code> (in its placement of parentheses). Both of these are about as unbalanced as you can get:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> foldr (<span class="fu">+</span>) <span class="dv">0</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="dv">1</span> <span class="fu">+</span> (<span class="dv">2</span> <span class="fu">+</span> (<span class="dv">3</span> <span class="fu">+</span> <span class="dv">0</span>))</a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="fu">&gt;&gt;&gt;</span> foldl (<span class="fu">+</span>) <span class="dv">0</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">((<span class="dv">0</span> <span class="fu">+</span> <span class="dv">1</span>) <span class="fu">+</span> <span class="dv">2</span>) <span class="fu">+</span> <span class="dv">3</span></a></code></pre></div>
<p>The first better fold I found was Jon Fairbairn‚Äôs simple <code>treeFold</code>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">treeFold ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">treeFold f <span class="fu">=</span> go</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">    go x [] <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">    go a  (b<span class="fu">:</span>l) <span class="fu">=</span> go (f a b) (pairMap l)</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">    pairMap (x<span class="fu">:</span>y<span class="fu">:</span>rest) <span class="fu">=</span> f x y <span class="fu">:</span> pairMap rest</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">    pairMap xs <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">  </a>
<a class="sourceLine" id="cb2-9" data-line-number="9"><span class="fu">&gt;&gt;&gt;</span> treeFold (<span class="fu">+</span>) <span class="dv">0</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb2-10" data-line-number="10">(<span class="dv">0</span> <span class="fu">+</span> <span class="dv">1</span>) <span class="fu">+</span> (<span class="dv">2</span> <span class="fu">+</span> <span class="dv">3</span>)</a></code></pre></div>
<p>Already this function was kind of magical: if your binary operator merges two sorted lists, <code>foldr</code> will give you insertion sort, whereas <code>treeFold</code> will give you merge sort; for summing floats, <code>treeFold</code> has a lower error growth than <code>sum</code>. By dividing up the work better, we were able to improve the characteristics of many algorithms automatically. We also saw that it could easily be made parallel:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">parseq ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">parseq a b <span class="fu">=</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">    runST</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">        (bool (par a b) (seq a b) <span class="fu">&lt;$&gt;</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">         unsafeIOToST (liftA2 (<span class="fu">&gt;</span>) numSparks getNumCapabilities))</a>
<a class="sourceLine" id="cb3-6" data-line-number="6"></a>
<a class="sourceLine" id="cb3-7" data-line-number="7"><span class="ot">treeFoldParallel ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb3-8" data-line-number="8">treeFoldParallel f <span class="fu">=</span></a>
<a class="sourceLine" id="cb3-9" data-line-number="9">    treeFold</a>
<a class="sourceLine" id="cb3-10" data-line-number="10">        (\l r <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb3-11" data-line-number="11">              r <span class="ot">`parseq`</span> (l <span class="ot">`parseq`</span> f l r))</a></code></pre></div>
<p>In the next post, we saw how we could make the fold incremental, by using binary number representations for data structures. This let us do 2 things: it meant the fold was structurally terminating, so it would pass the termination checker (efficiently) in languages like Agda or Idris, and it meant we could write <code>scanl</code> using the fold. The <code>scanl</code> was also efficient: you could run the fold at any point in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math> time, and work would be shared between subsequent runs. Effectively, this let us use it to solve greedy optimization problems. We also saw how it was effectively constructing an implicit binomial priority queue under the hood, and how it exploited laziness to get sharing.</p>
<p>I‚Äôve gotten huge mileage out of this fold and the general ideas about it, and today I‚Äôm going to show one more use of it. We‚Äôre going to improve some of the asymptotics of the data structure presented in <span class="citation" data-cites="lampropoulos_ode_2017">Lampropoulos, Spector-Zabusky, and Foner (<a href="#ref-lampropoulos_ode_2017">2017</a>)</span>.</p>
<h1 id="a-random-urn">A Random Urn</h1>
<p>The paper opens with the problem:</p>
<blockquote>
<p>Suppose you have an urn containing two red balls, four green balls, and three blue balls. If you take three balls out of the urn, what is the probability that two of them are green?</p>
</blockquote>
<p>If you were to take just <em>one</em> ball out of the earn, calculating the associated probabilities would be easy. Once you get to the second, though, you have to update the previous probability <em>based on what ball was removed</em>. In other words, we need to be able to dynamically update the distribution.</p>
<p>Using lists, this would obviously become an <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n)</annotation></semantics></math> operation. In the paper, an almost-perfect binary tree is used. This turns the operation into one that‚Äôs <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math>. The rest of the operations have the following complexities:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Operation</th>
<th>Complexity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>insert</code></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>remove</code></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>fromList</code></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n)</annotation></semantics></math></td>
</tr>
</tbody>
</table>
<p>As a quick spoiler, the improved version presented here has these complexities:</p>
<table>
<thead>
<tr class="header">
<th>Operation</th>
<th>Complexity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>insert</code></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math></td>
</tr>
<tr class="even">
<td><code>remove</code></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math></td>
</tr>
<tr class="odd">
<td><code>merge</code></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math></td>
</tr>
<tr class="even">
<td><code>fromList</code></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n)</annotation></semantics></math></td>
</tr>
</tbody>
</table>
<p>We add another operation (<code>merge</code>), which means that the new structure is viable as an instance of <code>Alternative</code>, <code>Monad</code>, and so on, making it an efficient monad for weighted backtracking search.</p>
<h1 id="priority-queues">Priority Queues</h1>
<p>The key thing to notice in the paper which will let us improve the structure is that what they‚Äôre designing is actually a <em>priority queue</em>. Well, a weird looking priority queue, but a priority queue nonetheless.</p>
<p>Think about it like a max-priority queue (pop returns the largest element first), with a degree of ‚Äúrandomization‚Äù. In other words, when you go to do a pop, all of the comparisons between the ordering keys (the weights in this case) sprinkles some randomness into the equation, meaning that instead of <code>1 &lt; 2</code> returning <code>True</code>, it returns <code>True</code> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mn>2</mn><mn>3</mn></mfrac><annotation encoding="application/x-tex">\frac{2}{3}</annotation></semantics></math> of the time, and <code>False</code> the other <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mn>1</mn><mn>3</mn></mfrac><annotation encoding="application/x-tex">\frac{1}{3}</annotation></semantics></math>.</p>
<p>This way of doing things means that not every priority queue is suitable: we want to run comparisons at <code>pop</code> time (not <code>insert</code>), so a binary heap (for instance) won‚Äôt do. At branches (non-leaves), the queue will only be allowed store <em>summaries</em> of the data, not the ‚Äúmax element‚Äù.</p>
<p>The one presented in the paper is something like a Braun priority queue: the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n)</annotation></semantics></math> <code>fromList</code> implementation is reminiscent of the one in <span class="citation" data-cites="okasaki_three_1997">Okasaki (<a href="#ref-okasaki_three_1997">1997</a>)</span>.</p>
<p>So what priority queue can we choose to get us the desired efficiency? Why, a binomial one of course!</p>
<h1 id="the-data-structure">The Data Structure</h1>
<p>The urn structure itself looks a lot like a binomial heap:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">Tree</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  {<span class="ot"> weight ::</span> <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">Word</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">  ,<span class="ot"> branch ::</span> <span class="dt">Node</span> a</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">  }</a>
<a class="sourceLine" id="cb4-6" data-line-number="6"></a>
<a class="sourceLine" id="cb4-7" data-line-number="7"><span class="kw">data</span> <span class="dt">Node</span> a</a>
<a class="sourceLine" id="cb4-8" data-line-number="8">  <span class="fu">=</span> <span class="dt">Leaf</span> a</a>
<a class="sourceLine" id="cb4-9" data-line-number="9">  <span class="fu">|</span> <span class="dt">Branch</span> (<span class="dt">Tree</span> a) (<span class="dt">Node</span> a)</a>
<a class="sourceLine" id="cb4-10" data-line-number="10"></a>
<a class="sourceLine" id="cb4-11" data-line-number="11"><span class="kw">data</span> <span class="dt">Heap</span> a</a>
<a class="sourceLine" id="cb4-12" data-line-number="12">  <span class="fu">=</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb4-13" data-line-number="13">  <span class="fu">|</span> <span class="dt">Cons</span> <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">Word</span> (<span class="dt">Tree</span> a) (<span class="dt">Heap</span> a)</a>
<a class="sourceLine" id="cb4-14" data-line-number="14">  </a>
<a class="sourceLine" id="cb4-15" data-line-number="15"><span class="kw">data</span> <span class="dt">Urn</span> a <span class="fu">=</span></a>
<a class="sourceLine" id="cb4-16" data-line-number="16">    <span class="dt">Urn</span> <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">Word</span></a>
<a class="sourceLine" id="cb4-17" data-line-number="17">        <span class="fu">!</span>(<span class="dt">Heap</span> a)</a></code></pre></div>
<p>By avoiding the usual <code>Skip</code> constructors you often see in a binomial heap we save a huge amount of space. Instead, we store the ‚Äúnumber of zeroes before this bit‚Äù. Another thing to point out is that only left branches in the trees store their weight: the same optimization is made in the paper.</p>
<p>Insertion is not much different from insertion for a usual binomial priority queue, although we don‚Äôt need to do anything to merge the trees:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">insertHeap ::</span> <span class="dt">Word</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Heap</span> a <span class="ot">-&gt;</span> <span class="dt">Heap</span> a</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">insertHeap i&#39; x&#39; <span class="fu">=</span> go <span class="dv">0</span> (<span class="dt">Tree</span> i&#39; (<span class="dt">Leaf</span> x&#39;))</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">    go <span class="fu">!</span>i x <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Cons</span> i x <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">    go <span class="fu">!</span>i x (<span class="dt">Cons</span> <span class="dv">0</span> y ys) <span class="fu">=</span> go (i<span class="fu">+</span><span class="dv">1</span>) (mergeTree x y) ys</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">    go <span class="fu">!</span>i x (<span class="dt">Cons</span> j y ys) <span class="fu">=</span> <span class="dt">Cons</span> i x (<span class="dt">Cons</span> (j<span class="fu">-</span><span class="dv">1</span>) y ys)</a>
<a class="sourceLine" id="cb5-7" data-line-number="7"></a>
<a class="sourceLine" id="cb5-8" data-line-number="8"><span class="ot">mergeTree ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb5-9" data-line-number="9">mergeTree xs ys <span class="fu">=</span></a>
<a class="sourceLine" id="cb5-10" data-line-number="10">  <span class="dt">Tree</span></a>
<a class="sourceLine" id="cb5-11" data-line-number="11">    (weight xs <span class="fu">+</span> weight ys)</a>
<a class="sourceLine" id="cb5-12" data-line-number="12">    (<span class="dt">Branch</span> xs (branch ys))</a>
<a class="sourceLine" id="cb5-13" data-line-number="13"></a>
<a class="sourceLine" id="cb5-14" data-line-number="14"><span class="ot">insert ::</span> <span class="dt">Word</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Urn</span> a <span class="ot">-&gt;</span> <span class="dt">Urn</span> a</a>
<a class="sourceLine" id="cb5-15" data-line-number="15">insert i x (<span class="dt">Urn</span> w xs) <span class="fu">=</span> <span class="dt">Urn</span> (w<span class="fu">+</span>i) (insertHeap i x xs)</a></code></pre></div>
<p>We <em>could</em> potentially get insertion from amortized <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math> to worst-case <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math> by using skew binary instead of binary (in fact I am almost sure it‚Äôs possible), but then I think we‚Äôd lose the efficient merge. I‚Äôll leave exploring that for another day.</p>
<p>To get randomness, we‚Äôll write a very simple class that encapsulates only what we need:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Sample</span> m <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">    <span class="co">-- | Inclusive range</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="ot">    inRange ::</span> <span class="dt">Word</span> <span class="ot">-&gt;</span> <span class="dt">Word</span> <span class="ot">-&gt;</span> m <span class="dt">Word</span></a></code></pre></div>
<p>You can later instantiate this to whatever random monad you end up using. (The same approach was taken in the paper, although we only require <code>Functor</code> here, not <code>Monad</code>).</p>
<p>Sampling (with replacement) first randomly chooses a tree from the top-level list, and then we drill down into that tree with binary search.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">sample ::</span> (<span class="dt">Functor</span> m, <span class="dt">Sample</span> m) <span class="ot">=&gt;</span> <span class="dt">Urn</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (m a)</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">sample (<span class="dt">Urn</span> _ <span class="dt">Nil</span>) <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">sample (<span class="dt">Urn</span> w&#39; (<span class="dt">Cons</span> _ x&#39; xs&#39;)) <span class="fu">=</span> <span class="dt">Just</span> (fmap (go x&#39; xs&#39;) (inRange <span class="dv">0</span> (w&#39; <span class="fu">-</span> <span class="dv">1</span>)))</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5">    go x <span class="dt">Nil</span> <span class="fu">!</span>w <span class="fu">=</span> go&#39; w (branch x)</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">    go x (<span class="dt">Cons</span> _ y ys) <span class="fu">!</span>w</a>
<a class="sourceLine" id="cb7-7" data-line-number="7">      <span class="fu">|</span> w <span class="fu">&lt;</span> weight x <span class="fu">=</span> go&#39; w (branch x)</a>
<a class="sourceLine" id="cb7-8" data-line-number="8">      <span class="fu">|</span> otherwise    <span class="fu">=</span> go y ys (w <span class="fu">-</span> weight x)</a>
<a class="sourceLine" id="cb7-9" data-line-number="9">    go&#39; <span class="fu">!</span>_ (<span class="dt">Leaf</span> x) <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb7-10" data-line-number="10">    go&#39; <span class="fu">!</span>i (<span class="dt">Branch</span> xs ys)</a>
<a class="sourceLine" id="cb7-11" data-line-number="11">      <span class="fu">|</span> i <span class="fu">&lt;</span> weight xs <span class="fu">=</span> go&#39; i (branch xs)</a>
<a class="sourceLine" id="cb7-12" data-line-number="12">      <span class="fu">|</span> otherwise <span class="fu">=</span> go&#39; (i <span class="fu">-</span> weight xs) ys</a></code></pre></div>
<p>So we‚Äôre off to a good start, but <code>remove</code> is a complex operation. We take the same route taken in the paper: first, we perform an ‚Äúuncons‚Äù-like operation, which pops out the last inserted element. Then, we randomly choose a point in the tree (using the same logic as in <code>sample</code>), and replace it with the popped element<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">remove ::</span> (<span class="dt">Functor</span> m, <span class="dt">Sample</span> m) <span class="ot">=&gt;</span> <span class="dt">Urn</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (m ((a, <span class="dt">Word</span>), <span class="dt">Urn</span> a))</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">remove (<span class="dt">Urn</span> w hp) <span class="fu">=</span> fmap go&#39; (Heap.uninsert hp)</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">    go&#39; (vw,v,hp&#39;) <span class="fu">=</span> fmap (<span class="ot">`go`</span> hp&#39;) (inRange <span class="dv">0</span> (w<span class="fu">-</span><span class="dv">1</span>))</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">        go <span class="fu">!</span>_  <span class="dt">Nil</span> <span class="fu">=</span> ((v, vw), <span class="dt">Urn</span> <span class="dv">0</span> <span class="dt">Nil</span>)</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">        go <span class="fu">!</span>rw vs<span class="fu">@</span>(<span class="dt">Cons</span> i&#39; x&#39; xs&#39;)</a>
<a class="sourceLine" id="cb8-8" data-line-number="8">          <span class="fu">|</span> rw <span class="fu">&lt;</span> vw <span class="fu">=</span> ((v, vw), <span class="dt">Urn</span> (w <span class="fu">-</span> vw) vs)</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">          <span class="fu">|</span> otherwise <span class="fu">=</span> replace (rw <span class="fu">-</span> vw) i&#39; x&#39; xs&#39;</a>
<a class="sourceLine" id="cb8-10" data-line-number="10">            (\ys yw y <span class="ot">-&gt;</span> ((y, yw), <span class="dt">Urn</span> (w <span class="fu">-</span> yw) ys))</a>
<a class="sourceLine" id="cb8-11" data-line-number="11"></a>
<a class="sourceLine" id="cb8-12" data-line-number="12">        replace <span class="fu">!</span>rw i x <span class="dt">Nil</span> k <span class="fu">=</span> replaceTree rw x (\t <span class="ot">-&gt;</span> k (<span class="dt">Cons</span> i t <span class="dt">Nil</span>))</a>
<a class="sourceLine" id="cb8-13" data-line-number="13">        replace <span class="fu">!</span>rw i x xs<span class="fu">@</span>(<span class="dt">Cons</span> j y ys) k</a>
<a class="sourceLine" id="cb8-14" data-line-number="14">          <span class="fu">|</span> rw <span class="fu">&lt;</span> weight x <span class="fu">=</span> replaceTree rw x (\t <span class="ot">-&gt;</span> k (<span class="dt">Cons</span> i t xs))</a>
<a class="sourceLine" id="cb8-15" data-line-number="15">          <span class="fu">|</span> otherwise <span class="fu">=</span> replace (rw <span class="fu">-</span> weight x) j y ys (k <span class="fu">.</span> <span class="dt">Cons</span> i x)</a>
<a class="sourceLine" id="cb8-16" data-line-number="16"></a>
<a class="sourceLine" id="cb8-17" data-line-number="17">        replaceTree <span class="fu">!</span>_  (<span class="dt">Tree</span> tw (<span class="dt">Leaf</span> x)) k <span class="fu">=</span> k (<span class="dt">Tree</span> vw (<span class="dt">Leaf</span> v)) tw x</a>
<a class="sourceLine" id="cb8-18" data-line-number="18">        replaceTree <span class="fu">!</span>rw (<span class="dt">Tree</span> tw (<span class="dt">Branch</span> xs ys)) k</a>
<a class="sourceLine" id="cb8-19" data-line-number="19">          <span class="fu">|</span> rw <span class="fu">&lt;</span> weight xs <span class="fu">=</span> replaceTree rw xs</a>
<a class="sourceLine" id="cb8-20" data-line-number="20">            (\t <span class="ot">-&gt;</span> k (<span class="dt">Tree</span> (tw <span class="fu">+</span> (weight t <span class="fu">-</span> weight xs)) (<span class="dt">Branch</span> t ys)))</a>
<a class="sourceLine" id="cb8-21" data-line-number="21">          <span class="fu">|</span> otherwise <span class="fu">=</span> replaceTree (rw <span class="fu">-</span> weight xs)</a>
<a class="sourceLine" id="cb8-22" data-line-number="22">            (<span class="dt">Tree</span> (tw <span class="fu">-</span> weight xs) ys)</a>
<a class="sourceLine" id="cb8-23" data-line-number="23">            (\t <span class="ot">-&gt;</span> k (<span class="dt">Tree</span> (weight xs <span class="fu">+</span> weight t) (<span class="dt">Branch</span> xs (branch t))))</a></code></pre></div>
<p>Merge is the same as on binomial heaps:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">mergeHeap ::</span> <span class="dt">Heap</span> a <span class="ot">-&gt;</span> <span class="dt">Heap</span> a <span class="ot">-&gt;</span> <span class="dt">Heap</span> a</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">mergeHeap <span class="dt">Nil</span> <span class="fu">=</span> id</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">mergeHeap (<span class="dt">Cons</span> i&#39; x&#39; xs&#39;) <span class="fu">=</span> merger i&#39; x&#39; xs&#39;</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">    merger <span class="fu">!</span>i x xs <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Cons</span> i x xs</a>
<a class="sourceLine" id="cb9-6" data-line-number="6">    merger <span class="fu">!</span>i x xs (<span class="dt">Cons</span> j y ys) <span class="fu">=</span> merge&#39; i x xs j y ys</a>
<a class="sourceLine" id="cb9-7" data-line-number="7"></a>
<a class="sourceLine" id="cb9-8" data-line-number="8">    merge&#39; <span class="fu">!</span>i x xs <span class="fu">!</span>j y ys <span class="fu">=</span> <span class="kw">case</span> compare i j <span class="kw">of</span></a>
<a class="sourceLine" id="cb9-9" data-line-number="9">        <span class="dt">LT</span> <span class="ot">-&gt;</span> <span class="dt">Cons</span> i x (merger (j<span class="fu">-</span>i<span class="fu">-</span><span class="dv">1</span>) y ys xs)</a>
<a class="sourceLine" id="cb9-10" data-line-number="10">        <span class="dt">GT</span> <span class="ot">-&gt;</span> <span class="dt">Cons</span> j y (merger (i<span class="fu">-</span>j<span class="fu">-</span><span class="dv">1</span>) x xs ys)</a>
<a class="sourceLine" id="cb9-11" data-line-number="11">        <span class="dt">EQ</span> <span class="ot">-&gt;</span> mergec (succ i) (mergeTree x y) xs ys</a>
<a class="sourceLine" id="cb9-12" data-line-number="12"></a>
<a class="sourceLine" id="cb9-13" data-line-number="13">    mergec <span class="fu">!</span>p <span class="fu">!</span>t <span class="dt">Nil</span> <span class="fu">=</span> carryLonger p t</a>
<a class="sourceLine" id="cb9-14" data-line-number="14">    mergec <span class="fu">!</span>p <span class="fu">!</span>t (<span class="dt">Cons</span> i x xs) <span class="fu">=</span> mergecr p t i x xs</a>
<a class="sourceLine" id="cb9-15" data-line-number="15"></a>
<a class="sourceLine" id="cb9-16" data-line-number="16">    mergecr <span class="fu">!</span>p <span class="fu">!</span>t <span class="fu">!</span>i x xs <span class="dt">Nil</span> <span class="fu">=</span> carryLonger&#39; p t i x xs</a>
<a class="sourceLine" id="cb9-17" data-line-number="17">    mergecr <span class="fu">!</span>p <span class="fu">!</span>t <span class="fu">!</span>i x xs (<span class="dt">Cons</span> j y ys) <span class="fu">=</span> mergec&#39; p t i x xs j y ys</a>
<a class="sourceLine" id="cb9-18" data-line-number="18"></a>
<a class="sourceLine" id="cb9-19" data-line-number="19">    mergec&#39; <span class="fu">!</span>p t <span class="fu">!</span>i x xs <span class="fu">!</span>j y ys <span class="fu">=</span> <span class="kw">case</span> compare i j <span class="kw">of</span></a>
<a class="sourceLine" id="cb9-20" data-line-number="20">      <span class="dt">LT</span> <span class="ot">-&gt;</span> mergecr&#39;&#39; p t i x xs (j<span class="fu">-</span>i<span class="fu">-</span><span class="dv">1</span>) y ys</a>
<a class="sourceLine" id="cb9-21" data-line-number="21">      <span class="dt">GT</span> <span class="ot">-&gt;</span> mergecr&#39;&#39; p t j y ys (i<span class="fu">-</span>j<span class="fu">-</span><span class="dv">1</span>) x xs</a>
<a class="sourceLine" id="cb9-22" data-line-number="22">      <span class="dt">EQ</span> <span class="ot">-&gt;</span> <span class="dt">Cons</span> p t (mergec i (mergeTree x y) xs ys)</a>
<a class="sourceLine" id="cb9-23" data-line-number="23"></a>
<a class="sourceLine" id="cb9-24" data-line-number="24">    mergecr&#39;&#39; <span class="fu">!</span>p <span class="fu">!</span>t  <span class="dv">0</span> x xs <span class="fu">!</span>j y ys <span class="fu">=</span> mergecr (p<span class="fu">+</span><span class="dv">1</span>) (mergeTree t x) j y ys xs</a>
<a class="sourceLine" id="cb9-25" data-line-number="25">    mergecr&#39;&#39; <span class="fu">!</span>p <span class="fu">!</span>t <span class="fu">!</span>i x xs <span class="fu">!</span>j y ys <span class="fu">=</span> <span class="dt">Cons</span> p t (<span class="dt">Cons</span> (i<span class="fu">-</span><span class="dv">1</span>) x (merger j y ys xs))</a>
<a class="sourceLine" id="cb9-26" data-line-number="26"></a>
<a class="sourceLine" id="cb9-27" data-line-number="27">    carryLonger <span class="fu">!</span>i <span class="fu">!</span>t <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Cons</span> i t <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb9-28" data-line-number="28">    carryLonger <span class="fu">!</span>i <span class="fu">!</span>t (<span class="dt">Cons</span> j y ys) <span class="fu">=</span> carryLonger&#39; i t j y ys</a>
<a class="sourceLine" id="cb9-29" data-line-number="29"></a>
<a class="sourceLine" id="cb9-30" data-line-number="30">    carryLonger&#39; <span class="fu">!</span>i <span class="fu">!</span>t  <span class="dv">0</span> y ys <span class="fu">=</span> carryLonger (succ i) (mergeTree t y) ys</a>
<a class="sourceLine" id="cb9-31" data-line-number="31">    carryLonger&#39; <span class="fu">!</span>i <span class="fu">!</span>t <span class="fu">!</span>j y ys <span class="fu">=</span> <span class="dt">Cons</span> i t (<span class="dt">Cons</span> (j<span class="fu">-</span><span class="dv">1</span>) y ys)</a>
<a class="sourceLine" id="cb9-32" data-line-number="32"></a>
<a class="sourceLine" id="cb9-33" data-line-number="33"><span class="ot">merge ::</span> <span class="dt">Urn</span> a <span class="ot">-&gt;</span> <span class="dt">Urn</span> a <span class="ot">-&gt;</span> <span class="dt">Urn</span> a</a>
<a class="sourceLine" id="cb9-34" data-line-number="34">merge (<span class="dt">Urn</span> i xs) (<span class="dt">Urn</span> j ys) <span class="fu">=</span> <span class="dt">Urn</span> (i<span class="fu">+</span>j) (mergeHeap xs ys)   </a></code></pre></div>
<h1 id="finger-trees">Finger Trees</h1>
<p>Again, the cleverness of all the tree folds is that they intelligently batch summarizing operations, allowing you to efficiently so prefix-scan-like operations that exploit sharing.</p>
<p>The bare-bones version just uses binary numbers: you can upgrade the <code>cons</code> operation to worst-case constant-time if you use <em>skew</em> binary. Are there other optimizations? Yes! What if we wanted to stick something on to the <em>other</em> end, for instance? What if we wanted to reverse?</p>
<p>If you figure out a way to do <em>all</em> these optimizations, and put them into one big data structure, you get the mother-of-all ‚Äúbatching‚Äù data structures: the finger tree. This is the basis for Haskell‚Äôs Data.Sequence, but it can also implement priority queues, urns (I‚Äôd imagine), fenwick-tree-like structures, and more.</p>
<h1 id="uses-and-further-work">Uses and Further Work</h1>
<p>First and foremost, I should test the above implementations! I‚Äôm pretty confident the asymptotics are correct, but I‚Äôm certain the implementations have bugs.</p>
<p>The efficient <code>merge</code> is intriguing: it means that <code>Urn</code> could conceivably be <code>Alternative</code>, <code>MonadPlus</code>, etc. I have yet to see a use for that, but it‚Äôs interesting nonetheless! I‚Äôm constantly looking for a way to express something like Dijkstra‚Äôs algorithm algebraicly, using the usual <code>Alternative</code> combinators; I don‚Äôt know if this is related.</p>
<p>The other interesting point is that, for this to be an instance of <code>Applicative</code>, it would need some analogue for multiplication for the weights. I‚Äôm not sure what that should be.</p>
<p>This is inherently <em>max</em>-priority. It‚Äôs not obvious how to translate what we have into a min-priority queue version.</p>
<p>Finally, it might be worth trying out different priority queues (a pairing heap is very similar in structure to this). Also, we could rearrange the weights so that larger ones are higher in each tree: this might give a performance boost.</p>
<div id="refs" class="references">
<div id="ref-lampropoulos_ode_2017">
<p>Lampropoulos, Leonidas, Antal Spector-Zabusky, and Kenneth Foner. 2017. ‚ÄúOde on a random urn (functional pearl).‚Äù In, 26‚Äì37. ACM Press. doi:<a href="https://doi.org/10.1145/3122955.3122959">10.1145/3122955.3122959</a>.</p>
</div>
<div id="ref-okasaki_three_1997">
<p>Okasaki, Chris. 1997. ‚ÄúThree Algorithms on Braun Trees.‚Äù <em>Journal of Functional Programming</em> 7 (6) (November): 661‚Äì666. doi:<a href="https://doi.org/10.1017/S0956796897002876">10.1017/S0956796897002876</a>.</p>
</div>
</div>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>There‚Äôs one extra step I haven‚Äôt mentioned: we also must allow the first element (the last inserted) to be chosen, so we run the random-number generator once to check if that‚Äôs the element we want to choose.<a href="#fnref1" class="footnote-back">‚Ü©</a></p></li>
</ol>
</section>
]]></description>
    <pubDate>Tue, 15 Jan 2019 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2019-01-15-binomial-urn.html</guid>
    <dc:creator>Donnacha Ois√≠n Kidney</dc:creator>
</item>
<item>
    <title>Balancing Scans</title>
    <link>https://doisinkidney.com/posts/2018-12-21-balancing-scans.html</link>
    <description><![CDATA[<div class="info">
    Posted on December 21, 2018
</div>
<div class="info">
    
        Part 2 of a <a href="/series/Balanced%20Folds.html">3-part series on Balanced Folds</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Agda.html">Agda</a>
    
</div>

<p><a href="2017-10-30-balancing-folds.html">Previously</a> I tried to figure out a way to fold lists in a more balanced way. Usually, when folding lists, you‚Äôve got two choices for your folds, both of which are extremely unbalanced in one direction or another. Jon Fairbairn <a href="https://www.mail-archive.com/haskell@haskell.org/msg01788.html">wrote</a> a more balanced version, which looked something like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">treeFold ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">treeFold f <span class="fu">=</span> go</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">    go x [] <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">    go a (b<span class="fu">:</span>l) <span class="fu">=</span> go (f a b) (pairMap l)</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">    pairMap (x<span class="fu">:</span>y<span class="fu">:</span>rest) <span class="fu">=</span> f x y <span class="fu">:</span> pairMap rest</a>
<a class="sourceLine" id="cb1-7" data-line-number="7">    pairMap xs <span class="fu">=</span> xs</a></code></pre></div>
<h1 id="magical-speedups">Magical Speedups</h1>
<p>The fold above is kind of magical: for a huge class of algorithms, it kind of ‚Äúautomatically‚Äù improves some factor of theirs from <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n)</annotation></semantics></math> to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math>. For instance: to sum a list of floats, <code class="sourceCode haskell">foldl&#39; (<span class="fu">+</span>) <span class="dv">0</span></code> will have an error growth of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n)</annotation></semantics></math>; <code>treeFold (+) 0</code>, though, has an error rate of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math>. Similarly, using the following function to merge two sorted lists:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">merge ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">merge [] ys <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">merge (x<span class="fu">:</span>xs) ys <span class="fu">=</span> go x xs ys</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5">    go x xs [] <span class="fu">=</span> x <span class="fu">:</span> xs</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">    go x xs (y<span class="fu">:</span>ys)</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">      <span class="fu">|</span> x <span class="fu">&lt;=</span> y    <span class="fu">=</span> x <span class="fu">:</span> go y ys xs</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">      <span class="fu">|</span> otherwise <span class="fu">=</span> y <span class="fu">:</span> go x xs ys</a></code></pre></div>
<p>We get either insertion sort (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n^2)</annotation></semantics></math>) or merge sort (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n \log n)</annotation></semantics></math>) just depending on which fold you use.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1">foldr    merge [] <span class="fu">.</span> map pure <span class="co">-- n^2</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">treeFold merge [] <span class="fu">.</span> map pure <span class="co">-- n log(n)</span></a></code></pre></div>
<p>I‚Äôll give some more examples later, but effectively it gives us a better ‚Äúdivide‚Äù step in many divide and conquer algorithms.</p>
<h1 id="termination">Termination</h1>
<p>As it was such a useful fold, and so integral to many tricky algorithms, I really wanted to have it available in Agda. Unfortunately, though, the functions (as defined above) aren‚Äôt structurally terminating, and there doesn‚Äôt <em>look</em> like there‚Äôs an obvious way to make it so. I tried to make well founded recursion work, but the proofs were ugly and slow.</p>
<p>However, we can use some structures from a <a href="2018-11-20-fast-verified-structures.html">previous post</a>: the nested binary sequence, for instance. It has some extra nice properties: instead of nesting the types, we can just apply the combining function.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">mutual</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  <span class="kw">data</span> Tree <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">    2^<span class="ot">_</span>√ó<span class="ot">_</span>+<span class="ot">_</span> <span class="ot">:</span> ‚Ñï <span class="ot">‚Üí</span> A <span class="ot">‚Üí</span> Node A <span class="ot">‚Üí</span> Tree A</a>
<a class="sourceLine" id="cb4-4" data-line-number="4"></a>
<a class="sourceLine" id="cb4-5" data-line-number="5">  <span class="kw">data</span> Node <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">    ‚ü®‚ü©  <span class="ot">:</span> Node A</a>
<a class="sourceLine" id="cb4-7" data-line-number="7">    ‚ü®<span class="ot">_</span>‚ü© <span class="ot">:</span> Tree A <span class="ot">‚Üí</span> Node A</a>
<a class="sourceLine" id="cb4-8" data-line-number="8"></a>
<a class="sourceLine" id="cb4-9" data-line-number="9"><span class="kw">module</span> TreeFold <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">(_</span>*<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">‚Üí</span> A <span class="ot">‚Üí</span> A<span class="ot">)</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-10" data-line-number="10">  <span class="kw">infixr</span> <span class="dv">5</span> <span class="ot">_</span>‚äõ<span class="ot">_</span> 2^<span class="ot">_</span>√ó<span class="ot">_</span>‚äõ<span class="ot">_</span></a>
<a class="sourceLine" id="cb4-11" data-line-number="11"></a>
<a class="sourceLine" id="cb4-12" data-line-number="12">  2^<span class="ot">_</span>√ó<span class="ot">_</span>‚äõ<span class="ot">_</span> <span class="ot">:</span> ‚Ñï <span class="ot">‚Üí</span> A <span class="ot">‚Üí</span> Tree A <span class="ot">‚Üí</span> Tree A</a>
<a class="sourceLine" id="cb4-13" data-line-number="13">  2^ n √ó x ‚äõ 2^ suc m √ó y + ys <span class="ot">=</span> 2^ n √ó x + ‚ü® 2^ m √ó y + ys ‚ü©</a>
<a class="sourceLine" id="cb4-14" data-line-number="14">  2^ n √ó x ‚äõ 2^ zero  √ó y + ‚ü®‚ü© <span class="ot">=</span> 2^ suc n √ó <span class="ot">(</span>x * y<span class="ot">)</span> + ‚ü®‚ü©</a>
<a class="sourceLine" id="cb4-15" data-line-number="15">  2^ n √ó x ‚äõ 2^ zero  √ó y + ‚ü® ys ‚ü© <span class="ot">=</span> 2^ suc n √ó <span class="ot">(</span>x * y<span class="ot">)</span> ‚äõ ys</a>
<a class="sourceLine" id="cb4-16" data-line-number="16"></a>
<a class="sourceLine" id="cb4-17" data-line-number="17">  <span class="ot">_</span>‚äõ<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">‚Üí</span> Tree A <span class="ot">‚Üí</span> Tree A</a>
<a class="sourceLine" id="cb4-18" data-line-number="18">  <span class="ot">_</span>‚äõ<span class="ot">_</span> <span class="ot">=</span> 2^ <span class="dv">0</span> √ó<span class="ot">_</span>‚äõ<span class="ot">_</span></a>
<a class="sourceLine" id="cb4-19" data-line-number="19"></a>
<a class="sourceLine" id="cb4-20" data-line-number="20">  ‚ü¶<span class="ot">_</span>‚üß‚Üì <span class="ot">:</span> Tree A <span class="ot">‚Üí</span> A</a>
<a class="sourceLine" id="cb4-21" data-line-number="21">  ‚ü¶ 2^ <span class="ot">_</span> √ó x + ‚ü®‚ü© ‚üß‚Üì <span class="ot">=</span> x</a>
<a class="sourceLine" id="cb4-22" data-line-number="22">  ‚ü¶ 2^ <span class="ot">_</span> √ó x + ‚ü® xs ‚ü© ‚üß‚Üì <span class="ot">=</span> x * ‚ü¶ xs ‚üß‚Üì</a>
<a class="sourceLine" id="cb4-23" data-line-number="23"></a>
<a class="sourceLine" id="cb4-24" data-line-number="24">  ‚ü¶<span class="ot">_</span>‚üß‚Üë <span class="ot">:</span> A <span class="ot">‚Üí</span> Tree A</a>
<a class="sourceLine" id="cb4-25" data-line-number="25">  ‚ü¶ x ‚üß‚Üë <span class="ot">=</span> 2^ <span class="dv">0</span> √ó x + ‚ü®‚ü©</a>
<a class="sourceLine" id="cb4-26" data-line-number="26"></a>
<a class="sourceLine" id="cb4-27" data-line-number="27">  ‚¶Ö<span class="ot">_</span>,<span class="ot">_</span>‚¶Ü <span class="ot">:</span> A <span class="ot">‚Üí</span> List A <span class="ot">‚Üí</span> A</a>
<a class="sourceLine" id="cb4-28" data-line-number="28">  ‚¶Ö x , xs ‚¶Ü <span class="ot">=</span> ‚ü¶ foldr <span class="ot">_</span>‚äõ<span class="ot">_</span> ‚ü¶ x ‚üß‚Üë xs ‚üß‚Üì</a></code></pre></div>
<p>Alternatively, we can get <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math> cons with the skew array:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">5</span> <span class="ot">_</span>‚äõ<span class="ot">_</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="ot">_</span>‚äõ<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">‚Üí</span> Tree A <span class="ot">‚Üí</span> Tree A</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">x ‚äõ 2^ n √ó y  + ‚ü®‚ü© <span class="ot">=</span> 2^ <span class="dv">0</span> √ó x + ‚ü® 2^ n √ó y + ‚ü®‚ü© ‚ü©</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">x ‚äõ 2^ n √ó y‚ÇÅ + ‚ü® 2^ <span class="dv">0</span>     √ó y‚ÇÇ + ys ‚ü© <span class="ot">=</span> 2^ suc n √ó <span class="ot">(</span>x * <span class="ot">(</span>y‚ÇÅ * y‚ÇÇ<span class="ot">))</span> + ys</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">x ‚äõ 2^ n √ó y‚ÇÅ + ‚ü® 2^ suc m √ó y‚ÇÇ + ys ‚ü© <span class="ot">=</span> 2^ <span class="dv">0</span> √ó x + ‚ü® 2^ n √ó y‚ÇÅ + ‚ü® 2^ m √ó y‚ÇÇ + ys ‚ü© ‚ü©</a></code></pre></div>
<p>Using this, a proper and efficient merge sort is very straightforward:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">data</span> Total <span class="ot">{</span>a r<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">(_</span>‚â§<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">‚Üí</span> A <span class="ot">‚Üí</span> <span class="dt">Set</span> r<span class="ot">)</span> <span class="ot">(</span>x y <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">(</span>a ‚äî r<span class="ot">)</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  x‚â§y <span class="ot">:</span> ‚¶É <span class="ot">_</span> <span class="ot">:</span> x ‚â§ y ‚¶Ñ <span class="ot">‚Üí</span> Total <span class="ot">_</span>‚â§<span class="ot">_</span> x y</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  y‚â§x <span class="ot">:</span> ‚¶É <span class="ot">_</span> <span class="ot">:</span> y ‚â§ x ‚¶Ñ <span class="ot">‚Üí</span> Total <span class="ot">_</span>‚â§<span class="ot">_</span> x y</a>
<a class="sourceLine" id="cb6-4" data-line-number="4"></a>
<a class="sourceLine" id="cb6-5" data-line-number="5"><span class="kw">module</span> Sorting <span class="ot">{</span>a r<span class="ot">}</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">               <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span></a>
<a class="sourceLine" id="cb6-7" data-line-number="7">               <span class="ot">{_</span>‚â§<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">‚Üí</span> A <span class="ot">‚Üí</span> <span class="dt">Set</span> r<span class="ot">}</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">               <span class="ot">(_</span>‚â§?<span class="ot">_</span> <span class="ot">:</span> <span class="ot">‚àÄ</span> x y <span class="ot">‚Üí</span> Total <span class="ot">_</span>‚â§<span class="ot">_</span> x y<span class="ot">)</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-9" data-line-number="9">  <span class="kw">data</span> [‚àô] <span class="ot">:</span> <span class="dt">Set</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-10" data-line-number="10">    ‚ä•   <span class="ot">:</span> [‚àô]</a>
<a class="sourceLine" id="cb6-11" data-line-number="11">    [<span class="ot">_</span>] <span class="ot">:</span> A <span class="ot">‚Üí</span> [‚àô]</a>
<a class="sourceLine" id="cb6-12" data-line-number="12"></a>
<a class="sourceLine" id="cb6-13" data-line-number="13">  <span class="kw">data</span> <span class="ot">_</span>‚â•<span class="ot">_</span> <span class="ot">(</span>x <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">:</span> [‚àô] <span class="ot">‚Üí</span> <span class="dt">Set</span> <span class="ot">(</span>a ‚äî r<span class="ot">)</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-14" data-line-number="14">    instance ‚åà<span class="ot">_</span>‚åâ <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>y<span class="ot">}</span> <span class="ot">‚Üí</span> y ‚â§ x <span class="ot">‚Üí</span> x ‚â• [ y ]</a>
<a class="sourceLine" id="cb6-15" data-line-number="15">    instance ‚åä‚ä•‚åã <span class="ot">:</span> x ‚â• ‚ä•</a>
<a class="sourceLine" id="cb6-16" data-line-number="16"></a>
<a class="sourceLine" id="cb6-17" data-line-number="17">  <span class="kw">infixr</span> <span class="dv">5</span> <span class="ot">_</span>‚à∑<span class="ot">_</span></a>
<a class="sourceLine" id="cb6-18" data-line-number="18">  <span class="kw">data</span> Ordered <span class="ot">(</span>b <span class="ot">:</span> [‚àô]<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">(</span>a ‚äî r<span class="ot">)</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-19" data-line-number="19">    []  <span class="ot">:</span> Ordered b</a>
<a class="sourceLine" id="cb6-20" data-line-number="20">    <span class="ot">_</span>‚à∑<span class="ot">_</span> <span class="ot">:</span> <span class="ot">‚àÄ</span> x <span class="ot">‚Üí</span> ‚¶É x‚â•b <span class="ot">:</span> x ‚â• b ‚¶Ñ <span class="ot">‚Üí</span> <span class="ot">(</span>xs <span class="ot">:</span> Ordered [ x ]<span class="ot">)</span> <span class="ot">‚Üí</span> Ordered b</a>
<a class="sourceLine" id="cb6-21" data-line-number="21"></a>
<a class="sourceLine" id="cb6-22" data-line-number="22">  <span class="ot">_</span>‚à™<span class="ot">_</span> <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>b<span class="ot">}</span> <span class="ot">‚Üí</span> Ordered b <span class="ot">‚Üí</span> Ordered b <span class="ot">‚Üí</span> Ordered b</a>
<a class="sourceLine" id="cb6-23" data-line-number="23">  [] ‚à™ ys <span class="ot">=</span> ys</a>
<a class="sourceLine" id="cb6-24" data-line-number="24">  <span class="ot">(</span>x ‚à∑ xs<span class="ot">)</span> ‚à™ ys <span class="ot">=</span> ‚üÖ x ‚àπ xs ‚à™ ys ‚üÜ</a>
<a class="sourceLine" id="cb6-25" data-line-number="25">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-26" data-line-number="26">    ‚üÖ<span class="ot">_</span>‚àπ<span class="ot">_</span>‚à™<span class="ot">_</span>‚üÜ <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>b<span class="ot">}</span> <span class="ot">‚Üí</span> <span class="ot">‚àÄ</span> x ‚¶É <span class="ot">_</span> <span class="ot">:</span> x ‚â• b ‚¶Ñ <span class="ot">‚Üí</span> Ordered [ x ] <span class="ot">‚Üí</span> Ordered b <span class="ot">‚Üí</span> Ordered b</a>
<a class="sourceLine" id="cb6-27" data-line-number="27">    ‚üÖ<span class="ot">_</span>‚à™<span class="ot">_</span>‚àπ<span class="ot">_</span>‚üÜ <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>b<span class="ot">}</span> <span class="ot">‚Üí</span> Ordered b <span class="ot">‚Üí</span> <span class="ot">‚àÄ</span> y ‚¶É <span class="ot">_</span> <span class="ot">:</span> y ‚â• b ‚¶Ñ <span class="ot">‚Üí</span> Ordered [ y ] <span class="ot">‚Üí</span> Ordered b</a>
<a class="sourceLine" id="cb6-28" data-line-number="28">    merge <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>b<span class="ot">}</span> x y ‚¶É <span class="ot">_</span> <span class="ot">:</span> x ‚â• b ‚¶Ñ ‚¶É <span class="ot">_</span> <span class="ot">:</span> y ‚â• b ‚¶Ñ</a>
<a class="sourceLine" id="cb6-29" data-line-number="29">          <span class="ot">‚Üí</span> Total <span class="ot">_</span>‚â§<span class="ot">_</span> x y</a>
<a class="sourceLine" id="cb6-30" data-line-number="30">          <span class="ot">‚Üí</span> Ordered [ x ]</a>
<a class="sourceLine" id="cb6-31" data-line-number="31">          <span class="ot">‚Üí</span> Ordered [ y ]</a>
<a class="sourceLine" id="cb6-32" data-line-number="32">          <span class="ot">‚Üí</span> Ordered b</a>
<a class="sourceLine" id="cb6-33" data-line-number="33"></a>
<a class="sourceLine" id="cb6-34" data-line-number="34">    ‚üÖ x ‚àπ xs ‚à™ [] ‚üÜ <span class="ot">=</span> x ‚à∑ xs</a>
<a class="sourceLine" id="cb6-35" data-line-number="35">    ‚üÖ x ‚àπ xs ‚à™ y ‚à∑ ys ‚üÜ <span class="ot">=</span> merge x y <span class="ot">(</span>x ‚â§? y<span class="ot">)</span> xs ys</a>
<a class="sourceLine" id="cb6-36" data-line-number="36">    ‚üÖ [] ‚à™ y ‚àπ ys ‚üÜ <span class="ot">=</span> y ‚à∑ ys</a>
<a class="sourceLine" id="cb6-37" data-line-number="37">    ‚üÖ x ‚à∑ xs ‚à™ y ‚àπ ys ‚üÜ <span class="ot">=</span> merge x y <span class="ot">(</span>x ‚â§? y<span class="ot">)</span> xs ys</a>
<a class="sourceLine" id="cb6-38" data-line-number="38"></a>
<a class="sourceLine" id="cb6-39" data-line-number="39">    merge x y x‚â§y xs ys <span class="ot">=</span> x ‚à∑ ‚üÖ xs ‚à™ y ‚àπ ys ‚üÜ</a>
<a class="sourceLine" id="cb6-40" data-line-number="40">    merge x y y‚â§x xs ys <span class="ot">=</span> y ‚à∑ ‚üÖ x ‚àπ xs ‚à™ ys ‚üÜ</a>
<a class="sourceLine" id="cb6-41" data-line-number="41"></a>
<a class="sourceLine" id="cb6-42" data-line-number="42"></a>
<a class="sourceLine" id="cb6-43" data-line-number="43">  <span class="kw">open</span> TreeFold</a>
<a class="sourceLine" id="cb6-44" data-line-number="44"></a>
<a class="sourceLine" id="cb6-45" data-line-number="45">  sort <span class="ot">:</span> List A <span class="ot">‚Üí</span> Ordered ‚ä•</a>
<a class="sourceLine" id="cb6-46" data-line-number="46">  sort <span class="ot">=</span> ‚¶Ö <span class="ot">_</span>‚à™<span class="ot">_</span> , [] ‚¶Ü ‚àò map <span class="ot">(_</span>‚à∑ []<span class="ot">)</span></a></code></pre></div>
<h1 id="validity">Validity</h1>
<p>It would be nice if we could verify these optimizated versions of folds. Luckily, by writing them using <code>foldr</code>, we‚Äôve stumbled into well-trodden ground: the <em>foldr fusion law</em>. It states that if you have some transformation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>, and two binary operators <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>‚äï</mo><annotation encoding="application/x-tex">\oplus</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>‚äó</mo><annotation encoding="application/x-tex">\otimes</annotation></semantics></math>, then:</p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right"><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>‚äï</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="left"></mtd><mtd columnalign="right"><mo>=</mo><mspace width="0.278em"></mspace></mtd><mtd columnalign="left"><mi>x</mi><mo>‚äó</mo><mi>f</mi><mi>y</mi></mtd></mtr><mtr><mtd columnalign="right"><mo>‚üπ</mo><mi>f</mi><mo>‚àò</mo><mtext mathvariant="normal">foldr</mtext><mo>‚äï</mo><mi>e</mi></mtd><mtd columnalign="left"></mtd><mtd columnalign="right"><mo>=</mo><mspace width="0.278em"></mspace></mtd><mtd columnalign="left"><mtext mathvariant="normal">foldr</mtext><mo>‚äó</mo><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mi>e</mi><mo stretchy="false" form="postfix">)</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align}
   f (x \oplus y)                         &amp;&amp;=\;&amp; x \otimes f y \\
   \implies f \circ \text{foldr} \oplus e &amp;&amp;=\;&amp; \text{foldr} \otimes (f e)
\end{align}</annotation></semantics></math>
<p>This fits right in with the function we used above. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> is <code>‚ü¶_‚üß‚Üì</code>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>‚äï</mo><annotation encoding="application/x-tex">\oplus</annotation></semantics></math> is <code>_‚äõ_</code>, and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>‚äó</mo><annotation encoding="application/x-tex">\otimes</annotation></semantics></math> is whatever combining function was passed in. Let‚Äôs prove the foldr fusion law, then, before we go any further.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">module</span> Proofs</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  <span class="ot">{</span>a r<span class="ot">}</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">  <span class="ot">{</span>R <span class="ot">:</span> Rel A r<span class="ot">}</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6"></a>
<a class="sourceLine" id="cb7-7" data-line-number="7">  <span class="kw">infix</span> <span class="dv">4</span> <span class="ot">_</span>‚âà<span class="ot">_</span></a>
<a class="sourceLine" id="cb7-8" data-line-number="8">  <span class="ot">_</span>‚âà<span class="ot">_</span> <span class="ot">=</span> R</a>
<a class="sourceLine" id="cb7-9" data-line-number="9"></a>
<a class="sourceLine" id="cb7-10" data-line-number="10">  <span class="kw">open</span> <span class="kw">import</span> Algebra<span class="ot">.</span>FunctionProperties <span class="ot">_</span>‚âà<span class="ot">_</span></a>
<a class="sourceLine" id="cb7-11" data-line-number="11"></a>
<a class="sourceLine" id="cb7-12" data-line-number="12">  foldr-universal <span class="ot">:</span> Transitive <span class="ot">_</span>‚âà<span class="ot">_</span></a>
<a class="sourceLine" id="cb7-13" data-line-number="13">                  <span class="ot">‚Üí</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>b<span class="ot">}</span> <span class="ot">{</span>B <span class="ot">:</span> <span class="dt">Set</span> b<span class="ot">}</span> <span class="ot">(</span>h <span class="ot">:</span> List B <span class="ot">‚Üí</span> A<span class="ot">)</span> f e</a>
<a class="sourceLine" id="cb7-14" data-line-number="14">                  <span class="ot">‚Üí</span> ‚àÄ[ f ‚ä¢ Congruent‚ÇÅ ]</a>
<a class="sourceLine" id="cb7-15" data-line-number="15">                  <span class="ot">‚Üí</span> <span class="ot">(</span>h [] ‚âà e<span class="ot">)</span></a>
<a class="sourceLine" id="cb7-16" data-line-number="16">                  <span class="ot">‚Üí</span> <span class="ot">(‚àÄ</span> x xs <span class="ot">‚Üí</span> h <span class="ot">(</span>x ‚à∑ xs<span class="ot">)</span> ‚âà f x <span class="ot">(</span>h xs<span class="ot">))</span></a>
<a class="sourceLine" id="cb7-17" data-line-number="17">                  <span class="ot">‚Üí</span> <span class="ot">‚àÄ</span> xs <span class="ot">‚Üí</span> h xs ‚âà foldr f e xs</a>
<a class="sourceLine" id="cb7-18" data-line-number="18">  foldr-universal <span class="ot">_</span>‚óã<span class="ot">_</span> h f e f‚ü®<span class="ot">_</span>‚ü© ‚áí[] ‚áí<span class="ot">_</span>‚à∑<span class="ot">_</span> [] <span class="ot">=</span> ‚áí[]</a>
<a class="sourceLine" id="cb7-19" data-line-number="19">  foldr-universal <span class="ot">_</span>‚óã<span class="ot">_</span> h f e f‚ü®<span class="ot">_</span>‚ü© ‚áí[] ‚áí<span class="ot">_</span>‚à∑<span class="ot">_</span> <span class="ot">(</span>x ‚à∑ xs<span class="ot">)</span> <span class="ot">=</span></a>
<a class="sourceLine" id="cb7-20" data-line-number="20">    <span class="ot">(</span>‚áí x ‚à∑ xs<span class="ot">)</span> ‚óã f‚ü® foldr-universal <span class="ot">_</span>‚óã<span class="ot">_</span> h f e f‚ü®<span class="ot">_</span>‚ü© ‚áí[] ‚áí<span class="ot">_</span>‚à∑<span class="ot">_</span> xs ‚ü©</a>
<a class="sourceLine" id="cb7-21" data-line-number="21"></a>
<a class="sourceLine" id="cb7-22" data-line-number="22">  foldr-fusion <span class="ot">:</span> Transitive <span class="ot">_</span>‚âà<span class="ot">_</span></a>
<a class="sourceLine" id="cb7-23" data-line-number="23">               <span class="ot">‚Üí</span> Reflexive <span class="ot">_</span>‚âà<span class="ot">_</span></a>
<a class="sourceLine" id="cb7-24" data-line-number="24">               <span class="ot">‚Üí</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>b c<span class="ot">}</span> <span class="ot">{</span>B <span class="ot">:</span> <span class="dt">Set</span> b<span class="ot">}</span> <span class="ot">{</span>C <span class="ot">:</span> <span class="dt">Set</span> c<span class="ot">}</span> <span class="ot">(</span>f <span class="ot">:</span> C <span class="ot">‚Üí</span> A<span class="ot">)</span> <span class="ot">{_</span>‚äï<span class="ot">_</span> <span class="ot">:</span> B <span class="ot">‚Üí</span> C <span class="ot">‚Üí</span> C<span class="ot">}</span> <span class="ot">{_</span>‚äó<span class="ot">_</span> <span class="ot">:</span> B <span class="ot">‚Üí</span> A <span class="ot">‚Üí</span> A<span class="ot">}</span> e</a>
<a class="sourceLine" id="cb7-25" data-line-number="25">               <span class="ot">‚Üí</span> ‚àÄ[ <span class="ot">_</span>‚äó<span class="ot">_</span> ‚ä¢ Congruent‚ÇÅ ]</a>
<a class="sourceLine" id="cb7-26" data-line-number="26">               <span class="ot">‚Üí</span> <span class="ot">(‚àÄ</span> x y <span class="ot">‚Üí</span> f <span class="ot">(</span>x ‚äï y<span class="ot">)</span> ‚âà x ‚äó f y<span class="ot">)</span></a>
<a class="sourceLine" id="cb7-27" data-line-number="27">               <span class="ot">‚Üí</span> <span class="ot">‚àÄ</span> xs <span class="ot">‚Üí</span> f <span class="ot">(</span>foldr <span class="ot">_</span>‚äï<span class="ot">_</span> e xs<span class="ot">)</span> ‚âà foldr <span class="ot">_</span>‚äó<span class="ot">_</span> <span class="ot">(</span>f e<span class="ot">)</span> xs</a>
<a class="sourceLine" id="cb7-28" data-line-number="28">  foldr-fusion <span class="ot">_</span>‚óã<span class="ot">_</span> ‚àé h <span class="ot">{</span>f<span class="ot">}</span> <span class="ot">{</span>g<span class="ot">}</span> e g‚ü®<span class="ot">_</span>‚ü© fuse <span class="ot">=</span></a>
<a class="sourceLine" id="cb7-29" data-line-number="29">    foldr-universal <span class="ot">_</span>‚óã<span class="ot">_</span> <span class="ot">(</span>h ‚àò foldr f e<span class="ot">)</span> g <span class="ot">(</span>h e<span class="ot">)</span> g‚ü®<span class="ot">_</span>‚ü© ‚àé <span class="ot">(Œª</span> x xs <span class="ot">‚Üí</span> fuse x <span class="ot">(</span>foldr f e xs<span class="ot">))</span></a></code></pre></div>
<p>We‚Äôre not using the proofs in Agda‚Äôs standard library because these are tied to propositional equality. In other words, instead of using an abstract binary relation, they prove things over <em>actual</em> equality. That‚Äôs all well and good, but as you can see above, we don‚Äôt need propositional equality: we don‚Äôt even need the relation to be an equivalence, we just need transitivity and reflexivity.</p>
<p>After that, we can state precisely what correspondence the tree fold has, and under what conditions it does the same things as a fold:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">module</span> <span class="ot">_</span> <span class="ot">{_</span>*<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">‚Üí</span> A <span class="ot">‚Üí</span> A<span class="ot">}</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  <span class="kw">open</span> TreeFold <span class="ot">_</span>*<span class="ot">_</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3"></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">  treeFoldHom <span class="ot">:</span> Transitive <span class="ot">_</span>‚âà<span class="ot">_</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5">              <span class="ot">‚Üí</span> Reflexive <span class="ot">_</span>‚âà<span class="ot">_</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">              <span class="ot">‚Üí</span> Associative <span class="ot">_</span>*<span class="ot">_</span></a>
<a class="sourceLine" id="cb8-7" data-line-number="7">              <span class="ot">‚Üí</span> RightCongruent <span class="ot">_</span>*<span class="ot">_</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8">              <span class="ot">‚Üí</span> <span class="ot">‚àÄ</span> x xs</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">              <span class="ot">‚Üí</span> ‚¶Ö x , xs ‚¶Ü ‚âà foldr <span class="ot">_</span>*<span class="ot">_</span> x xs</a>
<a class="sourceLine" id="cb8-10" data-line-number="10">  treeFoldHom <span class="ot">_</span>‚óã<span class="ot">_</span> ‚àé assoc *‚ü®<span class="ot">_</span>‚ü© b <span class="ot">=</span> foldr-fusion <span class="ot">_</span>‚óã<span class="ot">_</span> ‚àé ‚ü¶<span class="ot">_</span>‚üß‚Üì ‚ü¶ b ‚üß‚Üë *‚ü®<span class="ot">_</span>‚ü© <span class="ot">(</span>‚äõ-hom zero<span class="ot">)</span></a>
<a class="sourceLine" id="cb8-11" data-line-number="11">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-12" data-line-number="12">    ‚äõ-hom <span class="ot">:</span> <span class="ot">‚àÄ</span> n x xs <span class="ot">‚Üí</span> ‚ü¶ 2^ n √ó x ‚äõ xs ‚üß‚Üì ‚âà x * ‚ü¶ xs ‚üß‚Üì</a>
<a class="sourceLine" id="cb8-13" data-line-number="13">    ‚äõ-hom n x <span class="ot">(</span>2^ suc m √ó y + ‚ü®‚ü©    <span class="ot">)</span> <span class="ot">=</span> ‚àé</a>
<a class="sourceLine" id="cb8-14" data-line-number="14">    ‚äõ-hom n x <span class="ot">(</span>2^ suc m √ó y + ‚ü® ys ‚ü©<span class="ot">)</span> <span class="ot">=</span> ‚àé</a>
<a class="sourceLine" id="cb8-15" data-line-number="15">    ‚äõ-hom n x <span class="ot">(</span>2^ zero  √ó y + ‚ü®‚ü©    <span class="ot">)</span> <span class="ot">=</span> ‚àé</a>
<a class="sourceLine" id="cb8-16" data-line-number="16">    ‚äõ-hom n x <span class="ot">(</span>2^ zero  √ó y + ‚ü® ys ‚ü©<span class="ot">)</span> <span class="ot">=</span> ‚äõ-hom <span class="ot">(</span>suc n<span class="ot">)</span> <span class="ot">(</span>x * y<span class="ot">)</span> ys ‚óã assoc x y ‚ü¶ ys ‚üß‚Üì</a></code></pre></div>
<h1 id="implicit-data-structures">‚ÄúImplicit‚Äù Data Structures</h1>
<p>Consider the following implementation of the tree above in Haskell:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Tree</span> a <span class="fu">=</span> [(<span class="dt">Int</span>,a)]</a>
<a class="sourceLine" id="cb9-2" data-line-number="2"></a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="ot">cons ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">cons (<span class="fu">*</span>) <span class="fu">=</span> cons&#39; <span class="dv">0</span> </a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6">    cons&#39; n x [] <span class="fu">=</span> [(n,x)]</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">    cons&#39; n x ((<span class="dv">0</span>,y)<span class="fu">:</span>ys) <span class="fu">=</span> cons&#39; (n<span class="fu">+</span><span class="dv">1</span>) (x <span class="fu">*</span> y) ys</a>
<a class="sourceLine" id="cb9-8" data-line-number="8">    cons&#39; n x ((m,y)<span class="fu">:</span>ys) <span class="fu">=</span> (n,x) <span class="fu">:</span> (m<span class="fu">-</span><span class="dv">1</span>,y) <span class="fu">:</span> ys</a></code></pre></div>
<p>The <code>cons</code> function ‚Äúincrements‚Äù that list as if it were the bits of a binary number. Now, consider using the <code>merge</code> function from above, in a pattern like this:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">f <span class="fu">=</span> foldr (cons merge <span class="fu">.</span> pure) []</a></code></pre></div>
<p>What does <code>f</code> build? A list of lists, right?</p>
<p>Kind of. That‚Äôs what‚Äôs built in terms of the observable, but what‚Äôs actually stored in memory us a bunch of thunks. The shape of <em>those</em> is what I‚Äôm interested in. We can try and see what they look like by using a data structure that doesn‚Äôt force on merge:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a <span class="fu">=</span> <span class="dt">Leaf</span> a <span class="fu">|</span> <span class="dt">Tree</span> a <span class="fu">:*:</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb11-2" data-line-number="2"></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">f <span class="fu">=</span> foldr (cons (<span class="fu">:*:</span>) <span class="fu">.</span> <span class="dt">Leaf</span>) []</a></code></pre></div>
<p>Using a handy tree-drawing function, we can see what <code>f [1..13]</code> looks like:</p>
<pre><code>[(0,*),(1,*),(0,*)]
    ‚îî1    ‚îÇ ‚îå2  ‚îÇ  ‚îå6
          ‚îÇ‚îå‚î§   ‚îÇ ‚îå‚î§
          ‚îÇ‚îÇ‚îî3  ‚îÇ ‚îÇ‚îî7
          ‚îî‚î§    ‚îÇ‚îå‚î§
           ‚îÇ‚îå4  ‚îÇ‚îÇ‚îÇ‚îå8
           ‚îî‚î§   ‚îÇ‚îÇ‚îî‚î§
            ‚îî5  ‚îÇ‚îÇ ‚îî9
                ‚îî‚î§
                 ‚îÇ ‚îå10
                 ‚îÇ‚îå‚î§
                 ‚îÇ‚îÇ‚îî11
                 ‚îî‚î§
                  ‚îÇ‚îå12
                  ‚îî‚î§
                   ‚îî13</code></pre>
<p>It‚Äôs a binomial heap! It‚Äôs a list of trees, each one contains <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mi>n</mi></msup><annotation encoding="application/x-tex">2^n</annotation></semantics></math> elements. But they‚Äôre not in heap order, you say? Well, as a matter of fact, they <em>are</em>. It just hasn‚Äôt been evaluated yet. Once we force‚Äîsay‚Äîthe first element, the rest will shuffle themselves into a tree of thunks.</p>
<p>This illustrates a pretty interesting similarity between binomial heaps and merge sort. Performance-wise, though, there‚Äôs another interesting property: the thunks <em>stay thunked</em>. In other words, if we do a merge sort via:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1">sort <span class="fu">=</span> foldr (merge <span class="fu">.</span> snd) [] <span class="fu">.</span> foldr (cons merge <span class="fu">.</span> pure) []</a></code></pre></div>
<p>We could instead freeze the fold, and look at it at every point:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1">sortPrefixes <span class="fu">=</span> map (foldr (merge <span class="fu">.</span> snd) []) <span class="fu">.</span> scanl (flip (cons merge <span class="fu">.</span> pure)) []</a>
<a class="sourceLine" id="cb14-2" data-line-number="2"><span class="fu">&gt;&gt;&gt;</span> [[],[<span class="dv">1</span>],[<span class="dv">1</span>,<span class="dv">4</span>],[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">4</span>],[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>],[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>]]</a></code></pre></div>
<p>And <code>sortPrefixes</code> is only <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n^2)</annotation></semantics></math> (rather than <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n^2 \log n)</annotation></semantics></math>). I confess I don‚Äôt know of a use for sorted prefixes, but it should illustrate the general idea: we get a pretty decent batching of operations, with the ability to freeze at any point in time. The other nice property (which I mentioned in the last post) is that any of the tree folds are extremely parallel.</p>
<h1 id="random-shuffles">Random Shuffles</h1>
<p><a href="http://okmij.org/ftp/Haskell/AlgorithmsH.html#perfect-shuffle">There‚Äôs a great article on shuffling in Haskell</a> which provides an <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n \log n)</annotation></semantics></math> implementation of a perfect random shuffle. Unfortunately, the <a href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle">Fisher-Yates shuffle</a> isn‚Äôt applicable in a pure functional setting, so you have to be a little cleverer.</p>
<p>The first implementation most people jump to (certainly the one I thought of) is to assign everything in the sequence a random number, and then sort according to that number. Perhaps surprisingly, this <em>isn‚Äôt</em> perfectly random! It‚Äôs a little weird, but the example in the article explains it well: basically, for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> elements, your random numbers will have <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>n</mi><mi>n</mi></msup><annotation encoding="application/x-tex">n^n</annotation></semantics></math> possible values, but the output of the sort will have <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>!</mi></mrow><annotation encoding="application/x-tex">n!</annotation></semantics></math> possible values. Since they don‚Äôt divide into each other evenly, you‚Äôre going to have some extra weight on some permutations, and less on others.</p>
<p>Instead, we can generate a random <a href="https://en.wikipedia.org/wiki/Factorial_number_system"><em>factoradic</em></a> number. A factoradic number is one where the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>th digit is in base <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>. Because of this, a factoradic number with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> digits has <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>!</mi></mrow><annotation encoding="application/x-tex">n!</annotation></semantics></math> possible values: exactly what we want.</p>
<p>In the article, the digits of the number are used to pop values from a binary tree. Because the last digit will have <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> possible values, and the second last <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>‚àí</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math>, and so on, you can keep popping without hitting an empty tree.</p>
<p>This has the correct time complexity‚Äî<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n \log n)</annotation></semantics></math>‚Äîbut there‚Äôs a lot of overhead. Building the tree, then indexing into it, the rebuilding after each pop, etc.</p>
<p>We‚Äôd <em>like</em> to just sort the list, according to the indices. The problem is that the indices are relative: if you want to <code>cons</code> something onto the list, you have to increment the rest of the indices, as they‚Äôve all shifted right by one.</p>
<p>What we‚Äôll do instead is use the indices as <em>gaps</em>. Our merge function looks like the following:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1">merge [] ys <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">merge xs [] <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">merge ((x,i)<span class="fu">:</span>xs) ((y,j)<span class="fu">:</span>ys)</a>
<a class="sourceLine" id="cb15-4" data-line-number="4">  <span class="fu">|</span> i <span class="fu">&lt;=</span> j    <span class="fu">=</span> (x,i) <span class="fu">:</span> merge xs ((y,j<span class="fu">-</span>i)<span class="fu">:</span>ys)</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">  <span class="fu">|</span> otherwise <span class="fu">=</span> (y,j) <span class="fu">:</span> merge ((x,i<span class="fu">-</span>j<span class="fu">-</span><span class="dv">1</span>)<span class="fu">:</span>xs) ys</a></code></pre></div>
<p>With that, and the same <code>cons</code> as above, we get a very simple random shuffle algorithm:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1">shuffle xs <span class="fu">=</span> map fst</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">           <span class="fu">.</span> foldr (merge <span class="fu">.</span> snd) []</a>
<a class="sourceLine" id="cb16-3" data-line-number="3">           <span class="fu">.</span> foldr f (const []) xs</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-5" data-line-number="5">    f x xs (i<span class="fu">:</span>is) <span class="fu">=</span> cons merge [(x,i)] (xs is)</a></code></pre></div>
<p>The other interesting thing about this algorithm is that it can use Peano numbers with taking too much of a performance hit:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1">merge <span class="fu">:</span> <span class="ot">‚àÄ</span> {a} {<span class="dt">A</span> <span class="fu">:</span> <span class="dt">Set</span> a} <span class="ot">‚Üí</span> <span class="dt">List</span> (<span class="dt">A</span> √ó ‚Ñï) <span class="ot">‚Üí</span> <span class="dt">List</span> (<span class="dt">A</span> √ó ‚Ñï) <span class="ot">‚Üí</span> <span class="dt">List</span> (<span class="dt">A</span> √ó ‚Ñï)</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">merge xs [] <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb17-3" data-line-number="3">merge {<span class="dt">A</span> <span class="fu">=</span> <span class="dt">A</span>} xs ((y , j) <span class="ot">‚à∑</span> ys) <span class="fu">=</span> go<span class="fu">-</span>r xs y j ys</a>
<a class="sourceLine" id="cb17-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb17-5" data-line-number="5">  go<span class="fu">-</span>l <span class="fu">:</span> <span class="dt">A</span> <span class="ot">‚Üí</span> ‚Ñï <span class="ot">‚Üí</span> <span class="dt">List</span> (<span class="dt">A</span> √ó ‚Ñï) <span class="ot">‚Üí</span> <span class="dt">List</span> (<span class="dt">A</span> √ó ‚Ñï) <span class="ot">‚Üí</span> <span class="dt">List</span> (<span class="dt">A</span> √ó ‚Ñï)</a>
<a class="sourceLine" id="cb17-6" data-line-number="6">  go<span class="fu">-</span>r <span class="fu">:</span> <span class="dt">List</span> (<span class="dt">A</span> √ó ‚Ñï) <span class="ot">‚Üí</span> <span class="dt">A</span> <span class="ot">‚Üí</span> ‚Ñï <span class="ot">‚Üí</span> <span class="dt">List</span> (<span class="dt">A</span> √ó ‚Ñï) <span class="ot">‚Üí</span> <span class="dt">List</span> (<span class="dt">A</span> √ó ‚Ñï)</a>
<a class="sourceLine" id="cb17-7" data-line-number="7">  go <span class="fu">:</span> ‚Ñï <span class="ot">‚Üí</span> ‚Ñï <span class="ot">‚Üí</span> <span class="dt">A</span> <span class="ot">‚Üí</span> ‚Ñï <span class="ot">‚Üí</span> <span class="dt">List</span> (<span class="dt">A</span> √ó ‚Ñï) <span class="ot">‚Üí</span> <span class="dt">A</span> <span class="ot">‚Üí</span> ‚Ñï <span class="ot">‚Üí</span> <span class="dt">List</span> (<span class="dt">A</span> √ó ‚Ñï) <span class="ot">‚Üí</span> <span class="dt">List</span> (<span class="dt">A</span> √ó ‚Ñï)</a>
<a class="sourceLine" id="cb17-8" data-line-number="8"></a>
<a class="sourceLine" id="cb17-9" data-line-number="9">  go i     zero   x i‚Ä≤ xs y j‚Ä≤ ys <span class="fu">=</span> (y , j‚Ä≤) <span class="ot">‚à∑</span> go<span class="fu">-</span>l x i xs ys</a>
<a class="sourceLine" id="cb17-10" data-line-number="10">  go zero (suc j) x i‚Ä≤ xs y j‚Ä≤ ys <span class="fu">=</span> (x , i‚Ä≤) <span class="ot">‚à∑</span> go<span class="fu">-</span>r xs y j ys</a>
<a class="sourceLine" id="cb17-11" data-line-number="11">  go (suc i) (suc j) <span class="fu">=</span> go i j</a>
<a class="sourceLine" id="cb17-12" data-line-number="12"></a>
<a class="sourceLine" id="cb17-13" data-line-number="13">  go<span class="fu">-</span>l x i xs [] <span class="fu">=</span> (x , i) <span class="ot">‚à∑</span> xs</a>
<a class="sourceLine" id="cb17-14" data-line-number="14">  go<span class="fu">-</span>l x i xs ((y , j) <span class="ot">‚à∑</span> ys) <span class="fu">=</span> go i j x i xs y j ys</a>
<a class="sourceLine" id="cb17-15" data-line-number="15"></a>
<a class="sourceLine" id="cb17-16" data-line-number="16">  go<span class="fu">-</span>r [] y j ys <span class="fu">=</span> (y , j) <span class="ot">‚à∑</span> ys</a>
<a class="sourceLine" id="cb17-17" data-line-number="17">  go<span class="fu">-</span>r ((x , i) <span class="ot">‚à∑</span> xs) y j ys <span class="fu">=</span> go i j x i xs y j ys</a>
<a class="sourceLine" id="cb17-18" data-line-number="18"></a>
<a class="sourceLine" id="cb17-19" data-line-number="19">shuffle <span class="fu">:</span> <span class="ot">‚àÄ</span> {a} {<span class="dt">A</span> <span class="fu">:</span> <span class="dt">Set</span> a} <span class="ot">‚Üí</span> <span class="dt">List</span> <span class="dt">A</span> <span class="ot">‚Üí</span> <span class="dt">List</span> ‚Ñï <span class="ot">‚Üí</span> <span class="dt">List</span> <span class="dt">A</span></a>
<a class="sourceLine" id="cb17-20" data-line-number="20">shuffle {a} {<span class="dt">A</span>} xs i <span class="fu">=</span> map proj‚ÇÅ (‚¶Ö [] , zip<span class="fu">-</span>inds xs i ‚¶Ü)</a>
<a class="sourceLine" id="cb17-21" data-line-number="21">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb17-22" data-line-number="22">  open <span class="dt">TreeFold</span> {a} {<span class="dt">List</span> (<span class="dt">A</span> √ó ‚Ñï)} merge</a>
<a class="sourceLine" id="cb17-23" data-line-number="23"></a>
<a class="sourceLine" id="cb17-24" data-line-number="24">  zip<span class="fu">-</span>inds <span class="fu">:</span> <span class="dt">List</span> <span class="dt">A</span> <span class="ot">‚Üí</span> <span class="dt">List</span> ‚Ñï <span class="ot">‚Üí</span> <span class="dt">List</span> (<span class="dt">List</span> (<span class="dt">A</span> √ó ‚Ñï))</a>
<a class="sourceLine" id="cb17-25" data-line-number="25">  zip<span class="fu">-</span>inds [] inds <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb17-26" data-line-number="26">  zip<span class="fu">-</span>inds (x <span class="ot">‚à∑</span> xs) [] <span class="fu">=</span> ((x , <span class="dv">0</span>) <span class="ot">‚à∑</span> []) <span class="ot">‚à∑</span> zip<span class="fu">-</span>inds xs []</a>
<a class="sourceLine" id="cb17-27" data-line-number="27">  zip<span class="fu">-</span>inds (x <span class="ot">‚à∑</span> xs) (i <span class="ot">‚à∑</span> inds) <span class="fu">=</span> ((x , i) <span class="ot">‚à∑</span> []) <span class="ot">‚à∑</span> zip<span class="fu">-</span>inds xs inds</a></code></pre></div>
<p>I don‚Äôt know exactly what the complexity of this is, but I <em>think</em> it should be better than the usual approach of popping from a vector.</p>
<h1 id="future-stuff">Future Stuff</h1>
<p>This is just a collection of random thoughts for now, but I intend to work on using these folds to see if there are any other algorithms they can be useful for. In particular, I think I can write a version of Data.List.permutations which benefits from sharing. And I‚Äôm interested in using the implicit binomial heap for some search problems.</p>
]]></description>
    <pubDate>Fri, 21 Dec 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-12-21-balancing-scans.html</guid>
    <dc:creator>Donnacha Ois√≠n Kidney</dc:creator>
</item>
<item>
    <title>Pure and Lazy Breadth-First Traversals of Graphs in Haskell</title>
    <link>https://doisinkidney.com/posts/2018-12-18-traversing-graphs.html</link>
    <description><![CDATA[<div class="info">
    Posted on December 18, 2018
</div>
<div class="info">
    
        Part 5 of a <a href="/series/Breadth-First%20Traversals.html">5-part series on Breadth-First Traversals</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<p>Today, I‚Äôm going to look at extending the previous breadth-first traversal algorithms to arbitrary graphs (rather than just trees). Graphs with cycles are notoriously cumbersome in functional languages, so this actually proves to be a little trickier than I thought it would be. First, a quick recap.</p>
<h1 id="ways-to-breadth-first-search">3 Ways to Breadth-First Search</h1>
<p>So far, we have three major ways to traverse a tree in breadth-first order. The first is the simplest, and the fastest:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">bfe ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">bfe r <span class="fu">=</span> f r b []</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">    f (<span class="dt">Node</span> x xs) fw bw <span class="fu">=</span> x <span class="fu">:</span> fw (xs <span class="fu">:</span> bw)</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">  </a>
<a class="sourceLine" id="cb1-6" data-line-number="6">    b [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb1-7" data-line-number="7">    b qs <span class="fu">=</span> foldl (foldr f) b qs []</a></code></pre></div>
<p>Given a tree like the following:</p>
<pre><code>   ‚îå4
 ‚îå2‚î§
 ‚îÇ ‚îÇ ‚îå8
 ‚îÇ ‚îî5‚î§
 ‚îÇ   ‚îî9
1‚î§
 ‚îÇ   ‚îå10
 ‚îÇ ‚îå6‚îò
 ‚îî3‚î§
   ‚îî7</code></pre>
<p>We get:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> bfe tree</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>]</a></code></pre></div>
<p>It also demonstrates a theme that will run through this post: lists are the only <em>visible</em> data structure (other than the tree, of course). However, we are carefully batching the operations on those lists (the <code>foldl</code> is effectively a reverse) so that they have the same complexity as if we had used a queue. In actual fact, when lists are used this way, they <em>are</em> queues: ‚Äúcorecursive‚Äù ones <span class="citation" data-cites="allison_circular_2006 smith_lloyd_2009">(Allison <a href="#ref-allison_circular_2006">2006</a>; Smith <a href="#ref-smith_lloyd_2009">2009</a>)</span>.</p>
<p>The next two functions perform a breadth-first traversal ‚Äúlevel-wise‚Äù: instead of just returning all the nodes of the tree, we get them delimited by how far they are from the root.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">lwe ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">lwe r <span class="fu">=</span> f b r [] []</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">    f k (<span class="dt">Node</span> x xs) ls qs <span class="fu">=</span> k (x <span class="fu">:</span> ls) (xs <span class="fu">:</span> qs)</a>
<a class="sourceLine" id="cb4-5" data-line-number="5"></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">    b _ [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb4-7" data-line-number="7">    b k qs <span class="fu">=</span> k <span class="fu">:</span> foldl (foldl f) b qs [] []</a>
<a class="sourceLine" id="cb4-8" data-line-number="8"></a>
<a class="sourceLine" id="cb4-9" data-line-number="9"><span class="fu">&gt;&gt;&gt;</span> lwe tree</a>
<a class="sourceLine" id="cb4-10" data-line-number="10">[[<span class="dv">1</span>],[<span class="dv">2</span>,<span class="dv">3</span>],[<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>],[<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>]]</a></code></pre></div>
<p>The above function is very clearly related to the <code>bfe</code> function: we just add another queue (representing the current level), and work from there.</p>
<p>The third of these functions also does level-wise enumeration, but in a direct style (without continuations).</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">lwe ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">lwe r <span class="fu">=</span> f r []</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">    f (<span class="dt">Node</span> x xs) (q<span class="fu">:</span>qs) <span class="fu">=</span> (x<span class="fu">:</span>q) <span class="fu">:</span> foldr f qs xs</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">    f (<span class="dt">Node</span> x xs) []     <span class="fu">=</span> [x]   <span class="fu">:</span> foldr f [] xs</a></code></pre></div>
<p>There are more techniques out there than just these three (including the one in <a href="http://hackage.haskell.org/package/containers-0.6.0.1/docs/Data-Tree.html#v:levels">Data.Tree</a>), but these are my favorite, and they‚Äôre what I‚Äôll be looking at today.</p>
<h1 id="graphs-and-purity">Graphs and Purity</h1>
<p>Functional programming in general excels at working with trees and similar data structures. Graphs, though, are trickier. There‚Äôs been a lot of recent work in improving the situation <span class="citation" data-cites="mokhov_algebraic_2017">(Mokhov <a href="#ref-mokhov_algebraic_2017">2017</a>)</span>, but I‚Äôm going to keep it simple today: a graph is just a function.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Graph</span> a <span class="fu">=</span> a <span class="ot">-&gt;</span> [a]</a></code></pre></div>
<p>So the tree from above could be represented as:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1">graph <span class="dv">1</span> <span class="fu">=</span> [<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">graph <span class="dv">2</span> <span class="fu">=</span> [<span class="dv">4</span>,<span class="dv">5</span>]</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">graph <span class="dv">3</span> <span class="fu">=</span> [<span class="dv">6</span>,<span class="dv">7</span>]</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">graph <span class="dv">5</span> <span class="fu">=</span> [<span class="dv">8</span>,<span class="dv">9</span>]</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">graph <span class="dv">6</span> <span class="fu">=</span> [<span class="dv">10</span>]</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">graph _ <span class="fu">=</span> []</a></code></pre></div>
<p>As it happens, all of the algorithms that follow will work on graphs represented as rose trees (or represented any way, really).</p>
<p>So let‚Äôs fire up our first traversal!</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">bfs ::</span> <span class="dt">Graph</span> a <span class="ot">-&gt;</span> <span class="dt">Graph</span> a</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">bfs g r <span class="fu">=</span> f r b []</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">    f x fw bw <span class="fu">=</span> x <span class="fu">:</span> fw (g x <span class="fu">:</span> bw)</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">  </a>
<a class="sourceLine" id="cb8-6" data-line-number="6">    b [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">    b qs <span class="fu">=</span> foldl (foldr f) b qs []</a>
<a class="sourceLine" id="cb8-8" data-line-number="8">    </a>
<a class="sourceLine" id="cb8-9" data-line-number="9"><span class="fu">&gt;&gt;&gt;</span> bfs graph <span class="dv">1</span></a>
<a class="sourceLine" id="cb8-10" data-line-number="10">[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>]</a></code></pre></div>
<p>Unfortunately, this won‚Äôt handle cycles properly:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1">graph <span class="dv">1</span> <span class="fu">=</span> [<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">graph <span class="dv">2</span> <span class="fu">=</span> [<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">graph <span class="dv">3</span> <span class="fu">=</span> [<span class="dv">6</span>,<span class="dv">7</span>]</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">graph <span class="dv">5</span> <span class="fu">=</span> [<span class="dv">8</span>,<span class="dv">9</span>]</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">graph <span class="dv">6</span> <span class="fu">=</span> [<span class="dv">10</span>]</a>
<a class="sourceLine" id="cb9-6" data-line-number="6">graph _ <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb9-7" data-line-number="7"></a>
<a class="sourceLine" id="cb9-8" data-line-number="8"><span class="fu">&gt;&gt;&gt;</span> bfs graph <span class="dv">1</span></a>
<a class="sourceLine" id="cb9-9" data-line-number="9">[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">1</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">10</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">1</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">10</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">1</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">10</span>,<span class="dv">4</span>,<span class="dv">5</span><span class="fu">...</span></a></code></pre></div>
<p>We need a way to mark off what we‚Äôve already seen. The following isn‚Äôt good enough, also:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> nub (bfs graph <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span><span class="fu">...</span></a></code></pre></div>
<p>It will hang without finishing the list. The solution is to mark off nodes as we find them, with some set structure:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">bfs ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Graph</span> a <span class="ot">-&gt;</span> <span class="dt">Graph</span> a</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">bfs g ts <span class="fu">=</span> f ts b [] Set.empty</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4">    f x fw bw s</a>
<a class="sourceLine" id="cb11-5" data-line-number="5">      <span class="fu">|</span> Set.member x s <span class="fu">=</span> fw bw s</a>
<a class="sourceLine" id="cb11-6" data-line-number="6">      <span class="fu">|</span> otherwise      <span class="fu">=</span> x <span class="fu">:</span> fw (g x <span class="fu">:</span> bw) (Set.insert x s)</a>
<a class="sourceLine" id="cb11-7" data-line-number="7"></a>
<a class="sourceLine" id="cb11-8" data-line-number="8">    b [] _ <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb11-9" data-line-number="9">    b qs s <span class="fu">=</span> foldl (foldr f) b qs [] s</a>
<a class="sourceLine" id="cb11-10" data-line-number="10"></a>
<a class="sourceLine" id="cb11-11" data-line-number="11"><span class="fu">&gt;&gt;&gt;</span> bfs graph <span class="dv">1</span></a>
<a class="sourceLine" id="cb11-12" data-line-number="12">[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>]</a></code></pre></div>
<p>The levelwise algorithm is similar:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="ot">lws ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Graph</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [[a]] </a>
<a class="sourceLine" id="cb12-2" data-line-number="2">lws g r <span class="fu">=</span> f b r [] [] Set.empty</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">    f k x ls qs s</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">      <span class="fu">|</span> Set.member x s <span class="fu">=</span> k ls qs s</a>
<a class="sourceLine" id="cb12-6" data-line-number="6">      <span class="fu">|</span> otherwise <span class="fu">=</span> k (x <span class="fu">:</span> ls) (g x <span class="fu">:</span> qs) (Set.insert x s)</a>
<a class="sourceLine" id="cb12-7" data-line-number="7"></a>
<a class="sourceLine" id="cb12-8" data-line-number="8">    b _ [] _ <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb12-9" data-line-number="9">    b k qs s <span class="fu">=</span> k <span class="fu">:</span> foldl (foldl f) b qs [] [] s</a></code></pre></div>
<h1 id="tying-the-knot">Tying the Knot</h1>
<p>The other levelwise algorithm <em>doesn‚Äôt</em> translate across so easily. To see why, let‚Äôs look at the version without cycle detection:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="ot">lws ::</span> <span class="dt">Graph</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">lws g r <span class="fu">=</span> f r []</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4">    f x (q<span class="fu">:</span>qs) <span class="fu">=</span> (x<span class="fu">:</span>q) <span class="fu">:</span> foldr f qs (g x)</a>
<a class="sourceLine" id="cb13-5" data-line-number="5">    f x []     <span class="fu">=</span> [x]   <span class="fu">:</span> foldr f [] (g x)</a></code></pre></div>
<p>The recursive call is being made <em>depth</em>-first, not breadth-first. The result, of course, is breadth-first, but that‚Äôs only because the recursive call zips as it goes.</p>
<p>Just looking at the fourth line for now:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1">f x (q<span class="fu">:</span>qs) <span class="fu">=</span> (x<span class="fu">:</span>q) <span class="fu">:</span> foldr f qs (g x)</a></code></pre></div>
<p>We want whatever process built up that <code>q</code> to be denied access to <code>x</code>. The following doesn‚Äôt work:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1">f x (q<span class="fu">:</span>qs) <span class="fu">=</span> (x<span class="fu">:</span>filter (x<span class="fu">/=</span>) q) <span class="fu">:</span> foldr f qs (g x)</a></code></pre></div>
<p>As well as being terribly slow, the later computation can diverge when it finds a cycle, and filtering won‚Äôt do anything to help that.</p>
<p>The solution is to ‚Äútie the knot‚Äù. We basically do two passes over the data: one to build up the ‚Äúseen so far‚Äù list, and then another to do the actual search. The trick is to do both of these passes at once, and feed the result back into the demanding computation.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1">lws g r <span class="fu">=</span> takeWhile (not<span class="fu">.</span>null) (map fst (fix (f r <span class="fu">.</span> push)))</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3">    push xs <span class="fu">=</span> ([],Set.empty) <span class="fu">:</span> [ ([],seen) <span class="fu">|</span> (_,seen) <span class="ot">&lt;-</span> xs ]</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">    f x q<span class="fu">@</span>((l,s)<span class="fu">:</span>qs)</a>
<a class="sourceLine" id="cb16-5" data-line-number="5">      <span class="fu">|</span> Set.member x s <span class="fu">=</span> q</a>
<a class="sourceLine" id="cb16-6" data-line-number="6">      <span class="fu">|</span> otherwise <span class="fu">=</span> (x<span class="fu">:</span>l, Set.insert x s) <span class="fu">:</span> foldr f qs (g x)</a></code></pre></div>
<p>And it works!</p>
<p>I got the idea for this trick from the appendix of <span class="citation" data-cites="okasaki_breadth-first_2000">Okasaki (<a href="#ref-okasaki_breadth-first_2000">2000</a>)</span>. There‚Äôs something similar in <span class="citation" data-cites="kiselyov_pure-functional_2002">Kiselyov (<a href="#ref-kiselyov_pure-functional_2002">2002</a>)</span>.</p>
<hr />
<h1 id="references" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-allison_circular_2006">
<p>Allison, Lloyd. 2006. ‚ÄúCircular Programs and Self-Referential Structures.‚Äù <em>Software: Practice and Experience</em> 19 (2) (October): 99‚Äì109. doi:<a href="https://doi.org/10.1002/spe.4380190202">10.1002/spe.4380190202</a>.</p>
</div>
<div id="ref-kiselyov_pure-functional_2002">
<p>Kiselyov, Oleg. 2002. ‚ÄúPure-functional transformations of cyclic graphs and the Credit Card Transform.‚Äù <a href="http://okmij.org/ftp/Haskell/AlgorithmsH.html#ccard-transform" class="uri">http://okmij.org/ftp/Haskell/AlgorithmsH.html#ccard-transform</a>.</p>
</div>
<div id="ref-mokhov_algebraic_2017">
<p>Mokhov, Andrey. 2017. ‚ÄúAlgebraic Graphs with Class (Functional Pearl).‚Äù In <em>Proceedings of the 10th ACM SIGPLAN International Symposium on Haskell</em>, 2‚Äì13. Haskell 2017. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/3122955.3122956">10.1145/3122955.3122956</a>.</p>
</div>
<div id="ref-okasaki_breadth-first_2000">
<p>Okasaki, Chris. 2000. ‚ÄúBreadth-first Numbering: Lessons from a Small Exercise in Algorithm Design.‚Äù In <em>Proceedings of the Fifth ACM SIGPLAN International Conference on Functional Programming</em>, 131‚Äì136. ICFP ‚Äô00. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/351240.351253">10.1145/351240.351253</a>.</p>
</div>
<div id="ref-smith_lloyd_2009">
<p>Smith, Leon P. 2009. ‚ÄúLloyd Allison‚Äôs Corecursive Queues: Why Continuations Matter.‚Äù <em>The Monad.Reader</em> 14 (14) (July): 28.</p>
</div>
</div>
]]></description>
    <pubDate>Tue, 18 Dec 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-12-18-traversing-graphs.html</guid>
    <dc:creator>Donnacha Ois√≠n Kidney</dc:creator>
</item>
<item>
    <title>Prime Sieves in Agda</title>
    <link>https://doisinkidney.com/posts/2018-12-14-primes-in-agda.html</link>
    <description><![CDATA[<div class="info">
    Posted on December 14, 2018
</div>
<div class="info">
    
        Part 2 of a <a href="/series/Prime%20Sieves.html">2-part series on Prime Sieves</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Agda.html">Agda</a>
    
</div>

<p>Prime numbers in Agda are <em>slow</em>. First, they‚Äôre Peano-based, so a huge chunk of optimizations we might make in other languages are out of the window. Second, we really often want to <em>prove</em> that they‚Äôre prime, so the generation code has to carry verification logic with it (I won‚Äôt do that today, though). And third, as always in Agda, you have to convince the compiler of termination. With all of that in mind, let‚Äôs try and write a (very slow, very basic) prime sieve in Agda.</p>
<p>First, we can make an ‚Äúarray‚Äù of numbers that we cross off as we go.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb1-1" data-line-number="1">primes <span class="ot">:</span> <span class="ot">‚àÄ</span> n <span class="ot">‚Üí</span> List <span class="ot">(</span>Fin n<span class="ot">)</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">primes zero <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">primes <span class="ot">(</span>suc zero<span class="ot">)</span> <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">primes <span class="ot">(</span>suc <span class="ot">(</span>suc zero<span class="ot">))</span> <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">primes <span class="ot">(</span>suc <span class="ot">(</span>suc <span class="ot">(</span>suc m<span class="ot">)))</span> <span class="ot">=</span> sieve <span class="ot">(</span>tabulate <span class="ot">(</span>just ‚àò Fin<span class="ot">.</span>suc<span class="ot">))</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">  cross-off <span class="ot">:</span> Fin <span class="ot">_</span> <span class="ot">‚Üí</span> List <span class="ot">(</span>Maybe <span class="ot">(</span>Fin <span class="ot">_))</span> <span class="ot">‚Üí</span> List <span class="ot">(</span>Maybe <span class="ot">(</span>Fin <span class="ot">_))</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"></a>
<a class="sourceLine" id="cb1-9" data-line-number="9">  sieve <span class="ot">:</span> List <span class="ot">(</span>Maybe <span class="ot">(</span>Fin <span class="ot">_))</span> <span class="ot">‚Üí</span> List <span class="ot">(</span>Fin <span class="ot">_)</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10">  sieve [] <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb1-11" data-line-number="11">  sieve <span class="ot">(</span>nothing ‚à∑ xs<span class="ot">)</span> <span class="ot">=</span>         sieve xs</a>
<a class="sourceLine" id="cb1-12" data-line-number="12">  sieve <span class="ot">(</span>just x  ‚à∑ xs<span class="ot">)</span> <span class="ot">=</span> suc x ‚à∑ sieve <span class="ot">(</span>cross-off x xs<span class="ot">)</span></a>
<a class="sourceLine" id="cb1-13" data-line-number="13"></a>
<a class="sourceLine" id="cb1-14" data-line-number="14">  cross-off p fs <span class="ot">=</span> foldr f <span class="ot">(</span>const []<span class="ot">)</span> fs p</a>
<a class="sourceLine" id="cb1-15" data-line-number="15">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-16" data-line-number="16">    B <span class="ot">=</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">‚Üí</span> Fin i <span class="ot">‚Üí</span> List <span class="ot">(</span>Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">2</span> + m<span class="ot">)))</span></a>
<a class="sourceLine" id="cb1-17" data-line-number="17"></a>
<a class="sourceLine" id="cb1-18" data-line-number="18">    f <span class="ot">:</span> Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">2</span> + m<span class="ot">))</span> <span class="ot">‚Üí</span> B <span class="ot">‚Üí</span> B</a>
<a class="sourceLine" id="cb1-19" data-line-number="19">    f <span class="ot">_</span> xs zero    <span class="ot">=</span> nothing ‚à∑ xs p</a>
<a class="sourceLine" id="cb1-20" data-line-number="20">    f x xs <span class="ot">(</span>suc y<span class="ot">)</span> <span class="ot">=</span> x       ‚à∑ xs y</a></code></pre></div>
<p>Very simple so far: we run through the list, filtering out the multiples of each prime as we see it. Unfortunately, this won‚Äôt pass the termination checker. This recursive call to <code>sieve</code> is the problem:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb2-1" data-line-number="1">sieve <span class="ot">(</span>just x ‚à∑ xs<span class="ot">)</span> <span class="ot">=</span> suc x ‚à∑ sieve <span class="ot">(</span>cross-off x xs<span class="ot">)</span></a></code></pre></div>
<p>Agda finds if a function is terminating by checking that at least one argument gets (structurally) smaller on every recursive call. <code>sieve</code> only takes one argument (the input list), so that‚Äôs the one that needs to get smaller. In the line above, if we replaced it with the following:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb3-1" data-line-number="1">sieve <span class="ot">(</span>just x ‚à∑ xs<span class="ot">)</span> <span class="ot">=</span> suc x ‚à∑ sieve xs</a></code></pre></div>
<p>We‚Äôd be good to go: <code>xs</code> is definitely smaller than <code>(just x ‚à∑ xs)</code>. <code>cross-off x xs</code>, though? The thing is, <code>cross-off</code> returns a list of the same length that it‚Äôs given. But the function call is opaque: Agda can‚Äôt automatically see the fact that the length stays the same. Reaching for a proof here is the wrong move, though: you can get all of the same benefit by switching out the list for a length-indexed vector.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb4-1" data-line-number="1">primes <span class="ot">:</span> <span class="ot">‚àÄ</span> n <span class="ot">‚Üí</span> List <span class="ot">(</span>Fin n<span class="ot">)</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">primes zero <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">primes <span class="ot">(</span>suc zero<span class="ot">)</span> <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">primes <span class="ot">(</span>suc <span class="ot">(</span>suc zero<span class="ot">))</span> <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">primes <span class="ot">(</span>suc <span class="ot">(</span>suc <span class="ot">(</span>suc m<span class="ot">)))</span> <span class="ot">=</span> sieve <span class="ot">(</span>tabulate <span class="ot">(</span>just ‚àò Fin<span class="ot">.</span>suc<span class="ot">))</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7">  cross-off <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">‚Üí</span> Fin <span class="ot">_</span> <span class="ot">‚Üí</span> Vec <span class="ot">(</span>Maybe <span class="ot">_)</span> n <span class="ot">‚Üí</span> Vec <span class="ot">(</span>Maybe <span class="ot">_)</span> n</a>
<a class="sourceLine" id="cb4-8" data-line-number="8"></a>
<a class="sourceLine" id="cb4-9" data-line-number="9">  sieve <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">‚Üí</span>  Vec <span class="ot">(</span>Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">2</span> + m<span class="ot">)))</span> n <span class="ot">‚Üí</span> List <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">3</span> + m<span class="ot">))</span></a>
<a class="sourceLine" id="cb4-10" data-line-number="10">  sieve [] <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb4-11" data-line-number="11">  sieve <span class="ot">(</span>nothing ‚à∑ xs<span class="ot">)</span> <span class="ot">=</span>         sieve xs</a>
<a class="sourceLine" id="cb4-12" data-line-number="12">  sieve <span class="ot">(</span>just x  ‚à∑ xs<span class="ot">)</span> <span class="ot">=</span> suc x ‚à∑ sieve <span class="ot">(</span>cross-off x xs<span class="ot">)</span></a>
<a class="sourceLine" id="cb4-13" data-line-number="13"></a>
<a class="sourceLine" id="cb4-14" data-line-number="14">  cross-off p fs <span class="ot">=</span> foldr B f <span class="ot">(</span>const []<span class="ot">)</span> fs p</a>
<a class="sourceLine" id="cb4-15" data-line-number="15">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-16" data-line-number="16">    B <span class="ot">=</span> <span class="ot">Œª</span> n <span class="ot">‚Üí</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">‚Üí</span> Fin i <span class="ot">‚Üí</span> Vec <span class="ot">(</span>Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">2</span> + m<span class="ot">)))</span> n</a>
<a class="sourceLine" id="cb4-17" data-line-number="17"></a>
<a class="sourceLine" id="cb4-18" data-line-number="18">    f <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">‚Üí</span> Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">2</span> + m<span class="ot">))</span> <span class="ot">‚Üí</span> B n <span class="ot">‚Üí</span> B <span class="ot">(</span>suc n<span class="ot">)</span></a>
<a class="sourceLine" id="cb4-19" data-line-number="19">    f <span class="ot">_</span> xs zero    <span class="ot">=</span> nothing ‚à∑ xs p</a>
<a class="sourceLine" id="cb4-20" data-line-number="20">    f x xs <span class="ot">(</span>suc y<span class="ot">)</span> <span class="ot">=</span> x       ‚à∑ xs y</a></code></pre></div>
<p>Actually, my explanation above is a little bit of a lie. Often, the way I think about dependently-typed programs has a lot to do with my intuition for ‚Äúproofs‚Äù and so on. But this leads you down the wrong path (and it‚Äôs why writing a proof that <code>cross-off</code> returns a list of the same length is the wrong move).</p>
<p>The actual termination checking algorithm is very simple, albeit strict: the argument passed recursively must be <em>structurally</em> smaller. That‚Äôs it. Basically, the recursive argument has to be contained in one of the arguments passed. It has nothing to do with Agda ‚Äúseeing‚Äù inside the function <code>cross-off</code> or anything like that. What we‚Äôve done above (to make it terminate) is add another argument to the function: the length of the vector. The argument is implicit, but if we were to make it explicit in the recursive call:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb5-1" data-line-number="1">sieve <span class="ot">{</span>suc n<span class="ot">}</span> <span class="ot">(</span>just x  ‚à∑ xs<span class="ot">)</span> <span class="ot">=</span> suc x ‚à∑ sieve <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">(</span>cross-off x xs<span class="ot">)</span></a></code></pre></div>
<p>We can see that it does indeed get structurally smaller.</p>
<h1 id="adding-the-squaring-optimization">Adding the Squaring Optimization</h1>
<p>A simple improvement we should be able to make is stopping once we hit the square root of the limit. Since we don‚Äôt want to be squaring as we go, we‚Äôll use the following identity:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><msup><mo stretchy="false" form="postfix">)</mo><mn>2</mn></msup><mo>=</mo><msup><mi>n</mi><mn>2</mn></msup><mo>+</mo><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">(n + 1)^2 = n^2 + 2n + 1</annotation></semantics></math></p>
<p>to figure out the square of the next number from the previous. In fact, we‚Äôll just pass in the limit, and reduce it by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2n + 1</annotation></semantics></math> each time, until it reaches zero:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb6-1" data-line-number="1">primes <span class="ot">:</span> <span class="ot">‚àÄ</span> n <span class="ot">‚Üí</span> List <span class="ot">(</span>Fin n<span class="ot">)</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">primes zero <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">primes <span class="ot">(</span>suc zero<span class="ot">)</span> <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">primes <span class="ot">(</span>suc <span class="ot">(</span>suc zero<span class="ot">))</span> <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">primes <span class="ot">(</span>suc <span class="ot">(</span>suc <span class="ot">(</span>suc m<span class="ot">)))</span> <span class="ot">=</span> sieve <span class="dv">1</span> m <span class="ot">(</span>Vec<span class="ot">.</span>tabulate <span class="ot">(</span>just ‚àò Fin<span class="ot">.</span>suc ‚àò Fin<span class="ot">.</span>suc<span class="ot">))</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-7" data-line-number="7">  cross-off <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">‚Üí</span> ‚Ñï <span class="ot">‚Üí</span> Vec <span class="ot">(</span>Maybe <span class="ot">_)</span> n <span class="ot">‚Üí</span> Vec <span class="ot">(</span>Maybe <span class="ot">_)</span> n</a>
<a class="sourceLine" id="cb6-8" data-line-number="8"></a>
<a class="sourceLine" id="cb6-9" data-line-number="9">  sieve <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">‚Üí</span> ‚Ñï <span class="ot">‚Üí</span> ‚Ñï <span class="ot">‚Üí</span> Vec <span class="ot">(</span>Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">3</span> + m<span class="ot">)))</span> n <span class="ot">‚Üí</span> List <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">3</span> + m<span class="ot">))</span></a>
<a class="sourceLine" id="cb6-10" data-line-number="10">  sieve <span class="ot">_</span> zero <span class="ot">=</span> List<span class="ot">.</span>mapMaybe id ‚àò Vec<span class="ot">.</span>toList</a>
<a class="sourceLine" id="cb6-11" data-line-number="11">  sieve <span class="ot">_</span> <span class="ot">(</span>suc <span class="ot">_)</span> [] <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb6-12" data-line-number="12">  sieve i <span class="ot">(</span>suc l<span class="ot">)</span> <span class="ot">(</span>nothing ‚à∑ xs<span class="ot">)</span> <span class="ot">=</span>     sieve <span class="ot">(</span>suc i<span class="ot">)</span> <span class="ot">(</span>l ‚à∏ i ‚à∏ i<span class="ot">)</span> xs</a>
<a class="sourceLine" id="cb6-13" data-line-number="13">  sieve i <span class="ot">(</span>suc l<span class="ot">)</span> <span class="ot">(</span>just x  ‚à∑ xs<span class="ot">)</span> <span class="ot">=</span> x ‚à∑ sieve <span class="ot">(</span>suc i<span class="ot">)</span> <span class="ot">(</span>l ‚à∏ i ‚à∏ i<span class="ot">)</span> <span class="ot">(</span>cross-off i xs<span class="ot">)</span></a>
<a class="sourceLine" id="cb6-14" data-line-number="14"></a>
<a class="sourceLine" id="cb6-15" data-line-number="15">  cross-off p fs <span class="ot">=</span> Vec<span class="ot">.</span>foldr B f <span class="ot">(</span>const []<span class="ot">)</span> fs p</a>
<a class="sourceLine" id="cb6-16" data-line-number="16">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-17" data-line-number="17">      B <span class="ot">=</span> <span class="ot">Œª</span> n <span class="ot">‚Üí</span> ‚Ñï <span class="ot">‚Üí</span> Vec <span class="ot">(</span>Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">3</span> + m<span class="ot">)))</span> n</a>
<a class="sourceLine" id="cb6-18" data-line-number="18"></a>
<a class="sourceLine" id="cb6-19" data-line-number="19">      f <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">‚Üí</span> Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">3</span> + m<span class="ot">))</span> <span class="ot">‚Üí</span> B i <span class="ot">‚Üí</span> B <span class="ot">(</span>suc i<span class="ot">)</span></a>
<a class="sourceLine" id="cb6-20" data-line-number="20">      f <span class="ot">_</span> xs zero    <span class="ot">=</span> nothing ‚à∑ xs p</a>
<a class="sourceLine" id="cb6-21" data-line-number="21">      f x xs <span class="ot">(</span>suc y<span class="ot">)</span> <span class="ot">=</span> x       ‚à∑ xs y</a></code></pre></div>
<h1 id="finding-prime-factors">Finding Prime Factors</h1>
<p>A slight variation on the code above (the first version) will give us the prime factors of a number:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb7-1" data-line-number="1">primeFactors <span class="ot">:</span> <span class="ot">‚àÄ</span> n <span class="ot">‚Üí</span> List <span class="ot">(</span>Fin n<span class="ot">)</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">primeFactors zero <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">primeFactors <span class="ot">(</span>suc zero<span class="ot">)</span> <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">primeFactors <span class="ot">(</span>suc <span class="ot">(</span>suc zero<span class="ot">))</span> <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">primeFactors <span class="ot">(</span>suc <span class="ot">(</span>suc <span class="ot">(</span>suc m<span class="ot">)))</span> <span class="ot">=</span> sieve <span class="ot">(</span>Vec<span class="ot">.</span>tabulate <span class="ot">(</span>just ‚àò Fin<span class="ot">.</span>suc<span class="ot">))</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-7" data-line-number="7">  sieve <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">‚Üí</span> Vec <span class="ot">(</span>Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">2</span> + m<span class="ot">)))</span> n <span class="ot">‚Üí</span> List <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">3</span> + m<span class="ot">))</span></a>
<a class="sourceLine" id="cb7-8" data-line-number="8">  sieve [] <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb7-9" data-line-number="9">  sieve <span class="ot">(</span>nothing ‚à∑ xs<span class="ot">)</span> <span class="ot">=</span> sieve xs</a>
<a class="sourceLine" id="cb7-10" data-line-number="10">  sieve <span class="ot">(</span>just x  ‚à∑ xs<span class="ot">)</span> <span class="ot">=</span> Vec<span class="ot">.</span>foldr B remove b xs sieve x</a>
<a class="sourceLine" id="cb7-11" data-line-number="11">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-12" data-line-number="12">    B <span class="ot">=</span> <span class="ot">Œª</span> n <span class="ot">‚Üí</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>i<span class="ot">}</span></a>
<a class="sourceLine" id="cb7-13" data-line-number="13">            <span class="ot">‚Üí</span> <span class="ot">(</span>Vec <span class="ot">(</span>Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">2</span> + m<span class="ot">)))</span> n</a>
<a class="sourceLine" id="cb7-14" data-line-number="14">            <span class="ot">‚Üí</span> List <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">3</span> + m<span class="ot">)))</span></a>
<a class="sourceLine" id="cb7-15" data-line-number="15">            <span class="ot">‚Üí</span> Fin i</a>
<a class="sourceLine" id="cb7-16" data-line-number="16">            <span class="ot">‚Üí</span> List <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">3</span> + m<span class="ot">))</span></a>
<a class="sourceLine" id="cb7-17" data-line-number="17"></a>
<a class="sourceLine" id="cb7-18" data-line-number="18">    b <span class="ot">:</span> B <span class="dv">0</span></a>
<a class="sourceLine" id="cb7-19" data-line-number="19">    b k zero    <span class="ot">=</span> suc x ‚à∑ k []</a>
<a class="sourceLine" id="cb7-20" data-line-number="20">    b k <span class="ot">(</span>suc <span class="ot">_)</span> <span class="ot">=</span>         k []</a>
<a class="sourceLine" id="cb7-21" data-line-number="21"></a>
<a class="sourceLine" id="cb7-22" data-line-number="22">    remove <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">‚Üí</span> Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">2</span> + m<span class="ot">))</span> <span class="ot">‚Üí</span> B n <span class="ot">‚Üí</span> B <span class="ot">(</span>suc n<span class="ot">)</span></a>
<a class="sourceLine" id="cb7-23" data-line-number="23">    remove y ys k zero    <span class="ot">=</span> ys <span class="ot">(</span>k ‚àò <span class="ot">(</span>nothing ‚à∑<span class="ot">_))</span> x</a>
<a class="sourceLine" id="cb7-24" data-line-number="24">    remove y ys k <span class="ot">(</span>suc j<span class="ot">)</span> <span class="ot">=</span> ys <span class="ot">(</span>k ‚àò <span class="ot">(</span>y ‚à∑<span class="ot">_))</span> j</a></code></pre></div>
<p>Adding the squaring optimization complicates things significantly:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb8-1" data-line-number="1">primeFactors <span class="ot">:</span> <span class="ot">‚àÄ</span> n <span class="ot">‚Üí</span> List <span class="ot">(</span>Fin n<span class="ot">)</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">primeFactors zero <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">primeFactors <span class="ot">(</span>suc zero<span class="ot">)</span> <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">primeFactors <span class="ot">(</span>suc <span class="ot">(</span>suc zero<span class="ot">))</span> <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">primeFactors <span class="ot">(</span>suc <span class="ot">(</span>suc <span class="ot">(</span>suc m<span class="ot">)))</span> <span class="ot">=</span> sqr <span class="ot">(</span>suc m<span class="ot">)</span> m suc sieve</a>
<a class="sourceLine" id="cb8-6" data-line-number="6">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-7" data-line-number="7">  <span class="ot">_</span>2F-<span class="ot">_</span> <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">‚Üí</span> ‚Ñï <span class="ot">‚Üí</span> Fin n <span class="ot">‚Üí</span> ‚Ñï</a>
<a class="sourceLine" id="cb8-8" data-line-number="8">  x           2F- zero <span class="ot">=</span> x</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">  zero        2F- suc y <span class="ot">=</span> zero</a>
<a class="sourceLine" id="cb8-10" data-line-number="10">  suc zero    2F- suc y <span class="ot">=</span> zero</a>
<a class="sourceLine" id="cb8-11" data-line-number="11">  suc <span class="ot">(</span>suc x<span class="ot">)</span> 2F- suc y <span class="ot">=</span> x 2F- y</a>
<a class="sourceLine" id="cb8-12" data-line-number="12"></a>
<a class="sourceLine" id="cb8-13" data-line-number="13">  sqr <span class="ot">:</span> <span class="ot">‚àÄ</span> n</a>
<a class="sourceLine" id="cb8-14" data-line-number="14">      <span class="ot">‚Üí</span> ‚Ñï</a>
<a class="sourceLine" id="cb8-15" data-line-number="15">      <span class="ot">‚Üí</span> <span class="ot">(</span>Fin n <span class="ot">‚Üí</span> Fin <span class="ot">(</span><span class="dv">2</span> + m<span class="ot">))</span></a>
<a class="sourceLine" id="cb8-16" data-line-number="16">      <span class="ot">‚Üí</span> <span class="ot">(‚àÄ</span> <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">‚Üí</span> Vec <span class="ot">(</span>Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">2</span> + m<span class="ot">)))</span> i <span class="ot">‚Üí</span> ‚Ñï <span class="ot">‚Üí</span> List <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">3</span> + m<span class="ot">)))</span></a>
<a class="sourceLine" id="cb8-17" data-line-number="17">      <span class="ot">‚Üí</span> List <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">3</span> + m<span class="ot">))</span></a>
<a class="sourceLine" id="cb8-18" data-line-number="18">  sqr n       zero    f k <span class="ot">=</span> k [] n</a>
<a class="sourceLine" id="cb8-19" data-line-number="19">  sqr zero    <span class="ot">(</span>suc l<span class="ot">)</span> f k <span class="ot">=</span> k [] zero</a>
<a class="sourceLine" id="cb8-20" data-line-number="20">  sqr <span class="ot">(</span>suc n<span class="ot">)</span> <span class="ot">(</span>suc l<span class="ot">)</span> f k <span class="ot">=</span></a>
<a class="sourceLine" id="cb8-21" data-line-number="21">    <span class="kw">let</span> x <span class="ot">=</span> f zero</a>
<a class="sourceLine" id="cb8-22" data-line-number="22">    <span class="kw">in</span> sqr n <span class="ot">(</span>l 2F- x<span class="ot">)</span> <span class="ot">(</span>f ‚àò suc<span class="ot">)</span> <span class="ot">(</span>k ‚àò <span class="ot">(</span>just x ‚à∑<span class="ot">_))</span></a>
<a class="sourceLine" id="cb8-23" data-line-number="23"></a>
<a class="sourceLine" id="cb8-24" data-line-number="24">  sieve <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">‚Üí</span> Vec <span class="ot">(</span>Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">2</span> + m<span class="ot">)))</span> n <span class="ot">‚Üí</span> ‚Ñï <span class="ot">‚Üí</span> List <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">3</span> + m<span class="ot">))</span></a>
<a class="sourceLine" id="cb8-25" data-line-number="25">  sieve xs‚Ä≤ i <span class="ot">=</span> go xs‚Ä≤</a>
<a class="sourceLine" id="cb8-26" data-line-number="26">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-27" data-line-number="27">    go <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">‚Üí</span> Vec <span class="ot">(</span>Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">2</span> + m<span class="ot">)))</span> n <span class="ot">‚Üí</span> List <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">3</span> + m<span class="ot">))</span></a>
<a class="sourceLine" id="cb8-28" data-line-number="28">    go [] <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb8-29" data-line-number="29">    go <span class="ot">(</span>nothing ‚à∑ xs<span class="ot">)</span> <span class="ot">=</span> go xs</a>
<a class="sourceLine" id="cb8-30" data-line-number="30">    go <span class="ot">(</span>just x  ‚à∑ xs<span class="ot">)</span> <span class="ot">=</span> Vec<span class="ot">.</span>foldr B remove <span class="ot">(</span>b i<span class="ot">)</span> xs x go</a>
<a class="sourceLine" id="cb8-31" data-line-number="31">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-32" data-line-number="32">      B <span class="ot">=</span> <span class="ot">Œª</span> n <span class="ot">‚Üí</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>i<span class="ot">}</span></a>
<a class="sourceLine" id="cb8-33" data-line-number="33">              <span class="ot">‚Üí</span> Fin i</a>
<a class="sourceLine" id="cb8-34" data-line-number="34">              <span class="ot">‚Üí</span> <span class="ot">(</span>Vec <span class="ot">(</span>Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">2</span> + m<span class="ot">)))</span> n <span class="ot">‚Üí</span> List <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">3</span> + m<span class="ot">)))</span></a>
<a class="sourceLine" id="cb8-35" data-line-number="35">              <span class="ot">‚Üí</span> List <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">3</span> + m<span class="ot">))</span></a>
<a class="sourceLine" id="cb8-36" data-line-number="36"></a>
<a class="sourceLine" id="cb8-37" data-line-number="37">      b <span class="ot">:</span> ‚Ñï <span class="ot">‚Üí</span> B <span class="dv">0</span></a>
<a class="sourceLine" id="cb8-38" data-line-number="38">      b zero    zero    k <span class="ot">=</span> suc x ‚à∑ k []</a>
<a class="sourceLine" id="cb8-39" data-line-number="39">      b zero    <span class="ot">(</span>suc y<span class="ot">)</span> k <span class="ot">=</span> k []</a>
<a class="sourceLine" id="cb8-40" data-line-number="40">      b <span class="ot">(</span>suc n<span class="ot">)</span> zero    k <span class="ot">=</span> b n x k</a>
<a class="sourceLine" id="cb8-41" data-line-number="41">      b <span class="ot">(</span>suc n<span class="ot">)</span> <span class="ot">(</span>suc y<span class="ot">)</span> k <span class="ot">=</span> b n y k</a>
<a class="sourceLine" id="cb8-42" data-line-number="42"></a>
<a class="sourceLine" id="cb8-43" data-line-number="43">      remove <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">‚Üí</span> Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">2</span> + m<span class="ot">))</span> <span class="ot">‚Üí</span> B n <span class="ot">‚Üí</span> B <span class="ot">(</span>suc n<span class="ot">)</span></a>
<a class="sourceLine" id="cb8-44" data-line-number="44">      remove y ys zero    k <span class="ot">=</span> ys x <span class="ot">(</span>k ‚àò <span class="ot">(</span>nothing ‚à∑<span class="ot">_))</span></a>
<a class="sourceLine" id="cb8-45" data-line-number="45">      remove y ys <span class="ot">(</span>suc j<span class="ot">)</span> k <span class="ot">=</span> ys j <span class="ot">(</span>k ‚àò <span class="ot">(</span>y ‚à∑<span class="ot">_))</span></a></code></pre></div>
<h1 id="infinitude">Infinitude</h1>
<p>The above sieve aren‚Äôt ‚Äútrue‚Äù in that each <code>remove</code> is linear, so the performance is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n^2)</annotation></semantics></math> overall. This is the same problem we ran into with the naive infinite sieve in Haskell.</p>
<p>Since it bears such a similarity to the infinite sieve, we have to ask: can <em>this</em> sieve be infinite? Agda supports a notion of infinite data, so it would seem like it:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">5</span> <span class="ot">_</span>‚óÇ<span class="ot">_</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="kw">record</span> Stream <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  <span class="kw">constructor</span> <span class="ot">_</span>‚óÇ<span class="ot">_</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4">  <span class="kw">coinductive</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  <span class="kw">field</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6">    head <span class="ot">:</span> A</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">    tail <span class="ot">:</span> Stream A</a>
<a class="sourceLine" id="cb9-8" data-line-number="8"><span class="kw">open</span> Stream</a>
<a class="sourceLine" id="cb9-9" data-line-number="9"></a>
<a class="sourceLine" id="cb9-10" data-line-number="10">primes <span class="ot">:</span> Stream ‚Ñï</a>
<a class="sourceLine" id="cb9-11" data-line-number="11">primes <span class="ot">=</span> sieve <span class="dv">1</span> nats</a>
<a class="sourceLine" id="cb9-12" data-line-number="12">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-13" data-line-number="13">  nats <span class="ot">:</span> Stream ‚Ñï</a>
<a class="sourceLine" id="cb9-14" data-line-number="14">  head nats <span class="ot">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb9-15" data-line-number="15">  tail nats <span class="ot">=</span> nats</a>
<a class="sourceLine" id="cb9-16" data-line-number="16"></a>
<a class="sourceLine" id="cb9-17" data-line-number="17">  sieve <span class="ot">:</span> ‚Ñï <span class="ot">‚Üí</span> Stream ‚Ñï <span class="ot">‚Üí</span> Stream ‚Ñï</a>
<a class="sourceLine" id="cb9-18" data-line-number="18">  head <span class="ot">(</span>sieve i xs<span class="ot">)</span> <span class="ot">=</span> suc i</a>
<a class="sourceLine" id="cb9-19" data-line-number="19">  tail <span class="ot">(</span>sieve i xs<span class="ot">)</span> <span class="ot">=</span> remove i <span class="ot">(</span>head xs<span class="ot">)</span> <span class="ot">(</span>tail xs<span class="ot">)</span> <span class="ot">(</span>sieve ‚àò suc ‚àò <span class="ot">(_</span>+ i<span class="ot">))</span></a>
<a class="sourceLine" id="cb9-20" data-line-number="20">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-21" data-line-number="21">    remove <span class="ot">:</span> ‚Ñï <span class="ot">‚Üí</span> ‚Ñï <span class="ot">‚Üí</span> Stream ‚Ñï <span class="ot">‚Üí</span> <span class="ot">(</span>‚Ñï <span class="ot">‚Üí</span> Stream ‚Ñï <span class="ot">‚Üí</span> Stream ‚Ñï<span class="ot">)</span> <span class="ot">‚Üí</span> Stream ‚Ñï</a>
<a class="sourceLine" id="cb9-22" data-line-number="22">    remove zero zero zs       k <span class="ot">=</span> remove i <span class="ot">(</span>head zs<span class="ot">)</span> <span class="ot">(</span>tail zs<span class="ot">)</span> <span class="ot">(</span>k ‚àò suc<span class="ot">)</span></a>
<a class="sourceLine" id="cb9-23" data-line-number="23">    remove zero <span class="ot">(</span>suc z<span class="ot">)</span> zs    k <span class="ot">=</span> remove i z zs <span class="ot">(</span>k ‚àò suc<span class="ot">)</span></a>
<a class="sourceLine" id="cb9-24" data-line-number="24">    remove <span class="ot">(</span>suc y<span class="ot">)</span> zero zs    k <span class="ot">=</span> k zero <span class="ot">(</span>remove y <span class="ot">(</span>head zs<span class="ot">)</span> <span class="ot">(</span>tail zs<span class="ot">)</span> <span class="ot">_</span>‚óÇ<span class="ot">_)</span></a>
<a class="sourceLine" id="cb9-25" data-line-number="25">    remove <span class="ot">(</span>suc y<span class="ot">)</span> <span class="ot">(</span>suc z<span class="ot">)</span> zs k <span class="ot">=</span> remove y z zs <span class="ot">(</span>k ‚àò suc<span class="ot">)</span></a></code></pre></div>
<p>But this won‚Äôt pass the termination checker. What we actually need to prove to do so is that there are infinitely many primes: <a href="https://gist.github.com/copumpkin/1286093">a nontrivial task in Agda</a>.</p>
]]></description>
    <pubDate>Fri, 14 Dec 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-12-14-primes-in-agda.html</guid>
    <dc:creator>Donnacha Ois√≠n Kidney</dc:creator>
</item>
<item>
    <title>Keeping Formal Verification in Bounds</title>
    <link>https://doisinkidney.com/posts/2018-11-20-fast-verified-structures.html</link>
    <description><![CDATA[<div class="info">
    Posted on November 20, 2018
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Agda.html">Agda</a>
    
</div>

<p>One of the favorite pastimes of both Haskell and Agda programmers alike is verifying data structures. Among my favorite examples are Red-Black trees <span class="citation" data-cites="might_missing_2015 weirich_depending_2014">(Might <a href="#ref-might_missing_2015">2015</a>; Weirich <a href="#ref-weirich_depending_2014">2014</a>, verified for balance)</span>, perfect binary trees <span class="citation" data-cites="hinze_perfect_1999">(Hinze <a href="#ref-hinze_perfect_1999">1999</a>)</span>, square matrices <span class="citation" data-cites="okasaki_fast_1999">(Okasaki <a href="#ref-okasaki_fast_1999">1999</a><a href="#ref-okasaki_fast_1999">a</a>)</span>, search trees <span class="citation" data-cites="mcbride_how_2014">(McBride <a href="#ref-mcbride_how_2014">2014</a>, verified for balance and order)</span>, and binomial heaps <span class="citation" data-cites="hinze_numerical_1998">(Hinze <a href="#ref-hinze_numerical_1998">1998</a>, verified for structure)</span>.</p>
<p>There are many ways to verify data structures. One technique which has had recent massive success is to convert Haskell code to Coq, and then verify the Coq translation: this was the route taken by <span class="citation" data-cites="breitner_ready_2018-1">Breitner et al. (<a href="#ref-breitner_ready_2018-1">2018</a>)</span> to verify <code>Set</code> and <code>IntSet</code> in containers (a mammoth achievement, in my opinion).</p>
<p>This approach has some obvious advantages: you separate implementation from testing (which is usually a good idea), and your verification language can be different from your implementation language, with each tailored towards its particular domain.</p>
<p>LiquidHaskell <span class="citation" data-cites="bakst_liquidhaskell_2018">(Bakst et al. <a href="#ref-bakst_liquidhaskell_2018">2018</a>)</span> (and other tools like it) adds an extra type system to Haskell tailor-made for verification. The added type system (refinement types) is more automated (the typechecker uses Z3), more suited for ‚Äúinvariant‚Äù-like things (it supports subtyping), and has a bunch of domain-specific built-ins (reasoning about sets, equations, etc.). I‚Äôd encourage anyone who hasn‚Äôt used it to give it a try: especially if you‚Äôre experienced writing any kind of proof in a language like Agda or Idris, LiquidHaskell proofs are <em>shockingly</em> simple and easy.</p>
<p>What I‚Äôm going to focus on today, though, is writing <em>correct-by-construction</em> data structures, using Haskell and Agda‚Äôs own type systems. In particular, I‚Äôm going to look at how to write <em>fast</em> verification. In the other two approaches, we don‚Äôt really care about the ‚Äúspeed‚Äù of the proofs: sure, it‚Äôs nice to speed up compilation and so on, but we don‚Äôt have to worry about our implementation suffering at runtime because of some complex proof. When writing correct-by-construction code, though, our task is doubly hard: we now have to worry about the time complexity of both the implementation <em>and the proofs</em>.</p>
<p>In this post, I‚Äôm going to demonstrate some techniques to write proofs that stay within the complexity bounds of the algorithms they‚Äôre verifying (without cheating!). Along the way I‚Äôm going to verify some data structures I haven‚Äôt seen verified before (a skew-binary random-access list).</p>
<h1 id="technique-1-start-with-an-unverified-implementation-then-index">Technique 1: Start With an Unverified Implementation, then Index</h1>
<p>To demonstrate the first two techniques, we‚Äôre going to write a type for modular arithmetic. For a more tactile metaphor, think of the flip clock:</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/c/c3/Split-flap_display.jpg" /></p>
<p>Each digit can be incremented <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> times, where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> is whatever base you‚Äôre using (12 for our flip-clock above). Once you hit the limit, it flips the next digit along. We‚Äôll start with just one digit, and then just string them together to get our full type. That in mind, our ‚Äúdigit‚Äù type has two requirements:</p>
<ol>
<li>It should be incrementable.</li>
<li>Once it hits its limit, it should flip back to zero, and let us know that a flip was performed.</li>
</ol>
<p>Anyone who‚Äôs used a little Agda or Idris will be familiar with the <code>Fin</code> type:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> Fin <span class="ot">:</span> ‚Ñï <span class="ot">‚Üí</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  zero <span class="ot">:</span> <span class="ot">{</span>n <span class="ot">:</span> ‚Ñï<span class="ot">}</span> <span class="ot">‚Üí</span> Fin <span class="ot">(</span>suc n<span class="ot">)</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  suc  <span class="ot">:</span> <span class="ot">{</span>n <span class="ot">:</span> ‚Ñï<span class="ot">}</span> <span class="ot">‚Üí</span> Fin n <span class="ot">‚Üí</span> Fin <span class="ot">(</span>suc n<span class="ot">)</span></a></code></pre></div>
<p><code>Fin n</code> is the standard way to encode ‚Äúnumbers smaller than <code>n</code>‚Äù. However, for digits they‚Äôre entirely unsuitable: since the limit parameter changes on successor, the kind of increment we want is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n)</annotation></semantics></math>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb2-1" data-line-number="1">try-suc <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">‚Üí</span> Fin n <span class="ot">‚Üí</span> Maybe <span class="ot">(</span>Fin n<span class="ot">)</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">try-suc <span class="ot">(</span>suc x<span class="ot">)</span> <span class="ot">=</span> Maybe<span class="ot">.</span>map suc <span class="ot">(</span>try-suc x<span class="ot">)</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">try-suc <span class="ot">{</span>suc n<span class="ot">}</span> zero <span class="kw">with</span> n</a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="ot">...</span> <span class="ot">|</span> zero <span class="ot">=</span> nothing</a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="ot">...</span> <span class="ot">|</span> suc <span class="ot">_</span> <span class="ot">=</span> just <span class="ot">(</span>suc zero<span class="ot">)</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6"></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">suc-flip <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">‚Üí</span> Fin n <span class="ot">‚Üí</span> Fin n √ó Bool</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">suc-flip <span class="ot">{</span>suc n<span class="ot">}</span> x <span class="ot">=</span> maybe <span class="ot">(_</span>, false<span class="ot">)</span> <span class="ot">(</span>zero , true<span class="ot">)</span> <span class="ot">(</span>try-suc x<span class="ot">)</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9">suc-flip <span class="ot">{</span>zero<span class="ot">}</span> <span class="ot">()</span></a></code></pre></div>
<p>If we keep going down this path with proofs in mind, we might next look at the various <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>‚â§</mo><annotation encoding="application/x-tex">\leq</annotation></semantics></math> proofs in the Agda standard library (<a href="https://github.com/agda/agda-stdlib/blob/18b45b151f44cee2114fa4b3c1ad9ea532baf919/src/Data/Nat/Base.agda#L28">here</a>, <a href="https://github.com/agda/agda-stdlib/blob/18b45b151f44cee2114fa4b3c1ad9ea532baf919/src/Data/Nat/Base.agda#L117">here</a>, and <a href="https://github.com/agda/agda-stdlib/blob/18b45b151f44cee2114fa4b3c1ad9ea532baf919/src/Data/Nat/Base.agda#L133">here</a>), and see if we can we can wrangle them into doing what we want.</p>
<p>For me, though, this wasn‚Äôt a fruitful approach. Instead, we‚Äôll try and think of how we‚Äôd do this without proving anything, and then see if there‚Äôs any place in the resulting data structure we can hang some proof.</p>
<p>So, in an unproven way, let‚Äôs start with some numbers. Since we‚Äôre going to be incrementing, they‚Äôd better be unary:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">data</span> ‚Ñï <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  zero <span class="ot">:</span> ‚Ñï</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">  suc <span class="ot">:</span> ‚Ñï <span class="ot">‚Üí</span> ‚Ñï</a></code></pre></div>
<p>And then, for the ‚Äúflippable‚Äù type, we‚Äôll just store the limit alongside the value:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">record</span> Flipper <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  <span class="kw">constructor</span> <span class="ot">_</span>&amp;<span class="ot">_</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  <span class="kw">field</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">    val <span class="ot">:</span> ‚Ñï</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">    lim <span class="ot">:</span> ‚Ñï</a></code></pre></div>
<p>We‚Äôre not there yet: to check if we‚Äôve gone over the limit, we‚Äôll still have to compare <code>val</code> and <code>lim</code>. Hopefully you can guess the optimization we‚Äôll make: instead of storing the limit, we‚Äôll store the space left:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">record</span> Flipper <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">  <span class="kw">constructor</span> <span class="ot">_</span>&amp;<span class="ot">_</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  <span class="kw">field</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">    space <span class="ot">:</span> ‚Ñï</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">    val   <span class="ot">:</span> ‚Ñï</a></code></pre></div>
<p>And we get our flip function:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb6-1" data-line-number="1">suc-flip <span class="ot">:</span> Flipper <span class="ot">‚Üí</span> Flipper √ó Bool</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">suc-flip <span class="ot">(</span>zero  &amp; n<span class="ot">)</span> <span class="ot">=</span> <span class="ot">(</span>suc n &amp; zero <span class="ot">)</span>, true</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">suc-flip <span class="ot">(</span>suc m &amp; n<span class="ot">)</span> <span class="ot">=</span> <span class="ot">(</span>m     &amp; suc n<span class="ot">)</span>, false</a></code></pre></div>
<p>When there‚Äôs no space left, the digit must be maximal (9 in decimal, for instance), so it‚Äôll be one less than the base. That lets us stick it in for the base, rather than recalculating. In the other case, we just take one from the space left, and add it to the value.</p>
<p>So, to ‚Äúprove‚Äù this implementation, we might first reach for an equality proof that <code>val + space</code> is equal to your base. Don‚Äôt! Both <code>val</code> and <code>space</code> are inductive structures, which could be giving us information on every application of <code>suc</code>! Let‚Äôs set our sights on <code>val</code> and see how we can hang our proofs off of it.</p>
<p>We‚Äôre going to upgrade our Peano number with some information, which means that our resulting type is going to look an awful lot like a Peano number. In other words, two cases: <code>zero</code> and <code>suc</code>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">data</span> Val <span class="ot">_</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  zero-case <span class="ot">:</span> Val <span class="ot">_</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  suc-case  <span class="ot">:</span> Val <span class="ot">_</span> <span class="ot">‚Üí</span> Val <span class="ot">_</span></a></code></pre></div>
<p>For the <code>suc-case</code>, remember we only want to be allowed to increment it when the space left is more than zero. So let‚Äôs encode it:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">data</span> Val <span class="ot">_</span> <span class="ot">:</span> ‚Ñï <span class="ot">‚Üí</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  zero-case <span class="ot">:</span> Val <span class="ot">_</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  suc-case  <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>space<span class="ot">}</span> <span class="ot">‚Üí</span> Val <span class="ot">_</span> <span class="ot">(</span>suc space<span class="ot">)</span> <span class="ot">‚Üí</span> Val <span class="ot">_</span> space</a></code></pre></div>
<p>And for the <code>zero-case</code>, the space left is just the base. So let‚Äôs stick the base into the type as well:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">data</span> Val <span class="ot">(</span>base <span class="ot">:</span> ‚Ñï<span class="ot">)</span> <span class="ot">:</span> ‚Ñï <span class="ot">‚Üí</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">  zero-case <span class="ot">:</span> Val base base</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  suc-case  <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>space<span class="ot">}</span> <span class="ot">‚Üí</span> Val base <span class="ot">(</span>suc space<span class="ot">)</span> <span class="ot">‚Üí</span> Val base space</a></code></pre></div>
<p>(We‚Äôve changed around the way ‚Äúbase‚Äù works: it‚Äôs now one smaller. So to encode base-10 you‚Äôd have <code>Val 9 space</code>. You can get back to the other encoding with a simple wrapper, this way just makes things slightly easier from now on).</p>
<p>Finally, our flipper:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">record</span> Flipper <span class="ot">(</span>base <span class="ot">:</span> ‚Ñï<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">  <span class="kw">constructor</span> <span class="ot">_</span>&amp;<span class="ot">_</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  <span class="kw">field</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4">    space <span class="ot">:</span> ‚Ñï</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">    val <span class="ot">:</span> Val base space</a>
<a class="sourceLine" id="cb10-6" data-line-number="6"></a>
<a class="sourceLine" id="cb10-7" data-line-number="7">suc-flip <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">‚Üí</span> Flipper n <span class="ot">‚Üí</span> Flipper n √ó Bool</a>
<a class="sourceLine" id="cb10-8" data-line-number="8">suc-flip <span class="ot">(</span>zero  &amp; m<span class="ot">)</span> <span class="ot">=</span> <span class="ot">(_</span> &amp;  zero-case<span class="ot">)</span> , true</a>
<a class="sourceLine" id="cb10-9" data-line-number="9">suc-flip <span class="ot">(</span>suc n &amp; m<span class="ot">)</span> <span class="ot">=</span> <span class="ot">(</span>n &amp; suc-case m<span class="ot">)</span> , false</a></code></pre></div>
<p>Great! Everything works.</p>
<p>You may have noticed that the <code>Val</code> type is actually a proof for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>‚â•</mo><annotation encoding="application/x-tex">\geq</annotation></semantics></math> in disguise:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">data</span> <span class="ot">_</span>‚â•<span class="ot">_</span> <span class="ot">(</span>m <span class="ot">:</span> ‚Ñï<span class="ot">)</span> <span class="ot">:</span> ‚Ñï <span class="ot">‚Üí</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2">  m‚â•m <span class="ot">:</span> m ‚â• m</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  m‚â•p <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">‚Üí</span> m ‚â• suc n <span class="ot">‚Üí</span> m ‚â• n</a></code></pre></div>
<p>And the flipper itself is just an existential in disguise:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb12-1" data-line-number="1">Flipper <span class="ot">:</span> ‚Ñï <span class="ot">‚Üí</span> <span class="dt">Set</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">Flipper n <span class="ot">=</span> ‚àÉ <span class="ot">(</span>n ‚â•<span class="ot">_)</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3"></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">suc-flip <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">‚Üí</span> Flipper n <span class="ot">‚Üí</span> Flipper n √ó Bool</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">suc-flip <span class="ot">(</span>zero  , m<span class="ot">)</span> <span class="ot">=</span> <span class="ot">(_</span> , m‚â•m  <span class="ot">)</span>, true</a>
<a class="sourceLine" id="cb12-6" data-line-number="6">suc-flip <span class="ot">(</span>suc n , m<span class="ot">)</span> <span class="ot">=</span> <span class="ot">(</span>n , m‚â•p m<span class="ot">)</span>, false</a></code></pre></div>
<p>Hopefully this explanation will help you understand how to get from the specification to those 8 lines. This technique is going to come in especially handy later when we base data structures off of number systems.</p>
<h1 id="technique-2-once-you-eliminate-the-impossible-whatever-remains-no-matter-how-improbable-must-be-the-truth.">Technique 2: Once you eliminate the impossible, whatever remains, no matter how improbable, must be the truth.</h1>
<p>For this next trick, we‚Äôll add an extra operation to the flipper type above: conversion from a natural number. We want to be able to do it in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n)</annotation></semantics></math> time, and we won‚Äôt allow ourselves to change the original type definition. Here‚Äôs the type we‚Äôre aiming for:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb13-1" data-line-number="1">fromNat <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>m<span class="ot">}</span> <span class="ot">(</span>n <span class="ot">:</span> ‚Ñï<span class="ot">)</span> <span class="ot">‚Üí</span> <span class="ot">(</span>m‚â•n <span class="ot">:</span> m ‚â• n<span class="ot">)</span> <span class="ot">‚Üí</span> Flipper m</a></code></pre></div>
<p>We pass in a proof that the natural number we‚Äôre converting from is indeed in range (it‚Äôs marked irrelevant so we don‚Äôt pay for it). Here‚Äôs a non-answer:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb14-1" data-line-number="1">fromNat <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>m<span class="ot">}</span> <span class="ot">(</span>n <span class="ot">:</span> ‚Ñï<span class="ot">)</span> <span class="ot">‚Üí</span> <span class="ot">{</span>m‚â•n <span class="ot">:</span> m ‚â• n<span class="ot">}</span> <span class="ot">‚Üí</span> Flipper m</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">fromNat n <span class="ot">{</span>m‚â•n<span class="ot">}</span> <span class="ot">=</span> n , m‚â•n</a></code></pre></div>
<p>While this looks fine, it‚Äôs actually the <em>inverse</em> of what we want. We defined the inductive structure to be indicated by the inequality proof itself. Let‚Äôs make the desired output explicit:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb15-1" data-line-number="1">toNat <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>n m<span class="ot">}</span> <span class="ot">‚Üí</span> n ‚â• m <span class="ot">‚Üí</span> ‚Ñï</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">toNat m‚â•m <span class="ot">=</span> zero</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">toNat <span class="ot">(</span>m‚â•p n‚â•m<span class="ot">)</span> <span class="ot">=</span> suc <span class="ot">(</span>toNat n‚â•m<span class="ot">)</span></a>
<a class="sourceLine" id="cb15-4" data-line-number="4"></a>
<a class="sourceLine" id="cb15-5" data-line-number="5">fromNat-‚â° <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>n<span class="ot">}</span> m</a>
<a class="sourceLine" id="cb15-6" data-line-number="6">          <span class="ot">‚Üí</span> <span class="ot">.(</span>n‚â•m <span class="ot">:</span> n ‚â• m<span class="ot">)</span></a>
<a class="sourceLine" id="cb15-7" data-line-number="7">          <span class="ot">‚Üí</span>  Œ£[ n-m ‚àà Flipper n ] toNat <span class="ot">(</span>proj‚ÇÇ n-m<span class="ot">)</span> ‚â° m</a></code></pre></div>
<p>And finally we can try an implementation:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb16-1" data-line-number="1">fromNat-‚â° zero    <span class="ot">_</span>   <span class="ot">=</span> <span class="ot">(_</span> , m‚â•m<span class="ot">)</span> , refl</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">fromNat-‚â° <span class="ot">(</span>suc m<span class="ot">)</span> n‚â•m <span class="ot">=</span> ??? <span class="ot">(</span>fromNat-‚â° m <span class="ot">(</span>m‚â•p n‚â•m<span class="ot">))</span></a></code></pre></div>
<p>In the <code>???</code> there, we want some kind of successor function. The problem is that we would also need to prove that we <em>can</em> do a successor call. Except we don‚Äôt want to do that: proving that there‚Äôs space left is an expensive operation, and one we can avoid with another trick: first, we <em>assume</em> that there‚Äôs space left.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb17-1" data-line-number="1">fromNat-‚â° zero    n‚â•m <span class="ot">=</span> <span class="ot">(</span> <span class="ot">_</span> , m‚â•m<span class="ot">)</span> , refl</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">fromNat-‚â° <span class="ot">(</span>suc n<span class="ot">)</span> n‚â•m <span class="kw">with</span> fromNat-‚â° n <span class="ot">(</span>m‚â•p n‚â•m<span class="ot">)</span></a>
<a class="sourceLine" id="cb17-3" data-line-number="3"><span class="ot">...</span> <span class="ot">|</span> <span class="ot">(</span>suc space , n-1<span class="ot">)</span>, x‚â°m  <span class="ot">=</span> <span class="ot">(</span>space , m‚â•p n-1<span class="ot">)</span>, cong suc x‚â°m</a>
<a class="sourceLine" id="cb17-4" data-line-number="4"><span class="ot">...</span> <span class="ot">|</span> <span class="ot">(</span>zero      , n-1<span class="ot">)</span>, refl <span class="ot">=</span> ???</a></code></pre></div>
<p>But what about the second case? Well, we have to prove this impossible. What if it‚Äôs an extremely complex, expensive proof? It doesn‚Äôt matter! It will never be run! In contrast to proving the ‚Äúhappy path‚Äù correct, if we can confine all of the ugly complex cases to the unhappy paths, we can spend as long as we want proving them impossible without having to worry about runtime cost. Here‚Äôs the full function.</p>
<details>
<p><summary> <code>fromNat</code> implementation </summary></p>
<div class="sourceCode" id="cb18"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb18-1" data-line-number="1">fromNat-‚â° <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>n<span class="ot">}</span> m</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">          <span class="ot">‚Üí</span> <span class="ot">.(</span>n‚â•m <span class="ot">:</span> n ‚â• m<span class="ot">)</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3">          <span class="ot">‚Üí</span>  Œ£[ n-m ‚àà Flipper n ] toNat <span class="ot">(</span>proj‚ÇÇ n-m<span class="ot">)</span> ‚â° m</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">fromNat-‚â° zero    n‚â•m <span class="ot">=</span> <span class="ot">(</span> <span class="ot">_</span> , m‚â•m<span class="ot">)</span> , refl</a>
<a class="sourceLine" id="cb18-5" data-line-number="5">fromNat-‚â° <span class="ot">(</span>suc n<span class="ot">)</span> n‚â•m <span class="kw">with</span> fromNat-‚â° n <span class="ot">(</span>m‚â•p n‚â•m<span class="ot">)</span></a>
<a class="sourceLine" id="cb18-6" data-line-number="6"><span class="ot">...</span> <span class="ot">|</span> <span class="ot">(</span>suc space , n-1<span class="ot">)</span>, x‚â°m  <span class="ot">=</span> <span class="ot">(</span>space , m‚â•p n-1<span class="ot">)</span>, cong suc x‚â°m</a>
<a class="sourceLine" id="cb18-7" data-line-number="7"><span class="ot">...</span> <span class="ot">|</span> <span class="ot">(</span>zero      , n‚â•0<span class="ot">)</span>, refl <span class="ot">=</span> Irrel<span class="ot">.</span>‚ä•-elim <span class="ot">(</span>contra <span class="ot">_</span> zero n‚â•0 n‚â•m<span class="ot">)</span></a>
<a class="sourceLine" id="cb18-8" data-line-number="8">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-9" data-line-number="9">  <span class="kw">import</span> Data<span class="ot">.</span>Nat<span class="ot">.</span>Properties as <span class="dt">Prop</span></a>
<a class="sourceLine" id="cb18-10" data-line-number="10"></a>
<a class="sourceLine" id="cb18-11" data-line-number="11">  n‚â±sk+n <span class="ot">:</span> <span class="ot">‚àÄ</span> n k <span class="ot">{</span>sk+n<span class="ot">}</span> <span class="ot">‚Üí</span> sk+n ‚â° suc k ‚Ñï<span class="ot">.</span>+ n <span class="ot">‚Üí</span> n ‚â• sk+n <span class="ot">‚Üí</span> ‚ä•</a>
<a class="sourceLine" id="cb18-12" data-line-number="12">  n‚â±sk+n n k wit <span class="ot">(</span>m‚â•p n‚â•sk+n<span class="ot">)</span> <span class="ot">=</span> n‚â±sk+n n <span class="ot">(</span>suc k<span class="ot">)</span> <span class="ot">(</span>cong suc wit<span class="ot">)</span> n‚â•sk+n</a>
<a class="sourceLine" id="cb18-13" data-line-number="13">  n‚â±sk+n n k wit m‚â•m <span class="kw">with</span> <span class="dt">Prop</span><span class="ot">.</span>+-cancel ≥-‚â° <span class="dv">0</span> <span class="ot">(</span>suc k<span class="ot">)</span> wit</a>
<a class="sourceLine" id="cb18-14" data-line-number="14">  <span class="ot">...</span> <span class="ot">|</span> <span class="ot">()</span></a>
<a class="sourceLine" id="cb18-15" data-line-number="15"></a>
<a class="sourceLine" id="cb18-16" data-line-number="16">  contra <span class="ot">:</span> <span class="ot">‚àÄ</span> n m <span class="ot">‚Üí</span> <span class="ot">(</span>n‚â•m <span class="ot">:</span> n ‚â• m<span class="ot">)</span> <span class="ot">‚Üí</span> n ‚â• suc <span class="ot">(</span>m ‚Ñï<span class="ot">.</span>+ toNat n‚â•m<span class="ot">)</span> <span class="ot">‚Üí</span> ‚ä•</a>
<a class="sourceLine" id="cb18-17" data-line-number="17">  contra n m m‚â•m n‚â•st <span class="ot">=</span> n‚â±sk+n n zero <span class="ot">(</span>cong suc <span class="ot">(</span><span class="dt">Prop</span><span class="ot">.</span>+-identity ≥ n<span class="ot">))</span> n‚â•st</a>
<a class="sourceLine" id="cb18-18" data-line-number="18">  contra n m <span class="ot">(</span>m‚â•p n‚â•m<span class="ot">)</span> n‚â•st <span class="ot">=</span></a>
<a class="sourceLine" id="cb18-19" data-line-number="19">    contra</a>
<a class="sourceLine" id="cb18-20" data-line-number="20">      n</a>
<a class="sourceLine" id="cb18-21" data-line-number="21">      <span class="ot">(</span>suc m<span class="ot">)</span></a>
<a class="sourceLine" id="cb18-22" data-line-number="22">      n‚â•m</a>
<a class="sourceLine" id="cb18-23" data-line-number="23">      <span class="ot">(</span>subst <span class="ot">(Œª</span> x <span class="ot">‚Üí</span> n ‚â• suc x<span class="ot">)</span> <span class="ot">(</span><span class="dt">Prop</span><span class="ot">.</span>+-suc m <span class="ot">(</span>toNat n‚â•m<span class="ot">))</span> n‚â•st<span class="ot">)</span></a>
<a class="sourceLine" id="cb18-24" data-line-number="24"></a>
<a class="sourceLine" id="cb18-25" data-line-number="25">fromNat <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>n<span class="ot">}</span> m <span class="ot">‚Üí</span> <span class="ot">.(</span>n‚â•m <span class="ot">:</span> n ‚â• m<span class="ot">)</span> <span class="ot">‚Üí</span> Flipper n</a>
<a class="sourceLine" id="cb18-26" data-line-number="26">fromNat m n‚â•m <span class="ot">=</span> proj‚ÇÅ <span class="ot">(</span>fromNat-‚â° m n‚â•m<span class="ot">)</span></a></code></pre></div>
</details>
<h1 id="technique-3-make-indices-correct-by-construction">Technique 3: Make Indices Correct-By-Construction</h1>
<p>We‚Äôre going to switch into Haskell now, and in particular to functional arrays. These are data structures which aren‚Äôt real arrays, but they offer you the kind of interface you‚Äôd want from an array in a functional setting. You can‚Äôt get better than <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math> indexing, unfortunately <span class="citation" data-cites="ben-amram_pointers_1992">(Ben-Amram and Galil <a href="#ref-ben-amram_pointers_1992">1992</a>)</span>, but often it‚Äôs enough.</p>
<p>The first ‚Äúfunctional array‚Äù we‚Äôre going to be looking at nested binary random-access lists. It has <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math> indexing, as you might expect, and amortized single-threaded <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math> <code>cons</code>.</p>
<p>It starts out like a binary random-access list (‚Äúrandom-access list‚Äù is another name for ‚Äúfunctional array‚Äù). You can find a full explanation of the structure in your nearest copy of Purely Functional Data Structures <span class="citation" data-cites="okasaki_purely_1999">(Okasaki <a href="#ref-okasaki_purely_1999">1999</a><a href="#ref-okasaki_purely_1999">b</a>)</span>, but briefly: the structure mimics a binary number, in that it‚Äôs a list of ‚Äúbits‚Äù. At each set bit, it stores a tree with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mi>i</mi></msup><annotation encoding="application/x-tex">2^i</annotation></semantics></math> elements, where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math> is the position in the list. In this way, every binary number <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> has an analogous list of ‚Äúbits‚Äù which contains, in total, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> elements.</p>
<p>The ‚Äúnested‚Äù part refers to how we‚Äôre going to implement the trees. It works a little like this:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a <span class="fu">=</span> <span class="dt">Leaf</span> a <span class="fu">|</span> <span class="dt">Node</span> (<span class="dt">Tree</span> (a,a))</a></code></pre></div>
<p>You might have to squint at that definition for a second to understand it: instead of storing two trees at the <code>Node</code> constructor (which is what you‚Äôd usually do), we store a tree with double the elements. This has two advantages: all of the children have the same number of elements (this tree, for instance, is always some power of 2), and it also cuts down on memory use.</p>
<p>For the binary random-access list, we‚Äôll use the nested encoding of trees to encode the contents of each bit. There‚Äôs an implementation of this very thing on Hackage <span class="citation" data-cites="komuves_nested-sequence_2016">(Komuves and Divianszky <a href="#ref-komuves_nested-sequence_2016">2016</a>)</span>, and Okasaki himself wrote something very similar to it <span class="citation" data-cites="okasaki_fast_1999">(<a href="#ref-okasaki_fast_1999">1999</a><a href="#ref-okasaki_fast_1999">a</a>)</span>, but we‚Äôre going to go a little further than both of those by indexing the type by its size. Here it is:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Bit</span> <span class="fu">=</span> <span class="dt">O</span> <span class="fu">|</span> <span class="dt">I</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2"></a>
<a class="sourceLine" id="cb20-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Seq</span> ns a <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-4" data-line-number="4">    <span class="dt">Nil</span><span class="ot">  ::</span>                      <span class="dt">Seq</span> <span class="ch">&#39;[]      a</span></a>
<a class="sourceLine" id="cb20-5" data-line-number="5">    <span class="dt">Even</span><span class="ot"> ::</span>      <span class="dt">Seq</span> xs (a,a) <span class="ot">-&gt;</span> <span class="dt">Seq</span> (<span class="dt">O</span> <span class="fu">:</span> xs) a</a>
<a class="sourceLine" id="cb20-6" data-line-number="6">    <span class="dt">Odd</span><span class="ot">  ::</span> a <span class="ot">-&gt;</span> <span class="dt">Seq</span> xs (a,a) <span class="ot">-&gt;</span> <span class="dt">Seq</span> (<span class="dt">I</span> <span class="fu">:</span> xs) a</a></code></pre></div>
<p>The operations we‚Äôre interested will be <code>cons</code> and <code>uncons</code>: for the indices, they correspond to incrementing and decrementing the numbers, respectively. As such, we‚Äôll need type-level functions for those:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">Inc</span> (<span class="ot">ns ::</span> [<span class="dt">Bit</span>])<span class="ot"> ::</span> [<span class="dt">Bit</span>] <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-2" data-line-number="2">    <span class="dt">Inc</span> <span class="ch">&#39;[] = &#39;</span>[<span class="dt">I</span>]</a>
<a class="sourceLine" id="cb21-3" data-line-number="3">    <span class="dt">Inc</span> (<span class="dt">O</span> <span class="fu">:</span> xs) <span class="fu">=</span> <span class="dt">I</span> <span class="fu">:</span> xs</a>
<a class="sourceLine" id="cb21-4" data-line-number="4">    <span class="dt">Inc</span> (<span class="dt">I</span> <span class="fu">:</span> xs) <span class="fu">=</span> <span class="dt">O</span> <span class="fu">:</span> <span class="dt">Inc</span> xs</a></code></pre></div>
<p>And now the <code>cons</code> function:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="ot">cons ::</span> a <span class="ot">-&gt;</span> <span class="dt">Seq</span> ns a <span class="ot">-&gt;</span> <span class="dt">Seq</span> (<span class="dt">Inc</span> ns) a</a>
<a class="sourceLine" id="cb22-2" data-line-number="2">cons x <span class="dt">Nil</span>        <span class="fu">=</span> <span class="dt">Odd</span> x <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb22-3" data-line-number="3">cons x (<span class="dt">Even</span>  xs) <span class="fu">=</span> <span class="dt">Odd</span> x xs</a>
<a class="sourceLine" id="cb22-4" data-line-number="4">cons x (<span class="dt">Odd</span> y ys) <span class="fu">=</span> <span class="dt">Even</span> (cons (x,y) ys)</a></code></pre></div>
<p>However, we‚Äôre going to run into trouble if we try to write <code>uncons</code>:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">Dec</span> (<span class="ot">ns ::</span> [<span class="dt">Bit</span>])<span class="ot"> ::</span> [<span class="dt">Bit</span>] <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-2" data-line-number="2">    <span class="dt">Dec</span> (<span class="dt">I</span> <span class="fu">:</span> xs) <span class="fu">=</span> <span class="dt">O</span> <span class="fu">:</span> xs</a>
<a class="sourceLine" id="cb23-3" data-line-number="3">    <span class="dt">Dec</span> (<span class="dt">O</span> <span class="fu">:</span> xs) <span class="fu">=</span> <span class="dt">I</span> <span class="fu">:</span> <span class="dt">Dec</span> xs</a>
<a class="sourceLine" id="cb23-4" data-line-number="4">    <span class="dt">Dec</span> <span class="ch">&#39;[] = ???</span></a>
<a class="sourceLine" id="cb23-5" data-line-number="5">    </a>
<a class="sourceLine" id="cb23-6" data-line-number="6"><span class="ot">uncons ::</span> <span class="dt">Seq</span> ns a <span class="ot">-&gt;</span> (a, <span class="dt">Seq</span> (<span class="dt">Dec</span> ns) a)</a>
<a class="sourceLine" id="cb23-7" data-line-number="7">uncons (<span class="dt">Odd</span> x xs) <span class="fu">=</span> (x, <span class="dt">Even</span> xs)</a>
<a class="sourceLine" id="cb23-8" data-line-number="8">uncons (<span class="dt">Even</span>  xs) <span class="fu">=</span> <span class="kw">case</span> uncons xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb23-9" data-line-number="9">    ((x,y),ys) <span class="ot">-&gt;</span> (x, <span class="dt">Odd</span> y ys)</a>
<a class="sourceLine" id="cb23-10" data-line-number="10">uncons <span class="dt">Nil</span> <span class="fu">=</span> <span class="fu">???</span></a></code></pre></div>
<p>We <em>should</em> be able to write this function without returning a <code>Maybe</code>. Because we statically know the size, we can encode ‚Äúonly nonempty sequences‚Äù. The problem is that <code>Seq [] a</code> isn‚Äôt the only non-empty sequence: there‚Äôs also <code>Seq [O] a</code> and <code>Seq [O,O] a</code>, and so on. Our binary number system is redundant, because it contains trailing zeroes.</p>
<p>We could add some kind of proof into the data structure, but that would (again) be expensive. Instead, we can make the index <em>itself</em> correct-by-construction, by choosing a non-redundant representation of binary numbers.</p>
<p>Here‚Äôs the trick: instead of having a list of bits, we‚Äôre going to have a list of ‚Äúthe distance to the next one‚Äù. This eliminates the redundancy, and translates into our data structure like so:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="kw">data</span> <span class="dt">N</span> <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">|</span> <span class="dt">S</span> <span class="dt">N</span></a>
<a class="sourceLine" id="cb24-2" data-line-number="2"></a>
<a class="sourceLine" id="cb24-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Nest</span> n ns a <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-4" data-line-number="4">    <span class="dt">Odd</span><span class="ot">  ::</span> a <span class="ot">-&gt;</span> (<span class="dt">Seq</span>    ns (a,a)) <span class="ot">-&gt;</span> <span class="dt">Nest</span> <span class="dt">Z</span>     ns a</a>
<a class="sourceLine" id="cb24-5" data-line-number="5">    <span class="dt">Even</span><span class="ot"> ::</span>      (<span class="dt">Nest</span> n ns (a,a)) <span class="ot">-&gt;</span> <span class="dt">Nest</span> (<span class="dt">S</span> n) ns a</a>
<a class="sourceLine" id="cb24-6" data-line-number="6"></a>
<a class="sourceLine" id="cb24-7" data-line-number="7"><span class="kw">data</span> <span class="dt">Seq</span> ns a <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-8" data-line-number="8">    <span class="dt">Nil</span><span class="ot">  ::</span> <span class="dt">Seq</span> <span class="ch">&#39;[] a</span></a>
<a class="sourceLine" id="cb24-9" data-line-number="9">    <span class="dt">Cons</span><span class="ot"> ::</span> <span class="dt">Nest</span> n ns a <span class="ot">-&gt;</span> <span class="dt">Seq</span> (n <span class="fu">:</span> ns) a</a></code></pre></div>
<p>Lovely! Crucially for our <code>uncons</code>, we now know that any non-empty list of bits is a non-zero list of bits, so we can type ‚Äúnonempty sequence‚Äù easily:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">Dec</span> (<span class="ot">n ::</span> <span class="dt">N</span>) (<span class="ot">ns ::</span> [<span class="dt">N</span>]) <span class="fu">=</span> (<span class="ot">r ::</span> [<span class="dt">N</span>]) <span class="fu">|</span> r <span class="ot">-&gt;</span> n ns <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-2" data-line-number="2">    <span class="dt">Dec</span> (<span class="dt">S</span> n) ns       <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">:</span> <span class="dt">Dec</span> n ns</a>
<a class="sourceLine" id="cb25-3" data-line-number="3">    <span class="dt">Dec</span> <span class="dt">Z</span>     <span class="ch">&#39;[]      = &#39;</span>[]</a>
<a class="sourceLine" id="cb25-4" data-line-number="4">    <span class="dt">Dec</span> <span class="dt">Z</span>     (n <span class="fu">:</span> ns) <span class="fu">=</span> <span class="dt">S</span> n <span class="fu">:</span> ns</a>
<a class="sourceLine" id="cb25-5" data-line-number="5"></a>
<a class="sourceLine" id="cb25-6" data-line-number="6"><span class="ot">uncons ::</span> <span class="dt">Seq</span> (n <span class="fu">:</span> ns) a <span class="ot">-&gt;</span> (a, <span class="dt">Seq</span> (<span class="dt">Dec</span> n ns) a)</a>
<a class="sourceLine" id="cb25-7" data-line-number="7">uncons (<span class="dt">Cons</span> xs&#39;) <span class="fu">=</span> go xs&#39;</a>
<a class="sourceLine" id="cb25-8" data-line-number="8">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-9" data-line-number="9"><span class="ot">    go ::</span> <span class="dt">Nest</span> n ns a <span class="ot">-&gt;</span> (a, <span class="dt">Seq</span> (<span class="dt">Dec</span> n ns) a)</a>
<a class="sourceLine" id="cb25-10" data-line-number="10">    go (<span class="dt">Odd</span> x <span class="dt">Nil</span>) <span class="fu">=</span> (x, <span class="dt">Nil</span>)</a>
<a class="sourceLine" id="cb25-11" data-line-number="11">    go (<span class="dt">Odd</span> x (<span class="dt">Cons</span> xs)) <span class="fu">=</span> (x, <span class="dt">Cons</span> (<span class="dt">Even</span> xs))</a>
<a class="sourceLine" id="cb25-12" data-line-number="12">    go (<span class="dt">Even</span> xs) <span class="fu">=</span> <span class="kw">case</span> go xs <span class="kw">of</span> ((x,y),ys) <span class="ot">-&gt;</span> (x, <span class="dt">Cons</span> (<span class="dt">Odd</span> y ys))</a></code></pre></div>
<p>We‚Äôre still not done, though: here‚Äôs our new type family for incrementing things.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">Inc</span> (<span class="ot">ns ::</span> [<span class="dt">N</span>])<span class="ot"> ::</span> [<span class="dt">N</span>] <span class="kw">where</span></a>
<a class="sourceLine" id="cb26-2" data-line-number="2">    <span class="dt">Inc</span> <span class="ch">&#39;[] = &#39;</span>[<span class="dt">Z</span>]</a>
<a class="sourceLine" id="cb26-3" data-line-number="3">    <span class="dt">Inc</span> (<span class="dt">S</span> n <span class="fu">:</span> ns) <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">:</span> n <span class="fu">:</span> ns</a>
<a class="sourceLine" id="cb26-4" data-line-number="4">    <span class="dt">Inc</span> (<span class="dt">Z</span>   <span class="fu">:</span> ns) <span class="fu">=</span> <span class="dt">Carry</span> (<span class="dt">Inc</span> ns)</a>
<a class="sourceLine" id="cb26-5" data-line-number="5">    </a>
<a class="sourceLine" id="cb26-6" data-line-number="6"><span class="kw">type</span> family <span class="dt">Carry</span> (<span class="ot">ns ::</span> [<span class="dt">N</span>])<span class="ot"> ::</span> [<span class="dt">N</span>] <span class="kw">where</span></a>
<a class="sourceLine" id="cb26-7" data-line-number="7">    <span class="dt">Carry</span> <span class="ch">&#39;[] = &#39;</span>[]</a>
<a class="sourceLine" id="cb26-8" data-line-number="8">    <span class="dt">Carry</span> (n <span class="fu">:</span> ns) <span class="fu">=</span> <span class="dt">S</span> n <span class="fu">:</span> ns</a></code></pre></div>
<p>The <code>Carry</code> there is ugly, and that ugliness carries into the <code>cons</code> function:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="ot">cons ::</span> a <span class="ot">-&gt;</span> <span class="dt">Seq</span> ns a <span class="ot">-&gt;</span> <span class="dt">Seq</span> (<span class="dt">Inc</span> ns) a</a>
<a class="sourceLine" id="cb27-2" data-line-number="2">cons x <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Cons</span> (<span class="dt">Odd</span> x <span class="dt">Nil</span>)</a>
<a class="sourceLine" id="cb27-3" data-line-number="3">cons x&#39; (<span class="dt">Cons</span> xs&#39;) <span class="fu">=</span> go x&#39; xs&#39;</a>
<a class="sourceLine" id="cb27-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb27-5" data-line-number="5"><span class="ot">    go ::</span> a <span class="ot">-&gt;</span> <span class="dt">Nest</span> n ns a <span class="ot">-&gt;</span> <span class="dt">Seq</span> (<span class="dt">Inc</span> (n<span class="fu">:</span>ns)) a</a>
<a class="sourceLine" id="cb27-6" data-line-number="6">    go x (<span class="dt">Even</span>  xs) <span class="fu">=</span> <span class="dt">Cons</span> (<span class="dt">Odd</span> x (<span class="dt">Cons</span> xs))</a>
<a class="sourceLine" id="cb27-7" data-line-number="7">    go x (<span class="dt">Odd</span> y <span class="dt">Nil</span>) <span class="fu">=</span> <span class="dt">Cons</span> (<span class="dt">Even</span> (<span class="dt">Odd</span> (x,y) <span class="dt">Nil</span>))</a>
<a class="sourceLine" id="cb27-8" data-line-number="8">    go x (<span class="dt">Odd</span> y (<span class="dt">Cons</span> ys)) <span class="fu">=</span> carry (go (x,y) ys)</a>
<a class="sourceLine" id="cb27-9" data-line-number="9"></a>
<a class="sourceLine" id="cb27-10" data-line-number="10"><span class="ot">    carry ::</span> <span class="dt">Seq</span> ns (a,a) <span class="ot">-&gt;</span> <span class="dt">Seq</span> (<span class="dt">Carry</span> ns) a</a>
<a class="sourceLine" id="cb27-11" data-line-number="11">    carry <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb27-12" data-line-number="12">    carry (<span class="dt">Cons</span> xs) <span class="fu">=</span> <span class="dt">Cons</span> (<span class="dt">Even</span> xs)</a></code></pre></div>
<p>To clean it up, we‚Äôre going to use another technique.</p>
<h1 id="technique-4-provide-information-on-indices-as-early-as-possible">Technique 4: Provide Information on Indices as Early as Possible</h1>
<p>You occasionally see people wonder about the usual definition of addition on Peano numbers:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb28-1" data-line-number="1"><span class="ot">_</span>+<span class="ot">_</span> <span class="ot">:</span> ‚Ñï <span class="ot">‚Üí</span> ‚Ñï <span class="ot">‚Üí</span> ‚Ñï</a>
<a class="sourceLine" id="cb28-2" data-line-number="2">zero  + m <span class="ot">=</span> m</a>
<a class="sourceLine" id="cb28-3" data-line-number="3">suc n + m <span class="ot">=</span> suc <span class="ot">(</span>n + m<span class="ot">)</span></a></code></pre></div>
<p>It‚Äôs very simple, with only two equations. When someone sees the following error, then:</p>
<blockquote>
<p><code>couldn't match type n with n + 0</code></p>
</blockquote>
<p>They might be tempted to add it as an equation to the function:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb29-1" data-line-number="1"><span class="ot">_</span>+<span class="ot">_</span> <span class="ot">:</span> ‚Ñï <span class="ot">‚Üí</span> ‚Ñï <span class="ot">‚Üí</span> ‚Ñï</a>
<a class="sourceLine" id="cb29-2" data-line-number="2">zero  + m    <span class="ot">=</span> m</a>
<a class="sourceLine" id="cb29-3" data-line-number="3">n     + zero <span class="ot">=</span> n</a>
<a class="sourceLine" id="cb29-4" data-line-number="4">suc n + m    <span class="ot">=</span> suc <span class="ot">(</span>n + m<span class="ot">)</span></a></code></pre></div>
<p>Similarly, when someone sees the other error commonly found with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>+</mo><annotation encoding="application/x-tex">+</annotation></semantics></math>:</p>
<blockquote>
<p><code>couldn't match type S n + m with n + S m</code></p>
</blockquote>
<p>They‚Äôll add that equation in too! In fact, that particular equation will provide a valid definition of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>+</mo><annotation encoding="application/x-tex">+</annotation></semantics></math>:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="ot">_</span>+<span class="ot">_</span> <span class="ot">:</span> ‚Ñï <span class="ot">‚Üí</span> ‚Ñï <span class="ot">‚Üí</span> ‚Ñï</a>
<a class="sourceLine" id="cb30-2" data-line-number="2">zero  + m <span class="ot">=</span> m</a>
<a class="sourceLine" id="cb30-3" data-line-number="3">suc n + m <span class="ot">=</span> n + suc m</a></code></pre></div>
<p>So why is the first definition of + the one almost always used? Because it <em>maximizes output information from minimal input</em>. Take the second implementation above, the one with the zero on the right. In this function, we have to look at the second argument in the second clause: in other words, we don‚Äôt get to find out about the output until we‚Äôve looked at both <code>n</code> and <code>m</code>. In the usual definition, if you know the first argument is <code>suc</code> something, you also know the <em>output</em> must be <code>suc</code> something.</p>
<p>Similarly with the third implementation: we have to examine the first argument in its <em>entirety</em> before we wrap the output in a constructor. Yes, we can of course prove that they‚Äôre all equivalent, but remember: proofs are expensive, and we‚Äôre looking for speed here. So the first definition of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>+</mo><annotation encoding="application/x-tex">+</annotation></semantics></math> is our best bet, since it tells us the most without having to prove anything.</p>
<p>Looking back at our definition of <code>Inc</code>, we can actually provide more information a little sooner:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">Inc</span> (<span class="ot">ns ::</span> [<span class="dt">N</span>])<span class="ot"> ::</span> [<span class="dt">N</span>] <span class="kw">where</span></a>
<a class="sourceLine" id="cb31-2" data-line-number="2">    <span class="dt">Inc</span> <span class="ch">&#39;[] = &#39;</span>[<span class="dt">Z</span>]</a>
<a class="sourceLine" id="cb31-3" data-line-number="3">    <span class="dt">Inc</span> (<span class="dt">S</span> n <span class="fu">:</span> ns) <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">:</span> n <span class="fu">:</span> ns</a>
<a class="sourceLine" id="cb31-4" data-line-number="4">    <span class="dt">Inc</span> (<span class="dt">Z</span>   <span class="fu">:</span> ns) <span class="fu">=</span> <span class="dt">Carry</span> (<span class="dt">Inc</span> ns)</a></code></pre></div>
<p>In all of the outputs, the list is non-empty. We can encode that, by having two different functions for the head and tail of the list:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">IncHead</span> (<span class="ot">ns ::</span> [<span class="dt">N</span>])<span class="ot"> ::</span> <span class="dt">N</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-2" data-line-number="2">    <span class="dt">IncHead</span> <span class="ch">&#39;[] = Z</span></a>
<a class="sourceLine" id="cb32-3" data-line-number="3">    <span class="dt">IncHead</span> (n <span class="fu">:</span> ns) <span class="fu">=</span> <span class="dt">IncHead&#39;</span> n ns</a>
<a class="sourceLine" id="cb32-4" data-line-number="4"></a>
<a class="sourceLine" id="cb32-5" data-line-number="5"><span class="kw">type</span> family <span class="dt">IncHead&#39;</span> (<span class="ot">n ::</span> <span class="dt">N</span>) (<span class="ot">ns ::</span> [<span class="dt">N</span>])<span class="ot"> ::</span> <span class="dt">N</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-6" data-line-number="6">    <span class="dt">IncHead&#39;</span> (<span class="dt">S</span> n) ns <span class="fu">=</span> <span class="dt">Z</span></a>
<a class="sourceLine" id="cb32-7" data-line-number="7">    <span class="dt">IncHead&#39;</span> <span class="dt">Z</span> ns <span class="fu">=</span> <span class="dt">S</span> (<span class="dt">IncHead</span> ns)</a>
<a class="sourceLine" id="cb32-8" data-line-number="8"></a>
<a class="sourceLine" id="cb32-9" data-line-number="9"><span class="kw">type</span> family <span class="dt">IncTail</span> (<span class="ot">ns ::</span> [<span class="dt">N</span>])<span class="ot"> ::</span> [<span class="dt">N</span>] <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-10" data-line-number="10">    <span class="dt">IncTail</span> <span class="ch">&#39;[] = &#39;</span>[]</a>
<a class="sourceLine" id="cb32-11" data-line-number="11">    <span class="dt">IncTail</span> (n <span class="fu">:</span> ns) <span class="fu">=</span> <span class="dt">IncTail&#39;</span> n ns</a>
<a class="sourceLine" id="cb32-12" data-line-number="12"></a>
<a class="sourceLine" id="cb32-13" data-line-number="13"><span class="kw">type</span> family <span class="dt">IncTail&#39;</span> (<span class="ot">n ::</span> <span class="dt">N</span>) (<span class="ot">ns ::</span> [<span class="dt">N</span>])<span class="ot"> ::</span> [<span class="dt">N</span>] <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-14" data-line-number="14">    <span class="dt">IncTail&#39;</span> (<span class="dt">S</span> n) ns <span class="fu">=</span> n <span class="fu">:</span> ns</a>
<a class="sourceLine" id="cb32-15" data-line-number="15">    <span class="dt">IncTail&#39;</span> <span class="dt">Z</span> ns <span class="fu">=</span> <span class="dt">IncTail</span> ns</a>
<a class="sourceLine" id="cb32-16" data-line-number="16"></a>
<a class="sourceLine" id="cb32-17" data-line-number="17"><span class="kw">type</span> <span class="dt">Inc</span> (<span class="ot">ns ::</span> [<span class="dt">N</span>]) <span class="fu">=</span> <span class="dt">IncHead</span> ns <span class="fu">:</span> <span class="dt">IncTail</span> ns</a></code></pre></div>
<p>This tells the typechecker that we‚Äôre not returning an empty sequence right away, so we don‚Äôt have to pattern-match to prove it later, giving us a more efficient function.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" data-line-number="1"><span class="ot">cons ::</span> a <span class="ot">-&gt;</span> <span class="dt">Seq</span> ns a <span class="ot">-&gt;</span> <span class="dt">Seq</span> (<span class="dt">Inc</span> ns) a</a>
<a class="sourceLine" id="cb33-2" data-line-number="2">cons x&#39; xs&#39; <span class="fu">=</span> <span class="dt">Cons</span> (go x&#39; xs&#39;)</a>
<a class="sourceLine" id="cb33-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb33-4" data-line-number="4"><span class="ot">    go ::</span> a <span class="ot">-&gt;</span> <span class="dt">Seq</span> ns a <span class="ot">-&gt;</span> <span class="dt">Nest</span> (<span class="dt">IncHead</span> ns) (<span class="dt">IncTail</span> ns) a</a>
<a class="sourceLine" id="cb33-5" data-line-number="5">    go x <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Odd</span> x <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb33-6" data-line-number="6">    go x (<span class="dt">Cons</span> (<span class="dt">Even</span>  xs)) <span class="fu">=</span> <span class="dt">Odd</span> x (<span class="dt">Cons</span> xs)</a>
<a class="sourceLine" id="cb33-7" data-line-number="7">    go x (<span class="dt">Cons</span> (<span class="dt">Odd</span> y ys)) <span class="fu">=</span> <span class="dt">Even</span> (go (x,y) ys)</a></code></pre></div>
<h1 id="technique-5-lazy-proofs">Technique 5: Lazy Proofs</h1>
<p>Briefly after introducing the binary random-access list, Okasaki describes the <em>skew-binary</em> random-access list. As well as having the same indexing cost as the type above, it supports <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math> <code>cons</code>. But wait‚Äîdidn‚Äôt the previous structure have <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math> <code>cons</code>? Not really. Unfortunately, in a pure functional setting, imperative-style amortization measurements aren‚Äôt always valid. Say we perform a <code>cons</code> in the worst case, and it takes <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>log</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\log n</annotation></semantics></math> time. In an imperative setting, that‚Äôs no problem, because all of the rest of the operations are not going to be on the worst-case. In a pure setting, though, the old structure is still sitting around. You can still access it, and you can still get that awful worst-case time.</p>
<p>This is where the skew binary tree comes in. It‚Äôs based on the <a href="https://en.wikipedia.org/wiki/Skew_binary_number_system">skew binary numbers</a>: these work similarly to binary, but you‚Äôre allowed have (at most) a single 2 digit before any ones. This gives you <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math> incrementing and decrementing, which is what we need here. Let‚Äôs get started.</p>
<p>First, our type-level numbers. We‚Äôre going to use the sparse encoding as above, but we need some way to encode ‚Äúyou‚Äôre only allowed one 2‚Äù. The most lightweight way to do it I can think of is by implicitly assuming the second number in the list of gaps is one less than the others. In other words, we encode a 2 with <code>[n, 0, m]</code>. That <code>0</code> means that at position <code>n</code> there‚Äôs a 2, not a 1.</p>
<p>The corresponding type families for increment and decrement are clearly <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math>:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">Inc</span> (<span class="ot">ns ::</span> [<span class="dt">N</span>]) <span class="fu">=</span> (<span class="ot">ms ::</span> [<span class="dt">N</span>]) <span class="fu">|</span> ms <span class="ot">-&gt;</span> ns <span class="kw">where</span></a>
<a class="sourceLine" id="cb34-2" data-line-number="2">    <span class="dt">Inc</span> <span class="ch">&#39;[]              = Z   : &#39;</span>[]</a>
<a class="sourceLine" id="cb34-3" data-line-number="3">    <span class="dt">Inc</span> (x  <span class="fu">:</span> <span class="ch">&#39;[])       = Z   : x  : &#39;</span>[]</a>
<a class="sourceLine" id="cb34-4" data-line-number="4">    <span class="dt">Inc</span> (x  <span class="fu">:</span> <span class="dt">Z</span>    <span class="fu">:</span> xs) <span class="fu">=</span> <span class="dt">S</span> x <span class="fu">:</span> xs</a>
<a class="sourceLine" id="cb34-5" data-line-number="5">    <span class="dt">Inc</span> (x1 <span class="fu">:</span> <span class="dt">S</span> x2 <span class="fu">:</span> xs) <span class="fu">=</span> <span class="dt">Z</span>   <span class="fu">:</span> x1 <span class="fu">:</span> x2 <span class="fu">:</span> xs</a>
<a class="sourceLine" id="cb34-6" data-line-number="6"></a>
<a class="sourceLine" id="cb34-7" data-line-number="7"><span class="kw">type</span> family <span class="dt">Dec</span> (<span class="ot">n ::</span> <span class="dt">N</span>) (<span class="ot">ns ::</span> [<span class="dt">N</span>]) <span class="fu">=</span> (<span class="ot">ms ::</span> [<span class="dt">N</span>]) <span class="fu">|</span> ms <span class="ot">-&gt;</span> n ns <span class="kw">where</span></a>
<a class="sourceLine" id="cb34-8" data-line-number="8">    <span class="dt">Dec</span> (<span class="dt">S</span> x)  xs            <span class="fu">=</span> x  <span class="fu">:</span> <span class="dt">Z</span> <span class="fu">:</span> xs</a>
<a class="sourceLine" id="cb34-9" data-line-number="9">    <span class="dt">Dec</span> <span class="dt">Z</span>     <span class="ch">&#39;[]            = &#39;</span>[]</a>
<a class="sourceLine" id="cb34-10" data-line-number="10">    <span class="dt">Dec</span> <span class="dt">Z</span>     (x  <span class="fu">:</span> <span class="ch">&#39;[])     = x  : &#39;</span>[]</a>
<a class="sourceLine" id="cb34-11" data-line-number="11">    <span class="dt">Dec</span> <span class="dt">Z</span>     (x1 <span class="fu">:</span> x2 <span class="fu">:</span> xs) <span class="fu">=</span> x1 <span class="fu">:</span> <span class="dt">S</span> x2 <span class="fu">:</span> xs</a></code></pre></div>
<p>We don‚Äôt need to split this into head and tail families as we did before because there‚Äôs no recursive call: we know all we‚Äôre ever going to know about the output following <em>any</em> match on the input.</p>
<p>There‚Äôs another problem before we write the implementation: we can‚Äôt use the <code>Nest</code> construction that we had before, because then the head would be buried in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>log</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\log n</annotation></semantics></math> constructors (or thereabouts). Instead, we‚Äôre going to have to use GADTs to encode the ‚Äúgap‚Äù type, alongside the relevant tree. This gap type is going to be very similar to the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>‚â•</mo><annotation encoding="application/x-tex">\geq</annotation></semantics></math> proof we had for the modular counters, but with an extra parameter:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb35-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Gap</span> (<span class="ot">n ::</span> <span class="dt">N</span>) (<span class="ot">g ::</span> <span class="dt">N</span>) (<span class="ot">m ::</span> <span class="dt">N</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb35-2" data-line-number="2">    <span class="dt">Zy</span><span class="ot"> ::</span> <span class="dt">Gap</span> n <span class="dt">Z</span> n</a>
<a class="sourceLine" id="cb35-3" data-line-number="3">    <span class="dt">Sy</span><span class="ot"> ::</span> <span class="dt">Gap</span> n g m <span class="ot">-&gt;</span> <span class="dt">Gap</span> n (<span class="dt">S</span> g) (<span class="dt">S</span> m)</a></code></pre></div>
<p><code>Gap n g m</code> means there is a gap of <code>g</code> between <code>n</code> and <code>m</code>. Or, stated another way, it means <code>n + g = m</code>. Its inductive structure mimics the <code>g</code> parameter (it‚Äôs basically the <code>g</code> parameter itself with some added information).</p>
<p>With all of that together, here‚Äôs the definition of the array itself:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">Tree</span> (<span class="ot">n ::</span> <span class="dt">N</span>) (<span class="ot">a ::</span> <span class="dt">Type</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb36-2" data-line-number="2">    <span class="dt">Tree</span> <span class="dt">Z</span> a <span class="fu">=</span> a</a>
<a class="sourceLine" id="cb36-3" data-line-number="3">    <span class="dt">Tree</span> (<span class="dt">S</span> n) a <span class="fu">=</span> <span class="dt">Node</span> n a</a>
<a class="sourceLine" id="cb36-4" data-line-number="4"></a>
<a class="sourceLine" id="cb36-5" data-line-number="5"><span class="kw">data</span> <span class="dt">Node</span> n a <span class="fu">=</span> <span class="dt">Node</span> a (<span class="dt">Tree</span> n a) (<span class="dt">Tree</span> n a)</a>
<a class="sourceLine" id="cb36-6" data-line-number="6"></a>
<a class="sourceLine" id="cb36-7" data-line-number="7"><span class="kw">data</span> <span class="dt">SeqTail</span> (<span class="ot">n ::</span> <span class="dt">N</span>) (<span class="ot">ns ::</span> [<span class="dt">N</span>]) (<span class="ot">a ::</span> <span class="dt">Type</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb36-8" data-line-number="8">    <span class="dt">NilT</span><span class="ot">  ::</span> <span class="dt">SeqTail</span> n <span class="ch">&#39;[] a</span></a>
<a class="sourceLine" id="cb36-9" data-line-number="9">    <span class="dt">ConsT</span><span class="ot"> ::</span> <span class="dt">Gap</span> n g m</a>
<a class="sourceLine" id="cb36-10" data-line-number="10">          <span class="ot">-&gt;</span> <span class="dt">Tree</span> m a</a>
<a class="sourceLine" id="cb36-11" data-line-number="11">          <span class="ot">-&gt;</span> <span class="dt">SeqTail</span> (<span class="dt">S</span> m) ms a</a>
<a class="sourceLine" id="cb36-12" data-line-number="12">          <span class="ot">-&gt;</span> <span class="dt">SeqTail</span> n (g <span class="fu">:</span> ms) a</a>
<a class="sourceLine" id="cb36-13" data-line-number="13"></a>
<a class="sourceLine" id="cb36-14" data-line-number="14"><span class="kw">data</span> <span class="dt">Seq</span> (<span class="ot">ns ::</span> [<span class="dt">N</span>]) (<span class="ot">a ::</span> <span class="dt">Type</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb36-15" data-line-number="15">    <span class="dt">Nil</span><span class="ot">  ::</span> <span class="dt">Seq</span> <span class="ch">&#39;[] a</span></a>
<a class="sourceLine" id="cb36-16" data-line-number="16">    <span class="dt">Cons</span><span class="ot"> ::</span> <span class="dt">Gap</span> <span class="dt">Z</span> g n</a>
<a class="sourceLine" id="cb36-17" data-line-number="17">         <span class="ot">-&gt;</span> <span class="dt">Tree</span> n a</a>
<a class="sourceLine" id="cb36-18" data-line-number="18">         <span class="ot">-&gt;</span> <span class="dt">SeqTail</span> n ns a</a>
<a class="sourceLine" id="cb36-19" data-line-number="19">         <span class="ot">-&gt;</span> <span class="dt">Seq</span> (g <span class="fu">:</span> ns) a</a></code></pre></div>
<p>The <code>cons</code> operation again mimics the increment function, but there‚Äôs one final snag before it‚Äôll typecheck:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb37-1" data-line-number="1"><span class="ot">cons ::</span> a <span class="ot">-&gt;</span> <span class="dt">Seq</span> ns a <span class="ot">-&gt;</span> <span class="dt">Seq</span> (<span class="dt">Inc</span> ns) a</a>
<a class="sourceLine" id="cb37-2" data-line-number="2">cons x <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Cons</span> <span class="dt">Zy</span> x <span class="dt">NilT</span></a>
<a class="sourceLine" id="cb37-3" data-line-number="3">cons x (<span class="dt">Cons</span> zn y <span class="dt">NilT</span>) <span class="fu">=</span> <span class="dt">Cons</span> <span class="dt">Zy</span> x (<span class="dt">ConsT</span> zn y <span class="dt">NilT</span>)</a>
<a class="sourceLine" id="cb37-4" data-line-number="4">cons x (<span class="dt">Cons</span> zn y1 (<span class="dt">ConsT</span> <span class="dt">Zy</span> y2 ys)) <span class="fu">=</span> <span class="dt">Cons</span>(<span class="dt">Sy</span> zn) (<span class="dt">Node</span> x y1 y2) ys</a>
<a class="sourceLine" id="cb37-5" data-line-number="5">cons x (<span class="dt">Cons</span> zn y1 (<span class="dt">ConsT</span> (<span class="dt">Sy</span> nm) y2 ys)) <span class="fu">=</span></a>
<a class="sourceLine" id="cb37-6" data-line-number="6">    <span class="dt">Cons</span> <span class="dt">Zy</span> x (<span class="dt">ConsT</span> zn y1 (<span class="dt">ConsT</span> <span class="fu">???</span> y2 ys))</a></code></pre></div>
<p>On the final line, the <code>???</code> is missing. In the unverified version, <code>nm</code> would slot right in there. Here, though, if we try it we get an error, which basically amounts to:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb38-1" data-line-number="1"><span class="dt">Gap</span> n g m <span class="fu">/=</span> <span class="dt">Gap</span> (<span class="dt">S</span> n) g (<span class="dt">S</span> m)</a></code></pre></div>
<p>At this point, I‚Äôd usually throw out the inductive-style proof, and replace it with a proof of equality, which I‚Äôd aggressively erase in all of the functions. I said at the beginning I wouldn‚Äôt cheat, though, so here‚Äôs what I‚Äôll do instead:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb39-1" data-line-number="1"><span class="ot">gapr ::</span> <span class="dt">Gap</span> n g m <span class="ot">-&gt;</span> <span class="dt">Gap</span> (<span class="dt">S</span> n) g (<span class="dt">S</span> m)</a>
<a class="sourceLine" id="cb39-2" data-line-number="2">gapr <span class="dt">Zy</span>       <span class="fu">=</span> <span class="dt">Zy</span></a>
<a class="sourceLine" id="cb39-3" data-line-number="3">gapr (<span class="dt">Sy</span> pnm) <span class="fu">=</span> <span class="dt">Sy</span> (gapr pnm)</a>
<a class="sourceLine" id="cb39-4" data-line-number="4"></a>
<a class="sourceLine" id="cb39-5" data-line-number="5"><span class="ot">cons ::</span> a <span class="ot">-&gt;</span> <span class="dt">Seq</span> ns a <span class="ot">-&gt;</span> <span class="dt">Seq</span> (<span class="dt">Inc</span> ns) a</a>
<a class="sourceLine" id="cb39-6" data-line-number="6">cons x <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Cons</span> <span class="dt">Zy</span> x <span class="dt">NilT</span></a>
<a class="sourceLine" id="cb39-7" data-line-number="7">cons x (<span class="dt">Cons</span> zn y <span class="dt">NilT</span>) <span class="fu">=</span> <span class="dt">Cons</span> <span class="dt">Zy</span> x (<span class="dt">ConsT</span> zn y <span class="dt">NilT</span>)</a>
<a class="sourceLine" id="cb39-8" data-line-number="8">cons x (<span class="dt">Cons</span> zn y1 (<span class="dt">ConsT</span> <span class="dt">Zy</span> y2 ys)) <span class="fu">=</span> <span class="dt">Cons</span> (<span class="dt">Sy</span> zn) (<span class="dt">Node</span> x y1 y2) ys</a>
<a class="sourceLine" id="cb39-9" data-line-number="9">cons x (<span class="dt">Cons</span> zn y1 (<span class="dt">ConsT</span> (<span class="dt">Sy</span> nm) y2 ys)) <span class="fu">=</span></a>
<a class="sourceLine" id="cb39-10" data-line-number="10">    <span class="dt">Cons</span> <span class="dt">Zy</span> x (<span class="dt">ConsT</span> zn y1 (<span class="dt">ConsT</span> (gapr nm) y2 ys))</a></code></pre></div>
<p>At first glance, we‚Äôve lost the complexity bounds. That <code>gapr</code> operation is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>log</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\log n</annotation></semantics></math> (or something), and we‚Äôre performing it pretty frequently. We might keep the amortized bounds, but isn‚Äôt that not really worthy in a pure setting?</p>
<p>That would all be true, if it weren‚Äôt for laziness. Because we <em>delay</em> the evaluation of <code>gapr</code>, we won‚Äôt have to pay for it all in one big thunk. In fact, because it‚Äôs basically a unary number, we only have to pay for one part of it at a time. I haven‚Äôt yet fully worked out the proofs, but I‚Äôm pretty sure we‚Äôre guaranteed <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math> worst-case time here too.</p>
<h1 id="technique-6-when-all-else-fails-prove-it-later">Technique 6: When All Else Fails, Prove it Later</h1>
<p>About a year ago, I <a href="/posts/2017-04-23-verifying-data-structures-in-haskell-lhs.html">tried</a> to write a verified version of binomial heaps, which could then be used for sorting traversable containers. Unfortunately, I couldn‚Äôt figure out how to write delete-min, and gave up. I <em>did</em> recognize that the redundancy of the binary representation was a problem, but I couldn‚Äôt figure out much more than that.</p>
<p>Now, though, we have a new non-redundant representation of binary numbers, and some handy techniques to go along with it.</p>
<p>Unfortunately, I ran into a similar roadblock in the implementation. Here‚Äôs the point where I was stuck:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb40-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Zipper</span> a n xs <span class="fu">=</span> <span class="dt">Zipper</span> a (<span class="dt">Node</span> n a) (<span class="dt">Binomial</span> n xs a)</a>
<a class="sourceLine" id="cb40-2" data-line-number="2"></a>
<a class="sourceLine" id="cb40-3" data-line-number="3"><span class="ot">slideLeft ::</span> <span class="dt">Zipper</span> a (<span class="dt">S</span> n) xs <span class="ot">-&gt;</span> <span class="dt">Zipper</span> a n (<span class="dt">Z</span> <span class="fu">:</span> xs)</a>
<a class="sourceLine" id="cb40-4" data-line-number="4">slideLeft (<span class="dt">Zipper</span> m (t <span class="fu">:&lt;</span> ts) hs) <span class="fu">=</span> <span class="dt">Zipper</span> m ts (<span class="dt">Cons</span> (<span class="dt">Odd</span> t hs))</a>
<a class="sourceLine" id="cb40-5" data-line-number="5"></a>
<a class="sourceLine" id="cb40-6" data-line-number="6"><span class="ot">minView ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Binomial</span> n (x <span class="fu">:</span> xs) a <span class="ot">-&gt;</span> (a, <span class="dt">Binomial</span> n (<span class="dt">Decr</span> x xs) a)</a>
<a class="sourceLine" id="cb40-7" data-line-number="7">minView (<span class="dt">Cons</span> xs&#39;) <span class="fu">=</span> unZipper (go xs&#39;)</a>
<a class="sourceLine" id="cb40-8" data-line-number="8">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb40-9" data-line-number="9">    unZipper (<span class="dt">Zipper</span> x _ xs) <span class="fu">=</span> (x, xs)</a>
<a class="sourceLine" id="cb40-10" data-line-number="10"></a>
<a class="sourceLine" id="cb40-11" data-line-number="11"><span class="ot">    go ::</span> forall a n x xs<span class="fu">.</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Nest</span> n x xs a <span class="ot">-&gt;</span> <span class="dt">Zipper</span> a n (<span class="dt">Decr</span> x xs)</a>
<a class="sourceLine" id="cb40-12" data-line-number="12">    go (<span class="dt">Even</span> xs) <span class="fu">=</span> slideLeft (go xs)</a>
<a class="sourceLine" id="cb40-13" data-line-number="13">    go (<span class="dt">Odd</span> (<span class="dt">Root</span> x ts) <span class="dt">Empty</span>) <span class="fu">=</span> <span class="dt">Zipper</span> x ts <span class="dt">Empty</span></a>
<a class="sourceLine" id="cb40-14" data-line-number="14">    go (<span class="dt">Odd</span> c<span class="fu">@</span>(<span class="dt">Root</span> x ts) (<span class="dt">Cons</span> xs)) <span class="fu">=</span></a>
<a class="sourceLine" id="cb40-15" data-line-number="15">        <span class="kw">case</span> go xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb40-16" data-line-number="16">            (<span class="dt">Zipper</span> m (t&#39; <span class="fu">:&lt;</span> _) hs)</a>
<a class="sourceLine" id="cb40-17" data-line-number="17">              <span class="fu">|</span> m <span class="fu">&gt;=</span> x <span class="ot">-&gt;</span> <span class="dt">Zipper</span> x ts (<span class="dt">Cons</span> (<span class="dt">Even</span> xs))</a>
<a class="sourceLine" id="cb40-18" data-line-number="18">              <span class="fu">|</span> otherwise <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb40-19" data-line-number="19">                  <span class="dt">Zipper</span> m ts</a>
<a class="sourceLine" id="cb40-20" data-line-number="20">                      (<span class="kw">case</span> hs <span class="kw">of</span></a>
<a class="sourceLine" id="cb40-21" data-line-number="21">                           <span class="dt">Empty</span> <span class="ot">-&gt;</span> <span class="dt">Cons</span> (<span class="dt">Even</span> (<span class="dt">Odd</span> (mergeTree c t&#39;) <span class="dt">Empty</span>))</a>
<a class="sourceLine" id="cb40-22" data-line-number="22">                           <span class="dt">Cons</span> hs&#39; <span class="ot">-&gt;</span> <span class="dt">Cons</span> (<span class="dt">Even</span> (carryOneNest (mergeTree c t&#39;) hs&#39;)))</a></code></pre></div>
<p>The last two lines don‚Äôt typecheck! The errors were complex, but effectively they stated:</p>
<blockquote>
<p><code>Could not deduce</code></p>
<blockquote>
<p><code class="sourceCode haskell">x <span class="fu">:</span> xs <span class="fu">~</span> [<span class="dt">Z</span>]</code></p>
</blockquote>
<p><code>from the context</code></p>
<blockquote>
<p><code class="sourceCode haskell"><span class="dt">Decr</span> x xs <span class="fu">~</span> []</code></p>
</blockquote>
</blockquote>
<p>and:</p>
<blockquote>
<p><code>Could not deduce</code></p>
<blockquote>
<p><code class="sourceCode haskell">x <span class="fu">:</span> xs <span class="fu">~</span> <span class="dt">Inc</span> (y <span class="fu">:</span> ys)</code></p>
</blockquote>
<p><code>from the context</code></p>
<blockquote>
<p><code class="sourceCode haskell"><span class="dt">Decr</span> x xs <span class="fu">~</span> y <span class="fu">:</span> ys</code></p>
</blockquote>
</blockquote>
<p>The thing is, all of those look pretty provable. So, for this technique, we first figure out what proofs we need, and <em>assume</em> we have them. This means changing <code>minView</code> to the following:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb41-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Zipper</span> a n xs <span class="fu">=</span> <span class="dt">Zipper</span> a (<span class="dt">Node</span> n a) (<span class="dt">Binomial</span> n xs a)</a>
<a class="sourceLine" id="cb41-2" data-line-number="2"></a>
<a class="sourceLine" id="cb41-3" data-line-number="3"><span class="ot">slideLeft ::</span> <span class="dt">Zipper</span> a (<span class="dt">S</span> n) xs <span class="ot">-&gt;</span> <span class="dt">Zipper</span> a n (<span class="dt">Z</span> <span class="fu">:</span> xs)</a>
<a class="sourceLine" id="cb41-4" data-line-number="4">slideLeft (<span class="dt">Zipper</span> m (t <span class="fu">:&lt;</span> ts) hs) <span class="fu">=</span> <span class="dt">Zipper</span> m ts (<span class="dt">Cons</span> (<span class="dt">Odd</span> t hs))</a>
<a class="sourceLine" id="cb41-5" data-line-number="5"></a>
<a class="sourceLine" id="cb41-6" data-line-number="6"><span class="ot">minView ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Binomial</span> n (x <span class="fu">:</span> xs) a <span class="ot">-&gt;</span> (a, <span class="dt">Binomial</span> n (<span class="dt">Decr</span> x xs) a)</a>
<a class="sourceLine" id="cb41-7" data-line-number="7">minView (<span class="dt">Cons</span> xs&#39;) <span class="fu">=</span> unZipper (go xs&#39;)</a>
<a class="sourceLine" id="cb41-8" data-line-number="8">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb41-9" data-line-number="9">    unZipper (<span class="dt">Zipper</span> x _ xs) <span class="fu">=</span> (x, xs)</a>
<a class="sourceLine" id="cb41-10" data-line-number="10"></a>
<a class="sourceLine" id="cb41-11" data-line-number="11"><span class="ot">    go ::</span> forall a n x xs<span class="fu">.</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Nest</span> n x xs a <span class="ot">-&gt;</span> <span class="dt">Zipper</span> a n (<span class="dt">Decr</span> x xs)</a>
<a class="sourceLine" id="cb41-12" data-line-number="12">    go (<span class="dt">Even</span> xs) <span class="fu">=</span> slideLeft (go xs)</a>
<a class="sourceLine" id="cb41-13" data-line-number="13">    go (<span class="dt">Odd</span> (<span class="dt">Root</span> x ts) <span class="dt">Empty</span>) <span class="fu">=</span> <span class="dt">Zipper</span> x ts <span class="dt">Empty</span></a>
<a class="sourceLine" id="cb41-14" data-line-number="14">    go (<span class="dt">Odd</span> c<span class="fu">@</span>(<span class="dt">Root</span> x ts) (<span class="dt">Cons</span> xs)) <span class="fu">=</span></a>
<a class="sourceLine" id="cb41-15" data-line-number="15">        <span class="kw">case</span> go xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb41-16" data-line-number="16">            (<span class="dt">Zipper</span> m (t&#39; <span class="fu">:&lt;</span> _) (<span class="ot">hs ::</span> <span class="dt">Binomial</span> (<span class="dt">S</span> n) (<span class="dt">Decr</span> y ys) a))</a>
<a class="sourceLine" id="cb41-17" data-line-number="17">              <span class="fu">|</span> m <span class="fu">&gt;=</span> x <span class="ot">-&gt;</span> <span class="dt">Zipper</span> x ts (<span class="dt">Cons</span> (<span class="dt">Even</span> xs))</a>
<a class="sourceLine" id="cb41-18" data-line-number="18">              <span class="fu">|</span> otherwise <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb41-19" data-line-number="19">                  <span class="dt">Zipper</span> m ts</a>
<a class="sourceLine" id="cb41-20" data-line-number="20">                      (<span class="kw">case</span> hs <span class="kw">of</span></a>
<a class="sourceLine" id="cb41-21" data-line-number="21">                           <span class="dt">Empty</span> <span class="ot">-&gt;</span> gcastWith (lemma1 <span class="fu">@</span>y <span class="fu">@</span>ys <span class="dt">Refl</span>)</a>
<a class="sourceLine" id="cb41-22" data-line-number="22">                               <span class="dt">Cons</span> (<span class="dt">Even</span> (<span class="dt">Odd</span> (mergeTree c t&#39;) <span class="dt">Empty</span>))</a>
<a class="sourceLine" id="cb41-23" data-line-number="23">                           <span class="dt">Cons</span> hs&#39; <span class="ot">-&gt;</span> gcastWith (lemma2 <span class="fu">@</span>y <span class="fu">@</span>ys <span class="dt">Refl</span>)</a>
<a class="sourceLine" id="cb41-24" data-line-number="24">                               <span class="dt">Cons</span> (<span class="dt">Even</span> (carryOneNest (mergeTree c t&#39;) hs&#39;)))</a></code></pre></div>
<p>And writing in the templates for our lemmas:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb42-1" data-line-number="1"><span class="ot">lemma1 ::</span> forall x xs<span class="fu">.</span> <span class="dt">Decr</span> x xs <span class="fu">:~:</span> <span class="ch">&#39;[] -&gt; x : xs :~: Z : &#39;</span>[]</a>
<a class="sourceLine" id="cb42-2" data-line-number="2">lemma1 <span class="fu">=</span> _</a>
<a class="sourceLine" id="cb42-3" data-line-number="3"></a>
<a class="sourceLine" id="cb42-4" data-line-number="4"><span class="ot">lemma2 ::</span> forall x xs y ys<span class="fu">.</span> <span class="dt">Decr</span> x xs <span class="fu">:~:</span> y <span class="fu">:</span> ys <span class="ot">-&gt;</span> x <span class="fu">:</span> xs <span class="fu">:~:</span> <span class="dt">Inc</span> (y <span class="fu">:</span> ys)</a>
<a class="sourceLine" id="cb42-5" data-line-number="5">lemma2 <span class="fu">=</span> _</a></code></pre></div>
<p>We now need to provide the <em>implementations</em> for <code>lemma1</code> and <code>lemma2</code>. With this approach, even if we fail to do the next steps, we can cop out here and sub in <code>unsafeCoerce Refl</code> in place of the two proofs, maintaining the efficiency. We won‚Äôt need to, though!</p>
<p>Unlike in Agda, the types for those proofs won‚Äôt be around at runtime, so we won‚Äôt have anything to pattern match on. We‚Äôll need to look for things in the surrounding area which could act like singletons for the lemmas.</p>
<p>It turns out that the <code>xs</code> and <code>hs'</code> floating around can do exactly that: they tell us about the type-level <code>y</code> and <code>x</code>. So we just pass them to the lemmas (where they‚Äôre needed). This changes the last 4 lines of <code>minView</code> to:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb43-1" data-line-number="1"><span class="dt">Empty</span> <span class="ot">-&gt;</span> gcastWith (lemma1 <span class="dt">Refl</span> xs)</a>
<a class="sourceLine" id="cb43-2" data-line-number="2">    <span class="dt">Cons</span> (<span class="dt">Even</span> (<span class="dt">Odd</span> (mergeTree c t&#39;) <span class="dt">Empty</span>))</a>
<a class="sourceLine" id="cb43-3" data-line-number="3"><span class="dt">Cons</span> hs&#39; <span class="ot">-&gt;</span> gcastWith (lemma2 <span class="dt">Refl</span> xs hs&#39;)</a>
<a class="sourceLine" id="cb43-4" data-line-number="4">    <span class="dt">Cons</span> (<span class="dt">Even</span> (carryOneNest (mergeTree c t&#39;) hs&#39;))</a></code></pre></div>
<p>Now, we just have to fill in the lemmas! If we were lucky, they‚Äôd actually be constant-time.</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb44-1" data-line-number="1"><span class="ot">lemma1 ::</span> forall x xs n a<span class="fu">.</span> <span class="dt">Decr</span> x xs <span class="fu">:~:</span> <span class="ch">&#39;[]</span></a>
<a class="sourceLine" id="cb44-2" data-line-number="2">       <span class="ot">-&gt;</span>  <span class="dt">Nest</span> n x xs a</a>
<a class="sourceLine" id="cb44-3" data-line-number="3">       <span class="ot">-&gt;</span> x <span class="fu">:</span> xs <span class="fu">:~:</span> <span class="dt">Z</span> <span class="fu">:</span> <span class="ch">&#39;[]</span></a>
<a class="sourceLine" id="cb44-4" data-line-number="4">lemma1 <span class="dt">Refl</span> (<span class="dt">Odd</span> _ <span class="dt">Empty</span>) <span class="fu">=</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb44-5" data-line-number="5"></a>
<a class="sourceLine" id="cb44-6" data-line-number="6"><span class="ot">lemma2 ::</span> forall x xs y ys n a<span class="fu">.</span></a>
<a class="sourceLine" id="cb44-7" data-line-number="7">          <span class="dt">Decr</span> x xs <span class="fu">:~:</span> y <span class="fu">:</span> ys</a>
<a class="sourceLine" id="cb44-8" data-line-number="8">       <span class="ot">-&gt;</span> <span class="dt">Nest</span> n x xs a</a>
<a class="sourceLine" id="cb44-9" data-line-number="9">       <span class="ot">-&gt;</span> <span class="dt">Nest</span> n y ys a</a>
<a class="sourceLine" id="cb44-10" data-line-number="10">       <span class="ot">-&gt;</span> x <span class="fu">:</span> xs <span class="fu">:~:</span> <span class="dt">Inc</span> (y <span class="fu">:</span> ys)</a>
<a class="sourceLine" id="cb44-11" data-line-number="11">lemma2 <span class="dt">Refl</span> (<span class="dt">Even</span> (<span class="dt">Odd</span> _ <span class="dt">Empty</span>)) (<span class="dt">Odd</span> _ <span class="dt">Empty</span>) <span class="fu">=</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb44-12" data-line-number="12">lemma2 <span class="dt">Refl</span> (<span class="dt">Odd</span> _ (<span class="dt">Cons</span> _)) (<span class="dt">Even</span> _) <span class="fu">=</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb44-13" data-line-number="13">lemma2 <span class="dt">Refl</span> (<span class="dt">Even</span> xs) (<span class="dt">Odd</span> _ (<span class="dt">Cons</span> ys)) <span class="fu">=</span></a>
<a class="sourceLine" id="cb44-14" data-line-number="14">  gcastWith (lemma2 <span class="dt">Refl</span> xs ys) <span class="dt">Refl</span></a></code></pre></div>
<p>If they <em>had</em> been constant-time, that would have let us throw them out: each proof would essentially show you what cases needed to be scrutinized to satisfy the typechecker. You then just scrutinize those cases in the actual function, and it should all typecheck.</p>
<p>As it is, <code>lemma2</code> is actually ok. It does cost <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math>, but so does <code>carryOneNest</code>: we‚Äôve maintained the complexity! We <em>could</em> stop here, satisfied.</p>
<p>There‚Äôs another option, though, one that I picked up from Stephanie Weirich‚Äôs talk <span class="citation" data-cites="weirich_dependent_2017">(<a href="#ref-weirich_dependent_2017">2017</a>)</span>: you thread the requirement through the function as an equality constraint. It won‚Äôt always work, but when your function‚Äôs call graph matches that of the proof, the constraint will indeed be satisfied, with no runtime cost. In this case, we can whittle down the proof obligation to the following:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb45-1" data-line-number="1"><span class="dt">Inc</span> (<span class="dt">Decr</span> x xs) <span class="fu">~</span> (x <span class="fu">:</span> xs)</a></code></pre></div>
<p>Now we change the recursive <code>go</code> into continuation-passing style, and add that constraint to its signature, and everything works!</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb46-1" data-line-number="1"><span class="ot">minView ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Binomial</span> n (x <span class="fu">:</span> xs) a <span class="ot">-&gt;</span> (a, <span class="dt">Binomial</span> n (<span class="dt">Decr</span> x xs) a)</a>
<a class="sourceLine" id="cb46-2" data-line-number="2">minView (<span class="dt">Cons</span> xs&#39;) <span class="fu">=</span> go xs&#39; \(<span class="dt">Zipper</span> x _ xs) <span class="ot">-&gt;</span> (x,xs)</a>
<a class="sourceLine" id="cb46-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb46-4" data-line-number="4"><span class="ot">    go ::</span> <span class="dt">Ord</span> a</a>
<a class="sourceLine" id="cb46-5" data-line-number="5">       <span class="ot">=&gt;</span> <span class="dt">Nest</span> n x xs a</a>
<a class="sourceLine" id="cb46-6" data-line-number="6">       <span class="ot">-&gt;</span> (<span class="dt">Inc</span> (<span class="dt">Decr</span> x xs) <span class="fu">~</span> (x <span class="fu">:</span> xs) <span class="ot">=&gt;</span> <span class="dt">Zipper</span> a n (<span class="dt">Decr</span> x xs) <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb46-7" data-line-number="7">    go (<span class="dt">Even</span> xs) k <span class="fu">=</span> go xs \(<span class="dt">Zipper</span> m (t <span class="fu">:&lt;</span> ts) hs) <span class="ot">-&gt;</span> k (<span class="dt">Zipper</span> m ts (<span class="dt">Cons</span> (<span class="dt">Odd</span> t hs)))</a>
<a class="sourceLine" id="cb46-8" data-line-number="8">    go (<span class="dt">Odd</span> (<span class="dt">Root</span> x ts) <span class="dt">Empty</span>) k <span class="fu">=</span> k (<span class="dt">Zipper</span> x ts <span class="dt">Empty</span>)</a>
<a class="sourceLine" id="cb46-9" data-line-number="9">    go (<span class="dt">Odd</span> c<span class="fu">@</span>(<span class="dt">Root</span> x cs) (<span class="dt">Cons</span> xs)) k <span class="fu">=</span></a>
<a class="sourceLine" id="cb46-10" data-line-number="10">        go xs</a>
<a class="sourceLine" id="cb46-11" data-line-number="11">            \<span class="kw">case</span></a>
<a class="sourceLine" id="cb46-12" data-line-number="12">                <span class="dt">Zipper</span> m _ _ <span class="fu">|</span> m <span class="fu">&gt;=</span> x <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb46-13" data-line-number="13">                    k (<span class="dt">Zipper</span> x cs (<span class="dt">Cons</span> (<span class="dt">Even</span> xs)))</a>
<a class="sourceLine" id="cb46-14" data-line-number="14">                <span class="dt">Zipper</span> m (t <span class="fu">:&lt;</span> ts) <span class="dt">Empty</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb46-15" data-line-number="15">                    k (<span class="dt">Zipper</span> m ts (<span class="dt">Cons</span> (<span class="dt">Even</span> (<span class="dt">Odd</span> (mergeTree c t) <span class="dt">Empty</span>))))</a>
<a class="sourceLine" id="cb46-16" data-line-number="16">                <span class="dt">Zipper</span> m (t <span class="fu">:&lt;</span> ts) (<span class="dt">Cons</span> hs) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb46-17" data-line-number="17">                    k (<span class="dt">Zipper</span> m ts (<span class="dt">Cons</span> (<span class="dt">Even</span> (carryOneNest (mergeTree c t) hs))))</a></code></pre></div>
<h1 id="conclusion">Conclusion</h1>
<p>As I mentioned in the beginning, a huge amount of this stuff is <em>much</em> easier using other systems. On top of that, there‚Äôs currently a lot of work being done on dependent type erasure, so that proofs like the above don‚Äôt even exist at runtime. In other words, there‚Äôs a chance that all of these techniques will soon be useless!</p>
<p>Efficient proof-carrying code makes for an interesting puzzle, though, even if it is a bit of a hair shirt.</p>
<h1 id="code">Code</h1>
<p>Fuller implementations of the structures here are in <a href="https://github.com/oisdk/pure-arrays">this</a> git repository.</p>
<h1 id="references" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-bakst_liquidhaskell_2018">
<p>Bakst, Alexander, Ranjit Jhala, Ming Kawaguchi, Patrick Rondon, Eric Seidel, Michael Smith, Anish Tondwalkar, Chris Tetreault, and Niki Vazou. 2018. ‚ÄúLiquidHaskell: Liquid Types For Haskell.‚Äù ucsd-progsys. <a href="https://github.com/ucsd-progsys/liquidhaskell" class="uri">https://github.com/ucsd-progsys/liquidhaskell</a>.</p>
</div>
<div id="ref-ben-amram_pointers_1992">
<p>Ben-Amram, Amir M., and Zvi Galil. 1992. ‚ÄúOn Pointers Versus Addresses.‚Äù <em>J. ACM</em> 39 (3) (July): 617‚Äì648. doi:<a href="https://doi.org/10.1145/146637.146666">10.1145/146637.146666</a>. <a href="http://doi.acm.org/10.1145/146637.146666" class="uri">http://doi.acm.org/10.1145/146637.146666</a>.</p>
</div>
<div id="ref-breitner_ready_2018-1">
<p>Breitner, Joachim, Antal Spector-Zabusky, Yao Li, Christine Rizkallah, John Wiegley, and Stephanie Weirich. 2018. ‚ÄúReady, Set, Verify! Applying Hs-to-coq to Real-world Haskell Code (Experience Report).‚Äù <em>Proc. ACM Program. Lang.</em> 2 (ICFP) (July): 89:1‚Äì89:16. doi:<a href="https://doi.org/10.1145/3236784">10.1145/3236784</a>. <a href="http://doi.acm.org/10.1145/3236784" class="uri">http://doi.acm.org/10.1145/3236784</a>.</p>
</div>
<div id="ref-hinze_numerical_1998">
<p>Hinze, Ralf. 1998. <em>Numerical Representations as Higher-Order Nested Datatypes</em>. Institut f√ºr Informatik III, Universit√§t Bonn. <a href="http://www.cs.ox.ac.uk/ralf.hinze/publications/\#R5" class="uri">http://www.cs.ox.ac.uk/ralf.hinze/publications/\#R5</a>.</p>
</div>
<div id="ref-hinze_perfect_1999">
<p>‚Äî‚Äî‚Äî. 1999. <em>Perfect Trees and Bit-reversal Permutations</em>.</p>
</div>
<div id="ref-komuves_nested-sequence_2016">
<p>Komuves, Balazs, and Peter Divianszky. 2016. ‚ÄúNested-sequence: List-like data structures with O(Log(n)) random access.‚Äù <a href="http://hackage.haskell.org/package/nested-sequence" class="uri">http://hackage.haskell.org/package/nested-sequence</a>.</p>
</div>
<div id="ref-mcbride_how_2014">
<p>McBride, Conor Thomas. 2014. ‚ÄúHow to Keep Your Neighbours in Order.‚Äù In <em>Proceedings of the 19th ACM SIGPLAN International Conference on Functional Programming</em>, 297‚Äì309. ICFP ‚Äô14. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/2628136.2628163">10.1145/2628136.2628163</a>. <a href="https://personal.cis.strath.ac.uk/conor.mcbride/pub/Pivotal.pdf" class="uri">https://personal.cis.strath.ac.uk/conor.mcbride/pub/Pivotal.pdf</a>.</p>
</div>
<div id="ref-might_missing_2015">
<p>Might, Matthew. 2015. ‚ÄúMissing method: How to delete from Okasaki‚Äôs red-black trees.‚Äù <em>matt.might.net</em>. <a href="http://matt.might.net/articles/red-black-delete/" class="uri">http://matt.might.net/articles/red-black-delete/</a>.</p>
</div>
<div id="ref-okasaki_fast_1999">
<p>Okasaki, Chris. 1999a. ‚ÄúFrom Fast Exponentiation to Square Matrices: An Adventure in Types.‚Äù In <em>Proceedings of the ACM SIGPLAN International Conference on Functional Programming (ICFP‚Äô99), Paris, France, September 27-29, 1999</em>, 34:28. ACM. <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.456.357\&amp;rep=rep1\&amp;type=pdf" class="uri">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.456.357\&amp;rep=rep1\&amp;type=pdf</a>.</p>
</div>
<div id="ref-okasaki_purely_1999">
<p>‚Äî‚Äî‚Äî. 1999b. <em>Purely Functional Data Structures</em>. Cambridge University Press.</p>
</div>
<div id="ref-weirich_depending_2014">
<p>Weirich, Stephanie. 2014. ‚ÄúDepending on Types.‚Äù In <em>Proceedings of the 19th ACM SIGPLAN International Conference on Functional Programming</em>, 241‚Äì241. ICFP ‚Äô14. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/2628136.2631168">10.1145/2628136.2631168</a>. <a href="https://www.cis.upenn.edu/~sweirich/talks/icfp14.pdf" class="uri">https://www.cis.upenn.edu/~sweirich/talks/icfp14.pdf</a>.</p>
</div>
<div id="ref-weirich_dependent_2017">
<p>‚Äî‚Äî‚Äî. 2017. ‚ÄúDependent Types in Haskell.‚Äù St. Louis, MO, USA. <a href="https://www.youtube.com/watch?v=wNa3MMbhwS4" class="uri">https://www.youtube.com/watch?v=wNa3MMbhwS4</a>.</p>
</div>
</div>
]]></description>
    <pubDate>Tue, 20 Nov 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-11-20-fast-verified-structures.html</guid>
    <dc:creator>Donnacha Ois√≠n Kidney</dc:creator>
</item>
<item>
    <title>A Very Simple Prime Sieve in Haskell</title>
    <link>https://doisinkidney.com/posts/2018-11-10-a-very-simple-prime-sieve.html</link>
    <description><![CDATA[<div class="info">
    Posted on November 10, 2018
</div>
<div class="info">
    
        Part 1 of a <a href="/series/Prime%20Sieves.html">2-part series on Prime Sieves</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<p>A few days ago, the <a href="https://www.youtube.com/user/Computerphile">Computerphile YouTube channel</a> put up a video about infinite lists in Haskell <span class="citation" data-cites="haran_infinity_2018">(Haran <a href="#ref-haran_infinity_2018">2018</a>)</span>. It‚Äôs pretty basic, but finishes up with a definition of an infinite list of prime numbers. The definition was something like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1">primes <span class="fu">=</span> sieve [<span class="dv">2</span><span class="fu">..</span>]</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">sieve (p<span class="fu">:</span>ps) <span class="fu">=</span> p <span class="fu">:</span> sieve [ x <span class="fu">|</span> x <span class="ot">&lt;-</span> ps, mod x p <span class="fu">/=</span> <span class="dv">0</span> ]</a></code></pre></div>
<p>This really demonstrates the elegance of list comprehensions coupled with lazy evaluation. If we‚Äôre being totally pedantic, however, this <em>isn‚Äôt</em> a genuine <a href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes">sieve of Eratosthenes</a>. And this makes sense: the ‚Äútrue‚Äù sieve of Eratosthenes <span class="citation" data-cites="oneill_genuine_2009">(O‚ÄôNeill <a href="#ref-oneill_genuine_2009">2009</a>)</span> is probably too complex to demonstrate in a video meant to be an introduction to Haskell. This isn‚Äôt because Haskell is bad at this particular problem, mind you: it‚Äôs because a lazy, infinite sieve is something very hard to implement indeed.</p>
<p>Anyway, I‚Äôm going to try today to show a very simple prime sieve that (hopefully) rivals the simplicity of the definition above.</p>
<h1 id="a-first-attempt">A First Attempt</h1>
<p>Visualizations of the sieve of Eratosthenes often rely on metaphors of ‚Äúcrossing out‚Äù on some large table. Once you hit a prime, you cross off all of its multiples in the rest of the table, and then you move to the next crossed-off number.</p>
<figure>
<img src="https://upload.wikimedia.org/wikipedia/commons/0/0b/Sieve_of_Eratosthenes_animation.svg" alt="Sieve of Eratosthenes Animation. By Ricordisamoa, CC BY-SA 3.0, from Wikimedia Commons" /><figcaption>Sieve of Eratosthenes Animation. By Ricordisamoa, CC BY-SA 3.0, from Wikimedia Commons</figcaption>
</figure>
<p>Working with a finite array, it should be easy to see that this is extremely efficient. You‚Äôre crossing off every non-prime exactly once, only using addition and squaring.</p>
<p>To extend it to infinite lists, we will use the following function:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1">[] \\ ys <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">xs \\ [] <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">(x<span class="fu">:</span>xs) \\ (y<span class="fu">:</span>ys) <span class="fu">=</span> <span class="kw">case</span> compare x y <span class="kw">of</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">    <span class="dt">LT</span> <span class="ot">-&gt;</span> x <span class="fu">:</span> xs \\ (y<span class="fu">:</span>ys)</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">    <span class="dt">EQ</span> <span class="ot">-&gt;</span> xs \\ ys</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">    <span class="dt">GT</span> <span class="ot">-&gt;</span> (x<span class="fu">:</span>xs) \\ ys</a></code></pre></div>
<p>We‚Äôre ‚Äúsubtracting‚Äù the right list from the left. Crucially, it works with infinite lists:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> take <span class="dv">10</span> ([<span class="dv">1</span><span class="fu">..</span>] \\ [<span class="dv">2</span>,<span class="dv">4</span><span class="fu">..</span>])</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">[<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">7</span>,<span class="dv">9</span>,<span class="dv">11</span>,<span class="dv">13</span>,<span class="dv">15</span>,<span class="dv">17</span>,<span class="dv">19</span>]</a></code></pre></div>
<p>Finally, it only works if both lists are ordered and don‚Äôt contain duplicates, but our sieve does indeed satisfy that requirement. Using this, we‚Äôve already got a sieve:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">sieve (p<span class="fu">:</span>ps) <span class="fu">=</span> p <span class="fu">:</span> sieve (ps \\ [p<span class="fu">*</span>p, p<span class="fu">*</span>p<span class="fu">+</span>p<span class="fu">..</span>])</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">primes <span class="fu">=</span> <span class="dv">2</span> <span class="fu">:</span> sieve [<span class="dv">3</span>,<span class="dv">5</span><span class="fu">..</span>]</a></code></pre></div>
<p>No division, just addition and squaring, as promised. Unfortunately, though, this doesn‚Äôt have the time complexity we want. See, in the <code>(\\)</code> operation, we have to test every entry in the sieve against the prime factor: when we‚Äôre crossing off from an array, we just jump to the next composite number.</p>
<h1 id="using-a-queue">Using a Queue</h1>
<p>The way we speed up the ‚Äúcrossing-off‚Äù section of the algorithms is by using a priority queue: this was the optimization provided in <span class="citation" data-cites="oneill_genuine_2009">O‚ÄôNeill (<a href="#ref-oneill_genuine_2009">2009</a>)</span>. Before we go any further, then, let‚Äôs put one together:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:-</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Queue</span> a b <span class="fu">=</span> <span class="dt">Queue</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">    {<span class="ot"> minKey ::</span> <span class="fu">!</span>a</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">    ,<span class="ot"> minVal ::</span> b</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">    ,<span class="ot"> rest   ::</span> <span class="dt">List</span> a b</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">    }</a>
<a class="sourceLine" id="cb5-7" data-line-number="7"></a>
<a class="sourceLine" id="cb5-8" data-line-number="8"><span class="kw">data</span> <span class="dt">List</span> a b</a>
<a class="sourceLine" id="cb5-9" data-line-number="9">    <span class="fu">=</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb5-10" data-line-number="10">    <span class="fu">|</span> (<span class="fu">:-</span>) <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span>(<span class="dt">Queue</span> a b)</a>
<a class="sourceLine" id="cb5-11" data-line-number="11">           (<span class="dt">List</span> a b)</a>
<a class="sourceLine" id="cb5-12" data-line-number="12"></a>
<a class="sourceLine" id="cb5-13" data-line-number="13"></a>
<a class="sourceLine" id="cb5-14" data-line-number="14"><span class="ot">(&lt;+&gt;) ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Queue</span> a b <span class="ot">-&gt;</span> <span class="dt">Queue</span> a b <span class="ot">-&gt;</span> <span class="dt">Queue</span> a b</a>
<a class="sourceLine" id="cb5-15" data-line-number="15">(<span class="fu">&lt;+&gt;</span>) q1<span class="fu">@</span>(<span class="dt">Queue</span> x1 y1 ts1) q2<span class="fu">@</span>(<span class="dt">Queue</span> x2 y2 ts2)</a>
<a class="sourceLine" id="cb5-16" data-line-number="16">  <span class="fu">|</span> x1 <span class="fu">&lt;=</span> x2 <span class="fu">=</span> <span class="dt">Queue</span> x1 y1 (q2 <span class="fu">:-</span> ts1)</a>
<a class="sourceLine" id="cb5-17" data-line-number="17">  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Queue</span> x2 y2 (q1 <span class="fu">:-</span> ts2)</a>
<a class="sourceLine" id="cb5-18" data-line-number="18"></a>
<a class="sourceLine" id="cb5-19" data-line-number="19"><span class="ot">mergeQs ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">List</span> a b <span class="ot">-&gt;</span> <span class="dt">Queue</span> a b</a>
<a class="sourceLine" id="cb5-20" data-line-number="20">mergeQs (t <span class="fu">:-</span> <span class="dt">Nil</span>)        <span class="fu">=</span> t</a>
<a class="sourceLine" id="cb5-21" data-line-number="21">mergeQs (t1 <span class="fu">:-</span> t2 <span class="fu">:-</span> <span class="dt">Nil</span>) <span class="fu">=</span> t1 <span class="fu">&lt;+&gt;</span> t2</a>
<a class="sourceLine" id="cb5-22" data-line-number="22">mergeQs (t1 <span class="fu">:-</span> t2 <span class="fu">:-</span> ts)  <span class="fu">=</span> (t1 <span class="fu">&lt;+&gt;</span> t2) <span class="fu">&lt;+&gt;</span> mergeQs ts</a>
<a class="sourceLine" id="cb5-23" data-line-number="23">mergeQs <span class="dt">Nil</span>               <span class="fu">=</span> errorWithoutStackTrace <span class="st">&quot;tried to merge empty list&quot;</span></a>
<a class="sourceLine" id="cb5-24" data-line-number="24"></a>
<a class="sourceLine" id="cb5-25" data-line-number="25"><span class="ot">insert ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Queue</span> a b <span class="ot">-&gt;</span> <span class="dt">Queue</span> a b</a>
<a class="sourceLine" id="cb5-26" data-line-number="26">insert <span class="fu">!</span>k <span class="fu">!</span>v <span class="fu">=</span> (<span class="fu">&lt;+&gt;</span>) (singleton k v)</a>
<a class="sourceLine" id="cb5-27" data-line-number="27"></a>
<a class="sourceLine" id="cb5-28" data-line-number="28"><span class="ot">singleton ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Queue</span> a b</a>
<a class="sourceLine" id="cb5-29" data-line-number="29">singleton <span class="fu">!</span>k <span class="fu">!</span>v <span class="fu">=</span> <span class="dt">Queue</span> k v <span class="dt">Nil</span></a></code></pre></div>
<p>These are pairing heaps: I‚Äôm using them here because they‚Äôre relatively simple and very fast. A lot of their speed comes from the fact that the top-level constructor (<code>Queue</code>) is <em>non-empty</em>. Since, in this algorithm, we‚Äôre only actually going to be working with non-empty queues, this saves us a pattern match on pretty much every function. They‚Äôre also what‚Äôs used in <a href="https://github.com/haskell/containers/blob/master/Data/Sequence/Internal/sorting.md#sorting">Data.Sequence for sorting</a>.</p>
<p>With that, we can write our proper sieve:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1">insertPrime x xs <span class="fu">=</span> insert (x<span class="fu">*</span>x) (map (<span class="fu">*</span>x) xs)</a>
<a class="sourceLine" id="cb6-2" data-line-number="2"></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">adjust x q<span class="fu">@</span>(<span class="dt">Queue</span> y (z<span class="fu">:</span>zs) qs)</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">  <span class="fu">|</span> y <span class="fu">&lt;=</span> x <span class="fu">=</span> adjust x (insert z zs (mergeQs qs))</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">  <span class="fu">|</span> otherwise <span class="fu">=</span> q</a>
<a class="sourceLine" id="cb6-6" data-line-number="6"></a>
<a class="sourceLine" id="cb6-7" data-line-number="7">sieve (x<span class="fu">:</span>xs) <span class="fu">=</span> x <span class="fu">:</span> sieve&#39; xs (singleton (x<span class="fu">*</span>x) (map (<span class="fu">*</span>x) xs))</a>
<a class="sourceLine" id="cb6-8" data-line-number="8">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-9" data-line-number="9">    sieve&#39; (x<span class="fu">:</span>xs) table</a>
<a class="sourceLine" id="cb6-10" data-line-number="10">      <span class="fu">|</span> minKey table <span class="fu">&lt;=</span> x <span class="fu">=</span> sieve&#39; xs (adjust x table)</a>
<a class="sourceLine" id="cb6-11" data-line-number="11">      <span class="fu">|</span> otherwise <span class="fu">=</span> x <span class="fu">:</span> sieve&#39; xs (insertPrime x xs table)</a>
<a class="sourceLine" id="cb6-12" data-line-number="12">      </a>
<a class="sourceLine" id="cb6-13" data-line-number="13">primes <span class="fu">=</span> <span class="dv">2</span> <span class="fu">:</span> sieve [<span class="dv">3</span>,<span class="dv">5</span><span class="fu">..</span>]</a></code></pre></div>
<h1 id="simplifying">Simplifying</h1>
<p>The priority queue stores lists alongside their keys: what you might notice is that those lists are simply sequences of the type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mi>x</mi><mo>,</mo><mn>2</mn><mi>x</mi><mo>,</mo><mn>3</mn><mi>x</mi><mo>,</mo><mn>4</mn><mi>x</mi><mi>.</mi><mi>.</mi><mi>.</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[x, 2x, 3x, 4x...]</annotation></semantics></math> and so on. Rather than storing the whole list, we can instead store just the head and the step. This also simplifies (and greatly speeds up) the expensive <code>map (*x)</code> operation to just <em>two</em> multiplications. If you wanted, you could just sub in this representation of streams for all the lists above:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Stepper</span> a <span class="fu">=</span> <span class="dt">Stepper</span> {<span class="ot"> start ::</span> a,<span class="ot"> step ::</span> a }</a>
<a class="sourceLine" id="cb7-2" data-line-number="2"></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="ot">nextStep ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Stepper</span> a <span class="ot">-&gt;</span> (a, <span class="dt">Stepper</span> a)</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">nextStep (<span class="dt">Stepper</span> x y) <span class="fu">=</span> (x, <span class="dt">Stepper</span> (x<span class="fu">+</span>y) y)</a>
<a class="sourceLine" id="cb7-5" data-line-number="5"></a>
<a class="sourceLine" id="cb7-6" data-line-number="6">pattern x <span class="fu">:-</span> xs <span class="ot">&lt;-</span> (nextStep <span class="ot">-&gt;</span> (x,xs))</a>
<a class="sourceLine" id="cb7-7" data-line-number="7"></a>
<a class="sourceLine" id="cb7-8" data-line-number="8"><span class="ot">(^*) ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Stepper</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Stepper</span> a</a>
<a class="sourceLine" id="cb7-9" data-line-number="9"><span class="dt">Stepper</span> x y <span class="fu">^*</span> f <span class="fu">=</span> <span class="dt">Stepper</span> (x <span class="fu">*</span> f) (y <span class="fu">*</span> f)</a></code></pre></div>
<p>If you were so inclined, you could even make it conform to <code>Foldable</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Stepper</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">    <span class="dt">Stepper</span><span class="ot"> ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Stepper</span> a</a>
<a class="sourceLine" id="cb8-3" data-line-number="3"></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">nextStep (<span class="dt">Stepper</span> x y) <span class="fu">=</span> (x, <span class="dt">Stepper</span> (x<span class="fu">+</span>y) y)</a>
<a class="sourceLine" id="cb8-5" data-line-number="5"></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">pattern x <span class="fu">:-</span> xs <span class="ot">&lt;-</span> (nextStep <span class="ot">-&gt;</span> (x,xs))</a>
<a class="sourceLine" id="cb8-7" data-line-number="7"></a>
<a class="sourceLine" id="cb8-8" data-line-number="8"><span class="kw">instance</span> <span class="dt">Foldable</span> <span class="dt">Stepper</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-9" data-line-number="9">    foldr f b (x <span class="fu">:-</span> xs) <span class="fu">=</span> f x (foldr f b xs)</a></code></pre></div>
<p>But that‚Äôs overkill for what we need here.</p>
<p>Second observation is that if we remove the wheel (from 2), the ‚Äústart‚Äù is simply the <em>key</em> in the priority queue, again cutting down on space.</p>
<p>Finally, we get the implementation:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1">primes <span class="fu">=</span> <span class="dv">2</span> <span class="fu">:</span> sieve <span class="dv">3</span> (singleton <span class="dv">4</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">    adjust x q<span class="fu">@</span>(<span class="dt">Queue</span> y z qs)</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">        <span class="fu">|</span> x <span class="fu">&lt;</span> y <span class="fu">=</span> q</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">        <span class="fu">|</span> otherwise <span class="fu">=</span> adjust x (insert (y <span class="fu">+</span> z) z (mergeQs qs))</a>
<a class="sourceLine" id="cb9-6" data-line-number="6">    sieve x q</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">        <span class="fu">|</span> x <span class="fu">&lt;</span> minKey q <span class="fu">=</span> x <span class="fu">:</span> sieve (x <span class="fu">+</span> <span class="dv">1</span>) (insert (x <span class="fu">*</span> x) x q)</a>
<a class="sourceLine" id="cb9-8" data-line-number="8">        <span class="fu">|</span> otherwise <span class="fu">=</span> sieve (x <span class="fu">+</span> <span class="dv">1</span>) (adjust x q)</a></code></pre></div>
<p>8 lines for a lazy prime sieve isn‚Äôt bad!</p>
<p>I haven‚Äôt tried a huge amount to optimize the function, but it might be worth looking in to how to add back the wheels. I noticed that for no wheels, the queue contains only two elements per key; for one (the 2 wheel), we needed 3. I wonder if this pattern continues: possibly we could represent wheels as finite lists at each key in the queue. Maybe in a later post.</p>
<div id="refs" class="references">
<div id="ref-haran_infinity_2018">
<p>Haran, Brady. 2018. ‚ÄúTo Infinity &amp; Beyond - Computerphile.‚Äù <a href="https://www.youtube.com/watch?v=bnRNiE_OVWA&amp;feature=youtu.be" class="uri">https://www.youtube.com/watch?v=bnRNiE_OVWA&amp;feature=youtu.be</a>.</p>
</div>
<div id="ref-oneill_genuine_2009">
<p>O‚ÄôNeill, Melissa E. 2009. ‚ÄúThe Genuine Sieve of Eratosthenes.‚Äù <em>Journal of Functional Programming</em> 19 (01) (January): 95. doi:<a href="https://doi.org/10.1017/S0956796808007004">10.1017/S0956796808007004</a>.</p>
</div>
</div>
]]></description>
    <pubDate>Sat, 10 Nov 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-11-10-a-very-simple-prime-sieve.html</guid>
    <dc:creator>Donnacha Ois√≠n Kidney</dc:creator>
</item>
<item>
    <title>Total Combinations</title>
    <link>https://doisinkidney.com/posts/2018-10-16-total-combinations.html</link>
    <description><![CDATA[<div class="info">
    Posted on October 16, 2018
</div>
<div class="info">
    
        Part 1 of a <a href="/series/Total%20Combinatorics.html">1-part series on Total Combinatorics</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Agda.html">Agda</a>, <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<p>Here‚Äôs a quick puzzle: from a finite alphabet, produce an infinite list of infinite strings, each of them unique.</p>
<p>It‚Äôs not a super hard problem, but here are some examples of what you might get. Given the alphabet of <code>0</code> and <code>1</code>, for instance, you could produce the following:</p>
<pre><code>0000000...
1000000...
0100000...
1100000...
0010000...
1010000...
0110000...
1110000...
0001000...</code></pre>
<p>In other words, the enumeration of the binary numbers (least-significant-digit first). We‚Äôll just deal with bits first:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Bit</span> <span class="fu">=</span> <span class="dt">O</span> <span class="fu">|</span> <span class="dt">I</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Bit</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">    showsPrec _ <span class="dt">O</span> <span class="fu">=</span> (<span class="fu">:</span>) <span class="ch">&#39;0&#39;</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5">    showsPrec _ <span class="dt">I</span> <span class="fu">=</span> (<span class="fu">:</span>) <span class="ch">&#39;1&#39;</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6">    showList xs s <span class="fu">=</span> foldr f s xs</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8">        f <span class="dt">O</span> a <span class="fu">=</span> <span class="ch">&#39;0&#39;</span> <span class="fu">:</span> a</a>
<a class="sourceLine" id="cb2-9" data-line-number="9">        f <span class="dt">I</span> a <span class="fu">=</span> <span class="ch">&#39;1&#39;</span> <span class="fu">:</span> a</a></code></pre></div>
<p>Thinking recursively, we can see that the tail of each list is actually the original sequence, doubled-up:</p>
<p><code class="sourceCode"> 0<span class="er">000000</span>... <br/> 1<span class="er">000000</span>... <br/> 0<span class="er">100000</span>... <br/> 1<span class="er">100000</span>... <br/> 0<span class="er">010000</span>... <br/> 1<span class="er">010000</span>... <br/> 0<span class="er">110000</span>... <br/> 1<span class="er">110000</span>... <br/> 0<span class="er">001000</span>... <br/> </code></p>
<p>As it happens, we get something like this pattern with the monad instance for lists <em>anyway</em>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> (,) <span class="fu">&lt;$&gt;</span> [<span class="dt">O</span>,<span class="dt">I</span>] <span class="fu">&lt;*&gt;</span> <span class="st">&quot;abc&quot;</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">[(<span class="dv">0</span>,<span class="ch">&#39;a&#39;</span>),(<span class="dv">0</span>,<span class="ch">&#39;b&#39;</span>),(<span class="dv">0</span>,<span class="ch">&#39;c&#39;</span>),(<span class="dv">1</span>,<span class="ch">&#39;a&#39;</span>),(<span class="dv">1</span>,<span class="ch">&#39;b&#39;</span>),(<span class="dv">1</span>,<span class="ch">&#39;c&#39;</span>)]</a></code></pre></div>
<p>Well, actually it‚Äôs the wrong way around. We want to loop through the <em>first</em> list the quickest, incrementing the second slower. No worries, we can just use a flipped version of <code>&lt;*&gt;</code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">infixl</span> <span class="dv">4</span> <span class="fu">&lt;&lt;&gt;</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="ot">(&lt;&lt;&gt;) ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">fs <span class="fu">&lt;&lt;&gt;</span> xs <span class="fu">=</span> flip (<span class="fu">$</span>) <span class="fu">&lt;$&gt;</span> xs <span class="fu">&lt;*&gt;</span> fs</a>
<a class="sourceLine" id="cb4-4" data-line-number="4"></a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="fu">&gt;&gt;&gt;</span> (,) <span class="fu">&lt;$&gt;</span> [<span class="dt">O</span>,<span class="dt">I</span>] <span class="fu">&lt;&lt;&gt;</span> <span class="st">&quot;abc&quot;</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">[(<span class="dv">0</span>,<span class="ch">&#39;a&#39;</span>),(<span class="dv">1</span>,<span class="ch">&#39;a&#39;</span>),(<span class="dv">0</span>,<span class="ch">&#39;b&#39;</span>),(<span class="dv">1</span>,<span class="ch">&#39;b&#39;</span>),(<span class="dv">0</span>,<span class="ch">&#39;c&#39;</span>),(<span class="dv">1</span>,<span class="ch">&#39;c&#39;</span>)]</a></code></pre></div>
<p>Brilliant! So we can write our function now, yes?</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1">bins <span class="fu">=</span> (<span class="fu">:</span>) <span class="fu">&lt;$&gt;</span> [<span class="dt">O</span>,<span class="dt">I</span>] <span class="fu">&lt;&lt;&gt;</span> bins</a></code></pre></div>
<p>Nope! That won‚Äôt ever produce an answer, unfortunately.</p>
<h1 id="productivity">Productivity</h1>
<p>The issue with our definition above is that it‚Äôs not lazy enough: it demands information that it hasn‚Äôt produced yet, so it gets caught in an infinite loop before it can do anything!</p>
<p>We need to kick-start it a little, so it can produce output <em>before</em> it asks itself for more. Because we know what the first line is going to be, we can just tell it that:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1">bins <span class="fu">=</span> (<span class="fu">:</span>) <span class="fu">&lt;$&gt;</span> [<span class="dt">O</span>,<span class="dt">I</span>] <span class="fu">&lt;&lt;&gt;</span> (repeat <span class="dt">O</span> <span class="fu">:</span> tail bins)</a>
<a class="sourceLine" id="cb6-2" data-line-number="2"></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="fu">&gt;&gt;&gt;</span> mapM_ print (take <span class="dv">8</span> (map (take <span class="dv">3</span>) bins))</a>
<a class="sourceLine" id="cb6-4" data-line-number="4"><span class="dv">000</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5"><span class="dv">100</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6"><span class="dv">010</span></a>
<a class="sourceLine" id="cb6-7" data-line-number="7"><span class="dv">110</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8"><span class="dv">001</span></a>
<a class="sourceLine" id="cb6-9" data-line-number="9"><span class="dv">101</span></a>
<a class="sourceLine" id="cb6-10" data-line-number="10"><span class="dv">011</span></a>
<a class="sourceLine" id="cb6-11" data-line-number="11"><span class="dv">111</span></a></code></pre></div>
<p>The property that this function has that the previous didn‚Äôt is <em>productivity</em>: the dual of termination. See, we want to avoid a <em>kind</em> of infinite loops in <code>bins</code>, but we don‚Äôt want to avoid infinite things altogether: the list it produces is meant to be infinite, for goodness‚Äô sake. Instead, what it needs to do is produce every new value in <em>finite</em> time.</p>
<h1 id="checking-productivity">Checking Productivity</h1>
<p>In total languages, like Agda, termination checking is a must. To express computation like that above, though, you often also want a <em>productivity</em> checker. Agda can do that, too.</p>
<p>Let‚Äôs get started then. First, a stream:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">5</span> <span class="ot">_</span>‚óÇ<span class="ot">_</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="kw">record</span> Stream <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  <span class="kw">coinductive</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">  <span class="kw">constructor</span> <span class="ot">_</span>‚óÇ<span class="ot">_</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5">  <span class="kw">field</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6">    head <span class="ot">:</span> A</a>
<a class="sourceLine" id="cb7-7" data-line-number="7">    tail <span class="ot">:</span> Stream A</a>
<a class="sourceLine" id="cb7-8" data-line-number="8"><span class="kw">open</span> Stream</a></code></pre></div>
<p>In Haskell, there was no need to define a separate stream type: the type of lists contains both finite and infinite lists.</p>
<p>Agda can get a little more specific: here, we‚Äôve used the <code>coinductive</code> keyword, which means we‚Äôre free to create infinite <code>Stream</code>s. Rather than the usual termination checking (which would kick in when we consume a recursive, inductive type), we now get productivity checking: when creating a <code>Stream</code>, the <code>tail</code> must always be available in finite time. For a finite type, we‚Äôd have used the <code>inductive</code> keyword instead; this wouldn‚Äôt be much use, though, since there‚Äôs no way to create a finite <code>Stream</code> without a nil constructor!<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a></p>
<p>One of the interesting things about working with infinite data (when you‚Äôre forced to notice that it‚Äôs infinite, as you are in Agda) is that <em>everything</em> gets flipped. So you have to prove productivity, not totality; you use product types, rather than sums; and to define functions, you use <em>co</em>patterns, rather than patterns.</p>
<h1 id="copatterns">Copatterns</h1>
<p>Copatterns are a handy syntactic construct for writing functions about record types. Let‚Äôs start with an example, and then I‚Äôll try explain a little:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb8-1" data-line-number="1">pure <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">‚Üí</span> A <span class="ot">‚Üí</span> Stream A</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">head <span class="ot">(</span>pure x<span class="ot">)</span> <span class="ot">=</span> x</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">tail <span class="ot">(</span>pure x<span class="ot">)</span> <span class="ot">=</span> pure x</a></code></pre></div>
<p>Here, we‚Äôre defining <code>pure</code> on streams: <code>pure x</code> produces an infinite stream of <code>x</code>. Its equivalent would be repeat in Haskell:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1">repeat<span class="ot"> ::</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">repeat x <span class="fu">=</span> x <span class="fu">:</span> repeat x</a></code></pre></div>
<p>Except instead of describing what it <em>is</em>, you describe how it <em>acts</em> (it‚Äôs kind of an intensional vs.¬†extensional thing). In other words, if you want to make a stream <code>xs</code>, you have to answer the questions ‚Äúwhat‚Äôs the head of <code>xs</code>?‚Äù and ‚Äúwhat‚Äôs the tail of <code>xs</code>?‚Äù</p>
<p>Contrast this with pattern-matching: we‚Äôre producing (rather than consuming) a value, and in pattern matching, you have to answer a question for each <em>case</em>. If you want to consume a list <code>xs</code>, you have to answer the questions ‚Äúwhat do you do when it‚Äôs nil?‚Äù and ‚Äúwhat do you do when it‚Äôs cons?‚Äù</p>
<p>Anyway, I think the symmetry is kind of cool. Let‚Äôs get back to writing our functions.</p>
<h1 id="sized-types">Sized Types</h1>
<p>Unfortunately, we don‚Äôt have enough to prove productivity yet. As an explanation why, let‚Äôs first try produce the famous <code>fibs</code> list. Written here in Haskell:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">fibs <span class="fu">=</span> <span class="dv">0</span> <span class="fu">:</span> <span class="dv">1</span> <span class="fu">:</span> zipWith (<span class="fu">+</span>) fibs (tail fibs)</a></code></pre></div>
<p>Instead of <code>zipWith</code>, let‚Äôs define <code>&lt;*&gt;</code>. That will let us use <a href="https://agda.readthedocs.io/en/v2.5.4.1/language/syntactic-sugar.html#idiom-brackets">idiom brackets</a>.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">_</span>&lt;*&gt;<span class="ot">_</span> <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>a b<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">{</span>B <span class="ot">:</span> <span class="dt">Set</span> b<span class="ot">}</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2">      <span class="ot">‚Üí</span> Stream <span class="ot">(</span>A <span class="ot">‚Üí</span> B<span class="ot">)</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">      <span class="ot">‚Üí</span> Stream A</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">      <span class="ot">‚Üí</span> Stream B</a>
<a class="sourceLine" id="cb11-5" data-line-number="5">head <span class="ot">(</span>fs &lt;*&gt; xs<span class="ot">)</span> <span class="ot">=</span> head fs <span class="ot">(</span>head xs<span class="ot">)</span></a>
<a class="sourceLine" id="cb11-6" data-line-number="6">tail <span class="ot">(</span>fs &lt;*&gt; xs<span class="ot">)</span> <span class="ot">=</span> tail fs &lt;*&gt; tail xs</a></code></pre></div>
<p>And here‚Äôs <code>fibs</code>:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb12-1" data-line-number="1">fibs <span class="ot">:</span> Stream ‚Ñï</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">head fibs <span class="ot">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">head <span class="ot">(</span>tail fibs<span class="ot">)</span> <span class="ot">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">tail <span class="ot">(</span>tail fibs<span class="ot">)</span> <span class="ot">=</span> ‚¶á fibs + tail fibs ‚¶à</a></code></pre></div>
<p>But it doesn‚Äôt pass the productivity checker! Because we use a higher-order function (<code>&lt;*&gt;</code>), Agda won‚Äôt look at how much it dips into the infinite supply of values. This is a problem: we need it to know that <code>&lt;*&gt;</code> only needs the heads of its arguments to produce a head, and so on. The solution? Encode this information in the types.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">5</span> <span class="ot">_</span>‚óÇ<span class="ot">_</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2"><span class="kw">record</span> Stream <span class="ot">{</span>i <span class="ot">:</span> Size<span class="ot">}</span> <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">  <span class="kw">coinductive</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4">  <span class="kw">constructor</span> <span class="ot">_</span>‚óÇ<span class="ot">_</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5">  <span class="kw">field</span></a>
<a class="sourceLine" id="cb13-6" data-line-number="6">    head <span class="ot">:</span> A</a>
<a class="sourceLine" id="cb13-7" data-line-number="7">    tail <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>j <span class="ot">:</span> Size&lt; i<span class="ot">}</span> <span class="ot">‚Üí</span> Stream <span class="ot">{</span>j<span class="ot">}</span> A</a>
<a class="sourceLine" id="cb13-8" data-line-number="8"><span class="kw">open</span> Stream</a></code></pre></div>
<p>Now, <code>Stream</code> has an implicit <em>size</em> parameter. Basically, <code>Stream {i} A</code> can produce <code>i</code> more values. So <code>cons</code>, then, gives a stream one extra value to produce:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb14-1" data-line-number="1">cons <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>i a<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">‚Üí</span> A <span class="ot">‚Üí</span> Stream <span class="ot">{</span>i<span class="ot">}</span> A <span class="ot">‚Üí</span> Stream <span class="ot">{</span>‚Üë i<span class="ot">}</span> A</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">head <span class="ot">(</span>cons x xs<span class="ot">)</span> <span class="ot">=</span> x</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">tail <span class="ot">(</span>cons x xs<span class="ot">)</span> <span class="ot">=</span> xs</a></code></pre></div>
<p>Conversely, we can write a different definition of <code>tail</code> that consumes one value<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb15-1" data-line-number="1">tail‚Ä≤ <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>i a<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">‚Üí</span> Stream <span class="ot">{</span>‚Üë i<span class="ot">}</span> A <span class="ot">‚Üí</span> Stream <span class="ot">{</span>i<span class="ot">}</span> A</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">tail‚Ä≤ <span class="ot">{</span>i<span class="ot">}</span> xs <span class="ot">=</span> tail xs <span class="ot">{</span>i<span class="ot">}</span></a></code></pre></div>
<p>For <code>&lt;*&gt;</code>, we want to show that its result can produce just as much values as its inputs can:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="ot">_</span>&lt;*&gt;<span class="ot">_</span> <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>i a b<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">{</span>B <span class="ot">:</span> <span class="dt">Set</span> b<span class="ot">}</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2">      <span class="ot">‚Üí</span> Stream <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">(</span>A <span class="ot">‚Üí</span> B<span class="ot">)</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3">      <span class="ot">‚Üí</span> Stream <span class="ot">{</span>i<span class="ot">}</span> A</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">      <span class="ot">‚Üí</span> Stream <span class="ot">{</span>i<span class="ot">}</span> B</a>
<a class="sourceLine" id="cb16-5" data-line-number="5">head <span class="ot">(</span>fs &lt;*&gt; xs<span class="ot">)</span> <span class="ot">=</span> head fs <span class="ot">(</span>head xs<span class="ot">)</span></a>
<a class="sourceLine" id="cb16-6" data-line-number="6">tail <span class="ot">(</span>fs &lt;*&gt; xs<span class="ot">)</span> <span class="ot">=</span> tail fs &lt;*&gt; tail xs</a></code></pre></div>
<p>How does this help the termination/productivity checker? Well, for terminating functions, we have to keep giving the <code>tail</code> field smaller and smaller sizes, meaning that we‚Äôll eventually hit zero (and terminate). For productivity, we now have a way to talk about ‚Äúdefinedness‚Äù in types, so we can make sure that a recursive call doesn‚Äôt dip into a supply it hasn‚Äôt produced yet.</p>
<p>One more thing: <code>Size</code> types have strange typing rules, mainly for ergonomic purposes (this is why we‚Äôre not just using an <code>‚Ñï</code> parameter). One of them is that if you don‚Äôt specify the size, it‚Äôs defaulted to <code>‚àû</code>, so functions written without size annotations don‚Äôt have to be changed with this new definition:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb17-1" data-line-number="1">pure <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">‚Üí</span> A <span class="ot">‚Üí</span> Stream A</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">head <span class="ot">(</span>pure x<span class="ot">)</span> <span class="ot">=</span> x</a>
<a class="sourceLine" id="cb17-3" data-line-number="3">tail <span class="ot">(</span>pure x<span class="ot">)</span> <span class="ot">=</span> pure x</a></code></pre></div>
<p>Finally <code>fibs</code>:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb18-1" data-line-number="1">fibs <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">‚Üí</span> Stream <span class="ot">{</span>i<span class="ot">}</span> ‚Ñï</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">head fibs <span class="ot">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3">head <span class="ot">(</span>tail fibs<span class="ot">)</span> <span class="ot">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb18-4" data-line-number="4">tail <span class="ot">(</span>tail fibs<span class="ot">)</span> <span class="ot">=</span> ‚¶á fibs + tail fibs ‚¶à</a></code></pre></div>
<h1 id="bugs">Bugs!</h1>
<p>Before I show the Agda solution, I‚Äôd like to point out some bugs that were revealed in the Haskell version by trying to implement it totally. First of all, the function signature. ‚ÄúTakes an alphabet and produces unique strings‚Äù seems like this:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="ot">strings ::</span> [a] <span class="ot">-&gt;</span> [[a]]</a></code></pre></div>
<p>But what should you produce in this case:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1">strings []</a></code></pre></div>
<p>So it must be a non-empty list, giving us the following type and definition:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="ot">strings ::</span> <span class="dt">NonEmpty</span> a <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">strings (x <span class="fu">:|</span> xs) <span class="fu">=</span> (<span class="fu">:</span>) <span class="fu">&lt;$&gt;</span> (x<span class="fu">:</span>xs) <span class="fu">&lt;&lt;&gt;</span> (repeat x <span class="fu">:</span> tail (strings (x <span class="fu">:|</span> xs)))</a></code></pre></div>
<p>But this has a bug too! What happens if we pass in the following:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1">strings (x <span class="fu">:|</span> [])</a></code></pre></div>
<p>So this fails the specification: there is only one unique infinite string from that alphabet (<code>pure x</code>). Interestingly, though, our implementation above also won‚Äôt produce any output beyond the first element. I suppose, in a way, these things cancel each other out: our function does indeed produce all of the unique strings, it‚Äôs just a pity that it goes into an infinite loop to do so!</p>
<h1 id="bringing-it-all-together">Bringing it all Together</h1>
<p>Finally, we have our function:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb23-1" data-line-number="1">strings <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>i a<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">‚Üí</span> A √ó A √ó List A <span class="ot">‚Üí</span> Stream <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">(</span>Stream A<span class="ot">)</span></a>
<a class="sourceLine" id="cb23-2" data-line-number="2">head <span class="ot">(</span>strings <span class="ot">(</span>x , <span class="ot">_</span> , <span class="ot">_))</span> <span class="ot">=</span> pure x</a>
<a class="sourceLine" id="cb23-3" data-line-number="3">tail <span class="ot">(</span>strings <span class="ot">{</span>A <span class="ot">=</span> A<span class="ot">}</span> xs<span class="ot">@(</span>x‚ÇÅ , x‚ÇÇ , xt<span class="ot">))</span> <span class="ot">=</span> go x‚ÇÇ xt <span class="ot">(</span>strings xs<span class="ot">)</span></a>
<a class="sourceLine" id="cb23-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-5" data-line-number="5">  go <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">‚Üí</span> A <span class="ot">‚Üí</span> List A <span class="ot">‚Üí</span> Stream <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">(</span>Stream A<span class="ot">)</span> <span class="ot">‚Üí</span> Stream <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">(</span>Stream A<span class="ot">)</span></a>
<a class="sourceLine" id="cb23-6" data-line-number="6">  head <span class="ot">(</span>head <span class="ot">(</span>go y ys zs<span class="ot">))</span> <span class="ot">=</span> y</a>
<a class="sourceLine" id="cb23-7" data-line-number="7">  tail <span class="ot">(</span>head <span class="ot">(</span>go y ys zs<span class="ot">))</span> <span class="ot">=</span> head zs</a>
<a class="sourceLine" id="cb23-8" data-line-number="8">  tail <span class="ot">(</span>go <span class="ot">_</span> [] zs<span class="ot">)</span> <span class="ot">=</span> go x‚ÇÅ <span class="ot">(</span>x‚ÇÇ ‚à∑ xt<span class="ot">)</span> <span class="ot">(</span>tail zs<span class="ot">)</span></a>
<a class="sourceLine" id="cb23-9" data-line-number="9">  tail <span class="ot">(</span>go <span class="ot">_</span> <span class="ot">(</span>y ‚à∑ ys<span class="ot">)</span> zs<span class="ot">)</span> <span class="ot">=</span> go y ys zs</a></code></pre></div>
<p>As you can see, we do need to kick-start it without a recursive call (the first line is <code>pure x</code>). Then, <code>go</code> takes as a third argument the ‚Äútails‚Äù argument, and does the kind of backwards Cartesian product we want. However, since we‚Äôre into the second element of the stream now, we want to avoid repeating what we already said, which is why we have to give <code>go</code> <code>x‚ÇÇ</code>, rather than <code>x‚ÇÅ</code>. This is what forces us to take at least two elements, rather than at least one, also: we can‚Äôt just take the tail of the call to <code>go</code> (this is what we did in the Haskell version of <code>strings</code> with the <code>NonEmpty</code> list), as the recursive call to strings then doesn‚Äôt decrease in size:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb24-1" data-line-number="1">strings <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>i a<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">‚Üí</span> A √ó List A <span class="ot">‚Üí</span> Stream <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">(</span>Stream A<span class="ot">)</span></a>
<a class="sourceLine" id="cb24-2" data-line-number="2">head <span class="ot">(</span>strings <span class="ot">(</span>x , <span class="ot">_))</span> <span class="ot">=</span> pure x</a>
<a class="sourceLine" id="cb24-3" data-line-number="3">tail <span class="ot">(</span>strings <span class="ot">{</span>A <span class="ot">=</span> A<span class="ot">}</span> xs<span class="ot">@(</span>x , xt<span class="ot">))</span> <span class="ot">=</span> tail <span class="ot">(</span>go x xt <span class="ot">(</span>strings xs<span class="ot">))</span></a>
<a class="sourceLine" id="cb24-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-5" data-line-number="5">  go <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">‚Üí</span> A <span class="ot">‚Üí</span> List A <span class="ot">‚Üí</span> Stream <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">(</span>Stream A<span class="ot">)</span> <span class="ot">‚Üí</span> Stream <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">(</span>Stream A<span class="ot">)</span></a>
<a class="sourceLine" id="cb24-6" data-line-number="6">  head <span class="ot">(</span>head <span class="ot">(</span>go y ys zs<span class="ot">))</span> <span class="ot">=</span> y</a>
<a class="sourceLine" id="cb24-7" data-line-number="7">  tail <span class="ot">(</span>head <span class="ot">(</span>go y ys zs<span class="ot">))</span> <span class="ot">=</span> head zs</a>
<a class="sourceLine" id="cb24-8" data-line-number="8">  tail <span class="ot">(</span>go <span class="ot">_</span> [] zs<span class="ot">)</span> <span class="ot">=</span> go x xt <span class="ot">(</span>tail zs<span class="ot">)</span></a>
<a class="sourceLine" id="cb24-9" data-line-number="9">  tail <span class="ot">(</span>go <span class="ot">_</span> <span class="ot">(</span>y ‚à∑ ys<span class="ot">)</span> zs<span class="ot">)</span> <span class="ot">=</span> go y ys zs</a></code></pre></div>
<p>Agda will warn about termination on this function. Now, if you slap a pragma on it, it <em>will</em> produce the correct results for enough arguments, but give it one and you‚Äôll get an infinite loop, just as you were warned!</p>
<h1 id="further-work">Further Work</h1>
<p>I‚Äôm having a lot of fun with copatterns for various algorithms (especially combinatorics). I‚Äôm planning on working on two particular tasks with them for the next posts in this series:</p>
<dl>
<dt>Proving <code>strings</code></dt>
<dd><p>I‚Äôd like to prove that <code>strings</code> does indeed produce a stream of unique values. Following from that, it would be cool to do a Cantor diagonalisation on its output.</p>
</dd>
<dt>Permutations</dt>
<dd><p>Haskell‚Äôs <a href="http://hackage.haskell.org/package/base-4.12.0.0/docs/src/Data.OldList.html#permutations">permutations implementation in Data.List</a> does some interesting tricks to make it as lazy as possible. It would be great to write an implementation that is verified to be as lazy as possible: the pattern of ‚Äúdefinedness‚Äù is complex, though, so I don‚Äôt know if it‚Äôs possible with Agda‚Äôs current sized types.</p>
</dd>
</dl>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Thanks to <a href="http://gelisam.blogspot.com/">gelisam</a> for pointing out the poor phrasing here. Updated on 2018/10/16<a href="#fnref1" class="footnote-back">‚Ü©</a></p></li>
<li id="fn2"><p>You might wonder why the definition of <code>tail</code> doesn‚Äôt have this signature to begin with. The reason is that our record type must be <em>parameterized</em> (not indexed) over its size (as it‚Äôs a record type), so we use a less-than proof instead.<a href="#fnref2" class="footnote-back">‚Ü©</a></p></li>
</ol>
</section>
]]></description>
    <pubDate>Tue, 16 Oct 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-10-16-total-combinations.html</guid>
    <dc:creator>Donnacha Ois√≠n Kidney</dc:creator>
</item>
<item>
    <title>Agda Beginner(-ish) Tips, Tricks, and Pitfalls</title>
    <link>https://doisinkidney.com/posts/2018-09-20-agda-tips.html</link>
    <description><![CDATA[<div class="info">
    Posted on September 20, 2018
</div>
<div class="info">
    
        Part 1 of a <a href="/series/Agda%20Tips.html">2-part series on Agda Tips</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Agda.html">Agda</a>
    
</div>

<p>I‚Äôm in the middle of quite a large Agda project at the moment, and I‚Äôve picked up a few tips and tricks in the past few weeks. I‚Äôd imagine a lot of these are quite obvious once you get to grips with Agda, so I‚Äôm writing them down before I forget that they were once confusing stumbling blocks. Hopefully this helps other people trying to learn the language!</p>
<h1 id="parameterized-modules-strangeness">Parameterized Modules Strangeness</h1>
<p>Agda lets you parameterize modules, just as you can datatypes, with types, values, etc. It‚Äôs extremely handy for those situations where you want to be generic over some type, but that type won‚Äôt change inside the generic code. The keys to dictionaries is a good example: you can start the module with:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">module</span> Map <span class="ot">(</span>Key <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">(</span>Ordering <span class="ot">:</span> Ord Key<span class="ot">)</span> <span class="kw">where</span></a></code></pre></div>
<p>And now, where in Haskell you‚Äôd have to write something like <code>Ord a =&gt; Map a</code>‚Ä¶ in pretty much any function signature, you can just refer to <code>Key</code>, and you‚Äôre good to go. It‚Äôs kind of like a dynamic type synonym, in that way.</p>
<p>Here‚Äôs the strangeness, though: what if you don‚Äôt supply one of the arguments?</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">import</span> Map</a></code></pre></div>
<p>This won‚Äôt give you a type error, strange as it may seem. This will perform <em>lambda lifting</em>, meaning that now, every function exported by the module will have the type signature:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">(</span>Key <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">(</span>Ordering <span class="ot">:</span> Ord Key<span class="ot">)</span> <span class="ot">...</span></a></code></pre></div>
<p>Preceding its normal signature. In other words, it changes it into what you would have had to write in Haskell.</p>
<p>This is a powerful feature, but it can also give you some confusing errors if you don‚Äôt know about it (especially if the module has implicit arguments).</p>
<h1 id="auto">Auto</h1>
<p>If you‚Äôve got a hole in your program, you can put the cursor in it and press <code>SPC-m-a</code> (in spacemacs), and Agda will try and find the automatic solution to the problem. For a while, I didn‚Äôt think much of this feature, as rare was the program which Agda could figure out. Turns out I was just using it wrong! Into the hole you should type the options for the proof search: enabling case-splitting (<code>-c</code>), enabling the use of available definitions (<code>-r</code>), and listing possible solutions (<code>-l</code>).</p>
<h1 id="well-founded-recursion">Well-Founded Recursion</h1>
<p>Often, a program will not be obviously terminating (according to Agda‚Äôs termination checker). The first piece of advice is this: <em>don‚Äôt</em> use well-founded recursion. It‚Äôs a huge hammer, and often you can get away with fiddling with the function (try inlining definitions, rewriting generic functions to monomorphic versions, or replacing with-blocks with helper functions), or using one of the <a href="https://gallais.github.io/blog/termination-tricks.html">more lightweight techniques</a> out there.</p>
<p>However, sometimes it really is the best option, so you have to grit your teeth and use it. What I expected (and what I used originally) was a recursion combinator, with a type something like:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb4-1" data-line-number="1">wf-rec <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>a b<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">{</span>B <span class="ot">:</span> <span class="dt">Set</span> b<span class="ot">}</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">       <span class="ot">‚Üí</span> <span class="ot">((</span>x <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">‚Üí</span> <span class="ot">((</span>y <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">‚Üí</span> y &lt; x <span class="ot">‚Üí</span> B<span class="ot">)</span> <span class="ot">‚Üí</span> B<span class="ot">)</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">       <span class="ot">‚Üí</span> A <span class="ot">‚Üí</span> B</a></code></pre></div>
<p>So we‚Äôre trying to generate a function of type <code>A ‚Üí B</code>, but there‚Äôs a hairy recursive call in there somewhere. Instead we use this function, and pass it a version of our function that uses the supplied function rather than making a recursive call:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb5-1" data-line-number="1">terminating <span class="ot">:</span> A <span class="ot">‚Üí</span> B</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">terminating <span class="ot">=</span> wf-rec <span class="ot">(Œª</span> x recursive-call <span class="ot">‚Üí</span> <span class="ot">...)</span></a></code></pre></div>
<p>In other words, instead of calling the function itself, you call <code>recursive-call</code> above. Along with the argument, you supply a proof that it‚Äôs smaller than the outer argument (<code>y &lt; x</code>; assume for now that the definition of <code>&lt;</code> is just some relation like <a href="https://github.com/agda/agda-stdlib/blob/442cd8a06b63f7e3550af55fb75c9d345c6ddb8f/src/Data/Nat/Base.agda#L31"><code>_&lt;_</code> in Data.Nat</a>).</p>
<p>But wait! You don‚Äôt have to use it! Instead of all that, you can just pass the <code>Acc _&lt;_ x</code> type as a parameter to your function. In other words, if you have a dangerous function:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb6-1" data-line-number="1">f <span class="ot">:</span> A <span class="ot">‚Üí</span> B</a></code></pre></div>
<p>Instead write:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb7-1" data-line-number="1">f-step <span class="ot">:</span> <span class="ot">(</span>x <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">‚Üí</span> Acc <span class="ot">_</span>&lt;<span class="ot">_</span> x <span class="ot">‚Üí</span> B</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">f-step <span class="ot">=</span> <span class="ot">...</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">f <span class="ot">:</span> A <span class="ot">‚Üí</span> B</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">f x <span class="ot">=</span> f-step x <span class="ot">...</span></a></code></pre></div>
<p>Once you pattern match on the accessibility relation, the termination checker is satisfied. This is much easier to understand (for me anyway), and made it <em>much</em> easier to write proofs about it.</p>
<p>Thanks to <a href="http://oleg.fi">Oleg Grenrus (phadej)</a> on irc for helping me out with this! Funnily enough, he actually recommended the <code>Acc</code> approach, and I instead originally went with the recursion combinator. Would have saved a couple hours if I‚Äôd just listened! Also worth mentioning is the approach recommended by <a href="https://gallais.github.io">Guillaume Allais (gallais)</a>, detailed <a href="https://gallais.github.io/agdarsec/Induction.Nat.Strong.html">here</a>. Haven‚Äôt had time to figure it out, so this article may be updated to recommend it instead in the future.</p>
<h1 id="dont-touch-the-green-slime">Don‚Äôt Touch The Green Slime!</h1>
<p>This one is really important. If I hadn‚Äôt read the exact explanation <a href="https://twitter.com/pigworker/status/1013535783234473984">here</a> I think I may have given up with Agda (or at the very least the project I‚Äôm working on) out of frustration.</p>
<p>Basically the problem arises like this. Say you‚Äôre writing a function to split a vector in two. You can specify the type pretty precisely:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb8-1" data-line-number="1">split <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>a n m<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">‚Üí</span> Vec A <span class="ot">(</span>n + m<span class="ot">)</span> <span class="ot">‚Üí</span> Vec A n √ó Vec A m</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">split xs <span class="ot">=</span> <span class="ot">{!!}</span></a></code></pre></div>
<p>Try to pattern-match on <code>xs</code>, though, and you‚Äôll get the following error:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb9-1" data-line-number="1">I&#39;m not sure if there should be a case for the <span class="kw">constructor</span> [],</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">because I get stuck when trying <span class="kw">to</span> solve the following unification</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">problems <span class="ot">(</span>inferred index ‚âü expected index<span class="ot">):</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4">  zero ‚âü n + m</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">when checking that the expression ? has type Vec <span class="ot">.</span>A <span class="ot">.</span>n √ó Vec <span class="ot">.</span>A <span class="ot">.</span>m</a></code></pre></div>
<p>What?! That‚Äôs weird. Anyway, you fiddle around with the function, end up pattern matching on the <code>n</code> instead, and continue on with your life.</p>
<p>What about this, though: you want to write a type for proofs that one number is less than or equal to another. You go with something like this:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">infix</span> <span class="dv">4</span> <span class="ot">_</span>‚â§<span class="ot">_</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="kw">data</span> <span class="ot">_</span>‚â§<span class="ot">_</span> <span class="ot">(</span>n <span class="ot">:</span> ‚Ñï<span class="ot">)</span> <span class="ot">:</span> ‚Ñï <span class="ot">‚Üí</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  proof <span class="ot">:</span> <span class="ot">‚àÄ</span> k <span class="ot">‚Üí</span> n ‚â§ n + k</a></code></pre></div>
<p>And you want to use it in a proof. Here‚Äôs the example we‚Äôll be using: if two numbers are less than some limit <code>u</code>, then their maximum is also less than that limit:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb11-1" data-line-number="1">max <span class="ot">:</span> ‚Ñï <span class="ot">‚Üí</span> ‚Ñï <span class="ot">‚Üí</span> ‚Ñï</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">max zero m <span class="ot">=</span> m</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">max <span class="ot">(</span>suc n<span class="ot">)</span> zero <span class="ot">=</span> suc n</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">max <span class="ot">(</span>suc n<span class="ot">)</span> <span class="ot">(</span>suc m<span class="ot">)</span> <span class="ot">=</span> suc <span class="ot">(</span>max n m<span class="ot">)</span></a>
<a class="sourceLine" id="cb11-5" data-line-number="5"></a>
<a class="sourceLine" id="cb11-6" data-line-number="6">max-‚â§ <span class="ot">:</span> <span class="ot">‚àÄ</span> n m <span class="ot">{</span>u<span class="ot">}</span> <span class="ot">‚Üí</span> n ‚â§ u <span class="ot">‚Üí</span> m ‚â§ u <span class="ot">‚Üí</span> max n m ‚â§ u</a>
<a class="sourceLine" id="cb11-7" data-line-number="7">max-‚â§ n m <span class="ot">(</span>proof k<span class="ot">)</span> m‚â§u <span class="ot">=</span> <span class="ot">{!!}</span></a></code></pre></div>
<p>It won‚Äôt let you match on <code>m‚â§u</code>! Here‚Äôs the error:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb12-1" data-line-number="1">I&#39;m not sure if there should be a case for the <span class="kw">constructor</span> proof,</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">because I get stuck when trying <span class="kw">to</span> solve the following unification</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">problems <span class="ot">(</span>inferred index ‚âü expected index<span class="ot">):</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">  m‚ÇÅ + k‚ÇÇ ‚âü n‚ÇÅ + k‚ÇÅ</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">when checking that the expression ? has type max n m ‚â§ n + k</a></code></pre></div>
<p>What do you <em>mean</em> you‚Äôre not sure if there‚Äôs a case for the constructor <code>proof</code>: it‚Äôs the <em>only</em> case!</p>
<p>The problem is that Agda is trying to <em>unify</em> two types who both have calls to user-defined functions in them, which is a hard problem. As phrased by Conor McBride:</p>
<blockquote>
<p>When combining prescriptive and descriptive indices, ensure both are in constructor form. Exclude defined functions which yield difficult unification problems.</p>
</blockquote>
<p>So if you ever get the ‚ÄúI‚Äôm not sure if‚Ä¶‚Äù error, try either to:</p>
<ol>
<li>Redefine the indices so they use constructors, not functions.</li>
<li>Remove the index, instead having a proof inside the type of equality. What does that mean? Basically, transform the definition of <code>‚â§</code> above into <a href="https://github.com/agda/agda-stdlib/blob/442cd8a06b63f7e3550af55fb75c9d345c6ddb8f/src/Data/Nat/Base.agda#L72-L76">the one in Data.Nat</a>.</li>
</ol>
<h1 id="inspect">Inspect</h1>
<p>The use-case I had for this is a little long, I‚Äôm afraid (too long to include here), but it <em>did</em> come in handy. Basically, if you‚Äôre trying to prove something about a function, you may well want to <em>run</em> that function and pattern match on the result.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb13-1" data-line-number="1">f-is-the-same-as-g <span class="ot">:</span> <span class="ot">‚àÄ</span> x <span class="ot">‚Üí</span> f x ‚â° g x</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">f-is-the-same-as-g x <span class="kw">with</span> f x</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">f-is-the-same-as-g x <span class="ot">|</span> y <span class="ot">=</span> <span class="ot">{!!}</span></a></code></pre></div>
<p>This is a little different from the normal way of doing things, where you‚Äôd pattern match on the argument. It is a pattern you‚Äôll sometimes need to write, though. And here‚Äôs the issue: that <code>y</code> has nothing to do with <code>f x</code>, as far as Agda is concerned. All you‚Äôve done is introduced a new variable, and that‚Äôs that.</p>
<p>This is exactly the problem <a href="https://github.com/agda/agda-stdlib/blob/442cd8a06b63f7e3550af55fb75c9d345c6ddb8f/src/Relation/Binary/PropositionalEquality.agda#L111-L113"><code>inspect</code></a> solves: it runs your function, giving you a result, but <em>also</em> giving you a proof that the result is equal to running the function. You use it like this:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb14-1" data-line-number="1">f-is-the-same-as-g <span class="ot">:</span> <span class="ot">‚àÄ</span> x <span class="ot">‚Üí</span> f x ‚â° g x</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">f-is-the-same-as-g x <span class="kw">with</span> f x <span class="ot">|</span> inspect f x</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">f-is-the-same-as-g x <span class="ot">|</span> y <span class="ot">|</span> [ fx‚â°y ] <span class="ot">=</span> <span class="ot">{!!}</span></a></code></pre></div>
<h1 id="spc-g-g">SPC-G-G</h1>
<p>Because the Agda standard library is a big fan of type synonyms (<code>Op‚ÇÇ A</code> instead of <code>A ‚Üí A ‚Üí A</code> for example), it‚Äôs handy to know that pressing <code>SPC-G-G</code> (in spacemacs) over any identifier will bring you to the definition. Also, you can normalize a type with <code>SPC-m-n</code>.</p>
<h1 id="irrelevance">Irrelevance</h1>
<p>This one is a little confusing, because Agda‚Äôs notion of ‚Äúirrelevance‚Äù is different from Idris‚Äô, or Haskell‚Äôs. In all three languages, irrelevance is used for performance: it means that a value doesn‚Äôt need to be around at runtime, so the compiler can elide it.</p>
<p>That‚Äôs where the similarities stop though. In Haskell, <em>all</em> types are irrelevant: they‚Äôre figments of the typechecker‚Äôs imagination. You can‚Äôt get a type at runtime full stop.</p>
<p>In dependently typed languages, this isn‚Äôt a distinction we can rely on. The line between runtime entities and compile-time entities is drawn elsewhere, so quite often types <em>need</em> to exist at runtime. As you might guess, though, they don‚Äôt always need to. The length of a length-indexed vector, for instance, is completely determined by the structure of the vector: why would you bother storing all of that information at runtime? This is what Idris recognizes, and what it tries to remedy: it analyses code for these kinds of opportunities for elision, and does so when it can. Kind of like Haskell‚Äôs fusion, though, it‚Äôs an invisible optimization, and there‚Äôs no way to make Idris throw a type error when it can‚Äôt elide something you want it to elide.</p>
<p>Agda is totally different. Something is irrelevant in Agda if it‚Äôs <em>unique</em>. Or, rather, it‚Äôs irrelevant if all you rely on is its existence. It‚Äôs used for proofs that you carry around with you: in a rational number type, you might use it to say that the numerator and denominator have no common factors. The only information you want from this proof is whether it holds or not, so it‚Äôs the perfect candidate for irrelevance.</p>
<p>Weirdly, this means it‚Äôs useless for the length-indexed vector kind of stuff mentioned above. In fact, it doe exactly the opposite of what you might expect: if the length parameter is marked as irrelevant, the the types <code>Vec A n</code> and <code>Vec A (suc n)</code> are the same!</p>
<p>The way you <em>can</em> use it is to pattern-match if it‚Äôs impossible. Again, it‚Äôs designed for eliding proofs that you may carry with you otherwise.</p>
<h1 id="future-tips">Future Tips</h1>
<p>Once I‚Äôm finished the project, I‚Äôll try write up a guide on how to do literate Agda files. There were a couple of weird nuances that I had to pick up on the way, mainly to do with getting unicode to work.</p>
]]></description>
    <pubDate>Thu, 20 Sep 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-09-20-agda-tips.html</guid>
    <dc:creator>Donnacha Ois√≠n Kidney</dc:creator>
</item>
<item>
    <title>Verified AVL Trees in Haskell and Agda</title>
    <link>https://doisinkidney.com/posts/2018-07-30-verified-avl.html</link>
    <description><![CDATA[<div class="info">
    Posted on July 30, 2018
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Agda.html">Agda</a>
    
</div>

<p>I‚Äôve been writing a lot of Agda recently, and had the occasion to write a <a href="https://en.wikipedia.org/wiki/Fenwick_tree">Fenwick tree</a> that did some rebalancing. I went with <a href="https://en.wikipedia.org/wiki/AVL_tree">AVL</a>-style rebalancing (rather than <a href="https://en.wikipedia.org/wiki/Red‚Äìblack_tree">red-black</a> or <a href="https://en.wikipedia.org/wiki/Weight-balanced_tree">trees of bounded balance</a>). I‚Äôd written pretty full implementations of the other two before, and the Agda standard library <span class="citation" data-cites="danielsson_agda_2018">(Danielsson <a href="#ref-danielsson_agda_2018">2018</a>)</span> has an implementation already that I was able to use as a starting point. Also, apparently, AVL trees seem to perform better than red-black trees in practice <span class="citation" data-cites="pfaff_performance_2004">(Pfaff <a href="#ref-pfaff_performance_2004">2004</a>)</span>.</p>
<p>This post will be similar in style to Stephanie Weirich‚Äôs talk <span class="citation" data-cites="weirich_depending_2014">(<a href="#ref-weirich_depending_2014">2014</a>)</span>, which compares an Agda implementation of verified red-black trees to a Haskell one. When there‚Äôs two columns of code side-by-side, the left-hand side is Haskell, the right Agda.</p>
<p>The method of constructing the ordering proof is taken from ‚ÄúHow to Keep Your Neighbours in Order‚Äù <span class="citation" data-cites="mcbride_how_2014">(<a href="#ref-mcbride_how_2014">2014</a>)</span> by Conor McBride; the structural proofs are somewhat inspired by the implementation in the Agda standard library, but are mainly my own.</p>
<h1 id="height">Height</h1>
<p>AVL trees are more strictly balanced than red-black trees: the height of neighboring subtrees can differ by at most one. To store the height, we will start as every dependently-typed program does: with Peano numbers.</p>
<style>
.column {
    float: left;
    width: 50%;
}
.row:after {
    content: "";
    display: table;
    clear: both;
}
</style>
<div class="row">
<div class="column">
<p>Haskell</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> <span class="dt">N</span> <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">|</span> <span class="dt">S</span> <span class="dt">N</span></a></code></pre></div>
</div>
<div class="column">
<p>Agda</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> ‚Ñï <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  zero <span class="ot">:</span> ‚Ñï</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  suc  <span class="ot">:</span> ‚Ñï <span class="ot">‚Üí</span> ‚Ñï</a></code></pre></div>
</div>
</div>
<p>The trees will be balanced one of three possible ways: left-heavy, right-heavy, or even. We can represent these three cases in a GADT in the case of Haskell, or an indexed datatype in the case of Agda:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Balance</span><span class="ot"> ::</span> <span class="dt">N</span> <span class="ot">-&gt;</span> <span class="dt">N</span> <span class="ot">-&gt;</span> <span class="dt">N</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">      <span class="dt">L</span><span class="ot"> ::</span> <span class="dt">Balance</span> (<span class="dt">S</span> n) n    (<span class="dt">S</span> n)</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">      <span class="dt">O</span><span class="ot"> ::</span> <span class="dt">Balance</span>  n    n     n</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">      <span class="dt">R</span><span class="ot"> ::</span> <span class="dt">Balance</span>  n   (<span class="dt">S</span> n) (<span class="dt">S</span> n)</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb4"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">data</span> ‚ü®<span class="ot">_</span>‚äî<span class="ot">_</span>‚ü©‚â°<span class="ot">_</span> <span class="ot">:</span> ‚Ñï <span class="ot">‚Üí</span> ‚Ñï <span class="ot">‚Üí</span> ‚Ñï <span class="ot">‚Üí</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  ‚óø  <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">‚Üí</span> ‚ü® suc  n ‚äî      n ‚ü©‚â° suc  n</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  ‚ñΩ  <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">‚Üí</span> ‚ü®      n ‚äî      n ‚ü©‚â°      n</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">  ‚ó∫  <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">‚Üí</span> ‚ü®      n ‚äî suc  n ‚ü©‚â° suc  n</a></code></pre></div>
</div>
</div>
<p>Those unfamiliar with Agda might be a little intimidated by the mixfix operator in the balance definition: we‚Äôre using it here because the type can be seen of a proof that:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">max(x,y) = z</annotation></semantics></math></p>
<p>Or, using the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>‚äî</mo><annotation encoding="application/x-tex">\sqcup</annotation></semantics></math> operator:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>‚äî</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">(x \sqcup y) = z</annotation></semantics></math></p>
<p>We‚Äôll use this proof in the tree itself, as we‚Äôll need to know the maximum of the height of a node‚Äôs two subtrees to find the height of the node. Before we do that, we‚Äôll need a couple helper functions for manipulating the balance:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">balr ::</span> <span class="dt">Balance</span> x y z <span class="ot">-&gt;</span> <span class="dt">Balance</span> z x z</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">balr <span class="dt">L</span> <span class="fu">=</span> <span class="dt">O</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">balr <span class="dt">O</span> <span class="fu">=</span> <span class="dt">O</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">balr <span class="dt">R</span> <span class="fu">=</span> <span class="dt">L</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5"></a>
<a class="sourceLine" id="cb5-6" data-line-number="6"><span class="ot">ball ::</span> <span class="dt">Balance</span> x y z <span class="ot">-&gt;</span> <span class="dt">Balance</span> y z z</a>
<a class="sourceLine" id="cb5-7" data-line-number="7">ball <span class="dt">L</span> <span class="fu">=</span> <span class="dt">R</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8">ball <span class="dt">O</span> <span class="fu">=</span> <span class="dt">O</span></a>
<a class="sourceLine" id="cb5-9" data-line-number="9">ball <span class="dt">R</span> <span class="fu">=</span> <span class="dt">O</span></a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb6"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb6-1" data-line-number="1">‚Éï <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>x y z<span class="ot">}</span> <span class="ot">‚Üí</span> ‚ü® x ‚äî y ‚ü©‚â° z <span class="ot">‚Üí</span> ‚ü® z ‚äî x ‚ü©‚â° z</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">‚Éï  ‚óø  <span class="ot">=</span> ‚ñΩ</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">‚Éï  ‚ñΩ  <span class="ot">=</span> ‚ñΩ</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">‚Éï  ‚ó∫  <span class="ot">=</span> ‚óø</a>
<a class="sourceLine" id="cb6-5" data-line-number="5"></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">‚Éî <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>x y z<span class="ot">}</span> <span class="ot">‚Üí</span> ‚ü® x ‚äî y ‚ü©‚â° z <span class="ot">‚Üí</span> ‚ü® y ‚äî z ‚ü©‚â° z</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">‚Éî  ‚óø  <span class="ot">=</span> ‚ó∫</a>
<a class="sourceLine" id="cb6-8" data-line-number="8">‚Éî  ‚ñΩ  <span class="ot">=</span> ‚ñΩ</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">‚Éî  ‚ó∫  <span class="ot">=</span> ‚ñΩ</a></code></pre></div>
</div>
</div>
<h1 id="ordering">Ordering</h1>
<p>Along with the verification of the structure of the tree, we will also want to verify that its contents are ordered correctly. Unfortunately, this property is a little out of reach for Haskell, but it‚Äôs 100% doable in Agda. First, we‚Äôll need a way to describe orders on a data type. In Haskell, we might write:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Ord</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="ot">  (==) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="ot">  (&lt;)  ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a></code></pre></div>
</div>
<div class="column">
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>*</mo><mo>*</mo><mo>*</mo></mrow><annotation encoding="application/x-tex">***</annotation></semantics></math>
</div>
</div>
<p>That <code class="sourceCode haskell"><span class="dt">Bool</span></code> throws away any information gained in the comparison, though: we want to supply a proof with the result of the comparison. First, equality:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">infix <span class="dv">4</span> <span class="fu">==</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="kw">data</span><span class="ot"> (==) ::</span> <span class="dt">Type</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">          <span class="ot">-&gt;</span> <span class="dt">Type</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">          <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5">  <span class="dt">Refl</span><span class="ot"> ::</span> x <span class="fu">==</span> x</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb9"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">infix</span> <span class="dv">4</span> <span class="ot">_</span>‚â°<span class="ot">_</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="kw">data</span> <span class="ot">_</span>‚â°<span class="ot">_</span> <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">         <span class="ot">(</span>x <span class="ot">:</span> A<span class="ot">)</span> </a>
<a class="sourceLine" id="cb9-4" data-line-number="4">         <span class="ot">:</span> A <span class="ot">‚Üí</span> <span class="dt">Set</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  refl <span class="ot">:</span> x ‚â° x</a></code></pre></div>
</div>
</div>
<p>This is one of the many ways to describe equality in Agda. It‚Äôs a type with only one constructor, and it can only be constructed when its two arguments are the same. When we pattern match on the constructor, then, we‚Äôre given a proof that whatever things those arguments refer to must be the same.</p>
<p>Next, we need to describe an order. For this, we‚Äôll need two types: the empty type, and the unit type.</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Void</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Unit</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="kw">where</span> <span class="dt">Unit</span><span class="ot"> ::</span> <span class="dt">Unit</span></a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb11"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">data</span> ‚ä• <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2"><span class="kw">data</span> ‚ä§ <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span> ‚ü®‚ü© <span class="ot">:</span> ‚ä§</a></code></pre></div>
</div>
</div>
<p>These are kind of like type-level Bools, with one extra, powerful addition: they keep their proof after construction. Because <code class="sourceCode agda">‚ä•</code> has no constructors, if someone tells you they‚Äôre going to give you one, you can be pretty sure they‚Äôre lying. How do we use this? Well, first, on the numbers:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">type</span> family (<span class="ot">n ::</span> <span class="dt">N</span>) <span class="fu">&lt;</span> (<span class="ot">m ::</span> <span class="dt">N</span>)</a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="ot">    ::</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">  x   <span class="fu">&lt;</span> <span class="dt">Z</span>   <span class="fu">=</span> <span class="dt">Void</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">  <span class="dt">Z</span>   <span class="fu">&lt;</span> <span class="dt">S</span> y <span class="fu">=</span> <span class="dt">Unit</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5">  <span class="dt">S</span> x <span class="fu">&lt;</span> <span class="dt">S</span> y <span class="fu">=</span> x <span class="fu">&lt;</span> y</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb13"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="ot">_</span>‚Ñï&lt;<span class="ot">_</span> <span class="ot">:</span> ‚Ñï <span class="ot">‚Üí</span> ‚Ñï <span class="ot">‚Üí</span> <span class="dt">Set</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">x     ‚Ñï&lt; zero  <span class="ot">=</span> ‚ä•</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">zero  ‚Ñï&lt; suc y <span class="ot">=</span> ‚ä§</a>
<a class="sourceLine" id="cb13-4" data-line-number="4">suc x ‚Ñï&lt; suc y <span class="ot">=</span> x ‚Ñï&lt; y</a></code></pre></div>
</div>
</div>
<p>Therefore, if we ask for something of type <code class="sourceCode agda">x ‚Ñï&lt; y</code> (for some <code>x</code> and <code>y</code>), we know that it only exists when <code>x</code> really is less than <code>y</code> (according to the definition above).</p>
<p>For our actual code, we‚Äôll parameterize the whole thing over some abstract key type. We‚Äôll do this using a module (a feature recently added to Haskell, as it happens). That might look something like this:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1">signature <span class="dt">Key</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2">  <span class="kw">import</span> <span class="dt">Data.Kind</span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3">  <span class="kw">data</span> <span class="dt">Key</span></a>
<a class="sourceLine" id="cb14-4" data-line-number="4">  <span class="kw">type</span> family (<span class="ot">n ::</span> <span class="dt">Key</span>) <span class="fu">&lt;</span> (<span class="ot">m ::</span> <span class="dt">Key</span>)</a>
<a class="sourceLine" id="cb14-5" data-line-number="5"><span class="ot">    ::</span> <span class="dt">Type</span></a>
<a class="sourceLine" id="cb14-6" data-line-number="6"></a>
<a class="sourceLine" id="cb14-7" data-line-number="7"><span class="kw">module</span> <span class="dt">AVL</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-8" data-line-number="8">  <span class="kw">import</span> <span class="dt">Key</span></a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb15"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="kw">module</span> AVL</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">  <span class="ot">{</span>k r<span class="ot">}</span> <span class="ot">(</span>Key <span class="ot">:</span> <span class="dt">Set</span> k<span class="ot">)</span></a>
<a class="sourceLine" id="cb15-3" data-line-number="3">  <span class="ot">{_</span>&lt;<span class="ot">_</span> <span class="ot">:</span> Rel Key r<span class="ot">}</span></a>
<a class="sourceLine" id="cb15-4" data-line-number="4">  <span class="ot">(</span>isStrictTotalOrder</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">   <span class="ot">:</span> IsStrictTotalOrder <span class="ot">_</span>‚â°<span class="ot">_</span> <span class="ot">_</span>&lt;<span class="ot">_)</span></a>
<a class="sourceLine" id="cb15-6" data-line-number="6">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-7" data-line-number="7"></a>
<a class="sourceLine" id="cb15-8" data-line-number="8">  <span class="kw">open</span> IsStrictTotalOrder isStrictTotalOrder</a></code></pre></div>
</div>
</div>
<p>(the <code class="sourceCode agda">k</code> and <code class="sourceCode agda">r</code> here, as well as the <code class="sourceCode agda">Lift</code>ing noise below, are to do with Agda‚Äôs universe system, which I‚Äôll try explain in a bit)</p>
<p>Now, the trick for the ordering is to keep a proof that two neighboring values are ordered correctly in the tree at each leaf (as there‚Äôs a leaf between every pair of nodes, this is exactly the place you <em>should</em> store such a proof). A problem arises with the extremal leaves in the tree (leftmost and rightmost): each leaf is missing one neighboring value, so how can it store a proof of order? The solution is to affix two elements to our key type which we define as the greatest and least elements of the set.</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"></a>
<a class="sourceLine" id="cb16-2" data-line-number="2"></a>
<a class="sourceLine" id="cb16-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Bound</span> <span class="fu">=</span> <span class="dt">LB</span> <span class="fu">|</span> <span class="dt">IB</span> <span class="dt">Key</span> <span class="fu">|</span> <span class="dt">UB</span></a>
<a class="sourceLine" id="cb16-4" data-line-number="4"></a>
<a class="sourceLine" id="cb16-5" data-line-number="5"></a>
<a class="sourceLine" id="cb16-6" data-line-number="6"></a>
<a class="sourceLine" id="cb16-7" data-line-number="7">infix <span class="dv">4</span> <span class="fu">&lt;:</span></a>
<a class="sourceLine" id="cb16-8" data-line-number="8"></a>
<a class="sourceLine" id="cb16-9" data-line-number="9"><span class="kw">type</span> family (<span class="ot">x ::</span> <span class="dt">Bound</span>) <span class="fu">&lt;:</span> (<span class="ot">y ::</span> <span class="dt">Bound</span>)</a>
<a class="sourceLine" id="cb16-10" data-line-number="10"><span class="ot">    ::</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-11" data-line-number="11">  <span class="dt">LB</span>   <span class="fu">&lt;:</span> <span class="dt">LB</span>   <span class="fu">=</span> <span class="dt">Void</span></a>
<a class="sourceLine" id="cb16-12" data-line-number="12">  <span class="dt">LB</span>   <span class="fu">&lt;:</span> <span class="dt">UB</span>   <span class="fu">=</span> <span class="dt">Unit</span></a>
<a class="sourceLine" id="cb16-13" data-line-number="13">  <span class="dt">LB</span>   <span class="fu">&lt;:</span> <span class="dt">IB</span> _ <span class="fu">=</span> <span class="dt">Unit</span></a>
<a class="sourceLine" id="cb16-14" data-line-number="14">  <span class="dt">UB</span>   <span class="fu">&lt;:</span> _    <span class="fu">=</span> <span class="dt">Void</span></a>
<a class="sourceLine" id="cb16-15" data-line-number="15">  <span class="dt">IB</span> _ <span class="fu">&lt;:</span> <span class="dt">LB</span>   <span class="fu">=</span> <span class="dt">Void</span></a>
<a class="sourceLine" id="cb16-16" data-line-number="16">  <span class="dt">IB</span> _ <span class="fu">&lt;:</span> <span class="dt">UB</span>   <span class="fu">=</span> <span class="dt">Unit</span></a>
<a class="sourceLine" id="cb16-17" data-line-number="17">  <span class="dt">IB</span> x <span class="fu">&lt;:</span> <span class="dt">IB</span> y <span class="fu">=</span> x <span class="fu">&lt;</span> y</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb17"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw">infix</span> <span class="dv">5</span> [<span class="ot">_</span>]</a>
<a class="sourceLine" id="cb17-2" data-line-number="2"></a>
<a class="sourceLine" id="cb17-3" data-line-number="3"><span class="kw">data</span> [‚àô] <span class="ot">:</span> <span class="dt">Set</span> k <span class="kw">where</span></a>
<a class="sourceLine" id="cb17-4" data-line-number="4">  ‚åä‚åã ‚åà‚åâ <span class="ot">:</span> [‚àô]</a>
<a class="sourceLine" id="cb17-5" data-line-number="5">  [<span class="ot">_</span>]   <span class="ot">:</span> <span class="ot">(</span>k <span class="ot">:</span> Key<span class="ot">)</span> <span class="ot">‚Üí</span> [‚àô]</a>
<a class="sourceLine" id="cb17-6" data-line-number="6"></a>
<a class="sourceLine" id="cb17-7" data-line-number="7"><span class="kw">infix</span> <span class="dv">4</span> <span class="ot">_</span>[&lt;]<span class="ot">_</span></a>
<a class="sourceLine" id="cb17-8" data-line-number="8"></a>
<a class="sourceLine" id="cb17-9" data-line-number="9"><span class="ot">_</span>[&lt;]<span class="ot">_</span> <span class="ot">:</span> [‚àô] <span class="ot">‚Üí</span> [‚àô] <span class="ot">‚Üí</span> <span class="dt">Set</span> r</a>
<a class="sourceLine" id="cb17-10" data-line-number="10">‚åä‚åã     [&lt;] ‚åä‚åã    <span class="ot">=</span> Lift r ‚ä•</a>
<a class="sourceLine" id="cb17-11" data-line-number="11">‚åä‚åã     [&lt;] ‚åà‚åâ    <span class="ot">=</span> Lift r ‚ä§</a>
<a class="sourceLine" id="cb17-12" data-line-number="12">‚åä‚åã     [&lt;] [ <span class="ot">_</span> ] <span class="ot">=</span> Lift r ‚ä§</a>
<a class="sourceLine" id="cb17-13" data-line-number="13">‚åà‚åâ     [&lt;] <span class="ot">_</span>     <span class="ot">=</span> Lift r ‚ä•</a>
<a class="sourceLine" id="cb17-14" data-line-number="14">[ <span class="ot">_</span> ]  [&lt;] ‚åä‚åã    <span class="ot">=</span> Lift r ‚ä•</a>
<a class="sourceLine" id="cb17-15" data-line-number="15">[ <span class="ot">_</span> ]  [&lt;] ‚åà‚åâ    <span class="ot">=</span> Lift r ‚ä§</a>
<a class="sourceLine" id="cb17-16" data-line-number="16">[ x ]  [&lt;] [ y ] <span class="ot">=</span> x &lt; y</a></code></pre></div>
</div>
</div>
<h1 id="the-tree-type">The Tree Type</h1>
<p>After all that, we can get bring back Haskell into the story, and define or tree types:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"></a>
<a class="sourceLine" id="cb18-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Tree</span><span class="ot"> ::</span> <span class="dt">N</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3">          <span class="ot">-&gt;</span> <span class="dt">Type</span></a>
<a class="sourceLine" id="cb18-4" data-line-number="4">          <span class="ot">-&gt;</span> <span class="dt">Type</span></a>
<a class="sourceLine" id="cb18-5" data-line-number="5">          <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-6" data-line-number="6">  <span class="dt">Leaf</span><span class="ot"> ::</span> <span class="dt">Tree</span> <span class="dt">Z</span> k v</a>
<a class="sourceLine" id="cb18-7" data-line-number="7">  <span class="dt">Node</span><span class="ot"> ::</span> k</a>
<a class="sourceLine" id="cb18-8" data-line-number="8">       <span class="ot">-&gt;</span> v</a>
<a class="sourceLine" id="cb18-9" data-line-number="9">       <span class="ot">-&gt;</span> <span class="dt">Balance</span> lh rh h</a>
<a class="sourceLine" id="cb18-10" data-line-number="10">       <span class="ot">-&gt;</span> <span class="dt">Tree</span> lh k v</a>
<a class="sourceLine" id="cb18-11" data-line-number="11">       <span class="ot">-&gt;</span> <span class="dt">Tree</span> rh k v</a>
<a class="sourceLine" id="cb18-12" data-line-number="12">       <span class="ot">-&gt;</span> <span class="dt">Tree</span> (<span class="dt">S</span> h) k v</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb19"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="kw">data</span> Tree <span class="ot">{</span>v<span class="ot">}</span> </a>
<a class="sourceLine" id="cb19-2" data-line-number="2">          <span class="ot">(</span>V <span class="ot">:</span> Key <span class="ot">‚Üí</span> <span class="dt">Set</span> v<span class="ot">)</span></a>
<a class="sourceLine" id="cb19-3" data-line-number="3">          <span class="ot">(</span>l u <span class="ot">:</span> [‚àô]<span class="ot">)</span> <span class="ot">:</span> ‚Ñï <span class="ot">‚Üí</span></a>
<a class="sourceLine" id="cb19-4" data-line-number="4">          <span class="dt">Set</span> <span class="ot">(</span>k ‚äî v ‚äî r<span class="ot">)</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-5" data-line-number="5">  leaf  <span class="ot">:</span> <span class="ot">(</span>l&lt;u <span class="ot">:</span> l [&lt;] u<span class="ot">)</span> <span class="ot">‚Üí</span> Tree V l u <span class="dv">0</span></a>
<a class="sourceLine" id="cb19-6" data-line-number="6">  node  <span class="ot">:</span> <span class="ot">‚àÄ</span>  <span class="ot">{</span>h lh rh<span class="ot">}</span></a>
<a class="sourceLine" id="cb19-7" data-line-number="7">             <span class="ot">(</span>k <span class="ot">:</span> Key<span class="ot">)</span></a>
<a class="sourceLine" id="cb19-8" data-line-number="8">             <span class="ot">(</span>v <span class="ot">:</span> V k<span class="ot">)</span></a>
<a class="sourceLine" id="cb19-9" data-line-number="9">             <span class="ot">(</span>bl <span class="ot">:</span> ‚ü® lh ‚äî rh ‚ü©‚â° h<span class="ot">)</span></a>
<a class="sourceLine" id="cb19-10" data-line-number="10">             <span class="ot">(</span>lk <span class="ot">:</span> Tree V l [ k ] lh<span class="ot">)</span></a>
<a class="sourceLine" id="cb19-11" data-line-number="11">             <span class="ot">(</span>ku <span class="ot">:</span> Tree V [ k ] u rh<span class="ot">)</span> <span class="ot">‚Üí</span></a>
<a class="sourceLine" id="cb19-12" data-line-number="12">             Tree V l u <span class="ot">(</span>suc h<span class="ot">)</span></a></code></pre></div>
</div>
</div>
<p>The two definitions are similar, but have a few obvious differences. The Agda version stores the ordering proof at the leaves, as well as the bounds as indices. Its <a href="https://pigworker.wordpress.com/2015/01/09/universe-hierarchies/"><em>universe</em></a> is also different: briefly, universes are one of the ways to avoid Russell‚Äôs paradox when you‚Äôre dealing with dependent types.</p>
<p>In normal, standard Haskell, we think of types as things that describe values (how quaint!). When you‚Äôve got a list, everything in the list has the same type, and that is good and right.</p>
<p>These days, though, we‚Äôre not so constrained:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:-</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2"><span class="kw">data</span> <span class="dt">List</span> xs <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-3" data-line-number="3">  <span class="dt">Nil</span><span class="ot">  ::</span> <span class="dt">List</span> <span class="ch">&#39;[]</span></a>
<a class="sourceLine" id="cb20-4" data-line-number="4"><span class="ot">  (:-) ::</span> x</a>
<a class="sourceLine" id="cb20-5" data-line-number="5">       <span class="ot">-&gt;</span> <span class="dt">List</span> xs</a>
<a class="sourceLine" id="cb20-6" data-line-number="6">       <span class="ot">-&gt;</span> <span class="dt">List</span> (x <span class="fu">:</span> xs)</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb21"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">5</span> <span class="ot">_</span>·ç¶<span class="ot">_</span></a>
<a class="sourceLine" id="cb21-2" data-line-number="2"><span class="kw">data</span> List‚Ä≤ <span class="ot">:</span> List <span class="dt">Set</span> <span class="ot">‚Üí</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-3" data-line-number="3">  nil <span class="ot">:</span> List‚Ä≤ []</a>
<a class="sourceLine" id="cb21-4" data-line-number="4">  <span class="ot">_</span>·ç¶<span class="ot">_</span> <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>x xs<span class="ot">}</span></a>
<a class="sourceLine" id="cb21-5" data-line-number="5">      <span class="ot">‚Üí</span> x </a>
<a class="sourceLine" id="cb21-6" data-line-number="6">      <span class="ot">‚Üí</span> List‚Ä≤ xs </a>
<a class="sourceLine" id="cb21-7" data-line-number="7">      <span class="ot">‚Üí</span> List‚Ä≤ <span class="ot">(</span>x ‚à∑ xs<span class="ot">)</span></a></code></pre></div>
</div>
</div>
<p>This can quite happily store elements of different types:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="ot">example ::</span> <span class="dt">List</span> [<span class="dt">Bool</span>, <span class="dt">String</span>, <span class="dt">Integer</span>]</a>
<a class="sourceLine" id="cb22-2" data-line-number="2">example <span class="fu">=</span> <span class="dt">True</span> <span class="fu">:-</span> <span class="st">&quot;true&quot;</span> <span class="fu">:-</span> <span class="dv">1</span> <span class="fu">:-</span> <span class="dt">Nil</span></a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb23"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb23-1" data-line-number="1">example <span class="ot">:</span> List‚Ä≤ <span class="ot">(</span>Bool ‚à∑ String ‚à∑ ‚Ñï ‚à∑ []<span class="ot">)</span></a>
<a class="sourceLine" id="cb23-2" data-line-number="2">example <span class="ot">=</span> true ·ç¶ <span class="st">&quot;true&quot;</span> ·ç¶ <span class="dv">1</span> ·ç¶ nil</a></code></pre></div>
</div>
</div>
<p>And look at that bizarre-looking list on the wrong side of ‚Äú<code class="sourceCode haskell"><span class="ot">::</span></code>‚Äù! Types aren‚Äôt just describing values, they‚Äôre acting like values themselves. What type does <code class="sourceCode haskell">[<span class="dt">Bool</span>, <span class="dt">String</span>, <span class="dt">Integer</span>]</code> even have, anyway? Why, <code class="sourceCode haskell">[<span class="dt">Type</span>]</code> of course!</p>
<p>So we see that types can be put in lists, and types have types: the natural question then is:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="dt">Type</span><span class="ot"> ::</span> <span class="fu">???</span></a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb25"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="dt">Set</span> <span class="ot">:</span> ???</a></code></pre></div>
</div>
</div>
<p>And this is where Haskell and Agda diverge: in Haskell, we say <code class="sourceCode haskell"><span class="dt">Type</span><span class="ot"> ::</span> <span class="dt">Type</span></code> (as the old extension <code class="sourceCode haskell"><span class="dt">TypeInType</span></code> implied), and that‚Äôs that. From a certain point of view, we‚Äôve opened the door to Russell‚Äôs paradox (we‚Äôve allowed a set to be a member of itself). This isn‚Äôt an issue in Haskell, though, as the type-level language was already inconsistent.</p>
<p>Agda goes another way, saying that <code class="sourceCode agda"><span class="dt">Set</span></code> (Agda‚Äôs equivalent for <code class="sourceCode haskell"><span class="dt">Type</span></code>) has the type <code class="sourceCode agda"><span class="dt">Set‚ÇÅ</span></code>, and <code class="sourceCode agda"><span class="dt">Set‚ÇÅ</span></code> has the type <code class="sourceCode agda"><span class="dt">Set‚ÇÇ</span></code>, and so on<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>. These different sets are called ‚Äúuniverses‚Äù and their numbers ‚Äúlevels‚Äù. When we write <code class="sourceCode agda">k ‚äî v ‚äî r</code>, we‚Äôre saying we want to take the greatest universe level from those three possible levels: the level of the key, the value, and the relation, respectively.</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="dt">Type</span><span class="ot"> ::</span> <span class="dt">Type</span></a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb27"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="dt">Set</span> <span class="ot">:</span> <span class="dt">Set‚ÇÅ</span></a></code></pre></div>
</div>
</div>
<h1 id="rotations">Rotations</h1>
<p>AVL trees maintain their invariants through relatively simple rotations. We‚Äôll start with the right rotation, which fixes an imbalance of two on the left. Because the size of the tree returned might change, we‚Äôll need to wrap it in a datatype:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1"><span class="kw">data</span><span class="ot"> (++?) ::</span> (<span class="dt">N</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>)</a>
<a class="sourceLine" id="cb28-2" data-line-number="2">           <span class="ot">-&gt;</span> (<span class="dt">N</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>)</a>
<a class="sourceLine" id="cb28-3" data-line-number="3">           <span class="kw">where</span></a>
<a class="sourceLine" id="cb28-4" data-line-number="4">  <span class="dt">Stay</span><span class="ot"> ::</span> t n     <span class="ot">-&gt;</span> t <span class="fu">++?</span> n</a>
<a class="sourceLine" id="cb28-5" data-line-number="5">  <span class="dt">Incr</span><span class="ot"> ::</span> t (<span class="dt">S</span> n) <span class="ot">-&gt;</span> t <span class="fu">++?</span> n</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb29"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb29-1" data-line-number="1"></a>
<a class="sourceLine" id="cb29-2" data-line-number="2"><span class="ot">_</span>1?+‚ü®<span class="ot">_</span>‚ü© <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>ùìÅ<span class="ot">}</span> <span class="ot">(</span>T <span class="ot">:</span> ‚Ñï <span class="ot">‚Üí</span> <span class="dt">Set</span> ùìÅ<span class="ot">)</span> <span class="ot">‚Üí</span> ‚Ñï <span class="ot">‚Üí</span> <span class="dt">Set</span> ùìÅ</a>
<a class="sourceLine" id="cb29-3" data-line-number="3">T 1?+‚ü® n ‚ü© <span class="ot">=</span> ‚àÉ[ inc? ] T <span class="ot">(</span>if inc?</a>
<a class="sourceLine" id="cb29-4" data-line-number="4">                            then suc n</a>
<a class="sourceLine" id="cb29-5" data-line-number="5">                            else n<span class="ot">)</span></a>
<a class="sourceLine" id="cb29-6" data-line-number="6"></a>
<a class="sourceLine" id="cb29-7" data-line-number="7"><span class="kw">pattern</span> 0+<span class="ot">_</span> tr <span class="ot">=</span> false , tr</a>
<a class="sourceLine" id="cb29-8" data-line-number="8"><span class="kw">pattern</span> 1+<span class="ot">_</span> tr <span class="ot">=</span> true  , tr</a></code></pre></div>
</div>
</div>
<p>We could actually have the Agda definition be the same as Haskell‚Äôs, it doesn‚Äôt make much difference. I‚Äôm mainly using it here to demonstrate dependent pairs in Agda. The first member of the pair is just a boolean (increased in height/not increased in height). The second member is a tree whose height <em>depends</em> on the actual value of the boolean. The <code class="sourceCode agda">‚àÉ</code> business is just a fancy syntax; it also waggles its eyebrows at the way a (dependent) pair of type <code>(x , y)</code> means ‚ÄúThere exists an x such that y‚Äù.</p>
<p>Using this, we can write the type for right-rotation:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="ot">rotr ::</span> k</a>
<a class="sourceLine" id="cb30-2" data-line-number="2">     <span class="ot">-&gt;</span> v</a>
<a class="sourceLine" id="cb30-3" data-line-number="3">     <span class="ot">-&gt;</span> <span class="dt">Tree</span> (<span class="dt">S</span> (<span class="dt">S</span> rh)) k v</a>
<a class="sourceLine" id="cb30-4" data-line-number="4">     <span class="ot">-&gt;</span> <span class="dt">Tree</span> rh k v</a>
<a class="sourceLine" id="cb30-5" data-line-number="5">     <span class="ot">-&gt;</span> <span class="dt">Tree</span> k v <span class="fu">++?</span> <span class="dt">S</span> (<span class="dt">S</span> rh)</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb31"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb31-1" data-line-number="1">rot ≥ <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>lb ub rh v<span class="ot">}</span> <span class="ot">{</span>V <span class="ot">:</span> Key <span class="ot">‚Üí</span> <span class="dt">Set</span> v<span class="ot">}</span></a>
<a class="sourceLine" id="cb31-2" data-line-number="2">     <span class="ot">‚Üí</span> <span class="ot">(</span>k <span class="ot">:</span> Key<span class="ot">)</span></a>
<a class="sourceLine" id="cb31-3" data-line-number="3">     <span class="ot">‚Üí</span> V k</a>
<a class="sourceLine" id="cb31-4" data-line-number="4">     <span class="ot">‚Üí</span> Tree V lb [ k ] <span class="ot">(</span>suc <span class="ot">(</span>suc rh<span class="ot">))</span></a>
<a class="sourceLine" id="cb31-5" data-line-number="5">     <span class="ot">‚Üí</span> Tree V [ k ] ub rh</a>
<a class="sourceLine" id="cb31-6" data-line-number="6">     <span class="ot">‚Üí</span> Tree V lb ub 1?+‚ü® suc <span class="ot">(</span>suc rh<span class="ot">)</span> ‚ü©</a></code></pre></div>
</div>
</div>
<p>There are two possible cases, single rotation:</p>
<style>
.tree {
  margin: auto;
  width: 30%;
}
</style>
<div class="tree">
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" data-line-number="1">   ‚îåa       ‚îåa</a>
<a class="sourceLine" id="cb32-2" data-line-number="2"> ‚îåy‚î§       y‚î§</a>
<a class="sourceLine" id="cb32-3" data-line-number="3"> ‚îÇ ‚îîb <span class="fu">---&gt;</span>  ‚îÇ ‚îåb</a>
<a class="sourceLine" id="cb32-4" data-line-number="4">x‚î§          ‚îîx‚î§</a>
<a class="sourceLine" id="cb32-5" data-line-number="5"> ‚îîc           ‚îîc</a></code></pre></div>
</div>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" data-line-number="1">rotr x xv (<span class="dt">Node</span> y yv <span class="dt">L</span> a b) c <span class="fu">=</span></a>
<a class="sourceLine" id="cb33-2" data-line-number="2">  <span class="dt">Stay</span> (<span class="dt">Node</span> y yv <span class="dt">O</span> a (<span class="dt">Node</span> x xv <span class="dt">O</span> b c))</a>
<a class="sourceLine" id="cb33-3" data-line-number="3">rotr x xv (<span class="dt">Node</span> y yv <span class="dt">O</span> a b) c <span class="fu">=</span></a>
<a class="sourceLine" id="cb33-4" data-line-number="4">  <span class="dt">Incr</span> (<span class="dt">Node</span> y yv <span class="dt">R</span> a (<span class="dt">Node</span> x xv <span class="dt">L</span> b c))</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb34"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb34-1" data-line-number="1">rot ≥ x xv <span class="ot">(</span>node y yv ‚óø a b<span class="ot">)</span> c <span class="ot">=</span></a>
<a class="sourceLine" id="cb34-2" data-line-number="2">  0+ <span class="ot">(</span>node y yv ‚ñΩ a <span class="ot">(</span>node x xv ‚ñΩ  b c<span class="ot">))</span></a>
<a class="sourceLine" id="cb34-3" data-line-number="3">rot ≥ x xv <span class="ot">(</span>node y yv ‚ñΩ a b<span class="ot">)</span> c <span class="ot">=</span></a>
<a class="sourceLine" id="cb34-4" data-line-number="4">  1+ <span class="ot">(</span>node y yv ‚ó∫ a <span class="ot">(</span>node x xv ‚óø  b c<span class="ot">))</span></a></code></pre></div>
</div>
</div>
<p>And double:</p>
<div class="tree">
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb35-1" data-line-number="1">   ‚îåa           ‚îåa</a>
<a class="sourceLine" id="cb35-2" data-line-number="2"> ‚îåy‚î§          ‚îåy‚î§</a>
<a class="sourceLine" id="cb35-3" data-line-number="3"> ‚îÇ ‚îÇ ‚îåb       ‚îÇ ‚îîb</a>
<a class="sourceLine" id="cb35-4" data-line-number="4"> ‚îÇ ‚îîz‚î§  <span class="fu">---&gt;</span> z‚î§</a>
<a class="sourceLine" id="cb35-5" data-line-number="5"> ‚îÇ   ‚îîc       ‚îÇ ‚îåc</a>
<a class="sourceLine" id="cb35-6" data-line-number="6">x‚î§            ‚îîx‚î§</a>
<a class="sourceLine" id="cb35-7" data-line-number="7"> ‚îîd             ‚îîd</a></code></pre></div>
</div>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" data-line-number="1">rotr x xv (<span class="dt">Node</span> y yv <span class="dt">R</span> a </a>
<a class="sourceLine" id="cb36-2" data-line-number="2">            (<span class="dt">Node</span> z zv bl b c)) d <span class="fu">=</span></a>
<a class="sourceLine" id="cb36-3" data-line-number="3">  <span class="dt">Stay</span> (<span class="dt">Node</span> z zv <span class="dt">O</span> </a>
<a class="sourceLine" id="cb36-4" data-line-number="4">         (<span class="dt">Node</span> y yv (balr bl) a b)</a>
<a class="sourceLine" id="cb36-5" data-line-number="5">         (<span class="dt">Node</span> x xv (ball bl) c d))</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb37"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb37-1" data-line-number="1">rot ≥ x xv <span class="ot">(</span>node y yv ‚ó∫  a</a>
<a class="sourceLine" id="cb37-2" data-line-number="2">            <span class="ot">(</span>node z zv bl b c<span class="ot">))</span> d <span class="ot">=</span></a>
<a class="sourceLine" id="cb37-3" data-line-number="3">  0+ <span class="ot">(</span>node z zv ‚ñΩ</a>
<a class="sourceLine" id="cb37-4" data-line-number="4">       <span class="ot">(</span>node y yv <span class="ot">(</span>‚Éï bl<span class="ot">)</span> a b<span class="ot">)</span></a>
<a class="sourceLine" id="cb37-5" data-line-number="5">       <span class="ot">(</span>node x xv <span class="ot">(</span>‚Éî bl<span class="ot">)</span> c d<span class="ot">))</span></a></code></pre></div>
</div>
</div>
<p>I won‚Äôt bore you with left-rotation: suffice to say, it‚Äôs the opposite of right-rotation.</p>
<h1 id="insertion">Insertion</h1>
<p>Finally, the main event: insertion. Once the above functions have all been defined, it‚Äôs not very difficult, as it happens: by and large, the types guide you to the right answer. Of course, this is only after we decided to use the pivotal pragmatism and balance approach.</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb38-1" data-line-number="1">insertWith</a>
<a class="sourceLine" id="cb38-2" data-line-number="2"><span class="ot">    ::</span> <span class="dt">Ord</span> k</a>
<a class="sourceLine" id="cb38-3" data-line-number="3">    <span class="ot">=&gt;</span> (v <span class="ot">-&gt;</span> v <span class="ot">-&gt;</span> v)</a>
<a class="sourceLine" id="cb38-4" data-line-number="4">    <span class="ot">-&gt;</span> k</a>
<a class="sourceLine" id="cb38-5" data-line-number="5">    <span class="ot">-&gt;</span> v</a>
<a class="sourceLine" id="cb38-6" data-line-number="6">    <span class="ot">-&gt;</span> <span class="dt">Tree</span> h k v</a>
<a class="sourceLine" id="cb38-7" data-line-number="7">    <span class="ot">-&gt;</span> <span class="dt">Tree</span> k v <span class="fu">++?</span> h</a>
<a class="sourceLine" id="cb38-8" data-line-number="8">insertWith _ v vc <span class="dt">Leaf</span> <span class="fu">=</span></a>
<a class="sourceLine" id="cb38-9" data-line-number="9">  <span class="dt">Incr</span> (<span class="dt">Node</span> v vc <span class="dt">O</span> <span class="dt">Leaf</span> <span class="dt">Leaf</span>)</a>
<a class="sourceLine" id="cb38-10" data-line-number="10">insertWith f v vc (<span class="dt">Node</span> k kc bl tl tr) <span class="fu">=</span></a>
<a class="sourceLine" id="cb38-11" data-line-number="11">  <span class="kw">case</span> compare v k <span class="kw">of</span></a>
<a class="sourceLine" id="cb38-12" data-line-number="12">    <span class="dt">LT</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb38-13" data-line-number="13">      <span class="kw">case</span> insertWith f v vc tl <span class="kw">of</span></a>
<a class="sourceLine" id="cb38-14" data-line-number="14">        <span class="dt">Stay</span> tl&#39; <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb38-15" data-line-number="15">          <span class="dt">Stay</span> (<span class="dt">Node</span> k kc bl tl&#39; tr)</a>
<a class="sourceLine" id="cb38-16" data-line-number="16">        <span class="dt">Incr</span> tl&#39; <span class="ot">-&gt;</span> <span class="kw">case</span> bl <span class="kw">of</span></a>
<a class="sourceLine" id="cb38-17" data-line-number="17">          <span class="dt">L</span> <span class="ot">-&gt;</span> rotr k kc tl&#39; tr</a>
<a class="sourceLine" id="cb38-18" data-line-number="18">          <span class="dt">O</span> <span class="ot">-&gt;</span> <span class="dt">Incr</span> (<span class="dt">Node</span> k kc <span class="dt">L</span> tl&#39; tr)</a>
<a class="sourceLine" id="cb38-19" data-line-number="19">          <span class="dt">R</span> <span class="ot">-&gt;</span> <span class="dt">Stay</span> (<span class="dt">Node</span> k kc <span class="dt">O</span> tl&#39; tr)</a>
<a class="sourceLine" id="cb38-20" data-line-number="20">    <span class="dt">EQ</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb38-21" data-line-number="21">      <span class="dt">Stay</span> (<span class="dt">Node</span> v (f vc kc) bl tl tr)</a>
<a class="sourceLine" id="cb38-22" data-line-number="22">    <span class="dt">GT</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb38-23" data-line-number="23">      <span class="kw">case</span> insertWith f v vc tr <span class="kw">of</span></a>
<a class="sourceLine" id="cb38-24" data-line-number="24">        <span class="dt">Stay</span> tr&#39; <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb38-25" data-line-number="25">          <span class="dt">Stay</span> (<span class="dt">Node</span> k kc bl tl tr&#39;)</a>
<a class="sourceLine" id="cb38-26" data-line-number="26">        <span class="dt">Incr</span> tr&#39; <span class="ot">-&gt;</span> <span class="kw">case</span> bl <span class="kw">of</span></a>
<a class="sourceLine" id="cb38-27" data-line-number="27">          <span class="dt">L</span> <span class="ot">-&gt;</span> <span class="dt">Stay</span> (<span class="dt">Node</span> k kc <span class="dt">O</span> tl tr&#39;)</a>
<a class="sourceLine" id="cb38-28" data-line-number="28">          <span class="dt">O</span> <span class="ot">-&gt;</span> <span class="dt">Incr</span> (<span class="dt">Node</span> k kc <span class="dt">R</span> tl tr&#39;)</a>
<a class="sourceLine" id="cb38-29" data-line-number="29">          <span class="dt">R</span> <span class="ot">-&gt;</span> rotl k kc tl tr&#39;</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb39"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb39-1" data-line-number="1">insert <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>l u h v<span class="ot">}</span></a>
<a class="sourceLine" id="cb39-2" data-line-number="2">           <span class="ot">{</span>V <span class="ot">:</span> Key <span class="ot">‚Üí</span> <span class="dt">Set</span> v<span class="ot">}</span></a>
<a class="sourceLine" id="cb39-3" data-line-number="3">           <span class="ot">(</span>k <span class="ot">:</span> Key<span class="ot">)</span></a>
<a class="sourceLine" id="cb39-4" data-line-number="4">       <span class="ot">‚Üí</span> V k</a>
<a class="sourceLine" id="cb39-5" data-line-number="5">       <span class="ot">‚Üí</span> <span class="ot">(</span>V k <span class="ot">‚Üí</span> V k <span class="ot">‚Üí</span> V k<span class="ot">)</span></a>
<a class="sourceLine" id="cb39-6" data-line-number="6">       <span class="ot">‚Üí</span> Tree V l u h</a>
<a class="sourceLine" id="cb39-7" data-line-number="7">       <span class="ot">‚Üí</span> l &lt; k &lt; u</a>
<a class="sourceLine" id="cb39-8" data-line-number="8">       <span class="ot">‚Üí</span> Tree V l u 1?+‚ü® h ‚ü©</a>
<a class="sourceLine" id="cb39-9" data-line-number="9">insert v vc f <span class="ot">(</span>leaf l&lt;u<span class="ot">)</span> <span class="ot">(</span>l , u<span class="ot">)</span> <span class="ot">=</span></a>
<a class="sourceLine" id="cb39-10" data-line-number="10">  1+ <span class="ot">(</span>node v vc ‚ñΩ <span class="ot">(</span>leaf l<span class="ot">)</span> <span class="ot">(</span>leaf u<span class="ot">))</span></a>
<a class="sourceLine" id="cb39-11" data-line-number="11">insert v vc f <span class="ot">(</span>node k kc bl tl tr<span class="ot">)</span> prf</a>
<a class="sourceLine" id="cb39-12" data-line-number="12">  <span class="kw">with</span> compare v k</a>
<a class="sourceLine" id="cb39-13" data-line-number="13">insert v vc f <span class="ot">(</span>node k kc bl tl tr<span class="ot">)</span> <span class="ot">(</span>l , <span class="ot">_)</span></a>
<a class="sourceLine" id="cb39-14" data-line-number="14">    <span class="ot">|</span> tri&lt; a <span class="ot">_</span> <span class="ot">_</span> <span class="kw">with</span> insert v vc f tl <span class="ot">(</span>l , a<span class="ot">)</span></a>
<a class="sourceLine" id="cb39-15" data-line-number="15"><span class="ot">...</span> <span class="ot">|</span> 0+ tl‚Ä≤ <span class="ot">=</span> 0+ <span class="ot">(</span>node k kc bl tl‚Ä≤ tr<span class="ot">)</span></a>
<a class="sourceLine" id="cb39-16" data-line-number="16"><span class="ot">...</span> <span class="ot">|</span> 1+ tl‚Ä≤ <span class="kw">with</span> bl</a>
<a class="sourceLine" id="cb39-17" data-line-number="17"><span class="ot">...</span> <span class="ot">|</span> ‚óø <span class="ot">=</span> rot ≥ k kc tl‚Ä≤ tr</a>
<a class="sourceLine" id="cb39-18" data-line-number="18"><span class="ot">...</span> <span class="ot">|</span> ‚ñΩ <span class="ot">=</span> 1+ <span class="ot">(</span>node k kc  ‚óø  tl‚Ä≤ tr<span class="ot">)</span></a>
<a class="sourceLine" id="cb39-19" data-line-number="19"><span class="ot">...</span> <span class="ot">|</span> ‚ó∫ <span class="ot">=</span> 0+ <span class="ot">(</span>node k kc  ‚ñΩ  tl‚Ä≤ tr<span class="ot">)</span></a>
<a class="sourceLine" id="cb39-20" data-line-number="20">insert v vc f <span class="ot">(</span>node k kc bl tl tr<span class="ot">)</span> <span class="ot">_</span></a>
<a class="sourceLine" id="cb39-21" data-line-number="21">    <span class="ot">|</span> tri‚âà <span class="ot">_</span> refl <span class="ot">_</span> <span class="ot">=</span></a>
<a class="sourceLine" id="cb39-22" data-line-number="22">        0+ <span class="ot">(</span>node k <span class="ot">(</span>f vc kc<span class="ot">)</span> bl tl tr<span class="ot">)</span></a>
<a class="sourceLine" id="cb39-23" data-line-number="23">insert v vc f <span class="ot">(</span>node k kc bl tl tr<span class="ot">)</span> <span class="ot">(_</span> , u<span class="ot">)</span></a>
<a class="sourceLine" id="cb39-24" data-line-number="24">    <span class="ot">|</span> tri&gt; <span class="ot">_</span> <span class="ot">_</span> c <span class="kw">with</span> insert v vc f tr <span class="ot">(</span>c , u<span class="ot">)</span></a>
<a class="sourceLine" id="cb39-25" data-line-number="25"><span class="ot">...</span> <span class="ot">|</span> 0+ tr‚Ä≤ <span class="ot">=</span> 0+ <span class="ot">(</span>node k kc bl tl tr‚Ä≤<span class="ot">)</span></a>
<a class="sourceLine" id="cb39-26" data-line-number="26"><span class="ot">...</span> <span class="ot">|</span> 1+ tr‚Ä≤ <span class="kw">with</span> bl</a>
<a class="sourceLine" id="cb39-27" data-line-number="27"><span class="ot">...</span> <span class="ot">|</span> ‚óø <span class="ot">=</span> 0+ <span class="ot">(</span>node k kc ‚ñΩ tl tr‚Ä≤<span class="ot">)</span></a>
<a class="sourceLine" id="cb39-28" data-line-number="28"><span class="ot">...</span> <span class="ot">|</span> ‚ñΩ <span class="ot">=</span> 1+ <span class="ot">(</span>node k kc ‚ó∫ tl tr‚Ä≤<span class="ot">)</span></a>
<a class="sourceLine" id="cb39-29" data-line-number="29"><span class="ot">...</span> <span class="ot">|</span> ‚ó∫ <span class="ot">=</span> rotÀ° k kc tl tr‚Ä≤</a></code></pre></div>
</div>
</div>
<h1 id="conclusion">Conclusion</h1>
<p>Overall, I‚Äôve been enjoying programming in Agda. The things I liked and didn‚Äôt like surprised me:</p>
<dl>
<dt>Editor Support</dt>
<dd><p>Is excellent. I use <a href="http://spacemacs.org">spacemacs</a>, and the whole thing worked pretty seamlessly. Proof search and auto was maybe not as powerful as Idris‚Äô, although that might be down to lack of experience (note‚Äîas I write this, I see you can enable case-splitting in proof search, so it looks like I was right about my lack of experience). In many ways, it was much better than Haskell‚Äôs editor support: personally, I have never managed to get case-splitting to work in my Haskell setup, never mind some of the fancier features that you get in Agda.</p>
<p>It‚Äôs worth noting that my experience with Idris is similar: maybe it‚Äôs something about dependent types?</p>
<p>Of course, I missed lots of extra tools, like linters, code formatters, etc., but the tight integration with the compiler was so useful it more than made up for it.</p>
<p>Also, I‚Äôd implore anyone who‚Äôs had trouble with emacs before to give <a href="http://spacemacs.org">spacemacs</a> a go. It works well out-of-the-box, and has a system for keybinding discovery that <em>actually works</em>.</p>
</dd>
<dt>Documentation</dt>
<dd><p>Pretty good, considering. There are some missing parts (<a href="https://agda.readthedocs.io/en/v2.5.4.1/language/rewriting.html">rewriting</a> and <a href="https://agda.readthedocs.io/en/v2.5.4.1/language/telescopes.html">telescopes</a> are both stubs on the documentation site), but there seemed to be more fully worked-out examples available online for different concepts when I needed to figure them out.</p>
</dd>
</dl>
<p>Now, the thing about a lot of these complaints/commendations (<em>especially</em> with regards to tooling and personal setups) is that people tend to be pretty bad about evaluating how difficult finicky tasks like editor setups are. Once you‚Äôve gotten the hang of some of this stuff, you forget that you ever didn‚Äôt. Agda is the second dependently-typed language I‚Äôve really gone for a deepish dive on, and I‚Äôve been using spacemacs for a while, so YMMV.</p>
<p>One area of the language itself that I would have liked to see more on was irrelevance. Looking back at the definition of the tree type, in the Haskell version there‚Äôs no singleton storing the height (the balance type stores all the information we need), which means that it definitely doesn‚Äôt exist at runtime. As I understand it, that implies that the type should be irrelevant in the equivalent Agda. However, when I actually mark it as irrelevant, everything works fine, except that missing cases warnings start showing up. I couldn‚Äôt figure out why: Haskell was able to infer full case coverage without the index, after all. Equality proof erasure, also: is it safe? Consistent?</p>
<p>All in all, I‚Äôd encourage more Haskellers to give Agda a try. It‚Äôs fun, interesting, and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="script"><mi>ùí∞</mi><mi>ùìÉ</mi><mi>ùíæ</mi><mi>ùí∏</mi><mi>‚Ñ¥</mi><mi>ùíπ</mi><mi>‚ÑØ</mi></mstyle><annotation encoding="application/x-tex">\mathcal{Unicode}</annotation></semantics></math>!</p>
<h1 id="further-reading">Further Reading</h1>
<p>No ‚Äúdeletion is left as an exercise to the reader‚Äù here, no sir! Fuller implementations of both the Haskell and Agda versions of the code here are available: first, a pdf of the Agda code with lovely colours is <a href="/pdfs/AVL.pdf">here</a>. The accompanying repository is <a href="https://github.com/oisdk/agda-avl">here</a>, and the equivalent for the Haskell code is <a href="https://github.com/oisdk/verified-avl">here</a>. Of course, if you would rather read something by someone who knows what they‚Äôre talking about, please see the</p>
<h1 id="references" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-danielsson_agda_2018">
<p>Danielsson, Nils Anders. 2018. ‚ÄúThe Agda standard library.‚Äù</p>
</div>
<div id="ref-mcbride_how_2014">
<p>McBride, Conor Thomas. 2014. ‚ÄúHow to Keep Your Neighbours in Order.‚Äù In <em>Proceedings of the 19th ACM SIGPLAN International Conference on Functional Programming</em>, 297‚Äì309. ICFP ‚Äô14. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/2628136.2628163">10.1145/2628136.2628163</a>.</p>
</div>
<div id="ref-pfaff_performance_2004">
<p>Pfaff, Ben. 2004. ‚ÄúPerformance Analysis of BSTs in System Software.‚Äù In <em>Proceedings of the Joint International Conference on Measurement and Modeling of Computer Systems</em>, 410‚Äì411. SIGMETRICS ‚Äô04/Performance ‚Äô04. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/1005686.1005742">10.1145/1005686.1005742</a>.</p>
</div>
<div id="ref-weirich_depending_2014">
<p>Weirich, Stephanie. 2014. ‚ÄúDepending on Types.‚Äù In <em>Proceedings of the 19th ACM SIGPLAN International Conference on Functional Programming</em>, 241‚Äì241. ICFP ‚Äô14. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/2628136.2631168">10.1145/2628136.2631168</a>.</p>
</div>
</div>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>My phrasing is maybe a little confusing here. When <code class="sourceCode haskell"><span class="dt">Set</span></code> ‚Äúhas the type‚Äù <code class="sourceCode agda"><span class="dt">Set‚ÇÅ</span></code> it means that <code class="sourceCode haskell"><span class="dt">Set</span></code> is <em>in</em> <code class="sourceCode agda"><span class="dt">Set‚ÇÅ</span></code>, not the other way around.<a href="#fnref1" class="footnote-back">‚Ü©</a></p></li>
</ol>
</section>
]]></description>
    <pubDate>Mon, 30 Jul 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-07-30-verified-avl.html</guid>
    <dc:creator>Donnacha Ois√≠n Kidney</dc:creator>
</item>
<item>
    <title>Probabilistic Functional Programming</title>
    <link>https://doisinkidney.com/posts/2018-07-17-probability-presentation.html</link>
    <description><![CDATA[<div class="info">
    Posted on July 17, 2018
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Probability.html">Probability</a>
    
</div>

<p><a href="/pdfs/prob-presentation.pdf">Here</a> are the slides for a short talk I gave to a reading group I‚Äôm in at Harvard today. The speaker notes are included in the pdf, code and the tex is available in the <a href="https://github.com/oisdk/prob-presentation">repository</a>.</p>
]]></description>
    <pubDate>Tue, 17 Jul 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-07-17-probability-presentation.html</guid>
    <dc:creator>Donnacha Ois√≠n Kidney</dc:creator>
</item>
<item>
    <title>Probability 5 Ways</title>
    <link>https://doisinkidney.com/posts/2018-06-30-probability-5-ways.html</link>
    <description><![CDATA[<div class="info">
    Posted on June 30, 2018
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Probability.html">Probability</a>, <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<p>Ever since the famous pearl by <span class="citation" data-cites="erwig_functional_2006">Erwig and Kollmansberger (<a href="#ref-erwig_functional_2006">2006</a>)</span>, probabilistic programming with monads has been an interesting and diverse area in functional programming, with many different approaches.</p>
<p>I‚Äôm going to present five here, some of which I have not seen before.</p>
<h1 id="the-classic">The Classic</h1>
<p>As presented in the paper, a simple and elegant formulation of probability distributions looks like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Prob</span> a</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Prob</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">    {<span class="ot"> runProb ::</span> [(a, <span class="dt">Rational</span>)]</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">    }</a></code></pre></div>
<p>It‚Äôs a list of possible events, each tagged with their probability of happening. Here‚Äôs the probability distribution representing a die roll, for instance:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">die ::</span> <span class="dt">Prob</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">die <span class="fu">=</span> [ (x, <span class="dv">1</span><span class="fu">/</span><span class="dv">6</span>) <span class="fu">|</span> x <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span><span class="dv">6</span>] ]</a></code></pre></div>
<p>The semantics can afford to be a little fuzzy: it doesn‚Äôt hugely matter if the probabilities don‚Äôt add up to 1 (you can still extract meaningful answers when they don‚Äôt). However, I can‚Äôt see a way in which either negative probabilities or an empty list would make sense. It would be nice if those states were unrepresentable.</p>
<p>Its monadic structure multiplies conditional events:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Prob</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">    fmap f xs <span class="fu">=</span> <span class="dt">Prob</span> [ (f x, p) <span class="fu">|</span> (x,p) <span class="ot">&lt;-</span> runProb xs ]</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">    </a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Prob</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">    pure x <span class="fu">=</span> <span class="dt">Prob</span> [(x,<span class="dv">1</span>)]</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">    fs <span class="fu">&lt;*&gt;</span> xs</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">        <span class="fu">=</span> <span class="dt">Prob</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8">        [ (f x,fp<span class="fu">*</span>xp)</a>
<a class="sourceLine" id="cb3-9" data-line-number="9">        <span class="fu">|</span> (f,fp) <span class="ot">&lt;-</span> runProb fs</a>
<a class="sourceLine" id="cb3-10" data-line-number="10">        , (x,xp) <span class="ot">&lt;-</span> runProb xs ]</a>
<a class="sourceLine" id="cb3-11" data-line-number="11">                     </a>
<a class="sourceLine" id="cb3-12" data-line-number="12"><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Prob</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-13" data-line-number="13">    xs <span class="fu">&gt;&gt;=</span> f</a>
<a class="sourceLine" id="cb3-14" data-line-number="14">        <span class="fu">=</span> <span class="dt">Prob</span></a>
<a class="sourceLine" id="cb3-15" data-line-number="15">        [ (y,xp<span class="fu">*</span>yp)</a>
<a class="sourceLine" id="cb3-16" data-line-number="16">        <span class="fu">|</span> (x,xp) <span class="ot">&lt;-</span> runProb xs</a>
<a class="sourceLine" id="cb3-17" data-line-number="17">        , (y,yp) <span class="ot">&lt;-</span> runProb (f x) ]</a></code></pre></div>
<p>In most of the examples, we‚Äôll need a few extra functions in order for the types to be useful. First is support:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">support ::</span> <span class="dt">Prob</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">support <span class="fu">=</span> fmap fst <span class="fu">.</span> runProb</a></code></pre></div>
<p>And second is expectation:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">expect ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Rational</span>) <span class="ot">-&gt;</span> <span class="dt">Prob</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">expect p xs <span class="fu">=</span> sum [ p x <span class="fu">*</span> xp <span class="fu">|</span> (x,xp) <span class="ot">&lt;-</span> runProb xs ]</a>
<a class="sourceLine" id="cb5-3" data-line-number="3"></a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="ot">probOf ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Prob</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">probOf p <span class="fu">=</span> expect (bool <span class="dv">0</span> <span class="dv">1</span> <span class="fu">.</span> p)</a></code></pre></div>
<p>It‚Äôs useful to be able to construct uniform distributions:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1">uniform xs <span class="fu">=</span> <span class="dt">Prob</span> [ (x,n) <span class="fu">|</span> x <span class="ot">&lt;-</span> xs ]</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">    n <span class="fu">=</span> <span class="dv">1</span> <span class="fu">%</span> toEnum (length xs)</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">    </a>
<a class="sourceLine" id="cb6-5" data-line-number="5">die <span class="fu">=</span> uniform [<span class="dv">1</span><span class="fu">..</span><span class="dv">6</span>]</a>
<a class="sourceLine" id="cb6-6" data-line-number="6"></a>
<a class="sourceLine" id="cb6-7" data-line-number="7"><span class="fu">&gt;&gt;&gt;</span> probOf (<span class="dv">7</span><span class="fu">==</span>) <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">  x <span class="ot">&lt;-</span> die</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">  y <span class="ot">&lt;-</span> die</a>
<a class="sourceLine" id="cb6-10" data-line-number="10">  pure (x<span class="fu">+</span>y)</a>
<a class="sourceLine" id="cb6-11" data-line-number="11"><span class="dv">1</span> <span class="fu">%</span> <span class="dv">6</span></a></code></pre></div>
<h1 id="the-bells-and-whistles">The Bells and Whistles</h1>
<p>As elegant as the above approach is, it leaves something to be desired when it comes to efficiency. In particular, you‚Äôll see a combinatorial explosion at every step. To demonstrate, let‚Äôs take the example above, using three-sided dice instead so it doesn‚Äôt take up too much space.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1">die <span class="fu">=</span> uniform [<span class="dv">1</span><span class="fu">..</span><span class="dv">3</span>]</a>
<a class="sourceLine" id="cb7-2" data-line-number="2"></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">example <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">  x <span class="ot">&lt;-</span> die</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">  y <span class="ot">&lt;-</span> die</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">  pure (x<span class="fu">+</span>y)</a></code></pre></div>
<p>The probability table looks like this:</p>
<pre class="center"><code>2 1/9
3 2/9
4 1/3
5 2/9
6 1/9</code></pre>
<p>But the internal representation looks like this:</p>
<pre><code>2 1/9
3 1/9
4 1/9
3 1/9
4 1/9
5 1/9
4 1/9
5 1/9
6 1/9</code></pre>
<p>States are duplicated, because the implementation has no way of knowing that two outcomes are the same. We could collapse equivalent outcomes if we used a <code class="sourceCode haskell"><span class="dt">Map</span></code>, but then we can‚Äôt implement <code class="sourceCode haskell"><span class="dt">Functor</span></code>, <code class="sourceCode haskell"><span class="dt">Applicative</span></code>, or <code class="sourceCode haskell"><span class="dt">Monad</span></code>. The types:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="ot">    fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</a>
<a class="sourceLine" id="cb10-3" data-line-number="3"></a>
<a class="sourceLine" id="cb10-4" data-line-number="4"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Applicative</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-5" data-line-number="5"><span class="ot">    pure ::</span> a <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb10-6" data-line-number="6"><span class="ot">    (&lt;*&gt;) ::</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</a>
<a class="sourceLine" id="cb10-7" data-line-number="7"></a>
<a class="sourceLine" id="cb10-8" data-line-number="8"><span class="kw">class</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">Monad</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-9" data-line-number="9"><span class="ot">    (&gt;&gt;=) ::</span> f a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> f b</a></code></pre></div>
<p>Don‚Äôt allow an <code class="sourceCode haskell"><span class="dt">Ord</span></code> constraint, which is what we‚Äôd need to remove duplicates. We can instead make our own classes which <em>do</em> allow constraints:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">{-# LANGUAGE RebindableSyntax #-}</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2"><span class="ot">{-# LANGUAGE TypeFamilies     #-}</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3"></a>
<a class="sourceLine" id="cb11-4" data-line-number="4"><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (<span class="dt">Functor</span>(..),<span class="dt">Applicative</span>(..),<span class="dt">Monad</span>(..))</a>
<a class="sourceLine" id="cb11-5" data-line-number="5"></a>
<a class="sourceLine" id="cb11-6" data-line-number="6"><span class="kw">import</span> <span class="dt">Data.Kind</span></a>
<a class="sourceLine" id="cb11-7" data-line-number="7"></a>
<a class="sourceLine" id="cb11-8" data-line-number="8"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-9" data-line-number="9">    <span class="kw">type</span> <span class="dt">Domain</span> f<span class="ot"> a ::</span> <span class="dt">Constraint</span></a>
<a class="sourceLine" id="cb11-10" data-line-number="10">    <span class="kw">type</span> <span class="dt">Domain</span> f a <span class="fu">=</span> ()</a>
<a class="sourceLine" id="cb11-11" data-line-number="11"><span class="ot">    fmap ::</span> <span class="dt">Domain</span> f b <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</a>
<a class="sourceLine" id="cb11-12" data-line-number="12"></a>
<a class="sourceLine" id="cb11-13" data-line-number="13"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Applicative</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-14" data-line-number="14">    <span class="ot">{-# MINIMAL pure, liftA2 #-}</span></a>
<a class="sourceLine" id="cb11-15" data-line-number="15"><span class="ot">    pure   ::</span> <span class="dt">Domain</span> f a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb11-16" data-line-number="16"><span class="ot">    liftA2 ::</span> <span class="dt">Domain</span> f c <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f c</a>
<a class="sourceLine" id="cb11-17" data-line-number="17">    </a>
<a class="sourceLine" id="cb11-18" data-line-number="18"><span class="ot">    (&lt;*&gt;) ::</span> <span class="dt">Domain</span> f b <span class="ot">=&gt;</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</a>
<a class="sourceLine" id="cb11-19" data-line-number="19">    (<span class="fu">&lt;*&gt;</span>) <span class="fu">=</span> liftA2 (<span class="fu">$</span>) </a>
<a class="sourceLine" id="cb11-20" data-line-number="20"></a>
<a class="sourceLine" id="cb11-21" data-line-number="21"><span class="kw">class</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">Monad</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-22" data-line-number="22"><span class="ot">    (&gt;&gt;=) ::</span> <span class="dt">Domain</span> f b <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> f b</a>
<a class="sourceLine" id="cb11-23" data-line-number="23"></a>
<a class="sourceLine" id="cb11-24" data-line-number="24">fail<span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb11-25" data-line-number="25">fail <span class="fu">=</span> error</a>
<a class="sourceLine" id="cb11-26" data-line-number="26"></a>
<a class="sourceLine" id="cb11-27" data-line-number="27">return<span class="ot"> ::</span> (<span class="dt">Applicative</span> f, <span class="dt">Domain</span> f a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb11-28" data-line-number="28">return <span class="fu">=</span> pure</a></code></pre></div>
<p>This setup gets over a couple common annoyances in Haskell, like making <a href="http://hackage.haskell.org/package/containers-0.6.0.1/docs/Data-Set.html"><code class="sourceCode haskell"><span class="dt">Data.Set</span></code></a> a Monad:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">    <span class="kw">type</span> <span class="dt">Domain</span> <span class="dt">Set</span> a <span class="fu">=</span> <span class="dt">Ord</span> a</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">    fmap <span class="fu">=</span> Set.map</a>
<a class="sourceLine" id="cb12-4" data-line-number="4"></a>
<a class="sourceLine" id="cb12-5" data-line-number="5"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-6" data-line-number="6">    pure <span class="fu">=</span> Set.singleton</a>
<a class="sourceLine" id="cb12-7" data-line-number="7">    liftA2 f xs ys <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb12-8" data-line-number="8">        x <span class="ot">&lt;-</span> xs</a>
<a class="sourceLine" id="cb12-9" data-line-number="9">        y <span class="ot">&lt;-</span> ys</a>
<a class="sourceLine" id="cb12-10" data-line-number="10">        pure (f x y)</a>
<a class="sourceLine" id="cb12-11" data-line-number="11"></a>
<a class="sourceLine" id="cb12-12" data-line-number="12"><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-13" data-line-number="13">    (<span class="fu">&gt;&gt;=</span>) <span class="fu">=</span> flip foldMap</a></code></pre></div>
<p>And, of course, the probability monad:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Prob</span> a <span class="fu">=</span> <span class="dt">Prob</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">    {<span class="ot"> runProb ::</span> <span class="dt">Map</span> a <span class="dt">Rational</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">    }</a>
<a class="sourceLine" id="cb13-4" data-line-number="4"></a>
<a class="sourceLine" id="cb13-5" data-line-number="5"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Prob</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-6" data-line-number="6">    <span class="kw">type</span> <span class="dt">Domain</span> <span class="dt">Prob</span> a <span class="fu">=</span> <span class="dt">Ord</span> a</a>
<a class="sourceLine" id="cb13-7" data-line-number="7">    fmap f <span class="fu">=</span> <span class="dt">Prob</span> <span class="fu">.</span> Map.mapKeysWith (<span class="fu">+</span>) f <span class="fu">.</span> runProb</a>
<a class="sourceLine" id="cb13-8" data-line-number="8"></a>
<a class="sourceLine" id="cb13-9" data-line-number="9"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Prob</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-10" data-line-number="10">    pure x <span class="fu">=</span> <span class="dt">Prob</span> (Map.singleton x <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb13-11" data-line-number="11">    liftA2 f xs ys <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb13-12" data-line-number="12">      x <span class="ot">&lt;-</span> xs</a>
<a class="sourceLine" id="cb13-13" data-line-number="13">      y <span class="ot">&lt;-</span> ys</a>
<a class="sourceLine" id="cb13-14" data-line-number="14">      pure (f x y)</a>
<a class="sourceLine" id="cb13-15" data-line-number="15">      </a>
<a class="sourceLine" id="cb13-16" data-line-number="16"><span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Prob</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-17" data-line-number="17">    mempty <span class="fu">=</span> <span class="dt">Prob</span> Map.empty</a>
<a class="sourceLine" id="cb13-18" data-line-number="18">    mappend (<span class="dt">Prob</span> xs) (<span class="dt">Prob</span> ys) <span class="fu">=</span> <span class="dt">Prob</span> (Map.unionWith (<span class="fu">+</span>) xs ys)</a>
<a class="sourceLine" id="cb13-19" data-line-number="19"></a>
<a class="sourceLine" id="cb13-20" data-line-number="20"><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Prob</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-21" data-line-number="21">    <span class="dt">Prob</span> xs <span class="fu">&gt;&gt;=</span> f</a>
<a class="sourceLine" id="cb13-22" data-line-number="22">        <span class="fu">=</span> Map.foldMapWithKey ((<span class="dt">Prob</span> <span class="fu">.</span>) <span class="fu">.</span> flip (Map.map <span class="fu">.</span> (<span class="fu">*</span>)) <span class="fu">.</span> runProb <span class="fu">.</span> f) xs</a>
<a class="sourceLine" id="cb13-23" data-line-number="23"></a>
<a class="sourceLine" id="cb13-24" data-line-number="24">support <span class="fu">=</span> Map.keys <span class="fu">.</span> runProb</a>
<a class="sourceLine" id="cb13-25" data-line-number="25"></a>
<a class="sourceLine" id="cb13-26" data-line-number="26">expect p <span class="fu">=</span> getSum <span class="fu">.</span> Map.foldMapWithKey (\k v <span class="ot">-&gt;</span> <span class="dt">Sum</span> (p k <span class="fu">*</span> v)) <span class="fu">.</span> runProb</a>
<a class="sourceLine" id="cb13-27" data-line-number="27"></a>
<a class="sourceLine" id="cb13-28" data-line-number="28">probOf p <span class="fu">=</span> expect (bool <span class="dv">0</span> <span class="dv">1</span> <span class="fu">.</span> p)</a>
<a class="sourceLine" id="cb13-29" data-line-number="29"></a>
<a class="sourceLine" id="cb13-30" data-line-number="30">uniform xs <span class="fu">=</span> <span class="dt">Prob</span> (Map.fromList [ (x,n) <span class="fu">|</span> x <span class="ot">&lt;-</span> xs ])</a>
<a class="sourceLine" id="cb13-31" data-line-number="31">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-32" data-line-number="32">    n <span class="fu">=</span> <span class="dv">1</span> <span class="fu">%</span> toEnum (length xs)</a>
<a class="sourceLine" id="cb13-33" data-line-number="33"></a>
<a class="sourceLine" id="cb13-34" data-line-number="34">ifThenElse <span class="dt">True</span> t _ <span class="fu">=</span> t</a>
<a class="sourceLine" id="cb13-35" data-line-number="35">ifThenElse <span class="dt">False</span> _ f <span class="fu">=</span> f</a>
<a class="sourceLine" id="cb13-36" data-line-number="36"></a>
<a class="sourceLine" id="cb13-37" data-line-number="37">die <span class="fu">=</span> uniform [<span class="dv">1</span><span class="fu">..</span><span class="dv">6</span>]</a>
<a class="sourceLine" id="cb13-38" data-line-number="38"></a>
<a class="sourceLine" id="cb13-39" data-line-number="39"><span class="fu">&gt;&gt;&gt;</span> probOf (<span class="dv">7</span><span class="fu">==</span>) <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb13-40" data-line-number="40">  x <span class="ot">&lt;-</span> die</a>
<a class="sourceLine" id="cb13-41" data-line-number="41">  y <span class="ot">&lt;-</span> die</a>
<a class="sourceLine" id="cb13-42" data-line-number="42">  pure (x <span class="fu">+</span> y)</a>
<a class="sourceLine" id="cb13-43" data-line-number="43"><span class="dv">1</span> <span class="fu">%</span> <span class="dv">6</span></a></code></pre></div>
<h1 id="free">Free</h1>
<p>Coming up with the right implementation all at once is quite difficult: luckily, there are more general techniques for designing DSLs that break the problem into smaller parts, which also give us some insight into the underlying composition of the probability monad.</p>
<p>The technique relies on an algebraic concept called ‚Äúfree objects‚Äù. A free object for some class is a minimal implementation of that class. The classic example is lists: they‚Äôre the free monoid. Monoid requires that you have an additive operation, an empty element, and that the additive operation be associative. Lists have all of these things: what makes them <em>free</em>, though, is that they have nothing else. For instance, the additive operation on lists (concatenation) isn‚Äôt commutative: if it was, they wouldn‚Äôt be the free monoid any more, because they satisfy an extra law that‚Äôs not in monoid.</p>
<p>For our case, we can use the free monad: this takes a functor and gives it a monad instance, in a way we know will satisfy all the laws. This encoding is used in several papers <span class="citation" data-cites="scibior_practical_2015 larsen_memory_2011">(≈öcibior, Ghahramani, and Gordon <a href="#ref-scibior_practical_2015">2015</a>; Larsen <a href="#ref-larsen_memory_2011">2011</a>)</span>.</p>
<p>The idea is to first figure out what primitive operation you need. We‚Äôll use weighted choice:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="ot">choose ::</span> <span class="dt">Prob</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span> <span class="ot">-&gt;</span> <span class="dt">Prob</span> a <span class="ot">-&gt;</span> <span class="dt">Prob</span> a</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">choose <span class="fu">=</span> <span class="fu">...</span></a></code></pre></div>
<p>Then you encode it as a functor:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Choose</span> a</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Choose</span> <span class="dt">Rational</span> a a</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">    <span class="kw">deriving</span> (<span class="dt">Functor</span>,<span class="dt">Foldable</span>)</a></code></pre></div>
<p>We‚Äôll say the left-hand-choice has chance <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>, and the right-hand <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>‚àí</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">1-p</annotation></semantics></math>. Then, you just wrap it in the free monad:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Prob</span> <span class="fu">=</span> <span class="dt">Free</span> <span class="dt">Choose</span></a></code></pre></div>
<p>And you already have a monad instance. Support comes from the <a href="http://hackage.haskell.org/package/base-4.11.1.0/docs/Data-Foldable.html#v:toList"><code class="sourceCode haskell"><span class="dt">Foldable</span></code></a> instance:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Data.Foldable</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2"></a>
<a class="sourceLine" id="cb17-3" data-line-number="3"><span class="ot">support ::</span> <span class="dt">Prob</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb17-4" data-line-number="4">support <span class="fu">=</span> toList</a></code></pre></div>
<p>Expectation is an ‚Äúinterpreter‚Äù for the DSL:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="ot">expect ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Rational</span>) <span class="ot">-&gt;</span> <span class="dt">Prob</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2">expect p <span class="fu">=</span> iter f <span class="fu">.</span> fmap p</a>
<a class="sourceLine" id="cb18-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-4" data-line-number="4">    f (<span class="dt">Choose</span> c l r) <span class="fu">=</span> l <span class="fu">*</span> c <span class="fu">+</span> r <span class="fu">*</span> (<span class="dv">1</span><span class="fu">-</span>c)</a></code></pre></div>
<p>For building up the tree, we can use Huffman‚Äôs algorithm:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="ot">fromList ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Rational</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Prob</span> a</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">fromList p <span class="fu">=</span> go <span class="fu">.</span> foldMap (\x <span class="ot">-&gt;</span> singleton (p x) (<span class="dt">Pure</span> x))</a>
<a class="sourceLine" id="cb19-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-4" data-line-number="4">    go xs <span class="fu">=</span> <span class="kw">case</span> minView xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb19-5" data-line-number="5">      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> error <span class="st">&quot;empty list&quot;</span></a>
<a class="sourceLine" id="cb19-6" data-line-number="6">      <span class="dt">Just</span> ((xp,x),ys) <span class="ot">-&gt;</span> <span class="kw">case</span> minView ys <span class="kw">of</span></a>
<a class="sourceLine" id="cb19-7" data-line-number="7">        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> x</a>
<a class="sourceLine" id="cb19-8" data-line-number="8">        <span class="dt">Just</span> ((yp,y),zs) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb19-9" data-line-number="9">          go (insertHeap (xp<span class="fu">+</span>yp) (<span class="dt">Free</span> (<span class="dt">Choose</span> (xp<span class="fu">/</span>(xp<span class="fu">+</span>yp)) x y)) zs)</a></code></pre></div>
<p>And finally, it gets the same notation as before:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1">uniform <span class="fu">=</span> fromList (const <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb20-2" data-line-number="2"></a>
<a class="sourceLine" id="cb20-3" data-line-number="3">die <span class="fu">=</span> uniform [<span class="dv">1</span><span class="fu">..</span><span class="dv">6</span>]</a>
<a class="sourceLine" id="cb20-4" data-line-number="4"></a>
<a class="sourceLine" id="cb20-5" data-line-number="5">probOf p <span class="fu">=</span> expect (bool <span class="dv">0</span> <span class="dv">1</span> <span class="fu">.</span> p)</a>
<a class="sourceLine" id="cb20-6" data-line-number="6"></a>
<a class="sourceLine" id="cb20-7" data-line-number="7"><span class="fu">&gt;&gt;&gt;</span> probOf (<span class="dv">7</span><span class="fu">==</span>) <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb20-8" data-line-number="8">  x <span class="ot">&lt;-</span> die</a>
<a class="sourceLine" id="cb20-9" data-line-number="9">  y <span class="ot">&lt;-</span> die</a>
<a class="sourceLine" id="cb20-10" data-line-number="10">  pure (x <span class="fu">+</span> y)</a>
<a class="sourceLine" id="cb20-11" data-line-number="11"><span class="dv">1</span> <span class="fu">%</span> <span class="dv">6</span></a></code></pre></div>
<p>One of the advantages of the free approach is that it‚Äôs easy to define multiple interpreters. We could, for instance, write an interpreter that constructs a diagram:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> drawTree ((,) <span class="fu">&lt;$&gt;</span> uniform <span class="st">&quot;abc&quot;</span> <span class="fu">&lt;*&gt;</span> uniform <span class="st">&quot;de&quot;</span>)</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">           ‚îå(<span class="ch">&#39;c&#39;</span>,<span class="ch">&#39;d&#39;</span>)</a>
<a class="sourceLine" id="cb21-3" data-line-number="3">     ‚îå<span class="dv">1</span> <span class="fu">%</span> 2‚î§</a>
<a class="sourceLine" id="cb21-4" data-line-number="4">     ‚îÇ     ‚îî(<span class="ch">&#39;c&#39;</span>,<span class="ch">&#39;e&#39;</span>)</a>
<a class="sourceLine" id="cb21-5" data-line-number="5"><span class="dv">1</span> <span class="fu">%</span> 3‚î§</a>
<a class="sourceLine" id="cb21-6" data-line-number="6">     ‚îÇ           ‚îå(<span class="ch">&#39;a&#39;</span>,<span class="ch">&#39;d&#39;</span>)</a>
<a class="sourceLine" id="cb21-7" data-line-number="7">     ‚îÇ     ‚îå<span class="dv">1</span> <span class="fu">%</span> 2‚î§</a>
<a class="sourceLine" id="cb21-8" data-line-number="8">     ‚îÇ     ‚îÇ     ‚îî(<span class="ch">&#39;a&#39;</span>,<span class="ch">&#39;e&#39;</span>)</a>
<a class="sourceLine" id="cb21-9" data-line-number="9">     ‚îî<span class="dv">1</span> <span class="fu">%</span> 2‚î§</a>
<a class="sourceLine" id="cb21-10" data-line-number="10">           ‚îÇ     ‚îå(<span class="ch">&#39;b&#39;</span>,<span class="ch">&#39;d&#39;</span>)</a>
<a class="sourceLine" id="cb21-11" data-line-number="11">           ‚îî<span class="dv">1</span> <span class="fu">%</span> 2‚î§</a>
<a class="sourceLine" id="cb21-12" data-line-number="12">                 ‚îî(<span class="ch">&#39;b&#39;</span>,<span class="ch">&#39;e&#39;</span>)</a></code></pre></div>
<h1 id="final">Final</h1>
<p>There‚Äôs a lot to be said about free objects in category theory, also. Specifically, they‚Äôre related to initial and terminal (also called final) objects. The encoding above is initial, the final encoding is simply <code class="sourceCode haskell"><span class="dt">Cont</span></code>:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Cont</span> r a <span class="fu">=</span> <span class="dt">Cont</span> {<span class="ot"> runCont ::</span> (a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r }</a>
<a class="sourceLine" id="cb22-2" data-line-number="2"></a>
<a class="sourceLine" id="cb22-3" data-line-number="3"><span class="kw">type</span> <span class="dt">Prob</span> <span class="fu">=</span> <span class="dt">Cont</span> <span class="dt">Rational</span></a></code></pre></div>
<p>Here, also, we get the monad instance for free. In contrast to previously, expect is free:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1">expect <span class="fu">=</span> flip runCont</a></code></pre></div>
<p>Support, though, isn‚Äôt possible.</p>
<p>This version is also called the Giry monad: there‚Äôs a deep and fascinating theory behind it, which I probably won‚Äôt be able to do justice to here. Check out Jared Tobin‚Äôs post <span class="citation" data-cites="tobin_implementing_2017">(<a href="#ref-tobin_implementing_2017">2017</a>)</span> for a good deep dive on it.</p>
<h1 id="cofree">Cofree</h1>
<p>The branching structure of the tree captures the semantics of the probability monad well, but it doesn‚Äôt give us much insight into the original implementation. The question is, how can we deconstruct this:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Prob</span> a</a>
<a class="sourceLine" id="cb24-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Prob</span></a>
<a class="sourceLine" id="cb24-3" data-line-number="3">    {<span class="ot"> runProb ::</span> [(a, <span class="dt">Rational</span>)]</a>
<a class="sourceLine" id="cb24-4" data-line-number="4">    }</a></code></pre></div>
<p>Eric Kidd <span class="citation" data-cites="kidd_build_2007">(<a href="#ref-kidd_build_2007">2007</a>)</span> pointed out that the monad is the composition of the writer and list monads:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Prob</span> <span class="fu">=</span> <span class="dt">WriterT</span> (<span class="dt">Product</span> <span class="dt">Rational</span>) []</a></code></pre></div>
<p>but that seems unsatisfying: in contrast to the tree-based version, we don‚Äôt encode any branching structure, we‚Äôre able to have empty distributions, and it has the combinatorial explosion problem.</p>
<p>Adding a weighting to nondeterminism is encapsulated more concretely by the <code class="sourceCode haskell"><span class="dt">ListT</span></code> transformer. It looks like this:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">ListT</span> m a</a>
<a class="sourceLine" id="cb26-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">ListT</span></a>
<a class="sourceLine" id="cb26-3" data-line-number="3">    {<span class="ot"> runListT ::</span> m (<span class="dt">Maybe</span> (a, <span class="dt">ListT</span> m a))</a>
<a class="sourceLine" id="cb26-4" data-line-number="4">    }</a></code></pre></div>
<p>It‚Äôs a cons-list, with an effect before every layer<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>.</p>
<p>While this can be used to give us the monad we need, I‚Äôve found that something more like this fits the abstraction better:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="kw">data</span> <span class="dt">ListT</span> m a</a>
<a class="sourceLine" id="cb27-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">ListT</span> a (m (<span class="dt">Maybe</span> (<span class="dt">ListT</span> m a)))</a></code></pre></div>
<p>It‚Äôs a nonempty list, with the first element exposed. Turns out this is very similar to the cofree comonad:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Cofree</span> f a <span class="fu">=</span> a <span class="fu">:&lt;</span> f (<span class="dt">Cofree</span> f a)</a></code></pre></div>
<p>Just like the initial free encoding, we can start with a primitive operation:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Perhaps</span> a</a>
<a class="sourceLine" id="cb29-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Impossible</span></a>
<a class="sourceLine" id="cb29-3" data-line-number="3">    <span class="fu">|</span> <span class="dt">WithChance</span> <span class="dt">Rational</span> a</a>
<a class="sourceLine" id="cb29-4" data-line-number="4">    <span class="kw">deriving</span> (<span class="dt">Functor</span>,<span class="dt">Foldable</span>)</a></code></pre></div>
<p>And we get all of our instances as well:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Prob</span> a</a>
<a class="sourceLine" id="cb30-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Prob</span></a>
<a class="sourceLine" id="cb30-3" data-line-number="3">    {<span class="ot"> runProb ::</span> <span class="dt">Cofree</span> <span class="dt">Perhaps</span> a</a>
<a class="sourceLine" id="cb30-4" data-line-number="4">    } <span class="kw">deriving</span> (<span class="dt">Functor</span>,<span class="dt">Foldable</span>)</a>
<a class="sourceLine" id="cb30-5" data-line-number="5">    </a>
<a class="sourceLine" id="cb30-6" data-line-number="6"><span class="kw">instance</span> <span class="dt">Comonad</span> <span class="dt">Prob</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-7" data-line-number="7">    extract (<span class="dt">Prob</span> xs) <span class="fu">=</span> extract xs</a>
<a class="sourceLine" id="cb30-8" data-line-number="8">    duplicate (<span class="dt">Prob</span> xs) <span class="fu">=</span> <span class="dt">Prob</span> (fmap <span class="dt">Prob</span> (duplicate xs))</a>
<a class="sourceLine" id="cb30-9" data-line-number="9"></a>
<a class="sourceLine" id="cb30-10" data-line-number="10"><span class="ot">foldProb ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Rational</span> <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Prob</span> a <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb30-11" data-line-number="11">foldProb f b <span class="fu">=</span> r <span class="fu">.</span> runProb</a>
<a class="sourceLine" id="cb30-12" data-line-number="12">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-13" data-line-number="13">    r (x <span class="fu">:&lt;</span> <span class="dt">Impossible</span>) <span class="fu">=</span> b x</a>
<a class="sourceLine" id="cb30-14" data-line-number="14">    r (x <span class="fu">:&lt;</span> <span class="dt">WithChance</span> p xs) <span class="fu">=</span> f x p (r xs)</a>
<a class="sourceLine" id="cb30-15" data-line-number="15"></a>
<a class="sourceLine" id="cb30-16" data-line-number="16"><span class="ot">uniform ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Prob</span> a</a>
<a class="sourceLine" id="cb30-17" data-line-number="17">uniform (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="dt">Prob</span> (coiterW f (<span class="dt">EnvT</span> (length xs) (x <span class="fu">:|</span> xs)))</a>
<a class="sourceLine" id="cb30-18" data-line-number="18">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-19" data-line-number="19">    f (<span class="dt">EnvT</span> <span class="dv">0</span> (_ <span class="fu">:|</span> [])) <span class="fu">=</span> <span class="dt">Impossible</span></a>
<a class="sourceLine" id="cb30-20" data-line-number="20">    f (<span class="dt">EnvT</span> n (_ <span class="fu">:|</span> (y<span class="fu">:</span>ys))) </a>
<a class="sourceLine" id="cb30-21" data-line-number="21">        <span class="fu">=</span> <span class="dt">WithChance</span> (<span class="dv">1</span> <span class="fu">%</span> fromIntegral n) (<span class="dt">EnvT</span> (n <span class="fu">-</span> <span class="dv">1</span>) (y<span class="fu">:|</span>ys))</a>
<a class="sourceLine" id="cb30-22" data-line-number="22"></a>
<a class="sourceLine" id="cb30-23" data-line-number="23"><span class="ot">expect ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Rational</span>) <span class="ot">-&gt;</span> <span class="dt">Prob</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span></a>
<a class="sourceLine" id="cb30-24" data-line-number="24">expect p <span class="fu">=</span> foldProb f p</a>
<a class="sourceLine" id="cb30-25" data-line-number="25">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-26" data-line-number="26">    f x n xs <span class="fu">=</span> (p x <span class="fu">*</span> n <span class="fu">+</span> xs) <span class="fu">/</span> (n <span class="fu">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb30-27" data-line-number="27"></a>
<a class="sourceLine" id="cb30-28" data-line-number="28"><span class="ot">probOf ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Prob</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span></a>
<a class="sourceLine" id="cb30-29" data-line-number="29">probOf p <span class="fu">=</span> expect (\x <span class="ot">-&gt;</span> <span class="kw">if</span> p x <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb30-30" data-line-number="30"></a>
<a class="sourceLine" id="cb30-31" data-line-number="31"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Prob</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-32" data-line-number="32">    pure x <span class="fu">=</span> <span class="dt">Prob</span> (x <span class="fu">:&lt;</span> <span class="dt">Impossible</span>)</a>
<a class="sourceLine" id="cb30-33" data-line-number="33">    (<span class="fu">&lt;*&gt;</span>) <span class="fu">=</span> ap</a>
<a class="sourceLine" id="cb30-34" data-line-number="34">    </a>
<a class="sourceLine" id="cb30-35" data-line-number="35"><span class="ot">append ::</span> <span class="dt">Prob</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span> <span class="ot">-&gt;</span> <span class="dt">Prob</span> a <span class="ot">-&gt;</span> <span class="dt">Prob</span> a</a>
<a class="sourceLine" id="cb30-36" data-line-number="36">append <span class="fu">=</span> foldProb f (\x y <span class="ot">-&gt;</span>  <span class="dt">Prob</span> <span class="fu">.</span> (x <span class="fu">:&lt;</span>) <span class="fu">.</span> <span class="dt">WithChance</span> y <span class="fu">.</span> runProb)</a>
<a class="sourceLine" id="cb30-37" data-line-number="37">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-38" data-line-number="38">    f e r a p <span class="fu">=</span> <span class="dt">Prob</span> <span class="fu">.</span> (e <span class="fu">:&lt;</span>) <span class="fu">.</span> <span class="dt">WithChance</span> ip <span class="fu">.</span> runProb <span class="fu">.</span> a op</a>
<a class="sourceLine" id="cb30-39" data-line-number="39">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-40" data-line-number="40">        ip <span class="fu">=</span> p <span class="fu">*</span> r <span class="fu">/</span> (p <span class="fu">+</span> r <span class="fu">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb30-41" data-line-number="41">        op <span class="fu">=</span> p <span class="fu">/</span> (r <span class="fu">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb30-42" data-line-number="42"></a>
<a class="sourceLine" id="cb30-43" data-line-number="43"><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Prob</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-44" data-line-number="44">    xs <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> foldProb (append <span class="fu">.</span> f) f xs</a></code></pre></div>
<p>We see here that we‚Äôre talking about gambling-style odds, rather than probability. I wonder if the two representations are dual somehow?</p>
<p>The application of comonads to streams (<code class="sourceCode haskell"><span class="dt">ListT</span></code>) has been explored before <span class="citation" data-cites="uustalu_essence_2005">(Uustalu and Vene <a href="#ref-uustalu_essence_2005">2005</a>)</span>; I wonder if there are any insights to be gleaned from this particular probability comonad.</p>
<h1 id="references" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-erwig_functional_2006">
<p>Erwig, Martin, and Steve Kollmansberger. 2006. ‚ÄúFunctional pearls: Probabilistic functional programming in Haskell.‚Äù <em>Journal of Functional Programming</em> 16 (1): 21‚Äì34. doi:<a href="https://doi.org/10.1017/S0956796805005721">10.1017/S0956796805005721</a>.</p>
</div>
<div id="ref-kidd_build_2007">
<p>Kidd, Eric. 2007. ‚ÄúBuild your own probability monads.‚Äù</p>
</div>
<div id="ref-larsen_memory_2011">
<p>Larsen, Ken Friis. 2011. ‚ÄúMemory Efficient Implementation of Probability Monads.‚Äù</p>
</div>
<div id="ref-scibior_practical_2015">
<p>≈öcibior, Adam, Zoubin Ghahramani, and Andrew D. Gordon. 2015. ‚ÄúPractical Probabilistic Programming with Monads.‚Äù In <em>Proceedings of the 2015 ACM SIGPLAN Symposium on Haskell</em>, 50:165‚Äì176. Haskell ‚Äô15. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/2804302.2804317">10.1145/2804302.2804317</a>.</p>
</div>
<div id="ref-tobin_implementing_2017">
<p>Tobin, Jared. 2017. ‚ÄúImplementing the Giry Monad.‚Äù <em>jtobin.io</em>.</p>
</div>
<div id="ref-uustalu_essence_2005">
<p>Uustalu, Tarmo, and Varmo Vene. 2005. ‚ÄúThe Essence of Dataflow Programming.‚Äù In <em>Proceedings of the Third Asian Conference on Programming Languages and Systems</em>, 2‚Äì18. APLAS‚Äô05. Berlin, Heidelberg: Springer-Verlag. doi:<a href="https://doi.org/10.1007/11575467_2">10.1007/11575467_2</a>.</p>
</div>
</div>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Note this is <em>not</em> the same as the <code class="sourceCode haskell"><span class="dt">ListT</span></code> in <a href="http://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-List.html">transformers</a>; instead it‚Äôs a ‚Äú<a href="https://wiki.haskell.org/ListT_done_right">ListT done right</a>‚Äù.<a href="#fnref1" class="footnote-back">‚Ü©</a></p></li>
</ol>
</section>
]]></description>
    <pubDate>Sat, 30 Jun 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-06-30-probability-5-ways.html</guid>
    <dc:creator>Donnacha Ois√≠n Kidney</dc:creator>
</item>
<item>
    <title>Scheduling Effects</title>
    <link>https://doisinkidney.com/posts/2018-06-23-scheduling-effects.html</link>
    <description><![CDATA[<div class="info">
    Posted on June 23, 2018
</div>
<div class="info">
    
        Part 4 of a <a href="/series/Breadth-First%20Traversals.html">5-part series on Breadth-First Traversals</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<p>After the <a href="2018-06-03-breadth-first-traversals-in-too-much-detail.html">last post</a>, Noah Easterly pointed me to their <a href="https://hackage.haskell.org/package/tree-traversals">tree-traversals library</a>, and in particular the <a href="https://hackage.haskell.org/package/tree-traversals-0.1.0.0/docs/Control-Applicative-Phases.html#t:Phases"><code class="sourceCode haskell"><span class="dt">Phases</span></code></a> applicative transformer. It allows you to batch applicative effects to be run together: for the breadth-first traversal, we can batch the effects from each level together, giving us a lovely short solution to the problem.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1">breadthFirst c <span class="fu">=</span> runPhasesForwards <span class="fu">.</span> go</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">    go (x<span class="fu">:&lt;</span>xs) <span class="fu">=</span> liftA2 (<span class="fu">:&lt;</span>) (now (c x)) (delay (traverse go xs))</a></code></pre></div>
<p>In my efforts to speed this implementation up, I came across a wide and interesting literature on scheduling effects, which I‚Äôll go through a little here.</p>
<h1 id="coroutines">Coroutines</h1>
<p>The first thing that jumps to mind, for me, when I think of ‚Äúscheduling‚Äù is coroutines. These are constructs that let you finely control the order of execution of effects. They‚Äôre well explored in Haskell by now, and most libraries will let you do something like the following:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1">oneThenTwo <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  liftIO <span class="fu">$</span> print <span class="dv">1</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  delay <span class="fu">$</span> liftIO <span class="fu">$</span> print <span class="dv">2</span></a></code></pre></div>
<p>We first print <code>1</code>, then, after a delay, we print <code>2</code>. The <code class="sourceCode haskell">delay</code> doesn‚Äôt make a difference if we just run the whole thing:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> retract oneThenTwo</a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="dv">1</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="dv">2</span></a></code></pre></div>
<p>But you can see its effect when we use the <code class="sourceCode haskell">interleave</code> combinator:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> retract <span class="fu">$</span> interleave (replicate <span class="dv">3</span> oneThenTwo)</a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="dv">1</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="dv">1</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="dv">1</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="dv">2</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6"><span class="dv">2</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7"><span class="dv">2</span></a></code></pre></div>
<p>Hopefully you can see how useful this might be, and the similarity to the <code class="sourceCode haskell"><span class="dt">Phases</span></code> construction.</p>
<p>The genealogy of most coroutine libraries in Haskell seems to trace back to <span class="citation" data-cites="blazevic_coroutine_2011">Bla≈æeviƒá (<a href="#ref-blazevic_coroutine_2011">2011</a>)</span> or <span class="citation" data-cites="kiselyov_iteratees_2012">Kiselyov (<a href="#ref-kiselyov_iteratees_2012">2012</a>)</span>: the implementation I have been using in these past few examples (<a href="http://hackage.haskell.org/package/free-5.0.2/docs/Control-Monad-Trans-Iter.html"><code>IterT</code></a>) comes from a slightly different place. Let‚Äôs take a quick detour to explore it a little.</p>
<h1 id="partiality">Partiality</h1>
<p>In functional programming, there are several constructions for modeling error-like states: <code class="sourceCode haskell"><span class="dt">Maybe</span></code> for your nulls, <code class="sourceCode haskell"><span class="dt">Either</span></code> for your exceptions. What separates these approaches from the ‚Äúunsafe‚Äù variants (null pointers, unchecked exceptions) is that we can <em>prove</em>, in the type system, that the error case is handled correctly.</p>
<p>Conspicuously absent from the usual toolbox for modeling partiality is a way to model <em>nontermination</em>. At first glance, it may seem strange to attempt to do so in Haskell. After all, if I have a function of type:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a></code></pre></div>
<p>I can prove that I won‚Äôt throw any errors (with <code class="sourceCode haskell"><span class="dt">Either</span></code>, that is), because the type <code class="sourceCode haskell"><span class="dt">Int</span></code> doesn‚Äôt contain <code class="sourceCode haskell"><span class="dt">Left</span> _</code>. I‚Äôve also proved, miraculously, that I won‚Äôt make any null dereferences, because <code class="sourceCode haskell"><span class="dt">Int</span></code> also doesn‚Äôt contain <code class="sourceCode haskell"><span class="dt">Nothing</span></code>. I <em>haven‚Äôt</em> proved, however, that I won‚Äôt loop infinitely, because (in Haskell), <code class="sourceCode haskell"><span class="dt">Int</span></code> absolutely <em>does</em> contain <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>‚ä•</mi><annotation encoding="application/x-tex">\bot</annotation></semantics></math>.</p>
<p>So we‚Äôre somewhat scuppered. On the other hand, While we can‚Äôt <em>prove</em> termination in Haskell, we can:</p>
<ol>
<li>Model it.</li>
<li>Prove it in something else.</li>
</ol>
<p>Which is exactly what Venanzio Capretta did in the fascinating (and quite accessible) talk ‚ÄúPartiality is an effect‚Äù <span class="citation" data-cites="capretta_partiality_2004">(Capretta, Altenkirch, and Uustalu <a href="#ref-capretta_partiality_2004">2004</a>)</span><a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>.</p>
<p>The monad in question looks like this:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode idris"><code class="sourceCode idris"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Iter</span> a</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Now</span> a</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">    <span class="fu">|</span> <span class="dt">Later</span> (<span class="dt">Inf</span> (<span class="dt">Iter</span> a))</a></code></pre></div>
<p>We‚Äôre writing in Idris for the time being, so that we can prove termination and so on. The ‚Äúrecursive call‚Äù to <code class="sourceCode haskell"><span class="dt">Iter</span></code> is guarded by the <code class="sourceCode haskell"><span class="dt">Inf</span></code> type: this turns on a different kind of totality checking in the compiler. Usually, Idris will prevent you from constructing infinite values. But that‚Äôs exactly what we want to do here. Take the little-known function <a href="http://hackage.haskell.org/package/base-4.11.1.0/docs/Prelude.html#v:until"><code class="sourceCode haskell">until</code></a>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1">until<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a></code></pre></div>
<p>It‚Äôs clearly not necessarily total, and the totality checker will complain as such when we try and implement it directly:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode idris"><code class="sourceCode idris"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="fu">until</span> <span class="ot">:</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">until p f x <span class="fu">=</span> <span class="kw">if</span> p x <span class="kw">then</span> x <span class="kw">else</span> until p f (f x)</a></code></pre></div>
<p>But we can use <code class="sourceCode haskell"><span class="dt">Iter</span></code> to model that possible totality:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode idris"><code class="sourceCode idris"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="fu">until</span> <span class="ot">:</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Iter</span> a</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">until p f x <span class="fu">=</span> <span class="kw">if</span> p x <span class="kw">then</span> <span class="dt">Now</span> x <span class="kw">else</span> <span class="dt">Later</span> (until p f (f x))</a></code></pre></div>
<p>Of course, nothing‚Äôs for free: when we get the ability to construct infinite values, we lose the ability to consume them.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode idris"><code class="sourceCode idris"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="fu">run</span> <span class="ot">:</span> <span class="dt">Iter</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">run (<span class="dt">Now</span> x) <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">run (<span class="dt">Later</span> x) <span class="fu">=</span> run x</a></code></pre></div>
<p>We get an error on the <code class="sourceCode haskell">run</code> function. However, as you would expect, we can run <em>guarded</em> iteration: iteration up until some finite point.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode idris"><code class="sourceCode idris"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="fu">runUntil</span> <span class="ot">:</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Iter</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">runUntil <span class="dt">Z</span> <span class="fu">_</span> <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">runUntil (<span class="dt">S</span> n) (<span class="dt">Now</span> x) <span class="fu">=</span> <span class="dt">Just</span> x</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">runUntil (<span class="dt">S</span> n) (<span class="dt">Later</span> x) <span class="fu">=</span> runUntil n x</a></code></pre></div>
<p>Making our way back to Haskell, we must first‚Äîas is the law‚Äîadd a type parameter, and upgrade our humble monad to a monad transformer:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">IterT</span> m a <span class="fu">=</span> <span class="dt">IterT</span> {<span class="ot"> runIterT ::</span> m (<span class="dt">Either</span> a (<span class="dt">IterT</span> m a)) }</a>
<a class="sourceLine" id="cb12-2" data-line-number="2"></a>
<a class="sourceLine" id="cb12-3" data-line-number="3"><span class="kw">type</span> <span class="dt">Iter</span> <span class="fu">=</span> <span class="dt">IterT</span> <span class="dt">Identity</span></a></code></pre></div>
<p>The semantic meaning of the extra <code class="sourceCode haskell">m</code> here is interesting: each layer adds not just a recursive step, or a single iteration, but a single effect. Interpreting things in this way gets us back to the original goal:</p>
<h1 id="scheduling">Scheduling</h1>
<p>The <code class="sourceCode haskell"><span class="dt">Later</span></code> constructor above can be translated to a <code class="sourceCode haskell">delay</code> function on the transformer:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1">delay <span class="fu">=</span> <span class="dt">IterT</span> <span class="fu">.</span> pure <span class="fu">.</span> <span class="dt">Right</span></a></code></pre></div>
<p>And using this again, we can write the following incredibly short definition for <code class="sourceCode haskell">unfoldTreeM_BF</code>:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="ot">unfoldTreeM_BF ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (b <span class="ot">-&gt;</span> m (a, [b])) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> m (<span class="dt">Tree</span> a)</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">unfoldTreeM_BF f <span class="fu">=</span> retract <span class="fu">.</span> go</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-4" data-line-number="4">    go b <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb14-5" data-line-number="5">      (x,xs) <span class="ot">&lt;-</span> lift (f b)</a>
<a class="sourceLine" id="cb14-6" data-line-number="6">      fmap (<span class="dt">Node</span> x) (interleave (map (delay <span class="fu">.</span> go) xs))</a></code></pre></div>
<h1 id="applicative">Applicative</h1>
<p>It would be nice to bring this back to traversals, but alas, <code class="sourceCode haskell"><span class="dt">IterT</span></code> is pretty monad-centric. What‚Äôs more, if it‚Äôs analogous to <code class="sourceCode haskell"><span class="dt">Phases</span></code> it certainly doesn‚Äôt look like it:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Phases</span> f a <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2">  <span class="dt">Lift</span><span class="ot"> ::</span> f a <span class="ot">-&gt;</span> <span class="dt">Phases</span> f a</a>
<a class="sourceLine" id="cb15-3" data-line-number="3"><span class="ot">  (:&lt;*&gt;) ::</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Phases</span> f a <span class="ot">-&gt;</span> <span class="dt">Phases</span> f b</a></code></pre></div>
<p>However, in the documentation for <a href="http://hackage.haskell.org/package/free-5.0.2/docs/Control-Monad-Trans-Iter.html#t:IterT"><code class="sourceCode haskell"><span class="dt">IterT</span></code></a>, there‚Äôs the following little note:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="dt">IterT</span> <span class="fu">~</span> <span class="dt">FreeT</span> <span class="dt">Identity</span></a></code></pre></div>
<p>Where <code class="sourceCode haskell"><span class="dt">FreeT</span></code> is the <a href="http://hackage.haskell.org/package/free-5.0.2/docs/Control-Monad-Trans-Free.html">free monad transformer</a>. This seems to strongly hint that we could get the same thing for applicatives with <a href="http://hackage.haskell.org/package/free-5.0.2/docs/Control-Applicative-Trans-Free.html"><code class="sourceCode haskell"><span class="dt">ApT</span></code></a>. Let‚Äôs try it:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Phases</span> f a <span class="fu">=</span> <span class="dt">Phases</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2">    {<span class="ot"> runPhases ::</span> <span class="dt">ApT</span> <span class="dt">Identity</span> f a</a>
<a class="sourceLine" id="cb17-3" data-line-number="3">    } <span class="kw">deriving</span> <span class="dt">Functor</span></a></code></pre></div>
<p>The <code class="sourceCode haskell"><span class="dt">Applicative</span></code> instance is a little hairy, but it <em>seems</em> correct:</p>
<details>
<p><summary> Applicative Instance </summary></p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2">         <span class="dt">Applicative</span> (<span class="dt">Phases</span> f) <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3">    pure <span class="fu">=</span> <span class="dt">Phases</span> <span class="fu">.</span> pure</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">    liftA2 f&#39; (<span class="dt">Phases</span> (<span class="dt">ApT</span> xs&#39;)) (<span class="dt">Phases</span> (<span class="dt">ApT</span> ys&#39;)) <span class="fu">=</span></a>
<a class="sourceLine" id="cb18-5" data-line-number="5">        <span class="dt">Phases</span> (<span class="dt">ApT</span> (liftA2 (go f&#39;) xs&#39; ys&#39;))</a>
<a class="sourceLine" id="cb18-6" data-line-number="6">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-7" data-line-number="7">        go</a>
<a class="sourceLine" id="cb18-8" data-line-number="8"><span class="ot">            ::</span> <span class="ot">‚àÄ</span> a b c<span class="fu">.</span></a>
<a class="sourceLine" id="cb18-9" data-line-number="9">               (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c)</a>
<a class="sourceLine" id="cb18-10" data-line-number="10">            <span class="ot">-&gt;</span> <span class="dt">ApF</span> <span class="dt">Identity</span> f a</a>
<a class="sourceLine" id="cb18-11" data-line-number="11">            <span class="ot">-&gt;</span> <span class="dt">ApF</span> <span class="dt">Identity</span> f b</a>
<a class="sourceLine" id="cb18-12" data-line-number="12">            <span class="ot">-&gt;</span> <span class="dt">ApF</span> <span class="dt">Identity</span> f c</a>
<a class="sourceLine" id="cb18-13" data-line-number="13">        go f (<span class="dt">Pure</span> x) ys <span class="fu">=</span> fmap (f x) ys</a>
<a class="sourceLine" id="cb18-14" data-line-number="14">        go f xs (<span class="dt">Pure</span> y) <span class="fu">=</span> fmap (<span class="ot">`f`</span> y) xs</a>
<a class="sourceLine" id="cb18-15" data-line-number="15">        go f (<span class="dt">Ap</span> x (<span class="dt">ApT</span> xs)) (<span class="dt">Ap</span> y (<span class="dt">ApT</span> ys)) <span class="fu">=</span></a>
<a class="sourceLine" id="cb18-16" data-line-number="16">            <span class="dt">Ap</span></a>
<a class="sourceLine" id="cb18-17" data-line-number="17">                (liftA2 (,) x y)</a>
<a class="sourceLine" id="cb18-18" data-line-number="18">                (<span class="dt">ApT</span> (liftA2 (go (\xx yy <span class="ot">-&gt;</span> uncurry f <span class="fu">.</span> (xx <span class="fu">***</span> yy))) xs ys))</a></code></pre></div>
</details>
<p>(on a side note: thank <em>goodness</em> for <code class="sourceCode haskell">liftA2</code> finally getting into <code class="sourceCode haskell"><span class="dt">Applicative</span></code>)</p>
<p>And we get all the normal combinators:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="ot">delay ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">Phases</span> f a <span class="ot">-&gt;</span> <span class="dt">Phases</span> f a</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">delay <span class="fu">=</span> <span class="dt">Phases</span> <span class="fu">.</span> <span class="dt">ApT</span> <span class="fu">.</span> pure <span class="fu">.</span> <span class="dt">Ap</span> (pure ()) <span class="fu">.</span> fmap const <span class="fu">.</span> runPhases</a>
<a class="sourceLine" id="cb19-3" data-line-number="3"></a>
<a class="sourceLine" id="cb19-4" data-line-number="4"><span class="ot">lift ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Phases</span> f a</a>
<a class="sourceLine" id="cb19-5" data-line-number="5">lift <span class="fu">=</span> <span class="dt">Phases</span> <span class="fu">.</span> liftApO</a></code></pre></div>
<p>The issue comes with running the thing at the end: <code class="sourceCode haskell"><span class="dt">Monad</span></code> creeps back in.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="ot">retract ::</span> <span class="dt">Monad</span> f <span class="ot">=&gt;</span> <span class="dt">Phases</span> f a <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb20-2" data-line-number="2">retract <span class="fu">=</span> fmap (runIdentity <span class="fu">.</span> retractAp) <span class="fu">.</span> joinApT <span class="fu">.</span> runPhases</a></code></pre></div>
<p>Because the effects are all layered on top of each other, you need to flatten them out at the end, which requires <code class="sourceCode haskell">join</code>. Mind you, it does work: it‚Äôs just not as general as it could be.</p>
<p>All‚Äôs not lost, though. Turns out, we never needed the transformer in the first place: we could just define the different applicative instance straight off.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Phases</span> f a <span class="fu">=</span> <span class="dt">Phases</span></a>
<a class="sourceLine" id="cb21-2" data-line-number="2">    {<span class="ot"> runPhases ::</span> <span class="dt">Ap</span> f a</a>
<a class="sourceLine" id="cb21-3" data-line-number="3">    } <span class="kw">deriving</span> <span class="dt">Functor</span></a>
<a class="sourceLine" id="cb21-4" data-line-number="4"></a>
<a class="sourceLine" id="cb21-5" data-line-number="5"><span class="kw">instance</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb21-6" data-line-number="6">         <span class="dt">Applicative</span> (<span class="dt">Phases</span> f) <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-7" data-line-number="7">    pure <span class="fu">=</span> <span class="dt">Phases</span> <span class="fu">.</span> <span class="dt">Pure</span></a>
<a class="sourceLine" id="cb21-8" data-line-number="8">    liftA2 f&#39; (<span class="dt">Phases</span> xs&#39;) (<span class="dt">Phases</span> ys&#39;) <span class="fu">=</span> <span class="dt">Phases</span> (go f&#39; xs&#39; ys&#39;)</a>
<a class="sourceLine" id="cb21-9" data-line-number="9">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-10" data-line-number="10"><span class="ot">        go ::</span> <span class="ot">‚àÄ</span> a b c<span class="fu">.</span></a>
<a class="sourceLine" id="cb21-11" data-line-number="11">              (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c)</a>
<a class="sourceLine" id="cb21-12" data-line-number="12">           <span class="ot">-&gt;</span> <span class="dt">Ap</span> f a</a>
<a class="sourceLine" id="cb21-13" data-line-number="13">           <span class="ot">-&gt;</span> <span class="dt">Ap</span> f b</a>
<a class="sourceLine" id="cb21-14" data-line-number="14">           <span class="ot">-&gt;</span> <span class="dt">Ap</span> f c</a>
<a class="sourceLine" id="cb21-15" data-line-number="15">        go f (<span class="dt">Pure</span> x) ys <span class="fu">=</span> fmap (f x) ys</a>
<a class="sourceLine" id="cb21-16" data-line-number="16">        go f xs (<span class="dt">Pure</span> y) <span class="fu">=</span> fmap (<span class="ot">`f`</span> y) xs</a>
<a class="sourceLine" id="cb21-17" data-line-number="17">        go f (<span class="dt">Ap</span> x xs) (<span class="dt">Ap</span> y ys) <span class="fu">=</span></a>
<a class="sourceLine" id="cb21-18" data-line-number="18">            <span class="dt">Ap</span></a>
<a class="sourceLine" id="cb21-19" data-line-number="19">                (liftA2 (,) x y)</a>
<a class="sourceLine" id="cb21-20" data-line-number="20">                (go (\xx yy <span class="ot">-&gt;</span> uncurry f <span class="fu">.</span> (xx <span class="fu">***</span> yy)) xs ys)</a>
<a class="sourceLine" id="cb21-21" data-line-number="21"></a>
<a class="sourceLine" id="cb21-22" data-line-number="22"><span class="ot">delay ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">Phases</span> f a <span class="ot">-&gt;</span> <span class="dt">Phases</span> f a</a>
<a class="sourceLine" id="cb21-23" data-line-number="23">delay <span class="fu">=</span> <span class="dt">Phases</span> <span class="fu">.</span> <span class="dt">Ap</span> (pure ()) <span class="fu">.</span> fmap const <span class="fu">.</span> runPhases</a>
<a class="sourceLine" id="cb21-24" data-line-number="24"></a>
<a class="sourceLine" id="cb21-25" data-line-number="25"><span class="ot">retract ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">Phases</span> f a <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb21-26" data-line-number="26">retract <span class="fu">=</span> retractAp <span class="fu">.</span> runPhases</a>
<a class="sourceLine" id="cb21-27" data-line-number="27"></a>
<a class="sourceLine" id="cb21-28" data-line-number="28"><span class="ot">lift ::</span> f a <span class="ot">-&gt;</span> <span class="dt">Phases</span> f a</a>
<a class="sourceLine" id="cb21-29" data-line-number="29">lift <span class="fu">=</span> <span class="dt">Phases</span> <span class="fu">.</span> liftAp</a></code></pre></div>
<h1 id="more-coroutines">More Coroutines</h1>
<p>In the wonderful article Coroutine Pipelines <span class="citation" data-cites="blazevic_coroutine_2011">(Bla≈æeviƒá <a href="#ref-blazevic_coroutine_2011">2011</a>)</span>, several different threads on coroutine-like constructions are unified. What I‚Äôve demonstrated above isn‚Äôt yet as powerful as what you might see in a full coroutine library: ideally, you‚Äôd want generators and sinks. As it turns out, when we look back at the note from <code class="sourceCode haskell"><span class="dt">IterT</span></code>:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="dt">IterT</span> <span class="fu">~</span> <span class="dt">FreeT</span> <span class="dt">Identity</span></a></code></pre></div>
<p>We can get both of those other constructs by swapping out <code class="sourceCode haskell"><span class="dt">Identity</span></code><a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="dt">Generator</span> a <span class="fu">=</span> <span class="dt">FreeT</span> ((,) a)</a>
<a class="sourceLine" id="cb23-2" data-line-number="2"><span class="dt">Sink</span> a <span class="fu">=</span> <span class="dt">FreeT</span> ((<span class="ot">-&gt;</span>) a)</a></code></pre></div>
<p>(<code class="sourceCode haskell"><span class="dt">Sink</span></code> is usually called an <code class="sourceCode haskell"><span class="dt">Iteratee</span></code>)</p>
<p>This is the fundamental abstraction that underlies things like the pipes library <span class="citation" data-cites="gonzalez_pipes_2018">(Gonzalez <a href="#ref-gonzalez_pipes_2018">2018</a>)</span>.</p>
<h1 id="interleaving">Interleaving</h1>
<p>The only missing part from the first coroutine example by now is <code class="sourceCode haskell">interleave</code>. In the free library, it has the following signature:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="ot">interleave ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> [<span class="dt">IterT</span> m a] <span class="ot">-&gt;</span> <span class="dt">IterT</span> m [a]</a></code></pre></div>
<p>But we should be able to spot that, really, it‚Äôs a traversal. And, as a traversal, it should rely on some underlying <code class="sourceCode haskell"><span class="dt">Applicative</span></code> instance. Let‚Äôs try and come up with one:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Parallel</span> m f a <span class="fu">=</span> <span class="dt">Parallel</span></a>
<a class="sourceLine" id="cb25-2" data-line-number="2">    {<span class="ot"> runParallel ::</span> <span class="dt">FreeT</span> m f a</a>
<a class="sourceLine" id="cb25-3" data-line-number="3">    }</a>
<a class="sourceLine" id="cb25-4" data-line-number="4"></a>
<a class="sourceLine" id="cb25-5" data-line-number="5"><span class="kw">instance</span> (<span class="dt">Functor</span> f, <span class="dt">Functor</span> m) <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb25-6" data-line-number="6">         <span class="dt">Functor</span> (<span class="dt">Parallel</span> m f) <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-7" data-line-number="7">    fmap f <span class="fu">=</span> <span class="dt">Parallel</span> <span class="fu">.</span> <span class="dt">FreeT</span> <span class="fu">.</span> fmap go <span class="fu">.</span> runFreeT <span class="fu">.</span> runParallel</a>
<a class="sourceLine" id="cb25-8" data-line-number="8">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-9" data-line-number="9">        go <span class="fu">=</span> bimap f (<span class="dt">FreeT</span> <span class="fu">.</span> fmap go <span class="fu">.</span> runFreeT)</a>
<a class="sourceLine" id="cb25-10" data-line-number="10"></a>
<a class="sourceLine" id="cb25-11" data-line-number="11"><span class="kw">instance</span> (<span class="dt">Applicative</span> f, <span class="dt">Applicative</span> m) <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb25-12" data-line-number="12">         <span class="dt">Applicative</span> (<span class="dt">Parallel</span> m f) <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-13" data-line-number="13">    pure <span class="fu">=</span> <span class="dt">Parallel</span> <span class="fu">.</span> <span class="dt">FreeT</span> <span class="fu">.</span> pure <span class="fu">.</span> <span class="dt">Pure</span></a>
<a class="sourceLine" id="cb25-14" data-line-number="14">    <span class="dt">Parallel</span> fs&#39; <span class="fu">&lt;*&gt;</span> <span class="dt">Parallel</span> xs&#39; <span class="fu">=</span> <span class="dt">Parallel</span> (unw fs&#39; xs&#39;)</a>
<a class="sourceLine" id="cb25-15" data-line-number="15">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-16" data-line-number="16">        unw (<span class="dt">FreeT</span> fs) (<span class="dt">FreeT</span> xs) <span class="fu">=</span> <span class="dt">FreeT</span> (liftA2 go fs xs)</a>
<a class="sourceLine" id="cb25-17" data-line-number="17">        go (<span class="dt">Pure</span> f) <span class="fu">=</span> bimap f (runParallel <span class="fu">.</span> fmap f <span class="fu">.</span> <span class="dt">Parallel</span>)</a>
<a class="sourceLine" id="cb25-18" data-line-number="18">        go (<span class="dt">Free</span> fs) <span class="fu">=</span> <span class="dt">Free</span> <span class="fu">.</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb25-19" data-line-number="19">            <span class="dt">Pure</span> x <span class="ot">-&gt;</span> fmap (runParallel <span class="fu">.</span> fmap (<span class="fu">$</span>x) <span class="fu">.</span> <span class="dt">Parallel</span>) fs</a>
<a class="sourceLine" id="cb25-20" data-line-number="20">            <span class="dt">Free</span> xs <span class="ot">-&gt;</span> liftA2 unw fs xs</a></code></pre></div>
<p>Now, interleave is just <code class="sourceCode haskell">sequenceA</code>!</p>
<h1 id="applicatives-again">Applicatives, Again</h1>
<p>So we can see that there‚Äôs a ‚Äúparallel‚Äù applicative for both the free monad and the free applicative. To try and understand this type a little better, we can leverage our intuition about a much simpler, more familiar setting: lists. There‚Äôs an interesting similarity between lists and the free monad: <code class="sourceCode haskell"><span class="dt">FreeT</span> ((,) a)</code>) looks a lot like ‚Äú<a href="https://wiki.haskell.org/ListT_done_right"><code class="sourceCode haskell"><span class="dt">ListT</span></code> done right</a>‚Äù (so much so, in fact, that most coroutine libraries provide their own version of it). More concretely, list also has a famous ‚Äúparallel‚Äù applicative: <a href="http://hackage.haskell.org/package/base-4.11.1.0/docs/Control-Applicative.html#t:ZipList"><code class="sourceCode haskell"><span class="dt">ZipList</span></code></a>!</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">ZipList</span> a</a>
<a class="sourceLine" id="cb26-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">ZipList</span> </a>
<a class="sourceLine" id="cb26-3" data-line-number="3">    {<span class="ot"> getZipList ::</span> [a]</a>
<a class="sourceLine" id="cb26-4" data-line-number="4">    } <span class="kw">deriving</span> <span class="dt">Functor</span></a>
<a class="sourceLine" id="cb26-5" data-line-number="5"></a>
<a class="sourceLine" id="cb26-6" data-line-number="6"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">ZipList</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb26-7" data-line-number="7">  pure <span class="fu">=</span> <span class="dt">ZipList</span> <span class="fu">.</span> repeat</a>
<a class="sourceLine" id="cb26-8" data-line-number="8">  liftA2 f (<span class="dt">ZipList</span> xs) (<span class="dt">ZipList</span> ys) <span class="fu">=</span> <span class="dt">ZipList</span> (zipWith f xs ys)</a></code></pre></div>
<p>We‚Äôll use some of our knowledge about <code class="sourceCode haskell"><span class="dt">ZipList</span></code> to help us in the next section.</p>
<h1 id="timekeeping">Timekeeping</h1>
<p>We‚Äôve seen that efforts to model both coroutines and partiality end up in the same neighborhood: there‚Äôs yet another way to get there, which seems (at first) almost the opposite of the second. It starts with a blog post from Conor McBride <span class="citation" data-cites="mcbride_time_2009">(<a href="#ref-mcbride_time_2009">2009</a>)</span> called ‚ÄúTime flies like an applicative functor‚Äù. Curiously, here too breadth-first labeling is the focus. Remember first the lovely circular solution from <span class="citation" data-cites="jones_linear-time_1993-1">(<span class="citeproc-not-found" data-reference-id="jones_linear-time_1993-1"><strong>???</strong></span>)</span>:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a <span class="fu">=</span> <span class="dt">Leaf</span> <span class="fu">|</span> <span class="dt">Node</span> a (<span class="dt">Tree</span> a) (<span class="dt">Tree</span> a)</a>
<a class="sourceLine" id="cb27-2" data-line-number="2"></a>
<a class="sourceLine" id="cb27-3" data-line-number="3"><span class="ot">relabel ::</span> <span class="dt">Tree</span> x <span class="ot">-&gt;</span> [[a]] <span class="ot">-&gt;</span> (<span class="dt">Tree</span> a, [[a]])</a>
<a class="sourceLine" id="cb27-4" data-line-number="4">relabel <span class="dt">Leaf</span> xss <span class="fu">=</span> (<span class="dt">Leaf</span>,xss)</a>
<a class="sourceLine" id="cb27-5" data-line-number="5">relabel (<span class="dt">Node</span> _ l r) ((x<span class="fu">:</span>xs)<span class="fu">:</span>xss0) <span class="fu">=</span></a>
<a class="sourceLine" id="cb27-6" data-line-number="6">  <span class="kw">let</span> (l&#39;,xss1) <span class="fu">=</span> relabel l xss0</a>
<a class="sourceLine" id="cb27-7" data-line-number="7">      (r&#39;,xss2) <span class="fu">=</span> relabel r xss1</a>
<a class="sourceLine" id="cb27-8" data-line-number="8">  <span class="kw">in</span> (<span class="dt">Node</span> x l&#39; r&#39;,xs<span class="fu">:</span>xss2)</a>
<a class="sourceLine" id="cb27-9" data-line-number="9">  </a>
<a class="sourceLine" id="cb27-10" data-line-number="10"><span class="ot">bflabel ::</span> <span class="dt">Tree</span> x <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb27-11" data-line-number="11">bflabel tr xs <span class="fu">=</span> u</a>
<a class="sourceLine" id="cb27-12" data-line-number="12">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb27-13" data-line-number="13">    (u,xss) <span class="fu">=</span> relabel tr (xs<span class="fu">:</span>xss)</a></code></pre></div>
<p>As lovely as it is, spare a thought for the poor totality checker: it‚Äôs hard to imagine how it would even <em>start</em> to show that something so lazy and circular would terminate. <code class="sourceCode haskell"><span class="dt">IterT</span></code> won‚Äôt help us here, either: it can help us express programs that <em>might</em> diverge, not weird-looking ones that definitely won‚Äôt.</p>
<p>The solution presented is a type (<code class="sourceCode haskell"><span class="dt">De</span></code>) which has a limited set of combinators: a fixpoint (<code class="sourceCode haskell"><span class="ot">fix ::</span> (<span class="dt">De</span> x <span class="ot">-&gt;</span> x) <span class="ot">-&gt;</span> x</code>), and an applicative instance. As long as all problematic recursive calls are instead expressed using those combinators, the termination checker should be satisfied.</p>
<p><code class="sourceCode haskell"><span class="dt">De</span></code> can be thought of as a ‚Äúdelay‚Äù wrapper. Values of type <code class="sourceCode haskell"><span class="dt">De</span> a</code> are one step in the future, <code class="sourceCode haskell"><span class="dt">De</span> (<span class="dt">De</span> a)</code> are two, and so on. This idea was later expanded upon in <span class="citation" data-cites="atkey_how_2011">Atkey (<a href="#ref-atkey_how_2011">2011</a>)</span> and <span class="citation" data-cites="atkey_productive_2013">Atkey and McBride (<a href="#ref-atkey_productive_2013">2013</a>)</span> to <em>clock variables</em>. Instead of types with a delay, types are tagged with how much more time they have (something like ‚Äúfuel‚Äù in the Idris sense, maybe). So a value of type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>a</mi><mstyle mathvariant="sans-serif"><mi>ùñ™</mi></mstyle></msup><annotation encoding="application/x-tex">a^\mathsf{K}</annotation></semantics></math> is tagged with time <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="sans-serif"><mi>ùñ™</mi></mstyle><annotation encoding="application/x-tex">\mathsf{K}</annotation></semantics></math>, effectively meaning ‚ÄúI have <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="sans-serif"><mi>ùñ™</mi></mstyle><annotation encoding="application/x-tex">\mathsf{K}</annotation></semantics></math> productive steps left before I diverge‚Äù. ‚ÄúProductive steps‚Äù will mean something different for every data type: for lists, it could mean that it can produce up until the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="sans-serif"><mi>ùñ™</mi></mstyle><annotation encoding="application/x-tex">\mathsf{K}</annotation></semantics></math>th cons-cell. In the paper <span class="citation" data-cites="atkey_productive_2013">(Atkey and McBride <a href="#ref-atkey_productive_2013">2013</a>)</span> this is fleshed out a little more, with fixpoint combinators and so on. As a concrete example, take the type of the cons operator on streams:</p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">Cons</mtext><mo>:</mo><mtext mathvariant="normal">a</mtext><mo>‚Üí</mo><msup><mtext mathvariant="normal">Stream a</mtext><mstyle mathvariant="sans-serif"><mi>ùñ™</mi></mstyle></msup><mo>‚Üí</mo><msup><mtext mathvariant="normal">Stream a</mtext><mrow><mstyle mathvariant="sans-serif"><mi>ùñ™</mi></mstyle><mo>+</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">\begin{equation}
\text{Cons} : \text{a}
\rightarrow \text{Stream a}^\mathsf{K}
\rightarrow \text{Stream a}^{\mathsf{K}+1}
\end{equation}</annotation></semantics></math>
<p>It increments the clock on the type, saying that it has one more productive step than it did before. This is kind of the opposite of a ‚Äúdelay‚Äù: previously, the scheduling types have meant ‚Äúthis is available <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="sans-serif"><mi>ùñ™</mi></mstyle><annotation encoding="application/x-tex">\mathsf{K}</annotation></semantics></math> number of steps in the future‚Äù rather than ‚Äúthis is available for another <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="sans-serif"><mi>ùñ™</mi></mstyle><annotation encoding="application/x-tex">\mathsf{K}</annotation></semantics></math> steps‚Äù. We can still describe delays in this system, though, using the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mo>‚ä≥</mo><mstyle mathvariant="sans-serif"><mi>ùñ™</mi></mstyle></msup><annotation encoding="application/x-tex">\rhd^\mathsf{K}</annotation></semantics></math> notation:</p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">Cons</mtext><mo>:</mo><mtext mathvariant="normal">a</mtext><mo>‚Üí</mo><mover><mo>‚ä≥</mo><mstyle mathvariant="sans-serif"><mi>ùñ™</mi></mstyle></mover><mtext mathvariant="normal">Stream a</mtext><mo>‚Üí</mo><mtext mathvariant="normal">Stream a</mtext></mrow><annotation encoding="application/x-tex">\begin{equation}
\text{Cons} : \text{a}
\rightarrow \rhd^\mathsf{K}\text{Stream a}
\rightarrow \text{Stream a}
\end{equation}</annotation></semantics></math>
<p>Let‚Äôs first try express some of this in the free monad:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1"><span class="kw">data</span> <span class="dt">K</span> <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">|</span> <span class="dt">S</span> <span class="dt">K</span></a>
<a class="sourceLine" id="cb28-2" data-line-number="2"></a>
<a class="sourceLine" id="cb28-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Delay</span><span class="ot"> ::</span> <span class="dt">K</span> <span class="ot">-&gt;</span> (<span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> (<span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb28-4" data-line-number="4">  <span class="dt">Now</span><span class="ot">   ::</span> a <span class="ot">-&gt;</span> <span class="dt">Delay</span> n f m a</a>
<a class="sourceLine" id="cb28-5" data-line-number="5">  <span class="dt">Later</span><span class="ot"> ::</span> f (<span class="dt">DelayT</span> n f m a) <span class="ot">-&gt;</span> <span class="dt">Delay</span> (<span class="dt">S</span> n) f m a</a>
<a class="sourceLine" id="cb28-6" data-line-number="6"></a>
<a class="sourceLine" id="cb28-7" data-line-number="7"><span class="kw">instance</span> (<span class="dt">Functor</span> f, <span class="dt">Functor</span> m) <span class="ot">=&gt;</span> <span class="dt">Functor</span> (<span class="dt">Delay</span> n f m) <span class="kw">where</span></a>
<a class="sourceLine" id="cb28-8" data-line-number="8">  fmap f (<span class="dt">Now</span> x) <span class="fu">=</span> <span class="dt">Now</span> (f x)</a>
<a class="sourceLine" id="cb28-9" data-line-number="9">  fmap f (<span class="dt">Later</span> xs) <span class="fu">=</span> <span class="dt">Later</span> (fmap (fmap f) xs)</a>
<a class="sourceLine" id="cb28-10" data-line-number="10"></a>
<a class="sourceLine" id="cb28-11" data-line-number="11"><span class="kw">newtype</span> <span class="dt">DelayT</span> n f m a <span class="fu">=</span> <span class="dt">DelayT</span> {<span class="ot"> runDelayT ::</span> m (<span class="dt">Delay</span> n f m a) }</a>
<a class="sourceLine" id="cb28-12" data-line-number="12"></a>
<a class="sourceLine" id="cb28-13" data-line-number="13"><span class="kw">instance</span> (<span class="dt">Functor</span> f, <span class="dt">Functor</span> m) <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb28-14" data-line-number="14">         <span class="dt">Functor</span> (<span class="dt">DelayT</span> n f m) <span class="kw">where</span></a>
<a class="sourceLine" id="cb28-15" data-line-number="15">    fmap f <span class="fu">=</span> <span class="dt">DelayT</span> <span class="fu">.</span> fmap (fmap f) <span class="fu">.</span> runDelayT</a></code></pre></div>
<p>We can straight away express one of the combinators from the paper, <code class="sourceCode haskell">force</code>:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" data-line-number="1"><span class="ot">force ::</span> <span class="dt">Functor</span> m <span class="ot">=&gt;</span> (<span class="ot">‚àÄ</span> k<span class="fu">.</span> <span class="dt">DelayT</span> k f m a) <span class="ot">-&gt;</span> m a</a>
<a class="sourceLine" id="cb29-2" data-line-number="2">force (<span class="dt">DelayT</span> xs) <span class="fu">=</span> fmap f xs</a>
<a class="sourceLine" id="cb29-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb29-4" data-line-number="4"><span class="ot">    f ::</span> <span class="dt">Delay</span> <span class="dt">Z</span> f m a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb29-5" data-line-number="5">    f (<span class="dt">Now</span> x) <span class="fu">=</span> x</a></code></pre></div>
<p>Similar trick to <a href="http://hackage.haskell.org/package/base-4.11.1.0/docs/Control-Monad-ST.html#v:runST"><code class="sourceCode haskell">runST</code></a> here: if the type is delayed however long we want it to be, then it mustn‚Äôt really be delayed at all.</p>
<p>Next, remember that we have types for streams (generators) from the <code class="sourceCode haskell"><span class="dt">IterT</span></code> monad:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Stream</span> n a <span class="fu">=</span> <span class="dt">DelayT</span> n ((,) a)</a></code></pre></div>
<p>And cons does indeed have the right type:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" data-line-number="1"><span class="ot">cons ::</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Stream</span> n a m b <span class="ot">-&gt;</span> <span class="dt">Stream</span> (<span class="dt">S</span> n) a m b</a>
<a class="sourceLine" id="cb31-2" data-line-number="2">cons x xs <span class="fu">=</span> <span class="dt">DelayT</span> (pure (<span class="dt">Later</span> (x,xs)))</a></code></pre></div>
<p>We also get an applicative:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" data-line-number="1"><span class="kw">instance</span> (<span class="dt">Applicative</span> f, <span class="dt">Applicative</span> m) <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb32-2" data-line-number="2">         <span class="dt">Applicative</span> (<span class="dt">DelayT</span> n f m) <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-3" data-line-number="3">    pure <span class="fu">=</span> <span class="dt">DelayT</span> <span class="fu">.</span> pure <span class="fu">.</span> <span class="dt">Now</span></a>
<a class="sourceLine" id="cb32-4" data-line-number="4">    <span class="dt">DelayT</span> fs&#39; <span class="fu">&lt;*&gt;</span> <span class="dt">DelayT</span> xs&#39; <span class="fu">=</span> <span class="dt">DelayT</span> (liftA2 go fs&#39; xs&#39;)</a>
<a class="sourceLine" id="cb32-5" data-line-number="5">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-6" data-line-number="6"><span class="ot">        go ::</span> <span class="ot">‚àÄ</span> k a b<span class="fu">.</span> <span class="dt">Delay</span> k f m (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Delay</span> k f m a <span class="ot">-&gt;</span> <span class="dt">Delay</span> k f m b</a>
<a class="sourceLine" id="cb32-7" data-line-number="7">        go (<span class="dt">Now</span> f) <span class="fu">=</span> fmap f</a>
<a class="sourceLine" id="cb32-8" data-line-number="8">        go (<span class="dt">Later</span> fs) <span class="fu">=</span> <span class="dt">Later</span> <span class="fu">.</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb32-9" data-line-number="9">            <span class="dt">Now</span> x <span class="ot">-&gt;</span> fmap (fmap (<span class="fu">$</span>x)) fs</a>
<a class="sourceLine" id="cb32-10" data-line-number="10">            <span class="dt">Later</span> xs <span class="ot">-&gt;</span> liftA2 (<span class="fu">&lt;*&gt;</span>) fs xs</a></code></pre></div>
<p>Now, I‚Äôm not sure how much this stuff actually corresponds to the paper, but what caught my eye is the statement that <code class="sourceCode haskell"><span class="dt">De</span></code> is a classic ‚Äúapplicative-not-monad‚Äù: just like <code class="sourceCode haskell"><span class="dt">ZipList</span></code>. However, under the analogy that the free monad is listy, and the parallel construction is ziplist-y, what we have in the <code class="sourceCode haskell"><span class="dt">DelayT</span></code> is the equivalent of a length-indexed list. These have an applicative instance similar to ziplists: but they also have a monad. Can we apply the same trick here?</p>
<h1 id="future-posts">Future Posts</h1>
<p>There‚Äôs a lot of fascinating stuff out there‚Äîabout clock variables, especially‚Äîthat I hope to get a chance to learn about once I get a chance. What I‚Äôm particularly interested to follow up on includes:</p>
<ol>
<li>Comonads and their relationship to these constructions. Streams are naturally expressed as comonads, could they be used as a basis on which to build a similar ‚Äúdelay‚Äù mechanism?</li>
<li>I‚Äôd love to explore more efficient implementations like the ones in <span class="citation" data-cites="spivey_faster_2017">Spivey (<a href="#ref-spivey_faster_2017">2017</a>)</span>.</li>
<li>I‚Äôm interested to see the relationship between these types, power series, and algebras for combinatorial search <span class="citation" data-cites="spivey_algebras_2009">(Spivey <a href="#ref-spivey_algebras_2009">2009</a>)</span>.</li>
</ol>
<h1 id="references" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-atkey_how_2011">
<p>Atkey, Robert. 2011. ‚ÄúHow to be a Productive Programmer - by putting things off until tomorrow.‚Äù Heriot-Watt University.</p>
</div>
<div id="ref-atkey_productive_2013">
<p>Atkey, Robert, and Conor McBride. 2013. ‚ÄúProductive coprogramming with guarded recursion.‚Äù In, 197. ACM Press. doi:<a href="https://doi.org/10.1145/2500365.2500597">10.1145/2500365.2500597</a>.</p>
</div>
<div id="ref-blazevic_coroutine_2011">
<p>Bla≈æeviƒá, Mario. 2011. ‚ÄúCoroutine Pipelines.‚Äù <em>The Monad.Reader</em> 19 (19) (August): 29‚Äì50.</p>
</div>
<div id="ref-capretta_partiality_2004">
<p>Capretta, Venanzio, Thorsten Altenkirch, and Tarmo Uustalu. 2004. ‚ÄúPartiality is an effect.‚Äù In <em>Dependently Typed Programming</em>, 04381:20. Dagstuhl Seminar Proceedings. Dagstuhl, Germany: Internationales Begegnungs- und Forschungszentrum f√ºr Informatik (IBFI), Schloss Dagstuhl, Germany.</p>
</div>
<div id="ref-gonzalez_pipes_2018">
<p>Gonzalez, Gabriel. 2018. ‚ÄúPipes: Compositional pipelines.‚Äù</p>
</div>
<div id="ref-kiselyov_iteratees_2012">
<p>Kiselyov, Oleg. 2012. ‚ÄúIteratees.‚Äù In <em>Proceedings of the 11th International Conference on Functional and Logic Programming</em>, 166‚Äì181. Lecture Notes in Computer Science. Berlin, Heidelberg: Springer, Berlin, Heidelberg. doi:<a href="https://doi.org/10.1007/978-3-642-29822-6_15">10.1007/978-3-642-29822-6_15</a>.</p>
</div>
<div id="ref-mcbride_time_2009">
<p>McBride, Conor. 2009. ‚ÄúTime flies like an applicative functor.‚Äù <em>Epilogue for Epigram</em>.</p>
</div>
<div id="ref-spivey_algebras_2009">
<p>Spivey, J. Michael. 2009. ‚ÄúAlgebras for combinatorial search.‚Äù <em>Journal of Functional Programming</em> 19 (3-4) (July): 469‚Äì487. doi:<a href="https://doi.org/10.1017/S0956796809007321">10.1017/S0956796809007321</a>.</p>
</div>
<div id="ref-spivey_faster_2017">
<p>Spivey, Michael. 2017. ‚ÄúFaster coroutine pipelines.‚Äù <em>Proceedings of the ACM on Programming Languages</em> 1 (ICFP) (August): 1‚Äì23. doi:<a href="https://doi.org/10.1145/3110249">10.1145/3110249</a>.</p>
</div>
</div>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>There is a later, seemingly more formal version of the talk available <span class="citation" data-cites="capretta_partiality_2005">(<span class="citeproc-not-found" data-reference-id="capretta_partiality_2005"><strong>???</strong></span>)</span>, but the one from 2004 was a little easier for me to understand, and had a lot more Haskell code.<a href="#fnref1" class="footnote-back">‚Ü©</a></p></li>
<li id="fn2"><p>Small note: <code>(,) a</code> and <code>(-&gt;) a</code> are adjunct. I wonder if there is any implication from this? Certainly, producers and consumers seem adjunct, but there‚Äôs no instance I can find for it in adjunctions.<a href="#fnref2" class="footnote-back">‚Ü©</a></p></li>
</ol>
</section>
]]></description>
    <pubDate>Sat, 23 Jun 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-06-23-scheduling-effects.html</guid>
    <dc:creator>Donnacha Ois√≠n Kidney</dc:creator>
</item>
<item>
    <title>Breadth-First Traversals in Far Too Much Detail</title>
    <link>https://doisinkidney.com/posts/2018-06-03-breadth-first-traversals-in-too-much-detail.html</link>
    <description><![CDATA[<div class="info">
    Posted on June  3, 2018
</div>
<div class="info">
    
        Part 3 of a <a href="/series/Breadth-First%20Traversals.html">5-part series on Breadth-First Traversals</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<p>After looking at the algorithms I <a href="2018-06-01-rose-trees-breadth-first-traversing.html">posted last time</a>, I noticed some patterns emerging which I thought deserved a slightly longer post. I‚Äôll go through the problem <span class="citation" data-cites="gibbons_breadth-first_2015">(Gibbons <a href="#ref-gibbons_breadth-first_2015">2015</a>)</span> in a little more detail, and present some more algorithms to go along with it.</p>
<h1 id="the-problem">The Problem</h1>
<p>The original question was posed by <a href="https://www.facebook.com/groups/programming.haskell/permalink/985981691412832/">Etian Chatav</a>:</p>
<blockquote>
<p>What is the correct way to write breadth first traversal of a <code class="sourceCode haskell">[<span class="dt">Tree</span>]</code>?</p>
</blockquote>
<p>The breadth-first traversal here is a traversal in the lensy sense, i.e:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">breadthFirst ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> [<span class="dt">Tree</span> a] <span class="ot">-&gt;</span> f [<span class="dt">Tree</span> b]</a></code></pre></div>
<p>The <code class="sourceCode haskell"><span class="dt">Tree</span></code> type we‚Äôre referring to here is a rose tree; we can take the one defined in <a href="http://hackage.haskell.org/package/containers-0.5.11.0/docs/Data-Tree.html#t:Tree"><code class="sourceCode haskell"><span class="dt">Data.Tree</span></code></a>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Node</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">    {<span class="ot"> rootLabel ::</span> a</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">    ,<span class="ot"> subForest ::</span> [<span class="dt">Tree</span> a]</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">    }</a></code></pre></div>
<p>Finally, instead of solving the (somewhat intermediate) problem of traversing a forest, we‚Äôll look directly at traversing the tree itself. In other words, our solution should have the type:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">breadthFirst ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> f (<span class="dt">Tree</span> b)</a></code></pre></div>
<h1 id="breadth-first-enumeration">Breadth-First Enumeration</h1>
<p>As in <span class="citation" data-cites="gibbons_breadth-first_2015">Gibbons (<a href="#ref-gibbons_breadth-first_2015">2015</a>)</span>, let‚Äôs first look at just converting the tree to a list in breadth-first order. In other words, given the tree:</p>
<pre><code>   ‚îå3
 ‚îå2‚î§
 ‚îÇ ‚îî4
1‚î§
 ‚îÇ ‚îå6
 ‚îî5‚î§
   ‚îî7</code></pre>
<p>We want the list:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1">[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">5</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">6</span>,<span class="dv">7</span>]</a></code></pre></div>
<p>Last time I looked at this problem, the function I arrived at was as follows:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">breadthFirstEnumerate ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">breadthFirstEnumerate ts <span class="fu">=</span> f ts b []</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">    f (<span class="dt">Node</span> x xs) fw bw <span class="fu">=</span> x <span class="fu">:</span> fw (xs <span class="fu">:</span> bw)</a>
<a class="sourceLine" id="cb6-5" data-line-number="5"></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">    b [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">    b qs <span class="fu">=</span> foldl (foldr f) b qs []</a></code></pre></div>
<p>It‚Äôs admittedly a little difficult to understand, but it‚Äôs really not too complex: we‚Äôre popping items off the front of a queue, and pushing the subforest onto the end. <code class="sourceCode haskell">fw</code> is the recursive call here: that‚Äôs where we send the queue with the element pushed on. Even though it may <em>look</em> like we‚Äôre pushing onto the front (as we‚Äôre using a cons), this is really the <em>end</em> of the queue, since it‚Äôs being consumed in reverse, with <code class="sourceCode haskell">foldl</code>.</p>
<p>We can compare it to the technique used in <span class="citation" data-cites="allison_circular_2006">Allison (<a href="#ref-allison_circular_2006">2006</a>)</span> and <span class="citation" data-cites="smith_lloyd_2009">Smith (<a href="#ref-smith_lloyd_2009">2009</a>)</span>, where it‚Äôs called <em>corecursive queues</em>. Breadth-first enumeration is accomplished as follows in <span class="citation" data-cites="smith_lloyd_2009">Smith (<a href="#ref-smith_lloyd_2009">2009</a>)</span>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">levelOrder ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">levelOrder tr <span class="fu">=</span> map rootLabel qs</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">    qs <span class="fu">=</span> enqs [tr] <span class="dv">0</span> qs</a>
<a class="sourceLine" id="cb7-5" data-line-number="5"></a>
<a class="sourceLine" id="cb7-6" data-line-number="6">    enqs []     n xs <span class="fu">=</span> deq n xs</a>
<a class="sourceLine" id="cb7-7" data-line-number="7">    enqs (t<span class="fu">:</span>ts) n xs <span class="fu">=</span> t <span class="fu">:</span> enqs  ts (n<span class="fu">+</span><span class="dv">1</span>) xs</a>
<a class="sourceLine" id="cb7-8" data-line-number="8"></a>
<a class="sourceLine" id="cb7-9" data-line-number="9">    deq <span class="dv">0</span> _      <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb7-10" data-line-number="10">    deq n (x<span class="fu">:</span>xs) <span class="fu">=</span> enqs (subForest x) (n<span class="fu">-</span><span class="dv">1</span>) xs</a></code></pre></div>
<p>We get to avoid tracking the length of the queue, however.</p>
<h1 id="level-order-enumeration">Level-Order Enumeration</h1>
<p>Before we go the full way to traversal, we can try add a little structure to our breadth-first enumeration, by delimiting between levels in the tree. We want our function to have the following type:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">levels ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [[a]]</a></code></pre></div>
<p>Looking back at our example tree:</p>
<pre><code>   ‚îå3
 ‚îå2‚î§
 ‚îÇ ‚îî4
1‚î§
 ‚îÇ ‚îå6
 ‚îî5‚î§
   ‚îî7</code></pre>
<p>We now want the list:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">[[<span class="dv">1</span>],[<span class="dv">2</span>,<span class="dv">5</span>],[<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">6</span>,<span class="dv">7</span>]]</a></code></pre></div>
<p>This function is strictly more powerful than <code class="sourceCode haskell">breadthFirstEnumerate</code>, as we can define one in terms of the other:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1">breadthFirstEnumerate <span class="fu">=</span> concat <span class="fu">.</span> levels</a></code></pre></div>
<p>It‚Äôs also just a generally useful function, so there are several example implementations available online.</p>
<h3 id="iterative-style">Iterative-Style</h3>
<p>The one provided in <a href="http://hackage.haskell.org/package/containers-0.5.11.0/docs/src/Data.Tree.html#levels">Data.Tree</a> is as follows:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1">levels t <span class="fu">=</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">    map (map rootLabel) <span class="fu">$</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">        takeWhile (not <span class="fu">.</span> null) <span class="fu">$</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">        iterate (concatMap subForest) [t]</a></code></pre></div>
<p>Pretty nice, but it looks to me like it‚Äôs doing a lot of redundant work. We could write it as an unfold:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1">levels t <span class="fu">=</span>  unfoldr (f <span class="fu">.</span> concat) [[t]]</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">    f [] <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4">    f xs <span class="fu">=</span> <span class="dt">Just</span> (unzip [(y,ys) <span class="fu">|</span> <span class="dt">Node</span> y ys <span class="ot">&lt;-</span> xs])</a></code></pre></div>
<p>The performance danger here lies in <code class="sourceCode haskell">unzip</code>: one could potentially optimize that for a speedup.</p>
<h3 id="with-an-implicit-queue">With an (implicit) Queue</h3>
<p>Another definition, in the style of <code class="sourceCode haskell">breadthFirstEnumerate</code> above, is as follows:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1">levels ts <span class="fu">=</span> f b ts [] []</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3">    f k (<span class="dt">Node</span> x xs) ls qs <span class="fu">=</span> k (x <span class="fu">:</span> ls) (xs <span class="fu">:</span> qs)</a>
<a class="sourceLine" id="cb14-4" data-line-number="4"></a>
<a class="sourceLine" id="cb14-5" data-line-number="5">    b _ [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb14-6" data-line-number="6">    b k qs <span class="fu">=</span> k <span class="fu">:</span> foldl (foldl f) b qs [] []</a></code></pre></div>
<p>Here, we maintain a stack building up the current level, as well as a queue that we send to the next level. Because we‚Äôre consing onto the front of the stack, the subforest needs to be traversed in reverse, to build up the output list in the right order. This is why we‚Äôre using a second <code class="sourceCode haskell">foldl</code> here, whereas the original had <code class="sourceCode haskell">foldr</code> on the inner loop.</p>
<h3 id="zippy-style">Zippy-Style</h3>
<p>Looking at the implicit queue version, I noticed that it‚Äôs just using a church-encoded pair to reverse the direction of the fold. Instead of doing both reversals, we can use a normal pair, and run it in one direction:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1">levels ts <span class="fu">=</span> b (f ts ([],[]))</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-3" data-line-number="3">    f (<span class="dt">Node</span> x xs) (ls,qs) <span class="fu">=</span> (x<span class="fu">:</span>ls,xs<span class="fu">:</span>qs)</a>
<a class="sourceLine" id="cb15-4" data-line-number="4"></a>
<a class="sourceLine" id="cb15-5" data-line-number="5">    b (_,[]) <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb15-6" data-line-number="6">    b (k,qs) <span class="fu">=</span> k <span class="fu">:</span> b (foldr (flip (foldr f)) ([],[]) qs)</a></code></pre></div>
<p>Secondly, we‚Äôre running a fold on the second component of the pair: why not run the fold immediately, rather than building the intermediate list. In fact, we‚Äôre running a fold over the <em>whole</em> thing, which we can do straight away:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1">levels ts <span class="fu">=</span> f ts []</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3">    f (<span class="dt">Node</span> x xs) (q<span class="fu">:</span>qs) <span class="fu">=</span> (x<span class="fu">:</span>q) <span class="fu">:</span> foldr f qs xs</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">    f (<span class="dt">Node</span> x xs) []     <span class="fu">=</span> [x]   <span class="fu">:</span> foldr f [] xs</a></code></pre></div>
<p>After looking at it for a while, I realized it‚Äôs similar to an inlined version of the algorithm presented in <span class="citation" data-cites="gibbons_breadth-first_2015">Gibbons (<a href="#ref-gibbons_breadth-first_2015">2015</a>)</span>:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1">levels t <span class="fu">=</span> [rootLabel t] <span class="fu">:</span> foldr (lzw (<span class="fu">++</span>)) [] (map levels (subForest t))</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb17-3" data-line-number="3">    lzw f (x<span class="fu">:</span>xs) (y<span class="fu">:</span>ys) <span class="fu">=</span> f x y <span class="fu">:</span> lzw f xs ys</a>
<a class="sourceLine" id="cb17-4" data-line-number="4">    lzw _ xs [] <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb17-5" data-line-number="5">    lzw _ [] ys <span class="fu">=</span> ys</a></code></pre></div>
<h1 id="cofree">Cofree</h1>
<p>Before going any further, all of the functions so far can be redefined to work on the <a href="http://hackage.haskell.org/package/free-5.0.2/docs/Control-Comonad-Cofree.html">cofree comonad</a>:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Cofree</span> f a <span class="fu">=</span> a <span class="fu">:&lt;</span> f (<span class="dt">Cofree</span> f a)</a></code></pre></div>
<p>When <code class="sourceCode haskell">f</code> is specialized to <code class="sourceCode haskell">[]</code>, we get the original rose tree. So far, though, all we actually require is <code class="sourceCode haskell"><span class="dt">Foldable</span></code>.</p>
<p>From now on, then, we‚Äôll use <code class="sourceCode haskell"><span class="dt">Cofree</span></code> instead of <code class="sourceCode haskell"><span class="dt">Tree</span></code>.</p>
<h1 id="traversing">Traversing</h1>
<p>Finally, we can begin on the traversal itself. We know how to execute the effects in the right order, what‚Äôs missing is to build the tree back up in the right order.</p>
<h3 id="filling">Filling</h3>
<p>First thing we‚Äôll use is a trick with <code class="sourceCode haskell"><span class="dt">Traversable</span></code>, where we fill a container from a list. In other words:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1">fill [(),(),(),()] [<span class="dv">1</span><span class="fu">..</span>] <span class="fu">=</span> ([<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>],[<span class="dv">5</span><span class="fu">..</span>])</a></code></pre></div>
<p>With the state monad (or applicative, in this case, I suppose), we can define a ‚Äúpop‚Äù action, which takes an element from the supply:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1">pop <span class="fu">=</span> state (\(x<span class="fu">:</span>xs) <span class="ot">-&gt;</span> (x,xs))</a></code></pre></div>
<p>And then we <code class="sourceCode haskell">traverse</code> that action over our container:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1">fill <span class="fu">=</span> traverse (const pop)</a></code></pre></div>
<p>When we use fill, it‚Äôll have the following type:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="ot">breadthFirst ::</span> (<span class="dt">Applicative</span> f, <span class="dt">Traversable</span> t)</a>
<a class="sourceLine" id="cb22-2" data-line-number="2">             <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> <span class="dt">Cofree</span> t a <span class="ot">-&gt;</span> f (<span class="dt">Cofree</span> t b)</a>
<a class="sourceLine" id="cb22-3" data-line-number="3">breadthFirst <span class="fu">=</span> <span class="fu">...</span></a>
<a class="sourceLine" id="cb22-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-5" data-line-number="5">    <span class="fu">...</span></a>
<a class="sourceLine" id="cb22-6" data-line-number="6"><span class="ot">    fill ::</span> t (<span class="dt">Cofree</span> t a) <span class="ot">-&gt;</span> <span class="dt">State</span> [<span class="dt">Cofree</span> t b] (t (<span class="dt">Cofree</span> t b))</a>
<a class="sourceLine" id="cb22-7" data-line-number="7">    fill <span class="fu">=</span> traverse (const pop)</a></code></pre></div>
<p>Hopefully that makes sense: we‚Äôre going to get the subforest from here:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Cofree</span> t a <span class="fu">=</span> a <span class="fu">:&lt;</span> t (<span class="dt">Cofree</span> t a)</a>
<a class="sourceLine" id="cb23-2" data-line-number="2">                       <span class="fu">^^^^^^^^^^^^^^</span></a></code></pre></div>
<p>And we‚Äôre going to fill it with the result of the traversal, which changes the contents from <code>a</code>s to <code>b</code>s.</p>
<h3 id="composing-applicatives">Composing Applicatives</h3>
<p>One of the nice things about working with applicatives is that they compose, in a variety of different ways. In other words, if I have one effect, <code class="sourceCode haskell">f</code>, and another <code class="sourceCode haskell">g</code>, and I want to run them both on the contents of some list, I can do it in one pass, either by layering the effects, or putting them side-by-side.</p>
<p>In our case, we need to deal with two effects: the one generated by the traversal, (the one the caller wants to use), and the internal state we‚Äôre using to fill up the forests in our tree. We could use <a href="http://hackage.haskell.org/package/base-4.11.1.0/docs/Data-Functor-Compose.html#t:Compose"><code class="sourceCode haskell"><span class="dt">Compose</span></code></a> explicitly, but we can avoid some calls to <code class="sourceCode haskell">pure</code> if we write the combinators we‚Äôre going to use directly:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1">map2</a>
<a class="sourceLine" id="cb24-2" data-line-number="2"><span class="ot">    ::</span> (<span class="dt">Functor</span> f, <span class="dt">Functor</span> g)</a>
<a class="sourceLine" id="cb24-3" data-line-number="3">    <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> g b <span class="ot">-&gt;</span> f (g c)</a>
<a class="sourceLine" id="cb24-4" data-line-number="4">map2 f x xs <span class="fu">=</span></a>
<a class="sourceLine" id="cb24-5" data-line-number="5">    fmap (\y <span class="ot">-&gt;</span> fmap (f y) xs) x</a>
<a class="sourceLine" id="cb24-6" data-line-number="6"></a>
<a class="sourceLine" id="cb24-7" data-line-number="7">app2</a>
<a class="sourceLine" id="cb24-8" data-line-number="8"><span class="ot">    ::</span> (<span class="dt">Applicative</span> f, <span class="dt">Applicative</span> g)</a>
<a class="sourceLine" id="cb24-9" data-line-number="9">    <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> g b <span class="ot">-&gt;</span> f (g c) <span class="ot">-&gt;</span> f (g d)</a>
<a class="sourceLine" id="cb24-10" data-line-number="10">app2 f x xs <span class="fu">=</span></a>
<a class="sourceLine" id="cb24-11" data-line-number="11">    liftA2 (\y <span class="ot">-&gt;</span> liftA2 (f y) xs) x</a></code></pre></div>
<p>The outer applicative (<code>f</code>) will be the user‚Äôs effect, the inner will be <code>State</code>.</p>
<h1 id="take-1-zippy-style-traversing">Take 1: Zippy-Style Traversing</h1>
<p>First we‚Äôll try convert the zippy-style <code class="sourceCode haskell">levels</code> to a traversal. First, convert the function over to the cofree comonad:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1">levels tr <span class="fu">=</span> f tr []</a>
<a class="sourceLine" id="cb25-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-3" data-line-number="3">    f (x<span class="fu">:&lt;</span>xs) (q<span class="fu">:</span>qs) <span class="fu">=</span> (x<span class="fu">:</span>q) <span class="fu">:</span> foldr f qs xs</a>
<a class="sourceLine" id="cb25-4" data-line-number="4">    f (x<span class="fu">:&lt;</span>xs) []     <span class="fu">=</span> [x]   <span class="fu">:</span> foldr f [] xs</a></code></pre></div>
<p>Next, instead of building up a list of just the root labels, we‚Äôll pair them with the subforests:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1">breadthFirst tr <span class="fu">=</span> f tr []</a>
<a class="sourceLine" id="cb26-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb26-3" data-line-number="3">    f (x<span class="fu">:&lt;</span>xs) (q<span class="fu">:</span>qs) <span class="fu">=</span> ((x,xs)<span class="fu">:</span>q) <span class="fu">:</span> foldr f qs xs</a>
<a class="sourceLine" id="cb26-4" data-line-number="4">    f (x<span class="fu">:&lt;</span>xs) []     <span class="fu">=</span> [(x,xs)]   <span class="fu">:</span> foldr f [] xs</a></code></pre></div>
<p>Next, we‚Äôll fill the subforests:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1">breadthFirst tr <span class="fu">=</span> f tr []</a>
<a class="sourceLine" id="cb27-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb27-3" data-line-number="3">    f (x<span class="fu">:&lt;</span>xs) (q<span class="fu">:</span>qs) <span class="fu">=</span> ((x,fill xs)<span class="fu">:</span>q) <span class="fu">:</span> foldr f qs xs</a>
<a class="sourceLine" id="cb27-4" data-line-number="4">    f (x<span class="fu">:&lt;</span>xs) []     <span class="fu">=</span> [(x,fill xs)]   <span class="fu">:</span> foldr f [] xs</a></code></pre></div>
<p>Then, we can run the applicative effect on the root label:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1">breadthFirst c tr <span class="fu">=</span> f tr []</a>
<a class="sourceLine" id="cb28-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb28-3" data-line-number="3">    f (x<span class="fu">:&lt;</span>xs) (q<span class="fu">:</span>qs) <span class="fu">=</span> ((c x,fill xs)<span class="fu">:</span>q) <span class="fu">:</span> foldr f qs xs</a>
<a class="sourceLine" id="cb28-4" data-line-number="4">    f (x<span class="fu">:&lt;</span>xs) []     <span class="fu">=</span> [(c x,fill xs)]   <span class="fu">:</span> foldr f [] xs</a></code></pre></div>
<p>Now, to combine the effects, we can use the combinators we defined before:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" data-line-number="1">breadthFirst c tr <span class="fu">=</span> f tr []</a>
<a class="sourceLine" id="cb29-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb29-3" data-line-number="3">    f (x<span class="fu">:&lt;</span>xs) (q<span class="fu">:</span>qs) <span class="fu">=</span></a>
<a class="sourceLine" id="cb29-4" data-line-number="4">        app2 (\y ys zs <span class="ot">-&gt;</span> (y<span class="fu">:&lt;</span>ys) <span class="fu">:</span> zs) (c x) (fill xs) q <span class="fu">:</span> foldr f qs xs</a>
<a class="sourceLine" id="cb29-5" data-line-number="5">    f (x<span class="fu">:&lt;</span>xs) [] <span class="fu">=</span></a>
<a class="sourceLine" id="cb29-6" data-line-number="6">        map2 (\y ys <span class="ot">-&gt;</span> [y<span class="fu">:&lt;</span>ys]) (c x) (fill xs) <span class="fu">:</span> foldr f [] xs</a></code></pre></div>
<p>This builds a list containing all of the level-wise traversals of the tree. To collapse them into one, we can use a fold:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="ot">breadthFirst ::</span> (<span class="dt">Traversable</span> t, <span class="dt">Applicative</span> f)</a>
<a class="sourceLine" id="cb30-2" data-line-number="2">             <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b)</a>
<a class="sourceLine" id="cb30-3" data-line-number="3">             <span class="ot">-&gt;</span> <span class="dt">Cofree</span> t a</a>
<a class="sourceLine" id="cb30-4" data-line-number="4">             <span class="ot">-&gt;</span> f (<span class="dt">Cofree</span> t b)</a>
<a class="sourceLine" id="cb30-5" data-line-number="5">breadthFirst c tr <span class="fu">=</span></a>
<a class="sourceLine" id="cb30-6" data-line-number="6">    head <span class="fu">&lt;$&gt;</span> foldr (liftA2 evalState) (pure []) (f tr [])</a>
<a class="sourceLine" id="cb30-7" data-line-number="7">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-8" data-line-number="8">    f (x<span class="fu">:&lt;</span>xs) (q<span class="fu">:</span>qs) <span class="fu">=</span></a>
<a class="sourceLine" id="cb30-9" data-line-number="9">        app2 (\y ys zs <span class="ot">-&gt;</span> (y<span class="fu">:&lt;</span>ys)<span class="fu">:</span>zs) (c x) (fill xs) q <span class="fu">:</span> foldr f qs xs</a>
<a class="sourceLine" id="cb30-10" data-line-number="10">    f (x<span class="fu">:&lt;</span>xs) [] <span class="fu">=</span></a>
<a class="sourceLine" id="cb30-11" data-line-number="11">        map2 (\y ys <span class="ot">-&gt;</span> [y<span class="fu">:&lt;</span>ys]) (c x) (fill xs) <span class="fu">:</span> foldr f [] xs</a></code></pre></div>
<h1 id="take-2-queue-based-traversing">Take 2: Queue-Based Traversing</h1>
<p>Converting the queue-based implementation is easy once we‚Äôve done it with the zippy one. The result is (to my eye) a little easier to read, also:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" data-line-number="1">breadthFirst</a>
<a class="sourceLine" id="cb31-2" data-line-number="2"><span class="ot">    ::</span> (<span class="dt">Applicative</span> f, <span class="dt">Traversable</span> t)</a>
<a class="sourceLine" id="cb31-3" data-line-number="3">    <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> <span class="dt">Cofree</span> t a <span class="ot">-&gt;</span> f (<span class="dt">Cofree</span> t b)</a>
<a class="sourceLine" id="cb31-4" data-line-number="4">breadthFirst c tr <span class="fu">=</span></a>
<a class="sourceLine" id="cb31-5" data-line-number="5">    fmap head (f b tr e [])</a>
<a class="sourceLine" id="cb31-6" data-line-number="6">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb31-7" data-line-number="7">    f k (x<span class="fu">:&lt;</span>xs) ls qs <span class="fu">=</span></a>
<a class="sourceLine" id="cb31-8" data-line-number="8">      k (app2 (\y ys zs <span class="ot">-&gt;</span> (y<span class="fu">:&lt;</span>ys)<span class="fu">:</span>zs) (c x) (fill xs) ls) (xs<span class="fu">:</span>qs)</a>
<a class="sourceLine" id="cb31-9" data-line-number="9"></a>
<a class="sourceLine" id="cb31-10" data-line-number="10">    b _ [] <span class="fu">=</span> pure []</a>
<a class="sourceLine" id="cb31-11" data-line-number="11">    b l qs <span class="fu">=</span> liftA2 evalState l (foldl (foldl f) b qs e [])</a>
<a class="sourceLine" id="cb31-12" data-line-number="12"></a>
<a class="sourceLine" id="cb31-13" data-line-number="13">    e <span class="fu">=</span> pure (pure [])</a></code></pre></div>
<p>There are a couple things to notice here: first, we‚Äôre not using <code class="sourceCode haskell">map2</code> anywhere. That‚Äôs because in the zippy version we were able to notice when the queue was exhausted, so we could just output the singleton effect. Here, instead, we‚Äôre using <code class="sourceCode haskell">pure (pure [])</code>: this is potentially a source of inefficiency, as <code class="sourceCode haskell">liftA2 f (pure x) y</code> is less efficient than <code class="sourceCode haskell">fmap (f x) y</code> for some applicatives.</p>
<p>On the other hand, we don‚Äôt build up a list of levels to be combined with <code class="sourceCode haskell">foldr (liftA2 evalState)</code> at any point: we combine them at every level immediately. You may be able to do the same in the zippy version, but I haven‚Äôt figured it out yet.</p>
<h3 id="yoneda">Yoneda</h3>
<p>The final point to make here is to do with the very last thing we do in the traversal: <code class="sourceCode haskell">fmap head</code>. Strictly speaking, any <code class="sourceCode haskell">fmap</code>s in the code should be unnecessary: we <em>should</em> be able to fuse them all with any call to <code class="sourceCode haskell">liftA2</code>. This transformation is often called the ‚ÄúYoneda embedding‚Äù. We can use it here like so:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" data-line-number="1">breadthFirst</a>
<a class="sourceLine" id="cb32-2" data-line-number="2"><span class="ot">    ::</span> <span class="ot">‚àÄ</span> t a f b<span class="fu">.</span> (<span class="dt">Traversable</span> t, <span class="dt">Applicative</span> f)</a>
<a class="sourceLine" id="cb32-3" data-line-number="3">    <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> <span class="dt">Cofree</span> t a <span class="ot">-&gt;</span> f (<span class="dt">Cofree</span> t b)</a>
<a class="sourceLine" id="cb32-4" data-line-number="4">breadthFirst c tr <span class="fu">=</span> f (b head) tr e []</a>
<a class="sourceLine" id="cb32-5" data-line-number="5">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-6" data-line-number="6">    f k (x<span class="fu">:&lt;</span>xs) ls qs <span class="fu">=</span></a>
<a class="sourceLine" id="cb32-7" data-line-number="7">        k (app2 (\y ys zs <span class="ot">-&gt;</span> (y<span class="fu">:&lt;</span>ys) <span class="fu">:</span> zs) (c x) (fill xs) ls) (xs <span class="fu">:</span> qs)</a>
<a class="sourceLine" id="cb32-8" data-line-number="8"></a>
<a class="sourceLine" id="cb32-9" data-line-number="9"><span class="ot">    b ::</span> <span class="ot">‚àÄ</span> x<span class="fu">.</span> ([<span class="dt">Cofree</span> t b] <span class="ot">-&gt;</span> x)</a>
<a class="sourceLine" id="cb32-10" data-line-number="10">      <span class="ot">-&gt;</span> f (<span class="dt">State</span> [<span class="dt">Cofree</span> t b] [<span class="dt">Cofree</span> t b])</a>
<a class="sourceLine" id="cb32-11" data-line-number="11">      <span class="ot">-&gt;</span> [t (<span class="dt">Cofree</span> t a)]</a>
<a class="sourceLine" id="cb32-12" data-line-number="12">      <span class="ot">-&gt;</span> f x</a>
<a class="sourceLine" id="cb32-13" data-line-number="13">    b k _ [] <span class="fu">=</span> pure (k [])</a>
<a class="sourceLine" id="cb32-14" data-line-number="14">    b k l qs <span class="fu">=</span></a>
<a class="sourceLine" id="cb32-15" data-line-number="15">        liftA2 (\x <span class="ot">-&gt;</span> k <span class="fu">.</span> evalState x) l (foldl (foldl f) (b id) qs e [])</a>
<a class="sourceLine" id="cb32-16" data-line-number="16"></a>
<a class="sourceLine" id="cb32-17" data-line-number="17">    e <span class="fu">=</span> pure (pure [])</a></code></pre></div>
<p>Notice that we need scoped type variables here, since the type of <code class="sourceCode haskell">b</code> changes depending on when it‚Äôs called.</p>
<h1 id="take-3-iterative-traversing">Take 3: Iterative Traversing</h1>
<p>Transforming the iterative version is slightly different from the other two:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" data-line-number="1">breadthFirst c tr <span class="fu">=</span> fmap head (go [tr])</a>
<a class="sourceLine" id="cb33-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb33-3" data-line-number="3">    go [] <span class="fu">=</span> pure []</a>
<a class="sourceLine" id="cb33-4" data-line-number="4">    go xs <span class="fu">=</span></a>
<a class="sourceLine" id="cb33-5" data-line-number="5">        liftA2</a>
<a class="sourceLine" id="cb33-6" data-line-number="6">            evalState</a>
<a class="sourceLine" id="cb33-7" data-line-number="7">            (getCompose (traverse f xs))</a>
<a class="sourceLine" id="cb33-8" data-line-number="8">            (go (foldr (\(_<span class="fu">:&lt;</span>ys) b <span class="ot">-&gt;</span> foldr (<span class="fu">:</span>) b ys) [] xs))</a>
<a class="sourceLine" id="cb33-9" data-line-number="9">    f (x<span class="fu">:&lt;</span>xs) <span class="fu">=</span> <span class="dt">Compose</span> (map2 (<span class="fu">:&lt;</span>) (c x) (fill xs))</a></code></pre></div>
<p>We‚Äôre using <code class="sourceCode haskell"><span class="dt">Compose</span></code> directly here, in contrast to the other two algorithms.</p>
<h1 id="comparison">Comparison</h1>
<p>Performance-wise, no one algorithm wins out in every case. For enumeration, the zippy algorithm is the fastest in most cases‚Äîexcept when the tree had a large branching factor; then, the iterative algorithm wins out. For the traversals, the iterative algorithm is usually better‚Äîexcept for monads with more expensive applicative instances.</p>
<p>I‚Äôm still not convinced that the zippy traversal is as optimized as it could be, however. If anyone has a better implementation, I‚Äôd love to see it!</p>
<h1 id="fusion">Fusion</h1>
<p>Using the composability of applicatives, we can fuse several operations over traversables into one pass. Unfortunately, however, this can often introduce a memory overhead that makes the whole operation slower overall. One such example is the iterative algorithm above:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" data-line-number="1">breadthFirst c tr <span class="fu">=</span> fmap head (go [tr])</a>
<a class="sourceLine" id="cb34-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb34-3" data-line-number="3">    go [] <span class="fu">=</span> pure []</a>
<a class="sourceLine" id="cb34-4" data-line-number="4">    go xs <span class="fu">=</span> liftA2 evalState zs (go (ys []))</a>
<a class="sourceLine" id="cb34-5" data-line-number="5">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb34-6" data-line-number="6">        <span class="dt">Compose</span> (<span class="dt">Endo</span> ys,<span class="dt">Compose</span> zs) <span class="fu">=</span> traverse f xs</a>
<a class="sourceLine" id="cb34-7" data-line-number="7">    f (x <span class="fu">:&lt;</span> xs) <span class="fu">=</span></a>
<a class="sourceLine" id="cb34-8" data-line-number="8">        <span class="dt">Compose</span></a>
<a class="sourceLine" id="cb34-9" data-line-number="9">            (<span class="dt">Endo</span> (flip (foldr (<span class="fu">:</span>)) xs)</a>
<a class="sourceLine" id="cb34-10" data-line-number="10">            ,<span class="dt">Compose</span> (map2 (<span class="fu">:&lt;</span>) (c x) (fill xs)))</a></code></pre></div>
<p>We only traverse the subforest of each node once now, fusing the fill operation with building the list to send to the recursive call. This is expensive (especially memory-wise), though, and traversing the descendant is cheap; the result is that the one-pass version is slower (in my tests).</p>
<h1 id="generalizing">Generalizing</h1>
<p>The cofree comonad allows us to generalize over the type of ‚Äúdescendants‚Äù‚Äîfrom lists (in <code class="sourceCode haskell"><span class="dt">Tree</span></code>) to anything traversable. We could also generalize over the type of the traversal itself: given a way to access the descendants of a node, we should be able to traverse all nodes in a breadth-first order. This kind of thing is usually accomplished by <a href="http://hackage.haskell.org/package/lens-4.16.1/docs/Control-Lens-Plated.html">Plated</a>: it‚Äôs a class that gives you a traversal over the immediate descendants of some recursive type. Adapting the iterative version is relatively simple:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb35-1" data-line-number="1"><span class="ot">breadthFirstOf ::</span> <span class="dt">Traversal&#39;</span> a a <span class="ot">-&gt;</span> <span class="dt">Traversal&#39;</span> a a</a>
<a class="sourceLine" id="cb35-2" data-line-number="2">breadthFirstOf trav c tr <span class="fu">=</span> fmap head (go [tr])</a>
<a class="sourceLine" id="cb35-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb35-4" data-line-number="4">    go [] <span class="fu">=</span> pure []</a>
<a class="sourceLine" id="cb35-5" data-line-number="5">    go xs <span class="fu">=</span></a>
<a class="sourceLine" id="cb35-6" data-line-number="6">        liftA2</a>
<a class="sourceLine" id="cb35-7" data-line-number="7">            evalState</a>
<a class="sourceLine" id="cb35-8" data-line-number="8">            (getCompose (traverse f xs))</a>
<a class="sourceLine" id="cb35-9" data-line-number="9">            (go (foldr (\ys b <span class="ot">-&gt;</span> foldrOf trav (<span class="fu">:</span>) b ys) [] xs))</a>
<a class="sourceLine" id="cb35-10" data-line-number="10">    f xs <span class="fu">=</span> <span class="dt">Compose</span> (fmap fill (c xs))</a>
<a class="sourceLine" id="cb35-11" data-line-number="11">    fill <span class="fu">=</span> trav (const (<span class="dt">State</span> (\(x<span class="fu">:</span>xs) <span class="ot">-&gt;</span> (x, xs))))</a></code></pre></div>
<p>We can use this version to get back some of the old functions above:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" data-line-number="1"><span class="ot">breadthFirstEnumerate ::</span>  <span class="dt">Traversable</span> f <span class="ot">=&gt;</span> <span class="dt">Cofree</span> f a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb36-2" data-line-number="2">breadthFirstEnumerate <span class="fu">=</span> toListOf (breadthFirstOf plate <span class="fu">.</span> _extract)</a></code></pre></div>
<h1 id="unfolding">Unfolding</h1>
<p>Building a tree breadth-first, monadically, is still an unsolved problem <span class="citation" data-cites="feuer_is_2015">(it looks like: Feuer <a href="#ref-feuer_is_2015">2015</a>)</span>.</p>
<p>Using some of these we can implement a monadic breadth-first unfold for the cofree comonad:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb37-1" data-line-number="1"><span class="ot">unfoldM ::</span> (<span class="dt">Monad</span> m, <span class="dt">Traversable</span> t)</a>
<a class="sourceLine" id="cb37-2" data-line-number="2">        <span class="ot">=&gt;</span> (b <span class="ot">-&gt;</span> m (a, t b))</a>
<a class="sourceLine" id="cb37-3" data-line-number="3">        <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb37-4" data-line-number="4">        <span class="ot">-&gt;</span> m (<span class="dt">Cofree</span> t a)</a>
<a class="sourceLine" id="cb37-5" data-line-number="5">unfoldM c tr <span class="fu">=</span> go head [tr]</a>
<a class="sourceLine" id="cb37-6" data-line-number="6">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb37-7" data-line-number="7">    go k [] <span class="fu">=</span> pure (k [])</a>
<a class="sourceLine" id="cb37-8" data-line-number="8">    go k xs <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb37-9" data-line-number="9">        ys <span class="ot">&lt;-</span> traverse c xs</a>
<a class="sourceLine" id="cb37-10" data-line-number="10">        go (k <span class="fu">.</span> evalState (traverse f ys)) (toList (<span class="dt">Compose</span> (<span class="dt">Compose</span> ys)))</a>
<a class="sourceLine" id="cb37-11" data-line-number="11">    f (x,xs) <span class="fu">=</span> fmap (x<span class="fu">:&lt;</span>) (fill xs)</a></code></pre></div>
<h1 id="references" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-allison_circular_2006">
<p>Allison, Lloyd. 2006. ‚ÄúCircular Programs and Self-Referential Structures.‚Äù <em>Software: Practice and Experience</em> 19 (2) (October 30): 99‚Äì109. doi:<a href="https://doi.org/10.1002/spe.4380190202">10.1002/spe.4380190202</a>. <a href="http://users.monash.edu/~lloyd/tildeFP/1989SPE/" class="uri">http://users.monash.edu/~lloyd/tildeFP/1989SPE/</a>.</p>
</div>
<div id="ref-feuer_is_2015">
<p>Feuer, David. 2015. ‚ÄúIs a lazy, breadth-first monadic rose tree unfold possible?‚Äù Question. <em>Stack Overflow</em>. <a href="https://stackoverflow.com/q/27748526" class="uri">https://stackoverflow.com/q/27748526</a>.</p>
</div>
<div id="ref-gibbons_breadth-first_2015">
<p>Gibbons, Jeremy. 2015. ‚ÄúBreadth-First Traversal.‚Äù <em>Patterns in Functional Programming</em>. <a href="https://patternsinfp.wordpress.com/2015/03/05/breadth-first-traversal/" class="uri">https://patternsinfp.wordpress.com/2015/03/05/breadth-first-traversal/</a>.</p>
</div>
<div id="ref-smith_lloyd_2009">
<p>Smith, Leon P. 2009. ‚ÄúLloyd Allison‚Äôs Corecursive Queues: Why Continuations Matter.‚Äù <em>The Monad.Reader</em>, July 29. <a href="https://meldingmonads.files.wordpress.com/2009/06/corecqueues.pdf" class="uri">https://meldingmonads.files.wordpress.com/2009/06/corecqueues.pdf</a>.</p>
</div>
</div>
]]></description>
    <pubDate>Sun, 03 Jun 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-06-03-breadth-first-traversals-in-too-much-detail.html</guid>
    <dc:creator>Donnacha Ois√≠n Kidney</dc:creator>
</item>
<item>
    <title>Breadth-First Rose Trees: Traversals and the Cofree Comonad</title>
    <link>https://doisinkidney.com/posts/2018-06-01-rose-trees-breadth-first-traversing.html</link>
    <description><![CDATA[<div class="info">
    Posted on June  1, 2018
</div>
<div class="info">
    
        Part 2 of a <a href="/series/Breadth-First%20Traversals.html">5-part series on Breadth-First Traversals</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<p>I was looking again at the issue of writing breadth-first traversals for rose trees, and in particular the problem explored in <span class="citation" data-cites="gibbons_breadth-first_2015">Gibbons (<a href="#ref-gibbons_breadth-first_2015">2015</a>)</span>. The breadth-first traversal here is a traversal in the lensy sense.</p>
<p>First, let‚Äôs look back at getting the levels out of the tree. Here‚Äôs the old function I arrived at last time:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">levels ::</span> <span class="dt">Forest</span> a <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">levels ts <span class="fu">=</span> foldl f b ts [] []</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">    f k (<span class="dt">Node</span> x xs) ls qs <span class="fu">=</span> k (x <span class="fu">:</span> ls) (xs <span class="fu">:</span> qs)</a>
<a class="sourceLine" id="cb1-5" data-line-number="5"></a>
<a class="sourceLine" id="cb1-6" data-line-number="6">    b _ [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb1-7" data-line-number="7">    b k qs <span class="fu">=</span> k <span class="fu">:</span> foldl (foldl f) b qs [] []</a></code></pre></div>
<p>After wrangling the definition a little, I got to the following (much cleaner) definition:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">levels ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">levels tr <span class="fu">=</span> f tr [] <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  f (<span class="dt">Node</span> x xs) (y<span class="fu">:</span>ys) <span class="fu">=</span> (x<span class="fu">:</span>y) <span class="fu">:</span> foldr f ys xs</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">  f (<span class="dt">Node</span> x xs) []     <span class="fu">=</span> [x]   <span class="fu">:</span> foldr f [] xs</a></code></pre></div>
<h1 id="cofree">Cofree</h1>
<p>Before going any further, all of the functions so far can be redefined to work on the <a href="http://hackage.haskell.org/package/free-5.0.2/docs/Control-Comonad-Cofree.html">cofree comonad</a>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Cofree</span> f a <span class="fu">=</span> a <span class="fu">:&lt;</span> f (<span class="dt">Cofree</span> f a)</a></code></pre></div>
<p>When <code class="sourceCode haskell">f</code> is specialized to <code class="sourceCode haskell">[]</code>, we get the original rose tree. But what we actually require is much less specific: <code class="sourceCode haskell">levels</code>, for instance, only needs <code class="sourceCode haskell"><span class="dt">Foldable</span></code>.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">levelsCofree ::</span> <span class="dt">Foldable</span> f <span class="ot">=&gt;</span> <span class="dt">Cofree</span> f a <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">levelsCofree tr <span class="fu">=</span> f tr []</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">    f (x<span class="fu">:&lt;</span>xs) (y<span class="fu">:</span>ys) <span class="fu">=</span> (x<span class="fu">:</span>y) <span class="fu">:</span> foldr f ys xs</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">    f (x<span class="fu">:&lt;</span>xs) []     <span class="fu">=</span> [x]   <span class="fu">:</span> foldr f [] xs</a></code></pre></div>
<p>Using this, we can write the efficient breadth-first traversal:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1">breadthFirst</a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="ot">    ::</span> (<span class="dt">Applicative</span> f, <span class="dt">Traversable</span> t)</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">    <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> <span class="dt">Cofree</span> t a <span class="ot">-&gt;</span> f (<span class="dt">Cofree</span> t b)</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">breadthFirst c (t<span class="fu">:&lt;</span>ts) <span class="fu">=</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">    liftA2 evalState (map2 (<span class="fu">:&lt;</span>) (c t) (fill ts)) chld</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-7" data-line-number="7">    chld <span class="fu">=</span> foldr (liftA2 evalState) (pure []) (foldr f [] ts)</a>
<a class="sourceLine" id="cb5-8" data-line-number="8">    fill <span class="fu">=</span> traverse (const (state (\(x<span class="fu">:</span>xs) <span class="ot">-&gt;</span> (x,xs))))</a>
<a class="sourceLine" id="cb5-9" data-line-number="9"></a>
<a class="sourceLine" id="cb5-10" data-line-number="10">    f (x<span class="fu">:&lt;</span>xs) (q<span class="fu">:</span>qs)</a>
<a class="sourceLine" id="cb5-11" data-line-number="11">        <span class="fu">=</span> app2 (\y ys zs <span class="ot">-&gt;</span> (y<span class="fu">:&lt;</span>ys) <span class="fu">:</span> zs) (c x) (fill xs) q</a>
<a class="sourceLine" id="cb5-12" data-line-number="12">        <span class="fu">:</span> foldr f qs xs</a>
<a class="sourceLine" id="cb5-13" data-line-number="13">    f (x<span class="fu">:&lt;</span>xs) []</a>
<a class="sourceLine" id="cb5-14" data-line-number="14">        <span class="fu">=</span> map2 (\y ys <span class="ot">-&gt;</span> [y<span class="fu">:&lt;</span>ys]) (c x) (fill xs)</a>
<a class="sourceLine" id="cb5-15" data-line-number="15">        <span class="fu">:</span> foldr f [] xs</a>
<a class="sourceLine" id="cb5-16" data-line-number="16"></a>
<a class="sourceLine" id="cb5-17" data-line-number="17">    map2 k x xs <span class="fu">=</span> fmap   (\y <span class="ot">-&gt;</span> fmap   (k y) xs) x</a>
<a class="sourceLine" id="cb5-18" data-line-number="18">    app2 k x xs <span class="fu">=</span> liftA2 (\y <span class="ot">-&gt;</span> liftA2 (k y) xs) x</a></code></pre></div>
<p>At every level, the subforest‚Äôs shape it taken (<code class="sourceCode haskell">fill</code>), and it‚Äôs traversed recursively. We can fuse these two steps into one:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1">breadthFirst</a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="ot">    ::</span> (<span class="dt">Traversable</span> t, <span class="dt">Applicative</span> f)</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">    <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> <span class="dt">Cofree</span> t a  <span class="ot">-&gt;</span> f (<span class="dt">Cofree</span> t b)</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">breadthFirst c (t<span class="fu">:&lt;</span>ts) <span class="fu">=</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">    liftA2</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">        evalState</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">        (map2 (<span class="fu">:&lt;</span>) (c t) fill)</a>
<a class="sourceLine" id="cb6-8" data-line-number="8">        (foldr (liftA2 evalState) (pure []) (chld []))</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-10" data-line-number="10">    <span class="dt">Compose</span> (<span class="dt">Endo</span> chld,fill) <span class="fu">=</span> go ts</a>
<a class="sourceLine" id="cb6-11" data-line-number="11"></a>
<a class="sourceLine" id="cb6-12" data-line-number="12">    go <span class="fu">=</span> traverse (\x <span class="ot">-&gt;</span> <span class="dt">Compose</span> (<span class="dt">Endo</span> (f x), state (\(y<span class="fu">:</span>ys) <span class="ot">-&gt;</span> (y,ys))))</a>
<a class="sourceLine" id="cb6-13" data-line-number="13"></a>
<a class="sourceLine" id="cb6-14" data-line-number="14">    f (x<span class="fu">:&lt;</span>xs) (q<span class="fu">:</span>qs) <span class="fu">=</span> app2 (\y ys zs <span class="ot">-&gt;</span> (y<span class="fu">:&lt;</span>ys) <span class="fu">:</span> zs) (c x) r q <span class="fu">:</span> rs qs</a>
<a class="sourceLine" id="cb6-15" data-line-number="15">      <span class="kw">where</span> <span class="dt">Compose</span> (<span class="dt">Endo</span> rs,r) <span class="fu">=</span> go xs</a>
<a class="sourceLine" id="cb6-16" data-line-number="16">    f (x<span class="fu">:&lt;</span>xs) [] <span class="fu">=</span> map2 (\y ys <span class="ot">-&gt;</span> [y<span class="fu">:&lt;</span>ys]) (c x) r <span class="fu">:</span> rs []</a>
<a class="sourceLine" id="cb6-17" data-line-number="17">      <span class="kw">where</span> <span class="dt">Compose</span> (<span class="dt">Endo</span> rs,r) <span class="fu">=</span> go xs</a>
<a class="sourceLine" id="cb6-18" data-line-number="18"></a>
<a class="sourceLine" id="cb6-19" data-line-number="19">    map2 k x xs <span class="fu">=</span> fmap   (\y <span class="ot">-&gt;</span> fmap   (k y) xs) x</a>
<a class="sourceLine" id="cb6-20" data-line-number="20">    app2 k x xs <span class="fu">=</span> liftA2 (\y <span class="ot">-&gt;</span> liftA2 (k y) xs) x</a></code></pre></div>
<p>The overhead from this approach scraps any benefit, though.</p>
<div id="refs" class="references">
<div id="ref-gibbons_breadth-first_2015">
<p>Gibbons, Jeremy. 2015. ‚ÄúBreadth-First Traversal.‚Äù <em>Patterns in Functional Programming</em>. <a href="https://patternsinfp.wordpress.com/2015/03/05/breadth-first-traversal/" class="uri">https://patternsinfp.wordpress.com/2015/03/05/breadth-first-traversal/</a>.</p>
</div>
</div>
]]></description>
    <pubDate>Fri, 01 Jun 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-06-01-rose-trees-breadth-first-traversing.html</guid>
    <dc:creator>Donnacha Ois√≠n Kidney</dc:creator>
</item>
<item>
    <title>Sorting Small Things in Haskell</title>
    <link>https://doisinkidney.com/posts/2018-05-06-sorting-small.html</link>
    <description><![CDATA[<div class="info">
    Posted on May  6, 2018
</div>
<div class="info">
    
        Part 1 of a <a href="/series/Sorting.html">1-part series on Sorting</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Algorithms.html">Algorithms</a>
    
</div>

<p>I was working on some performance-intensive stuff recently, and I ran into the issue of sorting very small amounts of values (think 3, 4, 5).</p>
<p>The standard way to do this is with <a href="https://en.wikipedia.org/wiki/Sorting_network">sorting networks</a>. The way I‚Äôll be using doesn‚Äôt actually perform any parallelism (unfortunately), but it is a clean way to write the networks in Haskell without too much repetition.</p>
<p><a href="http://pages.ripco.net/~jgamble/nw.html">This</a> website will generate an optimal sorting network for your given size, and the output (for 3) looks like this:</p>
<pre><code>[[1,2]]
[[0,2]]
[[0,1]]</code></pre>
<p>Each pair of indices represents a ‚Äúcompare-and-swap‚Äù operation: so the first line means ‚Äúcompare the value at 1 to the value at 2: if it‚Äôs bigger, swap them‚Äù. For 5, the network looks like this:</p>
<pre><code>[[0,1],[2,3]]
[[0,2],[1,3]]
[[1,2],[0,4]]
[[1,4]]
[[2,4]]
[[3,4]]</code></pre>
<p>Pairs on the same line can be performed in parallel.</p>
<p>For our case, I‚Äôm going to be looking at sorting tuples, but the technique can easily be generalized to vectors, etc.</p>
<p>The first trick is to figure out how to do ‚Äúswapping‚Äù: we don‚Äôt want mutation, so what we can do instead is swap the <em>reference</em> to some value, by shadowing its name. In other words:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">swap2 ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> (a, a)</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">swap2 lte x y <span class="fu">|</span> lte x y <span class="fu">=</span> (x, y)</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">              <span class="fu">|</span> otherwise <span class="fu">=</span> (y, x)</a>
<a class="sourceLine" id="cb3-4" data-line-number="4"></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="ot">sort3 ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> (a,a,a) <span class="ot">-&gt;</span> (a,a,a)</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">sort3 lte (_0,_1,_2)</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">    <span class="fu">=</span> <span class="kw">case</span> swap2 lte _1 _2 <span class="kw">of</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8">      (_1, _2) <span class="ot">-&gt;</span> <span class="kw">case</span> swap2 lte _0 _2 <span class="kw">of</span></a>
<a class="sourceLine" id="cb3-9" data-line-number="9">        (_0, _2) <span class="ot">-&gt;</span> <span class="kw">case</span> swap2 lte _0 _1 <span class="kw">of</span></a>
<a class="sourceLine" id="cb3-10" data-line-number="10">          (_0, _1) <span class="ot">-&gt;</span> (_0, _1, _2)</a></code></pre></div>
<p>The indentation is hard to read, though, and wrapping-and-unwrapping tuples makes me nervous about the performance (although it may be inlined). The next step is to <em>church-encode</em> the pairs returned:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">swap2 ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">swap2 lte x y k</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">    <span class="fu">|</span> lte x y <span class="fu">=</span> k x y</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">    <span class="fu">|</span> otherwise <span class="fu">=</span> k y x</a>
<a class="sourceLine" id="cb4-5" data-line-number="5"></a>
<a class="sourceLine" id="cb4-6" data-line-number="6"><span class="ot">sort3 ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> (a,a,a) <span class="ot">-&gt;</span> (a,a,a)</a>
<a class="sourceLine" id="cb4-7" data-line-number="7">sort3 lte (_0,_1,_2)</a>
<a class="sourceLine" id="cb4-8" data-line-number="8">    <span class="fu">=</span> swap2 lte _1 _2 <span class="fu">$</span> \ _1 _2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb4-9" data-line-number="9">      swap2 lte _0 _2 <span class="fu">$</span> \ _0 _2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb4-10" data-line-number="10">      swap2 lte _0 _1 <span class="fu">$</span> \ _0 _1 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb4-11" data-line-number="11">      (_0,_1,_2)</a></code></pre></div>
<p>Then, to get this to compile down to efficient code, we can make judicious use of <a href="http://hackage.haskell.org/package/base-4.11.1.0/docs/GHC-Exts.html#v:inline"><code class="sourceCode haskell">inline</code></a> from GHC.Exts:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">import</span> <span class="dt">GHC.Exts</span> (inline)</a>
<a class="sourceLine" id="cb5-2" data-line-number="2"></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="ot">swap2 ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">swap2 lte x y k</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">    <span class="fu">|</span> inline lte x y <span class="fu">=</span> inline k x y</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">    <span class="fu">|</span> otherwise <span class="fu">=</span> inline k y x</a>
<a class="sourceLine" id="cb5-7" data-line-number="7"><span class="ot">{-# INLINE swap2 #-}</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8"></a>
<a class="sourceLine" id="cb5-9" data-line-number="9"><span class="ot">sort3 ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> (a, a, a) <span class="ot">-&gt;</span> (a, a, a)</a>
<a class="sourceLine" id="cb5-10" data-line-number="10">sort3 lte (_0,_1,_2)</a>
<a class="sourceLine" id="cb5-11" data-line-number="11">    <span class="fu">=</span> swap2 lte _1 _2 <span class="fu">$</span> \ _1 _2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb5-12" data-line-number="12">      swap2 lte _0 _2 <span class="fu">$</span> \ _0 _2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb5-13" data-line-number="13">      swap2 lte _0 _1 <span class="fu">$</span> \ _0 _1 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb5-14" data-line-number="14">      (_0,_1,_2)</a>
<a class="sourceLine" id="cb5-15" data-line-number="15"><span class="ot">{-# INLINE sort3 #-}</span></a></code></pre></div>
<p>And to see if this really does make efficient code, let‚Äôs look at the core (cleaned up):</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1">sort3</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  <span class="fu">=</span> \ (<span class="ot">lte ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">      (<span class="ot">ds ::</span> (a, a, a)) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">      <span class="kw">case</span> ds <span class="kw">of</span> wild_X8 (_0, _1, _2) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">      <span class="kw">case</span> lte _1 _2 <span class="kw">of</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">        <span class="dt">False</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb6-7" data-line-number="7">          <span class="kw">case</span> lte _0 _1 <span class="kw">of</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">            <span class="dt">False</span> <span class="ot">-&gt;</span> (_2, _1, _0)</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">            <span class="dt">True</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb6-10" data-line-number="10">              <span class="kw">case</span> lte _0 _2 <span class="kw">of</span></a>
<a class="sourceLine" id="cb6-11" data-line-number="11">                <span class="dt">False</span> <span class="ot">-&gt;</span> (_2, _0, _1)</a>
<a class="sourceLine" id="cb6-12" data-line-number="12">                <span class="dt">True</span> <span class="ot">-&gt;</span> (_0, _2, _1)</a>
<a class="sourceLine" id="cb6-13" data-line-number="13">        <span class="dt">True</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb6-14" data-line-number="14">          <span class="kw">case</span> lte _0 _2 <span class="kw">of</span></a>
<a class="sourceLine" id="cb6-15" data-line-number="15">            <span class="dt">False</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb6-16" data-line-number="16">              <span class="kw">case</span> lte _2 _1 <span class="kw">of</span></a>
<a class="sourceLine" id="cb6-17" data-line-number="17">                <span class="dt">False</span> <span class="ot">-&gt;</span> (_1, _2, _0)</a>
<a class="sourceLine" id="cb6-18" data-line-number="18">                <span class="dt">True</span> <span class="ot">-&gt;</span> (_2, _1, _0)</a>
<a class="sourceLine" id="cb6-19" data-line-number="19">            <span class="dt">True</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb6-20" data-line-number="20">              <span class="kw">case</span> lte _0 _1 <span class="kw">of</span></a>
<a class="sourceLine" id="cb6-21" data-line-number="21">                <span class="dt">False</span> <span class="ot">-&gt;</span> (_1, _0, _2)</a>
<a class="sourceLine" id="cb6-22" data-line-number="22">                <span class="dt">True</span> <span class="ot">-&gt;</span> wild_X8</a></code></pre></div>
<p>Fantastic! When we specialize to <code class="sourceCode haskell"><span class="dt">Int</span></code>, we get all of the proper unpacking:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">sort3Int ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Int</span>, <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">sort3Int <span class="fu">=</span> inline sort3 (<span class="fu">&lt;=</span>)</a></code></pre></div>
<p>Core (with just the variable names cleaned up this time):</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">sort3Int</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  <span class="fu">=</span> \ (<span class="ot">w ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>, <span class="dt">Int</span>)) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">      <span class="kw">case</span> w <span class="kw">of</span> w_X { (_0, _1, _2) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">      <span class="kw">case</span> _0 <span class="kw">of</span> w_0 { <span class="dt">GHC.Types.I</span><span class="fu">#</span> _0U <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5">      <span class="kw">case</span> _1 <span class="kw">of</span> w_1 { <span class="dt">GHC.Types.I</span><span class="fu">#</span> _1U <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">      <span class="kw">case</span> _2 <span class="kw">of</span> w_2 { <span class="dt">GHC.Types.I</span><span class="fu">#</span> _2U <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb8-7" data-line-number="7">      <span class="kw">case</span> <span class="fu">GHC.Prim.&lt;=#</span> _1U _2U <span class="kw">of</span> {</a>
<a class="sourceLine" id="cb8-8" data-line-number="8">        __DEFAULT <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb8-9" data-line-number="9">          <span class="kw">case</span> <span class="fu">GHC.Prim.&lt;=#</span> _0U _1U <span class="kw">of</span> {</a>
<a class="sourceLine" id="cb8-10" data-line-number="10">            __DEFAULT <span class="ot">-&gt;</span> (w_2, w_1, w_0);</a>
<a class="sourceLine" id="cb8-11" data-line-number="11">            <span class="dv">1</span><span class="fu">#</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb8-12" data-line-number="12">              <span class="kw">case</span> <span class="fu">GHC.Prim.&lt;=#</span> _0U _2U <span class="kw">of</span> {</a>
<a class="sourceLine" id="cb8-13" data-line-number="13">                __DEFAULT <span class="ot">-&gt;</span> (w_2, w_0, w_1);</a>
<a class="sourceLine" id="cb8-14" data-line-number="14">                <span class="dv">1</span><span class="fu">#</span> <span class="ot">-&gt;</span> (w_0, w_2, w_1)</a>
<a class="sourceLine" id="cb8-15" data-line-number="15">              }</a>
<a class="sourceLine" id="cb8-16" data-line-number="16">          };</a>
<a class="sourceLine" id="cb8-17" data-line-number="17">        <span class="dv">1</span><span class="fu">#</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb8-18" data-line-number="18">          <span class="kw">case</span> <span class="fu">GHC.Prim.&lt;=#</span> _0U _2U <span class="kw">of</span> {</a>
<a class="sourceLine" id="cb8-19" data-line-number="19">            __DEFAULT <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb8-20" data-line-number="20">              <span class="kw">case</span> <span class="fu">GHC.Prim.&lt;=#</span> _2U _1U <span class="kw">of</span> {</a>
<a class="sourceLine" id="cb8-21" data-line-number="21">                __DEFAULT <span class="ot">-&gt;</span> (w_1, w_2, w_0);</a>
<a class="sourceLine" id="cb8-22" data-line-number="22">                <span class="dv">1</span><span class="fu">#</span> <span class="ot">-&gt;</span> (w_2, w_1, w_0)</a>
<a class="sourceLine" id="cb8-23" data-line-number="23">              };</a>
<a class="sourceLine" id="cb8-24" data-line-number="24">            <span class="dv">1</span><span class="fu">#</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb8-25" data-line-number="25">              <span class="kw">case</span> <span class="fu">GHC.Prim.&lt;=#</span> _0U _1U <span class="kw">of</span> {</a>
<a class="sourceLine" id="cb8-26" data-line-number="26">                __DEFAULT <span class="ot">-&gt;</span> (w_1, w_0, w_2);</a>
<a class="sourceLine" id="cb8-27" data-line-number="27">                <span class="dv">1</span><span class="fu">#</span> <span class="ot">-&gt;</span> w_X</a>
<a class="sourceLine" id="cb8-28" data-line-number="28">              }</a>
<a class="sourceLine" id="cb8-29" data-line-number="29">          }</a>
<a class="sourceLine" id="cb8-30" data-line-number="30">      }</a>
<a class="sourceLine" id="cb8-31" data-line-number="31">      }</a>
<a class="sourceLine" id="cb8-32" data-line-number="32">      }</a>
<a class="sourceLine" id="cb8-33" data-line-number="33">      }</a>
<a class="sourceLine" id="cb8-34" data-line-number="34">      }</a></code></pre></div>
<p>Now, for the real test: sorting 5-tuples, using the network above.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">sort5 ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> (a,a,a,a,a) <span class="ot">-&gt;</span> (a,a,a,a,a)</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">sort5 lte (_0,_1,_2,_3,_4)</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">    <span class="fu">=</span> swap2 lte _0 _1 <span class="fu">$</span> \ _0 _1 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4">      swap2 lte _2 _3 <span class="fu">$</span> \ _2 _3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">      swap2 lte _0 _2 <span class="fu">$</span> \ _0 _2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6">      swap2 lte _1 _3 <span class="fu">$</span> \ _1 _3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-7" data-line-number="7">      swap2 lte _1 _2 <span class="fu">$</span> \ _1 _2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-8" data-line-number="8">      swap2 lte _0 _4 <span class="fu">$</span> \ _0 _4 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-9" data-line-number="9">      swap2 lte _1 _4 <span class="fu">$</span> \ _1 _4 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-10" data-line-number="10">      swap2 lte _2 _4 <span class="fu">$</span> \ _2 _4 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-11" data-line-number="11">      swap2 lte _3 _4 <span class="fu">$</span> \ _3 _4 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-12" data-line-number="12">      (_0,_1,_2,_3,_4)</a>
<a class="sourceLine" id="cb9-13" data-line-number="13"><span class="ot">{-# INLINE sort5 #-}</span></a></code></pre></div>
<p>The core output from this is over 1000 lines long: you can see it (with the variable names cleaned up) <a href="https://gist.github.com/oisdk/ec25d76d918135c4c28777e1b84ead5f">here</a>.</p>
<p>In my benchmarks, these functions are indeed quicker than their counterparts in vector, but I‚Äôm not confident in my knowledge of Haskell performance to make much of a strong statement about them.</p>
]]></description>
    <pubDate>Sun, 06 May 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-05-06-sorting-small.html</guid>
    <dc:creator>Donnacha Ois√≠n Kidney</dc:creator>
</item>
<item>
    <title>Type-Level Induction in Haskell</title>
    <link>https://doisinkidney.com/posts/2018-05-05-induction.html</link>
    <description><![CDATA[<div class="info">
    Posted on May  5, 2018
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Dependent%20Types.html">Dependent Types</a>
    
</div>

<p>The code from this post is available as a <a href="https://gist.github.com/oisdk/23c430b807c788dd43dc4d986c5fdfdd">gist</a>.</p>
<p>One of the most basic tools for use in type-level programming is the Peano definition of the natural numbers:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> ‚Ñï</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Z</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">    <span class="fu">|</span> <span class="dt">S</span> ‚Ñï</a></code></pre></div>
<p>Using the new <code class="sourceCode haskell"><span class="dt">TypeFamilyDependencies</span></code> extension, these numbers can be used to describe the ‚Äúsize‚Äù of some type. I‚Äôm going to use the proportion symbol here:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">type</span> family (t <span class="ot">‚à∑</span> k) ‚àù (n <span class="ot">‚à∑</span> ‚Ñï) <span class="fu">=</span> (a <span class="ot">‚à∑</span> <span class="dt">Type</span>) <span class="fu">|</span> a <span class="ot">‚Üí</span> t n k</a></code></pre></div>
<p>Using this type family we can describe induction on the natural numbers:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Finite</span> n <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">    induction <span class="ot">‚à∑</span> t ‚àù <span class="dt">Z</span> <span class="ot">‚Üí</span> (<span class="ot">‚àÄ</span> k<span class="fu">.</span> t ‚àù k <span class="ot">‚Üí</span> t ‚àù <span class="dt">S</span> k) <span class="ot">‚Üí</span> t ‚àù n</a>
<a class="sourceLine" id="cb3-3" data-line-number="3"></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="kw">instance</span> <span class="dt">Finite</span> <span class="dt">Z</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">    induction z _ <span class="fu">=</span> z</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">    <span class="ot">{-# inline induction #-}</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7"></a>
<a class="sourceLine" id="cb3-8" data-line-number="8"><span class="kw">instance</span> <span class="dt">Finite</span> n <span class="ot">‚áí</span> <span class="dt">Finite</span> (<span class="dt">S</span> n) <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-9" data-line-number="9">    induction z s <span class="fu">=</span> s (induction z s)</a>
<a class="sourceLine" id="cb3-10" data-line-number="10">    <span class="ot">{-# inline induction #-}</span></a></code></pre></div>
<p>The <code class="sourceCode haskell">induction</code> function reads as the standard mathematical definition of induction: given a proof (value) of the zero case, and a proof that any proof is true for its successor, we can give you a proof of the case for any finite number.</p>
<p>An added bonus here is that the size of something can usually be resolved at compile-time, so any inductive function on it should also be resolved at compile time.</p>
<p>We can use it to provide the standard instances for basic length-indexed lists:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:-</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="kw">data</span> <span class="dt">List</span> n a <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">        <span class="dt">Nil</span>  <span class="ot">‚à∑</span> <span class="dt">List</span> <span class="dt">Z</span> a</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">        (<span class="fu">:-</span>) <span class="ot">‚à∑</span> a <span class="ot">‚Üí</span> <span class="dt">List</span> n a <span class="ot">‚Üí</span> <span class="dt">List</span> (<span class="dt">S</span> n) a</a></code></pre></div>
<p>Some instances for those lists are easy:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">List</span> n) <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">    fmap _ <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">    fmap f (x <span class="fu">:-</span> xs) <span class="fu">=</span> f x <span class="fu">:-</span> fmap f xs</a></code></pre></div>
<p>However, for <code class="sourceCode haskell"><span class="dt">Applicative</span></code>, we need some way to recurse on the size of the list. This is where induction comes in.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">type</span> <span class="kw">instance</span> <span class="ch">&#39;(List,a) ‚àù n = List n a</span></a></code></pre></div>
<p>This lets us write <code class="sourceCode haskell">pure</code> in a pleasingly simple way:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Finite</span> n <span class="ot">‚áí</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">         <span class="dt">Applicative</span> (<span class="dt">List</span> n) <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">    pure x <span class="fu">=</span> induction <span class="dt">Nil</span> (x <span class="fu">:-</span>)</a></code></pre></div>
<p>But can we also write <code class="sourceCode haskell"><span class="fu">&lt;*&gt;</span></code> using induction? Yes! Because we‚Äôve factored out the induction itself, we just need to describe the notion of a ‚Äúsized‚Äù function:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">data</span> a ‚Ü¶ b</a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="kw">type</span> <span class="kw">instance</span> ((x <span class="ot">‚à∑</span> a) ‚Ü¶ (y <span class="ot">‚à∑</span> b)) ‚àù n <span class="fu">=</span> (x ‚àù n) <span class="ot">‚Üí</span> (y ‚àù n)</a></code></pre></div>
<p>Then we can write <code class="sourceCode haskell"><span class="fu">&lt;*&gt;</span></code> as so:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Finite</span> n <span class="ot">‚áí</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">         <span class="dt">Applicative</span> (<span class="dt">List</span> n) <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">    pure x <span class="fu">=</span> induction <span class="dt">Nil</span> (x <span class="fu">:-</span>)</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">    (<span class="fu">&lt;*&gt;</span>) <span class="fu">=</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">        induction</a>
<a class="sourceLine" id="cb9-6" data-line-number="6">            (\<span class="dt">Nil</span> <span class="dt">Nil</span> <span class="ot">‚Üí</span> <span class="dt">Nil</span>)</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">            (\k (f <span class="fu">:-</span> fs) (x <span class="fu">:-</span> xs) <span class="ot">‚Üí</span> f x <span class="fu">:-</span> k fs xs)</a></code></pre></div>
<p>What about the <code class="sourceCode haskell"><span class="dt">Monad</span></code> instance? For that, we need a little bit of plumbing: the type signature of <code class="sourceCode haskell"><span class="fu">&gt;&gt;=</span></code> is:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">(<span class="fu">&gt;&gt;=</span>) <span class="ot">‚à∑</span> m a <span class="ot">‚Üí</span> (a <span class="ot">‚Üí</span> m b) <span class="ot">‚Üí</span> m b</a></code></pre></div>
<p>One of the parameters (the second <code>a</code>) doesn‚Äôt have a size: we‚Äôll need to work around that, with <code class="sourceCode haskell"><span class="dt">Const</span></code>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">type</span> <span class="kw">instance</span> (<span class="dt">Const</span> a <span class="ot">‚à∑</span> ‚Ñï <span class="ot">‚Üí</span> <span class="dt">Type</span>) ‚àù n <span class="fu">=</span> <span class="dt">Const</span> a n</a></code></pre></div>
<p>Using this, we can write our <code class="sourceCode haskell"><span class="dt">Monad</span></code> instance:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1">head&#39; <span class="ot">‚à∑</span> <span class="dt">List</span> (<span class="dt">S</span> n) a <span class="ot">‚Üí</span> a</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">head&#39; (x <span class="fu">:-</span> _) <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb12-3" data-line-number="3"></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">tail&#39; <span class="ot">‚à∑</span> <span class="dt">List</span> (<span class="dt">S</span> n) a <span class="ot">‚Üí</span> <span class="dt">List</span> n a</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">tail&#39; (_ <span class="fu">:-</span> xs) <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb12-6" data-line-number="6"></a>
<a class="sourceLine" id="cb12-7" data-line-number="7"><span class="kw">instance</span> <span class="dt">Finite</span> n <span class="ot">‚áí</span></a>
<a class="sourceLine" id="cb12-8" data-line-number="8">         <span class="dt">Monad</span> (<span class="dt">List</span> n) <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-9" data-line-number="9">    xs <span class="fu">&gt;&gt;=</span> (f <span class="ot">‚à∑</span> a <span class="ot">‚Üí</span> <span class="dt">List</span> n b) <span class="fu">=</span></a>
<a class="sourceLine" id="cb12-10" data-line-number="10">        induction</a>
<a class="sourceLine" id="cb12-11" data-line-number="11">            (\<span class="dt">Nil</span> _ <span class="ot">‚Üí</span> <span class="dt">Nil</span>)</a>
<a class="sourceLine" id="cb12-12" data-line-number="12">            (\k (y <span class="fu">:-</span> ys) fn <span class="ot">‚Üí</span> head&#39; (fn (<span class="dt">Const</span> y)) <span class="fu">:-</span></a>
<a class="sourceLine" id="cb12-13" data-line-number="13">                               k ys (tail&#39; <span class="fu">.</span> fn <span class="fu">.</span> <span class="dt">Const</span> <span class="fu">.</span> getConst))</a>
<a class="sourceLine" id="cb12-14" data-line-number="14">            xs</a>
<a class="sourceLine" id="cb12-15" data-line-number="15">            (f <span class="fu">.</span> getConst <span class="ot">‚à∑</span> <span class="dt">Const</span> a n <span class="ot">‚Üí</span> <span class="dt">List</span> n b)</a></code></pre></div>
<h2 id="type-family-dependencies">Type Family Dependencies</h2>
<p>Getting the above to work actually took a surprising amount of work: the crux is that the <code class="sourceCode haskell">‚àù</code> type family needs to be injective, so the ‚Äúsuccessor‚Äù proof can typecheck. Unfortunately, this means that every type can only have one notion of ‚Äúsize‚Äù. What I‚Äôd prefer is to be able to pass in a function indicating exactly <em>how</em> to get the size out of a type, that could change depending on the situation. So we could recurse on the first argument of a function, for instance, or just its second, or just the result. This would need either type-level lambdas (which would be cool), or <a href="https://ghc.haskell.org/trac/ghc/ticket/10832">generalized type family dependencies</a>.</p>
]]></description>
    <pubDate>Sat, 05 May 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-05-05-induction.html</guid>
    <dc:creator>Donnacha Ois√≠n Kidney</dc:creator>
</item>
<item>
    <title>5 Cool Things You Can Do With Pattern Synonyms</title>
    <link>https://doisinkidney.com/posts/2018-04-12-pattern-synonyms.html</link>
    <description><![CDATA[<div class="info">
    Posted on April 12, 2018
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Pattern%20Synonyms.html">Pattern Synonyms</a>
    
</div>

<p><a href="https://ghc.haskell.org/trac/ghc/wiki/PatternSynonyms">Pattern Synonyms</a> is an excellent extension for Haskell. There are some <a href="https://ocharles.org.uk/blog/posts/2014-12-03-pattern-synonyms.html">very</a> <a href="https://www.schoolofhaskell.com/user/icelandj/Pattern%20synonyms">cool</a> examples of their use out there, and I thought I‚Äôd add to the list.</p>
<h1 id="make-things-look-like-lists">Make Things Look Like Lists</h1>
<p>Lists are <em>the</em> fundamental data structure for functional programmers. Unfortunately, once more specialized structures are required, you often have to switch over to an uncomfortable, annoying API which isn‚Äôt as pleasant or fun to use as cons and nil. With pattern synonyms, though, that‚Äôs not so! For instance, here‚Äôs how you would do it with a run-length-encoded list:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> <span class="dt">List</span> a</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">    <span class="fu">|</span> <span class="dt">ConsN</span> <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">Int</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">            a</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">            (<span class="dt">List</span> a)</a>
<a class="sourceLine" id="cb1-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="ot">cons ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a</a>
<a class="sourceLine" id="cb1-8" data-line-number="8">cons x (<span class="dt">ConsN</span> i y ys)</a>
<a class="sourceLine" id="cb1-9" data-line-number="9">  <span class="fu">|</span> x <span class="fu">==</span> y <span class="fu">=</span> <span class="dt">ConsN</span> (i<span class="fu">+</span><span class="dv">1</span>) y ys</a>
<a class="sourceLine" id="cb1-10" data-line-number="10">cons x xs <span class="fu">=</span> <span class="dt">ConsN</span> <span class="dv">1</span> x xs</a>
<a class="sourceLine" id="cb1-11" data-line-number="11"></a>
<a class="sourceLine" id="cb1-12" data-line-number="12"><span class="ot">uncons ::</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, <span class="dt">List</span> a)</a>
<a class="sourceLine" id="cb1-13" data-line-number="13">uncons <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb1-14" data-line-number="14">uncons (<span class="dt">ConsN</span> <span class="dv">1</span> x xs) <span class="fu">=</span> <span class="dt">Just</span> (x, xs)</a>
<a class="sourceLine" id="cb1-15" data-line-number="15">uncons (<span class="dt">ConsN</span> n x xs) <span class="fu">=</span> <span class="dt">Just</span> (x, <span class="dt">ConsN</span> (n<span class="fu">-</span><span class="dv">1</span>) x xs)</a>
<a class="sourceLine" id="cb1-16" data-line-number="16"></a>
<a class="sourceLine" id="cb1-17" data-line-number="17"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:-</span></a>
<a class="sourceLine" id="cb1-18" data-line-number="18">pattern<span class="ot"> (:-) ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a</a>
<a class="sourceLine" id="cb1-19" data-line-number="19">pattern x <span class="fu">:-</span> xs <span class="ot">&lt;-</span> (uncons <span class="ot">-&gt;</span> <span class="dt">Just</span> (x, xs))</a>
<a class="sourceLine" id="cb1-20" data-line-number="20">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-21" data-line-number="21">    x <span class="fu">:-</span> xs <span class="fu">=</span> cons x xs</a>
<a class="sourceLine" id="cb1-22" data-line-number="22"><span class="ot">{-# COMPLETE Nil, (:-) #-}</span></a>
<a class="sourceLine" id="cb1-23" data-line-number="23"></a>
<a class="sourceLine" id="cb1-24" data-line-number="24">zip<span class="ot"> ::</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> b <span class="ot">-&gt;</span> <span class="dt">List</span> (a,b)</a>
<a class="sourceLine" id="cb1-25" data-line-number="25">zip (x <span class="fu">:-</span> xs) (y <span class="fu">:-</span> ys) <span class="fu">=</span> (x,y) <span class="fu">:-</span> zip xs ys</a>
<a class="sourceLine" id="cb1-26" data-line-number="26">zip _ _ <span class="fu">=</span> <span class="dt">Nil</span></a></code></pre></div>
<p>A little more useful would be to do the same with a heap:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Leaf</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">    <span class="fu">|</span> <span class="dt">Node</span> a (<span class="dt">Tree</span> a) (<span class="dt">Tree</span> a)</a>
<a class="sourceLine" id="cb2-4" data-line-number="4"></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="ot">smerge ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">smerge <span class="dt">Leaf</span> ys <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">smerge xs <span class="dt">Leaf</span> <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">smerge h1<span class="fu">@</span>(<span class="dt">Node</span> x lx rx) h2<span class="fu">@</span>(<span class="dt">Node</span> y ly ry)</a>
<a class="sourceLine" id="cb2-9" data-line-number="9">  <span class="fu">|</span> x <span class="fu">&lt;=</span> y    <span class="fu">=</span> <span class="dt">Node</span> x (smerge h2 rx) lx</a>
<a class="sourceLine" id="cb2-10" data-line-number="10">  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Node</span> y (smerge h1 ry) ly</a>
<a class="sourceLine" id="cb2-11" data-line-number="11"></a>
<a class="sourceLine" id="cb2-12" data-line-number="12"><span class="ot">cons ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb2-13" data-line-number="13">cons x <span class="fu">=</span> smerge (<span class="dt">Node</span> x <span class="dt">Leaf</span> <span class="dt">Leaf</span>)</a>
<a class="sourceLine" id="cb2-14" data-line-number="14"></a>
<a class="sourceLine" id="cb2-15" data-line-number="15"><span class="ot">uncons ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, <span class="dt">Tree</span> a)</a>
<a class="sourceLine" id="cb2-16" data-line-number="16">uncons <span class="dt">Leaf</span> <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb2-17" data-line-number="17">uncons (<span class="dt">Node</span> x l r) <span class="fu">=</span> <span class="dt">Just</span> (x, smerge l r)</a>
<a class="sourceLine" id="cb2-18" data-line-number="18"></a>
<a class="sourceLine" id="cb2-19" data-line-number="19"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:-</span></a>
<a class="sourceLine" id="cb2-20" data-line-number="20">pattern<span class="ot"> (:-) ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb2-21" data-line-number="21">pattern x <span class="fu">:-</span> xs <span class="ot">&lt;-</span> (uncons <span class="ot">-&gt;</span> <span class="dt">Just</span> (x, xs))</a>
<a class="sourceLine" id="cb2-22" data-line-number="22">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-23" data-line-number="23">    x <span class="fu">:-</span> xs <span class="fu">=</span> cons x xs</a>
<a class="sourceLine" id="cb2-24" data-line-number="24"><span class="ot">{-# COMPLETE Leaf, (:-) #-}</span></a>
<a class="sourceLine" id="cb2-25" data-line-number="25"></a>
<a class="sourceLine" id="cb2-26" data-line-number="26">sort<span class="ot"> ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb2-27" data-line-number="27">sort <span class="fu">=</span> go <span class="fu">.</span> foldr (<span class="fu">:-</span>) <span class="dt">Leaf</span></a>
<a class="sourceLine" id="cb2-28" data-line-number="28">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-29" data-line-number="29">    go <span class="dt">Leaf</span> <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb2-30" data-line-number="30">    go (x <span class="fu">:-</span> xs) <span class="fu">=</span> x <span class="fu">:</span> go xs</a></code></pre></div>
<p>In fact, this pattern can be generalized, so <em>any</em> container-like-thing with a cons-like-thing can be modified as you would with lists. You can see the generalization in <a href="https://hackage.haskell.org/package/lens-4.16.1/docs/Control-Lens-Cons.html#v::-60-">lens</a>.</p>
<h1 id="retroactively-make-lyah-examples-work">Retroactively Make <a href="http://learnyouahaskell.com">LYAH</a> Examples Work</h1>
<p>One of the most confusing things I remember about learning Haskell early-on was that the vast majority of the Monads examples didn‚Äôt work, because they were written pre-transformers. In other words, the state monad was defined like so:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">State</span> s a <span class="fu">=</span> <span class="dt">State</span> {<span class="ot"> runState ::</span> s <span class="ot">-&gt;</span> (a, s) }</a></code></pre></div>
<p>But in transformers nowadays (which is where you get <code class="sourceCode haskell"><span class="dt">State</span></code> from if you import it in the normal way), the definition is:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">StateT</span> s m a <span class="fu">=</span> <span class="dt">StateT</span> {<span class="ot"> runStateT ::</span> s <span class="ot">-&gt;</span> m (a, s) }</a>
<a class="sourceLine" id="cb4-2" data-line-number="2"></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="kw">type</span> <span class="dt">State</span> s <span class="fu">=</span> <span class="dt">StateT</span> s <span class="dt">Identity</span></a></code></pre></div>
<p>This results in some <em>very</em> confusing error messages when you try run example code.</p>
<p>However, we can pretend that the change never happened, with a simple pattern synonym:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">StateT</span> s m a <span class="fu">=</span> <span class="dt">StateT</span> {<span class="ot"> runStateT ::</span> s <span class="ot">-&gt;</span> m (a, s) }</a>
<a class="sourceLine" id="cb5-2" data-line-number="2"></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="kw">type</span> <span class="dt">State</span> s <span class="fu">=</span> <span class="dt">StateT</span> s <span class="dt">Identity</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4"></a>
<a class="sourceLine" id="cb5-5" data-line-number="5"><span class="ot">runState ::</span> <span class="dt">State</span> s a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> (a, s)</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">runState xs <span class="fu">=</span> runIdentity <span class="fu">.</span> runStateT xs</a>
<a class="sourceLine" id="cb5-7" data-line-number="7"></a>
<a class="sourceLine" id="cb5-8" data-line-number="8">pattern <span class="dt">State</span><span class="ot"> ::</span> (s <span class="ot">-&gt;</span> (a, s)) <span class="ot">-&gt;</span> <span class="dt">State</span> s a</a>
<a class="sourceLine" id="cb5-9" data-line-number="9">pattern <span class="dt">State</span> x <span class="ot">&lt;-</span> (runState <span class="ot">-&gt;</span> x)</a>
<a class="sourceLine" id="cb5-10" data-line-number="10">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-11" data-line-number="11">    <span class="dt">State</span> x <span class="fu">=</span> <span class="dt">StateT</span> (<span class="dt">Identity</span> <span class="fu">.</span> x)</a></code></pre></div>
<h1 id="getting-type-level-numbers-with-an-efficient-runtime-representation">Getting Type-Level Numbers With an Efficient Runtime Representation</h1>
<p>If you want to write type-level proofs on numbers, you‚Äôll probably end up using Peano numerals and singletons:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Nat</span> <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">|</span> <span class="dt">S</span> <span class="dt">Nat</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Natty</span> n <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">  <span class="dt">Zy</span><span class="ot"> ::</span> <span class="dt">Natty</span> <span class="dt">Z</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">  <span class="dt">Sy</span><span class="ot"> ::</span> <span class="dt">Natty</span> n <span class="ot">-&gt;</span> <span class="dt">Natty</span> (<span class="dt">S</span> n)</a>
<a class="sourceLine" id="cb6-6" data-line-number="6"></a>
<a class="sourceLine" id="cb6-7" data-line-number="7"><span class="kw">type</span> family (<span class="fu">+</span>) (<span class="ot">n ::</span> <span class="dt">Nat</span>) (<span class="ot">m ::</span> <span class="dt">Nat</span>)<span class="ot"> ::</span> <span class="dt">Nat</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">  <span class="dt">Z</span> <span class="fu">+</span> m <span class="fu">=</span> m</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">  <span class="dt">S</span> n <span class="fu">+</span> m <span class="fu">=</span> <span class="dt">S</span> (n <span class="fu">+</span> m)</a>
<a class="sourceLine" id="cb6-10" data-line-number="10"></a>
<a class="sourceLine" id="cb6-11" data-line-number="11"><span class="ot">plusZeroIsZero ::</span> <span class="dt">Natty</span> n <span class="ot">-&gt;</span> n <span class="fu">+</span> <span class="dt">Z</span> <span class="fu">:~:</span> n</a>
<a class="sourceLine" id="cb6-12" data-line-number="12">plusZeroIsZero <span class="dt">Zy</span> <span class="fu">=</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb6-13" data-line-number="13">plusZeroIsZero (<span class="dt">Sy</span> n) <span class="fu">=</span> <span class="kw">case</span> plusZeroIsZero n <span class="kw">of</span></a>
<a class="sourceLine" id="cb6-14" data-line-number="14">  <span class="dt">Refl</span> <span class="ot">-&gt;</span> <span class="dt">Refl</span></a></code></pre></div>
<p>Pretty cool, right? We can even erase the proof (if we really trust it) using rewrite rules:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">{-# RULES </span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="ot">&quot;plusZeroIsZero&quot; forall n. plusZeroIsZero n = unsafeCoerce Refl</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="ot">#-}</span></a></code></pre></div>
<p>This isn‚Äôt <em>ideal</em>, but it‚Äôs getting there.</p>
<p>However, if we ever want to use these things at runtime (perhaps as a type-level indication of some data structure‚Äôs size), we‚Äôre going to rely on the value-level Peano addition, which is bad news.</p>
<p>Not so with pattern synonyms!</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">data</span> family <span class="dt">The</span><span class="ot"> k ::</span> k <span class="ot">-&gt;</span> <span class="dt">Type</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"></a>
<a class="sourceLine" id="cb8-3" data-line-number="3"><span class="kw">class</span> <span class="dt">Sing</span> (<span class="ot">a ::</span> k) <span class="kw">where</span><span class="ot"> sing ::</span> <span class="dt">The</span> k (<span class="ot">a ::</span> k)</a>
<a class="sourceLine" id="cb8-4" data-line-number="4"></a>
<a class="sourceLine" id="cb8-5" data-line-number="5"><span class="kw">data</span> <span class="dt">Nat</span> <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">|</span> <span class="dt">S</span> <span class="dt">Nat</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6"></a>
<a class="sourceLine" id="cb8-7" data-line-number="7"><span class="kw">newtype</span> <span class="kw">instance</span> <span class="dt">The</span> <span class="dt">Nat</span> n <span class="fu">=</span> <span class="dt">NatSing</span> <span class="dt">Natural</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8"></a>
<a class="sourceLine" id="cb8-9" data-line-number="9"><span class="kw">instance</span> <span class="dt">Sing</span> <span class="dt">Z</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-10" data-line-number="10">    sing <span class="fu">=</span> <span class="dt">NatSing</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb8-11" data-line-number="11"></a>
<a class="sourceLine" id="cb8-12" data-line-number="12"><span class="kw">instance</span> <span class="dt">Sing</span> n <span class="ot">=&gt;</span> <span class="dt">Sing</span> (<span class="dt">S</span> n) <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-13" data-line-number="13">    sing <span class="fu">=</span></a>
<a class="sourceLine" id="cb8-14" data-line-number="14">        (<span class="ot">coerce ::</span> (<span class="dt">Natural</span> <span class="ot">-&gt;</span> <span class="dt">Natural</span>) <span class="ot">-&gt;</span> (<span class="dt">The</span> <span class="dt">Nat</span> n <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> (<span class="dt">S</span> n)))</a>
<a class="sourceLine" id="cb8-15" data-line-number="15">            succ sing</a>
<a class="sourceLine" id="cb8-16" data-line-number="16"></a>
<a class="sourceLine" id="cb8-17" data-line-number="17"><span class="kw">data</span> <span class="dt">Natty</span> n <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-18" data-line-number="18">        <span class="dt">ZZy</span><span class="ot"> ::</span> <span class="dt">Natty</span> <span class="dt">Z</span></a>
<a class="sourceLine" id="cb8-19" data-line-number="19">        <span class="dt">SSy</span><span class="ot"> ::</span> <span class="dt">The</span> <span class="dt">Nat</span> n <span class="ot">-&gt;</span> <span class="dt">Natty</span> (<span class="dt">S</span> n)</a>
<a class="sourceLine" id="cb8-20" data-line-number="20"></a>
<a class="sourceLine" id="cb8-21" data-line-number="21"><span class="ot">getNatty ::</span> <span class="dt">The</span> <span class="dt">Nat</span> n <span class="ot">-&gt;</span> <span class="dt">Natty</span> n</a>
<a class="sourceLine" id="cb8-22" data-line-number="22">getNatty (<span class="dt">NatSing</span><span class="ot"> n ::</span> <span class="dt">The</span> <span class="dt">Nat</span> n) <span class="fu">=</span> <span class="kw">case</span> n <span class="kw">of</span></a>
<a class="sourceLine" id="cb8-23" data-line-number="23">  <span class="dv">0</span> <span class="ot">-&gt;</span> gcastWith (unsafeCoerce <span class="dt">Refl</span><span class="ot"> ::</span> n <span class="fu">:~:</span> <span class="dt">Z</span>) <span class="dt">ZZy</span></a>
<a class="sourceLine" id="cb8-24" data-line-number="24">  _ <span class="ot">-&gt;</span> gcastWith (unsafeCoerce <span class="dt">Refl</span><span class="ot"> ::</span> n <span class="fu">:~:</span> <span class="dt">S</span> m) (<span class="dt">SSy</span> (<span class="dt">NatSing</span> (pred n)))</a>
<a class="sourceLine" id="cb8-25" data-line-number="25"></a>
<a class="sourceLine" id="cb8-26" data-line-number="26">pattern <span class="dt">Zy</span><span class="ot"> ::</span> () <span class="ot">=&gt;</span> (n <span class="fu">~</span> <span class="dt">Z</span>) <span class="ot">=&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> n</a>
<a class="sourceLine" id="cb8-27" data-line-number="27">pattern <span class="dt">Zy</span> <span class="ot">&lt;-</span> (getNatty <span class="ot">-&gt;</span> <span class="dt">ZZy</span>) <span class="kw">where</span> <span class="dt">Zy</span> <span class="fu">=</span> <span class="dt">NatSing</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb8-28" data-line-number="28"></a>
<a class="sourceLine" id="cb8-29" data-line-number="29">pattern <span class="dt">Sy</span><span class="ot"> ::</span> () <span class="ot">=&gt;</span> (n <span class="fu">~</span> <span class="dt">S</span> m) <span class="ot">=&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> m <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> n</a>
<a class="sourceLine" id="cb8-30" data-line-number="30">pattern <span class="dt">Sy</span> x <span class="ot">&lt;-</span> (getNatty <span class="ot">-&gt;</span> <span class="dt">SSy</span> x) <span class="kw">where</span> <span class="dt">Sy</span> (<span class="dt">NatSing</span> x) <span class="fu">=</span> <span class="dt">NatSing</span> (succ x)</a>
<a class="sourceLine" id="cb8-31" data-line-number="31"><span class="ot">{-# COMPLETE Zy, Sy #-}</span></a>
<a class="sourceLine" id="cb8-32" data-line-number="32"></a>
<a class="sourceLine" id="cb8-33" data-line-number="33"><span class="kw">type</span> family (<span class="fu">+</span>) (<span class="ot">n ::</span> <span class="dt">Nat</span>) (<span class="ot">m ::</span> <span class="dt">Nat</span>)<span class="ot"> ::</span> <span class="dt">Nat</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-34" data-line-number="34">        <span class="dt">Z</span> <span class="fu">+</span> m <span class="fu">=</span> m</a>
<a class="sourceLine" id="cb8-35" data-line-number="35">        <span class="dt">S</span> n <span class="fu">+</span> m <span class="fu">=</span> <span class="dt">S</span> (n <span class="fu">+</span> m)</a>
<a class="sourceLine" id="cb8-36" data-line-number="36"></a>
<a class="sourceLine" id="cb8-37" data-line-number="37"><span class="co">-- | Efficient addition, with type-level proof.</span></a>
<a class="sourceLine" id="cb8-38" data-line-number="38"><span class="ot">add ::</span> <span class="dt">The</span> <span class="dt">Nat</span> n <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> m <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> (n <span class="fu">+</span> m)</a>
<a class="sourceLine" id="cb8-39" data-line-number="39">add <span class="fu">=</span> (<span class="ot">coerce ::</span> (<span class="dt">Natural</span> <span class="ot">-&gt;</span> <span class="dt">Natural</span> <span class="ot">-&gt;</span> <span class="dt">Natural</span>)</a>
<a class="sourceLine" id="cb8-40" data-line-number="40">              <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> n <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> m <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> (n <span class="fu">+</span> m)) (<span class="fu">+</span>)</a>
<a class="sourceLine" id="cb8-41" data-line-number="41"></a>
<a class="sourceLine" id="cb8-42" data-line-number="42"><span class="co">-- | Proof on efficient representation.</span></a>
<a class="sourceLine" id="cb8-43" data-line-number="43"><span class="ot">addZeroRight ::</span> <span class="dt">The</span> <span class="dt">Nat</span> n <span class="ot">-&gt;</span> n <span class="fu">+</span> <span class="dt">Z</span> <span class="fu">:~:</span> n</a>
<a class="sourceLine" id="cb8-44" data-line-number="44">addZeroRight <span class="dt">Zy</span> <span class="fu">=</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb8-45" data-line-number="45">addZeroRight (<span class="dt">Sy</span> n) <span class="fu">=</span> gcastWith (addZeroRight n) <span class="dt">Refl</span></a></code></pre></div>
<p>(unfortunately, incomplete pattern warnings don‚Äôt work here)</p>
<h1 id="hide-your-implementations">Hide Your Implementations</h1>
<p>So you‚Äôve got a tree type:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Tip</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">    <span class="fu">|</span> <span class="dt">Bin</span> a (<span class="dt">Tree</span> a) (<span class="dt">Tree</span> a)</a></code></pre></div>
<p>And you‚Äôve spent some time writing a (reasonably difficult) function on the tree:</p>
<details>
<p><summary> Complicated function on the tree </summary></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">showTree ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">showTree <span class="dt">Tip</span> <span class="fu">=</span> <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3">showTree (<span class="dt">Bin</span> x&#39; ls&#39; rs&#39;) <span class="fu">=</span> go <span class="dt">True</span> id xlen&#39; ls&#39;</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">                          <span class="fu">$</span> showString xshw&#39;</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">                          <span class="fu">$</span> endc ls&#39; rs&#39;</a>
<a class="sourceLine" id="cb10-6" data-line-number="6">                          <span class="fu">$</span> showChar <span class="ch">&#39;\n&#39;</span></a>
<a class="sourceLine" id="cb10-7" data-line-number="7">                          <span class="fu">$</span> go <span class="dt">False</span> id xlen&#39; rs&#39; <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb10-8" data-line-number="8">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-9" data-line-number="9">    xshw&#39; <span class="fu">=</span> show x&#39;</a>
<a class="sourceLine" id="cb10-10" data-line-number="10">    xlen&#39; <span class="fu">=</span> length xshw&#39;</a>
<a class="sourceLine" id="cb10-11" data-line-number="11"></a>
<a class="sourceLine" id="cb10-12" data-line-number="12">    go _ _ _ <span class="dt">Tip</span> <span class="fu">=</span> id</a>
<a class="sourceLine" id="cb10-13" data-line-number="13">    go up k i (<span class="dt">Bin</span> x ls rs) <span class="fu">=</span> branch <span class="dt">True</span> ls</a>
<a class="sourceLine" id="cb10-14" data-line-number="14">                            <span class="fu">.</span> k</a>
<a class="sourceLine" id="cb10-15" data-line-number="15">                            <span class="fu">.</span> pad i</a>
<a class="sourceLine" id="cb10-16" data-line-number="16">                            <span class="fu">.</span> showChar (bool <span class="ch">&#39;‚îî&#39;</span> <span class="ch">&#39;‚îå&#39;</span> up)</a>
<a class="sourceLine" id="cb10-17" data-line-number="17">                            <span class="fu">.</span> showString xshw</a>
<a class="sourceLine" id="cb10-18" data-line-number="18">                            <span class="fu">.</span> endc ls rs</a>
<a class="sourceLine" id="cb10-19" data-line-number="19">                            <span class="fu">.</span> showChar <span class="ch">&#39;\n&#39;</span></a>
<a class="sourceLine" id="cb10-20" data-line-number="20">                            <span class="fu">.</span> branch <span class="dt">False</span> rs</a>
<a class="sourceLine" id="cb10-21" data-line-number="21">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-22" data-line-number="22">        xshw <span class="fu">=</span> show x</a>
<a class="sourceLine" id="cb10-23" data-line-number="23">        xlen <span class="fu">=</span> length xshw</a>
<a class="sourceLine" id="cb10-24" data-line-number="24">        branch d</a>
<a class="sourceLine" id="cb10-25" data-line-number="25">          <span class="fu">|</span> d <span class="fu">==</span> up <span class="fu">=</span> go d (k <span class="fu">.</span> pad i) (xlen <span class="fu">+</span> <span class="dv">1</span>) </a>
<a class="sourceLine" id="cb10-26" data-line-number="26">          <span class="fu">|</span> otherwise <span class="fu">=</span> go d (k <span class="fu">.</span> pad i <span class="fu">.</span> showChar <span class="ch">&#39;‚îÇ&#39;</span>) xlen </a>
<a class="sourceLine" id="cb10-27" data-line-number="27"></a>
<a class="sourceLine" id="cb10-28" data-line-number="28">    endc <span class="dt">Tip</span>    <span class="dt">Tip</span>    <span class="fu">=</span> id</a>
<a class="sourceLine" id="cb10-29" data-line-number="29">    endc <span class="dt">Bin</span> {} <span class="dt">Tip</span>    <span class="fu">=</span> showChar <span class="ch">&#39;‚îò&#39;</span></a>
<a class="sourceLine" id="cb10-30" data-line-number="30">    endc <span class="dt">Tip</span>    <span class="dt">Bin</span> {} <span class="fu">=</span> showChar <span class="ch">&#39;‚îê&#39;</span></a>
<a class="sourceLine" id="cb10-31" data-line-number="31">    endc <span class="dt">Bin</span> {} <span class="dt">Bin</span> {} <span class="fu">=</span> showChar <span class="ch">&#39;‚î§&#39;</span></a>
<a class="sourceLine" id="cb10-32" data-line-number="32"></a>
<a class="sourceLine" id="cb10-33" data-line-number="33">    pad <span class="fu">=</span> (<span class="fu">++</span>) <span class="fu">.</span> flip replicate <span class="ch">&#39; &#39;</span></a></code></pre></div>
</details>
<p>But, for some reason or another, you need to add a field to your <code class="sourceCode haskell"><span class="dt">Bin</span></code> constructor, to store the size of the subtree (for instance). Does this function have to change? No! Simply change the tree definition as so:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Tip</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">    <span class="fu">|</span> <span class="dt">Bin&#39;</span> <span class="dt">Int</span> a (<span class="dt">Tree</span> a) (<span class="dt">Tree</span> a)</a>
<a class="sourceLine" id="cb11-4" data-line-number="4"></a>
<a class="sourceLine" id="cb11-5" data-line-number="5">pattern <span class="dt">Bin</span> x ls rs <span class="ot">&lt;-</span> <span class="dt">Bin&#39;</span> n x ls rs</a>
<a class="sourceLine" id="cb11-6" data-line-number="6"><span class="ot">{-# COMPLETE Tip, Bin #-}</span></a></code></pre></div>
<p>And all the old code works!</p>
<p>This gets to the core of pattern synonyms: it‚Äôs another tool which we can use to separate implementation from API.</p>
<h1 id="better-smart-constructors">Better Smart Constructors</h1>
<p>Say you‚Äôve got a data type that has certain constraints on what values it can hold. You‚Äôre not writing a paper for ICFP, so expressing those constraints as a beautiful type isn‚Äôt required: you just want to only export the constructor and accessors, and write some tests to make sure that those functions always obey the constraints.</p>
<p>But once you do this you‚Äôve lost something: pattern-matching. Let‚Äôs get it back with pattern synonyms!</p>
<p>As our simple example, our constraint is going to be ‚ÄúA list where the values are always ordered‚Äù:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">List</span> a <span class="fu">=</span> <span class="dt">List</span> {<span class="ot"> getList ::</span> [a] }</a>
<a class="sourceLine" id="cb12-2" data-line-number="2"></a>
<a class="sourceLine" id="cb12-3" data-line-number="3"><span class="ot">cons ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a</a>
<a class="sourceLine" id="cb12-4" data-line-number="4">cons x (<span class="dt">List</span> xs) <span class="fu">=</span> <span class="dt">List</span> (insert x xs)</a>
<a class="sourceLine" id="cb12-5" data-line-number="5"></a>
<a class="sourceLine" id="cb12-6" data-line-number="6"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:-</span></a>
<a class="sourceLine" id="cb12-7" data-line-number="7">pattern<span class="ot"> (:-) ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a</a>
<a class="sourceLine" id="cb12-8" data-line-number="8">pattern x <span class="fu">:-</span> xs <span class="ot">&lt;-</span> (<span class="dt">List</span> (x<span class="fu">:</span>xs))</a>
<a class="sourceLine" id="cb12-9" data-line-number="9">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-10" data-line-number="10">    x <span class="fu">:-</span> xs <span class="fu">=</span> cons x xs</a>
<a class="sourceLine" id="cb12-11" data-line-number="11"></a>
<a class="sourceLine" id="cb12-12" data-line-number="12">pattern <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">List</span> []</a>
<a class="sourceLine" id="cb12-13" data-line-number="13"><span class="ot">{-# COMPLETE Nil, (:-) #-}</span></a></code></pre></div>
]]></description>
    <pubDate>Thu, 12 Apr 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-04-12-pattern-synonyms.html</guid>
    <dc:creator>Donnacha Ois√≠n Kidney</dc:creator>
</item>
<item>
    <title>Countdown</title>
    <link>https://doisinkidney.com/posts/2018-03-20-countdown.html</link>
    <description><![CDATA[<div class="info">
    Posted on March 20, 2018
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Algorithms.html">Algorithms</a>
    
</div>

<p>There‚Äôs a popular UK TV show called <a href="https://en.wikipedia.org/wiki/Countdown_(game_show)">Countdown</a> with a round where contestants have to get as close to some target number as possible by constructing an arithmetic expression from six random numbers.</p>
<p>You don‚Äôt have to use all of the numbers, and you‚Äôre allowed use four operations: addition, subtraction, multiplication, and division. Additionally, each stage of the calculation must result in a positive integer.</p>
<p>Here‚Äôs an example. Try get to the target 586:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mo>,</mo><mn>25</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>5</mn><mo>,</mo><mn>3</mn><mo>,</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">100,25,1,5,3,10</annotation></semantics></math></p>
<p>On the show, contestants get 30 seconds to think of an answer.</p>
<details>
<summary> Solution </summary> <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>25</mn><mo>*</mo><mn>3</mn><mo>+</mo><mn>10</mn><mo>+</mo><mn>100</mn><mo>*</mo><mn>5</mn><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">25 * 3 + 10 + 100 * 5 + 1</annotation></semantics></math>
</details>
<p>Solving it in Haskell was first explored in depth in <span class="citation" data-cites="hutton_countdown_2002">Hutton (<a href="#ref-hutton_countdown_2002">2002</a>)</span>. There, a basic ‚Äúgenerate-and-test‚Äù implementation was provided and proven correct.</p>
<p>As an optimization problem, there are several factors which will influence the choice of algorithm:</p>
<ol type="1">
<li>There‚Äôs no obvious heuristic for constructing subexpressions in order to get to a final result. In other words, if we have <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>25</mn><mo>*</mo><mn>3</mn><mo>+</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">25 * 3 + 10</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>25</mn><mo>*</mo><mn>3</mn><mo>*</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">25 * 3 * 10</annotation></semantics></math>, there‚Äôs no easy way to tell which is ‚Äúcloser‚Äù to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>586</mn><annotation encoding="application/x-tex">586</annotation></semantics></math>. The latter is closer numerically, but the former is what we ended up using in the solution.</li>
<li>Because certain subexpressions aren‚Äôt allowed, we‚Äôll be able to prune the search space as we go.</li>
<li>Ideally, we‚Äôd only want to calculate each possible subexpression once, making it a pretty standard dynamic programming problem.</li>
</ol>
<p>I‚Äôll be focusing on the third point in this post, but we can add the second point in at the end. First, however, let‚Äôs write a naive implementation.</p>
<h2 id="generating-all-expressions">Generating all Expressions</h2>
<p>I can‚Äôt think of a simpler way to solve the problem than generate-and-test, so we‚Äôll work from there. Testing is easy (<code class="sourceCode haskell">(target <span class="fu">==</span>) <span class="fu">.</span> eval</code>), so we‚Äôll focus on generation. The core function we‚Äôll use for this is usually called ‚Äúunmerges‚Äù:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1">unmerges [x,y] <span class="fu">=</span> [([x],[y])]</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">unmerges (x<span class="fu">:</span>xs) <span class="fu">=</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">    ([x],xs) <span class="fu">:</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">    concat</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">        [ [(x<span class="fu">:</span>ys,zs),(ys,x<span class="fu">:</span>zs)]</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">        <span class="fu">|</span> (ys,zs) <span class="ot">&lt;-</span> unmerges xs ]</a>
<a class="sourceLine" id="cb1-7" data-line-number="7">unmerges _ <span class="fu">=</span> []</a></code></pre></div>
<p>It generates all possible 2-partitions of a list, ignoring order:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> unmerges <span class="st">&quot;abc&quot;</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">[(<span class="st">&quot;a&quot;</span>,<span class="st">&quot;bc&quot;</span>),(<span class="st">&quot;ab&quot;</span>,<span class="st">&quot;c&quot;</span>),(<span class="st">&quot;b&quot;</span>,<span class="st">&quot;ac&quot;</span>)]</a></code></pre></div>
<p>I haven‚Äôt looked much into how to optimize this function or make it nicer, as we‚Äôll be swapping it out later.</p>
<p>Next, we need to make the recursive calls:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">allExprs ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a]) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">allExprs _ [x] <span class="fu">=</span> [x]</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">allExprs c xs <span class="fu">=</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">    [ e</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">    <span class="fu">|</span> (ys,zs) <span class="ot">&lt;-</span> unmerges xs</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">    , y <span class="ot">&lt;-</span> allExprs c ys</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">    , z <span class="ot">&lt;-</span> allExprs c zs</a>
<a class="sourceLine" id="cb3-8" data-line-number="8">    , e <span class="ot">&lt;-</span> c y z ]</a></code></pre></div>
<p>Finally, using the <a href="https://hackage.haskell.org/package/simple-reflect">simple-reflect</a> library, we can take a look at the output:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> allExprs (\x y <span class="ot">-&gt;</span> [x<span class="fu">+</span>y,x<span class="fu">*</span>y]) [<span class="dv">1</span>,<span class="dv">2</span>]<span class="ot"> ::</span> [<span class="dt">Expr</span>]</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">[<span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span>,<span class="dv">1</span> <span class="fu">*</span> <span class="dv">2</span>]</a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="fu">&gt;&gt;&gt;</span> allExprs (\x y <span class="ot">-&gt;</span> [x<span class="fu">+</span>y]) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]<span class="ot"> ::</span> [<span class="dt">Expr</span>]</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">[<span class="dv">1</span> <span class="fu">+</span> (<span class="dv">2</span> <span class="fu">+</span> <span class="dv">3</span>),<span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span> <span class="fu">+</span> <span class="dv">3</span>,<span class="dv">2</span> <span class="fu">+</span> (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">3</span>)]</a></code></pre></div>
<p>Even at this early stage, we can actually already write a rudimentary solution:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">countdown ::</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> [<span class="dt">Expr</span>]</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">countdown xs targ <span class="fu">=</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">    filter</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">        ((<span class="fu">==</span>) targ <span class="fu">.</span> toInteger)</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">        (allExprs</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">             (\x y <span class="ot">-&gt;</span> [x,y,x<span class="fu">+</span>y,x<span class="fu">*</span>y])</a>
<a class="sourceLine" id="cb5-7" data-line-number="7">             (map fromInteger xs))</a>
<a class="sourceLine" id="cb5-8" data-line-number="8"></a>
<a class="sourceLine" id="cb5-9" data-line-number="9"><span class="fu">&gt;&gt;&gt;</span> mapM_ print (countdown [<span class="dv">100</span>,<span class="dv">25</span>,<span class="dv">1</span>,<span class="dv">5</span>,<span class="dv">3</span>,<span class="dv">10</span>] <span class="dv">586</span>)</a>
<a class="sourceLine" id="cb5-10" data-line-number="10"><span class="dv">1</span> <span class="fu">+</span> (<span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> (<span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> <span class="dv">10</span>))</a>
<a class="sourceLine" id="cb5-11" data-line-number="11"><span class="dv">1</span> <span class="fu">+</span> (<span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> <span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb5-12" data-line-number="12"><span class="dv">1</span> <span class="fu">+</span> (<span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> (<span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> <span class="dv">10</span>))</a>
<a class="sourceLine" id="cb5-13" data-line-number="13"><span class="dv">1</span> <span class="fu">+</span> <span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> (<span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb5-14" data-line-number="14"><span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> (<span class="dv">1</span> <span class="fu">+</span> (<span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> <span class="dv">10</span>))</a>
<a class="sourceLine" id="cb5-15" data-line-number="15"><span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb5-16" data-line-number="16"><span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> (<span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">10</span>))</a>
<a class="sourceLine" id="cb5-17" data-line-number="17"><span class="dv">1</span> <span class="fu">+</span> (<span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> <span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span>) <span class="fu">+</span> <span class="dv">10</span></a>
<a class="sourceLine" id="cb5-18" data-line-number="18"><span class="dv">1</span> <span class="fu">+</span> <span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> <span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> <span class="dv">10</span></a>
<a class="sourceLine" id="cb5-19" data-line-number="19"><span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span>) <span class="fu">+</span> <span class="dv">10</span></a>
<a class="sourceLine" id="cb5-20" data-line-number="20"><span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> <span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb5-21" data-line-number="21"><span class="dv">1</span> <span class="fu">+</span> <span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> (<span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb5-22" data-line-number="22"><span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> (<span class="dv">1</span> <span class="fu">+</span> (<span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> <span class="dv">10</span>))</a>
<a class="sourceLine" id="cb5-23" data-line-number="23"><span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb5-24" data-line-number="24"><span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> (<span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">10</span>))</a></code></pre></div>
<p>As you can see from the output, there‚Äôs a lot of repetition. We‚Äôll need to do some memoization to speed it up.</p>
<h2 id="pure-memoization">Pure Memoization</h2>
<p>The normal way most programmers think about ‚Äúmemoization‚Äù is something like this:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb6-1" data-line-number="1">memo_dict <span class="op">=</span> {<span class="dv">0</span>:<span class="dv">0</span>,<span class="dv">1</span>:<span class="dv">1</span>}</a>
<a class="sourceLine" id="cb6-2" data-line-number="2"></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="kw">def</span> fib(n):</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">    <span class="cf">if</span> n <span class="kw">in</span> memo_dict:</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">        <span class="cf">return</span> memo_dict[n]</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">    <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">        res <span class="op">=</span> fib(n<span class="dv">-1</span>) <span class="op">+</span> fib(n<span class="dv">-2</span>)</a>
<a class="sourceLine" id="cb6-8" data-line-number="8">        memo_dict[n] <span class="op">=</span> res</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">        <span class="cf">return</span> res</a></code></pre></div>
<p>In other words, it‚Äôs a fundamentally stateful process. We need to mutate some mapping when we haven‚Äôt seen the argument before.</p>
<p>Using laziness, though, we can emulate the same behavior purely. Instead of mutating the mapping on function calls, we fill the whole thing at the beginning, and then index into it. As long as the mapping is lazy, it‚Äôll only evaluate the function calls when they‚Äôre needed. We could use lists as our mapping to the natural numbers:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1">fibs <span class="fu">=</span> <span class="dv">0</span> <span class="fu">:</span> <span class="dv">1</span> <span class="fu">:</span> map fib [<span class="dv">2</span><span class="fu">..</span>]</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">fib n <span class="fu">=</span> fibs <span class="fu">!!</span> (n<span class="fu">-</span><span class="dv">1</span>) <span class="fu">+</span> fibs <span class="fu">!!</span> (n<span class="fu">-</span><span class="dv">2</span>)</a></code></pre></div>
<p>The benefit here is that we avoid the extra work of redundant calls. However, we pay for the speedup in three ways:</p>
<ol class="example" type="1">
<li>Space: we need to take up memory space storing the cached solutions.</li>
<li>Indexing: while we no longer have to pay for the expensive recursive calls, we <em>do</em> now have to pay for indexing into the data structure. In this example, we‚Äôre paying linear time to index into the list.</li>
<li>Generality: the memoization is tied directly to the argument type to the function. We need to be able to use the argument to our memoized function as an index into some data structure. While a lot of argument types admit some type of indexing (whether they‚Äôre <code class="sourceCode haskell"><span class="dt">Hashable</span></code>, <code class="sourceCode haskell"><span class="dt">Ord</span></code>, etc.), some don‚Äôt, and we can‚Äôt memoize those using this technique.</li>
</ol>
<p>We‚Äôre going to look at a technique that allow us to somewhat mitigate 2 and 3 above, using something called a <em>nexus</em>.</p>
<h2 id="nexuses">Nexuses</h2>
<p>The standard technique of memoization is focused on the arguments to the function, creating a concrete representation of them in memory to map to the results. Using nexuses, as described in <span class="citation" data-cites="bird_functional_2003">Bird and Hinze (<a href="#ref-bird_functional_2003">2003</a>)</span>, we‚Äôll instead focus on the function itself, creating a concrete representation of its call graph in memory. Here‚Äôs the call graph of Fibonacci:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">                                            ‚îåfib(<span class="dv">1</span>)<span class="fu">=</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">                                   ‚îåfib(<span class="dv">2</span>)<span class="fu">=</span>1‚î§</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">                                   ‚îÇ        ‚îîfib(<span class="dv">0</span>)<span class="fu">=</span><span class="dv">0</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">                          ‚îåfib(<span class="dv">3</span>)<span class="fu">=</span>2‚î§</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">                          ‚îÇ        ‚îîfib(<span class="dv">1</span>)<span class="fu">=</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">                 ‚îåfib(<span class="dv">4</span>)<span class="fu">=</span>3‚î§</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">                 ‚îÇ        ‚îÇ        ‚îåfib(<span class="dv">1</span>)<span class="fu">=</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8">                 ‚îÇ        ‚îîfib(<span class="dv">2</span>)<span class="fu">=</span>1‚î§</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">                 ‚îÇ                 ‚îîfib(<span class="dv">0</span>)<span class="fu">=</span><span class="dv">0</span></a>
<a class="sourceLine" id="cb8-10" data-line-number="10">        ‚îåfib(<span class="dv">5</span>)<span class="fu">=</span>5‚î§</a>
<a class="sourceLine" id="cb8-11" data-line-number="11">        ‚îÇ        ‚îÇ                 ‚îåfib(<span class="dv">1</span>)<span class="fu">=</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb8-12" data-line-number="12">        ‚îÇ        ‚îÇ        ‚îåfib(<span class="dv">2</span>)<span class="fu">=</span>1‚î§</a>
<a class="sourceLine" id="cb8-13" data-line-number="13">        ‚îÇ        ‚îÇ        ‚îÇ        ‚îîfib(<span class="dv">0</span>)<span class="fu">=</span><span class="dv">0</span></a>
<a class="sourceLine" id="cb8-14" data-line-number="14">        ‚îÇ        ‚îîfib(<span class="dv">3</span>)<span class="fu">=</span>2‚î§</a>
<a class="sourceLine" id="cb8-15" data-line-number="15">        ‚îÇ                 ‚îîfib(<span class="dv">1</span>)<span class="fu">=</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb8-16" data-line-number="16">fib(<span class="dv">6</span>)<span class="fu">=</span>8‚î§</a>
<a class="sourceLine" id="cb8-17" data-line-number="17">        ‚îÇ                          ‚îåfib(<span class="dv">1</span>)<span class="fu">=</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb8-18" data-line-number="18">        ‚îÇ                 ‚îåfib(<span class="dv">2</span>)<span class="fu">=</span>1‚î§</a>
<a class="sourceLine" id="cb8-19" data-line-number="19">        ‚îÇ                 ‚îÇ        ‚îîfib(<span class="dv">0</span>)<span class="fu">=</span><span class="dv">0</span></a>
<a class="sourceLine" id="cb8-20" data-line-number="20">        ‚îÇ        ‚îåfib(<span class="dv">3</span>)<span class="fu">=</span>2‚î§</a>
<a class="sourceLine" id="cb8-21" data-line-number="21">        ‚îÇ        ‚îÇ        ‚îîfib(<span class="dv">1</span>)<span class="fu">=</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb8-22" data-line-number="22">        ‚îîfib(<span class="dv">4</span>)<span class="fu">=</span>3‚î§</a>
<a class="sourceLine" id="cb8-23" data-line-number="23">                 ‚îÇ        ‚îåfib(<span class="dv">1</span>)<span class="fu">=</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb8-24" data-line-number="24">                 ‚îîfib(<span class="dv">2</span>)<span class="fu">=</span>1‚î§</a>
<a class="sourceLine" id="cb8-25" data-line-number="25">                          ‚îîfib(<span class="dv">0</span>)<span class="fu">=</span><span class="dv">0</span></a></code></pre></div>
<p>Turning <em>that</em> into a concrete datatype wouldn‚Äôt do us much good: it still has the massively redundant computations in it. However, we can recognize that entire subtrees are duplicates of each other: in those cases, instead of creating both subtrees, we could just create one and have each parent point to it<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1">        ‚îåfib(<span class="dv">5</span>)<span class="fu">=</span>5‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨fib(<span class="dv">3</span>)<span class="fu">=</span>2‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨fib(<span class="dv">1</span>)<span class="fu">=</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2">fib(<span class="dv">6</span>)<span class="fu">=</span>8‚î§        ‚îÇ        ‚îÇ        ‚îÇ        ‚îÇ</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥fib(<span class="dv">4</span>)<span class="fu">=</span>3‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥fib(<span class="dv">2</span>)<span class="fu">=</span>1‚î¥fib(<span class="dv">0</span>)<span class="fu">=</span><span class="dv">0</span></a></code></pre></div>
<p>This is a nexus. In Haskell, it‚Äôs not observably different from the other form, except that it takes up significantly less space. It‚Äôs also much quicker to construct.</p>
<p>If we use it to memoize <code class="sourceCode haskell">fib</code>, we‚Äôll no longer be indexing on the argument: we‚Äôll instead follow the relevant branch in the tree to the subcomputation, which is just chasing a pointer. It also means the argument doesn‚Äôt have to be constrained to any specific type. Here‚Äôs how you‚Äôd do it:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Leaf</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">    <span class="fu">|</span> <span class="dt">Node</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">    {<span class="ot"> val   ::</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5">    ,<span class="ot"> left  ::</span> <span class="dt">Tree</span></a>
<a class="sourceLine" id="cb12-6" data-line-number="6">    ,<span class="ot"> right ::</span> <span class="dt">Tree</span>}</a>
<a class="sourceLine" id="cb12-7" data-line-number="7"></a>
<a class="sourceLine" id="cb12-8" data-line-number="8"><span class="ot">fib ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb12-9" data-line-number="9">fib <span class="fu">=</span> val <span class="fu">.</span> go</a>
<a class="sourceLine" id="cb12-10" data-line-number="10">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-11" data-line-number="11">    go <span class="dv">0</span> <span class="fu">=</span> <span class="dt">Node</span> <span class="dv">0</span> <span class="dt">Leaf</span> <span class="dt">Leaf</span></a>
<a class="sourceLine" id="cb12-12" data-line-number="12">    go <span class="dv">1</span> <span class="fu">=</span> <span class="dt">Node</span> <span class="dv">1</span> (<span class="dt">Node</span> <span class="dv">0</span> <span class="dt">Leaf</span> <span class="dt">Leaf</span>) <span class="dt">Leaf</span></a>
<a class="sourceLine" id="cb12-13" data-line-number="13">    go n <span class="fu">=</span> node t (left t) <span class="kw">where</span> t <span class="fu">=</span> go (n<span class="fu">-</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb12-14" data-line-number="14">    node l r <span class="fu">=</span> <span class="dt">Node</span> (val l <span class="fu">+</span> val r) l r</a></code></pre></div>
<p>So this approach sounds amazing, right? No constraints on the argument type, no need to pay for indexing: why doesn‚Äôt everyone use it everywhere? The main reason is that figuring out a nexus for the call-graph is <em>hard</em>. In fact, finding an optimal one is NP-hard in general <span class="citation" data-cites="steffen_table_2006">(Steffen and Giegerich <a href="#ref-steffen_table_2006">2006</a>)</span>.</p>
<p>The second problem is that it‚Äôs difficult to abstract out. The standard technique of memoization relies on building a mapping from keys to values: about as bread-and-butter as it gets in programming. Even more, we already know how to say ‚Äúvalues of this type can be used efficiently as keys in some mapping‚Äù: for Data.Map it‚Äôs <code class="sourceCode haskell"><span class="dt">Ord</span></code>, for Data.HashMap it‚Äôs <code class="sourceCode haskell"><span class="dt">Hashable</span></code>. All of this together means we can build a nice library for memoization which exports the two following functions:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="ot">memoHash ::</span> <span class="dt">Hashable</span> a <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b)</a>
<a class="sourceLine" id="cb13-2" data-line-number="2"><span class="ot">memoOrd ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b)</a></code></pre></div>
<p>Building a nexus, however, is not bread-and-butter. On top of that, it‚Äôs difficult to say something like ‚Äúrecursive functions of this structure can be constructed using a nexus‚Äù. What‚Äôs the typeclass for that? In comparison to the signatures above, the constraint will need to be on the <em>arrows</em>, not the <code class="sourceCode haskell">a</code>. Even talking about the structure of recursive functions is regarded as somewhat of an advanced subject: that said, the <a href="https://hackage.haskell.org/package/recursion-schemes">recursion-schemes</a> package allows us to do so, and even has facilities for constructing something <em>like</em> nexuses with histomorphisms <span class="citation" data-cites="tobin_time_2016">(Tobin <a href="#ref-tobin_time_2016">2016</a>)</span>. I‚Äôm still looking to see if there‚Äôs a library out there that <em>does</em> manage to abstract nexuses in an ergonomic way, so I‚Äôd love to hear if there was one (or if there‚Äôs some more generalized form which accomplishes the same).</p>
<h2 id="memoizing-countdown">Memoizing Countdown</h2>
<p>That‚Äôs enough preamble. The nexus we want to construct for countdown is <em>not</em> going to memoize as much as possible: in particular, we‚Äôre only going to memoize the shape of the trees, not the operators used. This will massively reduce the memory overhead, and still give a decent speedup <span class="citation" data-cites="bird_countdown:_2005">(Bird and Mu <a href="#ref-bird_countdown:_2005">2005</a>, 11 ‚Äúbuilding a skeleton tree first‚Äù)</span>.</p>
<p>With that in mind, the ideal nexus looks something like this:</p>
<p><img src="/images/boolean-lattice.svg" /></p>
<p>We can represent the tree in Haskell as a rose tree:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Node</span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3">    {<span class="ot"> root   ::</span> a</a>
<a class="sourceLine" id="cb14-4" data-line-number="4">    ,<span class="ot"> forest ::</span> <span class="dt">Forest</span> a</a>
<a class="sourceLine" id="cb14-5" data-line-number="5">    }</a>
<a class="sourceLine" id="cb14-6" data-line-number="6"></a>
<a class="sourceLine" id="cb14-7" data-line-number="7"><span class="kw">type</span> <span class="dt">Forest</span> a <span class="fu">=</span> [<span class="dt">Tree</span> a]</a></code></pre></div>
<p>Constructing the nexus itself isn‚Äôt actually the most interesting part of this solution: <em>consuming</em> it is. We need to be able to go from the structure above into a list that‚Äôs the equivalent of <code class="sourceCode haskell">unmerges</code>. Doing a breadth-first traversal of the diagram above (without the top element) will give us:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mi>c</mi><mo>,</mo><mi>a</mi><mi>b</mi><mi>d</mi><mo>,</mo><mi>a</mi><mi>c</mi><mi>d</mi><mo>,</mo><mi>b</mi><mi>c</mi><mi>d</mi><mo>,</mo><mi>a</mi><mi>b</mi><mo>,</mo><mi>a</mi><mi>c</mi><mo>,</mo><mi>b</mi><mi>c</mi><mo>,</mo><mi>a</mi><mi>d</mi><mo>,</mo><mi>b</mi><mi>d</mi><mo>,</mo><mi>c</mi><mi>d</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo>,</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">abc, abd, acd, bcd, ab, ac, bc, ad, bd, cd, a, b, c, d</annotation></semantics></math></p>
<p>If you split that list in half, and zip it with its reverse, you‚Äôll get the output of <code class="sourceCode haskell">unmerges</code>.</p>
<p>However, the breadth-first traversal of the diagram isn‚Äôt the same thing as the breadth-first traversal of the rose tree. The latter will traverse <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mi>c</mi><mo>,</mo><mi>a</mi><mi>b</mi><mi>d</mi><mo>,</mo><mi>a</mi><mi>c</mi><mi>d</mi><mo>,</mo><mi>b</mi><mi>c</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">abc, abd, acd, bcd</annotation></semantics></math>, and then the children of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">abc</annotation></semantics></math> (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mo>,</mo><mi>a</mi><mi>c</mi><mo>,</mo><mi>b</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">ab,ac,bc</annotation></semantics></math>), and then the children of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">abd</annotation></semantics></math> (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mo>,</mo><mi>a</mi><mi>d</mi><mo>,</mo><mi>b</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">ab,ad,bd</annotation></semantics></math>): and here‚Äôs our problem. We traverse <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">ab</annotation></semantics></math> twice, because we can‚Äôt know that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">abc</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">abd</annotation></semantics></math> are pointing to the same value. What we have to do is first prune the tree, removing duplicates, and then perform a breadth-first traversal on that.</p>
<h3 id="pruning">Pruning</h3>
<p>Luckily, the duplicates follow a pattern, allowing us to remove them without having to do any equality checking. In each row, the first node has no duplicates in its children, the second‚Äôs first child is a duplicate, the third‚Äôs first and second children are duplicates, and so on. You should be able to see this in the diagram above. Adapting a little from the paper, we get an algorithm like this:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="ot">para ::</span> (a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">para f b <span class="fu">=</span> go</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-4" data-line-number="4">    go [] <span class="fu">=</span> b</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">    go (x<span class="fu">:</span>xs) <span class="fu">=</span> f x xs (go xs)</a>
<a class="sourceLine" id="cb15-6" data-line-number="6"></a>
<a class="sourceLine" id="cb15-7" data-line-number="7"><span class="ot">prune ::</span> <span class="dt">Forest</span> a <span class="ot">-&gt;</span> <span class="dt">Forest</span> a</a>
<a class="sourceLine" id="cb15-8" data-line-number="8">prune ts <span class="fu">=</span> pruneAt ts <span class="dv">0</span> </a>
<a class="sourceLine" id="cb15-9" data-line-number="9">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-10" data-line-number="10">    pruneAt <span class="fu">=</span> para f (const [])</a>
<a class="sourceLine" id="cb15-11" data-line-number="11">    f (<span class="dt">Node</span> x []) t _ _ <span class="fu">=</span> <span class="dt">Node</span> x [] <span class="fu">:</span> t</a>
<a class="sourceLine" id="cb15-12" data-line-number="12">    f (<span class="dt">Node</span> x us) _ a k <span class="fu">=</span></a>
<a class="sourceLine" id="cb15-13" data-line-number="13">        <span class="dt">Node</span> x (pruneAt (drop k us) k) <span class="fu">:</span> a (k <span class="fu">+</span> <span class="dv">1</span>)</a></code></pre></div>
<h3 id="breadth-first-traversal">Breadth-First Traversal</h3>
<p>I went through this in a <a href="/posts/2018-03-17-rose-trees-breadth-first.html">previous post</a>, so this is the end solution:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="ot">breadthFirst ::</span> <span class="dt">Forest</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">breadthFirst ts <span class="fu">=</span> foldr f b ts []</a>
<a class="sourceLine" id="cb16-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-4" data-line-number="4">    f (<span class="dt">Node</span> x xs) fw bw <span class="fu">=</span> x <span class="fu">:</span> fw (xs<span class="fu">:</span>bw)</a>
<a class="sourceLine" id="cb16-5" data-line-number="5"></a>
<a class="sourceLine" id="cb16-6" data-line-number="6">    b [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb16-7" data-line-number="7">    b q <span class="fu">=</span> foldl (foldr f) b q []</a></code></pre></div>
<p>With the appropriate incantations, this is actually the fastest implementation I‚Äôve found.</p>
<h3 id="fusing">Fusing</h3>
<p>We can actually inline both of the above functions, fusing them together:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="ot">spanNexus ::</span> <span class="dt">Forest</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">spanNexus ts <span class="fu">=</span> foldr f (const b) ts <span class="dv">0</span> []</a>
<a class="sourceLine" id="cb17-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb17-4" data-line-number="4">    f (<span class="dt">Node</span> x us) fw k bw <span class="fu">=</span> x <span class="fu">:</span> fw (k<span class="fu">+</span><span class="dv">1</span>) ((drop k us, k) <span class="fu">:</span> bw)</a>
<a class="sourceLine" id="cb17-5" data-line-number="5"></a>
<a class="sourceLine" id="cb17-6" data-line-number="6">    b [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb17-7" data-line-number="7">    b qs <span class="fu">=</span> foldl (uncurry <span class="fu">.</span> foldr f <span class="fu">.</span> const) b qs []</a></code></pre></div>
<h3 id="halving-convolving-and-folding">Halving, Convolving, and Folding</h3>
<p>So, now we can go from the tree to our list of splits. Next step is to convert that list into the output of unmerges, by zipping the reverse of the first half with the second. We can use an algorithm described in <span class="citation" data-cites="danvy_there_2005">Danvy and Goldberg (<a href="#ref-danvy_there_2005">2005</a>)</span> to do the zipping and reversing:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1">fold xs n <span class="fu">=</span> go xs n (const [])</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3">    go xs <span class="dv">0</span>     k <span class="fu">=</span> k xs</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">    go (x<span class="fu">:</span>xs) n k <span class="fu">=</span> go xs (n<span class="fu">-</span><span class="dv">2</span>) (\(y<span class="fu">:</span>ys) <span class="ot">-&gt;</span> (x,y) <span class="fu">:</span> k ys)</a></code></pre></div>
<p>And we can inline the function which collapses those results into one:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1">fold xs n <span class="fu">=</span> go xs n (const [])</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-3" data-line-number="3">    go <span class="dv">0</span> xss k <span class="fu">=</span> k xss</a>
<a class="sourceLine" id="cb19-4" data-line-number="4">    go n (xs<span class="fu">:</span>xss) k <span class="fu">=</span></a>
<a class="sourceLine" id="cb19-5" data-line-number="5">        go (n<span class="fu">-</span><span class="dv">2</span>) xss (\(ys<span class="fu">:</span>yss) <span class="ot">-&gt;</span> [ z</a>
<a class="sourceLine" id="cb19-6" data-line-number="6">                                      <span class="fu">|</span> x <span class="ot">&lt;-</span> xs</a>
<a class="sourceLine" id="cb19-7" data-line-number="7">                                      , y <span class="ot">&lt;-</span> ys</a>
<a class="sourceLine" id="cb19-8" data-line-number="8">                                      , z <span class="ot">&lt;-</span> cmb x y</a>
<a class="sourceLine" id="cb19-9" data-line-number="9">                                      ] <span class="fu">++</span> k yss)</a></code></pre></div>
<p>And that‚Äôs all we need!</p>
<details>
<p><summary> Full Code </summary></p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Tree</span> <span class="kw">as</span> <span class="dt">Rose</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2"></a>
<a class="sourceLine" id="cb20-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb20-4" data-line-number="4">    <span class="fu">=</span> <span class="dt">Leaf</span> <span class="dt">Int</span> a</a>
<a class="sourceLine" id="cb20-5" data-line-number="5">    <span class="fu">|</span> <span class="dt">Node</span> [<span class="dt">Tree</span> a]</a>
<a class="sourceLine" id="cb20-6" data-line-number="6">    <span class="kw">deriving</span> (<span class="dt">Show</span>,<span class="dt">Eq</span>,<span class="dt">Functor</span>)</a>
<a class="sourceLine" id="cb20-7" data-line-number="7">    </a>
<a class="sourceLine" id="cb20-8" data-line-number="8"><span class="ot">enumerateTrees ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a]) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb20-9" data-line-number="9">enumerateTrees _ [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb20-10" data-line-number="10">enumerateTrees cmb xs <span class="fu">=</span> (extract <span class="fu">.</span> steps <span class="fu">.</span> initial) xs</a>
<a class="sourceLine" id="cb20-11" data-line-number="11">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-12" data-line-number="12">    step <span class="fu">=</span> map nodes <span class="fu">.</span> group</a>
<a class="sourceLine" id="cb20-13" data-line-number="13"></a>
<a class="sourceLine" id="cb20-14" data-line-number="14">    steps [x] <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb20-15" data-line-number="15">    steps xs <span class="fu">=</span> steps (step xs)</a>
<a class="sourceLine" id="cb20-16" data-line-number="16"></a>
<a class="sourceLine" id="cb20-17" data-line-number="17">    initial <span class="fu">=</span> map (<span class="dt">Leaf</span> <span class="dv">1</span> <span class="fu">.</span> flip <span class="dt">Rose.Node</span> [] <span class="fu">.</span> pure)</a>
<a class="sourceLine" id="cb20-18" data-line-number="18"></a>
<a class="sourceLine" id="cb20-19" data-line-number="19">    extract (<span class="dt">Leaf</span> _ x) <span class="fu">=</span> Rose.rootLabel x</a>
<a class="sourceLine" id="cb20-20" data-line-number="20">    extract (<span class="dt">Node</span> [x]) <span class="fu">=</span> extract x</a>
<a class="sourceLine" id="cb20-21" data-line-number="21"></a>
<a class="sourceLine" id="cb20-22" data-line-number="22">    group [_] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb20-23" data-line-number="23">    group (<span class="dt">Leaf</span> _ x<span class="fu">:</span>vs) <span class="fu">=</span> <span class="dt">Node</span> [<span class="dt">Leaf</span> <span class="dv">2</span> [x, y] <span class="fu">|</span> <span class="dt">Leaf</span> _ y <span class="ot">&lt;-</span> vs] <span class="fu">:</span> group vs</a>
<a class="sourceLine" id="cb20-24" data-line-number="24">    group (<span class="dt">Node</span>   u<span class="fu">:</span>vs) <span class="fu">=</span> <span class="dt">Node</span> (zipWith comb (group u) vs) <span class="fu">:</span> group vs</a>
<a class="sourceLine" id="cb20-25" data-line-number="25"></a>
<a class="sourceLine" id="cb20-26" data-line-number="26">    comb (<span class="dt">Leaf</span> n xs) (<span class="dt">Leaf</span> _ x) <span class="fu">=</span> <span class="dt">Leaf</span> (n <span class="fu">+</span> <span class="dv">1</span>) (xs <span class="fu">++</span> [x])</a>
<a class="sourceLine" id="cb20-27" data-line-number="27">    comb (<span class="dt">Node</span> us) (<span class="dt">Node</span> vs) <span class="fu">=</span> <span class="dt">Node</span> (zipWith comb us vs)</a>
<a class="sourceLine" id="cb20-28" data-line-number="28"></a>
<a class="sourceLine" id="cb20-29" data-line-number="29">    forest ts <span class="fu">=</span> foldr f (const b) ts <span class="dv">0</span> []</a>
<a class="sourceLine" id="cb20-30" data-line-number="30">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-31" data-line-number="31">        f (<span class="dt">Rose.Node</span> x []) fw <span class="fu">!</span>k bw <span class="fu">=</span> x <span class="fu">:</span> fw (k <span class="fu">+</span> <span class="dv">1</span>) bw</a>
<a class="sourceLine" id="cb20-32" data-line-number="32">        f (<span class="dt">Rose.Node</span> x us) fw <span class="fu">!</span>k bw <span class="fu">=</span> x <span class="fu">:</span> fw (k <span class="fu">+</span> <span class="dv">1</span>) ((drop k us, k) <span class="fu">:</span> bw)</a>
<a class="sourceLine" id="cb20-33" data-line-number="33"></a>
<a class="sourceLine" id="cb20-34" data-line-number="34">        b [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb20-35" data-line-number="35">        b qs <span class="fu">=</span> foldl (uncurry <span class="fu">.</span> foldr f <span class="fu">.</span> const) b qs []</a>
<a class="sourceLine" id="cb20-36" data-line-number="36"></a>
<a class="sourceLine" id="cb20-37" data-line-number="37">    nodes (<span class="dt">Leaf</span> n x) <span class="fu">=</span> <span class="dt">Leaf</span> <span class="dv">1</span> (node n x)</a>
<a class="sourceLine" id="cb20-38" data-line-number="38">    nodes (<span class="dt">Node</span> xs) <span class="fu">=</span> <span class="dt">Node</span> (map nodes xs)</a>
<a class="sourceLine" id="cb20-39" data-line-number="39"></a>
<a class="sourceLine" id="cb20-40" data-line-number="40">    node n ts <span class="fu">=</span> <span class="dt">Rose.Node</span> (walk (<span class="dv">2</span> <span class="fu">^</span> n <span class="fu">-</span> <span class="dv">2</span>) (forest ts) (const [])) ts</a>
<a class="sourceLine" id="cb20-41" data-line-number="41">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-42" data-line-number="42">        walk <span class="dv">0</span> xss k <span class="fu">=</span> k xss</a>
<a class="sourceLine" id="cb20-43" data-line-number="43">        walk n (xs<span class="fu">:</span>xss) k <span class="fu">=</span></a>
<a class="sourceLine" id="cb20-44" data-line-number="44">            walk (n<span class="fu">-</span><span class="dv">2</span>) xss (\(ys<span class="fu">:</span>yss) <span class="ot">-&gt;</span> [ z</a>
<a class="sourceLine" id="cb20-45" data-line-number="45">                                         <span class="fu">|</span> x <span class="ot">&lt;-</span> xs</a>
<a class="sourceLine" id="cb20-46" data-line-number="46">                                         , y <span class="ot">&lt;-</span> ys</a>
<a class="sourceLine" id="cb20-47" data-line-number="47">                                         , z <span class="ot">&lt;-</span> cmb x y</a>
<a class="sourceLine" id="cb20-48" data-line-number="48">                                         ] <span class="fu">++</span> k yss)</a></code></pre></div>
</details>
<h2 id="using-it-for-countdown">Using it for Countdown</h2>
<p>The first thing to do for the Countdown solution is to figure out a representation for expressions. The one from simple-reflect is perfect for displaying the result, but we should memoize its calculation.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Memoed</span></a>
<a class="sourceLine" id="cb21-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">Memoed</span></a>
<a class="sourceLine" id="cb21-3" data-line-number="3">  {<span class="ot"> expr   ::</span> <span class="dt">Expr</span></a>
<a class="sourceLine" id="cb21-4" data-line-number="4">  ,<span class="ot"> result ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb21-5" data-line-number="5">  }</a></code></pre></div>
<p>Then, some helpers for building:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Op</span> <span class="fu">=</span> <span class="dt">Add</span> <span class="fu">|</span> <span class="dt">Dif</span> <span class="fu">|</span> <span class="dt">Mul</span> <span class="fu">|</span> <span class="dt">Div</span></a>
<a class="sourceLine" id="cb22-2" data-line-number="2"></a>
<a class="sourceLine" id="cb22-3" data-line-number="3">binOp f g x y <span class="fu">=</span> <span class="dt">Memoed</span> ((f <span class="ot">`on`</span> expr) x y) ((g <span class="ot">`on`</span> result) x y)</a>
<a class="sourceLine" id="cb22-4" data-line-number="4"></a>
<a class="sourceLine" id="cb22-5" data-line-number="5"><span class="ot">apply ::</span> <span class="dt">Op</span> <span class="ot">-&gt;</span> <span class="dt">Memoed</span> <span class="ot">-&gt;</span> <span class="dt">Memoed</span> <span class="ot">-&gt;</span> <span class="dt">Memoed</span></a>
<a class="sourceLine" id="cb22-6" data-line-number="6">apply <span class="dt">Add</span> x y <span class="fu">=</span> binOp (<span class="fu">+</span>) (<span class="fu">+</span>) x y</a>
<a class="sourceLine" id="cb22-7" data-line-number="7">apply <span class="dt">Dif</span> x y</a>
<a class="sourceLine" id="cb22-8" data-line-number="8">  <span class="fu">|</span> result y <span class="fu">&lt;</span> result x <span class="fu">=</span> binOp (<span class="fu">-</span>) (<span class="fu">-</span>) x y</a>
<a class="sourceLine" id="cb22-9" data-line-number="9">  <span class="fu">|</span> otherwise <span class="fu">=</span> binOp (<span class="fu">-</span>) (<span class="fu">-</span>) y x</a>
<a class="sourceLine" id="cb22-10" data-line-number="10">apply <span class="dt">Mul</span> x y <span class="fu">=</span> binOp (<span class="fu">*</span>) (<span class="fu">*</span>) x y</a>
<a class="sourceLine" id="cb22-11" data-line-number="11">apply <span class="dt">Div</span> x y <span class="fu">=</span> binOp div div x y</a></code></pre></div>
<p>Finally, the full algorithm:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="ot">enumerateExprs ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Memoed</span>]</a>
<a class="sourceLine" id="cb23-2" data-line-number="2">enumerateExprs <span class="fu">=</span> enumerateTrees cmb <span class="fu">.</span> map (\x <span class="ot">-&gt;</span> <span class="dt">Memoed</span> (fromIntegral x) x)</a>
<a class="sourceLine" id="cb23-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-4" data-line-number="4">    cmb x y <span class="fu">=</span></a>
<a class="sourceLine" id="cb23-5" data-line-number="5">        nubs <span class="fu">$</span></a>
<a class="sourceLine" id="cb23-6" data-line-number="6">        x <span class="fu">:</span></a>
<a class="sourceLine" id="cb23-7" data-line-number="7">        y <span class="fu">:</span></a>
<a class="sourceLine" id="cb23-8" data-line-number="8">        [ apply op x y</a>
<a class="sourceLine" id="cb23-9" data-line-number="9">        <span class="fu">|</span> op <span class="ot">&lt;-</span> [<span class="dt">Add</span>, <span class="dt">Dif</span>, <span class="dt">Mul</span>, <span class="dt">Div</span>]</a>
<a class="sourceLine" id="cb23-10" data-line-number="10">        , legal op (result x) (result y) ]</a>
<a class="sourceLine" id="cb23-11" data-line-number="11">    legal <span class="dt">Add</span> _ _ <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb23-12" data-line-number="12">    legal <span class="dt">Dif</span> x y <span class="fu">=</span> x <span class="fu">/=</span> y</a>
<a class="sourceLine" id="cb23-13" data-line-number="13">    legal <span class="dt">Mul</span> _ _ <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb23-14" data-line-number="14">    legal <span class="dt">Div</span> x y <span class="fu">=</span> x <span class="ot">`mod`</span> y <span class="fu">==</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb23-15" data-line-number="15">    nubs xs <span class="fu">=</span> foldr f (const []) xs IntSet.empty</a>
<a class="sourceLine" id="cb23-16" data-line-number="16">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-17" data-line-number="17">        f e a s</a>
<a class="sourceLine" id="cb23-18" data-line-number="18">          <span class="fu">|</span> IntSet.member (result e) s <span class="fu">=</span> a s</a>
<a class="sourceLine" id="cb23-19" data-line-number="19">          <span class="fu">|</span> otherwise <span class="fu">=</span> e <span class="fu">:</span> a (IntSet.insert (result e) s)</a>
<a class="sourceLine" id="cb23-20" data-line-number="20"></a>
<a class="sourceLine" id="cb23-21" data-line-number="21"><span class="ot">countdown ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Expr</span>]</a>
<a class="sourceLine" id="cb23-22" data-line-number="22">countdown targ <span class="fu">=</span> map expr <span class="fu">.</span> filter ((<span class="fu">==</span>) targ <span class="fu">.</span> result) <span class="fu">.</span> enumerateExprs</a>
<a class="sourceLine" id="cb23-23" data-line-number="23"></a>
<a class="sourceLine" id="cb23-24" data-line-number="24"><span class="fu">&gt;&gt;&gt;</span> (mapM_ print <span class="fu">.</span> reduction <span class="fu">.</span> head) (countdown <span class="dv">586</span> [<span class="dv">100</span>,<span class="dv">25</span>,<span class="dv">1</span>,<span class="dv">5</span>,<span class="dv">3</span>,<span class="dv">10</span>])</a>
<a class="sourceLine" id="cb23-25" data-line-number="25"><span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> <span class="dv">1</span> <span class="fu">+</span> (<span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb23-26" data-line-number="26"><span class="dv">75</span> <span class="fu">+</span> <span class="dv">1</span> <span class="fu">+</span> (<span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb23-27" data-line-number="27"><span class="dv">76</span> <span class="fu">+</span> (<span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb23-28" data-line-number="28"><span class="dv">76</span> <span class="fu">+</span> (<span class="dv">500</span> <span class="fu">+</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb23-29" data-line-number="29"><span class="dv">76</span> <span class="fu">+</span> <span class="dv">510</span></a>
<a class="sourceLine" id="cb23-30" data-line-number="30"><span class="dv">586</span></a></code></pre></div>
<p>There are some optimizations going on here, taken mainly from <span class="citation" data-cites="bird_countdown:_2005">Bird and Mu (<a href="#ref-bird_countdown:_2005">2005</a>)</span>:</p>
<ol type="1">
<li>We filter out illegal operations, as described originally.</li>
<li>We filter out any expressions that have the same value.</li>
</ol>
<h2 id="testing-the-implementation">Testing the Implementation</h2>
<p>So we‚Äôve followed the paper, written the code: time to test. The specification of the function is relatively simple: calculate all applications of the commutative operator to some input, <em>without</em> recalculating subtrees.</p>
<p>We‚Äôll need a free structure for the ‚Äúcommutative operator‚Äù:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb24-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Leaf</span> a</a>
<a class="sourceLine" id="cb24-3" data-line-number="3">    <span class="fu">|</span> <span class="dt">Tree</span> a <span class="fu">:^:</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb24-4" data-line-number="4">    <span class="kw">deriving</span> (<span class="dt">Foldable</span>,<span class="dt">Eq</span>,<span class="dt">Ord</span>,<span class="dt">Show</span>)</a></code></pre></div>
<p>Here‚Äôs the problem: it‚Äôs not commutative! We can remedy it by only exporting a constructor that creates the tree in a commutative way, and we can make it a pattern synonym so it looks normal:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="ot">{-# LANGUAGE DeriveFoldable  #-}</span></a>
<a class="sourceLine" id="cb25-2" data-line-number="2"><span class="ot">{-# LANGUAGE PatternSynonyms #-}</span></a>
<a class="sourceLine" id="cb25-3" data-line-number="3"></a>
<a class="sourceLine" id="cb25-4" data-line-number="4"><span class="kw">module</span> <span class="dt">Commutative</span></a>
<a class="sourceLine" id="cb25-5" data-line-number="5">  (<span class="dt">Tree</span>(<span class="dt">Leaf</span>)</a>
<a class="sourceLine" id="cb25-6" data-line-number="6">  ,pattern (<span class="fu">:*:</span>))</a>
<a class="sourceLine" id="cb25-7" data-line-number="7">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-8" data-line-number="8"></a>
<a class="sourceLine" id="cb25-9" data-line-number="9"><span class="kw">data</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb25-10" data-line-number="10">    <span class="fu">=</span> <span class="dt">Leaf</span> a</a>
<a class="sourceLine" id="cb25-11" data-line-number="11">    <span class="fu">|</span> <span class="dt">Tree</span> a <span class="fu">:^:</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb25-12" data-line-number="12">    <span class="kw">deriving</span> (<span class="dt">Eq</span>,<span class="dt">Ord</span>,<span class="dt">Show</span>,<span class="dt">Foldable</span>)</a>
<a class="sourceLine" id="cb25-13" data-line-number="13"></a>
<a class="sourceLine" id="cb25-14" data-line-number="14">pattern<span class="ot"> (:*:) ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb25-15" data-line-number="15">pattern xs <span class="fu">:*:</span> ys <span class="ot">&lt;-</span> xs <span class="fu">:^:</span> ys <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-16" data-line-number="16">  xs <span class="fu">:*:</span> ys</a>
<a class="sourceLine" id="cb25-17" data-line-number="17">      <span class="fu">|</span> xs <span class="fu">&lt;=</span> ys <span class="fu">=</span> xs <span class="fu">:^:</span> ys</a>
<a class="sourceLine" id="cb25-18" data-line-number="18">      <span class="fu">|</span> otherwise <span class="fu">=</span> ys <span class="fu">:^:</span> xs</a>
<a class="sourceLine" id="cb25-19" data-line-number="19"></a>
<a class="sourceLine" id="cb25-20" data-line-number="20"><span class="ot">{-# COMPLETE Leaf, (:*:) #-}</span></a></code></pre></div>
<p>Now we need to check if all applications are actually tested. First, to generate all trees:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="ot">allTrees ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Set</span> (<span class="dt">Tree</span> a)</a>
<a class="sourceLine" id="cb26-2" data-line-number="2">allTrees [x] <span class="fu">=</span> Set.singleton (<span class="dt">Leaf</span> x)</a>
<a class="sourceLine" id="cb26-3" data-line-number="3">allTrees xs <span class="fu">=</span> Set.unions (map (uncurry f) (unmerges xs))</a>
<a class="sourceLine" id="cb26-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb26-5" data-line-number="5">    f ls rs <span class="fu">=</span> Set.fromList ((liftA2 (<span class="fu">:*:</span>) <span class="ot">`on`</span> (Set.toList <span class="fu">.</span> allTrees)) ls rs)</a>
<a class="sourceLine" id="cb26-6" data-line-number="6"></a>
<a class="sourceLine" id="cb26-7" data-line-number="7"><span class="ot">allSubTrees ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Set</span> (<span class="dt">Tree</span> a)</a>
<a class="sourceLine" id="cb26-8" data-line-number="8">allSubTrees [x] <span class="fu">=</span> Set.singleton (<span class="dt">Leaf</span> x)</a>
<a class="sourceLine" id="cb26-9" data-line-number="9">allSubTrees xs <span class="fu">=</span></a>
<a class="sourceLine" id="cb26-10" data-line-number="10">    Set.unions (map (uncurry f <span class="fu">.</span> (allSubTrees <span class="fu">***</span> allSubTrees)) (unmerges xs))</a>
<a class="sourceLine" id="cb26-11" data-line-number="11">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb26-12" data-line-number="12">    f ls rs <span class="fu">=</span></a>
<a class="sourceLine" id="cb26-13" data-line-number="13">        Set.unions</a>
<a class="sourceLine" id="cb26-14" data-line-number="14">            [ls, rs, Set.fromList ((liftA2 (<span class="fu">:*:</span>) <span class="ot">`on`</span> Set.toList) ls rs)]</a></code></pre></div>
<p>Then, to test:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="ot">prop_exhaustiveSearch ::</span> <span class="dt">Natural</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb27-2" data-line-number="2">prop_exhaustiveSearch n <span class="fu">=</span></a>
<a class="sourceLine" id="cb27-3" data-line-number="3">         <span class="kw">let</span> src <span class="fu">=</span> [<span class="dv">0</span> <span class="fu">..</span> fromIntegral n]</a>
<a class="sourceLine" id="cb27-4" data-line-number="4">             expect <span class="fu">=</span> allSubTrees src</a>
<a class="sourceLine" id="cb27-5" data-line-number="5">             actual <span class="fu">=</span></a>
<a class="sourceLine" id="cb27-6" data-line-number="6">                 Set.fromList</a>
<a class="sourceLine" id="cb27-7" data-line-number="7">                     (enumerateTrees</a>
<a class="sourceLine" id="cb27-8" data-line-number="8">                          (\xs ys <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb27-9" data-line-number="9">                                [xs, ys, xs <span class="fu">:*:</span> ys])</a>
<a class="sourceLine" id="cb27-10" data-line-number="10">                          (map <span class="dt">Leaf</span> src))</a>
<a class="sourceLine" id="cb27-11" data-line-number="11">         <span class="kw">in</span> expect <span class="fu">==</span> actual</a>
<a class="sourceLine" id="cb27-12" data-line-number="12"></a>
<a class="sourceLine" id="cb27-13" data-line-number="13"><span class="ot">prop_exhaustiveSearchFull ::</span> <span class="dt">Natural</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb27-14" data-line-number="14">prop_exhaustiveSearchFull n <span class="fu">=</span></a>
<a class="sourceLine" id="cb27-15" data-line-number="15">         <span class="kw">let</span> src <span class="fu">=</span> [<span class="dv">0</span> <span class="fu">..</span> fromIntegral n]</a>
<a class="sourceLine" id="cb27-16" data-line-number="16">             expect <span class="fu">=</span> Map.fromSet (const <span class="dv">1</span>) (allTrees src)</a>
<a class="sourceLine" id="cb27-17" data-line-number="17">             actual <span class="fu">=</span></a>
<a class="sourceLine" id="cb27-18" data-line-number="18">                 freqs</a>
<a class="sourceLine" id="cb27-19" data-line-number="19">                     (enumerateTrees</a>
<a class="sourceLine" id="cb27-20" data-line-number="20">                          (\xs ys <span class="ot">-&gt;</span> [xs <span class="fu">:*:</span> ys])</a>
<a class="sourceLine" id="cb27-21" data-line-number="21">                          (map <span class="dt">Leaf</span> src))</a>
<a class="sourceLine" id="cb27-22" data-line-number="22">         <span class="kw">in</span> expect <span class="fu">==</span> actual</a></code></pre></div>
<p>Testing for repeated calls is more tricky. Remember, the memoization is supposed to be unobservable: in order to see it, we‚Äôre going to have to use some unsafe operations.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1">traceSubsequences</a>
<a class="sourceLine" id="cb28-2" data-line-number="2"><span class="ot">    ::</span> ((<span class="dt">Tree</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Tree</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Tree</span> <span class="dt">Int</span>]) <span class="ot">-&gt;</span> [<span class="dt">Tree</span> <span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Tree</span> <span class="dt">Int</span>])</a>
<a class="sourceLine" id="cb28-3" data-line-number="3">    <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb28-4" data-line-number="4">    <span class="ot">-&gt;</span> (<span class="dt">Map</span> (<span class="dt">Tree</span> <span class="dt">Int</span>) <span class="dt">Int</span>, [<span class="dt">Tree</span> <span class="dt">Int</span>])</a>
<a class="sourceLine" id="cb28-5" data-line-number="5">traceSubsequences enm ints <span class="fu">=</span></a>
<a class="sourceLine" id="cb28-6" data-line-number="6">    runST <span class="fu">$</span></a>
<a class="sourceLine" id="cb28-7" data-line-number="7">    <span class="kw">do</span> ref <span class="ot">&lt;-</span> newSTRef Map.empty</a>
<a class="sourceLine" id="cb28-8" data-line-number="8">       <span class="kw">let</span> res <span class="fu">=</span> enm (combine ref) (map (conv ref) ints)</a>
<a class="sourceLine" id="cb28-9" data-line-number="9">       traverse_ (foldr seq (pure ())) res</a>
<a class="sourceLine" id="cb28-10" data-line-number="10">       intm <span class="ot">&lt;-</span> readSTRef ref</a>
<a class="sourceLine" id="cb28-11" data-line-number="11">       pure (intm, res)</a>
<a class="sourceLine" id="cb28-12" data-line-number="12">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb28-13" data-line-number="13">    combine ref xs ys <span class="fu">=</span> unsafeRunST ([xs <span class="fu">:*:</span> ys] <span class="fu">&lt;$</span> modifySTRef&#39; ref (incr (xs <span class="fu">:*:</span> ys)))</a>
<a class="sourceLine" id="cb28-14" data-line-number="14">    <span class="ot">{-# NOINLINE combine #-}</span></a>
<a class="sourceLine" id="cb28-15" data-line-number="15">    conv ref x <span class="fu">=</span> unsafeRunST (<span class="dt">Leaf</span> x <span class="fu">&lt;$</span> modifySTRef&#39; ref (incr (<span class="dt">Leaf</span> x)))</a>
<a class="sourceLine" id="cb28-16" data-line-number="16">    <span class="ot">{-# NOINLINE conv #-}</span></a>
<a class="sourceLine" id="cb28-17" data-line-number="17">    unsafeRunST cmp <span class="fu">=</span> unsafePerformIO (unsafeSTToIO cmp)</a>
<a class="sourceLine" id="cb28-18" data-line-number="18"></a>
<a class="sourceLine" id="cb28-19" data-line-number="19"><span class="ot">prop_noRepeatedCalls ::</span> <span class="dt">Property</span></a>
<a class="sourceLine" id="cb28-20" data-line-number="20">prop_noRepeatedCalls <span class="fu">=</span></a>
<a class="sourceLine" id="cb28-21" data-line-number="21">    property <span class="fu">$</span> sized <span class="fu">$</span></a>
<a class="sourceLine" id="cb28-22" data-line-number="22">    \n <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb28-23" data-line-number="23">         pure <span class="fu">$</span></a>
<a class="sourceLine" id="cb28-24" data-line-number="24">         <span class="kw">let</span> src <span class="fu">=</span> [<span class="dv">0</span> <span class="fu">..</span> n]</a>
<a class="sourceLine" id="cb28-25" data-line-number="25">             (tint,tres) <span class="fu">=</span> fmap freqs (traceSubsequences enumerateTrees src)</a>
<a class="sourceLine" id="cb28-26" data-line-number="26">             (fint,fres) <span class="fu">=</span> fmap freqs (traceSubsequences dummyEnumerate src)</a>
<a class="sourceLine" id="cb28-27" data-line-number="27">         <span class="kw">in</span> counterexample</a>
<a class="sourceLine" id="cb28-28" data-line-number="28">                (mapCompare (freqs (allSubTrees src)) tint)</a>
<a class="sourceLine" id="cb28-29" data-line-number="29">                (all (<span class="dv">1</span> <span class="fu">==</span>) tint) <span class="fu">.&amp;&amp;.</span></a>
<a class="sourceLine" id="cb28-30" data-line-number="30">            counterexample (mapCompare tres fres) (tres <span class="fu">==</span> fres) <span class="fu">.&amp;&amp;.</span></a>
<a class="sourceLine" id="cb28-31" data-line-number="31">            (n <span class="fu">&gt;</span> <span class="dv">2</span> <span class="fu">==&gt;</span> tint <span class="fu">/=</span> fint)</a></code></pre></div>
<p>Here, <code class="sourceCode haskell">dummyEnumerate</code> is some method which performs the same task, but <em>doesn‚Äôt</em> construct a nexus, so we can ensure that our tests really do catch faulty implementations.</p>
<div id="refs" class="references">
<div id="ref-bird_functional_2003">
<p>Bird, Richard, and Ralf Hinze. 2003. ‚ÄúFunctional Pearl Trouble Shared is Trouble Halved.‚Äù In <em>Proceedings of the 2003 ACM SIGPLAN Workshop on Haskell</em>, 1‚Äì6. Haskell ‚Äô03. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/871895.871896">10.1145/871895.871896</a>. <a href="http://doi.acm.org/10.1145/871895.871896" class="uri">http://doi.acm.org/10.1145/871895.871896</a>.</p>
</div>
<div id="ref-bird_countdown:_2005">
<p>Bird, Richard, and Shin-Cheng Mu. 2005. ‚ÄúCountdown: A case study in origami programming.‚Äù <em>Journal of Functional Programming</em> 15 (05) (August): 679. doi:<a href="https://doi.org/10.1017/S0956796805005642">10.1017/S0956796805005642</a>. <a href="http://www.journals.cambridge.org/abstract_S0956796805005642" class="uri">http://www.journals.cambridge.org/abstract_S0956796805005642</a>.</p>
</div>
<div id="ref-danvy_there_2005">
<p>Danvy, Olivier, and Mayer Goldberg. 2005. ‚ÄúThere and Back Again.‚Äù <em>BRICS Report Series</em> 12 (3). doi:<a href="https://doi.org/10.7146/brics.v12i3.21869">10.7146/brics.v12i3.21869</a>. <a href="https://tidsskrift.dk/brics/article/view/21869" class="uri">https://tidsskrift.dk/brics/article/view/21869</a>.</p>
</div>
<div id="ref-hutton_countdown_2002">
<p>Hutton, Graham. 2002. ‚ÄúThe Countdown Problem.‚Äù <em>J. Funct. Program.</em> 12 (6) (November): 609‚Äì616. doi:<a href="https://doi.org/10.1017/S0956796801004300">10.1017/S0956796801004300</a>. <a href="http://www.cs.nott.ac.uk/~pszgmh/countdown.pdf" class="uri">http://www.cs.nott.ac.uk/~pszgmh/countdown.pdf</a>.</p>
</div>
<div id="ref-steffen_table_2006">
<p>Steffen, Peter, and Robert Giegerich. 2006. ‚ÄúTable Design in Dynamic Programming.‚Äù <em>Information and Computation</em> 204 (9) (September): 1325‚Äì1345. doi:<a href="https://doi.org/10.1016/j.ic.2006.02.006">10.1016/j.ic.2006.02.006</a>. <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.85.601&amp;rep=rep1&amp;type=pdf" class="uri">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.85.601&amp;rep=rep1&amp;type=pdf</a>.</p>
</div>
<div id="ref-tobin_time_2016">
<p>Tobin, Jared. 2016. ‚ÄúTime Traveling Recursion Schemes.‚Äù <em>jtobin.io</em>. <a href="https://jtobin.io/time-traveling-recursion" class="uri">https://jtobin.io/time-traveling-recursion</a>.</p>
</div>
</div>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>If you think that structure looks more like a funny linked list than a tree, that‚Äôs because it is. Instead of talking about ‚Äúleft‚Äù and ‚Äúright‚Äù branches, we could talk about the first and second elements in a list: in fact, this is exactly what‚Äôs happening in the famous <code class="sourceCode haskell">zipWith</code> Fibonacci implementation (in reverse).</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1">fibs <span class="fu">=</span> <span class="dv">0</span> <span class="fu">:</span> <span class="dv">1</span> <span class="fu">:</span> zipWith (<span class="fu">+</span>) fibs (tail fibs)</a></code></pre></div>
<p>Or, in my favourite version:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">fib n <span class="fu">=</span> fix ((<span class="fu">:</span>) <span class="dv">0</span> <span class="fu">.</span> scanl (<span class="fu">+</span>) <span class="dv">1</span>) <span class="fu">!!</span> n</a></code></pre></div>
<a href="#fnref1" class="footnote-back">‚Ü©</a></li>
</ol>
</section>
]]></description>
    <pubDate>Tue, 20 Mar 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-03-20-countdown.html</guid>
    <dc:creator>Donnacha Ois√≠n Kidney</dc:creator>
</item>
<item>
    <title>Rose Trees, Breadth-First</title>
    <link>https://doisinkidney.com/posts/2018-03-17-rose-trees-breadth-first.html</link>
    <description><![CDATA[<div class="info">
    Posted on March 17, 2018
</div>
<div class="info">
    
        Part 1 of a <a href="/series/Breadth-First%20Traversals.html">5-part series on Breadth-First Traversals</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<p>In contrast to the more common binary trees, in a rose tree every node can have any number of children.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Node</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">    {<span class="ot"> root   ::</span> a</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">    ,<span class="ot"> forest ::</span> <span class="dt">Forest</span> a</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">    }</a>
<a class="sourceLine" id="cb1-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="kw">type</span> <span class="dt">Forest</span> a <span class="fu">=</span> [<span class="dt">Tree</span> a]</a></code></pre></div>
<p>One of the important manipulations of this data structure, which forms the basis for several other algorithms, is a breadth-first traversal. I‚Äôd like to go through a couple of techniques for implementing it, and how more generally you can often get away with using much simpler data structures if you really pinpoint the API you need from them.</p>
<p>As a general technique, <span class="citation" data-cites="okasaki_breadth-first_2000">Okasaki (<a href="#ref-okasaki_breadth-first_2000">2000</a>)</span> advises that a queue be used:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">breadthFirst ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">breadthFirst tr <span class="fu">=</span> go (singleton tr)</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">    go q <span class="fu">=</span> <span class="kw">case</span> pop q <span class="kw">of</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5">      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> []</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">      <span class="dt">Just</span> (<span class="dt">Node</span> x xs,qs) <span class="ot">-&gt;</span> x <span class="fu">:</span> go (qs <span class="ot">`append`</span> xs)</a></code></pre></div>
<p>There are three functions left undefined there: <code class="sourceCode haskell">singleton</code>, <code class="sourceCode haskell">pop</code>, and <code class="sourceCode haskell">append</code>. They represent the API of our as-of-yet unimplemented queue, and their complexity will dictate the complexity of the overall algorithm. As a (bad) first choice, we could use simple lists, with the functions defined thus:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1">singleton x <span class="fu">=</span> [x]</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">pop (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="dt">Just</span> (x,xs)</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">pop [] <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">append <span class="fu">=</span> (<span class="fu">++</span>)</a></code></pre></div>
<p>Those repeated appends are bad news. The queue needs to be able to support popping from one side and appending from the other, which is something lists absolutely <em>cannot</em> do well.</p>
<p>We could swap in a more general queue implementation, possibly using Data.Sequence, or a pair of lists. But these are more complex and general than we need, so let‚Äôs try and pare down the requirements a little more.</p>
<p>First, we don‚Äôt need a pop: the go function can be expressed as a fold instead. Second, we don‚Äôt need <em>every</em> append to be immediately stuck into the queue, we can batch them, first appending to a structure that‚Äôs efficient for appends, and then converting that to a structure which is efficient for folds. In code:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">breadthFirst ::</span> <span class="dt">Forest</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">breadthFirst ts <span class="fu">=</span> foldr f b ts []</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">    f (<span class="dt">Node</span> x xs) fw bw <span class="fu">=</span> x <span class="fu">:</span> fw (xs <span class="fu">:</span> bw)</a>
<a class="sourceLine" id="cb4-5" data-line-number="5"></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">    b [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb4-7" data-line-number="7">    b qs <span class="fu">=</span> foldl (foldr f) b qs []</a></code></pre></div>
<p>We‚Äôre consing instead of appending, but the consumption is being done in the correct direction anyway, because of the <code class="sourceCode haskell">foldl</code>.</p>
<h2 id="levels">Levels</h2>
<p>So next step: to get the <code class="sourceCode haskell">levels</code> function from Data.Tree. Instead of doing a breadth-first traversal, it returns the nodes at each <em>level</em> of the tree. Conceptually, every time we did the reverse above (called <code class="sourceCode haskell">foldl</code>), we will do a cons as well:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">levels ::</span> <span class="dt">Forest</span> a <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">levels ts <span class="fu">=</span> foldl f b ts [] []</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">    f k (<span class="dt">Node</span> x xs) ls qs <span class="fu">=</span> k (x <span class="fu">:</span> ls) (xs <span class="fu">:</span> qs)</a>
<a class="sourceLine" id="cb5-5" data-line-number="5"></a>
<a class="sourceLine" id="cb5-6" data-line-number="6">    b _ [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb5-7" data-line-number="7">    b k qs <span class="fu">=</span> k <span class="fu">:</span> foldl (foldl f) b qs [] []</a></code></pre></div>
<h2 id="unfolding">Unfolding</h2>
<p>The original reason I started work on these problems was <a href="https://github.com/haskell/containers/issues/124">this</a> issue in containers. It concerns the <a href="https://hackage.haskell.org/package/containers-0.5.11.0/docs/Data-Tree.html#v:unfoldTreeM_BF"><code>unfoldTreeM_BF</code></a> function. An early go at rewriting it, inspired by levels above, looks like this:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">unfoldForestM_BF ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (b <span class="ot">-&gt;</span> m (a, [b])) <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> m (<span class="dt">Forest</span> a)</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">unfoldForestM_BF f ts <span class="fu">=</span> b [ts] (const id)</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">    b [] k <span class="fu">=</span> pure (k [] [])</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">    b qs k <span class="fu">=</span> foldl (foldr t) b qs [] (\x <span class="ot">-&gt;</span> k [] <span class="fu">.</span> foldr (uncurry run) id x)</a>
<a class="sourceLine" id="cb6-6" data-line-number="6"></a>
<a class="sourceLine" id="cb6-7" data-line-number="7">    t a fw bw k <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">        (x,cs) <span class="ot">&lt;-</span> f a</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">        <span class="kw">let</span> <span class="fu">!</span>n <span class="fu">=</span> length cs</a>
<a class="sourceLine" id="cb6-10" data-line-number="10">        fw (cs <span class="fu">:</span> bw) (k <span class="fu">.</span> (<span class="fu">:</span>) (x, n))</a>
<a class="sourceLine" id="cb6-11" data-line-number="11"></a>
<a class="sourceLine" id="cb6-12" data-line-number="12">    run x n xs ys <span class="fu">=</span></a>
<a class="sourceLine" id="cb6-13" data-line-number="13">      <span class="kw">case</span> splitAt n ys <span class="kw">of</span></a>
<a class="sourceLine" id="cb6-14" data-line-number="14">          (cs,zs) <span class="ot">-&gt;</span> <span class="dt">Node</span> x cs <span class="fu">:</span> xs zs</a></code></pre></div>
<p>It basically performs the same this as the levels function, but builds the tree back up in the end using the <code class="sourceCode haskell">run</code> function. In order to do that, we store the length of each subforest on line 9, so that each node knows how much to take from each level.</p>
<p>A possible optimization is to stop taking the length. Anything in list processing that takes a length screams ‚Äúwrong‚Äù to me (although it‚Äôs not always true!) so I often try to find a way to avoid it. The first option would be to keep the <code class="sourceCode haskell">cs</code> on line 8 around, and use <em>it</em> as an indicator for the length. That keeps it around longer than strictly necessary, though. The other option is to add a third level: for <code class="sourceCode haskell">breadthFirst</code> above, we had one level; for <code class="sourceCode haskell">levels</code>, we added another, to indicate the structure of the nodes and their subtrees; here, we can add a third, to maintain that structure when building back up:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">unfoldForestM_BF ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (b <span class="ot">-&gt;</span> m (a, [b])) <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> m (<span class="dt">Forest</span> a)</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">unfoldForestM_BF f ts <span class="fu">=</span> b [ts] (\ls <span class="ot">-&gt;</span> concat <span class="fu">.</span> ls)</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">    b [] k <span class="fu">=</span> pure (k id [])</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">    b qs k <span class="fu">=</span> foldl g b qs [] (\ls <span class="ot">-&gt;</span> k id <span class="fu">.</span> ls)</a>
<a class="sourceLine" id="cb7-6" data-line-number="6"></a>
<a class="sourceLine" id="cb7-7" data-line-number="7">    g a xs qs k <span class="fu">=</span> foldr t (\ls ys <span class="ot">-&gt;</span> a ys (k <span class="fu">.</span> run ls)) xs [] qs</a>
<a class="sourceLine" id="cb7-8" data-line-number="8"></a>
<a class="sourceLine" id="cb7-9" data-line-number="9">    t a fw xs bw <span class="fu">=</span> f a <span class="fu">&gt;&gt;=</span> \(x,cs) <span class="ot">-&gt;</span> fw (x<span class="fu">:</span>xs) (cs<span class="fu">:</span>bw)</a>
<a class="sourceLine" id="cb7-10" data-line-number="10"></a>
<a class="sourceLine" id="cb7-11" data-line-number="11">    run x xs <span class="fu">=</span> uncurry (<span class="fu">:</span>) <span class="fu">.</span> foldl go ((,) [] <span class="fu">.</span> xs) x</a>
<a class="sourceLine" id="cb7-12" data-line-number="12">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-13" data-line-number="13">        go ys y (z<span class="fu">:</span>zs) <span class="fu">=</span> (<span class="dt">Node</span> y z <span class="fu">:</span> ys&#39;, zs&#39;)</a>
<a class="sourceLine" id="cb7-14" data-line-number="14">          <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-15" data-line-number="15">            (ys&#39;,zs&#39;) <span class="fu">=</span> ys zs</a></code></pre></div>
<p>This unfortunately <em>slows down</em> the code.</p>
<div id="refs" class="references">
<div id="ref-okasaki_breadth-first_2000">
<p>Okasaki, Chris. 2000. ‚ÄúBreadth-first Numbering: Lessons from a Small Exercise in Algorithm Design.‚Äù In <em>Proceedings of the Fifth ACM SIGPLAN International Conference on Functional Programming</em>, 131‚Äì136. ICFP ‚Äô00. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/351240.351253">10.1145/351240.351253</a>. <a href="https://www.cs.tufts.edu/~nr/cs257/archive/chris-okasaki/breadth-first.pdf" class="uri">https://www.cs.tufts.edu/~nr/cs257/archive/chris-okasaki/breadth-first.pdf</a>.</p>
</div>
</div>
]]></description>
    <pubDate>Sat, 17 Mar 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-03-17-rose-trees-breadth-first.html</guid>
    <dc:creator>Donnacha Ois√≠n Kidney</dc:creator>
</item>
<item>
    <title>Single-Pass Huffman Coding</title>
    <link>https://doisinkidney.com/posts/2018-02-17-single-pass-huffman.html</link>
    <description><![CDATA[<div class="info">
    Posted on February 17, 2018
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Folds.html">Folds</a>
    
</div>

<p>While working on something else, I figured out a nice Haskell implementation of Huffman coding, and I thought I‚Äôd share it here. I‚Äôll go through a few techniques for transforming a multi-pass algorithm into a single-pass one first, and then I‚Äôll show how to use them for Huffman. If you just want to skip to the code, it‚Äôs provided at the end.<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a></p>
<p>The algorithm isn‚Äôt single-pass in the sense of <a href="https://www2.cs.duke.edu/csed/curious/compression/adaptivehuff.html">Adaptive Huffman Coding</a>: it still uses the normal Huffman algorithm, but the input is transformed in the same traversal that builds the tree to transform it.</p>
<h2 id="circular-programming">Circular Programming</h2>
<p>There are several techniques for turning multi-pass algorithms into single-pass ones in functional languages. Perhaps the most famous is circular programming: using <em>laziness</em> to eliminate a pass. <span class="citation" data-cites="bird_using_1984">Bird (<a href="#ref-bird_using_1984">1984</a>)</span> used this to great effect in solving the repmin problem:</p>
<blockquote>
<p>Given a tree of integers, replace every integer with the minimum integer in the tree, in one pass.</p>
</blockquote>
<p>For an imperative programmer, the problem is relatively easy: first, write the code to find the minimum value in the tree in the standard way, using a loop and a ‚Äúsmallest so far‚Äù accumulator. Then, inside the loop, after updating the accumulator, set the value of the leaf to be a <em>reference</em> to the accumulator.</p>
<p>At first, that solution may seem necessarily impure: we‚Äôre using global, mutable state to update many things at once. However, as the paper shows, we can claw back purity using laziness:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a <span class="fu">=</span> <span class="dt">Leaf</span> a <span class="fu">|</span> <span class="dt">Tree</span> a <span class="fu">:*:</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb2-2" data-line-number="2"></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="ot">repMin ::</span> <span class="dt">Tree</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Tree</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">repMin xs <span class="fu">=</span> ys <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5">  (m, ys) <span class="fu">=</span> go xs</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">  go (<span class="dt">Leaf</span> x) <span class="fu">=</span> (x, <span class="dt">Leaf</span> m)</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">  go (xs <span class="fu">:*:</span> ys) <span class="fu">=</span> (min x y, xs&#39; <span class="fu">:*:</span> ys&#39;)</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9">      (x,xs&#39;) <span class="fu">=</span> go xs</a>
<a class="sourceLine" id="cb2-10" data-line-number="10">      (y,ys&#39;) <span class="fu">=</span> go ys</a></code></pre></div>
<h2 id="there-and-back-again">There and Back Again</h2>
<p>Let‚Äôs say we don‚Äôt have laziness at our disposal: are we hosed? No!<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a> <span class="citation" data-cites="danvy_there_2005">Danvy and Goldberg (<a href="#ref-danvy_there_2005">2005</a>)</span> explore this very issue, by posing the question:</p>
<blockquote>
<p>Given two lists, xs and ys, can you zip xs with the reverse of ys in one pass?</p>
</blockquote>
<p>The technique used to solve the problem is named ‚ÄúThere and Back Again‚Äù; it should be clear why from one of the solutions:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1">convolve xs ys <span class="fu">=</span> walk xs const <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  walk [] k <span class="fu">=</span> k [] ys</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">  walk (x<span class="fu">:</span>xs) k <span class="fu">=</span> walk xs (\r (y<span class="fu">:</span>ys) <span class="ot">-&gt;</span> k ((x,y) <span class="fu">:</span> r) ys)</a></code></pre></div>
<p>The traversal of one list builds up the function to consume the other. We could write repmin in the same way:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">repMin <span class="fu">=</span> uncurry (<span class="fu">$</span>) <span class="fu">.</span> go <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  go (<span class="dt">Leaf</span> x) <span class="fu">=</span> (<span class="dt">Leaf</span>, x)</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  go (xs <span class="fu">:*:</span> ys) <span class="fu">=</span> (\m <span class="ot">-&gt;</span> xs&#39; m <span class="fu">:*:</span> ys&#39; m, min xm ym) <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">    (xs&#39;,xm) <span class="fu">=</span> go xs</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">    (ys&#39;,ym) <span class="fu">=</span> go ys</a></code></pre></div>
<h2 id="cayley-representations">Cayley Representations</h2>
<p>If you‚Äôre doing a lot of appending to some list-like structure, you probably don‚Äôt want to use actual lists: you‚Äôll end up traversing the left-hand-side of the append many more times than necessary. A type you can drop in to use instead is difference lists <span class="citation" data-cites="hughes_novel_1986">(Hughes <a href="#ref-hughes_novel_1986">1986</a>)</span>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">type</span> <span class="dt">DList</span> a <span class="fu">=</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb5-2" data-line-number="2"></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="ot">rep ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">DList</span> a</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">rep <span class="fu">=</span> (<span class="fu">++</span>)</a>
<a class="sourceLine" id="cb5-5" data-line-number="5"></a>
<a class="sourceLine" id="cb5-6" data-line-number="6">abs<span class="ot"> ::</span> <span class="dt">DList</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb5-7" data-line-number="7">abs xs <span class="fu">=</span> xs []</a>
<a class="sourceLine" id="cb5-8" data-line-number="8"></a>
<a class="sourceLine" id="cb5-9" data-line-number="9"><span class="ot">append ::</span> <span class="dt">DList</span> a <span class="ot">-&gt;</span> <span class="dt">DList</span> a <span class="ot">-&gt;</span> <span class="dt">DList</span> a</a>
<a class="sourceLine" id="cb5-10" data-line-number="10">append <span class="fu">=</span> (<span class="fu">.</span>)</a></code></pre></div>
<p><code class="sourceCode haskell">append</code> is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math> in this representation. In fact, for any monoid with a slow <code class="sourceCode haskell">mappend</code>, you can use the same trick: it‚Äôs called the Cayley representation, and available as <code class="sourceCode haskell"><span class="dt">Endo</span></code> in <a href="https://hackage.haskell.org/package/base-4.10.1.0/docs/Data-Monoid.html#t:Endo">Data.Monoid</a>.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">rep ::</span> <span class="dt">Monoid</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Endo</span> a</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">rep x <span class="fu">=</span> <span class="dt">Endo</span> (mappend x)</a>
<a class="sourceLine" id="cb6-3" data-line-number="3"></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">abs<span class="ot"> ::</span> <span class="dt">Monoid</span> a <span class="ot">=&gt;</span> <span class="dt">Endo</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">abs (<span class="dt">Endo</span> f) <span class="fu">=</span> f mempty</a>
<a class="sourceLine" id="cb6-6" data-line-number="6"></a>
<a class="sourceLine" id="cb6-7" data-line-number="7"><span class="kw">instance</span> <span class="dt">Monoid</span> (<span class="dt">Endo</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">  mempty <span class="fu">=</span> <span class="dt">Endo</span> id</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">  mappend (<span class="dt">Endo</span> f) (<span class="dt">Endo</span> g) <span class="fu">=</span> <span class="dt">Enfo</span> (f <span class="fu">.</span> g)</a></code></pre></div>
<p>You can actually do the same transformation for ‚Äúmonoids‚Äù in the categorical sense: applying it to monads, for instance, will give you codensity <span class="citation" data-cites="rivas_notions_2014">(Rivas and Jaskelioff <a href="#ref-rivas_notions_2014">2014</a>)</span>.</p>
<h2 id="traversable">Traversable</h2>
<p>Looking back‚Äîjust for a second‚Äîto the repmin example, we should be able to spot a pattern we can generalize. There‚Äôs really nothing tree-specific about it, so why can‚Äôt we apply it to lists? Or other structures, for that matter? It turns out we can: the <code class="sourceCode haskell">mapAccumL</code> function is tailor-made to this need:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">repMin ::</span> <span class="dt">Traversable</span> t <span class="ot">=&gt;</span> t <span class="dt">Integer</span> <span class="ot">-&gt;</span> t <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">repMin xs <span class="fu">=</span> ys <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  (<span class="fu">~</span>(<span class="dt">Just</span> m), ys) <span class="fu">=</span> mapAccumL f <span class="dt">Nothing</span> xs</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">  f <span class="dt">Nothing</span> x <span class="fu">=</span> (<span class="dt">Just</span> x, m)</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">  f (<span class="dt">Just</span> y) x <span class="fu">=</span> (<span class="dt">Just</span> (min x y), m)</a></code></pre></div>
<p>The tilde before the <code class="sourceCode haskell"><span class="dt">Just</span></code> ensures this won‚Äôt fail on empty input.</p>
<h1 id="huffman-coding">Huffman Coding</h1>
<p>Finally, it‚Äôs time for the main event. Huffman coding is a <em>very</em> multi-pass algorithm, usually. The steps look like this:</p>
<ol type="1">
<li>Build a frequency table for each character in the input.</li>
<li>Build a priority queue from that frequency table.</li>
<li>Iteratively pop elements and combine them (into Huffman trees) from the queue until there‚Äôs only one left.</li>
<li>That Huffman tree can be used to construct the mapping from items back to their Huffman codes.</li>
<li>Traverse the input again, using the constructed mapping to replace elements with their codes.</li>
</ol>
<p>We can‚Äôt <em>skip</em> any of these steps: we can try perform them all at once, though.</p>
<p>Let‚Äôs write the multi-pass version first. We‚Äôll need the frequency table:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">frequencies ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Map</span> a <span class="dt">Int</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">frequencies <span class="fu">=</span> Map.fromListWith (<span class="fu">+</span>) <span class="fu">.</span> map (flip (,) <span class="dv">1</span>)</a></code></pre></div>
<p>And a heap, ordered on the frequencies of its elements (I‚Äôm using a skew heap here):</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Heap</span> a</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  <span class="fu">|</span> <span class="dt">Node</span> <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">Int</span> a (<span class="dt">Heap</span> a) (<span class="dt">Heap</span> a)</a>
<a class="sourceLine" id="cb9-4" data-line-number="4"></a>
<a class="sourceLine" id="cb9-5" data-line-number="5"><span class="kw">instance</span> <span class="dt">Monoid</span> (<span class="dt">Heap</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6">  mappend <span class="dt">Nil</span> ys <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">  mappend xs <span class="dt">Nil</span> <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb9-8" data-line-number="8">  mappend h1<span class="fu">@</span>(<span class="dt">Node</span> i x lx rx) h2<span class="fu">@</span>(<span class="dt">Node</span> j y ly ry)</a>
<a class="sourceLine" id="cb9-9" data-line-number="9">    <span class="fu">|</span> i <span class="fu">&lt;=</span> j    <span class="fu">=</span> <span class="dt">Node</span> i x (mappend h2 rx) lx</a>
<a class="sourceLine" id="cb9-10" data-line-number="10">    <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Node</span> j y (mappend h1 ry) ly</a>
<a class="sourceLine" id="cb9-11" data-line-number="11">  mempty <span class="fu">=</span> <span class="dt">Nil</span></a></code></pre></div>
<p>Next, we need to build the tree<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>. We can use the tree type from above.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">buildTree ::</span> <span class="dt">Map</span> a <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Tree</span> a)</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">buildTree <span class="fu">=</span> prune <span class="fu">.</span> toHeap <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  toHeap <span class="fu">=</span> Map.foldMapWithKey (\k v <span class="ot">-&gt;</span> <span class="dt">Node</span> v (<span class="dt">Leaf</span> k) <span class="dt">Nil</span> <span class="dt">Nil</span>)</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">  prune <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb10-5" data-line-number="5">  prune (<span class="dt">Node</span> i x l r) <span class="fu">=</span> <span class="kw">case</span> mappend l r <span class="kw">of</span></a>
<a class="sourceLine" id="cb10-6" data-line-number="6">    <span class="dt">Nil</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> x</a>
<a class="sourceLine" id="cb10-7" data-line-number="7">    <span class="dt">Node</span> j y l&#39; r&#39; <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb10-8" data-line-number="8">      prune (mappend (<span class="dt">Node</span> (i<span class="fu">+</span>j) (x <span class="fu">:*:</span> y) <span class="dt">Nil</span> <span class="dt">Nil</span>) (mappend l&#39; r&#39;))</a></code></pre></div>
<p>Then, a way to convert between the tree and a map:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">toMapping ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Map</span> a [<span class="dt">Bool</span>]</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">toMapping (<span class="dt">Leaf</span> x) <span class="fu">=</span> Map.singleton x []</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">toMapping (xs <span class="fu">:*:</span> ys) <span class="fu">=</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4">    Map.union (fmap (<span class="dt">True</span><span class="fu">:</span>) (toMapping xs)) (fmap (<span class="dt">False</span><span class="fu">:</span>) (toMapping ys))</a></code></pre></div>
<p>And finally, putting the whole thing together:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="ot">huffman ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> (<span class="dt">Maybe</span> (<span class="dt">Tree</span> a), [[<span class="dt">Bool</span>]])</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">huffman xs <span class="fu">=</span> (tree, map (mapb <span class="fu">Map.!</span>) xs) <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">  freq <span class="fu">=</span> frequencies xs</a>
<a class="sourceLine" id="cb12-4" data-line-number="4">  tree <span class="fu">=</span> buildTree freq</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">  mapb <span class="fu">=</span> maybe Map.empty toMapping tree</a></code></pre></div>
<h2 id="removing-the-passes">Removing the passes</h2>
<p>The first thing to fix is the <code class="sourceCode haskell">toMapping</code> function: at every level, it calls <code class="sourceCode haskell">union</code>, a complex and expensive operation. However, <code class="sourceCode haskell">union</code> and <code class="sourceCode haskell">empty</code> form a monoid, so we can use the Cayley representation to reduce the calls to a minimum. Next, we want to get rid of the <code class="sourceCode haskell">fmap</code>s: we can do that by assembling a function to perform the <code class="sourceCode haskell">fmap</code> as we go, as in <code class="sourceCode haskell">convolve</code><a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a>.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="ot">toMapping ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Map</span> a [<span class="dt">Bool</span>]</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">toMapping tree <span class="fu">=</span> go tree id Map.empty <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">  go (<span class="dt">Leaf</span> x) k <span class="fu">=</span> Map.insert x (k [])</a>
<a class="sourceLine" id="cb13-4" data-line-number="4">  go (xs <span class="fu">:*:</span> ys) k <span class="fu">=</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5">    go xs (k <span class="fu">.</span> (<span class="fu">:</span>) <span class="dt">True</span>) <span class="fu">.</span> go ys (k <span class="fu">.</span> (<span class="fu">:</span>) <span class="dt">False</span>)</a></code></pre></div>
<p>Secondly, we can integrate the <code class="sourceCode haskell">toMapping</code> function with the <code class="sourceCode haskell">buildTree</code> function, removing another pass:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="ot">buildTree ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Map</span> a <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Tree</span> a, <span class="dt">Map</span> a [<span class="dt">Bool</span>])</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">buildTree <span class="fu">=</span> prune <span class="fu">.</span> toHeap <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3">  toHeap <span class="fu">=</span> Map.foldMapWithKey (\k v <span class="ot">-&gt;</span> <span class="dt">Node</span> v (<span class="dt">Leaf</span> k, leaf k) <span class="dt">Nil</span> <span class="dt">Nil</span>)</a>
<a class="sourceLine" id="cb14-4" data-line-number="4">  prune <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb14-5" data-line-number="5">  prune (<span class="dt">Node</span> i x l r) <span class="fu">=</span> <span class="kw">case</span> mappend l r <span class="kw">of</span></a>
<a class="sourceLine" id="cb14-6" data-line-number="6">    <span class="dt">Nil</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> (fmap (\k <span class="ot">-&gt;</span> k id Map.empty) x)</a>
<a class="sourceLine" id="cb14-7" data-line-number="7">    <span class="dt">Node</span> j y l&#39; r&#39; <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb14-8" data-line-number="8">      prune (mappend (<span class="dt">Node</span> (i<span class="fu">+</span>j) (cmb x y) <span class="dt">Nil</span> <span class="dt">Nil</span>) (mappend l&#39; r&#39;))</a>
<a class="sourceLine" id="cb14-9" data-line-number="9">  leaf x k <span class="fu">=</span> Map.insert x (k [])</a>
<a class="sourceLine" id="cb14-10" data-line-number="10">  node xs ys k <span class="fu">=</span> xs (k <span class="fu">.</span> (<span class="fu">:</span>) <span class="dt">True</span>) <span class="fu">.</span> ys (k <span class="fu">.</span> (<span class="fu">:</span>) <span class="dt">False</span>)</a>
<a class="sourceLine" id="cb14-11" data-line-number="11">  cmb (xt,xm) (yt,ym) <span class="fu">=</span> (xt <span class="fu">:*:</span> yt, node xm ym)</a></code></pre></div>
<p>Finally, to remove the second pass over the list, we can copy repmin, using <code class="sourceCode haskell">mapAccumL</code> to both construct the mapping and apply it to the structure in one go.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="ot">huffman ::</span> (<span class="dt">Ord</span> a, <span class="dt">Traversable</span> t) <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> (<span class="dt">Maybe</span> (<span class="dt">Tree</span> a), t [<span class="dt">Bool</span>])</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">huffman xs <span class="fu">=</span> (fmap fst tree, ys) <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-3" data-line-number="3">  (freq,ys) <span class="fu">=</span> mapAccumL f Map.empty xs</a>
<a class="sourceLine" id="cb15-4" data-line-number="4">  f fm x <span class="fu">=</span> (Map.insertWith (<span class="fu">+</span>) x <span class="dv">1</span> fm, mapb <span class="fu">Map.!</span> x)</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">  tree <span class="fu">=</span> buildTree freq</a>
<a class="sourceLine" id="cb15-6" data-line-number="6">  mapb <span class="fu">=</span> maybe Map.empty snd tree</a></code></pre></div>
<p>And that‚Äôs it!</p>
<h1 id="generalization">Generalization</h1>
<p>The similarity between the repmin function and the solution above is suggestive: is there a way to <em>encode</em> this idea of making a multi-pass algorithm single-pass? Of course! We can use an applicative:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Circular</span> a b c <span class="fu">=</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2">    <span class="dt">Circular</span> <span class="fu">!</span>a</a>
<a class="sourceLine" id="cb16-3" data-line-number="3">             (b <span class="ot">-&gt;</span> c)</a>
<a class="sourceLine" id="cb16-4" data-line-number="4"></a>
<a class="sourceLine" id="cb16-5" data-line-number="5"><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Circular</span> a b) <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-6" data-line-number="6">    fmap f (<span class="dt">Circular</span> tally run) <span class="fu">=</span> <span class="dt">Circular</span> tally (f <span class="fu">.</span> run)</a>
<a class="sourceLine" id="cb16-7" data-line-number="7"></a>
<a class="sourceLine" id="cb16-8" data-line-number="8"><span class="kw">instance</span> <span class="dt">Monoid</span> a <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb16-9" data-line-number="9">         <span class="dt">Applicative</span> (<span class="dt">Circular</span> a b) <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-10" data-line-number="10">    pure x <span class="fu">=</span> <span class="dt">Circular</span> mempty (const x)</a>
<a class="sourceLine" id="cb16-11" data-line-number="11">    <span class="dt">Circular</span> fl fr <span class="fu">&lt;*&gt;</span> <span class="dt">Circular</span> xl xr <span class="fu">=</span></a>
<a class="sourceLine" id="cb16-12" data-line-number="12">        <span class="dt">Circular</span></a>
<a class="sourceLine" id="cb16-13" data-line-number="13">            (mappend fl xl)</a>
<a class="sourceLine" id="cb16-14" data-line-number="14">            (\r <span class="ot">-&gt;</span> fr r (xr r))</a>
<a class="sourceLine" id="cb16-15" data-line-number="15"></a>
<a class="sourceLine" id="cb16-16" data-line-number="16">liftHuffman</a>
<a class="sourceLine" id="cb16-17" data-line-number="17"><span class="ot">    ::</span> <span class="dt">Ord</span> a</a>
<a class="sourceLine" id="cb16-18" data-line-number="18">    <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Circular</span> (<span class="dt">Map</span> a <span class="dt">Int</span>) (<span class="dt">Map</span> a [<span class="dt">Bool</span>]) [<span class="dt">Bool</span>]</a>
<a class="sourceLine" id="cb16-19" data-line-number="19">liftHuffman x <span class="fu">=</span> <span class="dt">Circular</span> (Map.singleton x <span class="dv">1</span>) (<span class="fu">Map.!</span> x)</a>
<a class="sourceLine" id="cb16-20" data-line-number="20"></a>
<a class="sourceLine" id="cb16-21" data-line-number="21">runHuffman</a>
<a class="sourceLine" id="cb16-22" data-line-number="22"><span class="ot">    ::</span> <span class="dt">Ord</span> a</a>
<a class="sourceLine" id="cb16-23" data-line-number="23">    <span class="ot">=&gt;</span> <span class="dt">Circular</span> (<span class="dt">Map</span> a <span class="dt">Int</span>) (<span class="dt">Map</span> a [<span class="dt">Bool</span>]) r <span class="ot">-&gt;</span> (<span class="dt">Maybe</span> (<span class="dt">Tree</span> a), r)</a>
<a class="sourceLine" id="cb16-24" data-line-number="24">runHuffman (<span class="dt">Circular</span> smry run) <span class="fu">=</span></a>
<a class="sourceLine" id="cb16-25" data-line-number="25">    maybe (<span class="dt">Nothing</span>, run Map.empty) (<span class="dt">Just</span> <span class="fu">***</span> run) (buildTree smry)</a>
<a class="sourceLine" id="cb16-26" data-line-number="26"></a>
<a class="sourceLine" id="cb16-27" data-line-number="27">huffman</a>
<a class="sourceLine" id="cb16-28" data-line-number="28"><span class="ot">    ::</span> (<span class="dt">Ord</span> a, <span class="dt">Traversable</span> t)</a>
<a class="sourceLine" id="cb16-29" data-line-number="29">    <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> (<span class="dt">Maybe</span> (<span class="dt">Tree</span> a), t [<span class="dt">Bool</span>])</a>
<a class="sourceLine" id="cb16-30" data-line-number="30">huffman <span class="fu">=</span> runHuffman <span class="fu">.</span> traverse liftHuffman</a></code></pre></div>
<p>Thanks to it being an applicative, you can do all the fun lensy things with it:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="ot">showBin ::</span> [<span class="dt">Bool</span>] <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2">showBin <span class="fu">=</span> map (bool <span class="ch">&#39;0&#39;</span> <span class="ch">&#39;1&#39;</span>)</a>
<a class="sourceLine" id="cb17-3" data-line-number="3"></a>
<a class="sourceLine" id="cb17-4" data-line-number="4"><span class="fu">&gt;&gt;&gt;</span> <span class="kw">let</span> liftBin <span class="fu">=</span> fmap showBin <span class="fu">.</span> liftHuffman</a>
<a class="sourceLine" id="cb17-5" data-line-number="5"><span class="fu">&gt;&gt;&gt;</span> (snd <span class="fu">.</span> runHuffman <span class="fu">.</span> (each<span class="fu">.</span>traverse) liftBin) (<span class="st">&quot;abb&quot;</span>, <span class="st">&quot;cad&quot;</span>, <span class="st">&quot;c&quot;</span>)</a>
<a class="sourceLine" id="cb17-6" data-line-number="6">([<span class="st">&quot;01&quot;</span>,<span class="st">&quot;11&quot;</span>,<span class="st">&quot;11&quot;</span>],[<span class="st">&quot;00&quot;</span>,<span class="st">&quot;01&quot;</span>,<span class="st">&quot;10&quot;</span>],[<span class="st">&quot;00&quot;</span>])</a></code></pre></div>
<p>Bringing us back to the start, it can also let us solve repmin!</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="ot">liftRepMin ::</span> a <span class="ot">-&gt;</span> <span class="dt">Circular</span> (<span class="dt">Option</span> (<span class="dt">Min</span> a)) a a</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">liftRepMin x <span class="fu">=</span> <span class="dt">Circular</span> (pure (pure x)) id</a>
<a class="sourceLine" id="cb18-3" data-line-number="3"></a>
<a class="sourceLine" id="cb18-4" data-line-number="4"><span class="ot">runRepMin ::</span> <span class="dt">Circular</span> (<span class="dt">Option</span> (<span class="dt">Min</span> a)) a b <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb18-5" data-line-number="5">runRepMin (<span class="dt">Circular</span> m r) <span class="fu">=</span> r (<span class="kw">case</span> m <span class="kw">of</span></a>
<a class="sourceLine" id="cb18-6" data-line-number="6">  <span class="dt">Option</span> (<span class="dt">Just</span> (<span class="dt">Min</span> x)) <span class="ot">-&gt;</span> x)</a>
<a class="sourceLine" id="cb18-7" data-line-number="7"></a>
<a class="sourceLine" id="cb18-8" data-line-number="8"><span class="ot">repMin ::</span> (<span class="dt">Ord</span> a, <span class="dt">Traversable</span> t) <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> t a</a>
<a class="sourceLine" id="cb18-9" data-line-number="9">repMin <span class="fu">=</span> runRepMin <span class="fu">.</span> traverse liftRepMin</a></code></pre></div>
<h1 id="related">Related</h1>
<p>So the <code class="sourceCode haskell"><span class="dt">Circular</span></code> type is actually just the product of reader and writer, and is closely related to the <a href="https://github.com/treeowl/sort-traversable">sort</a> type.</p>
<p>It‚Äôs also related to the <a href="https://www.reddit.com/r/haskell/comments/7qwzn4/an_update_about_the_store_monad_and_state_comonad/"><code class="sourceCode haskell"><span class="dt">Prescient</span></code></a> type, which I noticed after I‚Äôd written the above.</p>
<h1 id="references" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-bird_more_1997">
<p>Bird, Richard, Geraint Jones, and Oege De Moor. 1997. ‚ÄúMore haste‚Äö less speed: Lazy versus eager evaluation.‚Äù <em>Journal of Functional Programming</em> 7 (5) (September): 541‚Äì547. doi:<a href="https://doi.org/10.1017/S0956796897002827">10.1017/S0956796897002827</a>. <a href="https://ora.ox.ac.uk/objects/uuid:761a4646-60a2-4622-a1e0-ddea11507d57/datastreams/ATTACHMENT01" class="uri">https://ora.ox.ac.uk/objects/uuid:761a4646-60a2-4622-a1e0-ddea11507d57/datastreams/ATTACHMENT01</a>.</p>
</div>
<div id="ref-bird_using_1984">
<p>Bird, R. S. 1984. ‚ÄúUsing Circular Programs to Eliminate Multiple Traversals of Data.‚Äù <em>Acta Inf.</em> 21 (3) (October): 239‚Äì250. doi:<a href="https://doi.org/10.1007/BF00264249">10.1007/BF00264249</a>. <a href="http://dx.doi.org/10.1007/BF00264249" class="uri">http://dx.doi.org/10.1007/BF00264249</a>.</p>
</div>
<div id="ref-danvy_there_2005">
<p>Danvy, Olivier, and Mayer Goldberg. 2005. ‚ÄúThere and Back Again.‚Äù <a href="http://brics.dk/RS/05/3/BRICS-RS-05-3.pdf" class="uri">http://brics.dk/RS/05/3/BRICS-RS-05-3.pdf</a>.</p>
</div>
<div id="ref-hughes_novel_1986">
<p>Hughes, R. John Muir. 1986. ‚ÄúA Novel Representation of Lists and Its Application to the Function &quot;Reverse&quot;.‚Äù <em>Information Processing Letters</em> 22 (3) (March): 141‚Äì144. doi:<a href="https://doi.org/10.1016/0020-0190(86)90059-1">10.1016/0020-0190(86)90059-1</a>. <a href="http://www.sciencedirect.com/science/article/pii/0020019086900591" class="uri">http://www.sciencedirect.com/science/article/pii/0020019086900591</a>.</p>
</div>
<div id="ref-pippenger_pure_1997">
<p>Pippenger, Nicholas. 1997. ‚ÄúPure Versus Impure Lisp.‚Äù <em>ACM Trans. Program. Lang. Syst.</em> 19 (2) (March): 223‚Äì238. doi:<a href="https://doi.org/10.1145/244795.244798">10.1145/244795.244798</a>. <a href="http://doi.acm.org/10.1145/244795.244798" class="uri">http://doi.acm.org/10.1145/244795.244798</a>.</p>
</div>
<div id="ref-rivas_notions_2014">
<p>Rivas, Exequiel, and Mauro Jaskelioff. 2014. ‚ÄúNotions of Computation as Monoids.‚Äù <em>arXiv:1406.4823 [cs, math]</em> (May). <a href="http://arxiv.org/abs/1406.4823" class="uri">http://arxiv.org/abs/1406.4823</a>.</p>
</div>
</div>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Huffman coding single-pass implementation:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">import</span>           <span class="dt">Data.Map.Strict</span>  (<span class="dt">Map</span>)</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map.Strict</span>  <span class="kw">as</span> <span class="dt">Map</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">import</span>           <span class="dt">Data.Traversable</span> (mapAccumL)</a>
<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="kw">data</span> <span class="dt">Heap</span> a</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">  <span class="fu">=</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">  <span class="fu">|</span> <span class="dt">Node</span> <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">Int</span> a (<span class="dt">Heap</span> a) (<span class="dt">Heap</span> a)</a>
<a class="sourceLine" id="cb1-8" data-line-number="8"></a>
<a class="sourceLine" id="cb1-9" data-line-number="9"><span class="kw">instance</span> <span class="dt">Monoid</span> (<span class="dt">Heap</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10">  mappend <span class="dt">Nil</span> ys <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb1-11" data-line-number="11">  mappend xs <span class="dt">Nil</span> <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb1-12" data-line-number="12">  mappend h1<span class="fu">@</span>(<span class="dt">Node</span> i x lx rx) h2<span class="fu">@</span>(<span class="dt">Node</span> j y ly ry)</a>
<a class="sourceLine" id="cb1-13" data-line-number="13">    <span class="fu">|</span> i <span class="fu">&lt;=</span> j    <span class="fu">=</span> <span class="dt">Node</span> i x (mappend h2 rx) lx</a>
<a class="sourceLine" id="cb1-14" data-line-number="14">    <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Node</span> j y (mappend h1 ry) ly</a>
<a class="sourceLine" id="cb1-15" data-line-number="15">  mempty <span class="fu">=</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb1-16" data-line-number="16"></a>
<a class="sourceLine" id="cb1-17" data-line-number="17"><span class="kw">data</span> <span class="dt">Tree</span> a <span class="fu">=</span> <span class="dt">Leaf</span> a <span class="fu">|</span> <span class="dt">Tree</span> a <span class="fu">:*:</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb1-18" data-line-number="18"></a>
<a class="sourceLine" id="cb1-19" data-line-number="19"><span class="ot">buildTree ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Map</span> a <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Tree</span> a, <span class="dt">Map</span> a [<span class="dt">Bool</span>])</a>
<a class="sourceLine" id="cb1-20" data-line-number="20">buildTree <span class="fu">=</span> prune <span class="fu">.</span> toHeap <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-21" data-line-number="21">  toHeap <span class="fu">=</span> Map.foldMapWithKey (\k v <span class="ot">-&gt;</span> <span class="dt">Node</span> v (<span class="dt">Leaf</span> k, leaf k) <span class="dt">Nil</span> <span class="dt">Nil</span>)</a>
<a class="sourceLine" id="cb1-22" data-line-number="22">  prune <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb1-23" data-line-number="23">  prune (<span class="dt">Node</span> i x l r) <span class="fu">=</span> <span class="kw">case</span> mappend l r <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-24" data-line-number="24">    <span class="dt">Nil</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> (fmap (\k <span class="ot">-&gt;</span> k id Map.empty) x)</a>
<a class="sourceLine" id="cb1-25" data-line-number="25">    <span class="dt">Node</span> j y l&#39; r&#39; <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb1-26" data-line-number="26">      prune (mappend (<span class="dt">Node</span> (i<span class="fu">+</span>j) (cmb x y) <span class="dt">Nil</span> <span class="dt">Nil</span>) (mappend l&#39; r&#39;))</a>
<a class="sourceLine" id="cb1-27" data-line-number="27">  leaf x k <span class="fu">=</span> Map.insert x (k [])</a>
<a class="sourceLine" id="cb1-28" data-line-number="28">  node xs ys k <span class="fu">=</span> xs (k <span class="fu">.</span> (<span class="fu">:</span>) <span class="dt">True</span>) <span class="fu">.</span> ys (k <span class="fu">.</span> (<span class="fu">:</span>) <span class="dt">False</span>)</a>
<a class="sourceLine" id="cb1-29" data-line-number="29">  cmb (xt,xm) (yt,ym) <span class="fu">=</span> (xt <span class="fu">:*:</span> yt, node xm ym)</a>
<a class="sourceLine" id="cb1-30" data-line-number="30"></a>
<a class="sourceLine" id="cb1-31" data-line-number="31"><span class="ot">huffman ::</span> (<span class="dt">Ord</span> a, <span class="dt">Traversable</span> t) <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> (<span class="dt">Maybe</span> (<span class="dt">Tree</span> a), t [<span class="dt">Bool</span>])</a>
<a class="sourceLine" id="cb1-32" data-line-number="32">huffman xs <span class="fu">=</span> (fmap fst tree, ys) <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-33" data-line-number="33">  (freq,ys) <span class="fu">=</span> mapAccumL f Map.empty xs</a>
<a class="sourceLine" id="cb1-34" data-line-number="34">  f fm x <span class="fu">=</span> (Map.insertWith (<span class="fu">+</span>) x <span class="dv">1</span> fm, mapb <span class="fu">Map.!</span> x)</a>
<a class="sourceLine" id="cb1-35" data-line-number="35">  tree <span class="fu">=</span> buildTree freq</a>
<a class="sourceLine" id="cb1-36" data-line-number="36">  mapb <span class="fu">=</span> maybe Map.empty snd tree</a></code></pre></div>
<a href="#fnref1" class="footnote-back">‚Ü©</a></li>
<li id="fn2"><p>Well, that‚Äôs a little bit of a lie. In terms of asympostics, <span class="citation" data-cites="pippenger_pure_1997">Pippenger (<a href="#ref-pippenger_pure_1997">1997</a>)</span> stated a problem that could be solved in linear time in impure Lisp, but <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Œ©</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\Omega(n \log n)</annotation></semantics></math> in pure Lisp. <span class="citation" data-cites="bird_more_1997">Bird, Jones, and Moor (<a href="#ref-bird_more_1997">1997</a>)</span> then produced an algorithm that could solve the problem in linear time, by using laziness. So, in some cases, laziness will give you asymptotics you can‚Äôt get without it (if you want to stay pure).<a href="#fnref2" class="footnote-back">‚Ü©</a></p></li>
<li id="fn3"><p>There‚Äôs actually a nicer version of the <code class="sourceCode haskell">buildTree</code> function which uses <code class="sourceCode haskell"><span class="dt">StateT</span> (<span class="dt">Heap</span> a) <span class="dt">Maybe</span></code>, but it‚Äôs equivalent to this one under the hood, and I though might be a little distracting.<a href="#fnref3" class="footnote-back">‚Ü©</a></p></li>
<li id="fn4"><p>Something to notice about this function is that it‚Äôs going top-down and bottom-up at the same time. Combining the maps (with <code class="sourceCode haskell">(<span class="fu">.</span>)</code>) is done bottom-up, but building the codes is top-down. This means the codes are built in reverse order! That‚Äôs why the accumulating parameter (<code class="sourceCode haskell">k</code>) is a difference list, rather than a normal list. As it happens, if normal lists were used, the function would be slightly more efficient through sharing, but the codes would all be reversed.<a href="#fnref4" class="footnote-back">‚Ü©</a></p></li>
</ol>
</section>
]]></description>
    <pubDate>Sat, 17 Feb 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-02-17-single-pass-huffman.html</guid>
    <dc:creator>Donnacha Ois√≠n Kidney</dc:creator>
</item>
<item>
    <title>Monadic List Functions</title>
    <link>https://doisinkidney.com/posts/2018-02-11-monadic-list.functions.html</link>
    <description><![CDATA[<div class="info">
    Posted on February 11, 2018
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Applicative.html">Applicative</a>
    
</div>

<p>Here‚Äôs an old Haskell chestnut:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> filterM (\_ <span class="ot">-&gt;</span> [<span class="dt">False</span>, <span class="dt">True</span>]) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">[[],[<span class="dv">3</span>],[<span class="dv">2</span>],[<span class="dv">2</span>,<span class="dv">3</span>],[<span class="dv">1</span>],[<span class="dv">1</span>,<span class="dv">3</span>],[<span class="dv">1</span>,<span class="dv">2</span>],[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]]</a></code></pre></div>
<p><code class="sourceCode haskell">filterM (\_ <span class="ot">-&gt;</span> [<span class="dt">False</span>,<span class="dt">True</span>])</code> gives the power set of some input list. It‚Äôs one of the especially magical demonstrations of monads. From a high-level perspective, it makes sense: for each element in the list, we want it to be present in one output, and not present in another. It‚Äôs hard to see how it actually <em>works</em>, though. The (old<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>) <a href="https://hackage.haskell.org/package/base-4.7.0.0/docs/src/Control-Monad.html#filterM">source</a> for <code class="sourceCode haskell">filterM</code> doesn‚Äôt help hugely, either:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">filterM          ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m [a]</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">filterM _ []     <span class="fu">=</span>  return []</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">filterM p (x<span class="fu">:</span>xs) <span class="fu">=</span>  <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">   flg <span class="ot">&lt;-</span> p x</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">   ys  <span class="ot">&lt;-</span> filterM p xs</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">   return (<span class="kw">if</span> flg <span class="kw">then</span> x<span class="fu">:</span>ys <span class="kw">else</span> ys)</a></code></pre></div>
<p>Again, elegant and beautiful (aside from the three-space indent), but opaque. Despite not really getting how it works, I was encouraged by its simplicity to try my hand at some of the other functions from Data.List.</p>
<h2 id="grouping">Grouping</h2>
<p>Let‚Äôs start with the subject of my <a href="2018-01-07-groupBy.html">last post</a>. Here‚Äôs the implementation:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">groupBy ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">groupBy p xs <span class="fu">=</span> build (\c n <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">  <span class="kw">let</span> f x a q</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">        <span class="fu">|</span> q x <span class="fu">=</span> (x <span class="fu">:</span> ys, zs)</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">        <span class="fu">|</span> otherwise <span class="fu">=</span> ([], c (x <span class="fu">:</span> ys) zs)</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">        <span class="kw">where</span> (ys,zs) <span class="fu">=</span> a (p x)</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">  <span class="kw">in</span> snd (foldr f (const ([], n)) xs (const <span class="dt">False</span>)))</a></code></pre></div>
<p>It translates over pretty readily:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">groupByM ::</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> m <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m [[a]]</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">groupByM p xs <span class="fu">=</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  fmap snd (foldr f (const (pure ([], []))) xs (const (pure (<span class="dt">False</span>))))</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5">    f x a q <span class="fu">=</span> liftA2 st (q x) (a (p x)) <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">      st b (ys,zs)</a>
<a class="sourceLine" id="cb4-7" data-line-number="7">        <span class="fu">|</span> b <span class="fu">=</span> (x <span class="fu">:</span> ys, zs)</a>
<a class="sourceLine" id="cb4-8" data-line-number="8">        <span class="fu">|</span> otherwise <span class="fu">=</span> ([], (x<span class="fu">:</span>ys)<span class="fu">:</span>zs)</a></code></pre></div>
<p>Let‚Äôs try it with a similar example to <code class="sourceCode haskell">filterM</code>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> groupByM (\_ _ <span class="ot">-&gt;</span> [<span class="dt">False</span>, <span class="dt">True</span>]) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">[[[<span class="dv">1</span>],[<span class="dv">2</span>],[<span class="dv">3</span>]],[[<span class="dv">1</span>],[<span class="dv">2</span>,<span class="dv">3</span>]],[[<span class="dv">1</span>,<span class="dv">2</span>],[<span class="dv">3</span>]],[[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]]]</a></code></pre></div>
<p>It gives the partitions of the list!</p>
<h2 id="sorting">Sorting</h2>
<p>So these monadic generalisations have been discovered before, several times over. There‚Äôs even a <a href="https://hackage.haskell.org/package/monadlist-0.0.2">package</a> with monadic versions of the functions in Data.List. Exploring this idea with a little more formality is the paper ‚ÄúAll Sorts of Permutations‚Äù <span class="citation" data-cites="christiansen_all_2016">(Christiansen, Danilenko, and Dylus <a href="#ref-christiansen_all_2016">2016</a>)</span>, and accompanying presentation <a href="https://www.youtube.com/watch?v=vV3jqTxJ9Wc">on YouTube</a>. They show that the monadic version of sort produces permutations of the input list, and examine the output from different sorting algorithms. Here‚Äôs a couple of their implementations, altered slightly:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">insertM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> m <span class="dt">Bool</span>) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m [a]</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">insertM _ x [] <span class="fu">=</span> pure [x]</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">insertM p x yys<span class="fu">@</span>(y<span class="fu">:</span>ys) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">  lte <span class="ot">&lt;-</span> p x y</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">  <span class="kw">if</span> lte</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">    <span class="kw">then</span> pure (x<span class="fu">:</span>yys)</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">    <span class="kw">else</span> fmap (y<span class="fu">:</span>) (insertM p x ys)</a>
<a class="sourceLine" id="cb6-8" data-line-number="8"></a>
<a class="sourceLine" id="cb6-9" data-line-number="9"><span class="ot">insertSortM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> m <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m [a]</a>
<a class="sourceLine" id="cb6-10" data-line-number="10">insertSortM p <span class="fu">=</span> foldrM (insertM p) []</a>
<a class="sourceLine" id="cb6-11" data-line-number="11"></a>
<a class="sourceLine" id="cb6-12" data-line-number="12"><span class="ot">partitionM ::</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m ([a],[a])</a>
<a class="sourceLine" id="cb6-13" data-line-number="13">partitionM p <span class="fu">=</span> foldr f (pure ([],[])) <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-14" data-line-number="14">  f x <span class="fu">=</span> liftA2 ifStmt (p x) <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-15" data-line-number="15">    ifStmt flg (tr,fl)</a>
<a class="sourceLine" id="cb6-16" data-line-number="16">      <span class="fu">|</span> flg <span class="fu">=</span> (x<span class="fu">:</span>tr,fl)</a>
<a class="sourceLine" id="cb6-17" data-line-number="17">      <span class="fu">|</span> otherwise <span class="fu">=</span> (tr,x<span class="fu">:</span>fl)</a>
<a class="sourceLine" id="cb6-18" data-line-number="18">      </a>
<a class="sourceLine" id="cb6-19" data-line-number="19"><span class="ot">quickSortM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> m <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m [a]</a>
<a class="sourceLine" id="cb6-20" data-line-number="20">quickSortM p [] <span class="fu">=</span> pure []</a>
<a class="sourceLine" id="cb6-21" data-line-number="21">quickSortM p (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-22" data-line-number="22">  (gt,le) <span class="ot">&lt;-</span> partitionM (p x) xs</a>
<a class="sourceLine" id="cb6-23" data-line-number="23">  ls <span class="ot">&lt;-</span> quickSortM p le</a>
<a class="sourceLine" id="cb6-24" data-line-number="24">  gs <span class="ot">&lt;-</span> quickSortM p gt</a>
<a class="sourceLine" id="cb6-25" data-line-number="25">  pure (ls <span class="fu">++</span> [x] <span class="fu">++</span> gs)</a>
<a class="sourceLine" id="cb6-26" data-line-number="26"></a>
<a class="sourceLine" id="cb6-27" data-line-number="27"><span class="fu">&gt;&gt;&gt;</span> insertSortM (\_ _ <span class="ot">-&gt;</span> [<span class="dt">False</span>,<span class="dt">True</span>]) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb6-28" data-line-number="28">[[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>],[<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">2</span>],[<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">2</span>],[<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">3</span>],[<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">1</span>],[<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">1</span>]]</a>
<a class="sourceLine" id="cb6-29" data-line-number="29"></a>
<a class="sourceLine" id="cb6-30" data-line-number="30"><span class="fu">&gt;&gt;&gt;</span> quickSortM (\_ _ <span class="ot">-&gt;</span> [<span class="dt">False</span>,<span class="dt">True</span>]) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb6-31" data-line-number="31">[[<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">1</span>],[<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">1</span>],[<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">3</span>],[<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">2</span>],[<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">2</span>],[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]]</a></code></pre></div>
<p>As it should be easy to see, they‚Äôre very concise and elegant, and strongly resemble the pure versions of the algorithms.</p>
<h2 id="state">State</h2>
<p>So the examples above are very interesting and cool, but they don‚Äôt necessarily have a place in real Haskell code. If you wanted to find the permutations, partitions, or power set of a list you‚Äôd probably use a more standard implementation. That‚Äôs not to say that these monadic functions have no uses, though: especially when coupled with <code class="sourceCode haskell"><span class="dt">State</span></code> they yield readable and fast implementations for certain tricky functions. <code class="sourceCode haskell">ordNub</code>, for instance:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">ordNub ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">ordNub <span class="fu">=</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  flip evalState Set.empty <span class="fu">.</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">  filterM</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">    (\x <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6">       flg <span class="ot">&lt;-</span> gets (Set.notMember x)</a>
<a class="sourceLine" id="cb7-7" data-line-number="7">       when flg (modify (Set.insert x))</a>
<a class="sourceLine" id="cb7-8" data-line-number="8">       pure flg)</a></code></pre></div>
<p>Alternatively, using a monadic version of <code class="sourceCode haskell">maximumOn</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">maximumOnM ::</span> (<span class="dt">Applicative</span> m, <span class="dt">Ord</span> b) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m (<span class="dt">Maybe</span> a)</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">maximumOnM p <span class="fu">=</span> (fmap <span class="fu">.</span> fmap) snd <span class="fu">.</span> foldl f (pure <span class="dt">Nothing</span>)</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">    f a e <span class="fu">=</span> liftA2 g a (p e)</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">        g <span class="dt">Nothing</span> q <span class="fu">=</span> <span class="dt">Just</span> (q, e)</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">        g b<span class="fu">@</span>(<span class="dt">Just</span> (o, y)) q</a>
<a class="sourceLine" id="cb8-8" data-line-number="8">          <span class="fu">|</span> o <span class="fu">&lt;</span> q <span class="fu">=</span> <span class="dt">Just</span> (q, e)</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">          <span class="fu">|</span> otherwise <span class="fu">=</span> b</a></code></pre></div>
<p>You can write a one-pass <code class="sourceCode haskell">mostFrequent</code>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">mostFrequent ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">mostFrequent <span class="fu">=</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  flip evalState Map.empty <span class="fu">.</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4">  maximumOnM</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">    (\x <span class="ot">-&gt;</span> maybe <span class="dv">1</span> succ <span class="fu">&lt;$&gt;</span> state (Map.insertLookupWithKey (const (<span class="fu">+</span>)) x <span class="dv">1</span>))</a></code></pre></div>
<h2 id="decision-trees">Decision Trees</h2>
<p>One of the nicest things about the paper was the diagrams of decision trees provided for each sorting algorithm. I couldn‚Äôt find a library to do that for me, so I had a go at producing my own. First, we‚Äôll need a data type to represent the tree itself:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">data</span> <span class="dt">DecTree</span> t a</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">Pure</span> a</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  <span class="fu">|</span> <span class="dt">Choice</span> t (<span class="dt">DecTree</span> t a) (<span class="dt">DecTree</span> t a)</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">  <span class="kw">deriving</span> <span class="dt">Functor</span></a></code></pre></div>
<p>We‚Äôll say the left branch is ‚Äútrue‚Äù and the right ‚Äúfalse‚Äù. Applicative and monad instances are relatively mechanical<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Applicative</span> (<span class="dt">DecTree</span> t) <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2">  pure <span class="fu">=</span> <span class="dt">Pure</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  <span class="dt">Pure</span> f <span class="fu">&lt;*&gt;</span> xs <span class="fu">=</span> fmap f xs</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">  <span class="dt">Choice</span> c ls rs <span class="fu">&lt;*&gt;</span> xs <span class="fu">=</span> <span class="dt">Choice</span> c (ls <span class="fu">&lt;*&gt;</span> xs) (rs <span class="fu">&lt;*&gt;</span> xs)</a>
<a class="sourceLine" id="cb11-5" data-line-number="5">  </a>
<a class="sourceLine" id="cb11-6" data-line-number="6"><span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">DecTree</span> t) <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-7" data-line-number="7">  <span class="dt">Pure</span> x <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> f x</a>
<a class="sourceLine" id="cb11-8" data-line-number="8">  <span class="dt">Choice</span> c ls rs <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">Choice</span> c (ls <span class="fu">&gt;&gt;=</span> f) (rs <span class="fu">&gt;&gt;=</span> f)</a></code></pre></div>
<p>We can now create a comparator function that constructs one of these trees, and remembers the values it was given:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="ot">traceCompare ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">DecTree</span> (a,a) <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">traceCompare x y <span class="fu">=</span> <span class="dt">Choice</span> (x,y) (<span class="dt">Pure</span> <span class="dt">True</span>) (<span class="dt">Pure</span> <span class="dt">False</span>)</a></code></pre></div>
<p>Finally, to draw the tree, I‚Äôll use a function from my <a href="https://github.com/oisdk/binary-tree">binary tree</a> library:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="ot">printDecTree ::</span> (<span class="dt">Show</span> a, <span class="dt">Show</span> b) <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">DecTree</span> (a,a) b <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">printDecTree rel t <span class="fu">=</span> putStr (drawTreeWith id (go t) <span class="st">&quot;&quot;</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">  go (<span class="dt">Pure</span> xs) <span class="fu">=</span> <span class="dt">Node</span> (show xs) <span class="dt">Leaf</span> <span class="dt">Leaf</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4">  go (<span class="dt">Choice</span> (x,y) tr fl) <span class="fu">=</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5">    <span class="dt">Node</span> (show x <span class="fu">++</span> rel <span class="fu">++</span> show y) (go tr) (go fl)</a></code></pre></div>
<p>And we get these really nice diagrams out:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> (printDecTree <span class="st">&quot;&lt;=&quot;</span> <span class="fu">.</span> insertSortM traceCompare) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb14-2" data-line-number="2"></a>
<a class="sourceLine" id="cb14-3" data-line-number="3">         ‚îå[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb14-4" data-line-number="4">    ‚îå<span class="dv">1</span><span class="fu">&lt;=</span>2‚î§</a>
<a class="sourceLine" id="cb14-5" data-line-number="5">    ‚îÇ    ‚îÇ    ‚îå[<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb14-6" data-line-number="6">    ‚îÇ    ‚îî<span class="dv">1</span><span class="fu">&lt;=</span>3‚î§</a>
<a class="sourceLine" id="cb14-7" data-line-number="7">    ‚îÇ         ‚îî[<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb14-8" data-line-number="8"><span class="dv">2</span><span class="fu">&lt;=</span>3‚î§</a>
<a class="sourceLine" id="cb14-9" data-line-number="9">    ‚îÇ    ‚îå[<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">2</span>]</a>
<a class="sourceLine" id="cb14-10" data-line-number="10">    ‚îî<span class="dv">1</span><span class="fu">&lt;=</span>3‚î§</a>
<a class="sourceLine" id="cb14-11" data-line-number="11">         ‚îÇ    ‚îå[<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">2</span>]</a>
<a class="sourceLine" id="cb14-12" data-line-number="12">         ‚îî<span class="dv">1</span><span class="fu">&lt;=</span>2‚î§</a>
<a class="sourceLine" id="cb14-13" data-line-number="13">              ‚îî[<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb14-14" data-line-number="14"></a>
<a class="sourceLine" id="cb14-15" data-line-number="15"><span class="fu">&gt;&gt;&gt;</span> (printDecTree <span class="st">&quot;&lt;=&quot;</span> <span class="fu">.</span> quickSortM traceCompare) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb14-16" data-line-number="16"></a>
<a class="sourceLine" id="cb14-17" data-line-number="17">              ‚îå[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb14-18" data-line-number="18">         ‚îå<span class="dv">2</span><span class="fu">&lt;=</span>3‚î§</a>
<a class="sourceLine" id="cb14-19" data-line-number="19">         ‚îÇ    ‚îî[<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">2</span>]</a>
<a class="sourceLine" id="cb14-20" data-line-number="20">    ‚îå<span class="dv">1</span><span class="fu">&lt;=</span>3‚î§</a>
<a class="sourceLine" id="cb14-21" data-line-number="21">    ‚îÇ    ‚îî[<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">2</span>]</a>
<a class="sourceLine" id="cb14-22" data-line-number="22"><span class="dv">1</span><span class="fu">&lt;=</span>2‚î§</a>
<a class="sourceLine" id="cb14-23" data-line-number="23">    ‚îÇ    ‚îå[<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb14-24" data-line-number="24">    ‚îî<span class="dv">1</span><span class="fu">&lt;=</span>3‚î§</a>
<a class="sourceLine" id="cb14-25" data-line-number="25">         ‚îÇ    ‚îå[<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb14-26" data-line-number="26">         ‚îî<span class="dv">2</span><span class="fu">&lt;=</span>3‚î§</a>
<a class="sourceLine" id="cb14-27" data-line-number="27">              ‚îî[<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">1</span>]</a></code></pre></div>
<p>We can also try it out with the other monadic list functions:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> (printDecTree <span class="st">&quot;=&quot;</span> <span class="fu">.</span> groupByM traceCompare) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb15-2" data-line-number="2"></a>
<a class="sourceLine" id="cb15-3" data-line-number="3">       ‚îå[[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]]</a>
<a class="sourceLine" id="cb15-4" data-line-number="4">   ‚îå<span class="dv">2</span><span class="fu">=</span>3‚î§</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">   ‚îÇ   ‚îî[[<span class="dv">1</span>,<span class="dv">2</span>],[<span class="dv">3</span>]]</a>
<a class="sourceLine" id="cb15-6" data-line-number="6"><span class="dv">1</span><span class="fu">=</span>2‚î§</a>
<a class="sourceLine" id="cb15-7" data-line-number="7">   ‚îÇ   ‚îå[[<span class="dv">1</span>],[<span class="dv">2</span>,<span class="dv">3</span>]]</a>
<a class="sourceLine" id="cb15-8" data-line-number="8">   ‚îî<span class="dv">2</span><span class="fu">=</span>3‚î§</a>
<a class="sourceLine" id="cb15-9" data-line-number="9">       ‚îî[[<span class="dv">1</span>],[<span class="dv">2</span>],[<span class="dv">3</span>]]</a></code></pre></div>
<h2 id="applicative">Applicative</h2>
<p>You might notice that none of these ‚Äúmonadic‚Äù functions actually require a monad constraint: they‚Äôre all applicative. There‚Äôs a straightforward implementation that relies only on applicative for most of these functions, with a notable exception: sort. Getting <em>that</em> to work with just applicative is the subject of a future post.</p>
<h3 id="references" class="unnumbered">References</h3>
<div id="refs" class="references">
<div id="ref-christiansen_all_2016">
<p>Christiansen, Jan, Nikita Danilenko, and Sandra Dylus. 2016. ‚ÄúAll Sorts of Permutations (Functional Pearl).‚Äù In <em>Proceedings of the 21st ACM SIGPLAN International Conference on Functional Programming</em>, 168‚Äì179. ICFP 2016. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/2951913.2951949">10.1145/2951913.2951949</a>. <a href="http://informatik.uni-kiel.de/~sad/icfp2016-preprint.pdf" class="uri">http://informatik.uni-kiel.de/~sad/icfp2016-preprint.pdf</a>.</p>
</div>
</div>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>The definition has since been <a href="https://hackage.haskell.org/package/base-4.10.1.0/docs/src/Control.Monad.html#filterM">updated</a> to more modern Haskell: it now uses a fold, and only requires <code class="sourceCode haskell"><span class="dt">Applicative</span></code>.<a href="#fnref1" class="footnote-back">‚Ü©</a></p></li>
<li id="fn2"><p>Part of the reason the instances are so mechanical is that this type strongly resembles the <a href="https://hackage.haskell.org/package/free-5/docs/Control-Monad-Free.html#t:Free">free monad</a>:</p>
<p><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Free</span> f a <span class="fu">=</span> <span class="dt">Pure</span> a <span class="fu">|</span> <span class="dt">Free</span> (f (<span class="dt">Free</span> f a))</code></p>
<p>In fact, the example given in the <code class="sourceCode haskell"><span class="dt">MonadFree</span></code> class is the following:</p>
<p><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Pair</span> a <span class="fu">=</span> <span class="dt">Pair</span> a a</code></p>
<p><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Tree</span> <span class="fu">=</span> <span class="dt">Free</span> <span class="dt">Pair</span></code></p>
<p>The only difference with the above type and the decision tree is that the decision tree carries a tag with it.</p>
<p>So what‚Äôs so interesting about this relationship? Well, <code class="sourceCode haskell"><span class="dt">Pair</span></code> is actually a <a href="https://hackage.haskell.org/package/adjunctions-4.4/docs/Data-Functor-Rep.html">representable functor</a>. Any representable functor <code class="sourceCode haskell">f a</code> can be converted to (and from) a function <code class="sourceCode haskell">key <span class="ot">-&gt;</span> a</code>, where <code class="sourceCode haskell">key</code> is the specific key for <code class="sourceCode haskell">f</code>. The key for <code class="sourceCode haskell"><span class="dt">Pair</span></code> is <code class="sourceCode haskell"><span class="dt">Bool</span></code>: the result of the function we passed in to the sorting functions!</p>
<p>In general, you can make a ‚Äúdecision tree‚Äù for any function of type <code class="sourceCode haskell">a <span class="ot">-&gt;</span> b</code> like so:</p>
<p><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">DecTree</span> a b r <span class="fu">=</span> <span class="dt">Rep</span> f <span class="fu">~</span> b <span class="ot">=&gt;</span> <span class="dt">Free</span> (<span class="dt">Compose</span> ((,) a) f) r</code></p>
<p>But more on that in a later post.<a href="#fnref2" class="footnote-back">‚Ü©</a></p></li>
</ol>
</section>
]]></description>
    <pubDate>Sun, 11 Feb 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-02-11-monadic-list.functions.html</guid>
    <dc:creator>Donnacha Ois√≠n Kidney</dc:creator>
</item>
<item>
    <title>groupBy</title>
    <link>https://doisinkidney.com/posts/2018-01-07-groupBy.html</link>
    <description><![CDATA[<div class="info">
    Posted on January  7, 2018
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Folds.html">Folds</a>
    
</div>

<p>Here‚Äôs a useful function from <a href="https://hackage.haskell.org/package/base-4.10.1.0/docs/Data-List.html#v:groupBy">Data.List</a>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">groupBy ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">groupBy (<span class="fu">==</span>) <span class="st">&quot;aabcdda&quot;</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="co">-- [&quot;aa&quot;,&quot;b&quot;,&quot;c&quot;,&quot;dd&quot;,&quot;a&quot;]</span></a></code></pre></div>
<p>However, as has been pointed out before<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>, <code class="sourceCode haskell">groupBy</code> expects an equivalence relation, and can exhibit surprising behavior when it doesn‚Äôt get one. Let‚Äôs say, for instance, that we wanted to group numbers that were close together:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">groupClose ::</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> [[<span class="dt">Integer</span>]]</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">groupClose <span class="fu">=</span> groupBy (\x y <span class="ot">-&gt;</span> abs (x <span class="fu">-</span> y) <span class="fu">&lt;</span> <span class="dv">3</span>)</a></code></pre></div>
<p>What would you expect on the list <code>[1, 2, 3, 4, 5]</code>? All in the same group? Well, what you actually get is:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1">[[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>],[<span class="dv">4</span>,<span class="dv">5</span>]]</a></code></pre></div>
<p>This is because the implementation of <code class="sourceCode haskell">groupBy</code> only compares to the first element in each group:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">groupBy _  []           <span class="fu">=</span>  []</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">groupBy eq (x<span class="fu">:</span>xs)       <span class="fu">=</span>  (x<span class="fu">:</span>ys) <span class="fu">:</span> groupBy eq zs</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">                           <span class="kw">where</span> (ys,zs) <span class="fu">=</span> span (eq x) xs</a></code></pre></div>
<p>Brandon Simmons gave a <a href="http://brandon.si/code/an-alternative-definition-for-datalistgroupby/">definition</a> of <code class="sourceCode haskell">groupBy</code> that is perhaps more useful, but it used explicit recursion, rather than a fold.</p>
<p>A definition with <code class="sourceCode haskell">foldr</code> turned out to be trickier than I expected. I found some of the laziness properties especially difficult:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> head (groupBy (<span class="fu">==</span>) (<span class="dv">1</span><span class="fu">:</span><span class="dv">2</span><span class="fu">:</span>undefined))</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">[<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="fu">&gt;&gt;&gt;</span> (head <span class="fu">.</span> head) (groupBy (<span class="fu">==</span>) (<span class="dv">1</span><span class="fu">:</span>undefined))</a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="dv">1</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5"><span class="fu">&gt;&gt;&gt;</span> (head <span class="fu">.</span> head <span class="fu">.</span> tail) (groupBy (<span class="fu">==</span>) (<span class="dv">1</span><span class="fu">:</span><span class="dv">2</span><span class="fu">:</span>undefined))</a>
<a class="sourceLine" id="cb5-6" data-line-number="6"><span class="dv">2</span></a></code></pre></div>
<p>Here‚Äôs the definition I came up with, after some deliberation:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">groupBy ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">groupBy p xs <span class="fu">=</span> build (\c n <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  <span class="kw">let</span> f x a q</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">        <span class="fu">|</span> q x <span class="fu">=</span> (x <span class="fu">:</span> ys, zs)</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">        <span class="fu">|</span> otherwise <span class="fu">=</span> ([], c (x <span class="fu">:</span> ys) zs)</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">        <span class="kw">where</span> (ys,zs) <span class="fu">=</span> a (p x)</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">  <span class="kw">in</span> snd (foldr f (const ([], n)) xs (const <span class="dt">False</span>)))</a>
<a class="sourceLine" id="cb6-8" data-line-number="8"><span class="ot">{-# INLINE groupBy #-}</span></a></code></pre></div>
<p>Seemingly benign changes to the function will break one or more of the above tests. In particular, the laziness of a ‚Äúwhere‚Äù binding needs to be taken into account. Here‚Äôs an early attempt which failed:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">groupBy ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">groupBy p xs <span class="fu">=</span> build (\c n <span class="ot">-&gt;</span> </a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  <span class="kw">let</span> f x a q d</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">        <span class="fu">|</span> q x <span class="fu">=</span> a (p x) (d <span class="fu">.</span> (<span class="fu">:</span>) x)</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">        <span class="fu">|</span> otherwise <span class="fu">=</span> d [] (a (p x) (c <span class="fu">.</span> (<span class="fu">:</span>) x))</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">  <span class="kw">in</span> foldr f (\_ d <span class="ot">-&gt;</span> d [] n) xs (const <span class="dt">False</span>) (\ _ y <span class="ot">-&gt;</span> y))</a></code></pre></div>
<p>Once done, though, it works as expected:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> groupBy (<span class="fu">==</span>) <span class="st">&quot;aaabcccdda&quot;</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">[<span class="st">&quot;aaa&quot;</span>,<span class="st">&quot;b&quot;</span>,<span class="st">&quot;ccc&quot;</span>,<span class="st">&quot;dd&quot;</span>,<span class="st">&quot;a&quot;</span>]</a>
<a class="sourceLine" id="cb8-3" data-line-number="3"><span class="fu">&gt;&gt;&gt;</span> groupBy (<span class="fu">==</span>) []</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">[]</a>
<a class="sourceLine" id="cb8-5" data-line-number="5"><span class="fu">&gt;&gt;&gt;</span> groupBy (<span class="fu">&lt;=</span>) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">0</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">2</span>]</a>
<a class="sourceLine" id="cb8-6" data-line-number="6">[[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">3</span>],[<span class="dv">1</span>,<span class="dv">2</span>],[<span class="dv">0</span>,<span class="dv">4</span>,<span class="dv">5</span>],[<span class="dv">2</span>]]</a></code></pre></div>
<p>It‚Äôs the fastest version I could find that obeyed the above laziness properties.</p>
<p>The <a href="https://ghc.haskell.org/trac/ghc/ticket/13593">GHC page on the issue</a> unfortunately seems to indicate the implementation won‚Äôt be changed. Ah, well. Regardless, I have a <a href="https://github.com/oisdk/groupBy">repository</a> with the implementation above (with extra fusion machinery added) and comparisons to other implementations.</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>There are several threads on the libraries mailing list on this topic:</p>
<dl>
<dt>2006</dt>
<dd><a href="http://www.haskell.org/pipermail/haskell-cafe/2006-October/019148.html">mapAccumL - find max in-sequence subsequence</a>
</dd>
<dt>2007</dt>
<dd><a href="https://mail.haskell.org/pipermail/libraries/2007-August/008028.html">Data.List.groupBy with non-transitive equality predicate</a> (this is the longest discussion on the topic)
</dd>
<dt>2008</dt>
<dd><a href="https://mail.haskell.org/pipermail/libraries/2008-September/010629.html">Generalize groupBy in a useful way?</a>
</dd>
<dt>2009</dt>
<dd><a href="https://mail.haskell.org/pipermail/libraries/2009-June/011866.html">nubBy seems broken in recent GHCs</a>
</dd>
</dl>
<a href="#fnref1" class="footnote-back">‚Ü©</a></li>
</ol>
</section>
]]></description>
    <pubDate>Sun, 07 Jan 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-01-07-groupBy.html</guid>
    <dc:creator>Donnacha Ois√≠n Kidney</dc:creator>
</item>
<item>
    <title>Balancing Folds</title>
    <link>https://doisinkidney.com/posts/2017-10-30-balancing-folds.html</link>
    <description><![CDATA[<div class="info">
    Posted on October 30, 2017
</div>
<div class="info">
    
        Part 1 of a <a href="/series/Balanced%20Folds.html">3-part series on Balanced Folds</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Folds.html">Folds</a>
    
</div>

<p>There are three main ways to fold things in Haskell: from the right, from the left, and from either side. Let‚Äôs look at the left vs right variants first. <code class="sourceCode haskell">foldr</code> works from the right:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1">foldr (<span class="fu">+</span>) <span class="dv">0</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="dv">1</span> <span class="fu">+</span> (<span class="dv">2</span> <span class="fu">+</span> (<span class="dv">3</span> <span class="fu">+</span> <span class="dv">0</span>))</a></code></pre></div>
<p>And <code class="sourceCode haskell">foldl</code> from the left:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1">foldl (<span class="fu">+</span>) <span class="dv">0</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">((<span class="dv">0</span> <span class="fu">+</span> <span class="dv">1</span>) <span class="fu">+</span> <span class="dv">2</span>) <span class="fu">+</span> <span class="dv">3</span></a></code></pre></div>
<p>As you‚Äôll notice, the result of the two operations above is the same (6; although one may take much longer than the other). In fact, <em>whenever</em> the result of <code class="sourceCode haskell">foldr</code> and <code class="sourceCode haskell">foldl</code> is the same for a pair of arguments (in this case <code class="sourceCode haskell"><span class="fu">+</span></code> and <code class="sourceCode haskell"><span class="dv">0</span></code>), we say that that pair forms a <a href="https://hackage.haskell.org/package/base-4.10.0.0/docs/Data-Monoid.html#t:Monoid"><code class="sourceCode haskell"><span class="dt">Monoid</span></code></a> for some type (well, there‚Äôs some extra stuff to do with <code class="sourceCode haskell"><span class="dv">0</span></code>, but I only care about associativity at the moment). In this case, the <a href="https://hackage.haskell.org/package/base-4.10.0.0/docs/Data-Monoid.html#t:Sum"><code class="sourceCode haskell"><span class="dt">Sum</span></code></a> monoid is formed:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Sum</span> a <span class="fu">=</span> <span class="dt">Sum</span> {<span class="ot"> getSum ::</span> a }</a>
<a class="sourceLine" id="cb3-2" data-line-number="2"></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="kw">instance</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Sum</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">  mempty <span class="fu">=</span> <span class="dt">Sum</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">  mappend (<span class="dt">Sum</span> x) (<span class="dt">Sum</span> y) <span class="fu">=</span> <span class="dt">Sum</span> (x <span class="fu">+</span> y)</a></code></pre></div>
<p>When you know that you have a monoid, you can use the <a href="https://hackage.haskell.org/package/base-4.10.0.0/docs/Data-Foldable.html#v:foldMap"><code class="sourceCode haskell">foldMap</code></a> function: this is the third kind of fold. It says that you don‚Äôt care which of <code class="sourceCode haskell">foldl</code> or <code class="sourceCode haskell">foldr</code> is used, so the implementer of <code class="sourceCode haskell">foldMap</code> can put the parentheses wherever they want:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">foldMap <span class="dt">Sum</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">(<span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span>) <span class="fu">+</span> (<span class="dv">3</span> <span class="fu">+</span> <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="dv">0</span> <span class="fu">+</span> ((<span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span>) <span class="fu">+</span> <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">((<span class="dv">0</span> <span class="fu">+</span> <span class="dv">1</span>) <span class="fu">+</span> <span class="dv">2</span>) <span class="fu">+</span> <span class="dv">3</span></a></code></pre></div>
<p>And we can‚Äôt tell the difference from the result. This is a pretty bare-bones introduction to folds and monoids: you won‚Äôt need to know more than that for the rest of this post, but the topic area is fascinating and deep, so don‚Äôt let me give you the impression that I‚Äôve done anything more than scratched the surface.</p>
<h1 id="other-ways-to-fold">Other Ways to Fold</h1>
<p>Quite often, we <em>do</em> care about where the parentheses go. Take, for instance, a binary tree type, with values at the leaves:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">Empty</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  <span class="fu">|</span> <span class="dt">Leaf</span> a</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">  <span class="fu">|</span> <span class="dt">Tree</span> a <span class="fu">:*:</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb5-5" data-line-number="5"></a>
<a class="sourceLine" id="cb5-6" data-line-number="6"><span class="kw">instance</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb5-7" data-line-number="7">         <span class="dt">Show</span> (<span class="dt">Tree</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8">    show <span class="dt">Empty</span> <span class="fu">=</span> <span class="st">&quot;()&quot;</span></a>
<a class="sourceLine" id="cb5-9" data-line-number="9">    show (<span class="dt">Leaf</span> x) <span class="fu">=</span> show x</a>
<a class="sourceLine" id="cb5-10" data-line-number="10">    show (l <span class="fu">:*:</span> r) <span class="fu">=</span> <span class="st">&quot;(&quot;</span> <span class="fu">++</span> show l <span class="fu">++</span> <span class="st">&quot;*&quot;</span> <span class="fu">++</span> show r <span class="fu">++</span> <span class="st">&quot;)&quot;</span></a></code></pre></div>
<p>We can‚Äôt (well, shouldn‚Äôt) us <code class="sourceCode haskell">foldMap</code> here, because we would be able to tell the difference between different arrangements of parentheses:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> foldMap something [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb6-2" data-line-number="2"></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">((<span class="dv">1</span><span class="fu">*</span><span class="dv">2</span>)<span class="fu">*</span>(<span class="dv">3</span><span class="fu">*</span>())) ‚îÇ (()<span class="fu">*</span>((<span class="dv">1</span><span class="fu">*</span><span class="dv">2</span>)<span class="fu">*</span><span class="dv">3</span>)) ‚îÇ (((()<span class="fu">*</span><span class="dv">1</span>)<span class="fu">*</span><span class="dv">2</span>)<span class="fu">*</span><span class="dv">3</span>)</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">       ‚îå<span class="dv">1</span>      ‚îÇ      ‚îå()       ‚îÇ       ‚îå()</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">      ‚îå‚î§       ‚îÇ      ‚î§         ‚îÇ      ‚îå‚î§</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">      ‚îÇ‚îî<span class="dv">2</span>      ‚îÇ      ‚îÇ ‚îå<span class="dv">1</span>      ‚îÇ      ‚îÇ‚îî<span class="dv">1</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">      ‚î§        ‚îÇ      ‚îÇ‚îå‚î§       ‚îÇ     ‚îå‚î§</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">      ‚îÇ‚îå<span class="dv">3</span>      ‚îÇ      ‚îÇ‚îÇ‚îî<span class="dv">2</span>      ‚îÇ     ‚îÇ‚îî<span class="dv">2</span></a>
<a class="sourceLine" id="cb6-10" data-line-number="10">      ‚îî‚î§       ‚îÇ      ‚îî‚î§        ‚îÇ     ‚î§</a>
<a class="sourceLine" id="cb6-11" data-line-number="11">       ‚îî()     ‚îÇ       ‚îî<span class="dv">3</span>       ‚îÇ     ‚îî<span class="dv">3</span></a></code></pre></div>
<p>So we use one of the folds which lets us choose the arrangements of parentheses:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> (foldr (<span class="fu">:*:</span>) <span class="dt">Empty</span> <span class="fu">.</span> map <span class="dt">Leaf</span>) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">(<span class="dv">1</span><span class="fu">*</span>(<span class="dv">2</span><span class="fu">*</span>(<span class="dv">3</span><span class="fu">*</span>(<span class="dv">4</span><span class="fu">*</span>(<span class="dv">5</span><span class="fu">*</span>(<span class="dv">6</span><span class="fu">*</span>()))))))</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">     ‚îå<span class="dv">1</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">    ‚îå‚î§</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">    ‚îÇ‚îî<span class="dv">2</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6">   ‚îå‚î§</a>
<a class="sourceLine" id="cb7-7" data-line-number="7">   ‚îÇ‚îî<span class="dv">3</span></a>
<a class="sourceLine" id="cb7-8" data-line-number="8">  ‚îå‚î§</a>
<a class="sourceLine" id="cb7-9" data-line-number="9">  ‚îÇ‚îî<span class="dv">4</span></a>
<a class="sourceLine" id="cb7-10" data-line-number="10"> ‚îå‚î§</a>
<a class="sourceLine" id="cb7-11" data-line-number="11"> ‚îÇ‚îî<span class="dv">5</span></a>
<a class="sourceLine" id="cb7-12" data-line-number="12">‚îå‚î§</a>
<a class="sourceLine" id="cb7-13" data-line-number="13">‚îÇ‚îî<span class="dv">6</span></a>
<a class="sourceLine" id="cb7-14" data-line-number="14">‚î§</a>
<a class="sourceLine" id="cb7-15" data-line-number="15">‚îî()</a>
<a class="sourceLine" id="cb7-16" data-line-number="16"></a>
<a class="sourceLine" id="cb7-17" data-line-number="17"><span class="fu">&gt;&gt;&gt;</span> (foldl (<span class="fu">:*:</span>) <span class="dt">Empty</span> <span class="fu">.</span> map <span class="dt">Leaf</span>) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]</a>
<a class="sourceLine" id="cb7-18" data-line-number="18">((((((()<span class="fu">*</span><span class="dv">1</span>)<span class="fu">*</span><span class="dv">2</span>)<span class="fu">*</span><span class="dv">3</span>)<span class="fu">*</span><span class="dv">4</span>)<span class="fu">*</span><span class="dv">5</span>)<span class="fu">*</span><span class="dv">6</span>)</a>
<a class="sourceLine" id="cb7-19" data-line-number="19">‚îå()</a>
<a class="sourceLine" id="cb7-20" data-line-number="20">‚î§</a>
<a class="sourceLine" id="cb7-21" data-line-number="21">‚îÇ‚îå<span class="dv">1</span></a>
<a class="sourceLine" id="cb7-22" data-line-number="22">‚îî‚î§</a>
<a class="sourceLine" id="cb7-23" data-line-number="23"> ‚îÇ‚îå<span class="dv">2</span></a>
<a class="sourceLine" id="cb7-24" data-line-number="24"> ‚îî‚î§</a>
<a class="sourceLine" id="cb7-25" data-line-number="25">  ‚îÇ‚îå<span class="dv">3</span></a>
<a class="sourceLine" id="cb7-26" data-line-number="26">  ‚îî‚î§</a>
<a class="sourceLine" id="cb7-27" data-line-number="27">   ‚îÇ‚îå<span class="dv">4</span></a>
<a class="sourceLine" id="cb7-28" data-line-number="28">   ‚îî‚î§</a>
<a class="sourceLine" id="cb7-29" data-line-number="29">    ‚îÇ‚îå<span class="dv">5</span></a>
<a class="sourceLine" id="cb7-30" data-line-number="30">    ‚îî‚î§</a>
<a class="sourceLine" id="cb7-31" data-line-number="31">     ‚îî<span class="dv">6</span></a></code></pre></div>
<p>The issue is that neither of the trees generated are necessarily what we want: often, we want something more <em>balanced</em>.</p>
<h2 id="treefold">TreeFold</h2>
<p>To try and find a more balanced fold, let‚Äôs (for now) assume we‚Äôre always going to get non-empty input. This will let us simplify the <code class="sourceCode haskell"><span class="dt">Tree</span></code> type a little, to:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">Leaf</span> a</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  <span class="fu">|</span> <span class="dt">Tree</span> a <span class="fu">:*:</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">  <span class="kw">deriving</span> <span class="dt">Foldable</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5"></a>
<a class="sourceLine" id="cb8-6" data-line-number="6"><span class="kw">instance</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb8-7" data-line-number="7">         <span class="dt">Show</span> (<span class="dt">Tree</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8">    show (<span class="dt">Leaf</span> x) <span class="fu">=</span> show x</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">    show (l <span class="fu">:*:</span> r) <span class="fu">=</span> <span class="st">&quot;(&quot;</span> <span class="fu">++</span> show l <span class="fu">++</span> <span class="st">&quot;*&quot;</span> <span class="fu">++</span> show r <span class="fu">++</span> <span class="st">&quot;)&quot;</span></a></code></pre></div>
<p>Then, we can use Jon Fairbairn‚Äôs fold described in <a href="http://www.mail-archive.com/haskell@haskell.org/msg01788.html">this</a> email, adapted a bit for our non-empty input:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Data.List.NonEmpty</span> (<span class="dt">NonEmpty</span>(..))</a>
<a class="sourceLine" id="cb9-2" data-line-number="2"></a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="ot">treeFold ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">NonEmpty</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">treeFold f <span class="fu">=</span> go</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6">    go (x <span class="fu">:|</span> []) <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">    go (a <span class="fu">:|</span> b<span class="fu">:</span>l) <span class="fu">=</span> go (f a b <span class="fu">:|</span> pairMap l)</a>
<a class="sourceLine" id="cb9-8" data-line-number="8">    pairMap (x<span class="fu">:</span>y<span class="fu">:</span>rest) <span class="fu">=</span> f x y <span class="fu">:</span> pairMap rest</a>
<a class="sourceLine" id="cb9-9" data-line-number="9">    pairMap xs <span class="fu">=</span> xs</a></code></pre></div>
<p>There are two parts to this function: <code class="sourceCode haskell">pairMap</code> and the <code class="sourceCode haskell">go</code> helper. <code class="sourceCode haskell">pairMap</code> combines adjacent elements in the list using the combining function. As a top-level function it might look like this:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">pairMap f (x<span class="fu">:</span>y<span class="fu">:</span>rest) <span class="fu">=</span> f x y <span class="fu">:</span> pairMap f rest</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">pairMap f xs <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb10-3" data-line-number="3"></a>
<a class="sourceLine" id="cb10-4" data-line-number="4">pairMap (<span class="fu">++</span>) [<span class="st">&quot;a&quot;</span>,<span class="st">&quot;b&quot;</span>,<span class="st">&quot;c&quot;</span>,<span class="st">&quot;d&quot;</span>,<span class="st">&quot;e&quot;</span>]</a>
<a class="sourceLine" id="cb10-5" data-line-number="5"><span class="co">-- [&quot;ab&quot;,&quot;cd&quot;,&quot;e&quot;]</span></a></code></pre></div>
<p>As you can see, it leaves any leftovers untouched at the end of the list.</p>
<p>The <code class="sourceCode haskell">go</code> helper applies <code class="sourceCode haskell">pairMap</code> repeatedly to the list until it has only one element. This gives us much more balanced results that <code class="sourceCode haskell">foldl</code> or <code class="sourceCode haskell">foldr</code> (turn on <code class="sourceCode haskell"><span class="fu">-</span><span class="dt">XOverloadedLists</span></code> to write non-empty lists using this syntax):</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> (treeFold (<span class="fu">:*:</span>) <span class="fu">.</span> fmap <span class="dt">Leaf</span>) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">(((<span class="dv">1</span><span class="fu">*</span><span class="dv">2</span>)<span class="fu">*</span>(<span class="dv">3</span><span class="fu">*</span><span class="dv">4</span>))<span class="fu">*</span>(<span class="dv">5</span><span class="fu">*</span><span class="dv">6</span>))</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  ‚îå<span class="dv">1</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4"> ‚îå‚î§</a>
<a class="sourceLine" id="cb11-5" data-line-number="5"> ‚îÇ‚îî<span class="dv">2</span></a>
<a class="sourceLine" id="cb11-6" data-line-number="6">‚îå‚î§</a>
<a class="sourceLine" id="cb11-7" data-line-number="7">‚îÇ‚îÇ‚îå<span class="dv">3</span></a>
<a class="sourceLine" id="cb11-8" data-line-number="8">‚îÇ‚îî‚î§</a>
<a class="sourceLine" id="cb11-9" data-line-number="9">‚îÇ ‚îî<span class="dv">4</span></a>
<a class="sourceLine" id="cb11-10" data-line-number="10">‚î§</a>
<a class="sourceLine" id="cb11-11" data-line-number="11">‚îÇ‚îå<span class="dv">5</span></a>
<a class="sourceLine" id="cb11-12" data-line-number="12">‚îî‚î§</a>
<a class="sourceLine" id="cb11-13" data-line-number="13"> ‚îî<span class="dv">6</span></a>
<a class="sourceLine" id="cb11-14" data-line-number="14"></a>
<a class="sourceLine" id="cb11-15" data-line-number="15"><span class="fu">&gt;&gt;&gt;</span> (treeFold (<span class="fu">:*:</span>) <span class="fu">.</span> fmap <span class="dt">Leaf</span>) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>]</a>
<a class="sourceLine" id="cb11-16" data-line-number="16">(((<span class="dv">1</span><span class="fu">*</span><span class="dv">2</span>)<span class="fu">*</span>(<span class="dv">3</span><span class="fu">*</span><span class="dv">4</span>))<span class="fu">*</span>((<span class="dv">5</span><span class="fu">*</span><span class="dv">6</span>)<span class="fu">*</span>(<span class="dv">7</span><span class="fu">*</span><span class="dv">8</span>)))</a>
<a class="sourceLine" id="cb11-17" data-line-number="17">  ‚îå<span class="dv">1</span></a>
<a class="sourceLine" id="cb11-18" data-line-number="18"> ‚îå‚î§</a>
<a class="sourceLine" id="cb11-19" data-line-number="19"> ‚îÇ‚îî<span class="dv">2</span></a>
<a class="sourceLine" id="cb11-20" data-line-number="20">‚îå‚î§</a>
<a class="sourceLine" id="cb11-21" data-line-number="21">‚îÇ‚îÇ‚îå<span class="dv">3</span></a>
<a class="sourceLine" id="cb11-22" data-line-number="22">‚îÇ‚îî‚î§</a>
<a class="sourceLine" id="cb11-23" data-line-number="23">‚îÇ ‚îî<span class="dv">4</span></a>
<a class="sourceLine" id="cb11-24" data-line-number="24">‚î§</a>
<a class="sourceLine" id="cb11-25" data-line-number="25">‚îÇ ‚îå<span class="dv">5</span></a>
<a class="sourceLine" id="cb11-26" data-line-number="26">‚îÇ‚îå‚î§</a>
<a class="sourceLine" id="cb11-27" data-line-number="27">‚îÇ‚îÇ‚îî<span class="dv">6</span></a>
<a class="sourceLine" id="cb11-28" data-line-number="28">‚îî‚î§</a>
<a class="sourceLine" id="cb11-29" data-line-number="29"> ‚îÇ‚îå<span class="dv">7</span></a>
<a class="sourceLine" id="cb11-30" data-line-number="30"> ‚îî‚î§</a>
<a class="sourceLine" id="cb11-31" data-line-number="31">  ‚îî<span class="dv">8</span></a></code></pre></div>
<p>However, there are still cases where one branch will be much larger than its sibling. The fold fills a balanced binary tree from the left, but any leftover elements are put at the top level. In other words:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> (treeFold (<span class="fu">:*:</span>) <span class="fu">.</span> fmap <span class="dt">Leaf</span>) [<span class="dv">1</span><span class="fu">..</span><span class="dv">9</span>]</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">((((<span class="dv">1</span><span class="fu">*</span><span class="dv">2</span>)<span class="fu">*</span>(<span class="dv">3</span><span class="fu">*</span><span class="dv">4</span>))<span class="fu">*</span>((<span class="dv">5</span><span class="fu">*</span><span class="dv">6</span>)<span class="fu">*</span>(<span class="dv">7</span><span class="fu">*</span><span class="dv">8</span>)))<span class="fu">*</span><span class="dv">9</span>)</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">   ‚îå<span class="dv">1</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">  ‚îå‚î§</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">  ‚îÇ‚îî<span class="dv">2</span></a>
<a class="sourceLine" id="cb12-6" data-line-number="6"> ‚îå‚î§</a>
<a class="sourceLine" id="cb12-7" data-line-number="7"> ‚îÇ‚îÇ‚îå<span class="dv">3</span></a>
<a class="sourceLine" id="cb12-8" data-line-number="8"> ‚îÇ‚îî‚î§</a>
<a class="sourceLine" id="cb12-9" data-line-number="9"> ‚îÇ ‚îî<span class="dv">4</span></a>
<a class="sourceLine" id="cb12-10" data-line-number="10">‚îå‚î§</a>
<a class="sourceLine" id="cb12-11" data-line-number="11">‚îÇ‚îÇ ‚îå<span class="dv">5</span></a>
<a class="sourceLine" id="cb12-12" data-line-number="12">‚îÇ‚îÇ‚îå‚î§</a>
<a class="sourceLine" id="cb12-13" data-line-number="13">‚îÇ‚îÇ‚îÇ‚îî<span class="dv">6</span></a>
<a class="sourceLine" id="cb12-14" data-line-number="14">‚îÇ‚îî‚î§</a>
<a class="sourceLine" id="cb12-15" data-line-number="15">‚îÇ ‚îÇ‚îå<span class="dv">7</span></a>
<a class="sourceLine" id="cb12-16" data-line-number="16">‚îÇ ‚îî‚î§</a>
<a class="sourceLine" id="cb12-17" data-line-number="17">‚îÇ  ‚îî<span class="dv">8</span></a>
<a class="sourceLine" id="cb12-18" data-line-number="18">‚î§</a>
<a class="sourceLine" id="cb12-19" data-line-number="19">‚îî<span class="dv">9</span></a></code></pre></div>
<p>That <code class="sourceCode haskell"><span class="dv">9</span></code> hanging out on its own there is a problem.</p>
<h2 id="typewriters-and-slaloms">Typewriters and Slaloms</h2>
<p>One observation we can make is that <code class="sourceCode haskell">pairMap</code> always starts from the same side on each iteration, like a typewriter moving from one line to the next. This has the consequence of building up the leftovers on one side, leaving them until the top level.</p>
<p>We can improve the situation slightly by going back and forth, slalom-style, so we consume leftovers on each iteration:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="ot">treeFold ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">NonEmpty</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">treeFold f <span class="fu">=</span> goTo <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">  </a>
<a class="sourceLine" id="cb13-4" data-line-number="4">  goTo (y <span class="fu">:|</span> []) <span class="fu">=</span> y</a>
<a class="sourceLine" id="cb13-5" data-line-number="5">  goTo (a <span class="fu">:|</span> b <span class="fu">:</span> rest) <span class="fu">=</span> goFro (pairMap f (f a b) rest)</a>
<a class="sourceLine" id="cb13-6" data-line-number="6">  goFro (y <span class="fu">:|</span> []) <span class="fu">=</span> y</a>
<a class="sourceLine" id="cb13-7" data-line-number="7">  goFro (a <span class="fu">:|</span> b <span class="fu">:</span> rest) <span class="fu">=</span> goTo (pairMap (flip f) (f b a) rest)</a>
<a class="sourceLine" id="cb13-8" data-line-number="8"></a>
<a class="sourceLine" id="cb13-9" data-line-number="9">  pairMap f <span class="fu">=</span> go [] <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-10" data-line-number="10">    go ys y (a<span class="fu">:</span>b<span class="fu">:</span>rest) <span class="fu">=</span> go (y<span class="fu">:</span>ys) (f a b) rest</a>
<a class="sourceLine" id="cb13-11" data-line-number="11">    go ys y [z] <span class="fu">=</span> z <span class="fu">:|</span> y <span class="fu">:</span> ys</a>
<a class="sourceLine" id="cb13-12" data-line-number="12">    go ys y [] <span class="fu">=</span> y <span class="fu">:|</span> ys</a></code></pre></div>
<p>Notice that we have to flip the combining function to make sure the ordering is the same on output. For the earlier example, this solves the issue:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> (treeFold (<span class="fu">:*:</span>) <span class="fu">.</span> fmap <span class="dt">Leaf</span>) [<span class="dv">1</span><span class="fu">..</span><span class="dv">9</span>]</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">(((<span class="dv">1</span><span class="fu">*</span><span class="dv">2</span>)<span class="fu">*</span>((<span class="dv">3</span><span class="fu">*</span><span class="dv">4</span>)<span class="fu">*</span>(<span class="dv">5</span><span class="fu">*</span><span class="dv">6</span>)))<span class="fu">*</span>((<span class="dv">7</span><span class="fu">*</span><span class="dv">8</span>)<span class="fu">*</span><span class="dv">9</span>))</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">  ‚îå<span class="dv">1</span></a>
<a class="sourceLine" id="cb14-4" data-line-number="4"> ‚îå‚î§</a>
<a class="sourceLine" id="cb14-5" data-line-number="5"> ‚îÇ‚îî<span class="dv">2</span></a>
<a class="sourceLine" id="cb14-6" data-line-number="6">‚îå‚î§</a>
<a class="sourceLine" id="cb14-7" data-line-number="7">‚îÇ‚îÇ ‚îå<span class="dv">3</span></a>
<a class="sourceLine" id="cb14-8" data-line-number="8">‚îÇ‚îÇ‚îå‚î§</a>
<a class="sourceLine" id="cb14-9" data-line-number="9">‚îÇ‚îÇ‚îÇ‚îî<span class="dv">4</span></a>
<a class="sourceLine" id="cb14-10" data-line-number="10">‚îÇ‚îî‚î§</a>
<a class="sourceLine" id="cb14-11" data-line-number="11">‚îÇ ‚îÇ‚îå<span class="dv">5</span></a>
<a class="sourceLine" id="cb14-12" data-line-number="12">‚îÇ ‚îî‚î§</a>
<a class="sourceLine" id="cb14-13" data-line-number="13">‚îÇ  ‚îî<span class="dv">6</span></a>
<a class="sourceLine" id="cb14-14" data-line-number="14">‚î§</a>
<a class="sourceLine" id="cb14-15" data-line-number="15">‚îÇ ‚îå<span class="dv">7</span></a>
<a class="sourceLine" id="cb14-16" data-line-number="16">‚îÇ‚îå‚î§</a>
<a class="sourceLine" id="cb14-17" data-line-number="17">‚îÇ‚îÇ‚îî<span class="dv">8</span></a>
<a class="sourceLine" id="cb14-18" data-line-number="18">‚îî‚î§</a>
<a class="sourceLine" id="cb14-19" data-line-number="19"> ‚îî<span class="dv">9</span></a></code></pre></div>
<p>It does <em>not</em> build up the tree as balanced as it possibly could, though:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> (treeFold (<span class="fu">:*:</span>) <span class="fu">.</span> fmap <span class="dt">Leaf</span>) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">((<span class="dv">1</span><span class="fu">*</span><span class="dv">2</span>)<span class="fu">*</span>((<span class="dv">3</span><span class="fu">*</span><span class="dv">4</span>)<span class="fu">*</span>(<span class="dv">5</span><span class="fu">*</span><span class="dv">6</span>)))</a>
<a class="sourceLine" id="cb15-3" data-line-number="3"> ‚îå<span class="dv">1</span></a>
<a class="sourceLine" id="cb15-4" data-line-number="4">‚îå‚î§</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">‚îÇ‚îî<span class="dv">2</span></a>
<a class="sourceLine" id="cb15-6" data-line-number="6">‚î§</a>
<a class="sourceLine" id="cb15-7" data-line-number="7">‚îÇ ‚îå<span class="dv">3</span></a>
<a class="sourceLine" id="cb15-8" data-line-number="8">‚îÇ‚îå‚î§</a>
<a class="sourceLine" id="cb15-9" data-line-number="9">‚îÇ‚îÇ‚îî<span class="dv">4</span></a>
<a class="sourceLine" id="cb15-10" data-line-number="10">‚îî‚î§</a>
<a class="sourceLine" id="cb15-11" data-line-number="11"> ‚îÇ‚îå<span class="dv">5</span></a>
<a class="sourceLine" id="cb15-12" data-line-number="12"> ‚îî‚î§</a>
<a class="sourceLine" id="cb15-13" data-line-number="13">  ‚îî<span class="dv">6</span></a></code></pre></div>
<p>There‚Äôs four elements in the right branch, and two in the left in the above example. Three in each would be optimal.</p>
<p>Wait‚Äîoptimal in what sense, exactly? What do we mean when we say one tree is more balanced than another? Let‚Äôs say the ‚Äúbalance factor‚Äù is the largest difference in size of two sibling trees:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="ot">balFac ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2">balFac <span class="fu">=</span> fst <span class="fu">.</span> go <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3"><span class="ot">  go ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> (<span class="dt">Integer</span>, <span class="dt">Integer</span>)</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">  go (<span class="dt">Leaf</span> _) <span class="fu">=</span> (<span class="dv">0</span>, <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb16-5" data-line-number="5">  go (l <span class="fu">:*:</span> r) <span class="fu">=</span> (lb <span class="ot">`max`</span> rb <span class="ot">`max`</span> abs (rs <span class="fu">-</span> ls), rs <span class="fu">+</span> ls) <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-6" data-line-number="6">    (lb,ls) <span class="fu">=</span> go l</a>
<a class="sourceLine" id="cb16-7" data-line-number="7">    (rb,rs) <span class="fu">=</span> go r</a></code></pre></div>
<p>And one tree is more balanced than another if it has a smaller balance factor.</p>
<p>There‚Äôs effectively no limit on the balance factor for the typewriter method: when the input is one larger than a power of two, it‚Äôll stick the one extra in one branch and the rest in another (as with <code class="sourceCode haskell">[<span class="dv">1</span><span class="fu">..</span><span class="dv">9</span>]</code> in the example above).</p>
<p>For the slalom method, it looks like there‚Äôs something more interesting going on, limit-wise. I haven‚Äôt been able to verify this formally (yet), but from what I can tell, a tree of height <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> will have at most a balance factor of the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>th <a href="https://oeis.org/A001045">Jacobsthal number</a>. That‚Äôs (apparently) also the number of ways to tie a tie using <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n + 2</annotation></semantics></math> turns.</p>
<p>That was just gathered from some quick experiments and <a href="https://oeis.org/">oeis.org</a>, but it seems to make sense intuitively. Jacobsthal numbers are defined like this:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1">j <span class="dv">0</span> <span class="fu">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2">j <span class="dv">1</span> <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb17-3" data-line-number="3">j n <span class="fu">=</span> j (n<span class="fu">-</span><span class="dv">1</span>) <span class="fu">+</span> <span class="dv">2</span> <span class="fu">*</span> j (n<span class="fu">-</span><span class="dv">2</span>)</a></code></pre></div>
<p>So, at the top level, there‚Äôs the imbalance caused by the second-last <code class="sourceCode haskell">pairFold</code>, plus the imbalance caused by the third-to-last. However, the third-to-last imbalance is twice what it was at that level, because it is now working with an already-paired-up list. Why isn‚Äôt the second last imbalance also doubled? Because it‚Äôs counteracted by the fact that we turned around: the imbalance is in an element that‚Äôs a leftover element. At least that‚Äôs what my intuition is at this point.</p>
<p>The minimum balance factor is, of course, one. Unfortunately, to achieve that, I lost some of the properties of the previous folds:</p>
<h2 id="lengths">Lengths</h2>
<p>Up until now, I have been avoiding taking the length of the incoming list. It would lose a lot of laziness, cause an extra traversal, and generally seems like an ugly solution. Nonetheless, it gives the most balanced results I could find so far:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="ot">treeFold ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">NonEmpty</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">treeFold f (x<span class="fu">:|</span>xs) <span class="fu">=</span> go (length (x<span class="fu">:</span>xs)) (x<span class="fu">:</span>xs) <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3">  go <span class="dv">1</span> [y] <span class="fu">=</span> y</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">  go n ys <span class="fu">=</span> f (go m a) (go (n<span class="fu">-</span>m) b) <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-5" data-line-number="5">    (a,b) <span class="fu">=</span> splitAt m ys </a>
<a class="sourceLine" id="cb18-6" data-line-number="6">    m <span class="fu">=</span> n <span class="ot">`div`</span> <span class="dv">2</span></a></code></pre></div>
<p><code class="sourceCode haskell">splitAt</code> is an inefficient operation, but if we let the left-hand call return its unused input from the list, we can avoid it:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="ot">treeFold ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">NonEmpty</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">treeFold f (x<span class="fu">:|</span>xs) <span class="fu">=</span> fst (go (length (x<span class="fu">:</span>xs)) (x<span class="fu">:</span>xs)) <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-3" data-line-number="3">  go <span class="dv">1</span> (y<span class="fu">:</span>ys) <span class="fu">=</span> (y,ys)</a>
<a class="sourceLine" id="cb19-4" data-line-number="4">  go n ys <span class="fu">=</span> (f l r, rs) <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-5" data-line-number="5">    (l,ls) <span class="fu">=</span> go m ys</a>
<a class="sourceLine" id="cb19-6" data-line-number="6">    (r,rs) <span class="fu">=</span> go (n<span class="fu">-</span>m) ls</a>
<a class="sourceLine" id="cb19-7" data-line-number="7">    m <span class="fu">=</span> n <span class="ot">`div`</span> <span class="dv">2</span></a></code></pre></div>
<p>Finally, you may have spotted the state monad in this last version. We can make the similarity explicit:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="ot">treeFold ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">NonEmpty</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb20-2" data-line-number="2">treeFold f (x<span class="fu">:|</span>xs) <span class="fu">=</span> evalState (go (length (x<span class="fu">:</span>xs))) (x<span class="fu">:</span>xs) <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-3" data-line-number="3">  go <span class="dv">1</span> <span class="fu">=</span> state (\(y<span class="fu">:</span>ys) <span class="ot">-&gt;</span> (y,ys))</a>
<a class="sourceLine" id="cb20-4" data-line-number="4">  go n <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb20-5" data-line-number="5">    <span class="kw">let</span> m <span class="fu">=</span> n <span class="ot">`div`</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb20-6" data-line-number="6">    l <span class="ot">&lt;-</span> go m</a>
<a class="sourceLine" id="cb20-7" data-line-number="7">    r <span class="ot">&lt;-</span> go (n<span class="fu">-</span>m)</a>
<a class="sourceLine" id="cb20-8" data-line-number="8">    return (f l r)</a></code></pre></div>
<p>And there you have it: three different ways to fold in a more balanced way. Perhaps surprisingly, the first is the fastest in my tests. I‚Äôd love to hear if there‚Äôs a more balanced version (which is lazy, ideally) that is just as efficient as the first implementation.</p>
<h1 id="stable-summation">Stable Summation</h1>
<p>I have found two other uses for these folds other than simply constructing more balanced binary trees. The first is summation of floating-point numbers. If you sum floating-point numbers in the usual way with <code class="sourceCode haskell">foldl&#39;</code> (or, indeed, with an accumulator in an imperative language), you will see an error growth of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n)</annotation></semantics></math>, where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> is the number of floats you‚Äôre summing.</p>
<p>A well-known solution to this problem is the <a href="https://en.wikipedia.org/wiki/Kahan_summation_algorithm">Kahan summation algorithm</a>. It carries with it a running compensation for accumulating errors, giving it <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math> error growth. There are two downsides to the algorithm: it takes four times the number of numerical operations to perform, and isn‚Äôt parallel.</p>
<p>For that reason, it‚Äôs often not used in practice: instead, floats are summed <em>pairwise</em>, in a manner often referred to as <a href="https://en.wikipedia.org/wiki/Pairwise_summation">cascade summation</a>. This is what‚Äôs used in <a href="https://github.com/numpy/numpy/pull/3685">NumPy</a>. The error growth isn‚Äôt quite as good‚Äî<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ùí™</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log{n})</annotation></semantics></math>‚Äîbut it takes the exact same number of operations as normal summation. On top of that:</p>
<h1 id="parallelization">Parallelization</h1>
<p>Dividing a fold into roughly-equal chunks is exactly the kind of problem encountered when trying to parallelize certain algorithms. Adapting the folds above so that their work is performed in parallel is surprisingly easy:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="ot">splitPar ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">splitPar f <span class="fu">=</span> go</a>
<a class="sourceLine" id="cb21-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-4" data-line-number="4">    go l r <span class="dv">0</span> <span class="fu">=</span> f (l <span class="dv">0</span>) (r <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb21-5" data-line-number="5">    go l r n <span class="fu">=</span> lt <span class="ot">`par`</span> (rt <span class="ot">`pseq`</span> f lt rt)</a>
<a class="sourceLine" id="cb21-6" data-line-number="6">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-7" data-line-number="7">        lt <span class="fu">=</span> l (n<span class="fu">-</span>m)</a>
<a class="sourceLine" id="cb21-8" data-line-number="8">        rt <span class="fu">=</span> r m</a>
<a class="sourceLine" id="cb21-9" data-line-number="9">        m <span class="fu">=</span> n <span class="ot">`div`</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb21-10" data-line-number="10"></a>
<a class="sourceLine" id="cb21-11" data-line-number="11"><span class="ot">treeFoldParallel ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">NonEmpty</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb21-12" data-line-number="12">treeFoldParallel f xs <span class="fu">=</span></a>
<a class="sourceLine" id="cb21-13" data-line-number="13">    treeFold const (splitPar f) xs numCapabilities</a></code></pre></div>
<p>The above will split the fold into <code class="sourceCode haskell">numCapabilities</code> chunks, and perform each one in parallel. <code class="sourceCode haskell">numCapabilities</code> is a constant defined in <a href="https://hackage.haskell.org/package/base-4.10.0.0/docs/GHC-Conc.html">GHC.Conc</a>: it‚Äôs the number of threads which can be run simultaneously at any one time. Alternatively, you could the function include a parameter for how many chunks to split the computation into. You could also have the fold adapt as it went, choosing whether or not to spark based on how many sparks exist at any given time:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="ot">parseq ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb22-2" data-line-number="2">parseq a b <span class="fu">=</span></a>
<a class="sourceLine" id="cb22-3" data-line-number="3">    runST</a>
<a class="sourceLine" id="cb22-4" data-line-number="4">        (bool (par a b) (seq a b) <span class="fu">&lt;$&gt;</span></a>
<a class="sourceLine" id="cb22-5" data-line-number="5">         unsafeIOToST (liftA2 (<span class="fu">&gt;</span>) numSparks getNumCapabilities))</a>
<a class="sourceLine" id="cb22-6" data-line-number="6"></a>
<a class="sourceLine" id="cb22-7" data-line-number="7"><span class="ot">treeFoldAdaptive ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb22-8" data-line-number="8">treeFoldAdaptive f <span class="fu">=</span></a>
<a class="sourceLine" id="cb22-9" data-line-number="9">    Lazy.treeFold</a>
<a class="sourceLine" id="cb22-10" data-line-number="10">        (\l r <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb22-11" data-line-number="11">              r <span class="ot">`parseq`</span> (l <span class="ot">`parseq`</span> f l r))</a></code></pre></div>
<p>Adapted from <a href="https://www.reddit.com/r/haskell/comments/73umrw/another_parallelism_primitive_parseq/dnurduu/?utm_content=permalink&amp;utm_medium=front&amp;utm_source=reddit&amp;utm_name=haskell">this</a> comment by Edward Kmett. This is actually the fastest version of all the folds.</p>
<p>All of this is provided in a <a href="https://hackage.haskell.org/package/treefold">library</a> I‚Äôve put up on Hackage.</p>
]]></description>
    <pubDate>Mon, 30 Oct 2017 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2017-10-30-balancing-folds.html</guid>
    <dc:creator>Donnacha Ois√≠n Kidney</dc:creator>
</item>
<item>
    <title>Convolutions and Semirings</title>
    <link>https://doisinkidney.com/posts/2017-10-13-convolutions-and-semirings.html</link>
    <description><![CDATA[<div class="info">
    Posted on October 13, 2017
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Semirings.html">Semirings</a>
    
</div>

<p>I have been working a little more on my <a href="https://hackage.haskell.org/package/semiring-num">semirings library</a> recently, and I have come across some interesting functions in the process. First, a quick recap on the <code class="sourceCode haskell"><span class="dt">Semiring</span></code> class and some related functions:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Semiring</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="ot">  one ::</span> a</a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="ot">  zero ::</span> a</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">  <span class="kw">infixl</span> <span class="dv">6</span> <span class="fu">&lt;+&gt;</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="ot">  (&lt;+&gt;) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">  <span class="kw">infixl</span> <span class="dv">7</span> <span class="fu">&lt;.&gt;</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="ot">  (&lt;.&gt;) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb1-8" data-line-number="8"></a>
<a class="sourceLine" id="cb1-9" data-line-number="9"><span class="ot">add ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Semiring</span> a) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb1-10" data-line-number="10">add <span class="fu">=</span> foldl&#39; (<span class="fu">&lt;+&gt;</span>) zero</a>
<a class="sourceLine" id="cb1-11" data-line-number="11"></a>
<a class="sourceLine" id="cb1-12" data-line-number="12"><span class="ot">mul ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Semiring</span> a) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb1-13" data-line-number="13">mul <span class="fu">=</span> foldl&#39; (<span class="fu">&lt;.&gt;</span>) one</a>
<a class="sourceLine" id="cb1-14" data-line-number="14"></a>
<a class="sourceLine" id="cb1-15" data-line-number="15"><span class="kw">instance</span> <span class="dt">Semiring</span> <span class="dt">Integer</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-16" data-line-number="16">  one <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-17" data-line-number="17">  zero <span class="fu">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb1-18" data-line-number="18">  (<span class="fu">&lt;+&gt;</span>) <span class="fu">=</span> (<span class="fu">+</span>)</a>
<a class="sourceLine" id="cb1-19" data-line-number="19">  (<span class="fu">&lt;.&gt;</span>) <span class="fu">=</span> (<span class="fu">*</span>)</a>
<a class="sourceLine" id="cb1-20" data-line-number="20"></a>
<a class="sourceLine" id="cb1-21" data-line-number="21"><span class="kw">instance</span> <span class="dt">Semiring</span> <span class="dt">Bool</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-22" data-line-number="22">  one <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb1-23" data-line-number="23">  zero <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb1-24" data-line-number="24">  (<span class="fu">&lt;+&gt;</span>) <span class="fu">=</span> (<span class="fu">||</span>)</a>
<a class="sourceLine" id="cb1-25" data-line-number="25">  (<span class="fu">&lt;.&gt;</span>) <span class="fu">=</span> (<span class="fu">&amp;&amp;</span>)</a></code></pre></div>
<p>You can think of it as a replacement for <code class="sourceCode haskell"><span class="dt">Num</span></code>, but it turns out to be much more generally useful than that.</p>
<h1 id="matrix-multiplication">Matrix Multiplication</h1>
<p>The first interesting function is to do with matrix multiplication. Here‚Äôs the code for multiplying two matrices represented as nested lists:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">mulMatrix ::</span> <span class="dt">Semiring</span> a <span class="ot">=&gt;</span> [[a]] <span class="ot">-&gt;</span> [[a]] <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">mulMatrix xs ys <span class="fu">=</span> map (\row <span class="ot">-&gt;</span> map (add <span class="fu">.</span> zipWith (<span class="fu">&lt;.&gt;</span>) row) cs) xs</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">    cs <span class="fu">=</span> transpose ys</a></code></pre></div>
<p>One of the issues with this code (other than its woeful performance) is that it seems needlessly list-specific. <code class="sourceCode haskell">zipWith</code> seems like the kind of thing that exists on a bunch of different structures. Indeed, the <a href="https://hackage.haskell.org/package/base-4.10.0.0/docs/Control-Applicative.html#t:ZipList"><code class="sourceCode haskell"><span class="dt">ZipList</span></code> wrapper</a> uses <code class="sourceCode haskell">zipWith</code> as its <code class="sourceCode haskell"><span class="fu">&lt;*&gt;</span></code> implementation. Let‚Äôs try that for now:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">mulMatrix ::</span> (<span class="dt">Semiring</span> a, <span class="dt">Applicative</span> f) <span class="ot">=&gt;</span> f (f a) <span class="ot">-&gt;</span> f (f a) <span class="ot">-&gt;</span> f (f a)</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">mulMatrix xs ys <span class="fu">=</span> fmap (\row <span class="ot">-&gt;</span> fmap (add <span class="fu">.</span> liftA2 (<span class="fu">&lt;.&gt;</span>) row) cs) xs</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">    cs <span class="fu">=</span> transpose ys</a></code></pre></div>
<p>Of course, now <code class="sourceCode haskell">add</code> needs to work on our <code class="sourceCode haskell">f</code>, so it should be <code class="sourceCode haskell"><span class="dt">Foldable</span></code></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">mulMatrix </a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="ot">  ::</span> (<span class="dt">Semiring</span> a, <span class="dt">Applicative</span> f, <span class="dt">Foldable</span> f) </a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  <span class="ot">=&gt;</span> f (f a) <span class="ot">-&gt;</span> f (f a) <span class="ot">-&gt;</span> f (f a)</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">mulMatrix <span class="fu">=</span> <span class="fu">...</span></a></code></pre></div>
<p><code class="sourceCode haskell">transpose</code> is the missing piece now. A little bit of <code class="sourceCode haskell"><span class="dt">Applicative</span></code> magic can help us out again, though: <code class="sourceCode haskell">sequenceA</code> is <code class="sourceCode haskell">transpose</code> on <code class="sourceCode haskell"><span class="dt">ZipList</span></code>s <span class="citation" data-cites="mcbride_applicative_2008">(McBride and Paterson <a href="#ref-mcbride_applicative_2008">2008</a>)</span>.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1">mulMatrix </a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="ot">  ::</span> (<span class="dt">Semiring</span> a, <span class="dt">Applicative</span> f, <span class="dt">Traversable</span> f) </a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  <span class="ot">=&gt;</span> f (f a) <span class="ot">-&gt;</span> f (f a) <span class="ot">-&gt;</span> f (f a)</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">mulMatrix xs ys <span class="fu">=</span> </a>
<a class="sourceLine" id="cb5-5" data-line-number="5">    fmap (\row <span class="ot">-&gt;</span> fmap (add <span class="fu">.</span> liftA2 (<span class="fu">&lt;.&gt;</span>) row) cs) xs</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-7" data-line-number="7">    cs <span class="fu">=</span> sequenceA ys</a></code></pre></div>
<p>One further generalization: The two <code class="sourceCode haskell">f</code>s don‚Äôt actually need to be the same:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1">mulMatrix</a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="ot">    ::</span> (<span class="dt">Applicative</span> n</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">       ,<span class="dt">Traversable</span> m</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">       ,<span class="dt">Applicative</span> m</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">       ,<span class="dt">Applicative</span> p</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">       ,<span class="dt">Semiring</span> a)</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">    <span class="ot">=&gt;</span> n (m a) <span class="ot">-&gt;</span> m (p a) <span class="ot">-&gt;</span> n (p a)</a>
<a class="sourceLine" id="cb6-8" data-line-number="8">mulMatrix xs ys <span class="fu">=</span> fmap (\row <span class="ot">-&gt;</span> fmap (add <span class="fu">.</span> liftA2 (<span class="fu">&lt;.&gt;</span>) row) cs) xs</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-10" data-line-number="10">    cs <span class="fu">=</span> sequenceA ys</a></code></pre></div>
<p>Happily, the way that the wrappers (<code class="sourceCode haskell">n</code>, <code class="sourceCode haskell">m</code>, and <code class="sourceCode haskell">p</code>) match up coincides precisely with how matrix dimensions match up in matrix multiplication. Quoting from the <a href="https://en.wikipedia.org/wiki/Matrix_multiplication">Wikipedia definition</a>:</p>
<blockquote>
<p>if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math> is an <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>√ó</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n \times m</annotation></semantics></math> matrix and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math> is an <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>√ó</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">m \times p</annotation></semantics></math> matrix, their matrix product <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">AB</annotation></semantics></math> is an <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>√ó</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">n \times p</annotation></semantics></math> matrix</p>
</blockquote>
<p>This function is present in the <a href="https://hackage.haskell.org/package/linear-1.20.7/docs/Linear-Matrix.html#v:-33--42--33-">linear package</a> with some different constraints. In fairness, <code class="sourceCode haskell"><span class="dt">Applicative</span></code> probably isn‚Äôt the best thing to use here since it doesn‚Äôt work for so many instances (<a href="https://hackage.haskell.org/package/base-4.10.0.0/docs/Control-Monad-Zip.html"><code class="sourceCode haskell"><span class="dt">MonadZip</span></code></a> or something similar may be more suitable), but it‚Äôs very handy to have, and works out-of the box for types like:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Three</span> a </a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">Three</span> a a a </a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  <span class="kw">deriving</span> (<span class="dt">Functor</span>, <span class="dt">Foldable</span>, <span class="dt">Traversable</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb7-4" data-line-number="4"></a>
<a class="sourceLine" id="cb7-5" data-line-number="5"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Three</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6">  pure x <span class="fu">=</span> <span class="dt">Three</span> x x x</a>
<a class="sourceLine" id="cb7-7" data-line-number="7">  <span class="dt">Three</span> fx fy fz <span class="fu">&lt;*&gt;</span> <span class="dt">Three</span> xx xy xz <span class="fu">=</span> <span class="dt">Three</span> (fx xx) (fy xy) (fz xz)</a></code></pre></div>
<p>Which makes it (to my mind) useful enough to keep. Also, it hugely simplified the code for <a href="https://github.com/oisdk/Square/blob/master/src/Data/Square.hs#L183">matrix multiplication in square matrices</a> I had, from <span class="citation" data-cites="okasaki_fast_1999">Okasaki (<a href="#ref-okasaki_fast_1999">1999</a>)</span>.</p>
<h1 id="convolutions">Convolutions</h1>
<p>If you‚Äôre putting a general class in a library that you want people to use, and there exist sensible instances for common Haskell types, you should probably provide those instances in the library to avoid orphans. The meaning of ‚Äúsensible‚Äù here is vague: generally speaking, if there is only one obvious or clear instance, then it‚Äôs sensible. For a list instance for the semiring class, for instance, I could figure out several law-abiding definitions for <code class="sourceCode haskell"><span class="fu">&lt;+&gt;</span></code>, <code class="sourceCode haskell">one</code> and <code class="sourceCode haskell">zero</code>, but only one for <code class="haskel">&lt;.&gt;</code>: polynomial multiplication. You know, where you multiply two polynomials like so:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><mn>2</mn><mi>x</mi><mo>+</mo><mn>3</mn><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><mn>5</mn><mi>x</mi><mo>+</mo><mn>3</mn><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>4</mn><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mn>9</mn><msup><mi>x</mi><mn>5</mn></msup><mo>+</mo><mn>15</mn><msup><mi>x</mi><mn>4</mn></msup><mo>+</mo><mn>18</mn><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><mn>28</mn><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>38</mn><mi>x</mi><mo>+</mo><mn>24</mn></mrow><annotation encoding="application/x-tex">(x^3 + 2x + 3)(5x + 3x^2 + 4) = 9x^5 + 15x^4 + 18x^3 + 28x^2 + 38x + 24</annotation></semantics></math></p>
<p>A more general definition looks something like this:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msub><mi>a</mi><mn>0</mn></msub><msup><mi>x</mi><mn>0</mn></msup><mo>+</mo><msub><mi>a</mi><mn>1</mn></msub><msup><mi>x</mi><mn>1</mn></msup><mo>+</mo><msub><mi>a</mi><mn>2</mn></msub><msup><mi>x</mi><mn>2</mn></msup><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>b</mi><mn>0</mn></msub><msup><mi>x</mi><mn>0</mn></msup><mo>+</mo><msub><mi>b</mi><mn>1</mn></msub><msup><mi>x</mi><mn>1</mn></msup><mo>+</mo><msub><mi>b</mi><mn>2</mn></msub><msup><mi>x</mi><mn>2</mn></msup><mo stretchy="false" form="postfix">)</mo><mo>=</mo></mrow><annotation encoding="application/x-tex">(a_0x^0 + a_1x^1 + a_2x^2)(b_0x^0 + b_1x^1 + b_2x^2) =</annotation></semantics></math> <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>0</mn></msub><msub><mi>b</mi><mn>0</mn></msub><msup><mi>x</mi><mn>0</mn></msup><mo>+</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>a</mi><mn>0</mn></msub><msub><mi>b</mi><mn>1</mn></msub><mo>+</mo><msub><mi>a</mi><mn>1</mn></msub><msub><mi>b</mi><mn>0</mn></msub><mo stretchy="false" form="postfix">)</mo><msup><mi>x</mi><mn>1</mn></msup><mo>+</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>a</mi><mn>0</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mo>+</mo><msub><mi>a</mi><mn>1</mn></msub><msub><mi>b</mi><mn>1</mn></msub><mo>+</mo><msub><mi>a</mi><mn>2</mn></msub><msub><mi>b</mi><mn>0</mn></msub><mo stretchy="false" form="postfix">)</mo><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>a</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mo>+</mo><msub><mi>a</mi><mn>2</mn></msub><msub><mi>b</mi><mn>1</mn></msub><mo stretchy="false" form="postfix">)</mo><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><msub><mi>a</mi><mn>2</mn></msub><msub><mi>b</mi><mn>2</mn></msub><msup><mi>x</mi><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">a_0b_0x^0 + (a_0b_1 + a_1b_0)x^1 + (a_0b_2 + a_1b_1 + a_2b_0)x^2 + (a_1b_2 + a_2b_1)x^3 + a_2b_2x^4</annotation></semantics></math></p>
<p>Or, fully generalized:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>k</mi></msub><mo>=</mo><msub><mi>a</mi><mn>0</mn></msub><msub><mi>b</mi><mi>k</mi></msub><mo>+</mo><msub><mi>a</mi><mn>1</mn></msub><msub><mi>b</mi><mrow><mi>k</mi><mo>‚àí</mo><mn>1</mn></mrow></msub><mo>+</mo><mi>‚Ä¶</mi><mo>+</mo><msub><mi>a</mi><mrow><mi>k</mi><mo>‚àí</mo><mn>1</mn></mrow></msub><msub><mi>b</mi><mn>1</mn></msub><mo>+</mo><msub><mi>a</mi><mi>k</mi></msub><msub><mi>b</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">c_k = a_0b_k + a_1b_{k-1} + \ldots + a_{k-1}b_1 + a_kb_0</annotation></semantics></math> <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>√ó</mo><mi>g</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><munderover><mo>‚àë</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>n</mi><mo>+</mo><mi>m</mi></mrow></munderover><msub><mi>c</mi><mi>i</mi></msub><msup><mi>x</mi><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">f(x) \times g(x) = \sum_{i=0}^{n+m}c_ix^i</annotation></semantics></math></p>
<p>So it turns out that you can represent polynomials pretty elegantly as lists. Take an example from above:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><mn>2</mn><mi>x</mi><mo>+</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">x^3 + 2x + 3</annotation></semantics></math></p>
<p>And rearrange it in order of the powers of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><msup><mi>x</mi><mn>0</mn></msup><mo>+</mo><mn>2</mn><msup><mi>x</mi><mn>1</mn></msup><mo>+</mo><msup><mi>x</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">3x^0 + 2x^1 + x^3</annotation></semantics></math></p>
<p>And fill in missing coefficients:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><msup><mi>x</mi><mn>0</mn></msup><mo>+</mo><mn>2</mn><msup><mi>x</mi><mn>1</mn></msup><mo>+</mo><mn>0</mn><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>1</mn><msup><mi>x</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">3x^0 + 2x^1 + 0x^2 + 1x^3</annotation></semantics></math></p>
<p>And then the list representation of that polynomial is the list of those coefficients:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">[<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">0</span>, <span class="dv">1</span>]</a></code></pre></div>
<p>For me, the definitions of multiplication above were pretty hard to understand. In Haskell, however, the definition is quite beautiful:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Semiring</span> a <span class="ot">=&gt;</span> <span class="dt">Semiring</span> [a] <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">  one <span class="fu">=</span> [one]</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  zero <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">  [] <span class="fu">&lt;+&gt;</span> ys <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  xs <span class="fu">&lt;+&gt;</span> [] <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb9-6" data-line-number="6">  (x<span class="fu">:</span>xs) <span class="fu">&lt;+&gt;</span> (y<span class="fu">:</span>ys) <span class="fu">=</span> x <span class="fu">&lt;+&gt;</span> y <span class="fu">:</span> (xs <span class="fu">&lt;+&gt;</span> ys)</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">  _ <span class="fu">&lt;.&gt;</span> [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb9-8" data-line-number="8">  [] <span class="fu">&lt;.&gt;</span> _ <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb9-9" data-line-number="9">  (x<span class="fu">:</span>xs) <span class="fu">&lt;.&gt;</span> (y<span class="fu">:</span>ys) <span class="fu">=</span> (x<span class="fu">&lt;.&gt;</span>y) <span class="fu">:</span> map (x<span class="fu">&lt;.&gt;</span>) ys <span class="fu">&lt;+&gt;</span> xs <span class="fu">&lt;.&gt;</span> (y<span class="fu">:</span>ys)</a></code></pre></div>
<p>This definition for <code class="sourceCode haskell"><span class="fu">&lt;.&gt;</span></code> can be found on page 4 of <span class="citation" data-cites="mcilroy_power_1999">McIlroy (<a href="#ref-mcilroy_power_1999">1999</a>)</span>. Although there was a version of the paper with a slightly different definition:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">_ <span class="fu">&lt;.&gt;</span> [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">[] <span class="fu">&lt;.&gt;</span> _ <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">(x<span class="fu">:</span>xs) <span class="fu">&lt;.&gt;</span> (y<span class="fu">:</span>ys) </a>
<a class="sourceLine" id="cb10-4" data-line-number="4">  <span class="fu">=</span> (x<span class="fu">&lt;.&gt;</span>y) <span class="fu">:</span> (map (x<span class="fu">&lt;.&gt;</span>) ys <span class="fu">&lt;+&gt;</span> map (<span class="fu">&lt;.&gt;</span>y) xs <span class="fu">&lt;+&gt;</span> (zero <span class="fu">:</span> (xs <span class="fu">&lt;.&gt;</span> ys)))</a></code></pre></div>
<p>Similar to one which appeared in <span class="citation" data-cites="dolan_fun_2013">Dolan (<a href="#ref-dolan_fun_2013">2013</a>)</span>.</p>
<p>As it happens, I prefer the first definition. It‚Äôs shorter, and I figured out how to write it as a fold:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1">_ <span class="fu">&lt;.&gt;</span> [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">xs <span class="fu">&lt;.&gt;</span> ys <span class="fu">=</span> foldr f [] xs <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  f x zs <span class="fu">=</span> map (x <span class="fu">&lt;.&gt;</span>) ys <span class="fu">&lt;+&gt;</span> (zero <span class="fu">:</span> zs)</a></code></pre></div>
<p>And if you inline the <code class="sourceCode haskell"><span class="fu">&lt;+&gt;</span></code>, you get a reasonable speedup:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1">xs <span class="fu">&lt;.&gt;</span> ys <span class="fu">=</span> foldr f [] xs</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">    f x zs <span class="fu">=</span> foldr (g x) id ys (zero <span class="fu">:</span> zs)</a>
<a class="sourceLine" id="cb12-4" data-line-number="4">    g x y a (z<span class="fu">:</span>zs) <span class="fu">=</span> x <span class="fu">&lt;.&gt;</span> y <span class="fu">&lt;+&gt;</span> z <span class="fu">:</span> a zs</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">    g x y a [] <span class="fu">=</span> x <span class="fu">&lt;.&gt;</span> y <span class="fu">:</span> a []</a></code></pre></div>
<p>The definition of <code class="sourceCode haskell"><span class="fu">&lt;+&gt;</span></code> can also use a fold on either side for fusion purposes:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1">(<span class="fu">&lt;+&gt;</span>) <span class="fu">=</span> foldr f id <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">  f x xs (y<span class="fu">:</span>ys) <span class="fu">=</span> x <span class="fu">&lt;+&gt;</span> y <span class="fu">:</span> xs ys</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">  f x xs [] <span class="fu">=</span> x <span class="fu">:</span> xs []</a>
<a class="sourceLine" id="cb13-4" data-line-number="4"></a>
<a class="sourceLine" id="cb13-5" data-line-number="5">(<span class="fu">&lt;+&gt;</span>) <span class="fu">=</span> flip (foldr f id) <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-6" data-line-number="6">  f y ys (x<span class="fu">:</span>xs) <span class="fu">=</span> x <span class="fu">&lt;+&gt;</span> y <span class="fu">:</span> ys xs</a>
<a class="sourceLine" id="cb13-7" data-line-number="7">  f y ys [] <span class="fu">=</span> y <span class="fu">:</span> ys []</a></code></pre></div>
<p>There are rules in the library to choose one of the above definitions if fusion is available.</p>
<p>This definition is much more widely useful than it may seem at first. Say, for instance, you wanted to search through pairs of things from two infinite lists. You can‚Äôt use the normal way to pair things for lists, the Cartesian product, because it will diverge:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1">[(x,y) <span class="fu">|</span> x <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span>], y <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span>]]</a>
<a class="sourceLine" id="cb14-2" data-line-number="2"><span class="co">-- [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10)...</span></a></code></pre></div>
<p>You‚Äôll never get beyond 1 in the first list. Zipping isn‚Äôt an option either, because you won‚Äôt really explore the search space, only corresponding pairs. <a href="https://byorgey.wordpress.com/2008/04/22/list-convolutions/">Brent Yorgey showed</a> that if you want a list like this:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1">[(y,x<span class="fu">-</span>y) <span class="fu">|</span> x <span class="ot">&lt;-</span> [<span class="dv">0</span><span class="fu">..</span>], y <span class="ot">&lt;-</span> [<span class="dv">0</span><span class="fu">..</span>x] ]</a>
<a class="sourceLine" id="cb15-2" data-line-number="2"><span class="co">-- [(0,0),(0,1),(1,0),(0,2),(1,1),(2,0),(0,3),(1,2),(2,1),(3,0)...</span></a></code></pre></div>
<p>Then what you‚Äôre looking for is a convolution (the same thing as polynomial multiplication). <code class="sourceCode haskell"><span class="fu">&lt;.&gt;</span></code> above can be adapted readily:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="ot">convolve ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [[(a,b)]]</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">convolve xs ys <span class="fu">=</span> foldr f [] xs</a>
<a class="sourceLine" id="cb16-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-4" data-line-number="4">    f x zs <span class="fu">=</span> foldr (g x) id ys ([] <span class="fu">:</span> zs)</a>
<a class="sourceLine" id="cb16-5" data-line-number="5">    g x y a (z<span class="fu">:</span>zs) <span class="fu">=</span> ((x, y) <span class="fu">:</span> z) <span class="fu">:</span> a zs</a>
<a class="sourceLine" id="cb16-6" data-line-number="6">    g x y a [] <span class="fu">=</span> [(x, y)] <span class="fu">:</span> a []</a></code></pre></div>
<p>Flatten out this result to get your ordering. This convolution is a little different from the one in the blog post. By inlining <code class="sourceCode haskell"><span class="fu">&lt;+&gt;</span></code> we can avoid the expensive <code class="sourceCode haskell"><span class="fu">++</span></code> function, without using difference lists.</p>
<h1 id="long-multiplication">Long Multiplication</h1>
<p>Here‚Äôs another cool use of lists as polynomials: they can be used as a <a href="https://en.Wikipedia.org/wiki/Positional_notation">positional numeral system</a>. Most common numeral systems are positional, including Arabic (the system you most likely use, where twenty-four is written as 24) and binary. Non-positional systems are things like Roman numerals. Looking at the Arabic system for now, we see that the way of writing down numbers:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1989</mn><annotation encoding="application/x-tex">1989</annotation></semantics></math></p>
<p>Can be thought of the sum of each digit multiplied by ten to the power of its position:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1989</mn><mo>=</mo><mn>1</mn><mo>√ó</mo><msup><mn>10</mn><mn>3</mn></msup><mo>+</mo><mn>9</mn><mo>√ó</mo><msup><mn>10</mn><mn>2</mn></msup><mo>+</mo><mn>8</mn><mo>√ó</mo><msup><mn>10</mn><mn>1</mn></msup><mo>+</mo><mn>9</mn><mo>√ó</mo><msup><mn>10</mn><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">1989 = 1 \times 10^3 \plus 9 \times 10^2 \plus 8 \times 10^1 \plus 9 \times 10^0</annotation></semantics></math> <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1989</mn><mo>=</mo><mn>1</mn><mo>√ó</mo><mn>1000</mn><mo>+</mo><mn>9</mn><mo>√ó</mo><mn>100</mn><mo>+</mo><mn>8</mn><mo>√ó</mo><mn>10</mn><mo>+</mo><mn>9</mn><mo>√ó</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1989 = 1 \times 1000 \plus 9 \times 100 \plus 8 \times 10 \plus 9 \times 1</annotation></semantics></math> <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1989</mn><mo>=</mo><mn>1000</mn><mo>+</mo><mn>900</mn><mo>+</mo><mn>80</mn><mo>+</mo><mn>9</mn></mrow><annotation encoding="application/x-tex">1989 = 1000 \plus 900 \plus 80 \plus 9</annotation></semantics></math> <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1989</mn><mo>=</mo><mn>1989</mn></mrow><annotation encoding="application/x-tex">1989 = 1989</annotation></semantics></math></p>
<p>Where the positions are numbered from the right. In other words, it‚Äôs our polynomial list from above in reverse. As well as that, the convolution is long multiplication.</p>
<p>Now, taking this straight off we can try some examples:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="co">-- 12 + 15 = 27</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2">[<span class="dv">2</span>, <span class="dv">1</span>] <span class="fu">&lt;+&gt;</span> [<span class="dv">5</span>, <span class="dv">1</span>] <span class="fu">==</span> [<span class="dv">7</span>, <span class="dv">2</span>]</a>
<a class="sourceLine" id="cb17-3" data-line-number="3"></a>
<a class="sourceLine" id="cb17-4" data-line-number="4"><span class="co">-- 23 * 2 = 46</span></a>
<a class="sourceLine" id="cb17-5" data-line-number="5">[<span class="dv">3</span>, <span class="dv">2</span>] <span class="fu">&lt;.&gt;</span> [<span class="dv">2</span>] <span class="fu">==</span> [<span class="dv">6</span>, <span class="dv">4</span>]</a></code></pre></div>
<p>The issue, of course, is that we‚Äôre not handling carrying properly:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1">[<span class="dv">6</span>] <span class="fu">&lt;+&gt;</span> [<span class="dv">6</span>] <span class="fu">==</span> [<span class="dv">12</span>]</a></code></pre></div>
<p>No matter: we can perform all the carries after the addition, and everything works out fine:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1">carry</a>
<a class="sourceLine" id="cb19-2" data-line-number="2"><span class="ot">    ::</span> <span class="dt">Integral</span> a</a>
<a class="sourceLine" id="cb19-3" data-line-number="3">    <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb19-4" data-line-number="4">carry base xs <span class="fu">=</span> foldr f (toBase base) xs <span class="dv">0</span></a>
<a class="sourceLine" id="cb19-5" data-line-number="5">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-6" data-line-number="6">    f e a cin <span class="fu">=</span> r <span class="fu">:</span> a q <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-7" data-line-number="7">      (q,r) <span class="fu">=</span> quotRem (cin <span class="fu">+</span> e) base</a>
<a class="sourceLine" id="cb19-8" data-line-number="8">        </a>
<a class="sourceLine" id="cb19-9" data-line-number="9"><span class="ot">toBase ::</span> <span class="dt">Integral</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb19-10" data-line-number="10">toBase base <span class="fu">=</span> unfoldr f <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-11" data-line-number="11">  f <span class="dv">0</span> <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb19-12" data-line-number="12">  f n <span class="fu">=</span> <span class="dt">Just</span> (swap (quotRem n base))</a></code></pre></div>
<p>Wrap the whole thing in a newtype and we can have a <code class="sourceCode haskell"><span class="dt">Num</span></code> instance:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Positional</span> </a>
<a class="sourceLine" id="cb20-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">Positional</span> </a>
<a class="sourceLine" id="cb20-3" data-line-number="3">  {<span class="ot"> withBase ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> [<span class="dt">Integer</span>] </a>
<a class="sourceLine" id="cb20-4" data-line-number="4">  } </a>
<a class="sourceLine" id="cb20-5" data-line-number="5"></a>
<a class="sourceLine" id="cb20-6" data-line-number="6"><span class="kw">instance</span> <span class="dt">Num</span> <span class="dt">Positional</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-7" data-line-number="7">  <span class="dt">Positional</span> x <span class="fu">+</span> <span class="dt">Positional</span> y <span class="fu">=</span> <span class="dt">Positional</span> (carry <span class="fu">&lt;*&gt;</span> x <span class="fu">&lt;+&gt;</span> y)</a>
<a class="sourceLine" id="cb20-8" data-line-number="8">  <span class="dt">Positional</span> x <span class="fu">*</span> <span class="dt">Positional</span> y <span class="fu">=</span> <span class="dt">Positional</span> (carry <span class="fu">&lt;*&gt;</span> x <span class="fu">&lt;.&gt;</span> y)</a>
<a class="sourceLine" id="cb20-9" data-line-number="9">  fromInteger m <span class="fu">=</span> <span class="dt">Positional</span> (\base <span class="ot">-&gt;</span> toBase base m)</a>
<a class="sourceLine" id="cb20-10" data-line-number="10">  abs <span class="fu">=</span> id</a>
<a class="sourceLine" id="cb20-11" data-line-number="11">  signum <span class="fu">=</span> id</a>
<a class="sourceLine" id="cb20-12" data-line-number="12">  negate <span class="fu">=</span> id</a>
<a class="sourceLine" id="cb20-13" data-line-number="13">  </a>
<a class="sourceLine" id="cb20-14" data-line-number="14"><span class="ot">toDigits ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Positional</span> <span class="ot">-&gt;</span> [<span class="dt">Integer</span>]</a>
<a class="sourceLine" id="cb20-15" data-line-number="15">toDigits base p <span class="fu">=</span> reverse (withBase p base)</a></code></pre></div>
<p>This also lets us choose our base after the fact:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1">sumHundred <span class="fu">=</span> (sum <span class="fu">.</span> map fromInteger) [<span class="dv">1</span><span class="fu">..</span><span class="dv">100</span>]</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">toDigits <span class="dv">10</span> sumHundred</a>
<a class="sourceLine" id="cb21-3" data-line-number="3"><span class="co">-- [5,0,5,0]</span></a>
<a class="sourceLine" id="cb21-4" data-line-number="4">toDigits <span class="dv">2</span> sumHundred</a>
<a class="sourceLine" id="cb21-5" data-line-number="5"><span class="co">-- [1,0,0,1,1,1,0,1,1,1,0,1,0]</span></a></code></pre></div>
<h1 id="vectors">Vectors</h1>
<p>All the hand-optimizing, inlining, and fusion magic in the world won‚Äôt make a list-based implementation of convolution faster than a proper one on vectors, unfortunately. In particular, for larger vectors, a fast Fourier transform can be used. Also, usually code like this will be parallelized, rather than sequential. That said, it can be helpful to implement the slower version on vectors, in the usual indexed way, for comparison‚Äôs sake:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Semiring</span> a <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb22-2" data-line-number="2">         <span class="dt">Semiring</span> (<span class="dt">Vector</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-3" data-line-number="3">    one <span class="fu">=</span> Vector.singleton one</a>
<a class="sourceLine" id="cb22-4" data-line-number="4">    zero <span class="fu">=</span> Vector.empty</a>
<a class="sourceLine" id="cb22-5" data-line-number="5">    xs <span class="fu">&lt;+&gt;</span> ys <span class="fu">=</span></a>
<a class="sourceLine" id="cb22-6" data-line-number="6">        <span class="kw">case</span> compare (Vector.length xs) (Vector.length ys) <span class="kw">of</span></a>
<a class="sourceLine" id="cb22-7" data-line-number="7">            <span class="dt">EQ</span> <span class="ot">-&gt;</span> Vector.zipWith (<span class="fu">&lt;+&gt;</span>) xs ys</a>
<a class="sourceLine" id="cb22-8" data-line-number="8">            <span class="dt">LT</span> <span class="ot">-&gt;</span> Vector.unsafeAccumulate (<span class="fu">&lt;+&gt;</span>) ys (Vector.indexed xs)</a>
<a class="sourceLine" id="cb22-9" data-line-number="9">            <span class="dt">GT</span> <span class="ot">-&gt;</span> Vector.unsafeAccumulate (<span class="fu">&lt;+&gt;</span>) xs (Vector.indexed ys)</a>
<a class="sourceLine" id="cb22-10" data-line-number="10">    signal <span class="fu">&lt;.&gt;</span> kernel</a>
<a class="sourceLine" id="cb22-11" data-line-number="11">      <span class="fu">|</span> Vector.null signal <span class="fu">=</span> Vector.empty</a>
<a class="sourceLine" id="cb22-12" data-line-number="12">      <span class="fu">|</span> Vector.null kernel <span class="fu">=</span> Vector.empty</a>
<a class="sourceLine" id="cb22-13" data-line-number="13">      <span class="fu">|</span> otherwise <span class="fu">=</span> Vector.generate (slen <span class="fu">+</span> klen <span class="fu">-</span> <span class="dv">1</span>) f</a>
<a class="sourceLine" id="cb22-14" data-line-number="14">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-15" data-line-number="15">        f n <span class="fu">=</span></a>
<a class="sourceLine" id="cb22-16" data-line-number="16">            foldl&#39;</a>
<a class="sourceLine" id="cb22-17" data-line-number="17">                (\a k <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb22-18" data-line-number="18">                      a <span class="fu">&lt;+&gt;</span></a>
<a class="sourceLine" id="cb22-19" data-line-number="19">                      Vector.unsafeIndex signal k <span class="fu">&lt;.&gt;</span></a>
<a class="sourceLine" id="cb22-20" data-line-number="20">                      Vector.unsafeIndex kernel (n <span class="fu">-</span> k))</a>
<a class="sourceLine" id="cb22-21" data-line-number="21">                zero</a>
<a class="sourceLine" id="cb22-22" data-line-number="22">                [kmin <span class="fu">..</span> kmax]</a>
<a class="sourceLine" id="cb22-23" data-line-number="23">          <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-24" data-line-number="24">            <span class="fu">!</span>kmin <span class="fu">=</span> max <span class="dv">0</span> (n <span class="fu">-</span> (klen <span class="fu">-</span> <span class="dv">1</span>))</a>
<a class="sourceLine" id="cb22-25" data-line-number="25">            <span class="fu">!</span>kmax <span class="fu">=</span> min n (slen <span class="fu">-</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb22-26" data-line-number="26">        <span class="fu">!</span>slen <span class="fu">=</span> Vector.length signal</a>
<a class="sourceLine" id="cb22-27" data-line-number="27">        <span class="fu">!</span>klen <span class="fu">=</span> Vector.length kernel</a></code></pre></div>
<h1 id="search">Search</h1>
<p>As has been observed before <span class="citation" data-cites="rivas_monoids_2015">(Rivas, Jaskelioff, and Schrijvers <a href="#ref-rivas_monoids_2015">2015</a>)</span> there‚Äôs a pretty suggestive similarity between semirings and the <code class="sourceCode haskell"><span class="dt">Applicative</span></code>/<code class="sourceCode haskell"><span class="dt">Alternative</span></code> classes in Haskell:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Semiring</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-2" data-line-number="2"><span class="ot">  one ::</span> a</a>
<a class="sourceLine" id="cb23-3" data-line-number="3"><span class="ot">  zero ::</span> a</a>
<a class="sourceLine" id="cb23-4" data-line-number="4"><span class="ot">  (&lt;+&gt;) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb23-5" data-line-number="5"><span class="ot">  (&lt;.&gt;) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb23-6" data-line-number="6"></a>
<a class="sourceLine" id="cb23-7" data-line-number="7"><span class="kw">class</span> <span class="dt">Applicative</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-8" data-line-number="8"><span class="ot">  pure ::</span> a <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb23-9" data-line-number="9"><span class="ot">  (&lt;*&gt;) ::</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</a>
<a class="sourceLine" id="cb23-10" data-line-number="10"></a>
<a class="sourceLine" id="cb23-11" data-line-number="11"><span class="kw">class</span> <span class="dt">Alternative</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-12" data-line-number="12"><span class="ot">  empty ::</span> f a</a>
<a class="sourceLine" id="cb23-13" data-line-number="13"><span class="ot">  (&lt;|&gt;) ::</span> f a <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f a</a></code></pre></div>
<p>So can our implementation of convolution be used to implement the methods for these classes? Partially:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Search</span> f a <span class="fu">=</span> <span class="dt">Search</span> {<span class="ot"> runSearch ::</span> [f a] }</a>
<a class="sourceLine" id="cb24-2" data-line-number="2"></a>
<a class="sourceLine" id="cb24-3" data-line-number="3"><span class="kw">instance</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Functor</span> (<span class="dt">Search</span> f) <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-4" data-line-number="4">  fmap f (<span class="dt">Search</span> xs) <span class="fu">=</span> <span class="dt">Search</span> ((fmap<span class="fu">.</span>fmap) f xs)</a>
<a class="sourceLine" id="cb24-5" data-line-number="5"></a>
<a class="sourceLine" id="cb24-6" data-line-number="6"><span class="kw">instance</span> <span class="dt">Alternative</span> f <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="dt">Search</span> f) <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-7" data-line-number="7">  pure x <span class="fu">=</span> <span class="dt">Search</span> [pure x]</a>
<a class="sourceLine" id="cb24-8" data-line-number="8">  _ <span class="fu">&lt;*&gt;</span> <span class="dt">Search</span> [] <span class="fu">=</span> <span class="dt">Search</span> []</a>
<a class="sourceLine" id="cb24-9" data-line-number="9">  <span class="dt">Search</span> xs <span class="fu">&lt;*&gt;</span> <span class="dt">Search</span> ys <span class="fu">=</span> <span class="dt">Search</span> (foldr f [] xs) <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-10" data-line-number="10">    f x zs <span class="fu">=</span> foldr (g x) id ys (empty <span class="fu">:</span> zs)</a>
<a class="sourceLine" id="cb24-11" data-line-number="11">    g x y a (z<span class="fu">:</span>zs) <span class="fu">=</span> (x <span class="fu">&lt;*&gt;</span> y <span class="fu">&lt;|&gt;</span> z) <span class="fu">:</span> a zs</a>
<a class="sourceLine" id="cb24-12" data-line-number="12">    g x y a [] <span class="fu">=</span> (x <span class="fu">&lt;*&gt;</span> y) <span class="fu">:</span> a []</a>
<a class="sourceLine" id="cb24-13" data-line-number="13"></a>
<a class="sourceLine" id="cb24-14" data-line-number="14"><span class="kw">instance</span> <span class="dt">Alternative</span> f <span class="ot">=&gt;</span> <span class="dt">Alternative</span> (<span class="dt">Search</span> f) <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-15" data-line-number="15">  <span class="dt">Search</span> xs <span class="fu">&lt;|&gt;</span> <span class="dt">Search</span> ys <span class="fu">=</span> <span class="dt">Search</span> (go xs ys) <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-16" data-line-number="16">    go [] ys <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb24-17" data-line-number="17">    go xs [] <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb24-18" data-line-number="18">    go (x<span class="fu">:</span>xs) (y<span class="fu">:</span>ys) <span class="fu">=</span> (x <span class="fu">&lt;|&gt;</span> y) <span class="fu">:</span> go xs ys</a>
<a class="sourceLine" id="cb24-19" data-line-number="19">  empty <span class="fu">=</span> <span class="dt">Search</span> []</a></code></pre></div>
<p>At first, this seems perfect: the types all match up, and the definitions seem sensible. The issue is with the laws: <code class="sourceCode haskell"><span class="dt">Applicative</span></code> and <code class="sourceCode haskell"><span class="dt">Alternative</span></code> are missing <em>four</em> that semirings require. In particular: commutativity of plus, annihilation by zero, and distributivity left and right:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1">xs <span class="fu">&lt;|&gt;</span> ys <span class="fu">=</span> ys <span class="fu">&lt;|&gt;</span> xs</a>
<a class="sourceLine" id="cb25-2" data-line-number="2">empty <span class="fu">&lt;*&gt;</span> xs <span class="fu">=</span> fs <span class="fu">&lt;*&gt;</span> empty <span class="fu">=</span> empty</a>
<a class="sourceLine" id="cb25-3" data-line-number="3">fs <span class="fu">&lt;*&gt;</span> (xs <span class="fu">&lt;|&gt;</span> ys) <span class="fu">=</span> fs <span class="fu">&lt;*&gt;</span> xs <span class="fu">&lt;|&gt;</span> fs <span class="fu">&lt;*&gt;</span> ys</a>
<a class="sourceLine" id="cb25-4" data-line-number="4">(fs <span class="fu">&lt;|&gt;</span> gs) <span class="fu">&lt;*&gt;</span> xs <span class="fu">=</span> fs <span class="fu">&lt;*&gt;</span> xs <span class="fu">&lt;|&gt;</span> gs <span class="fu">&lt;*&gt;</span> ys</a></code></pre></div>
<p>The vast majority of the instances of <code class="sourceCode haskell"><span class="dt">Alternative</span></code> today fail one or more of these laws. Taking lists as an example, <code class="sourceCode haskell"><span class="fu">++</span></code> obviously isn‚Äôt commutative, and <code class="sourceCode haskell"><span class="fu">&lt;*&gt;</span></code> only distributes when it‚Äôs on the right.</p>
<p>What‚Äôs the problem, though? Polynomial multiplication follows <em>more</em> laws than those required by <code class="sourceCode haskell"><span class="dt">Applicative</span></code>: why should that worry us? Unfortunately, in order for multiplication to follow those laws, it actually relies on the underlying semiring being law-abiding. And it <em>fails</em> the applicative laws when it isn‚Äôt.</p>
<p>There are two angles from which we could come at this problem: either we relax the semiring laws and try and make our implementation of convolution rely on them as little as possible, or we find <code class="sourceCode haskell"><span class="dt">Alternative</span></code> instances which follow the semiring laws. Or we could meet in the middle, relaxing the laws as much as possible until we find some <code class="sourceCode haskell"><span class="dt">Alternative</span></code>s that meet our standards.</p>
<p>This has actually been accomplished in several papers: the previously mentioned <span class="citation" data-cites="rivas_monoids_2015">Rivas, Jaskelioff, and Schrijvers (<a href="#ref-rivas_monoids_2015">2015</a>)</span> discusses near-semirings, defined as semiring-like structures with associativity, identity, and these two laws:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>√ó</mo><mi>x</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">0 \times x = 0</annotation></semantics></math> <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo><mo>√ó</mo><mi>z</mi><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>√ó</mo><mi>z</mi><mo stretchy="false" form="postfix">)</mo><mo>+</mo><mo stretchy="false" form="prefix">(</mo><mi>y</mi><mo>√ó</mo><mi>z</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(x \plus y) \times z = (x \times z) \plus (y \times z)</annotation></semantics></math></p>
<p>In contrast to normal semirings, zero only annihilates when it‚Äôs on the left, and multiplication only distributes over addition when it‚Äôs on the right. Addition is not required to be commutative.</p>
<p>The lovely paper <span class="citation" data-cites="spivey_algebras_2009">Spivey (<a href="#ref-spivey_algebras_2009">2009</a>)</span> has a similar concept: a ‚Äúbunch‚Äù.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Bunch</span> m <span class="kw">where</span></a>
<a class="sourceLine" id="cb26-2" data-line-number="2"><span class="ot">  return ::</span> a <span class="ot">-&gt;</span> m a</a>
<a class="sourceLine" id="cb26-3" data-line-number="3"><span class="ot">  (&gt;&gt;=) ::</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b</a>
<a class="sourceLine" id="cb26-4" data-line-number="4"><span class="ot">  zero ::</span> m a</a>
<a class="sourceLine" id="cb26-5" data-line-number="5"><span class="ot">  (&lt;|&gt;) ::</span> m a <span class="ot">-&gt;</span> m a <span class="ot">-&gt;</span> m a</a>
<a class="sourceLine" id="cb26-6" data-line-number="6"><span class="ot">  wrap ::</span> m a <span class="ot">-&gt;</span> m a</a></code></pre></div>
<p>The laws are all the same (with <code class="sourceCode haskell"><span class="fu">&lt;*&gt;</span></code> implemented in terms of <code class="sourceCode haskell"><span class="fu">&gt;&gt;=</span></code>), and the extra <code class="sourceCode haskell">wrap</code> operation can be expressed like so:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="ot">wrap ::</span> <span class="dt">Alternative</span> f <span class="ot">=&gt;</span> <span class="dt">Search</span> f a <span class="ot">-&gt;</span> <span class="dt">Search</span> f a</a>
<a class="sourceLine" id="cb27-2" data-line-number="2">wrap (<span class="dt">Search</span> xs) <span class="fu">=</span> <span class="dt">Search</span> (empty <span class="fu">:</span> xs)</a></code></pre></div>
<p>A definition of <code class="sourceCode haskell"><span class="fu">&gt;&gt;=</span></code> for our polynomials is also provided:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1">[] <span class="fu">&gt;&gt;=</span> _ <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb28-2" data-line-number="2">(x<span class="fu">:</span>xs) <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> foldr (<span class="fu">&lt;|&gt;</span>) empty (fmap f x) <span class="fu">&lt;|&gt;</span> wrap (xs <span class="fu">&gt;&gt;=</span> f)</a></code></pre></div>
<p>This will require the underlying <code class="sourceCode haskell">f</code> to be <code class="sourceCode haskell"><span class="dt">Foldable</span></code>. We can inline a little, and express the whole thing as a fold:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" data-line-number="1"><span class="kw">instance</span> (<span class="dt">Foldable</span> f, <span class="dt">Alternative</span> f) <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">Search</span> f) <span class="kw">where</span></a>
<a class="sourceLine" id="cb29-2" data-line-number="2">  <span class="dt">Search</span> xs <span class="fu">&gt;&gt;=</span> k <span class="fu">=</span> foldr f empty xs <span class="kw">where</span></a>
<a class="sourceLine" id="cb29-3" data-line-number="3">    f e a <span class="fu">=</span> foldr ((<span class="fu">&lt;|&gt;</span>) <span class="fu">.</span> k) (wrap a) e</a></code></pre></div>
<p>For <code class="sourceCode haskell"><span class="dt">Search</span></code> to meet the requirements of a bunch, the paper notes that the <code class="sourceCode haskell">f</code> must be assumed to be a bag, i.e., the order of its elements must be ignored.</p>
<p><span class="citation" data-cites="kiselyov_backtracking_2005">Kiselyov et al. (<a href="#ref-kiselyov_backtracking_2005">2005</a>)</span> kind of goes the other direction, defining a monad which has fair disjunction and conjunction. Unfortunately, the fair conjunction loses associativity.</p>
<h1 id="distance">Distance</h1>
<p>The end of the paper on algebras for combinatorial search wonders if notions of distance could be added to some of the algebras. I <em>think</em> that should be as simple as supplying a suitable near-semiring for <code class="sourceCode haskell">f</code>, but the definition of <code class="sourceCode haskell"><span class="fu">&gt;&gt;=</span></code> would need to be changed. The near-semiring I had in mind was the probability monad. It works correctly if inlined:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Search</span> s a <span class="fu">=</span> <span class="dt">Search</span> {<span class="ot"> runSearch ::</span> [[(a,s)]] }</a>
<a class="sourceLine" id="cb30-2" data-line-number="2"></a>
<a class="sourceLine" id="cb30-3" data-line-number="3"><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Search</span> s) <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-4" data-line-number="4">  fmap f (<span class="dt">Search</span> xs) <span class="fu">=</span> <span class="dt">Search</span> ((fmap<span class="fu">.</span>fmap<span class="fu">.</span>first) f xs)</a>
<a class="sourceLine" id="cb30-5" data-line-number="5"></a>
<a class="sourceLine" id="cb30-6" data-line-number="6"><span class="kw">instance</span> <span class="dt">Semiring</span> s <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="dt">Search</span> s) <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-7" data-line-number="7">  pure x <span class="fu">=</span> <span class="dt">Search</span> [[(x,one)]]</a>
<a class="sourceLine" id="cb30-8" data-line-number="8">  _ <span class="fu">&lt;*&gt;</span> <span class="dt">Search</span> [] <span class="fu">=</span> <span class="dt">Search</span> []</a>
<a class="sourceLine" id="cb30-9" data-line-number="9">  <span class="dt">Search</span> xs <span class="fu">&lt;*&gt;</span> <span class="dt">Search</span> ys <span class="fu">=</span> <span class="dt">Search</span> (foldr f [] xs) <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-10" data-line-number="10">    f x zs <span class="fu">=</span> foldr (g x) id ys (empty <span class="fu">:</span> zs)</a>
<a class="sourceLine" id="cb30-11" data-line-number="11">    g x y a (z<span class="fu">:</span>zs) <span class="fu">=</span> (m x y <span class="fu">++</span> z) <span class="fu">:</span> a zs</a>
<a class="sourceLine" id="cb30-12" data-line-number="12">    g x y a [] <span class="fu">=</span> (m x y) <span class="fu">:</span> a []</a>
<a class="sourceLine" id="cb30-13" data-line-number="13">    m ls rs <span class="fu">=</span> [(l r, lp<span class="fu">&lt;.&gt;</span>rp) <span class="fu">|</span> (l,lp) <span class="ot">&lt;-</span> ls, (r,rp) <span class="ot">&lt;-</span> rs]</a>
<a class="sourceLine" id="cb30-14" data-line-number="14"></a>
<a class="sourceLine" id="cb30-15" data-line-number="15"><span class="kw">instance</span> <span class="dt">Semiring</span> s <span class="ot">=&gt;</span> <span class="dt">Alternative</span> (<span class="dt">Search</span> s) <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-16" data-line-number="16">  <span class="dt">Search</span> xs <span class="fu">&lt;|&gt;</span> <span class="dt">Search</span> ys <span class="fu">=</span> <span class="dt">Search</span> (go xs ys) <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-17" data-line-number="17">    go [] ys <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb30-18" data-line-number="18">    go xs [] <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb30-19" data-line-number="19">    go (x<span class="fu">:</span>xs) (y<span class="fu">:</span>ys) <span class="fu">=</span> (x <span class="fu">++</span> y) <span class="fu">:</span> go xs ys</a>
<a class="sourceLine" id="cb30-20" data-line-number="20">  empty <span class="fu">=</span> <span class="dt">Search</span> []</a>
<a class="sourceLine" id="cb30-21" data-line-number="21"></a>
<a class="sourceLine" id="cb30-22" data-line-number="22"><span class="ot">wrap ::</span> <span class="dt">Search</span> s a <span class="ot">-&gt;</span> <span class="dt">Search</span> s a</a>
<a class="sourceLine" id="cb30-23" data-line-number="23">wrap (<span class="dt">Search</span> xs) <span class="fu">=</span> <span class="dt">Search</span> ([] <span class="fu">:</span> xs)</a>
<a class="sourceLine" id="cb30-24" data-line-number="24"></a>
<a class="sourceLine" id="cb30-25" data-line-number="25"><span class="kw">instance</span> <span class="dt">Semiring</span> s <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">Search</span> s) <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-26" data-line-number="26">  <span class="dt">Search</span> xs <span class="fu">&gt;&gt;=</span> k <span class="fu">=</span> foldr f empty xs <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-27" data-line-number="27">    f e a <span class="fu">=</span> foldr ((<span class="fu">&lt;|&gt;</span>) <span class="fu">.</span> uncurry (mulIn <span class="fu">.</span> k)) (wrap a) e</a>
<a class="sourceLine" id="cb30-28" data-line-number="28">    mulIn (<span class="dt">Search</span> x) xp <span class="fu">=</span> <span class="dt">Search</span> ((fmap<span class="fu">.</span>fmap<span class="fu">.</span>fmap) (xp<span class="fu">&lt;.&gt;</span>) x)</a></code></pre></div>
<p>But I couldn‚Äôt figure out how to get it to work for a more generalized inner monad. The above could probably be sped up, or randomized, using the many well-known techniques for probability monad optimization.</p>
<h1 id="references" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-dolan_fun_2013">
<p>Dolan, Stephen. 2013. ‚ÄúFun with semirings: A functional pearl on the abuse of linear algebra.‚Äù In, 48:101. ACM Press. doi:<a href="https://doi.org/10.1145/2500365.2500613">10.1145/2500365.2500613</a>. <a href="https://www.cl.cam.ac.uk/~sd601/papers/semirings.pdf" class="uri">https://www.cl.cam.ac.uk/~sd601/papers/semirings.pdf</a>.</p>
</div>
<div id="ref-kiselyov_backtracking_2005">
<p>Kiselyov, Oleg, Chung-chieh Shan, Daniel P Friedman, and Amr Sabry. 2005. ‚ÄúBacktracking, interleaving, and terminating monad transformers (functional pearl).‚Äù <em>ACM SIGPLAN Notices</em> 40 (9): 192‚Äì203. <a href="http://okmij.org/ftp/Computation/monads.html#LogicT" class="uri">http://okmij.org/ftp/Computation/monads.html#LogicT</a>.</p>
</div>
<div id="ref-mcbride_applicative_2008">
<p>McBride, Conor, and Ross Paterson. 2008. ‚ÄúApplicative programming with effects.‚Äù <em>Journal of functional programming</em> 18 (01): 1‚Äì13. <a href="http://strictlypositive.org/Idiom.pdf" class="uri">http://strictlypositive.org/Idiom.pdf</a>.</p>
</div>
<div id="ref-mcilroy_power_1999">
<p>McIlroy, M. Douglas. 1999. ‚ÄúPower Series, Power Serious.‚Äù <em>J. Funct. Program.</em> 9 (3) (May): 325‚Äì337. doi:<a href="https://doi.org/10.1017/S0956796899003299">10.1017/S0956796899003299</a>. <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.333.3156&amp;rep=rep1&amp;type=pdf" class="uri">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.333.3156&amp;rep=rep1&amp;type=pdf</a>.</p>
</div>
<div id="ref-okasaki_fast_1999">
<p>Okasaki, Chris. 1999. ‚ÄúFrom Fast Exponentiation to Square Matrices: An Adventure in Types.‚Äù In <em>Proceedings of the ACM SIGPLAN International Conference on Functional Programming (ICFP‚Äô99), Paris, France, September 27-29, 1999</em>, 34:28. ACM. <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.456.357&amp;rep=rep1&amp;type=pdf" class="uri">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.456.357&amp;rep=rep1&amp;type=pdf</a>.</p>
</div>
<div id="ref-rivas_monoids_2015">
<p>Rivas, Exequiel, Mauro Jaskelioff, and Tom Schrijvers. 2015. ‚ÄúFrom monoids to near-semirings: The essence of MonadPlus and Alternative.‚Äù In <em>Proceedings of the 17th International Symposium on Principles and Practice of Declarative Programming</em>, 196‚Äì207. ACM. doi:<a href="https://doi.org/10.1145/2790449.2790514">10.1145/2790449.2790514</a>. <a href="http://www.fceia.unr.edu.ar/~mauro/pubs/FromMonoidstoNearsemirings.pdf" class="uri">http://www.fceia.unr.edu.ar/~mauro/pubs/FromMonoidstoNearsemirings.pdf</a>.</p>
</div>
<div id="ref-spivey_algebras_2009">
<p>Spivey, J. Michael. 2009. ‚ÄúAlgebras for combinatorial search.‚Äù <em>Journal of Functional Programming</em> 19 (3-4) (July): 469‚Äì487. doi:<a href="https://doi.org/10.1017/S0956796809007321">10.1017/S0956796809007321</a>. <a href="https://pdfs.semanticscholar.org/db3e/373bb6e7e7837ebc524da0a25903958554ed.pdf" class="uri">https://pdfs.semanticscholar.org/db3e/373bb6e7e7837ebc524da0a25903958554ed.pdf</a>.</p>
</div>
</div>
]]></description>
    <pubDate>Fri, 13 Oct 2017 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2017-10-13-convolutions-and-semirings.html</guid>
    <dc:creator>Donnacha Ois√≠n Kidney</dc:creator>
</item>
<item>
    <title>Applicative Arithmetic</title>
    <link>https://doisinkidney.com/posts/2017-09-25-applicative-arithmetic.html</link>
    <description><![CDATA[<div class="info">
    Posted on September 25, 2017
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Applicative.html">Applicative</a>
    
</div>

<h1 id="safer-arithmetic">Safer Arithmetic</h1>
<p>There are a couple partial functions in the Haskell Prelude which people seem to agree shouldn‚Äôt be there. <code class="sourceCode haskell">head</code>, for example, will throw an error on an empty list. Most seem to agree that it should work something more like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1">head<span class="ot"> ::</span> <span class="dt">Foldable</span> f <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">head <span class="fu">=</span> foldr (const <span class="fu">.</span> <span class="dt">Just</span>) <span class="dt">Nothing</span></a></code></pre></div>
<p>There are other examples, like <code class="sourceCode haskell">last</code>, <code class="sourceCode haskell"><span class="fu">!!</span></code>, etc.</p>
<p>One which people <em>don‚Äôt</em> agree on, however, is division by zero. In the current Prelude, the following will throw an error:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="dv">1</span> <span class="fu">/</span> <span class="dv">0</span></a></code></pre></div>
<p>The ‚Äúsafe‚Äù version might have a signature like this:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">(/) ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</a></code></pre></div>
<p>However, this turns out to be quite a headache for writing code generally. So the default is the (somewhat) unsafe version.</p>
<p>Is there a way to introduce a safer version without much overhead, so the programmer is given the option? Of course! With some newtype magic, it‚Äôs pretty simple to write a wrapper which catches division by zero in some arbitrary monad:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">AppNum</span> f a <span class="fu">=</span> <span class="dt">AppNum</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">    {<span class="ot"> runAppNum ::</span> f a</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">    } <span class="kw">deriving</span> (<span class="dt">Functor</span>,<span class="dt">Applicative</span>,<span class="dt">Monad</span>,<span class="dt">Alternative</span>,<span class="dt">Show</span>,<span class="dt">Eq</span>,<span class="dt">MonadFail</span>)</a>
<a class="sourceLine" id="cb4-4" data-line-number="4"></a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="kw">instance</span> (<span class="dt">Num</span> a, <span class="dt">Applicative</span> f) <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">         <span class="dt">Num</span> (<span class="dt">AppNum</span> f a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7">    abs <span class="fu">=</span> fmap abs</a>
<a class="sourceLine" id="cb4-8" data-line-number="8">    signum <span class="fu">=</span> fmap signum</a>
<a class="sourceLine" id="cb4-9" data-line-number="9">    (<span class="fu">+</span>) <span class="fu">=</span> liftA2 (<span class="fu">+</span>)</a>
<a class="sourceLine" id="cb4-10" data-line-number="10">    (<span class="fu">*</span>) <span class="fu">=</span> liftA2 (<span class="fu">*</span>)</a>
<a class="sourceLine" id="cb4-11" data-line-number="11">    (<span class="fu">-</span>) <span class="fu">=</span> liftA2 (<span class="fu">-</span>)</a>
<a class="sourceLine" id="cb4-12" data-line-number="12">    negate <span class="fu">=</span> fmap negate</a>
<a class="sourceLine" id="cb4-13" data-line-number="13">    fromInteger <span class="fu">=</span> pure <span class="fu">.</span> fromInteger</a>
<a class="sourceLine" id="cb4-14" data-line-number="14"></a>
<a class="sourceLine" id="cb4-15" data-line-number="15"><span class="kw">instance</span> (<span class="dt">Fractional</span> a, <span class="dt">MonadFail</span> f, <span class="dt">Eq</span> a) <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb4-16" data-line-number="16">         <span class="dt">Fractional</span> (<span class="dt">AppNum</span> f a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-17" data-line-number="17">    fromRational <span class="fu">=</span> pure <span class="fu">.</span> fromRational</a>
<a class="sourceLine" id="cb4-18" data-line-number="18">    xs <span class="fu">/</span> ys <span class="fu">=</span></a>
<a class="sourceLine" id="cb4-19" data-line-number="19">        ys <span class="fu">&gt;&gt;=</span></a>
<a class="sourceLine" id="cb4-20" data-line-number="20">        \<span class="kw">case</span></a>
<a class="sourceLine" id="cb4-21" data-line-number="21">            <span class="dv">0</span> <span class="ot">-&gt;</span> fail <span class="st">&quot;divide by zero&quot;</span></a>
<a class="sourceLine" id="cb4-22" data-line-number="22">            y <span class="ot">-&gt;</span> fmap (<span class="fu">/</span> y) xs</a></code></pre></div>
<p>I‚Äôm using the <code class="sourceCode haskell"><span class="fu">-</span><span class="dt">XLambdaCase</span></code> extension and <code class="sourceCode haskell"><span class="dt">MonadFail</span></code> here.</p>
<h1 id="free-applicatives">Free Applicatives</h1>
<p>You‚Äôll notice that you only need <code class="sourceCode haskell"><span class="dt">Applicative</span></code> for most of the arithmetic operations above. In fact, you only need <code class="sourceCode haskell"><span class="dt">Monad</span></code> when you want to examine the contents of <code class="sourceCode haskell">f</code>. Using that fact, we can manipulate expression trees using the free applicative from the <a href="https://hackage.haskell.org/package/free">free</a> package. Say, for instance, we want to have free variables in our expressions. Using <code class="sourceCode haskell"><span class="dt">Either</span></code>, it‚Äôs pretty easy:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">type</span> <span class="dt">WithVars</span> <span class="fu">=</span> <span class="dt">AppNum</span> (<span class="dt">Ap</span> (<span class="dt">Either</span> <span class="dt">String</span>)) <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="ot">var ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">WithVars</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">var <span class="fu">=</span> <span class="dt">AppNum</span> <span class="fu">.</span> liftAp <span class="fu">.</span> <span class="dt">Left</span></a></code></pre></div>
<p>We can collect the free variables from an expression:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">vars ::</span> <span class="dt">WithVars</span> <span class="ot">-&gt;</span> [<span class="dt">String</span>]</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">vars <span class="fu">=</span> runAp_ (either pure (const [])) <span class="fu">.</span> runAppNum</a>
<a class="sourceLine" id="cb6-3" data-line-number="3"></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">x <span class="fu">=</span> <span class="dv">1</span><span class="ot"> ::</span> <span class="dt">WithVars</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">y <span class="fu">=</span> var <span class="st">&quot;y&quot;</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">z <span class="fu">=</span> var <span class="st">&quot;z&quot;</span></a>
<a class="sourceLine" id="cb6-7" data-line-number="7"></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">vars (x <span class="fu">+</span> y <span class="fu">+</span> z) <span class="co">-- [&quot;y&quot;,&quot;z&quot;]</span></a></code></pre></div>
<p>If we want to sub in, though, we‚Äôre going to run into a problem: we can‚Äôt just pass in a <code class="sourceCode haskell"><span class="dt">Map</span> <span class="dt">String</span> <span class="dt">Integer</span></code> because you‚Äôre able to construct values like this:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">bad ::</span> <span class="dt">AppNum</span> (<span class="dt">Ap</span> (<span class="dt">Either</span> <span class="dt">String</span>)) (<span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>)</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">bad <span class="fu">=</span> <span class="dt">AppNum</span> (liftAp (<span class="dt">Left</span> <span class="st">&quot;oh noes&quot;</span>))</a></code></pre></div>
<p>We‚Äôd need to pass in a <code class="sourceCode haskell"><span class="dt">Map</span> <span class="dt">String</span> (<span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>)</code> as well; in fact you‚Äôd need a map for every possible type. Which isn‚Äôt feasible.</p>
<h1 id="gadts">GADTs</h1>
<p>Luckily, we <em>can</em> constrain the types of variables in our expression so that they‚Äôre always <code class="sourceCode haskell"><span class="dt">Integer</span></code>, using a GADT:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Variable</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">        <span class="dt">Constant</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Variable</span> a</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">        <span class="dt">Variable</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Variable</span> <span class="dt">Integer</span></a></code></pre></div>
<p>The type above seems useless on its own: it doesn‚Äôt have a <code class="sourceCode haskell"><span class="dt">Functor</span></code> instance, never mind an <code class="sourceCode haskell"><span class="dt">Applicative</span></code>, so how can it fit into <code class="sourceCode haskell"><span class="dt">AppNum</span></code>?</p>
<p>The magic comes from the free applicative, which converts any type of kind <code class="sourceCode haskell"><span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></code> into an applicative. With that in mind, we can change around the previous code:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">type</span> <span class="dt">WithVars</span> <span class="fu">=</span> <span class="dt">AppNum</span> (<span class="dt">Ap</span> <span class="dt">Variable</span>) <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"></a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="ot">var ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">WithVars</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4">var <span class="fu">=</span> <span class="dt">AppNum</span> <span class="fu">.</span> liftAp <span class="fu">.</span> <span class="dt">Variable</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5"></a>
<a class="sourceLine" id="cb9-6" data-line-number="6"><span class="ot">vars ::</span> <span class="dt">WithVars</span> <span class="ot">-&gt;</span> [<span class="dt">String</span>]</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">vars <span class="fu">=</span> runAp_ f <span class="fu">.</span> runAppNum</a>
<a class="sourceLine" id="cb9-8" data-line-number="8">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-9" data-line-number="9"><span class="ot">    f ::</span> <span class="dt">Variable</span> a <span class="ot">-&gt;</span> [<span class="dt">String</span>]</a>
<a class="sourceLine" id="cb9-10" data-line-number="10">    f (<span class="dt">Constant</span> _) <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb9-11" data-line-number="11">    f (<span class="dt">Variable</span> s) <span class="fu">=</span> [s]</a></code></pre></div>
<p>And write the function to sub in for us:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">variableA</a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="ot">    ::</span> <span class="dt">Applicative</span> f</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">    <span class="ot">=&gt;</span> (<span class="dt">String</span> <span class="ot">-&gt;</span> f <span class="dt">Integer</span>) <span class="ot">-&gt;</span> <span class="dt">Variable</span> a <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">variableA _ (<span class="dt">Constant</span> x) <span class="fu">=</span> pure x</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">variableA f (<span class="dt">Variable</span> s) <span class="fu">=</span> f s</a>
<a class="sourceLine" id="cb10-6" data-line-number="6"></a>
<a class="sourceLine" id="cb10-7" data-line-number="7"><span class="ot">variable ::</span> (<span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>) <span class="ot">-&gt;</span> <span class="dt">Variable</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb10-8" data-line-number="8">variable _ (<span class="dt">Constant</span> x) <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb10-9" data-line-number="9">variable f (<span class="dt">Variable</span> s) <span class="fu">=</span> f s</a>
<a class="sourceLine" id="cb10-10" data-line-number="10"></a>
<a class="sourceLine" id="cb10-11" data-line-number="11"><span class="ot">replace ::</span> <span class="dt">Map</span> <span class="dt">String</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">WithVars</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb10-12" data-line-number="12">replace m <span class="fu">=</span> runAp (variable (m <span class="fu">Map.!</span>)) <span class="fu">.</span> runAppNum</a>
<a class="sourceLine" id="cb10-13" data-line-number="13"></a>
<a class="sourceLine" id="cb10-14" data-line-number="14">replace (Map.fromList [(<span class="st">&quot;z&quot;</span>,<span class="dv">2</span>), (<span class="st">&quot;y&quot;</span>,<span class="dv">3</span>)]) (x <span class="fu">+</span> y <span class="fu">+</span> z)</a>
<a class="sourceLine" id="cb10-15" data-line-number="15"><span class="co">-- 6</span></a></code></pre></div>
<h1 id="accumulation">Accumulation</h1>
<p>This will fail if a free variable isn‚Äôt present in the map, unfortunately. To fix it, we <em>could</em> use <code class="sourceCode haskell"><span class="dt">Either</span></code> instead of <code class="sourceCode haskell"><span class="dt">Identity</span></code>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">replace ::</span> <span class="dt">Map</span> <span class="dt">String</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">WithVars</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2">replace m <span class="fu">=</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">    runAp</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">        (variableA <span class="fu">$</span></a>
<a class="sourceLine" id="cb11-5" data-line-number="5">         \s <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb11-6" data-line-number="6">              maybe (<span class="dt">Left</span> s) <span class="dt">Right</span> (Map.lookup s m)) <span class="fu">.</span></a>
<a class="sourceLine" id="cb11-7" data-line-number="7">    runAppNum</a></code></pre></div>
<p>But this only gives us the first missing variable encountered. We‚Äôd like to get back <em>all</em> of the missing variables, ideally: accumulating the <code class="sourceCode haskell"><span class="dt">Left</span></code>s. <code class="sourceCode haskell"><span class="dt">Either</span></code> doesn‚Äôt accumulate values, as if it did it would <a href="https://stackoverflow.com/a/23611068/4892417">break the monad laws</a>.</p>
<p>There‚Äôs no issue with the <em>applicative</em> laws, though, which is why the <a href="https://hackage.haskell.org/package/validation-0.5.4">validation</a> package provides a <em>non-monadic</em> either-like type, which we can use here.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="ot">replace ::</span> <span class="dt">Map</span> <span class="dt">String</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">WithVars</span> <span class="ot">-&gt;</span> <span class="dt">AccValidation</span> [<span class="dt">String</span>] <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">replace m <span class="fu">=</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">    runAp</a>
<a class="sourceLine" id="cb12-4" data-line-number="4">        (variableA <span class="fu">$</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5">         \s <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb12-6" data-line-number="6">              maybe (<span class="dt">AccFailure</span> [s]) pure (Map.lookup s m)) <span class="fu">.</span></a>
<a class="sourceLine" id="cb12-7" data-line-number="7">    runAppNum</a>
<a class="sourceLine" id="cb12-8" data-line-number="8"></a>
<a class="sourceLine" id="cb12-9" data-line-number="9">replace (Map.fromList []) (x <span class="fu">+</span> y <span class="fu">+</span> z)</a>
<a class="sourceLine" id="cb12-10" data-line-number="10"><span class="co">-- AccFailure [&quot;y&quot;,&quot;z&quot;]</span></a></code></pre></div>
<h1 id="other-uses">Other uses</h1>
<p>There are a bunch more applicatives you could use instead of <code class="sourceCode haskell"><span class="dt">Either</span></code>. Using lists, for instance, you could calculate the possible outcomes from a range of inputs:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1">range<span class="ot"> ::</span> <span class="dt">WithVars</span> <span class="ot">-&gt;</span> [<span class="dt">Integer</span>]</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">range <span class="fu">=</span> runAp (variable (const [<span class="dv">1</span><span class="fu">..</span><span class="dv">3</span>])) <span class="fu">.</span> runAppNum</a>
<a class="sourceLine" id="cb13-3" data-line-number="3"></a>
<a class="sourceLine" id="cb13-4" data-line-number="4">range (x <span class="fu">+</span> y <span class="fu">+</span> z)</a>
<a class="sourceLine" id="cb13-5" data-line-number="5"><span class="co">-- [3,4,5,4,5,6,5,6,7]</span></a></code></pre></div>
<p>Or you could ask the user for input:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="ot">query ::</span> <span class="dt">WithVars</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2">query <span class="fu">=</span> runAp (variable f) <span class="fu">.</span> runAppNum</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-4" data-line-number="4">    f s <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb14-5" data-line-number="5">      putStr <span class="st">&quot;Input a value for &quot;</span></a>
<a class="sourceLine" id="cb14-6" data-line-number="6">      putStrLn s</a>
<a class="sourceLine" id="cb14-7" data-line-number="7">      fmap read getLine</a></code></pre></div>
<p>Finally, and this one‚Äôs a bit exotic, you could examine every variable in turn, with defaults for the others:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1">zygo</a>
<a class="sourceLine" id="cb15-2" data-line-number="2"><span class="ot">    ::</span> (forall x<span class="fu">.</span> f x <span class="ot">-&gt;</span> x)</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">    <span class="ot">-&gt;</span> (forall x<span class="fu">.</span> f x <span class="ot">-&gt;</span> (x <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> b)</a>
<a class="sourceLine" id="cb15-4" data-line-number="4">    <span class="ot">-&gt;</span> <span class="dt">Ap</span> f a</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">    <span class="ot">-&gt;</span> [b]</a>
<a class="sourceLine" id="cb15-6" data-line-number="6">zygo (<span class="ot">l ::</span> forall x<span class="fu">.</span> f x <span class="ot">-&gt;</span> x) (<span class="ot">c ::</span> forall x<span class="fu">.</span> f x <span class="ot">-&gt;</span> (x <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> b) <span class="fu">=</span></a>
<a class="sourceLine" id="cb15-7" data-line-number="7">    fst <span class="fu">.</span> go id</a>
<a class="sourceLine" id="cb15-8" data-line-number="8">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-9" data-line-number="9"><span class="ot">    go ::</span> forall c<span class="fu">.</span> (c <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Ap</span> f c <span class="ot">-&gt;</span> ([b], c)</a>
<a class="sourceLine" id="cb15-10" data-line-number="10">    go _ (<span class="dt">Pure</span> x) <span class="fu">=</span> ([], x)</a>
<a class="sourceLine" id="cb15-11" data-line-number="11">    go k (<span class="dt">Ap</span> x f) <span class="fu">=</span> (c x (k <span class="fu">.</span> ls) <span class="fu">:</span> xs, ls lx)</a>
<a class="sourceLine" id="cb15-12" data-line-number="12">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-13" data-line-number="13">        (xs,ls) <span class="fu">=</span> go (k <span class="fu">.</span> (<span class="fu">$</span> lx)) f</a>
<a class="sourceLine" id="cb15-14" data-line-number="14">        lx <span class="fu">=</span> l x</a>
<a class="sourceLine" id="cb15-15" data-line-number="15"></a>
<a class="sourceLine" id="cb15-16" data-line-number="16"><span class="ot">examineEach ::</span> <span class="dt">WithVars</span> <span class="ot">-&gt;</span> [<span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>]</a>
<a class="sourceLine" id="cb15-17" data-line-number="17">examineEach <span class="fu">=</span> zygo (variable (const <span class="dv">1</span>)) g <span class="fu">.</span> runAppNum</a>
<a class="sourceLine" id="cb15-18" data-line-number="18">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-19" data-line-number="19"><span class="ot">    g ::</span> <span class="dt">Variable</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb15-20" data-line-number="20">    g (<span class="dt">Constant</span> x) rhs _ <span class="fu">=</span> rhs x</a>
<a class="sourceLine" id="cb15-21" data-line-number="21">    g (<span class="dt">Variable</span> _) rhs i <span class="fu">=</span> rhs i</a></code></pre></div>
<p>This produces a list of functions which are equivalent to subbing in for each variable with the rest set to 1.</p>
]]></description>
    <pubDate>Mon, 25 Sep 2017 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2017-09-25-applicative-arithmetic.html</guid>
    <dc:creator>Donnacha Ois√≠n Kidney</dc:creator>
</item>
<item>
    <title>Verifying Data Structures in Haskell</title>
    <link>https://doisinkidney.com/posts/2017-04-23-verifying-data-structures-in-haskell-lhs.html</link>
    <description><![CDATA[<div class="info">
    Posted on April 23, 2017
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Dependent%20Types.html">Dependent Types</a>, <a href="/tags/Data%20Structures.html">Data Structures</a>
    
</div>

<div class="sourceCode" id="cb1"><pre class="sourceCode haskell literate hidden_source"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">{-# LANGUAGE DataKinds #-}</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="ot">{-# LANGUAGE TypeOperators #-}</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="ot">{-# LANGUAGE TypeFamilies #-}</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="ot">{-# LANGUAGE TypeInType #-}</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="ot">{-# LANGUAGE KindSignatures #-}</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="ot">{-# LANGUAGE GADTs #-}</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="ot">{-# LANGUAGE RankNTypes #-}</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"><span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9"><span class="ot">{-# LANGUAGE BangPatterns #-}</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10"><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11"><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></a>
<a class="sourceLine" id="cb1-12" data-line-number="12"><span class="ot">{-# LANGUAGE RebindableSyntax #-}</span></a>
<a class="sourceLine" id="cb1-13" data-line-number="13"></a>
<a class="sourceLine" id="cb1-14" data-line-number="14"><span class="ot">{-# OPTIONS_GHC -fplugin GHC.TypeLits.Normalise #-}</span></a>
<a class="sourceLine" id="cb1-15" data-line-number="15"></a>
<a class="sourceLine" id="cb1-16" data-line-number="16"><span class="kw">module</span> <span class="dt">VerifiedDataStructures</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-17" data-line-number="17"></a>
<a class="sourceLine" id="cb1-18" data-line-number="18"><span class="kw">import</span> <span class="dt">Data.Kind</span> <span class="kw">hiding</span> (type (*))</a>
<a class="sourceLine" id="cb1-19" data-line-number="19"><span class="kw">import</span> <span class="dt">Data.Type.Equality</span></a>
<a class="sourceLine" id="cb1-20" data-line-number="20"><span class="kw">import</span> <span class="dt">Unsafe.Coerce</span></a>
<a class="sourceLine" id="cb1-21" data-line-number="21"><span class="kw">import</span> <span class="dt">GHC.TypeLits</span> <span class="kw">hiding</span> (type (&lt;=))</a>
<a class="sourceLine" id="cb1-22" data-line-number="22"><span class="kw">import</span> <span class="dt">Data.Proxy</span></a>
<a class="sourceLine" id="cb1-23" data-line-number="23"><span class="kw">import</span> <span class="dt">Data.Coerce</span></a>
<a class="sourceLine" id="cb1-24" data-line-number="24"><span class="kw">import</span> <span class="dt">Prelude</span></a></code></pre></div>
<p>A while ago I read <a href="https://www.reddit.com/r/haskell/comments/63a4ea/fast_total_sorting_of_arbitrary_traversable/">this</a> post on reddit (by David Feuer), about sorting traversables (which was a follow-up on <a href="http://elvishjerricco.github.io/2017/03/23/applicative-sorting.html">this</a> post by Will Fancher), and I was inspired to write some pseudo-dependently-typed Haskell. The post (and subsequent <a href="https://github.com/treeowl/sort-traversable">library</a>) detailed how to use size-indexed heaps to perform fast, total sorting on any traversable. I ended up with a <a href="https://github.com/oisdk/type-indexed-queues">library</a> which has five size-indexed heaps (Braun, pairing, binomial, skew, and leftist), each verified for structural correctness. I also included the non-indexed implementations of each for comparison (as well as benchmarks, tests, and all that good stuff).</p>
<p>The purpose of this post is to go through some of the tricks I used and problems I encountered writing a lot of type-level code in modern Haskell.</p>
<h3 id="type-level-numbers-in-haskell">Type-Level Numbers in Haskell</h3>
<p>In order to index things by their size, we‚Äôll need a type-level representation of size. We‚Äôll use <a href="https://wiki.haskell.org/Peano_numbers">Peano</a> numbers for now:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Peano</span> <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">|</span> <span class="dt">S</span> <span class="dt">Peano</span></a></code></pre></div>
<p><code class="sourceCode haskell"><span class="dt">Z</span></code> stands for zero, and <code class="sourceCode haskell"><span class="dt">S</span></code> for successor. The terseness is pretty necessary here, unfortunately: arithmetic becomes unreadable otherwise. The simplicity of this definition is useful for proofs and manipulation; however any runtime representation of these numbers is going to be woefully slow.</p>
<p>With the <code class="sourceCode haskell"><span class="dt">DataKinds</span></code> extension, the above is automatically promoted to the type-level, so we can write type-level functions (type families) on the <code class="sourceCode haskell"><span class="dt">Peano</span></code> type:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">Plus</span> (<span class="ot">n ::</span> <span class="dt">Peano</span>) (<span class="ot">m ::</span> <span class="dt">Peano</span>)<span class="ot"> ::</span> <span class="dt">Peano</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">        <span class="dt">Plus</span> <span class="dt">Z</span> m <span class="fu">=</span> m</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">        <span class="dt">Plus</span> (<span class="dt">S</span> n) m <span class="fu">=</span> <span class="dt">S</span> (<span class="dt">Plus</span> n m)</a></code></pre></div>
<p>Here the <code class="sourceCode haskell"><span class="dt">TypeFamilies</span></code> extension is needed. I‚Äôll try and mention every extension I‚Äôm using as we go, but I might forget a few, so check the repository for all of the examples (quick aside: I <em>did</em> manage to avoid using <code class="sourceCode haskell"><span class="dt">UndecidableInstances</span></code>, but more on that later). One pragma that‚Äôs worth mentioning is:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">{-# OPTIONS_GHC -fno-warn-unticked-promoted-constructors #-}</span></a></code></pre></div>
<p>This suppresses warnings on the definition of <code class="sourceCode haskell"><span class="dt">Plus</span></code> above. Without it, GHC would want us to write:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">Plus</span> (<span class="ot">n ::</span> <span class="dt">Peano</span>) (<span class="ot">m ::</span> <span class="dt">Peano</span>)<span class="ot"> ::</span> <span class="dt">Peano</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">        <span class="dt">Plus</span> <span class="ch">&#39;Z m = m</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">        <span class="dt">Plus</span> (<span class="ch">&#39;S n) m = &#39;</span><span class="dt">S</span> (<span class="dt">Plus</span> n m)</a></code></pre></div>
<p>I think that looks pretty ugly, and it can get much worse with more involved arithmetic. The only thing I have found the warnings useful for is <code class="sourceCode haskell">[]</code>: the type-level empty list gives an error in its unticked form.</p>
<h3 id="using-the-type-level-numbers-with-a-pairing-heap">Using the Type-Level Numbers with a Pairing Heap</h3>
<p>In the original post, a pairing heap <span class="citation" data-cites="fredman_pairing_1986">(Fredman et al. <a href="#ref-fredman_pairing_1986">1986</a>)</span> was used, for its simplicity and performance. The implementation looked like this:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Heap</span> n a <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  <span class="dt">E</span><span class="ot"> ::</span> <span class="dt">Heap</span> <span class="dt">Z</span> a</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  <span class="dt">T</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">HVec</span> n a <span class="ot">-&gt;</span> <span class="dt">Heap</span> (<span class="dt">S</span> n) a</a>
<a class="sourceLine" id="cb6-4" data-line-number="4"></a>
<a class="sourceLine" id="cb6-5" data-line-number="5"><span class="kw">data</span> <span class="dt">HVec</span> n a <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">  <span class="dt">HNil</span><span class="ot"> ::</span> <span class="dt">HVec</span> <span class="dt">Z</span> a</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">  <span class="dt">HCons</span><span class="ot"> ::</span> <span class="dt">Heap</span> m a <span class="ot">-&gt;</span> <span class="dt">HVec</span> n a <span class="ot">-&gt;</span> <span class="dt">HVec</span> (<span class="dt">Plus</span> m n) a</a></code></pre></div>
<p>You immediately run into trouble when you try to define merge:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">merge ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Heap</span> m a <span class="ot">-&gt;</span> <span class="dt">Heap</span> n a <span class="ot">-&gt;</span> <span class="dt">Heap</span> (<span class="dt">Plus</span> m n) a</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">merge <span class="dt">E</span> ys <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">merge xs <span class="dt">E</span> <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">merge h1<span class="fu">@</span>(<span class="dt">T</span> x xs) h2<span class="fu">@</span>(<span class="dt">T</span> y ys)</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">  <span class="fu">|</span> x <span class="fu">&lt;=</span> y <span class="fu">=</span> <span class="dt">T</span> x (<span class="dt">HCons</span> h2 xs)</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">T</span> y (<span class="dt">HCons</span> h1 ys)</a></code></pre></div>
<p>Three errors show up here, but we‚Äôll look at the first one:</p>
<blockquote>
<p><code>Could not deduce (m ~ (Plus m Z))</code></p>
</blockquote>
<p>GHC doesn‚Äôt know that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mi>x</mi><mo>+</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x = x + 0</annotation></semantics></math>. Somehow, we‚Äôll have to <em>prove</em> that it does.</p>
<h3 id="singletons">Singletons</h3>
<p>In a language with true dependent types, proving the proposition above is as simple as:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode idris"><code class="sourceCode idris"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="fu">plusZeroNeutral</span> <span class="ot">:</span> (n <span class="ot">:</span> <span class="dt">Nat</span>) <span class="ot">-&gt;</span> n <span class="fu">+</span> <span class="dv">0</span> <span class="fu">=</span> n</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">plusZeroNeutral <span class="dt">Z</span> <span class="fu">=</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">plusZeroNeutral (<span class="dt">S</span> k) <span class="fu">=</span> cong (plusZeroNeutral k)</a></code></pre></div>
<p>(this example is in Idris)</p>
<p>In Haskell, on the other hand, we can‚Äôt do the same: functions on the value-level <code class="sourceCode haskell"><span class="dt">Peano</span></code> have no relationship with functions on the type-level <code class="sourceCode haskell"><span class="dt">Peano</span></code>. There‚Äôs no way to automatically link or promote one to the other.</p>
<p>This is where singletons come in <span class="citation" data-cites="eisenberg_dependently_2012">(Eisenberg and Weirich <a href="#ref-eisenberg_dependently_2012">2012</a>)</span>. A singleton is a datatype which mirrors a type-level value exactly, except that it has a type parameter which matches the equivalent value on the type-level. In this way, we can write functions on the value-level which are linked to the type-level. Here‚Äôs a potential singleton for <code class="sourceCode haskell"><span class="dt">Peano</span></code>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Natty</span> n <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">    <span class="dt">Zy</span><span class="ot"> ::</span> <span class="dt">Natty</span> <span class="dt">Z</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">    <span class="dt">Sy</span><span class="ot"> ::</span> <span class="dt">Natty</span> n <span class="ot">-&gt;</span> <span class="dt">Natty</span> (<span class="dt">S</span> n)</a></code></pre></div>
<p>(we need <code class="sourceCode haskell"><span class="dt">GADTs</span></code> for this example)</p>
<p>Now, when we pattern-match on <code class="sourceCode haskell"><span class="dt">Natty</span></code>, we get a proof of whatever its type parameter was. Here‚Äôs a trivial example:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">isZero ::</span> <span class="dt">Natty</span> n <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (n <span class="fu">:~:</span> <span class="dt">Z</span>)</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">isZero <span class="dt">Zy</span> <span class="fu">=</span> <span class="dt">Just</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3">isZero (<span class="dt">Sy</span> _) <span class="fu">=</span> <span class="dt">Nothing</span></a></code></pre></div>
<p>When we match on <code class="sourceCode haskell"><span class="dt">Zy</span></code>, the <em>only value</em> which <code class="sourceCode haskell">n</code> could have been is <code class="sourceCode haskell"><span class="dt">Z</span></code>, because the only way to construct <code class="sourceCode haskell"><span class="dt">Zy</span></code> is if the type parameter is <code class="sourceCode haskell"><span class="dt">Z</span></code>.</p>
<p>Using this technique, the <code class="sourceCode haskell">plusZeroNeutral</code> proof looks reasonably similar to the Idris version:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">plusZeroNeutral ::</span> <span class="dt">Natty</span> n <span class="ot">-&gt;</span> <span class="dt">Plus</span> n <span class="dt">Z</span> <span class="fu">:~:</span> n</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">plusZeroNeutral <span class="dt">Zy</span> <span class="fu">=</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">plusZeroNeutral (<span class="dt">Sy</span> n) <span class="fu">=</span> <span class="kw">case</span> plusZeroNeutral n <span class="kw">of</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4">    <span class="dt">Refl</span> <span class="ot">-&gt;</span> <span class="dt">Refl</span></a></code></pre></div>
<p>To generalize the singletons a little, we could probably use the <a href="https://hackage.haskell.org/package/singletons">singletons</a> library, or we could roll our own:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">data</span> family <span class="dt">The</span><span class="ot"> k ::</span> k <span class="ot">-&gt;</span> <span class="dt">Type</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2"></a>
<a class="sourceLine" id="cb12-3" data-line-number="3"><span class="kw">data</span> <span class="kw">instance</span> <span class="dt">The</span> <span class="dt">Peano</span> n <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">    <span class="dt">Zy</span><span class="ot"> ::</span> <span class="dt">The</span> <span class="dt">Peano</span> <span class="dt">Z</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5">    <span class="dt">Sy</span><span class="ot"> ::</span> <span class="dt">The</span> <span class="dt">Peano</span> n <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Peano</span> (<span class="dt">S</span> n)</a>
<a class="sourceLine" id="cb12-6" data-line-number="6"></a>
<a class="sourceLine" id="cb12-7" data-line-number="7"><span class="ot">plusZeroNeutral ::</span> <span class="dt">The</span> <span class="dt">Peano</span> n <span class="ot">-&gt;</span> <span class="dt">Plus</span> n <span class="dt">Z</span> <span class="fu">:~:</span> n</a>
<a class="sourceLine" id="cb12-8" data-line-number="8">plusZeroNeutral <span class="dt">Zy</span> <span class="fu">=</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb12-9" data-line-number="9">plusZeroNeutral (<span class="dt">Sy</span> n) <span class="fu">=</span> <span class="kw">case</span> plusZeroNeutral n <span class="kw">of</span></a>
<a class="sourceLine" id="cb12-10" data-line-number="10">    <span class="dt">Refl</span> <span class="ot">-&gt;</span> <span class="dt">Refl</span></a></code></pre></div>
<p>The <code class="sourceCode haskell"><span class="dt">The</span></code> naming is kind of cute, I think. It makes the signature look <em>almost</em> like the Idris version (<code class="sourceCode idris">the</code> is a function from the Idris standard library). The <code class="sourceCode haskell"><span class="dt">The</span></code> type family requires the <code class="sourceCode haskell"><span class="dt">TypeInType</span></code> extension, which I‚Äôll talk a little more about later.</p>
<h3 id="proof-erasure-and-totality">Proof Erasure and Totality</h3>
<p>There‚Äôs an issue with these kinds of proofs: the proof code runs <em>every time</em> it is needed. Since the same value is coming out the other end each time (<code class="sourceCode haskell"><span class="dt">Refl</span></code>), this seems wasteful.</p>
<p>In a language like Idris, this problem is avoided by noticing that you‚Äôre only using the proof for its type information, and then erasing it at runtime. In Haskell, we can accomplish the same with a rule:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="ot">{-# NOINLINE plusZeroNeutral #-}</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2"></a>
<a class="sourceLine" id="cb13-3" data-line-number="3"><span class="ot">{-# RULES</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4"><span class="ot">&quot;plusZeroNeutral&quot; forall x. plusZeroNeutral x </span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5"><span class="ot">  = unsafeCoerce (Refl :: &#39;Z :~: &#39;Z)</span></a>
<a class="sourceLine" id="cb13-6" data-line-number="6"><span class="ot"> #-}</span></a></code></pre></div>
<p>This basically says ‚Äúif this type-checks, then the proof must exist, and therefore the proof must be valid. So don‚Äôt bother running it‚Äù. Unfortunately, that‚Äôs a <em>little bit</em> of a lie. It‚Äôs pretty easy to write a proof which type-checks that <em>isn‚Äôt</em> valid:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="ot">falseIsTrue ::</span> <span class="dt">False</span> <span class="fu">:~:</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2">falseIsTrue <span class="fu">=</span> falseIsTrue</a></code></pre></div>
<p>We won‚Äôt be able to perform computations which rely on this proof in Haskell, though: because the computation will never terminate, the proof will never provide an answer. This means that, while the proof isn‚Äôt valid, it <em>is</em> type safe. That is, of course, unless we use our manual proof-erasure technique. The <code class="sourceCode haskell"><span class="dt">RULES</span></code> pragma will happily replace it with the <code class="sourceCode haskell">unsafeCoerce</code> version, effectively introducing unsoundness into our proofs. The reason that this doesn‚Äôt cause a problem for language like Idris is that Idris has a totality checker: you <em>can‚Äôt</em> write the above definition (with the totality checker turned on) in Idris.</p>
<p>So what‚Äôs the solution? Do we have to suffer through the slower proof code to maintain correctness? In reality, it‚Äôs usually OK to assume termination. It‚Äôs pretty easy to see that a proof like <code class="sourceCode haskell">plusZeroNeutral</code> is total. It‚Äôs worth bearing in mind, though, that until Haskell gets a totality checker (<a href="https://typesandkinds.wordpress.com/2016/07/24/dependent-types-in-haskell-progress-report/">likely never</a>, apparently) these proofs aren‚Äôt ‚Äúproper‚Äù.</p>
<h3 id="generating-singletons">Generating Singletons</h3>
<p>One extra thing: while you‚Äôre proving things in one area of your code, you might not have the relevant singleton handy. To generate them on-demand, you‚Äôll need a typeclass:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="kw">class</span> <span class="dt">KnownSing</span> (<span class="ot">x ::</span> k) <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2"><span class="ot">    sing ::</span> <span class="dt">The</span> k x</a>
<a class="sourceLine" id="cb15-3" data-line-number="3"></a>
<a class="sourceLine" id="cb15-4" data-line-number="4"><span class="kw">instance</span> <span class="dt">KnownSing</span> <span class="dt">Z</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-5" data-line-number="5">    sing <span class="fu">=</span> <span class="dt">Zy</span></a>
<a class="sourceLine" id="cb15-6" data-line-number="6"></a>
<a class="sourceLine" id="cb15-7" data-line-number="7"><span class="kw">instance</span> <span class="dt">KnownSing</span> n <span class="ot">=&gt;</span> <span class="dt">KnownSing</span> (<span class="dt">S</span> n) <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-8" data-line-number="8">    sing <span class="fu">=</span> <span class="dt">Sy</span> sing</a></code></pre></div>
<p>This kind of drives home the inefficiency of singleton-based proofs, and why it‚Äôs important to erase them aggressively.</p>
<h3 id="proofs-bundled-with-the-data-structure">Proofs Bundled with the Data Structure</h3>
<p>One other way to solve these problems is to try find a data structure which runs the proof code anyway. As an example, consider a length-indexed list:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:-</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2"><span class="kw">data</span> <span class="dt">List</span> n a <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3">    <span class="dt">Nil</span><span class="ot"> ::</span> <span class="dt">List</span> <span class="dt">Z</span> a</a>
<a class="sourceLine" id="cb16-4" data-line-number="4"><span class="ot">    (:-) ::</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> n a <span class="ot">-&gt;</span> <span class="dt">List</span> (<span class="dt">S</span> n) a</a></code></pre></div>
<p>You might worry that concatenation of two lists requires some expensive proof code, like <code class="sourceCode haskell">merge</code> for the pairing heap. Maybe surprisingly, the default implementation just works:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">++</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2"><span class="ot">(++) ::</span> <span class="dt">List</span> n a <span class="ot">-&gt;</span> <span class="dt">List</span> m a <span class="ot">-&gt;</span> <span class="dt">List</span> (<span class="dt">Plus</span> n m) a</a>
<a class="sourceLine" id="cb17-3" data-line-number="3">(<span class="fu">++</span>) <span class="dt">Nil</span> ys <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb17-4" data-line-number="4">(<span class="fu">++</span>) (x <span class="fu">:-</span> xs) ys <span class="fu">=</span> x <span class="fu">:-</span> xs <span class="fu">++</span> ys</a></code></pre></div>
<p>Why? Well, if you look back to the definition of <code class="sourceCode haskell"><span class="dt">Plus</span></code>, it‚Äôs almost exactly the same as the definition of <code class="sourceCode haskell">(<span class="fu">++</span>)</code>. In effect, we‚Äôre using <em>lists</em> as the singleton for <code class="sourceCode haskell"><span class="dt">Peano</span></code> here.</p>
<p>The question is, then: is there a heap which performs these proofs automatically for functions like merge? As far as I can tell: <em>almost</em>. First though:</p>
<h3 id="small-digression-manipulating-and-using-the-length-indexed-list">Small Digression: Manipulating and Using the Length-Indexed List</h3>
<p>The standard definition of <code class="sourceCode haskell"><span class="fu">++</span></code> on normal lists can be cleaned up a little with <code class="sourceCode haskell">foldr</code></p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="ot">(++) ::</span> [a] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">(<span class="fu">++</span>) <span class="fu">=</span> flip (foldr (<span class="fu">:</span>))</a></code></pre></div>
<p>Can we get a similar definition for our length-indexed lists? Turns out we can, but the type of <code class="sourceCode haskell">foldr</code> needs to be a little different:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="ot">foldrList ::</span> (forall x<span class="fu">.</span> a <span class="ot">-&gt;</span> b x <span class="ot">-&gt;</span> b (<span class="dt">S</span> x)) </a>
<a class="sourceLine" id="cb19-2" data-line-number="2">          <span class="ot">-&gt;</span> b m <span class="ot">-&gt;</span> <span class="dt">List</span> n a <span class="ot">-&gt;</span> b (n <span class="fu">+</span> m)</a>
<a class="sourceLine" id="cb19-3" data-line-number="3">foldrList f b <span class="dt">Nil</span> <span class="fu">=</span> b</a>
<a class="sourceLine" id="cb19-4" data-line-number="4">foldrList f b (x <span class="fu">:-</span> xs) <span class="fu">=</span> f x (foldrList f b xs)</a>
<a class="sourceLine" id="cb19-5" data-line-number="5"></a>
<a class="sourceLine" id="cb19-6" data-line-number="6"><span class="kw">newtype</span> <span class="dt">Flip</span> (<span class="ot">f ::</span> t <span class="ot">-&gt;</span> u <span class="ot">-&gt;</span> <span class="dt">Type</span>) (<span class="ot">a ::</span> u) (<span class="ot">b ::</span> t) </a>
<a class="sourceLine" id="cb19-7" data-line-number="7">    <span class="fu">=</span> <span class="dt">Flip</span> {<span class="ot"> unFlip ::</span> f b a }</a>
<a class="sourceLine" id="cb19-8" data-line-number="8"></a>
<a class="sourceLine" id="cb19-9" data-line-number="9"><span class="ot">foldrList1 ::</span> (forall x<span class="fu">.</span> a <span class="ot">-&gt;</span> b x c <span class="ot">-&gt;</span> b (<span class="dt">S</span> x) c) </a>
<a class="sourceLine" id="cb19-10" data-line-number="10">           <span class="ot">-&gt;</span> b m c <span class="ot">-&gt;</span> <span class="dt">List</span> n a <span class="ot">-&gt;</span> b (n <span class="fu">+</span> m) c</a>
<a class="sourceLine" id="cb19-11" data-line-number="11">foldrList1 f b </a>
<a class="sourceLine" id="cb19-12" data-line-number="12">    <span class="fu">=</span> unFlip <span class="fu">.</span> foldrList (\e <span class="ot">-&gt;</span> <span class="dt">Flip</span> <span class="fu">.</span> f e <span class="fu">.</span> unFlip) (<span class="dt">Flip</span> b)</a>
<a class="sourceLine" id="cb19-13" data-line-number="13"></a>
<a class="sourceLine" id="cb19-14" data-line-number="14"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">++</span></a>
<a class="sourceLine" id="cb19-15" data-line-number="15"><span class="ot">(++) ::</span> <span class="dt">List</span> n a <span class="ot">-&gt;</span> <span class="dt">List</span> m a <span class="ot">-&gt;</span> <span class="dt">List</span> (n <span class="fu">+</span> m) a</a>
<a class="sourceLine" id="cb19-16" data-line-number="16">(<span class="fu">++</span>) <span class="fu">=</span> flip (foldrList1 (<span class="fu">:-</span>))</a></code></pre></div>
<p>So what‚Äôs the point of this more complicated version? Well, if this were normal Haskell, we might get some foldr-fusion or something (in reality we would probably use <a href="http://hackage.haskell.org/package/base-4.9.1.0/docs/GHC-Exts.html#v:augment"><code class="sourceCode haskell">augment</code></a> if that were the purpose).</p>
<p>With this type-level business, though, there‚Äôs a similar application: loop unrolling. Consider the natural-number type again. We can write a typeclass which will perform induction over them:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="kw">class</span> <span class="dt">KnownPeano</span> (<span class="ot">n ::</span> <span class="dt">Peano</span>)  <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2"><span class="ot">    unrollRepeat ::</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb20-3" data-line-number="3"></a>
<a class="sourceLine" id="cb20-4" data-line-number="4"><span class="kw">instance</span> <span class="dt">KnownPeano</span> <span class="dt">Z</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-5" data-line-number="5">    unrollRepeat _ <span class="fu">=</span> const id</a>
<a class="sourceLine" id="cb20-6" data-line-number="6">    <span class="ot">{-# INLINE unrollRepeat #-}</span></a>
<a class="sourceLine" id="cb20-7" data-line-number="7"></a>
<a class="sourceLine" id="cb20-8" data-line-number="8"><span class="kw">instance</span> <span class="dt">KnownPeano</span> n <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb20-9" data-line-number="9">         <span class="dt">KnownPeano</span> (<span class="dt">S</span> n) <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-10" data-line-number="10">    unrollRepeat (<span class="ot">_ ::</span> <span class="dt">Proxy</span> (<span class="dt">S</span> n)) f x <span class="fu">=</span></a>
<a class="sourceLine" id="cb20-11" data-line-number="11">        f (unrollRepeat (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> n) f x)</a>
<a class="sourceLine" id="cb20-12" data-line-number="12">    <span class="ot">{-# INLINE unrollRepeat #-}</span></a></code></pre></div>
<p>Because the recursion here calls a different <code class="sourceCode haskell">unrollRepeat</code> function in the ‚Äúrecursive‚Äù call, we get around the <a href="http://stackoverflow.com/questions/42179783/is-there-any-way-to-inline-a-recursive-function">usual hurdle</a> of not being able to inline recursive calls. That means that the whole loop will be unrolled, at compile-time. We can do the same for foldr:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="kw">class</span> <span class="dt">HasFoldr</span> (<span class="ot">n ::</span> <span class="dt">Peano</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-2" data-line-number="2">    unrollFoldr </a>
<a class="sourceLine" id="cb21-3" data-line-number="3"><span class="ot">        ::</span> (forall x<span class="fu">.</span> a <span class="ot">-&gt;</span> b x <span class="ot">-&gt;</span> b (<span class="dt">S</span> x)) </a>
<a class="sourceLine" id="cb21-4" data-line-number="4">        <span class="ot">-&gt;</span> b m </a>
<a class="sourceLine" id="cb21-5" data-line-number="5">        <span class="ot">-&gt;</span> <span class="dt">List</span> n a </a>
<a class="sourceLine" id="cb21-6" data-line-number="6">        <span class="ot">-&gt;</span> b (n <span class="fu">+</span> m)</a>
<a class="sourceLine" id="cb21-7" data-line-number="7">  </a>
<a class="sourceLine" id="cb21-8" data-line-number="8"><span class="kw">instance</span> <span class="dt">HasFoldr</span> <span class="dt">Z</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-9" data-line-number="9">    unrollFoldr _ b _ <span class="fu">=</span> b</a>
<a class="sourceLine" id="cb21-10" data-line-number="10">    <span class="ot">{-# INLINE unrollFoldr #-}</span></a>
<a class="sourceLine" id="cb21-11" data-line-number="11"></a>
<a class="sourceLine" id="cb21-12" data-line-number="12"><span class="kw">instance</span> <span class="dt">HasFoldr</span> n <span class="ot">=&gt;</span> <span class="dt">HasFoldr</span> (<span class="dt">S</span> n) <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-13" data-line-number="13">    unrollFoldr f b (x <span class="fu">:-</span> xs) <span class="fu">=</span> f x (unrollFoldr f b xs)</a>
<a class="sourceLine" id="cb21-14" data-line-number="14">    <span class="ot">{-# INLINE unrollFoldr #-}</span></a></code></pre></div>
<p>I can‚Äôt think of many uses for this technique, but one that comes to mind is an n-ary uncurry (like Lisp‚Äôs <a href="https://en.wikipedia.org/wiki/Apply#Common_Lisp_and_Scheme">apply</a>):</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:-</span></a>
<a class="sourceLine" id="cb22-2" data-line-number="2"><span class="kw">data</span> <span class="dt">List</span> (<span class="ot">xs ::</span> [<span class="fu">*</span>]) <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-3" data-line-number="3">        <span class="dt">Nil</span><span class="ot"> ::</span> <span class="dt">List</span> <span class="ch">&#39;[]</span></a>
<a class="sourceLine" id="cb22-4" data-line-number="4"><span class="ot">        (:-) ::</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> xs <span class="ot">-&gt;</span> <span class="dt">List</span> (a <span class="ch">&#39;: xs)</span></a>
<a class="sourceLine" id="cb22-5" data-line-number="5"></a>
<a class="sourceLine" id="cb22-6" data-line-number="6"><span class="kw">class</span> <span class="dt">KnownList</span> (<span class="ot">xs ::</span> [<span class="fu">*</span>])  <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-7" data-line-number="7">    foldrT</a>
<a class="sourceLine" id="cb22-8" data-line-number="8"><span class="ot">        ::</span> (forall y ys<span class="fu">.</span> y <span class="ot">-&gt;</span> result ys <span class="ot">-&gt;</span> result (y <span class="ch">&#39;: ys))</span></a>
<a class="sourceLine" id="cb22-9" data-line-number="9">        <span class="ot">-&gt;</span> result <span class="ch">&#39;[]</span></a>
<a class="sourceLine" id="cb22-10" data-line-number="10">        <span class="ot">-&gt;</span> <span class="dt">List</span> xs</a>
<a class="sourceLine" id="cb22-11" data-line-number="11">        <span class="ot">-&gt;</span> result xs</a>
<a class="sourceLine" id="cb22-12" data-line-number="12"></a>
<a class="sourceLine" id="cb22-13" data-line-number="13"><span class="kw">instance</span> <span class="dt">KnownList</span> (<span class="ch">&#39;[] :: [*]) where</span></a>
<a class="sourceLine" id="cb22-14" data-line-number="14">    foldrT _ <span class="fu">=</span> const</a>
<a class="sourceLine" id="cb22-15" data-line-number="15">    <span class="ot">{-# INLINE foldrT #-}</span></a>
<a class="sourceLine" id="cb22-16" data-line-number="16"></a>
<a class="sourceLine" id="cb22-17" data-line-number="17"><span class="kw">instance</span> <span class="dt">KnownList</span> xs <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb22-18" data-line-number="18">         <span class="dt">KnownList</span> (x <span class="ch">&#39;: xs) where</span></a>
<a class="sourceLine" id="cb22-19" data-line-number="19">    foldrT f b (x <span class="fu">:-</span> xs) <span class="fu">=</span> f x (foldrT f b xs)</a>
<a class="sourceLine" id="cb22-20" data-line-number="20">    <span class="ot">{-# INLINE foldrT #-}</span></a>
<a class="sourceLine" id="cb22-21" data-line-number="21"></a>
<a class="sourceLine" id="cb22-22" data-line-number="22"><span class="kw">type</span> family <span class="dt">Func</span> (<span class="ot">xs ::</span> [<span class="fu">*</span>]) (<span class="ot">y ::</span> <span class="fu">*</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-23" data-line-number="23">        <span class="dt">Func</span> <span class="ch">&#39;[] y = y</span></a>
<a class="sourceLine" id="cb22-24" data-line-number="24">        <span class="dt">Func</span> (x <span class="ch">&#39;: xs) y = x -&gt; Func xs y</span></a>
<a class="sourceLine" id="cb22-25" data-line-number="25"></a>
<a class="sourceLine" id="cb22-26" data-line-number="26"><span class="kw">newtype</span> <span class="dt">FunType</span> y xs <span class="fu">=</span> <span class="dt">FunType</span></a>
<a class="sourceLine" id="cb22-27" data-line-number="27">    {<span class="ot"> runFun ::</span> <span class="dt">Func</span> xs y <span class="ot">-&gt;</span> y</a>
<a class="sourceLine" id="cb22-28" data-line-number="28">    }</a>
<a class="sourceLine" id="cb22-29" data-line-number="29"></a>
<a class="sourceLine" id="cb22-30" data-line-number="30">uncurry</a>
<a class="sourceLine" id="cb22-31" data-line-number="31"><span class="ot">    ::</span> <span class="dt">KnownList</span> xs</a>
<a class="sourceLine" id="cb22-32" data-line-number="32">    <span class="ot">=&gt;</span> <span class="dt">Func</span> xs y <span class="ot">-&gt;</span> <span class="dt">List</span> xs <span class="ot">-&gt;</span> y</a>
<a class="sourceLine" id="cb22-33" data-line-number="33">uncurry f l <span class="fu">=</span></a>
<a class="sourceLine" id="cb22-34" data-line-number="34">    runFun</a>
<a class="sourceLine" id="cb22-35" data-line-number="35">        (foldrT</a>
<a class="sourceLine" id="cb22-36" data-line-number="36">             (c (\x g h <span class="ot">-&gt;</span> g (h x)))</a>
<a class="sourceLine" id="cb22-37" data-line-number="37">             (<span class="dt">FunType</span> id)</a>
<a class="sourceLine" id="cb22-38" data-line-number="38">             l)</a>
<a class="sourceLine" id="cb22-39" data-line-number="39">        f</a>
<a class="sourceLine" id="cb22-40" data-line-number="40">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-41" data-line-number="41"><span class="ot">    c ::</span> (a <span class="ot">-&gt;</span> ((<span class="dt">Func</span> xs y <span class="ot">-&gt;</span> y) <span class="ot">-&gt;</span> (<span class="dt">Func</span> zs z <span class="ot">-&gt;</span> z)))</a>
<a class="sourceLine" id="cb22-42" data-line-number="42">      <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> (<span class="dt">FunType</span> y xs <span class="ot">-&gt;</span> <span class="dt">FunType</span> z zs))</a>
<a class="sourceLine" id="cb22-43" data-line-number="43">    c <span class="fu">=</span> coerce</a>
<a class="sourceLine" id="cb22-44" data-line-number="44">    <span class="ot">{-# INLINE c #-}</span></a>
<a class="sourceLine" id="cb22-45" data-line-number="45"><span class="ot">{-# INLINE uncurry #-}</span></a></code></pre></div>
<p>I <em>think</em> that you can be guaranteed the above is inlined at compile-time, making it essentially equivalent to a handwritten <code class="sourceCode haskell">uncurry</code>.</p>
<h3 id="binomial-heaps">Binomial Heaps</h3>
<p>Anyway, back to the size-indexed heaps. The reason that <code class="sourceCode haskell">(<span class="fu">++</span>)</code> worked so easily on lists is that a list can be thought of as the data-structure equivalent to Peano numbers. Another numeric-system-based data structure is the binomial heap, which is based on binary numbering <span class="citation" data-cites="hinze_functional_1999">(I‚Äôm going mainly off of the description from Hinze <a href="#ref-hinze_functional_1999">1999</a>)</span>.</p>
<p>So, to work with binary numbers, let‚Äôs get some preliminaries on the type-level out of the way:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="kw">data</span> <span class="kw">instance</span> <span class="dt">The</span> <span class="dt">Bool</span> x <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-2" data-line-number="2">    <span class="dt">Falsy</span><span class="ot"> ::</span> <span class="dt">The</span> <span class="dt">Bool</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb23-3" data-line-number="3">    <span class="dt">Truey</span><span class="ot"> ::</span> <span class="dt">The</span> <span class="dt">Bool</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb23-4" data-line-number="4"></a>
<a class="sourceLine" id="cb23-5" data-line-number="5"><span class="kw">data</span> <span class="kw">instance</span> <span class="dt">The</span> [k] xs <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-6" data-line-number="6">    <span class="dt">Nily</span><span class="ot"> ::</span> <span class="dt">The</span> [k] <span class="ch">&#39;[]</span></a>
<a class="sourceLine" id="cb23-7" data-line-number="7">    <span class="dt">Cony</span><span class="ot"> ::</span> <span class="dt">The</span> k x <span class="ot">-&gt;</span> <span class="dt">The</span> [k] xs <span class="ot">-&gt;</span> <span class="dt">The</span> [k] (x <span class="fu">:</span> xs)</a>
<a class="sourceLine" id="cb23-8" data-line-number="8"></a>
<a class="sourceLine" id="cb23-9" data-line-number="9"><span class="kw">instance</span> <span class="dt">KnownSing</span> <span class="dt">True</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-10" data-line-number="10">    sing <span class="fu">=</span> <span class="dt">Truey</span></a>
<a class="sourceLine" id="cb23-11" data-line-number="11"></a>
<a class="sourceLine" id="cb23-12" data-line-number="12"><span class="kw">instance</span> <span class="dt">KnownSing</span> <span class="dt">False</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-13" data-line-number="13">    sing <span class="fu">=</span> <span class="dt">Falsy</span></a>
<a class="sourceLine" id="cb23-14" data-line-number="14"></a>
<a class="sourceLine" id="cb23-15" data-line-number="15"><span class="kw">instance</span> <span class="dt">KnownSing</span> <span class="ch">&#39;[] where</span></a>
<a class="sourceLine" id="cb23-16" data-line-number="16">    sing <span class="fu">=</span> <span class="dt">Nily</span></a>
<a class="sourceLine" id="cb23-17" data-line-number="17"></a>
<a class="sourceLine" id="cb23-18" data-line-number="18"><span class="kw">instance</span> (<span class="dt">KnownSing</span> xs, <span class="dt">KnownSing</span> x) <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb23-19" data-line-number="19">         <span class="dt">KnownSing</span> (x <span class="fu">:</span> xs) <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-20" data-line-number="20">    sing <span class="fu">=</span> <span class="dt">Cony</span> sing sing</a></code></pre></div>
<p>We‚Äôll represent a binary number as a list of Booleans:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">Sum</span> (<span class="ot">x ::</span> <span class="dt">Bool</span>) (<span class="ot">y ::</span> <span class="dt">Bool</span>) (<span class="ot">cin ::</span> <span class="dt">Bool</span>)<span class="ot"> ::</span> <span class="dt">Bool</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-2" data-line-number="2">        <span class="dt">Sum</span> <span class="dt">False</span> <span class="dt">False</span> <span class="dt">False</span> <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb24-3" data-line-number="3">        <span class="dt">Sum</span> <span class="dt">False</span> <span class="dt">False</span> <span class="dt">True</span>  <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb24-4" data-line-number="4">        <span class="dt">Sum</span> <span class="dt">False</span> <span class="dt">True</span>  <span class="dt">False</span> <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb24-5" data-line-number="5">        <span class="dt">Sum</span> <span class="dt">False</span> <span class="dt">True</span>  <span class="dt">True</span>  <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb24-6" data-line-number="6">        <span class="dt">Sum</span> <span class="dt">True</span>  <span class="dt">False</span> <span class="dt">False</span> <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb24-7" data-line-number="7">        <span class="dt">Sum</span> <span class="dt">True</span>  <span class="dt">False</span> <span class="dt">True</span>  <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb24-8" data-line-number="8">        <span class="dt">Sum</span> <span class="dt">True</span>  <span class="dt">True</span>  <span class="dt">False</span> <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb24-9" data-line-number="9">        <span class="dt">Sum</span> <span class="dt">True</span>  <span class="dt">True</span>  <span class="dt">True</span>  <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb24-10" data-line-number="10"></a>
<a class="sourceLine" id="cb24-11" data-line-number="11"><span class="kw">type</span> family <span class="dt">Carry</span> (<span class="ot">x ::</span> <span class="dt">Bool</span>) (<span class="ot">y ::</span> <span class="dt">Bool</span>) (<span class="ot">cin ::</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb24-12" data-line-number="12">     (<span class="ot">xs ::</span> [<span class="dt">Bool</span>]) (<span class="ot">ys ::</span> [<span class="dt">Bool</span>])<span class="ot"> ::</span> [<span class="dt">Bool</span>] <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-13" data-line-number="13">        <span class="dt">Carry</span> <span class="dt">False</span> <span class="dt">False</span> <span class="dt">False</span> xs ys <span class="fu">=</span> <span class="dt">Add</span> <span class="dt">False</span> xs ys</a>
<a class="sourceLine" id="cb24-14" data-line-number="14">        <span class="dt">Carry</span> <span class="dt">False</span> <span class="dt">False</span> <span class="dt">True</span>  xs ys <span class="fu">=</span> <span class="dt">Add</span> <span class="dt">False</span> xs ys</a>
<a class="sourceLine" id="cb24-15" data-line-number="15">        <span class="dt">Carry</span> <span class="dt">False</span> <span class="dt">True</span>  <span class="dt">False</span> xs ys <span class="fu">=</span> <span class="dt">Add</span> <span class="dt">False</span> xs ys</a>
<a class="sourceLine" id="cb24-16" data-line-number="16">        <span class="dt">Carry</span> <span class="dt">False</span> <span class="dt">True</span>  <span class="dt">True</span>  xs ys <span class="fu">=</span> <span class="dt">Add</span> <span class="dt">True</span>  xs ys</a>
<a class="sourceLine" id="cb24-17" data-line-number="17">        <span class="dt">Carry</span> <span class="dt">True</span>  <span class="dt">False</span> <span class="dt">False</span> xs ys <span class="fu">=</span> <span class="dt">Add</span> <span class="dt">False</span> xs ys</a>
<a class="sourceLine" id="cb24-18" data-line-number="18">        <span class="dt">Carry</span> <span class="dt">True</span>  <span class="dt">False</span> <span class="dt">True</span>  xs ys <span class="fu">=</span> <span class="dt">Add</span> <span class="dt">True</span>  xs ys</a>
<a class="sourceLine" id="cb24-19" data-line-number="19">        <span class="dt">Carry</span> <span class="dt">True</span>  <span class="dt">True</span>  <span class="dt">False</span> xs ys <span class="fu">=</span> <span class="dt">Add</span> <span class="dt">True</span>  xs ys</a>
<a class="sourceLine" id="cb24-20" data-line-number="20">        <span class="dt">Carry</span> <span class="dt">True</span>  <span class="dt">True</span>  <span class="dt">True</span>  xs ys <span class="fu">=</span> <span class="dt">Add</span> <span class="dt">True</span>  xs ys</a>
<a class="sourceLine" id="cb24-21" data-line-number="21"></a>
<a class="sourceLine" id="cb24-22" data-line-number="22"><span class="kw">type</span> family <span class="dt">Add</span> (<span class="ot">cin ::</span> <span class="dt">Bool</span>) (<span class="ot">xs ::</span> [<span class="dt">Bool</span>]) (<span class="ot">ys ::</span> [<span class="dt">Bool</span>]) <span class="ot">::</span></a>
<a class="sourceLine" id="cb24-23" data-line-number="23">     [<span class="dt">Bool</span>] <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-24" data-line-number="24">        <span class="dt">Add</span> c (x <span class="fu">:</span> xs) (y <span class="fu">:</span> ys) <span class="fu">=</span> <span class="dt">Sum</span> x y c <span class="fu">:</span> <span class="dt">Carry</span> x y c xs ys</a>
<a class="sourceLine" id="cb24-25" data-line-number="25">        <span class="dt">Add</span> <span class="dt">False</span> <span class="ch">&#39;[] ys = ys</span></a>
<a class="sourceLine" id="cb24-26" data-line-number="26">        <span class="dt">Add</span> <span class="dt">False</span> xs <span class="ch">&#39;[] = xs</span></a>
<a class="sourceLine" id="cb24-27" data-line-number="27">        <span class="dt">Add</span> <span class="dt">True</span>  <span class="ch">&#39;[] ys = CarryOne ys</span></a>
<a class="sourceLine" id="cb24-28" data-line-number="28">        <span class="dt">Add</span> <span class="dt">True</span>  xs <span class="ch">&#39;[] = CarryOne xs</span></a>
<a class="sourceLine" id="cb24-29" data-line-number="29"></a>
<a class="sourceLine" id="cb24-30" data-line-number="30"><span class="kw">type</span> family <span class="dt">CarryOne</span> (<span class="ot">xs ::</span> [<span class="dt">Bool</span>])<span class="ot"> ::</span> [<span class="dt">Bool</span>] <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-31" data-line-number="31">        <span class="dt">CarryOne</span> <span class="ch">&#39;[] = True : &#39;</span>[]</a>
<a class="sourceLine" id="cb24-32" data-line-number="32">        <span class="dt">CarryOne</span> (<span class="dt">False</span> <span class="fu">:</span> xs) <span class="fu">=</span> <span class="dt">True</span> <span class="fu">:</span> xs</a>
<a class="sourceLine" id="cb24-33" data-line-number="33">        <span class="dt">CarryOne</span> (<span class="dt">True</span>  <span class="fu">:</span> xs) <span class="fu">=</span> <span class="dt">False</span> <span class="fu">:</span> <span class="dt">CarryOne</span> xs</a></code></pre></div>
<p>The odd definition of <code class="sourceCode haskell"><span class="dt">Carry</span></code> is to avoid <code class="sourceCode haskell"><span class="dt">UndecidableInstances</span></code>: if we had written, instead:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">Carry</span> (<span class="ot">x ::</span> <span class="dt">Bool</span>) (<span class="ot">y ::</span> <span class="dt">Bool</span>) (<span class="ot">cin ::</span> <span class="dt">Bool</span>)<span class="ot"> ::</span> <span class="dt">Bool</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-2" data-line-number="2">        <span class="dt">Carry</span> <span class="dt">False</span> <span class="dt">False</span> <span class="dt">False</span> <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb25-3" data-line-number="3">        <span class="dt">Carry</span> <span class="dt">False</span> <span class="dt">False</span> <span class="dt">True</span>  <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb25-4" data-line-number="4">        <span class="dt">Carry</span> <span class="dt">False</span> <span class="dt">True</span>  <span class="dt">False</span> <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb25-5" data-line-number="5">        <span class="dt">Carry</span> <span class="dt">False</span> <span class="dt">True</span>  <span class="dt">True</span>  <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb25-6" data-line-number="6">        <span class="dt">Carry</span> <span class="dt">True</span>  <span class="dt">False</span> <span class="dt">False</span> <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb25-7" data-line-number="7">        <span class="dt">Carry</span> <span class="dt">True</span>  <span class="dt">False</span> <span class="dt">True</span>  <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb25-8" data-line-number="8">        <span class="dt">Carry</span> <span class="dt">True</span>  <span class="dt">True</span>  <span class="dt">False</span> <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb25-9" data-line-number="9">        <span class="dt">Carry</span> <span class="dt">True</span>  <span class="dt">True</span>  <span class="dt">True</span>  <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb25-10" data-line-number="10"></a>
<a class="sourceLine" id="cb25-11" data-line-number="11"><span class="kw">type</span> family <span class="dt">Add</span> (<span class="ot">cin ::</span> <span class="dt">Bool</span>) (<span class="ot">xs ::</span> [<span class="dt">Bool</span>]) (<span class="ot">ys ::</span> [<span class="dt">Bool</span>]) <span class="ot">::</span></a>
<a class="sourceLine" id="cb25-12" data-line-number="12">     [<span class="dt">Bool</span>] <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-13" data-line-number="13">        <span class="dt">Add</span> c (x <span class="fu">:</span> xs) (y <span class="fu">:</span> ys) <span class="fu">=</span> <span class="dt">Sum</span> x y c <span class="fu">:</span> <span class="dt">Add</span> (<span class="dt">Carry</span> x y c) xs ys</a>
<a class="sourceLine" id="cb25-14" data-line-number="14">        <span class="dt">Add</span> <span class="dt">False</span> <span class="ch">&#39;[] ys = ys</span></a>
<a class="sourceLine" id="cb25-15" data-line-number="15">        <span class="dt">Add</span> <span class="dt">False</span> xs <span class="ch">&#39;[] = xs</span></a>
<a class="sourceLine" id="cb25-16" data-line-number="16">        <span class="dt">Add</span> <span class="dt">True</span>  <span class="ch">&#39;[] ys = CarryOne ys</span></a>
<a class="sourceLine" id="cb25-17" data-line-number="17">        <span class="dt">Add</span> <span class="dt">True</span>  xs <span class="ch">&#39;[] = CarryOne xs</span></a></code></pre></div>
<p>We would have been warned about nested type-family application.</p>
<p>Now we can base the merge function very closely on these type families. First, though, we‚Äôll have to implement the heap.</p>
<h3 id="almost-verified-data-structures">Almost-Verified Data Structures</h3>
<p>There are different potential properties you can verify in a data structure. In the sort-traversable post, the property of interest was that the number of elements in the structure would stay the same after adding and removing some number <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> of elements. For this post, we‚Äôll also verify structural invariants. I won‚Äôt, however, verify the <a href="https://www.cs.cmu.edu/~adamchik/15-121/lectures/Binary%20Heaps/heaps.html">heap property</a>. Maybe in a later post.</p>
<p>When indexing a data structure by its size, you encode an awful lot of information into the type signature: the type becomes very <em>specific</em> to the structure in question. It is possible, though, to encode a fair few structural invariants <em>without</em> getting so specific. Here‚Äôs a signature for ‚Äúperfect leaf tree‚Äù:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="kw">data</span> <span class="dt">BalTree</span> a <span class="fu">=</span> <span class="dt">Leaf</span> a <span class="fu">|</span> <span class="dt">Node</span> (<span class="dt">BalTree</span> (a,a))</a></code></pre></div>
<p>With that signature, it‚Äôs <em>impossible</em> to create a tree with more elements in its left branch than its right; the size of the tree, however, remains unspecified. You can use a similar trick to implement <a href="https://github.com/oisdk/Square">matrices which must be square</a> <span class="citation" data-cites="okasaki_fast_1999">(from Okasaki <a href="#ref-okasaki_fast_1999">1999</a>)</span>: the usual trick (<code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Matrix</span> n a <span class="fu">=</span> <span class="dt">List</span> n (<span class="dt">List</span> n a)</code>) is too specific, providing size information at compile-time. If you‚Äôre interested in this approach, there are several more examples in <span class="citation" data-cites="hinze_manufacturing_2001">Hinze (<a href="#ref-hinze_manufacturing_2001">2001</a>)</span>.</p>
<p>It is possible to go from the size-indexed version back to the non-indexed version, with an existential (<code class="sourceCode haskell"><span class="dt">RankNTypes</span></code> for this example):</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="kw">data</span> <span class="dt">ErasedSize</span> f a <span class="fu">=</span> forall (<span class="ot">n ::</span> <span class="dt">Peano</span>)<span class="fu">.</span> <span class="dt">ErasedSize</span></a>
<a class="sourceLine" id="cb27-2" data-line-number="2">    {<span class="ot"> runErasedSize ::</span> f n a</a>
<a class="sourceLine" id="cb27-3" data-line-number="3">    }</a></code></pre></div>
<p>This will let you prove invariants in your implementation using an index, while keeping the user-facing type signature general and non-indexed.</p>
<h3 id="a-fully-structurally-verified-binomial-heap">A Fully-Structurally-Verified Binomial Heap</h3>
<p><span class="citation" data-cites="wasserman_playing_2010">Wasserman (<a href="#ref-wasserman_playing_2010">2010</a>)</span>, was able to encode all of the structural invariants of the binomial heap <em>without</em> indexing by its size (well, all invariants except truncation, which turned out to be important a little later). I‚Äôll be using a similar approach, except I‚Äôll leverage some of the newer bells and whistles in GHC. Where Wasserman‚Äôs version used types like this for the numbering:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Zero</span> a <span class="fu">=</span> <span class="dt">Zero</span></a>
<a class="sourceLine" id="cb28-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Succ</span> rk a <span class="fu">=</span> <span class="dt">BinomTree</span> rk a <span class="fu">:&lt;</span> rk a</a>
<a class="sourceLine" id="cb28-3" data-line-number="3"><span class="kw">data</span> <span class="dt">BinomTree</span> rk a <span class="fu">=</span> <span class="dt">BinomTree</span> a (rk a)</a></code></pre></div>
<p>We can reuse the type-level Peano numbers with a GADT:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:-</span></a>
<a class="sourceLine" id="cb29-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Binomial</span> xs rk a <span class="kw">where</span></a>
<a class="sourceLine" id="cb29-3" data-line-number="3">       <span class="dt">Nil</span><span class="ot"> ::</span> <span class="dt">Binomial</span> <span class="ch">&#39;[] n a</span></a>
<a class="sourceLine" id="cb29-4" data-line-number="4">       <span class="dt">Skip</span><span class="ot"> ::</span> <span class="dt">Binomial</span> xs (<span class="dt">S</span> rk) a <span class="ot">-&gt;</span> <span class="dt">Binomial</span> (<span class="dt">False</span> <span class="fu">:</span> xs) rk a</a>
<a class="sourceLine" id="cb29-5" data-line-number="5"><span class="ot">       (:-) ::</span> <span class="dt">Tree</span> rk a </a>
<a class="sourceLine" id="cb29-6" data-line-number="6">            <span class="ot">-&gt;</span> <span class="dt">Binomial</span> xs (<span class="dt">S</span> rk) a </a>
<a class="sourceLine" id="cb29-7" data-line-number="7">            <span class="ot">-&gt;</span> <span class="dt">Binomial</span> (<span class="dt">True</span> <span class="fu">:</span> xs) rk a</a>
<a class="sourceLine" id="cb29-8" data-line-number="8"></a>
<a class="sourceLine" id="cb29-9" data-line-number="9"><span class="kw">data</span> <span class="dt">Tree</span> rk a <span class="fu">=</span> <span class="dt">Root</span> a (<span class="dt">Node</span> rk a)</a>
<a class="sourceLine" id="cb29-10" data-line-number="10"></a>
<a class="sourceLine" id="cb29-11" data-line-number="11"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:&lt;</span></a>
<a class="sourceLine" id="cb29-12" data-line-number="12"><span class="kw">data</span> <span class="dt">Node</span> n a <span class="kw">where</span></a>
<a class="sourceLine" id="cb29-13" data-line-number="13">       <span class="dt">NilN</span><span class="ot"> ::</span> <span class="dt">Node</span> <span class="dt">Z</span> a</a>
<a class="sourceLine" id="cb29-14" data-line-number="14"><span class="ot">       (:&lt;) ::</span> <span class="dt">Tree</span> n a <span class="ot">-&gt;</span> <span class="dt">Node</span> n a <span class="ot">-&gt;</span> <span class="dt">Node</span> (<span class="dt">S</span> n) a</a></code></pre></div>
<p>The definition of <code class="sourceCode haskell"><span class="dt">Tree</span></code> here ensures that any tree of rank <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> has <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mi>n</mi></msup><annotation encoding="application/x-tex">2^n</annotation></semantics></math> elements. The binomial heap, then, is a list of trees, in ascending order of size, with a <code class="sourceCode haskell"><span class="dt">True</span></code> at every point in its type-level list where a tree is present, and a <code class="sourceCode haskell"><span class="dt">False</span></code> wherever one is absent. In other words, the type-level list is a binary encoding of the number of elements it contains.</p>
<p>And here are the merge functions:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="ot">mergeTree ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Tree</span> rk a <span class="ot">-&gt;</span> <span class="dt">Tree</span> rk a <span class="ot">-&gt;</span> <span class="dt">Tree</span> (<span class="dt">S</span> rk) a</a>
<a class="sourceLine" id="cb30-2" data-line-number="2">mergeTree xr<span class="fu">@</span>(<span class="dt">Root</span> x xs) yr<span class="fu">@</span>(<span class="dt">Root</span> y ys)</a>
<a class="sourceLine" id="cb30-3" data-line-number="3">  <span class="fu">|</span> x <span class="fu">&lt;=</span> y    <span class="fu">=</span> <span class="dt">Root</span> x (yr <span class="fu">:&lt;</span> xs)</a>
<a class="sourceLine" id="cb30-4" data-line-number="4">  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Root</span> y (xr <span class="fu">:&lt;</span> ys)</a>
<a class="sourceLine" id="cb30-5" data-line-number="5"></a>
<a class="sourceLine" id="cb30-6" data-line-number="6">merge </a>
<a class="sourceLine" id="cb30-7" data-line-number="7"><span class="ot">    ::</span> <span class="dt">Ord</span> a </a>
<a class="sourceLine" id="cb30-8" data-line-number="8">    <span class="ot">=&gt;</span> <span class="dt">Binomial</span> xs z a </a>
<a class="sourceLine" id="cb30-9" data-line-number="9">    <span class="ot">-&gt;</span> <span class="dt">Binomial</span> ys z a </a>
<a class="sourceLine" id="cb30-10" data-line-number="10">    <span class="ot">-&gt;</span> <span class="dt">Binomial</span> (<span class="dt">Add</span> <span class="dt">False</span> xs ys) z a</a>
<a class="sourceLine" id="cb30-11" data-line-number="11">merge <span class="dt">Nil</span> ys              <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb30-12" data-line-number="12">merge xs <span class="dt">Nil</span>              <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb30-13" data-line-number="13">merge (<span class="dt">Skip</span> xs) (<span class="dt">Skip</span> ys) <span class="fu">=</span> <span class="dt">Skip</span> (merge xs ys)</a>
<a class="sourceLine" id="cb30-14" data-line-number="14">merge (<span class="dt">Skip</span> xs) (y <span class="fu">:-</span> ys) <span class="fu">=</span> y <span class="fu">:-</span> merge xs ys</a>
<a class="sourceLine" id="cb30-15" data-line-number="15">merge (x <span class="fu">:-</span> xs) (<span class="dt">Skip</span> ys) <span class="fu">=</span> x <span class="fu">:-</span> merge xs ys</a>
<a class="sourceLine" id="cb30-16" data-line-number="16">merge (x <span class="fu">:-</span> xs) (y <span class="fu">:-</span> ys) <span class="fu">=</span> <span class="dt">Skip</span> (mergeCarry (mergeTree x y) xs ys)</a>
<a class="sourceLine" id="cb30-17" data-line-number="17"></a>
<a class="sourceLine" id="cb30-18" data-line-number="18">mergeCarry</a>
<a class="sourceLine" id="cb30-19" data-line-number="19"><span class="ot">    ::</span> <span class="dt">Ord</span> a</a>
<a class="sourceLine" id="cb30-20" data-line-number="20">    <span class="ot">=&gt;</span> <span class="dt">Tree</span> rk a </a>
<a class="sourceLine" id="cb30-21" data-line-number="21">    <span class="ot">-&gt;</span> <span class="dt">Binomial</span> xs rk a </a>
<a class="sourceLine" id="cb30-22" data-line-number="22">    <span class="ot">-&gt;</span> <span class="dt">Binomial</span> ys rk a </a>
<a class="sourceLine" id="cb30-23" data-line-number="23">    <span class="ot">-&gt;</span> <span class="dt">Binomial</span> (<span class="dt">Add</span> <span class="dt">True</span> xs ys) rk a</a>
<a class="sourceLine" id="cb30-24" data-line-number="24">mergeCarry t <span class="dt">Nil</span> ys              <span class="fu">=</span> carryOne t ys</a>
<a class="sourceLine" id="cb30-25" data-line-number="25">mergeCarry t xs <span class="dt">Nil</span>              <span class="fu">=</span> carryOne t xs</a>
<a class="sourceLine" id="cb30-26" data-line-number="26">mergeCarry t (<span class="dt">Skip</span> xs) (<span class="dt">Skip</span> ys) <span class="fu">=</span> t <span class="fu">:-</span> merge xs ys</a>
<a class="sourceLine" id="cb30-27" data-line-number="27">mergeCarry t (<span class="dt">Skip</span> xs) (y <span class="fu">:-</span> ys) <span class="fu">=</span> <span class="dt">Skip</span> (mergeCarry (mergeTree t y) xs ys)</a>
<a class="sourceLine" id="cb30-28" data-line-number="28">mergeCarry t (x <span class="fu">:-</span> xs) (<span class="dt">Skip</span> ys) <span class="fu">=</span> <span class="dt">Skip</span> (mergeCarry (mergeTree t x) xs ys)</a>
<a class="sourceLine" id="cb30-29" data-line-number="29">mergeCarry t (x <span class="fu">:-</span> xs) (y <span class="fu">:-</span> ys) <span class="fu">=</span> t <span class="fu">:-</span> mergeCarry (mergeTree x y) xs ys</a>
<a class="sourceLine" id="cb30-30" data-line-number="30"></a>
<a class="sourceLine" id="cb30-31" data-line-number="31">carryOne </a>
<a class="sourceLine" id="cb30-32" data-line-number="32"><span class="ot">    ::</span> <span class="dt">Ord</span> a </a>
<a class="sourceLine" id="cb30-33" data-line-number="33">    <span class="ot">=&gt;</span> <span class="dt">Tree</span> rk a <span class="ot">-&gt;</span> <span class="dt">Binomial</span> xs rk a <span class="ot">-&gt;</span> <span class="dt">Binomial</span> (<span class="dt">CarryOne</span> xs) rk a</a>
<a class="sourceLine" id="cb30-34" data-line-number="34">carryOne t <span class="dt">Nil</span>       <span class="fu">=</span> t <span class="fu">:-</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb30-35" data-line-number="35">carryOne t (<span class="dt">Skip</span> xs) <span class="fu">=</span> t <span class="fu">:-</span> xs</a>
<a class="sourceLine" id="cb30-36" data-line-number="36">carryOne t (x <span class="fu">:-</span> xs) <span class="fu">=</span> <span class="dt">Skip</span> (carryOne (mergeTree t x) xs)</a></code></pre></div>
<p>You‚Äôll notice that no proofs are needed: that‚Äôs because the merge function itself is the same as the type family, like the way <code class="sourceCode haskell"><span class="fu">++</span></code> for lists was the same as the <code class="sourceCode haskell"><span class="dt">Plus</span></code> type family.</p>
<p>Of course, this structure is only verified insofar as you believe the type families. It does provide a degree of double-entry, though: any mistake in the type family will have to be mirrored in the merge function to type-check. On top of that, we can write some proofs of properties we might expect:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" data-line-number="1">addCommutes</a>
<a class="sourceLine" id="cb31-2" data-line-number="2"><span class="ot">  ::</span> <span class="dt">The</span> [<span class="dt">Bool</span>] xs</a>
<a class="sourceLine" id="cb31-3" data-line-number="3">  <span class="ot">-&gt;</span> <span class="dt">The</span> [<span class="dt">Bool</span>] ys</a>
<a class="sourceLine" id="cb31-4" data-line-number="4">  <span class="ot">-&gt;</span> <span class="dt">Add</span> <span class="dt">False</span> xs ys <span class="fu">:~:</span> <span class="dt">Add</span> <span class="dt">False</span> ys xs</a>
<a class="sourceLine" id="cb31-5" data-line-number="5">addCommutes <span class="dt">Nily</span> _ <span class="fu">=</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb31-6" data-line-number="6">addCommutes _ <span class="dt">Nily</span> <span class="fu">=</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb31-7" data-line-number="7">addCommutes (<span class="dt">Cony</span> <span class="dt">Falsy</span> xs) (<span class="dt">Cony</span> <span class="dt">Falsy</span> ys) <span class="fu">=</span></a>
<a class="sourceLine" id="cb31-8" data-line-number="8">    gcastWith (addCommutes xs ys) <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb31-9" data-line-number="9">addCommutes (<span class="dt">Cony</span> <span class="dt">Truey</span> xs) (<span class="dt">Cony</span> <span class="dt">Falsy</span> ys) <span class="fu">=</span></a>
<a class="sourceLine" id="cb31-10" data-line-number="10">    gcastWith (addCommutes xs ys) <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb31-11" data-line-number="11">addCommutes (<span class="dt">Cony</span> <span class="dt">Falsy</span> xs) (<span class="dt">Cony</span> <span class="dt">Truey</span> ys) <span class="fu">=</span></a>
<a class="sourceLine" id="cb31-12" data-line-number="12">    gcastWith (addCommutes xs ys) <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb31-13" data-line-number="13">addCommutes (<span class="dt">Cony</span> <span class="dt">Truey</span> xs) (<span class="dt">Cony</span> <span class="dt">Truey</span> ys) <span class="fu">=</span></a>
<a class="sourceLine" id="cb31-14" data-line-number="14">    gcastWith (addCommutesCarry xs ys) <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb31-15" data-line-number="15"></a>
<a class="sourceLine" id="cb31-16" data-line-number="16">addCommutesCarry</a>
<a class="sourceLine" id="cb31-17" data-line-number="17"><span class="ot">  ::</span> <span class="dt">The</span> [<span class="dt">Bool</span>] xs</a>
<a class="sourceLine" id="cb31-18" data-line-number="18">  <span class="ot">-&gt;</span> <span class="dt">The</span> [<span class="dt">Bool</span>] ys</a>
<a class="sourceLine" id="cb31-19" data-line-number="19">  <span class="ot">-&gt;</span> <span class="dt">Add</span> <span class="dt">True</span> xs ys <span class="fu">:~:</span> <span class="dt">Add</span> <span class="dt">True</span> ys xs</a>
<a class="sourceLine" id="cb31-20" data-line-number="20">addCommutesCarry <span class="dt">Nily</span> _ <span class="fu">=</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb31-21" data-line-number="21">addCommutesCarry _ <span class="dt">Nily</span> <span class="fu">=</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb31-22" data-line-number="22">addCommutesCarry (<span class="dt">Cony</span> <span class="dt">Falsy</span> xs) (<span class="dt">Cony</span> <span class="dt">Falsy</span> ys) <span class="fu">=</span></a>
<a class="sourceLine" id="cb31-23" data-line-number="23">    gcastWith (addCommutes xs ys) <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb31-24" data-line-number="24">addCommutesCarry (<span class="dt">Cony</span> <span class="dt">Truey</span> xs) (<span class="dt">Cony</span> <span class="dt">Falsy</span> ys) <span class="fu">=</span></a>
<a class="sourceLine" id="cb31-25" data-line-number="25">    gcastWith (addCommutesCarry xs ys) <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb31-26" data-line-number="26">addCommutesCarry (<span class="dt">Cony</span> <span class="dt">Falsy</span> xs) (<span class="dt">Cony</span> <span class="dt">Truey</span> ys) <span class="fu">=</span></a>
<a class="sourceLine" id="cb31-27" data-line-number="27">    gcastWith (addCommutesCarry xs ys) <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb31-28" data-line-number="28">addCommutesCarry (<span class="dt">Cony</span> <span class="dt">Truey</span> xs) (<span class="dt">Cony</span> <span class="dt">Truey</span> ys) <span class="fu">=</span></a>
<a class="sourceLine" id="cb31-29" data-line-number="29">    gcastWith (addCommutesCarry xs ys) <span class="dt">Refl</span></a></code></pre></div>
<p>Unfortunately, though, this method <em>does</em> require proofs (ugly proofs) for the delete-min operation. One of the issues is truncation: since the binary digits are stored least-significant-bit first, the same number can be represented with any number of trailing zeroes. This kept causing problems for me when it came to subtraction, and adding the requirement of no trailing zeroes (truncation) to the constructors for the heap was a pain, requiring extra proofs on merge to show that it preserves truncation.</p>
<h3 id="doubly-dependent-types">Doubly-Dependent Types</h3>
<p>Since some of these properties are much easier to verify on the type-level Peano numbers, one approach might be to convert back and forth between Peano numbers and binary, and use the proofs on Peano numbers instead.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">BintoPeano</span> (<span class="ot">xs ::</span> [<span class="dt">Bool</span>])<span class="ot"> ::</span> <span class="dt">Peano</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-2" data-line-number="2">        <span class="dt">BintoPeano</span> <span class="ch">&#39;[] = Z</span></a>
<a class="sourceLine" id="cb32-3" data-line-number="3">        <span class="dt">BintoPeano</span> (<span class="dt">False</span> <span class="fu">:</span> xs) <span class="fu">=</span> <span class="dt">BintoPeano</span> xs <span class="fu">+</span> <span class="dt">BintoPeano</span> xs</a>
<a class="sourceLine" id="cb32-4" data-line-number="4">        <span class="dt">BintoPeano</span> (<span class="dt">True</span> <span class="fu">:</span> xs) <span class="fu">=</span> <span class="dt">S</span> (<span class="dt">BintoPeano</span> xs <span class="fu">+</span> <span class="dt">BintoPeano</span> xs)</a></code></pre></div>
<p>First problem: this requires <code class="sourceCode haskell"><span class="dt">UndecidableInstances</span></code>. I‚Äôd <em>really</em> rather not have that turned on, to be honest. In Idris (and Agda), you can <em>prove</em> decidability using <a href="https://www.idris-lang.org/docs/0.12/contrib_doc/docs/Control.WellFounded.html">a number of different methods</a>, but this isn‚Äôt available in Haskell yet.</p>
<p>Regardless, we can push on.</p>
<p>To go in the other direction, we‚Äôll need to calculate the parity of natural numbers. Taken from <a href="http://docs.idris-lang.org/en/latest/tutorial/theorems.html#theorems-in-practice">the Idris tutorial</a>:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Parity</span> (<span class="ot">n ::</span> <span class="dt">Peano</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb33-2" data-line-number="2">    <span class="dt">Even</span><span class="ot"> ::</span> <span class="dt">The</span> <span class="dt">Peano</span> n <span class="ot">-&gt;</span> <span class="dt">Parity</span> (n <span class="fu">+</span> n)</a>
<a class="sourceLine" id="cb33-3" data-line-number="3">    <span class="dt">Odd</span><span class="ot">  ::</span> <span class="dt">The</span> <span class="dt">Peano</span> n <span class="ot">-&gt;</span> <span class="dt">Parity</span> (<span class="dt">S</span> (n <span class="fu">+</span> n))</a>
<a class="sourceLine" id="cb33-4" data-line-number="4"></a>
<a class="sourceLine" id="cb33-5" data-line-number="5"><span class="ot">parity ::</span> <span class="dt">The</span> <span class="dt">Peano</span> n <span class="ot">-&gt;</span> <span class="dt">Parity</span> n</a>
<a class="sourceLine" id="cb33-6" data-line-number="6">parity <span class="dt">Zy</span> <span class="fu">=</span> <span class="dt">Even</span> <span class="dt">Zy</span></a>
<a class="sourceLine" id="cb33-7" data-line-number="7">parity (<span class="dt">Sy</span> <span class="dt">Zy</span>) <span class="fu">=</span> <span class="dt">Odd</span> <span class="dt">Zy</span></a>
<a class="sourceLine" id="cb33-8" data-line-number="8">parity (<span class="dt">Sy</span> (<span class="dt">Sy</span> n)) <span class="fu">=</span> <span class="kw">case</span> parity n <span class="kw">of</span></a>
<a class="sourceLine" id="cb33-9" data-line-number="9">  <span class="dt">Even</span> m <span class="ot">-&gt;</span> gcastWith (plusSuccDistrib m m) (<span class="dt">Even</span> (<span class="dt">Sy</span> m))</a>
<a class="sourceLine" id="cb33-10" data-line-number="10">  <span class="dt">Odd</span>  m <span class="ot">-&gt;</span> gcastWith (plusSuccDistrib m m) (<span class="dt">Odd</span> (<span class="dt">Sy</span> m))</a>
<a class="sourceLine" id="cb33-11" data-line-number="11"></a>
<a class="sourceLine" id="cb33-12" data-line-number="12"><span class="ot">plusSuccDistrib ::</span> <span class="dt">The</span> <span class="dt">Peano</span> n <span class="ot">-&gt;</span> proxy m <span class="ot">-&gt;</span> n <span class="fu">+</span> <span class="dt">S</span> m <span class="fu">:~:</span> <span class="dt">S</span> (n <span class="fu">+</span> m)</a>
<a class="sourceLine" id="cb33-13" data-line-number="13">plusSuccDistrib <span class="dt">Zy</span> _ <span class="fu">=</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb33-14" data-line-number="14">plusSuccDistrib (<span class="dt">Sy</span> n) p <span class="fu">=</span> gcastWith (plusSuccDistrib n p) <span class="dt">Refl</span></a></code></pre></div>
<p>We need this function on the type-level, though, not the value-level: here, again, we run into trouble. What does <code class="sourceCode haskell">gcastWith</code> look like on the type-level? As far as I can tell, it doesn‚Äôt exist (yet. Although I haven‚Äôt looked deeply into the singletons library yet).</p>
<p>This idea of doing dependently-typed stuff on the type-level <em>started</em> to be possible with <code class="sourceCode haskell"><span class="dt">TypeInType</span></code>. For instance, we could have defined our binary type as:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Binary</span><span class="ot"> ::</span> <span class="dt">Peano</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb34-2" data-line-number="2">    <span class="dt">O</span><span class="ot"> ::</span> <span class="dt">Binary</span> n <span class="ot">-&gt;</span> <span class="dt">Binary</span> (n <span class="fu">+</span> n)</a>
<a class="sourceLine" id="cb34-3" data-line-number="3">    <span class="dt">I</span><span class="ot"> ::</span> <span class="dt">Binary</span> n <span class="ot">-&gt;</span> <span class="dt">Binary</span> (<span class="dt">S</span> (n <span class="fu">+</span> n))</a>
<a class="sourceLine" id="cb34-4" data-line-number="4">    <span class="dt">E</span><span class="ot"> ::</span> <span class="dt">Binary</span> <span class="dt">Z</span></a></code></pre></div>
<p>And then the binomial heap as:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb35-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Binomial</span> (<span class="ot">xs ::</span> <span class="dt">Binary</span> n) (<span class="ot">rk ::</span> <span class="dt">Peano</span>) (<span class="ot">a ::</span> <span class="dt">Type</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb35-2" data-line-number="2">       <span class="dt">Nil</span><span class="ot"> ::</span> <span class="dt">Binomial</span> <span class="dt">E</span> n a</a>
<a class="sourceLine" id="cb35-3" data-line-number="3">       <span class="dt">Skip</span><span class="ot"> ::</span> <span class="dt">Binomial</span> xs (<span class="dt">S</span> rk) a <span class="ot">-&gt;</span> <span class="dt">Binomial</span> (<span class="dt">O</span> xs) rk a</a>
<a class="sourceLine" id="cb35-4" data-line-number="4"><span class="ot">       (:-) ::</span> <span class="dt">Tree</span> rk a </a>
<a class="sourceLine" id="cb35-5" data-line-number="5">            <span class="ot">-&gt;</span> <span class="dt">Binomial</span> xs (<span class="dt">S</span> rk) a </a>
<a class="sourceLine" id="cb35-6" data-line-number="6">            <span class="ot">-&gt;</span> <span class="dt">Binomial</span> (<span class="dt">I</span> xs) rk a</a></code></pre></div>
<p>What we‚Äôre doing here is indexing a type <em>by an indexed type</em>. <a href="http://stackoverflow.com/a/13241158/4892417">This wasn‚Äôt possible in Haskell a few years ago</a>. It still doesn‚Äôt get us a nice definition of subtraction, though.</p>
<h3 id="using-a-typechecker-plugin">Using a Typechecker Plugin</h3>
<p>It‚Äôs pretty clear that this approach gets tedious almost immediately. What‚Äôs more, if we want the proofs to be erased, we introduce potential for errors.</p>
<p>The solution? Beef up GHC‚Äôs typechecker with a plugin. I first came across this approach in <a href="https://www.youtube.com/watch?v=u_OsUlwkmBQ">Kenneth Foner‚Äôs talk at Compose</a>. He used a plugin that called out to the <a href="https://github.com/Z3Prover/z3">Z3 theorem prover</a> <span class="citation" data-cites="diatchki_improving_2015">(from Diatchki <a href="#ref-diatchki_improving_2015">2015</a>)</span>; I‚Äôll use a <a href="https://hackage.haskell.org/package/ghc-typelits-natnormalise">simpler plugin</a> which just normalizes type-literals.</p>
<p>From what I‚Äôve used of these plugins so far, they seem to work really well. They‚Äôre very unobtrusive, only requiring a pragma at the top of your file:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" data-line-number="1"><span class="ot">{-# OPTIONS_GHC -fplugin GHC.TypeLits.Normalise #-}</span></a></code></pre></div>
<p>The plugin is only called when GHC can‚Äôt unify two types: this means you don‚Äôt get odd-looking error messages in unrelated code (in fact, the error messages I‚Äôve seen so far have been excellent‚Äîa real improvement on the standard error messages for type-level arithmetic). Another benefit is that we get to use type-level literals (<code class="sourceCode haskell"><span class="dt">Nat</span></code> imported from <a href="https://hackage.haskell.org/package/base-4.9.1.0/docs/GHC-TypeLits.html">GHC.TypeLits</a>), rather then the noisy-looking type-level Peano numbers.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb37-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> n a <span class="fu">=</span> <span class="dt">Root</span> a (<span class="dt">Node</span> n a)</a>
<a class="sourceLine" id="cb37-2" data-line-number="2"></a>
<a class="sourceLine" id="cb37-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Node</span><span class="ot"> ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb37-4" data-line-number="4">        <span class="dt">NilN</span><span class="ot"> ::</span> <span class="dt">Node</span> <span class="dv">0</span> a</a>
<a class="sourceLine" id="cb37-5" data-line-number="5"><span class="ot">        (:&lt;) ::</span> <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span>(<span class="dt">Tree</span> n a)</a>
<a class="sourceLine" id="cb37-6" data-line-number="6">             <span class="ot">-&gt;</span> <span class="dt">Node</span> n a</a>
<a class="sourceLine" id="cb37-7" data-line-number="7">             <span class="ot">-&gt;</span> <span class="dt">Node</span> (<span class="dv">1</span> <span class="fu">+</span> n) a</a>
<a class="sourceLine" id="cb37-8" data-line-number="8"></a>
<a class="sourceLine" id="cb37-9" data-line-number="9"><span class="ot">mergeTree ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Tree</span> n a <span class="ot">-&gt;</span> <span class="dt">Tree</span> n a <span class="ot">-&gt;</span> <span class="dt">Tree</span> (<span class="dv">1</span> <span class="fu">+</span> n) a</a>
<a class="sourceLine" id="cb37-10" data-line-number="10">mergeTree xr<span class="fu">@</span>(<span class="dt">Root</span> x xs) yr<span class="fu">@</span>(<span class="dt">Root</span> y ys)</a>
<a class="sourceLine" id="cb37-11" data-line-number="11">  <span class="fu">|</span> x <span class="fu">&lt;=</span> y    <span class="fu">=</span> <span class="dt">Root</span> x (yr <span class="fu">:&lt;</span> xs)</a>
<a class="sourceLine" id="cb37-12" data-line-number="12">  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Root</span> y (xr <span class="fu">:&lt;</span> ys)</a>
<a class="sourceLine" id="cb37-13" data-line-number="13"></a>
<a class="sourceLine" id="cb37-14" data-line-number="14"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:-</span></a>
<a class="sourceLine" id="cb37-15" data-line-number="15"><span class="kw">data</span> <span class="dt">Binomial</span><span class="ot"> ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb37-16" data-line-number="16">        <span class="dt">Nil</span><span class="ot">  ::</span> <span class="dt">Binomial</span> n <span class="dv">0</span> a</a>
<a class="sourceLine" id="cb37-17" data-line-number="17"><span class="ot">        (:-) ::</span> <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span>(<span class="dt">Tree</span> z a)</a>
<a class="sourceLine" id="cb37-18" data-line-number="18">             <span class="ot">-&gt;</span> <span class="dt">Binomial</span> (<span class="dv">1</span> <span class="fu">+</span> z) xs a</a>
<a class="sourceLine" id="cb37-19" data-line-number="19">             <span class="ot">-&gt;</span> <span class="dt">Binomial</span> z (<span class="dv">1</span> <span class="fu">+</span> xs <span class="fu">+</span> xs) a</a>
<a class="sourceLine" id="cb37-20" data-line-number="20">        <span class="dt">Skip</span><span class="ot"> ::</span> <span class="dt">Binomial</span> (<span class="dv">1</span> <span class="fu">+</span> z) (<span class="dv">1</span> <span class="fu">+</span> xs) a</a>
<a class="sourceLine" id="cb37-21" data-line-number="21">             <span class="ot">-&gt;</span> <span class="dt">Binomial</span> z (<span class="dv">2</span> <span class="fu">+</span> xs <span class="fu">+</span> xs) a</a></code></pre></div>
<p>This definition also ensures that the binomial heap has no trailing zeroes in its binary representation: the <code class="sourceCode haskell"><span class="dt">Skip</span></code> constructor can only be applied to a heap bigger than zero.</p>
<p>Since we‚Äôre going to be looking at several different heaps, we‚Äôll need a class to represent all of them:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb38-1" data-line-number="1"><span class="kw">class</span> <span class="dt">IndexedQueue</span> h a <span class="kw">where</span></a>
<a class="sourceLine" id="cb38-2" data-line-number="2"></a>
<a class="sourceLine" id="cb38-3" data-line-number="3">    <span class="ot">{-# MINIMAL insert, empty, minViewMay, minView #-}</span></a>
<a class="sourceLine" id="cb38-4" data-line-number="4"></a>
<a class="sourceLine" id="cb38-5" data-line-number="5">    empty</a>
<a class="sourceLine" id="cb38-6" data-line-number="6"><span class="ot">        ::</span> h <span class="dv">0</span> a</a>
<a class="sourceLine" id="cb38-7" data-line-number="7"></a>
<a class="sourceLine" id="cb38-8" data-line-number="8">    minView</a>
<a class="sourceLine" id="cb38-9" data-line-number="9"><span class="ot">        ::</span> h (<span class="dv">1</span> <span class="fu">+</span> n) a <span class="ot">-&gt;</span> (a, h n a)</a>
<a class="sourceLine" id="cb38-10" data-line-number="10"></a>
<a class="sourceLine" id="cb38-11" data-line-number="11">    singleton</a>
<a class="sourceLine" id="cb38-12" data-line-number="12"><span class="ot">        ::</span> a <span class="ot">-&gt;</span> h <span class="dv">1</span> a</a>
<a class="sourceLine" id="cb38-13" data-line-number="13">    singleton <span class="fu">=</span> flip insert empty</a>
<a class="sourceLine" id="cb38-14" data-line-number="14"></a>
<a class="sourceLine" id="cb38-15" data-line-number="15">    insert</a>
<a class="sourceLine" id="cb38-16" data-line-number="16"><span class="ot">        ::</span> a <span class="ot">-&gt;</span> h n a <span class="ot">-&gt;</span> h (<span class="dv">1</span> <span class="fu">+</span> n) a</a>
<a class="sourceLine" id="cb38-17" data-line-number="17"></a>
<a class="sourceLine" id="cb38-18" data-line-number="18">    minViewMay</a>
<a class="sourceLine" id="cb38-19" data-line-number="19"><span class="ot">       ::</span> h n a</a>
<a class="sourceLine" id="cb38-20" data-line-number="20">       <span class="ot">-&gt;</span> (n <span class="fu">~</span> <span class="dv">0</span> <span class="ot">=&gt;</span> b)</a>
<a class="sourceLine" id="cb38-21" data-line-number="21">       <span class="ot">-&gt;</span> (forall m<span class="fu">.</span> (<span class="dv">1</span> <span class="fu">+</span> m) <span class="fu">~</span> n <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> h m a <span class="ot">-&gt;</span> b)</a>
<a class="sourceLine" id="cb38-22" data-line-number="22">       <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb38-23" data-line-number="23"></a>
<a class="sourceLine" id="cb38-24" data-line-number="24"><span class="kw">class</span> <span class="dt">IndexedQueue</span> h a <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb38-25" data-line-number="25">      <span class="dt">MeldableIndexedQueue</span> h a <span class="kw">where</span></a>
<a class="sourceLine" id="cb38-26" data-line-number="26">    merge</a>
<a class="sourceLine" id="cb38-27" data-line-number="27"><span class="ot">        ::</span> h n a <span class="ot">-&gt;</span> h m a <span class="ot">-&gt;</span> h (n <span class="fu">+</span> m) a</a></code></pre></div>
<p>You‚Äôll need <code class="sourceCode haskell"><span class="dt">MultiParamTypeClasses</span></code> for this one.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb39-1" data-line-number="1">mergeB</a>
<a class="sourceLine" id="cb39-2" data-line-number="2"><span class="ot">    ::</span> <span class="dt">Ord</span> a</a>
<a class="sourceLine" id="cb39-3" data-line-number="3">    <span class="ot">=&gt;</span> <span class="dt">Binomial</span> z xs a <span class="ot">-&gt;</span> <span class="dt">Binomial</span> z ys a <span class="ot">-&gt;</span> <span class="dt">Binomial</span> z (xs <span class="fu">+</span> ys) a</a>
<a class="sourceLine" id="cb39-4" data-line-number="4">mergeB <span class="dt">Nil</span> ys              <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb39-5" data-line-number="5">mergeB xs <span class="dt">Nil</span>              <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb39-6" data-line-number="6">mergeB (<span class="dt">Skip</span> xs) (<span class="dt">Skip</span> ys) <span class="fu">=</span> <span class="dt">Skip</span> (mergeB xs ys)</a>
<a class="sourceLine" id="cb39-7" data-line-number="7">mergeB (<span class="dt">Skip</span> xs) (y <span class="fu">:-</span> ys) <span class="fu">=</span> y <span class="fu">:-</span> mergeB xs ys</a>
<a class="sourceLine" id="cb39-8" data-line-number="8">mergeB (x <span class="fu">:-</span> xs) (<span class="dt">Skip</span> ys) <span class="fu">=</span> x <span class="fu">:-</span> mergeB xs ys</a>
<a class="sourceLine" id="cb39-9" data-line-number="9">mergeB (x <span class="fu">:-</span> xs) (y <span class="fu">:-</span> ys) <span class="fu">=</span> <span class="dt">Skip</span> (mergeCarry (mergeTree x y) xs ys)</a>
<a class="sourceLine" id="cb39-10" data-line-number="10"></a>
<a class="sourceLine" id="cb39-11" data-line-number="11">mergeCarry</a>
<a class="sourceLine" id="cb39-12" data-line-number="12"><span class="ot">    ::</span> <span class="dt">Ord</span> a</a>
<a class="sourceLine" id="cb39-13" data-line-number="13">    <span class="ot">=&gt;</span> <span class="dt">Tree</span> z a</a>
<a class="sourceLine" id="cb39-14" data-line-number="14">    <span class="ot">-&gt;</span> <span class="dt">Binomial</span> z xs a</a>
<a class="sourceLine" id="cb39-15" data-line-number="15">    <span class="ot">-&gt;</span> <span class="dt">Binomial</span> z ys a</a>
<a class="sourceLine" id="cb39-16" data-line-number="16">    <span class="ot">-&gt;</span> <span class="dt">Binomial</span> z (<span class="dv">1</span> <span class="fu">+</span> xs <span class="fu">+</span> ys) a</a>
<a class="sourceLine" id="cb39-17" data-line-number="17">mergeCarry <span class="fu">!</span>t <span class="dt">Nil</span> ys              <span class="fu">=</span> carryOne t ys</a>
<a class="sourceLine" id="cb39-18" data-line-number="18">mergeCarry <span class="fu">!</span>t xs <span class="dt">Nil</span>              <span class="fu">=</span> carryOne t xs</a>
<a class="sourceLine" id="cb39-19" data-line-number="19">mergeCarry <span class="fu">!</span>t (<span class="dt">Skip</span> xs) (<span class="dt">Skip</span> ys) <span class="fu">=</span> t <span class="fu">:-</span> mergeB xs ys</a>
<a class="sourceLine" id="cb39-20" data-line-number="20">mergeCarry <span class="fu">!</span>t (<span class="dt">Skip</span> xs) (y <span class="fu">:-</span> ys) <span class="fu">=</span> <span class="dt">Skip</span> (mergeCarry (mergeTree t y) xs ys)</a>
<a class="sourceLine" id="cb39-21" data-line-number="21">mergeCarry <span class="fu">!</span>t (x <span class="fu">:-</span> xs) (<span class="dt">Skip</span> ys) <span class="fu">=</span> <span class="dt">Skip</span> (mergeCarry (mergeTree t x) xs ys)</a>
<a class="sourceLine" id="cb39-22" data-line-number="22">mergeCarry <span class="fu">!</span>t (x <span class="fu">:-</span> xs) (y <span class="fu">:-</span> ys) <span class="fu">=</span> t <span class="fu">:-</span> mergeCarry (mergeTree x y) xs ys</a>
<a class="sourceLine" id="cb39-23" data-line-number="23"></a>
<a class="sourceLine" id="cb39-24" data-line-number="24"><span class="ot">carryOne ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Tree</span> z a <span class="ot">-&gt;</span> <span class="dt">Binomial</span> z xs a <span class="ot">-&gt;</span> <span class="dt">Binomial</span> z (<span class="dv">1</span> <span class="fu">+</span> xs) a</a>
<a class="sourceLine" id="cb39-25" data-line-number="25">carryOne <span class="fu">!</span>t <span class="dt">Nil</span>       <span class="fu">=</span> t <span class="fu">:-</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb39-26" data-line-number="26">carryOne <span class="fu">!</span>t (<span class="dt">Skip</span> xs) <span class="fu">=</span> t <span class="fu">:-</span> xs</a>
<a class="sourceLine" id="cb39-27" data-line-number="27">carryOne <span class="fu">!</span>t (x <span class="fu">:-</span> xs) <span class="fu">=</span> <span class="dt">Skip</span> (carryOne (mergeTree t x) xs)</a>
<a class="sourceLine" id="cb39-28" data-line-number="28"></a>
<a class="sourceLine" id="cb39-29" data-line-number="29"><span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">MeldableIndexedQueue</span> (<span class="dt">Binomial</span> <span class="dv">0</span>) a <span class="kw">where</span></a>
<a class="sourceLine" id="cb39-30" data-line-number="30">    merge <span class="fu">=</span> mergeB</a>
<a class="sourceLine" id="cb39-31" data-line-number="31">    <span class="ot">{-# INLINE merge #-}</span></a>
<a class="sourceLine" id="cb39-32" data-line-number="32"></a>
<a class="sourceLine" id="cb39-33" data-line-number="33"><span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">IndexedQueue</span> (<span class="dt">Binomial</span> <span class="dv">0</span>) a <span class="kw">where</span></a>
<a class="sourceLine" id="cb39-34" data-line-number="34">    empty <span class="fu">=</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb39-35" data-line-number="35">    singleton x <span class="fu">=</span> <span class="dt">Root</span> x <span class="dt">NilN</span> <span class="fu">:-</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb39-36" data-line-number="36">    insert <span class="fu">=</span> merge <span class="fu">.</span> singleton</a></code></pre></div>
<p>(<code class="sourceCode haskell"><span class="dt">BangPatterns</span></code> for this example)</p>
<p>On top of that, it‚Äôs very easy to define delete-min:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb40-1" data-line-number="1">    minView xs <span class="fu">=</span> <span class="kw">case</span> minViewZip xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb40-2" data-line-number="2">      <span class="dt">Zipper</span> x _ ys <span class="ot">-&gt;</span> (x, ys)</a>
<a class="sourceLine" id="cb40-3" data-line-number="3">    minViewMay q b f <span class="fu">=</span> <span class="kw">case</span> q <span class="kw">of</span></a>
<a class="sourceLine" id="cb40-4" data-line-number="4">      <span class="dt">Nil</span> <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb40-5" data-line-number="5">      _ <span class="fu">:-</span> _ <span class="ot">-&gt;</span> uncurry f (minView q)</a>
<a class="sourceLine" id="cb40-6" data-line-number="6">      <span class="dt">Skip</span> _ <span class="ot">-&gt;</span> uncurry f (minView q)</a>
<a class="sourceLine" id="cb40-7" data-line-number="7"></a>
<a class="sourceLine" id="cb40-8" data-line-number="8"><span class="kw">data</span> <span class="dt">Zipper</span> a n rk <span class="fu">=</span> <span class="dt">Zipper</span> <span class="fu">!</span>a (<span class="dt">Node</span> rk a) (<span class="dt">Binomial</span> rk n a)</a>
<a class="sourceLine" id="cb40-9" data-line-number="9"></a>
<a class="sourceLine" id="cb40-10" data-line-number="10"><span class="ot">skip ::</span> <span class="dt">Binomial</span> (<span class="dv">1</span> <span class="fu">+</span> z) xs a <span class="ot">-&gt;</span> <span class="dt">Binomial</span> z (xs <span class="fu">+</span> xs) a</a>
<a class="sourceLine" id="cb40-11" data-line-number="11">skip x <span class="fu">=</span> <span class="kw">case</span> x <span class="kw">of</span></a>
<a class="sourceLine" id="cb40-12" data-line-number="12">  <span class="dt">Nil</span>    <span class="ot">-&gt;</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb40-13" data-line-number="13">  <span class="dt">Skip</span> _ <span class="ot">-&gt;</span> <span class="dt">Skip</span> x</a>
<a class="sourceLine" id="cb40-14" data-line-number="14">  _ <span class="fu">:-</span> _ <span class="ot">-&gt;</span> <span class="dt">Skip</span> x</a>
<a class="sourceLine" id="cb40-15" data-line-number="15"></a>
<a class="sourceLine" id="cb40-16" data-line-number="16"><span class="kw">data</span> <span class="dt">MinViewZipper</span> a n rk <span class="kw">where</span></a>
<a class="sourceLine" id="cb40-17" data-line-number="17">    <span class="dt">Infty</span><span class="ot"> ::</span> <span class="dt">MinViewZipper</span> a <span class="dv">0</span> rk</a>
<a class="sourceLine" id="cb40-18" data-line-number="18">    <span class="dt">Min</span><span class="ot"> ::</span> <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span>(<span class="dt">Zipper</span> a n rk) <span class="ot">-&gt;</span> <span class="dt">MinViewZipper</span> a (n<span class="fu">+</span><span class="dv">1</span>) rk</a>
<a class="sourceLine" id="cb40-19" data-line-number="19"></a>
<a class="sourceLine" id="cb40-20" data-line-number="20"><span class="ot">slideLeft ::</span> <span class="dt">Zipper</span> a n (<span class="dv">1</span> <span class="fu">+</span> rk) <span class="ot">-&gt;</span> <span class="dt">Zipper</span> a (<span class="dv">1</span> <span class="fu">+</span> n <span class="fu">+</span> n) rk</a>
<a class="sourceLine" id="cb40-21" data-line-number="21">slideLeft (<span class="dt">Zipper</span> m (t <span class="fu">:&lt;</span> ts) hs)</a>
<a class="sourceLine" id="cb40-22" data-line-number="22">  <span class="fu">=</span> <span class="dt">Zipper</span> m ts (t <span class="fu">:-</span> hs)</a>
<a class="sourceLine" id="cb40-23" data-line-number="23"></a>
<a class="sourceLine" id="cb40-24" data-line-number="24">pushLeft </a>
<a class="sourceLine" id="cb40-25" data-line-number="25"><span class="ot">  ::</span> <span class="dt">Ord</span> a </a>
<a class="sourceLine" id="cb40-26" data-line-number="26">  <span class="ot">=&gt;</span> <span class="dt">Tree</span> rk a </a>
<a class="sourceLine" id="cb40-27" data-line-number="27">  <span class="ot">-&gt;</span> <span class="dt">Zipper</span> a n (<span class="dv">1</span> <span class="fu">+</span> rk) </a>
<a class="sourceLine" id="cb40-28" data-line-number="28">  <span class="ot">-&gt;</span> <span class="dt">Zipper</span> a (<span class="dv">2</span> <span class="fu">+</span> n <span class="fu">+</span> n) rk</a>
<a class="sourceLine" id="cb40-29" data-line-number="29">pushLeft c (<span class="dt">Zipper</span> m (t <span class="fu">:&lt;</span> ts) hs)</a>
<a class="sourceLine" id="cb40-30" data-line-number="30">  <span class="fu">=</span> <span class="dt">Zipper</span> m ts (<span class="dt">Skip</span> (carryOne (mergeTree c t) hs))</a>
<a class="sourceLine" id="cb40-31" data-line-number="31"></a>
<a class="sourceLine" id="cb40-32" data-line-number="32"><span class="ot">minViewZip ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Binomial</span> rk (<span class="dv">1</span> <span class="fu">+</span> n) a <span class="ot">-&gt;</span> <span class="dt">Zipper</span> a n rk</a>
<a class="sourceLine" id="cb40-33" data-line-number="33">minViewZip (<span class="dt">Skip</span> xs) <span class="fu">=</span> slideLeft (minViewZip xs)</a>
<a class="sourceLine" id="cb40-34" data-line-number="34">minViewZip (t<span class="fu">@</span>(<span class="dt">Root</span> x ts) <span class="fu">:-</span> f) <span class="fu">=</span> <span class="kw">case</span> minViewZipMay f <span class="kw">of</span></a>
<a class="sourceLine" id="cb40-35" data-line-number="35">  <span class="dt">Min</span> ex<span class="fu">@</span>(<span class="dt">Zipper</span> minKey _ _) <span class="fu">|</span> minKey <span class="fu">&lt;</span> x <span class="ot">-&gt;</span> pushLeft t ex</a>
<a class="sourceLine" id="cb40-36" data-line-number="36">  _                          <span class="ot">-&gt;</span> <span class="dt">Zipper</span> x ts (skip f)</a>
<a class="sourceLine" id="cb40-37" data-line-number="37"></a>
<a class="sourceLine" id="cb40-38" data-line-number="38"><span class="ot">minViewZipMay ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Binomial</span> rk n a <span class="ot">-&gt;</span> <span class="dt">MinViewZipper</span> a n rk</a>
<a class="sourceLine" id="cb40-39" data-line-number="39">minViewZipMay (<span class="dt">Skip</span> xs) <span class="fu">=</span> <span class="dt">Min</span> (slideLeft (minViewZip xs))</a>
<a class="sourceLine" id="cb40-40" data-line-number="40">minViewZipMay <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Infty</span></a>
<a class="sourceLine" id="cb40-41" data-line-number="41">minViewZipMay (t<span class="fu">@</span>(<span class="dt">Root</span> x ts) <span class="fu">:-</span> f) <span class="fu">=</span> <span class="dt">Min</span> <span class="fu">$</span> <span class="kw">case</span> minViewZipMay f <span class="kw">of</span></a>
<a class="sourceLine" id="cb40-42" data-line-number="42">  <span class="dt">Min</span> ex<span class="fu">@</span>(<span class="dt">Zipper</span> minKey _ _) <span class="fu">|</span> minKey <span class="fu">&lt;</span> x <span class="ot">-&gt;</span> pushLeft t ex</a>
<a class="sourceLine" id="cb40-43" data-line-number="43">  _                          <span class="ot">-&gt;</span> <span class="dt">Zipper</span> x ts (skip f)</a></code></pre></div>
<p>Similarly, compare the version of the pairing heap with the plugin:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb41-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Heap</span> n a <span class="kw">where</span></a>
<a class="sourceLine" id="cb41-2" data-line-number="2">  <span class="dt">E</span><span class="ot"> ::</span> <span class="dt">Heap</span> <span class="dv">0</span> a</a>
<a class="sourceLine" id="cb41-3" data-line-number="3">  <span class="dt">T</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">HVec</span> n a <span class="ot">-&gt;</span> <span class="dt">Heap</span> (<span class="dv">1</span> <span class="fu">+</span> n) a</a>
<a class="sourceLine" id="cb41-4" data-line-number="4"></a>
<a class="sourceLine" id="cb41-5" data-line-number="5"><span class="kw">data</span> <span class="dt">HVec</span> n a <span class="kw">where</span></a>
<a class="sourceLine" id="cb41-6" data-line-number="6">  <span class="dt">HNil</span><span class="ot"> ::</span> <span class="dt">HVec</span> <span class="dv">0</span> a</a>
<a class="sourceLine" id="cb41-7" data-line-number="7">  <span class="dt">HCons</span><span class="ot"> ::</span> <span class="dt">Heap</span> m a <span class="ot">-&gt;</span> <span class="dt">HVec</span> n a <span class="ot">-&gt;</span> <span class="dt">HVec</span> (m <span class="fu">+</span> n) a</a>
<a class="sourceLine" id="cb41-8" data-line-number="8"></a>
<a class="sourceLine" id="cb41-9" data-line-number="9"><span class="ot">insert ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Heap</span> n a <span class="ot">-&gt;</span> <span class="dt">Heap</span> (<span class="dv">1</span> <span class="fu">+</span> n) a</a>
<a class="sourceLine" id="cb41-10" data-line-number="10">insert x xs <span class="fu">=</span> merge (<span class="dt">T</span> x <span class="dt">HNil</span>) xs</a>
<a class="sourceLine" id="cb41-11" data-line-number="11"></a>
<a class="sourceLine" id="cb41-12" data-line-number="12"><span class="ot">merge ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Heap</span> m a <span class="ot">-&gt;</span> <span class="dt">Heap</span> n a <span class="ot">-&gt;</span> <span class="dt">Heap</span> (m <span class="fu">+</span> n) a</a>
<a class="sourceLine" id="cb41-13" data-line-number="13">merge <span class="dt">E</span> ys <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb41-14" data-line-number="14">merge xs <span class="dt">E</span> <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb41-15" data-line-number="15">merge h1<span class="fu">@</span>(<span class="dt">T</span> x xs) h2<span class="fu">@</span>(<span class="dt">T</span> y ys)</a>
<a class="sourceLine" id="cb41-16" data-line-number="16">  <span class="fu">|</span> x <span class="fu">&lt;=</span> y <span class="fu">=</span> <span class="dt">T</span> x (<span class="dt">HCons</span> h2 xs)</a>
<a class="sourceLine" id="cb41-17" data-line-number="17">  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">T</span> y (<span class="dt">HCons</span> h1 ys)</a>
<a class="sourceLine" id="cb41-18" data-line-number="18"></a>
<a class="sourceLine" id="cb41-19" data-line-number="19"><span class="ot">minView ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Heap</span> (<span class="dv">1</span> <span class="fu">+</span> n) a <span class="ot">-&gt;</span> (a, <span class="dt">Heap</span> n a)</a>
<a class="sourceLine" id="cb41-20" data-line-number="20">minView (<span class="dt">T</span> x hs) <span class="fu">=</span> (x, mergePairs hs)</a>
<a class="sourceLine" id="cb41-21" data-line-number="21"></a>
<a class="sourceLine" id="cb41-22" data-line-number="22"><span class="ot">mergePairs ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">HVec</span> n a <span class="ot">-&gt;</span> <span class="dt">Heap</span> n a</a>
<a class="sourceLine" id="cb41-23" data-line-number="23">mergePairs <span class="dt">HNil</span> <span class="fu">=</span> <span class="dt">E</span></a>
<a class="sourceLine" id="cb41-24" data-line-number="24">mergePairs (<span class="dt">HCons</span> h <span class="dt">HNil</span>) <span class="fu">=</span> h</a>
<a class="sourceLine" id="cb41-25" data-line-number="25">mergePairs (<span class="dt">HCons</span> h1 (<span class="dt">HCons</span> h2 hs)) <span class="fu">=</span></a>
<a class="sourceLine" id="cb41-26" data-line-number="26">    merge (merge h1 h2) (mergePairs hs)</a></code></pre></div>
<p>To the version without the plugin:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb42-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Heap</span> n a <span class="kw">where</span></a>
<a class="sourceLine" id="cb42-2" data-line-number="2">  <span class="dt">E</span><span class="ot"> ::</span> <span class="dt">Heap</span> <span class="dt">Z</span> a</a>
<a class="sourceLine" id="cb42-3" data-line-number="3">  <span class="dt">T</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">HVec</span> n a <span class="ot">-&gt;</span> <span class="dt">Heap</span> (<span class="dt">S</span> n) a</a>
<a class="sourceLine" id="cb42-4" data-line-number="4"></a>
<a class="sourceLine" id="cb42-5" data-line-number="5"><span class="kw">data</span> <span class="dt">HVec</span> n a <span class="kw">where</span></a>
<a class="sourceLine" id="cb42-6" data-line-number="6">  <span class="dt">HNil</span><span class="ot"> ::</span> <span class="dt">HVec</span> <span class="dt">Z</span> a</a>
<a class="sourceLine" id="cb42-7" data-line-number="7">  <span class="dt">HCons</span><span class="ot"> ::</span> <span class="dt">Heap</span> m a <span class="ot">-&gt;</span> <span class="dt">HVec</span> n a <span class="ot">-&gt;</span> <span class="dt">HVec</span> (m <span class="fu">+</span> n) a</a>
<a class="sourceLine" id="cb42-8" data-line-number="8"></a>
<a class="sourceLine" id="cb42-9" data-line-number="9"><span class="kw">class</span> <span class="dt">Sized</span> h <span class="kw">where</span></a>
<a class="sourceLine" id="cb42-10" data-line-number="10"><span class="ot">  size ::</span> h n a <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Peano</span> n</a>
<a class="sourceLine" id="cb42-11" data-line-number="11"></a>
<a class="sourceLine" id="cb42-12" data-line-number="12"><span class="kw">instance</span> <span class="dt">Sized</span> <span class="dt">Heap</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb42-13" data-line-number="13">  size <span class="dt">E</span> <span class="fu">=</span> <span class="dt">Zy</span></a>
<a class="sourceLine" id="cb42-14" data-line-number="14">  size (<span class="dt">T</span> _ xs) <span class="fu">=</span> <span class="dt">Sy</span> (size xs)</a>
<a class="sourceLine" id="cb42-15" data-line-number="15"></a>
<a class="sourceLine" id="cb42-16" data-line-number="16"><span class="ot">plus ::</span> <span class="dt">The</span> <span class="dt">Peano</span> n <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Peano</span> m <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Peano</span> (n <span class="fu">+</span> m)</a>
<a class="sourceLine" id="cb42-17" data-line-number="17">plus <span class="dt">Zy</span> m <span class="fu">=</span> m</a>
<a class="sourceLine" id="cb42-18" data-line-number="18">plus (<span class="dt">Sy</span> n) m <span class="fu">=</span> <span class="dt">Sy</span> (plus n m)</a>
<a class="sourceLine" id="cb42-19" data-line-number="19"></a>
<a class="sourceLine" id="cb42-20" data-line-number="20"><span class="kw">instance</span> <span class="dt">Sized</span> <span class="dt">HVec</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb42-21" data-line-number="21">  size <span class="dt">HNil</span> <span class="fu">=</span> <span class="dt">Zy</span></a>
<a class="sourceLine" id="cb42-22" data-line-number="22">  size (<span class="dt">HCons</span> h hs) <span class="fu">=</span> size h <span class="ot">`plus`</span> size hs</a>
<a class="sourceLine" id="cb42-23" data-line-number="23"></a>
<a class="sourceLine" id="cb42-24" data-line-number="24"><span class="ot">insert ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Heap</span> n a <span class="ot">-&gt;</span> <span class="dt">Heap</span> (<span class="dt">S</span> n) a</a>
<a class="sourceLine" id="cb42-25" data-line-number="25">insert x xs <span class="fu">=</span> merge (<span class="dt">T</span> x <span class="dt">HNil</span>) xs</a>
<a class="sourceLine" id="cb42-26" data-line-number="26"></a>
<a class="sourceLine" id="cb42-27" data-line-number="27"><span class="ot">merge ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Heap</span> m a <span class="ot">-&gt;</span> <span class="dt">Heap</span> n a <span class="ot">-&gt;</span> <span class="dt">Heap</span> (m <span class="fu">+</span> n) a</a>
<a class="sourceLine" id="cb42-28" data-line-number="28">merge <span class="dt">E</span> ys <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb42-29" data-line-number="29">merge xs <span class="dt">E</span> <span class="fu">=</span> <span class="kw">case</span> plusZero (size xs) <span class="kw">of</span> <span class="dt">Refl</span> <span class="ot">-&gt;</span> xs</a>
<a class="sourceLine" id="cb42-30" data-line-number="30">merge h1<span class="fu">@</span>(<span class="dt">T</span> x xs) h2<span class="fu">@</span>(<span class="dt">T</span> y ys)</a>
<a class="sourceLine" id="cb42-31" data-line-number="31">  <span class="fu">|</span> x <span class="fu">&lt;=</span> y <span class="fu">=</span> <span class="kw">case</span> plusCommutative (size h2) (size xs) <span class="kw">of</span></a>
<a class="sourceLine" id="cb42-32" data-line-number="32">                    <span class="dt">Refl</span> <span class="ot">-&gt;</span> <span class="dt">T</span> x (<span class="dt">HCons</span> h2 xs)</a>
<a class="sourceLine" id="cb42-33" data-line-number="33">  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="kw">case</span> plusSuccDistrib (size xs) (size ys) <span class="kw">of</span></a>
<a class="sourceLine" id="cb42-34" data-line-number="34">                    <span class="dt">Refl</span> <span class="ot">-&gt;</span> <span class="dt">T</span> y (<span class="dt">HCons</span> h1 ys)</a>
<a class="sourceLine" id="cb42-35" data-line-number="35"></a>
<a class="sourceLine" id="cb42-36" data-line-number="36"><span class="ot">minView ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Heap</span> (<span class="dt">S</span> n) a <span class="ot">-&gt;</span> (a, <span class="dt">Heap</span> n a)</a>
<a class="sourceLine" id="cb42-37" data-line-number="37">minView (<span class="dt">T</span> x hs) <span class="fu">=</span> (x, mergePairs hs)</a>
<a class="sourceLine" id="cb42-38" data-line-number="38"></a>
<a class="sourceLine" id="cb42-39" data-line-number="39"><span class="ot">mergePairs ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">HVec</span> n a <span class="ot">-&gt;</span> <span class="dt">Heap</span> n a</a>
<a class="sourceLine" id="cb42-40" data-line-number="40">mergePairs <span class="dt">HNil</span> <span class="fu">=</span> <span class="dt">E</span></a>
<a class="sourceLine" id="cb42-41" data-line-number="41">mergePairs (<span class="dt">HCons</span> h <span class="dt">HNil</span>) <span class="fu">=</span> <span class="kw">case</span> plusZero (size h) <span class="kw">of</span> <span class="dt">Refl</span> <span class="ot">-&gt;</span> h</a>
<a class="sourceLine" id="cb42-42" data-line-number="42">mergePairs (<span class="dt">HCons</span> h1 (<span class="dt">HCons</span> h2 hs)) <span class="fu">=</span></a>
<a class="sourceLine" id="cb42-43" data-line-number="43">  <span class="kw">case</span> plusAssoc (size h1) (size h2) (size hs) <span class="kw">of</span></a>
<a class="sourceLine" id="cb42-44" data-line-number="44">    <span class="dt">Refl</span> <span class="ot">-&gt;</span> merge (merge h1 h2) (mergePairs hs)</a></code></pre></div>
<h3 id="leftist-heaps">Leftist Heaps</h3>
<p>The typechecker plugin makes it relatively easy to implement several other heaps: skew, Braun, etc. You‚Äôll need one extra trick to implement a <a href="http://lambda.jstolarek.com/2014/10/weight-biased-leftist-heaps-verified-in-haskell-using-dependent-types/">leftist heap</a>, though. Let‚Äôs take a look at the unverified version:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb43-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Leftist</span> a</a>
<a class="sourceLine" id="cb43-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Leaf</span></a>
<a class="sourceLine" id="cb43-3" data-line-number="3">    <span class="fu">|</span> <span class="dt">Node</span> <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">Int</span></a>
<a class="sourceLine" id="cb43-4" data-line-number="4">           a</a>
<a class="sourceLine" id="cb43-5" data-line-number="5">           (<span class="dt">Leftist</span> a)</a>
<a class="sourceLine" id="cb43-6" data-line-number="6">           (<span class="dt">Leftist</span> a)</a>
<a class="sourceLine" id="cb43-7" data-line-number="7"></a>
<a class="sourceLine" id="cb43-8" data-line-number="8"><span class="ot">rank ::</span> <span class="dt">Leftist</span> s <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb43-9" data-line-number="9">rank <span class="dt">Leaf</span>          <span class="fu">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb43-10" data-line-number="10">rank (<span class="dt">Node</span> r _ _ _) <span class="fu">=</span> r</a>
<a class="sourceLine" id="cb43-11" data-line-number="11"><span class="ot">{-# INLINE rank #-}</span></a>
<a class="sourceLine" id="cb43-12" data-line-number="12"></a>
<a class="sourceLine" id="cb43-13" data-line-number="13"><span class="ot">mergeL ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Leftist</span> a <span class="ot">-&gt;</span> <span class="dt">Leftist</span> a <span class="ot">-&gt;</span> <span class="dt">Leftist</span> a</a>
<a class="sourceLine" id="cb43-14" data-line-number="14">mergeL <span class="dt">Leaf</span> h2 <span class="fu">=</span> h2</a>
<a class="sourceLine" id="cb43-15" data-line-number="15">mergeL h1 <span class="dt">Leaf</span> <span class="fu">=</span> h1</a>
<a class="sourceLine" id="cb43-16" data-line-number="16">mergeL h1<span class="fu">@</span>(<span class="dt">Node</span> w1 p1 l1 r1) h2<span class="fu">@</span>(<span class="dt">Node</span> w2 p2 l2 r2)</a>
<a class="sourceLine" id="cb43-17" data-line-number="17">  <span class="fu">|</span> p1 <span class="fu">&lt;</span> p2 <span class="fu">=</span></a>
<a class="sourceLine" id="cb43-18" data-line-number="18">      <span class="kw">if</span> ll <span class="fu">&lt;=</span> lr</a>
<a class="sourceLine" id="cb43-19" data-line-number="19">          <span class="kw">then</span> <span class="dt">LNode</span> (w1 <span class="fu">+</span> w2) p1 l1 (mergeL r1 h2)</a>
<a class="sourceLine" id="cb43-20" data-line-number="20">          <span class="kw">else</span> <span class="dt">LNode</span> (w1 <span class="fu">+</span> w2) p1 (mergeL r1 h2) l1</a>
<a class="sourceLine" id="cb43-21" data-line-number="21">  <span class="fu">|</span> otherwise <span class="fu">=</span></a>
<a class="sourceLine" id="cb43-22" data-line-number="22">      <span class="kw">if</span> rl <span class="fu">&lt;=</span> rr</a>
<a class="sourceLine" id="cb43-23" data-line-number="23">          <span class="kw">then</span> <span class="dt">LNode</span> (w1 <span class="fu">+</span> w2) p2 l2 (mergeL r2 h1)</a>
<a class="sourceLine" id="cb43-24" data-line-number="24">          <span class="kw">else</span> <span class="dt">LNode</span> (w1 <span class="fu">+</span> w2) p2 (mergeL r2 h1) l2</a>
<a class="sourceLine" id="cb43-25" data-line-number="25">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb43-26" data-line-number="26">    ll <span class="fu">=</span> rank r1 <span class="fu">+</span> w2</a>
<a class="sourceLine" id="cb43-27" data-line-number="27">    lr <span class="fu">=</span> rank l1</a>
<a class="sourceLine" id="cb43-28" data-line-number="28">    rl <span class="fu">=</span> rank r2 <span class="fu">+</span> w1</a>
<a class="sourceLine" id="cb43-29" data-line-number="29">    rr <span class="fu">=</span> rank l2</a></code></pre></div>
<p>In a weight-biased leftist heap, the left branch in any tree must have at least as many elements as the right branch. Ideally, we would encode that in the representation of size-indexed leftist heap:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb44-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Leftist</span> n a <span class="kw">where</span></a>
<a class="sourceLine" id="cb44-2" data-line-number="2">        <span class="dt">Leaf</span><span class="ot"> ::</span> <span class="dt">Leftist</span> <span class="dv">0</span> a</a>
<a class="sourceLine" id="cb44-3" data-line-number="3">        <span class="dt">Node</span><span class="ot"> ::</span> <span class="fu">!</span>(<span class="dt">The</span> <span class="dt">Nat</span> (n <span class="fu">+</span> m <span class="fu">+</span> <span class="dv">1</span>))</a>
<a class="sourceLine" id="cb44-4" data-line-number="4">             <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb44-5" data-line-number="5">             <span class="ot">-&gt;</span> <span class="dt">Leftist</span> n a</a>
<a class="sourceLine" id="cb44-6" data-line-number="6">             <span class="ot">-&gt;</span> <span class="dt">Leftist</span> m a</a>
<a class="sourceLine" id="cb44-7" data-line-number="7">             <span class="ot">-&gt;</span> <span class="fu">!</span>(m <span class="fu">&lt;=</span> n)</a>
<a class="sourceLine" id="cb44-8" data-line-number="8">             <span class="ot">-&gt;</span> <span class="dt">Leftist</span> (n <span class="fu">+</span> m <span class="fu">+</span> <span class="dv">1</span>) a</a>
<a class="sourceLine" id="cb44-9" data-line-number="9"></a>
<a class="sourceLine" id="cb44-10" data-line-number="10"><span class="ot">rank ::</span> <span class="dt">Leftist</span> n s <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> n</a>
<a class="sourceLine" id="cb44-11" data-line-number="11">rank <span class="dt">Leaf</span>             <span class="fu">=</span> sing</a>
<a class="sourceLine" id="cb44-12" data-line-number="12">rank (<span class="dt">Node</span> r _ _ _ _) <span class="fu">=</span> r</a>
<a class="sourceLine" id="cb44-13" data-line-number="13"><span class="ot">{-# INLINE rank #-}</span></a></code></pre></div>
<p>Two problems, though: first of all, we need to be able to <em>compare</em> the sizes of two heaps, in the merge function. If we were using the type-level Peano numbers, this would be too slow. More importantly, though, we need the comparison to provide a <em>proof</em> of the ordering, so that we can use it in the resulting <code class="sourceCode haskell"><span class="dt">Node</span></code> constructor.</p>
<h3 id="integer-backed-type-level-numbers">Integer-Backed Type-Level Numbers</h3>
<p>In Agda, the Peano type is actually backed by Haskell‚Äôs <code class="sourceCode haskell"><span class="dt">Integer</span></code> at runtime. This allows compile-time proofs to be written about values which are calculated efficiently. We can mimic the same thing in Haskell with a newtype wrapper <em>around</em> <code class="sourceCode haskell"><span class="dt">Integer</span></code> with a phantom <code class="sourceCode haskell"><span class="dt">Peano</span></code> parameter, if we promise to never put an integer in which has a different value to its phantom value. We can make this promise a little more trustworthy if we don‚Äôt export the newtype constructor.</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb45-1" data-line-number="1"><span class="kw">newtype</span> <span class="kw">instance</span> <span class="dt">The</span> <span class="dt">Nat</span> n <span class="kw">where</span></a>
<a class="sourceLine" id="cb45-2" data-line-number="2">        <span class="dt">NatSing</span><span class="ot"> ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> n</a>
<a class="sourceLine" id="cb45-3" data-line-number="3"></a>
<a class="sourceLine" id="cb45-4" data-line-number="4"><span class="kw">instance</span> <span class="dt">KnownNat</span> n <span class="ot">=&gt;</span> <span class="dt">KnownSing</span> n <span class="kw">where</span></a>
<a class="sourceLine" id="cb45-5" data-line-number="5">    sing <span class="fu">=</span> <span class="dt">NatSing</span> <span class="fu">$</span> Prelude.fromInteger <span class="fu">$</span> natVal (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> n)</a></code></pre></div>
<p><code class="sourceCode haskell"><span class="dt">FlexibleInstances</span></code> is needed for the instance. We can also encode all the necessary arithmetic:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb46-1" data-line-number="1"><span class="kw">infixl</span> <span class="dv">6</span> <span class="fu">+.</span></a>
<a class="sourceLine" id="cb46-2" data-line-number="2"><span class="ot">(+.) ::</span> <span class="dt">The</span> <span class="dt">Nat</span> n <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> m <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> (n <span class="fu">+</span> m)</a>
<a class="sourceLine" id="cb46-3" data-line-number="3">(<span class="fu">+.</span>) <span class="fu">=</span></a>
<a class="sourceLine" id="cb46-4" data-line-number="4">    (<span class="ot">coerce ::</span> (<span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>) </a>
<a class="sourceLine" id="cb46-5" data-line-number="5">            <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> n <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> m <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> (n <span class="fu">+</span> m))</a>
<a class="sourceLine" id="cb46-6" data-line-number="6">        (<span class="fu">+</span>)</a>
<a class="sourceLine" id="cb46-7" data-line-number="7"><span class="ot">{-# INLINE (+.) #-}</span></a></code></pre></div>
<p>Finally, the compare function (<code class="sourceCode haskell"><span class="dt">ScopedTypeVariables</span></code> for this):</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb47-1" data-line-number="1">infix <span class="dv">4</span> <span class="fu">&lt;=.</span></a>
<a class="sourceLine" id="cb47-2" data-line-number="2"><span class="ot">(&lt;=.) ::</span> <span class="dt">The</span> <span class="dt">Nat</span> n <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> m <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Bool</span> (n <span class="fu">&lt;=?</span> m)</a>
<a class="sourceLine" id="cb47-3" data-line-number="3">(<span class="fu">&lt;=.</span>) (<span class="dt">NatSing</span><span class="ot"> x ::</span> <span class="dt">The</span> <span class="dt">Nat</span> n) (<span class="dt">NatSing</span><span class="ot"> y ::</span> <span class="dt">The</span> <span class="dt">Nat</span> m)</a>
<a class="sourceLine" id="cb47-4" data-line-number="4">  <span class="fu">|</span> x <span class="fu">&lt;=</span> y <span class="fu">=</span> </a>
<a class="sourceLine" id="cb47-5" data-line-number="5">      <span class="kw">case</span> (unsafeCoerce (<span class="dt">Refl</span><span class="ot"> ::</span> <span class="dt">True</span> <span class="fu">:~:</span> <span class="dt">True</span>)<span class="ot"> ::</span> (n <span class="fu">&lt;=?</span> m) <span class="fu">:~:</span> <span class="dt">True</span>) <span class="kw">of</span></a>
<a class="sourceLine" id="cb47-6" data-line-number="6">        <span class="dt">Refl</span> <span class="ot">-&gt;</span> <span class="dt">Truey</span></a>
<a class="sourceLine" id="cb47-7" data-line-number="7">  <span class="fu">|</span> otherwise <span class="fu">=</span> </a>
<a class="sourceLine" id="cb47-8" data-line-number="8">      <span class="kw">case</span> (unsafeCoerce (<span class="dt">Refl</span><span class="ot"> ::</span> <span class="dt">True</span> <span class="fu">:~:</span> <span class="dt">True</span>)<span class="ot"> ::</span> (n <span class="fu">&lt;=?</span> m) <span class="fu">:~:</span> <span class="dt">False</span>) <span class="kw">of</span></a>
<a class="sourceLine" id="cb47-9" data-line-number="9">        <span class="dt">Refl</span> <span class="ot">-&gt;</span> <span class="dt">Falsy</span></a>
<a class="sourceLine" id="cb47-10" data-line-number="10"><span class="ot">{-# INLINE (&lt;=.) #-}</span></a>
<a class="sourceLine" id="cb47-11" data-line-number="11"></a>
<a class="sourceLine" id="cb47-12" data-line-number="12"><span class="ot">totalOrder ::</span>  p n <span class="ot">-&gt;</span> q m <span class="ot">-&gt;</span> (n <span class="fu">&lt;=?</span> m) <span class="fu">:~:</span> <span class="dt">False</span> <span class="ot">-&gt;</span> (m <span class="fu">&lt;=?</span> n) <span class="fu">:~:</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb47-13" data-line-number="13">totalOrder (<span class="ot">_ ::</span> p n) (<span class="ot">_ ::</span> q m) <span class="dt">Refl</span> <span class="fu">=</span> </a>
<a class="sourceLine" id="cb47-14" data-line-number="14">    unsafeCoerce <span class="dt">Refl</span><span class="ot"> ::</span> (m <span class="fu">&lt;=?</span> n) <span class="fu">:~:</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb47-15" data-line-number="15"></a>
<a class="sourceLine" id="cb47-16" data-line-number="16"><span class="kw">type</span> x <span class="fu">&lt;=</span> y <span class="fu">=</span> (x <span class="fu">&lt;=?</span> y) <span class="fu">:~:</span> <span class="dt">True</span></a></code></pre></div>
<p>It‚Äôs worth mentioning that all of these functions are somewhat axiomatic: there‚Äôs no checking of these definitions going on, and any later proofs are only correct in terms of these functions.</p>
<p>If we want our merge function to <em>really</em> look like the non-verified version, though, we‚Äôll have to mess around with the syntax a little.</p>
<h3 id="a-dependent-if-then-else">A Dependent if-then-else</h3>
<p>When matching on a singleton, <em>within</em> the case-match, proof of the singleton‚Äôs type is provided. For instance:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb48-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">IfThenElse</span> (<span class="ot">c ::</span> <span class="dt">Bool</span>) (<span class="ot">true ::</span> k) (<span class="ot">false ::</span> k)<span class="ot"> ::</span> k</a>
<a class="sourceLine" id="cb48-2" data-line-number="2">     <span class="kw">where</span></a>
<a class="sourceLine" id="cb48-3" data-line-number="3">        <span class="dt">IfThenElse</span> <span class="dt">True</span> true false <span class="fu">=</span> true</a>
<a class="sourceLine" id="cb48-4" data-line-number="4">        <span class="dt">IfThenElse</span> <span class="dt">False</span> true false <span class="fu">=</span> false</a>
<a class="sourceLine" id="cb48-5" data-line-number="5"></a>
<a class="sourceLine" id="cb48-6" data-line-number="6"><span class="ot">intOrString ::</span> <span class="dt">The</span> <span class="dt">Bool</span> cond <span class="ot">-&gt;</span> <span class="dt">IfThenElse</span> cond <span class="dt">Int</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb48-7" data-line-number="7">intOrString <span class="dt">Truey</span> <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb48-8" data-line-number="8">intOrString <span class="dt">Falsy</span> <span class="fu">=</span> <span class="st">&quot;abc&quot;</span></a></code></pre></div>
<p>In Haskell, since we can overload the if-then-else construct (with <code class="sourceCode haskell"><span class="dt">RebindableSyntax</span></code>), we can provide the same syntax, while hiding the dependent nature:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb49-1" data-line-number="1"><span class="ot">ifThenElse ::</span> <span class="dt">The</span> <span class="dt">Bool</span> c <span class="ot">-&gt;</span> (c <span class="fu">:~:</span> <span class="dt">True</span> <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (c <span class="fu">:~:</span> <span class="dt">False</span> <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb49-2" data-line-number="2">ifThenElse <span class="dt">Truey</span> t _ <span class="fu">=</span> t <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb49-3" data-line-number="3">ifThenElse <span class="dt">Falsy</span> _ f <span class="fu">=</span> f <span class="dt">Refl</span></a></code></pre></div>
<h3 id="verified-merge">Verified Merge</h3>
<p>Finally, then, we can write the implementation for merge, which looks almost <em>exactly</em> the same as the non-verified merge:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb50-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">IndexedQueue</span> <span class="dt">Leftist</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb50-2" data-line-number="2"></a>
<a class="sourceLine" id="cb50-3" data-line-number="3">    minView (<span class="dt">Node</span> _ x l r _) <span class="fu">=</span> (x, merge l r)</a>
<a class="sourceLine" id="cb50-4" data-line-number="4">    <span class="ot">{-# INLINE minView #-}</span></a>
<a class="sourceLine" id="cb50-5" data-line-number="5"></a>
<a class="sourceLine" id="cb50-6" data-line-number="6"></a>
<a class="sourceLine" id="cb50-7" data-line-number="7">    singleton x <span class="fu">=</span> <span class="dt">Node</span> sing x <span class="dt">Leaf</span> <span class="dt">Leaf</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb50-8" data-line-number="8">    <span class="ot">{-# INLINE singleton #-}</span></a>
<a class="sourceLine" id="cb50-9" data-line-number="9"></a>
<a class="sourceLine" id="cb50-10" data-line-number="10">    empty <span class="fu">=</span> <span class="dt">Leaf</span></a>
<a class="sourceLine" id="cb50-11" data-line-number="11">    <span class="ot">{-# INLINE empty #-}</span></a>
<a class="sourceLine" id="cb50-12" data-line-number="12"></a>
<a class="sourceLine" id="cb50-13" data-line-number="13">    insert <span class="fu">=</span> merge <span class="fu">.</span> singleton</a>
<a class="sourceLine" id="cb50-14" data-line-number="14">    <span class="ot">{-# INLINE insert #-}</span></a>
<a class="sourceLine" id="cb50-15" data-line-number="15"></a>
<a class="sourceLine" id="cb50-16" data-line-number="16">    minViewMay <span class="dt">Leaf</span> b _             <span class="fu">=</span> b</a>
<a class="sourceLine" id="cb50-17" data-line-number="17">    minViewMay (<span class="dt">Node</span> _ x l r _) _ f <span class="fu">=</span> f x (merge l r)</a>
<a class="sourceLine" id="cb50-18" data-line-number="18"></a>
<a class="sourceLine" id="cb50-19" data-line-number="19"><span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb50-20" data-line-number="20">         <span class="dt">MeldableIndexedQueue</span> <span class="dt">Leftist</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb50-21" data-line-number="21">    merge <span class="dt">Leaf</span> h2 <span class="fu">=</span> h2</a>
<a class="sourceLine" id="cb50-22" data-line-number="22">    merge h1 <span class="dt">Leaf</span> <span class="fu">=</span> h1</a>
<a class="sourceLine" id="cb50-23" data-line-number="23">    merge h1<span class="fu">@</span>(<span class="dt">Node</span> w1 p1 l1 r1 _) h2<span class="fu">@</span>(<span class="dt">Node</span> w2 p2 l2 r2 _)</a>
<a class="sourceLine" id="cb50-24" data-line-number="24">      <span class="fu">|</span> p1 <span class="fu">&lt;</span> p2 <span class="fu">=</span></a>
<a class="sourceLine" id="cb50-25" data-line-number="25">          <span class="kw">if</span> ll <span class="fu">&lt;=.</span> lr</a>
<a class="sourceLine" id="cb50-26" data-line-number="26">             <span class="kw">then</span> <span class="dt">Node</span> (w1 <span class="fu">+.</span> w2) p1 l1 (merge r1 h2)</a>
<a class="sourceLine" id="cb50-27" data-line-number="27">             <span class="kw">else</span> <span class="dt">Node</span> (w1 <span class="fu">+.</span> w2) p1 (merge r1 h2) l1 <span class="fu">.</span> totalOrder ll lr</a>
<a class="sourceLine" id="cb50-28" data-line-number="28">      <span class="fu">|</span> otherwise <span class="fu">=</span></a>
<a class="sourceLine" id="cb50-29" data-line-number="29">          <span class="kw">if</span> rl <span class="fu">&lt;=.</span> rr</a>
<a class="sourceLine" id="cb50-30" data-line-number="30">              <span class="kw">then</span> <span class="dt">Node</span> (w1 <span class="fu">+.</span> w2) p2 l2 (merge r2 h1)</a>
<a class="sourceLine" id="cb50-31" data-line-number="31">              <span class="kw">else</span> <span class="dt">Node</span> (w1 <span class="fu">+.</span> w2) p2 (merge r2 h1) l2 <span class="fu">.</span> totalOrder rl rr</a>
<a class="sourceLine" id="cb50-32" data-line-number="32">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb50-33" data-line-number="33">        ll <span class="fu">=</span> rank r1 <span class="fu">+.</span> w2</a>
<a class="sourceLine" id="cb50-34" data-line-number="34">        lr <span class="fu">=</span> rank l1</a>
<a class="sourceLine" id="cb50-35" data-line-number="35">        rl <span class="fu">=</span> rank r2 <span class="fu">+.</span> w1</a>
<a class="sourceLine" id="cb50-36" data-line-number="36">        rr <span class="fu">=</span> rank l2</a>
<a class="sourceLine" id="cb50-37" data-line-number="37">    <span class="ot">{-# INLINE merge #-}</span></a></code></pre></div>
<p>What‚Äôs cool about this implementation is that it has the same performance as the non-verified version (if <code class="sourceCode haskell"><span class="dt">Integer</span></code> is swapped out for <code class="sourceCode haskell"><span class="dt">Int</span></code>, that is), and it <em>looks</em> pretty much the same. This is very close to static verification for free.</p>
<h3 id="generalizing-sort-to-parts">Generalizing Sort to Parts</h3>
<p>The <code class="sourceCode haskell"><span class="dt">Sort</span></code> type used in the original blog post can be generalized to <em>any</em> indexed container.</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb51-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Parts</span> f g a b r <span class="kw">where</span></a>
<a class="sourceLine" id="cb51-2" data-line-number="2">    <span class="dt">Parts</span><span class="ot"> ::</span> (forall n<span class="fu">.</span> g (m <span class="fu">+</span> n) b <span class="ot">-&gt;</span> (g n b, r))</a>
<a class="sourceLine" id="cb51-3" data-line-number="3">         <span class="ot">-&gt;</span> <span class="fu">!</span>(f m a)</a>
<a class="sourceLine" id="cb51-4" data-line-number="4">         <span class="ot">-&gt;</span> <span class="dt">Parts</span> f g a b r</a>
<a class="sourceLine" id="cb51-5" data-line-number="5"></a>
<a class="sourceLine" id="cb51-6" data-line-number="6"><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Parts</span> f g a b) <span class="kw">where</span></a>
<a class="sourceLine" id="cb51-7" data-line-number="7">  fmap f (<span class="dt">Parts</span> g h) <span class="fu">=</span></a>
<a class="sourceLine" id="cb51-8" data-line-number="8">    <span class="dt">Parts</span> (\h&#39; <span class="ot">-&gt;</span> <span class="kw">case</span> g h&#39; <span class="kw">of</span> (remn, r) <span class="ot">-&gt;</span> (remn, f r)) h</a>
<a class="sourceLine" id="cb51-9" data-line-number="9">  <span class="ot">{-# INLINE fmap #-}</span></a>
<a class="sourceLine" id="cb51-10" data-line-number="10"></a>
<a class="sourceLine" id="cb51-11" data-line-number="11"><span class="kw">instance</span> (<span class="dt">IndexedQueue</span> f x, <span class="dt">MeldableIndexedQueue</span> f x) <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb51-12" data-line-number="12">          <span class="dt">Applicative</span> (<span class="dt">Parts</span> f g x y) <span class="kw">where</span></a>
<a class="sourceLine" id="cb51-13" data-line-number="13">    pure x <span class="fu">=</span> <span class="dt">Parts</span> (\h <span class="ot">-&gt;</span> (h, x)) empty</a>
<a class="sourceLine" id="cb51-14" data-line-number="14">    <span class="ot">{-# INLINE pure #-}</span></a>
<a class="sourceLine" id="cb51-15" data-line-number="15"></a>
<a class="sourceLine" id="cb51-16" data-line-number="16">    (<span class="dt">Parts</span> f (<span class="ot">xs ::</span> f m x)<span class="ot"> ::</span> <span class="dt">Parts</span> f g x y (a <span class="ot">-&gt;</span> b)) <span class="fu">&lt;*&gt;</span> </a>
<a class="sourceLine" id="cb51-17" data-line-number="17">      <span class="dt">Parts</span> g (<span class="ot">ys ::</span> f n x) <span class="fu">=</span></a>
<a class="sourceLine" id="cb51-18" data-line-number="18">        <span class="dt">Parts</span> h (merge xs ys)</a>
<a class="sourceLine" id="cb51-19" data-line-number="19">        <span class="kw">where</span></a>
<a class="sourceLine" id="cb51-20" data-line-number="20"><span class="ot">          h ::</span> forall o <span class="fu">.</span> g ((m <span class="fu">+</span> n) <span class="fu">+</span> o) y <span class="ot">-&gt;</span> (g o y, b)</a>
<a class="sourceLine" id="cb51-21" data-line-number="21">          h v <span class="fu">=</span> <span class="kw">case</span> f v <span class="kw">of</span> { (v&#39;, a) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb51-22" data-line-number="22">                    <span class="kw">case</span> g v&#39; <span class="kw">of</span> { (v&#39;&#39;, b) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb51-23" data-line-number="23">                      (v&#39;&#39;, a b)}}</a>
<a class="sourceLine" id="cb51-24" data-line-number="24">    <span class="ot">{-# INLINABLE (&lt;*&gt;) #-}</span></a></code></pre></div>
<p>This version doesn‚Äôt insist that you order the elements of the heap in any particular way: we could use indexed difference lists to reverse a container, or indexed lists to calculate permutations of a container, for instance.</p>
<h3 id="other-uses-for-size-indexed-heaps">Other Uses For Size-Indexed Heaps</h3>
<p>I‚Äôd be very interested to see any other uses of these indexed heaps, if anyone has any ideas. Potentially the could be used in any place where there is a need for some heap which is known to be of a certain size (a true prime sieve, for instance).</p>
<h3 id="the-library">The Library</h3>
<p>I‚Äôve explored all of these ideas <a href="https://github.com/oisdk/type-indexed-queues">here</a>. It has implementations of all the heaps I mentioned, as well as the index-erasing type, and a size-indexed list, for reversing traversables. In the future, I might add things like a Fibonacci heap, or the optimal Brodal/Okasaki heap <span class="citation" data-cites="brodal_optimal_1996">(Brodal and Okasaki <a href="#ref-brodal_optimal_1996">1996</a>)</span>.</p>
<hr />
<div id="refs" class="references">
<div id="ref-brodal_optimal_1996">
<p>Brodal, Gerth St√∏lting, and Chris Okasaki. 1996. ‚ÄúOptimal Purely Functional Priority Queues.‚Äù <em>Journal of Functional Programming</em> 6 (6) (November): 839‚Äì857. doi:<a href="https://doi.org/10.1017/S095679680000201X">10.1017/S095679680000201X</a>. <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.48.973" class="uri">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.48.973</a>.</p>
</div>
<div id="ref-diatchki_improving_2015">
<p>Diatchki, Iavor S. 2015. ‚ÄúImproving Haskell Types with SMT.‚Äù In <em>Proceedings of the 2015 ACM SIGPLAN Symposium on Haskell</em>, 1‚Äì10. Haskell ‚Äô15. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/2804302.2804307">10.1145/2804302.2804307</a>. <a href="http://yav.github.io/publications/improving-smt-types.pdf" class="uri">http://yav.github.io/publications/improving-smt-types.pdf</a>.</p>
</div>
<div id="ref-eisenberg_dependently_2012">
<p>Eisenberg, Richard A., and Stephanie Weirich. 2012. ‚ÄúDependently Typed Programming with Singletons.‚Äù In <em>Proceedings of the 2012 Haskell Symposium</em>, 117‚Äì130. Haskell ‚Äô12. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/2364506.2364522">10.1145/2364506.2364522</a>. <a href="http://cs.brynmawr.edu/~rae/papers/2012/singletons/paper.pdf" class="uri">http://cs.brynmawr.edu/~rae/papers/2012/singletons/paper.pdf</a>.</p>
</div>
<div id="ref-fredman_pairing_1986">
<p>Fredman, Michael L., Robert Sedgewick, Daniel D. Sleator, and Robert E. Tarjan. 1986. ‚ÄúThe pairing heap: A new form of self-adjusting heap.‚Äù <em>Algorithmica</em> 1 (1-4) (January): 111‚Äì129. doi:<a href="https://doi.org/10.1007/BF01840439">10.1007/BF01840439</a>. <a href="http://www.cs.princeton.edu/courses/archive/fall09/cos521/Handouts/pairingheaps.pdf" class="uri">http://www.cs.princeton.edu/courses/archive/fall09/cos521/Handouts/pairingheaps.pdf</a>.</p>
</div>
<div id="ref-hinze_functional_1999">
<p>Hinze, Ralf. 1999. ‚ÄúFunctional Pearls: Explaining Binomial Heaps.‚Äù <em>Journal of Functional Programming</em> 9 (1) (January): 93‚Äì104. doi:<a href="https://doi.org/10.1017/S0956796899003317">10.1017/S0956796899003317</a>. <a href="http://www.cs.ox.ac.uk/ralf.hinze/publications/#J1" class="uri">http://www.cs.ox.ac.uk/ralf.hinze/publications/#J1</a>.</p>
</div>
<div id="ref-hinze_manufacturing_2001">
<p>‚Äî‚Äî‚Äî. 2001. ‚ÄúManufacturing datatypes.‚Äù <em>Journal of Functional Programming</em> 11 (5) (September): 493‚Äì524. doi:<a href="https://doi.org/10.1017/S095679680100404X">10.1017/S095679680100404X</a>. <a href="http://www.cs.ox.ac.uk/ralf.hinze/publications/#J6" class="uri">http://www.cs.ox.ac.uk/ralf.hinze/publications/#J6</a>.</p>
</div>
<div id="ref-okasaki_fast_1999">
<p>Okasaki, Chris. 1999. ‚ÄúFrom Fast Exponentiation to Square Matrices: An Adventure in Types.‚Äù In <em>Proceedings of the ACM SIGPLAN International Conference on Functional Programming (ICFP‚Äô99), Paris, France, September 27-29, 1999</em>, 34:28. ACM. <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.456.357&amp;rep=rep1&amp;type=pdf" class="uri">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.456.357&amp;rep=rep1&amp;type=pdf</a>.</p>
</div>
<div id="ref-wasserman_playing_2010">
<p>Wasserman, Louis. 2010. ‚ÄúPlaying with Priority Queues.‚Äù <em>The Monad.Reader</em> 16 (16) (May): 37. <a href="https://themonadreader.files.wordpress.com/2010/05/issue16.pdf" class="uri">https://themonadreader.files.wordpress.com/2010/05/issue16.pdf</a>.</p>
</div>
</div>
]]></description>
    <pubDate>Sun, 23 Apr 2017 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2017-04-23-verifying-data-structures-in-haskell-lhs.html</guid>
    <dc:creator>Donnacha Ois√≠n Kidney</dc:creator>
</item>
<item>
    <title>Fun with Recursion Schemes</title>
    <link>https://doisinkidney.com/posts/2017-03-30-fun-with-recursion-schemes.html</link>
    <description><![CDATA[<div class="info">
    Posted on March 30, 2017
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Recursion%20Schemes.html">Recursion Schemes</a>
    
</div>

<h2 id="folding-algebras">Folding Algebras</h2>
<p>I saw <a href="https://www.reddit.com/r/haskell/comments/608y0l/would_this_sugar_make_sense/">this</a> post on reddit recently, and it got me thinking about recursion schemes. One of the primary motivations behind them is the reduction of boilerplate. The classic example is evaluation of arithmetic expressions:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> <span class="dt">ExprF</span> a</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">LitF</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  <span class="fu">|</span> (<span class="fu">:+:</span>) a a</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">  <span class="fu">|</span> (<span class="fu">:*:</span>) a a</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">  <span class="kw">deriving</span> <span class="dt">Functor</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="kw">type</span> <span class="dt">Expr</span> <span class="fu">=</span> <span class="dt">Fix</span> <span class="dt">ExprF</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"></a>
<a class="sourceLine" id="cb1-9" data-line-number="9"><span class="ot">eval ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10">eval <span class="fu">=</span> unfix <span class="fu">&gt;&gt;&gt;</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11">  <span class="dt">LitF</span> n <span class="ot">-&gt;</span> n</a>
<a class="sourceLine" id="cb1-12" data-line-number="12">  x <span class="fu">:+:</span> y <span class="ot">-&gt;</span> eval x <span class="fu">+</span> eval y</a>
<a class="sourceLine" id="cb1-13" data-line-number="13">  x <span class="fu">:*:</span> y <span class="ot">-&gt;</span> eval x <span class="fu">*</span> eval y</a></code></pre></div>
<p>The calls to <code class="sourceCode haskell">eval</code> are the boilerplate: this is where the main recursion scheme, <code class="sourceCode haskell">cata</code> can help.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">evalF ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">evalF <span class="fu">=</span> cata <span class="fu">$</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  <span class="dt">LitF</span> n <span class="ot">-&gt;</span> n</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">  x <span class="fu">:+:</span> y <span class="ot">-&gt;</span> x <span class="fu">+</span> y</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">  x <span class="fu">:*:</span> y <span class="ot">-&gt;</span> x <span class="fu">*</span> y</a></code></pre></div>
<p>I still feel like there‚Äôs boilerplate, though. Ideally I‚Äôd like to write this:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">evalF ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">evalF <span class="fu">=</span> cata <span class="fu">$</span> <span class="fu">???</span> <span class="fu">$</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">  <span class="dt">Lit</span> <span class="ot">-&gt;</span> id</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">  <span class="dt">Add</span> <span class="ot">-&gt;</span> (<span class="fu">+</span>)</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">  <span class="dt">Mul</span> <span class="ot">-&gt;</span> (<span class="fu">*</span>)</a></code></pre></div>
<p>The <code class="sourceCode haskell"><span class="fu">???</span></code> needs to be filled in. It‚Äôs a little tricky, though: the type of the algebra changes depending on what expression it‚Äôs given. GADTs will allow us to attach types to cases:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">data</span> <span class="dt">ExprI</span> a r f <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  <span class="dt">Lit</span><span class="ot"> ::</span> <span class="dt">ExprI</span> a b (<span class="dt">Integer</span> <span class="ot">-&gt;</span> b)</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  <span class="dt">Add</span><span class="ot"> ::</span> <span class="dt">ExprI</span> a b (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b)</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">  <span class="dt">Mul</span><span class="ot"> ::</span> <span class="dt">ExprI</span> a b (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b)</a></code></pre></div>
<p>The first type parameter is the same as the first type parameter to <code class="sourceCode haskell"><span class="dt">ExprF</span></code>. The second is the output type of the algebra, and the third is the type of the fold required to produce that output type. The third type parameter <em>depends</em> on the case matched in the GADT. Using this, we can write a function which converts a fold/pattern match to a standard algebra:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">foldAlg ::</span> (forall f<span class="fu">.</span> <span class="dt">ExprI</span> a r f <span class="ot">-&gt;</span> f) <span class="ot">-&gt;</span> (<span class="dt">ExprF</span> a <span class="ot">-&gt;</span> r)</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">foldAlg f (<span class="dt">LitF</span> i)  <span class="fu">=</span> f <span class="dt">Lit</span> i</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">foldAlg f (x <span class="fu">:+:</span> y) <span class="fu">=</span> f <span class="dt">Add</span> x y</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">foldAlg f (x <span class="fu">:*:</span> y) <span class="fu">=</span> f <span class="dt">Mul</span> x y</a></code></pre></div>
<p>And finally, we can write the nice evaluation algebra:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">evalF ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">evalF <span class="fu">=</span> cata <span class="fu">$</span> foldAlg <span class="fu">$</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  <span class="dt">Lit</span> <span class="ot">-&gt;</span> id</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">  <span class="dt">Add</span> <span class="ot">-&gt;</span> (<span class="fu">+</span>)</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">  <span class="dt">Mul</span> <span class="ot">-&gt;</span> (<span class="fu">*</span>)</a></code></pre></div>
<p>I hacked together some quick template Haskell to generate the matchers over <a href="https://github.com/oisdk/pattern-folds">here</a>. It uses a class <code class="sourceCode haskell"><span class="dt">AsPatternFold</span></code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">class</span> <span class="dt">AsPatternFold</span> x f <span class="fu">|</span> x <span class="ot">-&gt;</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="ot">  foldMatch ::</span> (forall a<span class="fu">.</span> f r a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (x <span class="ot">-&gt;</span> r)</a></code></pre></div>
<p>And you generate the extra data type, with an instance, by doing this:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">makePatternFolds <span class="ch">&#39;&#39;</span><span class="dt">ExprF</span></a></code></pre></div>
<p>The code it generates can be used like this:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">evalF ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">evalF <span class="fu">=</span> cata <span class="fu">$</span> foldMatch <span class="fu">$</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  <span class="dt">LitI</span> <span class="ot">-&gt;</span> id</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">  (<span class="fu">:+|</span>) <span class="ot">-&gt;</span> (<span class="fu">+</span>)</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  (<span class="fu">:*|</span>) <span class="ot">-&gt;</span> (<span class="fu">*</span>)</a></code></pre></div>
<p>It‚Äôs terribly hacky at the moment, I may clean it up later.</p>
<h2 id="record-case">Record Case</h2>
<p>There‚Äôs another approach to the same idea that is slightly more sensible, using record wildcards. You define a handler for you datatype (an algebra):</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">data</span> <span class="dt">ExprAlg</span> a r</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">ExprAlg</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  {<span class="ot"> litF ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> r</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">  ,<span class="ot"> (+:) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> r</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">  ,<span class="ot"> (*:) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> r }</a></code></pre></div>
<p>Then, to use it, you define how to interact between the handler and the datatype, like before. The benefit is that record wildcard syntax allows you to piggy back on the function definition syntax, like so:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">data</span> <span class="dt">ExprF</span> a</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">LitF</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  <span class="fu">|</span> (<span class="fu">:+:</span>) a a</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">  <span class="fu">|</span> (<span class="fu">:*:</span>) a a</a>
<a class="sourceLine" id="cb11-5" data-line-number="5"></a>
<a class="sourceLine" id="cb11-6" data-line-number="6">makeHandler <span class="ch">&#39;&#39;</span><span class="dt">ExprF</span></a>
<a class="sourceLine" id="cb11-7" data-line-number="7"></a>
<a class="sourceLine" id="cb11-8" data-line-number="8"><span class="ot">exprAlg ::</span> <span class="dt">ExprF</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb11-9" data-line-number="9">exprAlg <span class="fu">=</span> index <span class="dt">ExprFAlg</span> {<span class="fu">..</span>} <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-10" data-line-number="10">  litF <span class="fu">=</span> id</a>
<a class="sourceLine" id="cb11-11" data-line-number="11">  (<span class="fu">+:</span>) <span class="fu">=</span> (<span class="fu">+</span>)</a>
<a class="sourceLine" id="cb11-12" data-line-number="12">  (<span class="fu">*:</span>) <span class="fu">=</span> (<span class="fu">*</span>)</a></code></pre></div>
<p>This approach is much more principled: the <code class="sourceCode haskell">index</code> function, for example, comes from the <a href="https://hackage.haskell.org/package/adjunctions">adjunctions</a> package, from the <a href="https://hackage.haskell.org/package/adjunctions-4.3/docs/Data-Functor-Rep.html"><code class="sourceCode haskell"><span class="dt">Representable</span></code></a> class. That‚Äôs because those algebras are actually representable functors, with their representation being the thing they match. They also conform to a whole bunch of things automatically, letting you combine them interesting ways.</p>
<h2 id="printing-expressions">Printing Expressions</h2>
<p>Properly printing expressions, with minimal parentheses, is a surprisingly difficult problem. <span class="citation" data-cites="ramsey_unparsing_1998">Ramsey (<a href="#ref-ramsey_unparsing_1998">1998</a>)</span> provides a solution of the form:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1">isParens side (<span class="dt">Assoc</span> ao po) (<span class="dt">Assoc</span> ai pi) <span class="fu">=</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">  pi <span class="fu">&lt;=</span> po <span class="fu">&amp;&amp;</span> (pi <span class="fu">/=</span> po <span class="fu">||</span> ai <span class="fu">/=</span> ao <span class="fu">||</span> ao <span class="fu">/=</span> side)</a></code></pre></div>
<p>Using this, we can write an algebra for printing expressions. It should work in the general case, not just on the expression type defined above, so we need to make another unfixed functor to describe the printing of an expression:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Side</span> <span class="fu">=</span> <span class="dt">L</span> <span class="fu">|</span> <span class="dt">R</span> <span class="kw">deriving</span> <span class="dt">Eq</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2"></a>
<a class="sourceLine" id="cb13-3" data-line-number="3"><span class="kw">data</span> <span class="dt">ShowExpr</span> t e</a>
<a class="sourceLine" id="cb13-4" data-line-number="4">  <span class="fu">=</span> <span class="dt">ShowLit</span> {<span class="ot"> _repr ::</span> t }</a>
<a class="sourceLine" id="cb13-5" data-line-number="5">  <span class="fu">|</span> <span class="dt">Prefix</span>  {<span class="ot"> _repr ::</span> t,<span class="ot"> _assoc ::</span> (<span class="dt">Int</span>,<span class="dt">Side</span>),<span class="ot"> _child  ::</span> e }</a>
<a class="sourceLine" id="cb13-6" data-line-number="6">  <span class="fu">|</span> <span class="dt">Postfix</span> {<span class="ot"> _repr ::</span> t,<span class="ot"> _assoc ::</span> (<span class="dt">Int</span>,<span class="dt">Side</span>),<span class="ot"> _child  ::</span> e }</a>
<a class="sourceLine" id="cb13-7" data-line-number="7">  <span class="fu">|</span> <span class="dt">Binary</span>  {<span class="ot"> _repr ::</span> t,<span class="ot"> _assoc ::</span> (<span class="dt">Int</span>,<span class="dt">Side</span>),<span class="ot"> _lchild ::</span> e</a>
<a class="sourceLine" id="cb13-8" data-line-number="8">                                              ,<span class="ot"> _rchild ::</span> e }</a>
<a class="sourceLine" id="cb13-9" data-line-number="9">  <span class="kw">deriving</span> <span class="dt">Functor</span></a>
<a class="sourceLine" id="cb13-10" data-line-number="10">  </a>
<a class="sourceLine" id="cb13-11" data-line-number="11">makeLenses <span class="ch">&#39;&#39;</span><span class="dt">ShowExpr</span></a></code></pre></div>
<p>The lenses are probably overkill. For printing, we need not only the precedence of the current level, but also the precedence one level below. Seems like the perfect case for a zygomorphism:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="ot">showExprAlg ::</span> <span class="dt">Semigroup</span> t</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">            <span class="ot">=&gt;</span> (t <span class="ot">-&gt;</span> t)</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">            <span class="ot">-&gt;</span> <span class="dt">ShowExpr</span> t (<span class="dt">Maybe</span> (<span class="dt">Int</span>,<span class="dt">Side</span>), t)</a>
<a class="sourceLine" id="cb14-4" data-line-number="4">            <span class="ot">-&gt;</span> t</a>
<a class="sourceLine" id="cb14-5" data-line-number="5">showExprAlg prns <span class="fu">=</span> \<span class="kw">case</span> </a>
<a class="sourceLine" id="cb14-6" data-line-number="6">    <span class="dt">ShowLit</span> t               <span class="ot">-&gt;</span>                   t</a>
<a class="sourceLine" id="cb14-7" data-line-number="7">    <span class="dt">Prefix</span>  t s       (q,y) <span class="ot">-&gt;</span>                   t <span class="fu">&lt;&gt;</span> ifPrns <span class="dt">R</span> s q y</a>
<a class="sourceLine" id="cb14-8" data-line-number="8">    <span class="dt">Postfix</span> t s (p,x)       <span class="ot">-&gt;</span> ifPrns <span class="dt">L</span> s p x <span class="fu">&lt;&gt;</span> t</a>
<a class="sourceLine" id="cb14-9" data-line-number="9">    <span class="dt">Binary</span>  t s (p,x) (q,y) <span class="ot">-&gt;</span> ifPrns <span class="dt">L</span> s p x <span class="fu">&lt;&gt;</span> t <span class="fu">&lt;&gt;</span> ifPrns <span class="dt">R</span> s q y</a>
<a class="sourceLine" id="cb14-10" data-line-number="10">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-11" data-line-number="11">    ifPrns sid (op,oa) (<span class="dt">Just</span> (ip,ia))</a>
<a class="sourceLine" id="cb14-12" data-line-number="12">      <span class="fu">|</span> ip <span class="fu">&lt;</span> op <span class="fu">||</span> ip <span class="fu">==</span> op <span class="fu">&amp;&amp;</span> (ia <span class="fu">/=</span> oa <span class="fu">||</span> sid <span class="fu">/=</span> oa) <span class="fu">=</span> prns</a>
<a class="sourceLine" id="cb14-13" data-line-number="13">    ifPrns _ _ _ <span class="fu">=</span> id</a></code></pre></div>
<p>The first argument to this algebra is the parenthesizing function. This algebra works fine for when the <code class="sourceCode haskell"><span class="dt">ShowExpr</span></code> type is already constructed:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="ot">showExpr&#39; ::</span> <span class="dt">Semigroup</span> t <span class="ot">=&gt;</span> (t <span class="ot">-&gt;</span> t) <span class="ot">-&gt;</span> <span class="dt">Fix</span> (<span class="dt">ShowExpr</span> t) <span class="ot">-&gt;</span> t</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">showExpr&#39; <span class="fu">=</span> zygo (preview assoc) <span class="fu">.</span> showExprAlg</a></code></pre></div>
<p>But we still need to construct the <code class="sourceCode haskell"><span class="dt">ShowExpr</span></code> from something else first. <code class="sourceCode haskell">hylo</code> might be a good fit:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="ot">hylo ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (f b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> f a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b</a></code></pre></div>
<p>But that performs a catamorphism after an anamorphism, and we want a zygomorphism after an anamorphism. Luckily, the <a href="https://hackage.haskell.org/package/recursion-schemes">recursion-schemes</a> library is constructed in such a way that different schemes can be stuck together relatively easily:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1">hylozygo</a>
<a class="sourceLine" id="cb17-2" data-line-number="2"><span class="ot">    ::</span> <span class="dt">Functor</span> f</a>
<a class="sourceLine" id="cb17-3" data-line-number="3">    <span class="ot">=&gt;</span> (f a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (f (a, b) <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> f c) <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb17-4" data-line-number="4">hylozygo x y z <span class="fu">=</span> ghylo (distZygo x) distAna y (fmap <span class="dt">Identity</span> <span class="fu">.</span> z)</a>
<a class="sourceLine" id="cb17-5" data-line-number="5"></a>
<a class="sourceLine" id="cb17-6" data-line-number="6"><span class="ot">showExpr ::</span> <span class="dt">Semigroup</span> t</a>
<a class="sourceLine" id="cb17-7" data-line-number="7">         <span class="ot">=&gt;</span> (t <span class="ot">-&gt;</span> t)</a>
<a class="sourceLine" id="cb17-8" data-line-number="8">         <span class="ot">-&gt;</span> (e <span class="ot">-&gt;</span> <span class="dt">ShowExpr</span> t e)</a>
<a class="sourceLine" id="cb17-9" data-line-number="9">         <span class="ot">-&gt;</span> e <span class="ot">-&gt;</span> t</a>
<a class="sourceLine" id="cb17-10" data-line-number="10">showExpr <span class="fu">=</span> hylozygo (preview assoc) <span class="fu">.</span> showExprAlg</a></code></pre></div>
<p>Let‚Äôs try it out, with a right-associative operator this time to make things more difficult:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="kw">data</span> <span class="dt">ExprF</span> a</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">LitF</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3">  <span class="fu">|</span> (<span class="fu">:+:</span>) a a</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">  <span class="fu">|</span> (<span class="fu">:*:</span>) a a</a>
<a class="sourceLine" id="cb18-5" data-line-number="5">  <span class="fu">|</span> (<span class="fu">:^:</span>) a a</a>
<a class="sourceLine" id="cb18-6" data-line-number="6">  <span class="kw">deriving</span> <span class="dt">Functor</span></a>
<a class="sourceLine" id="cb18-7" data-line-number="7"></a>
<a class="sourceLine" id="cb18-8" data-line-number="8">makeHandler <span class="ch">&#39;&#39;</span><span class="dt">ExprF</span></a>
<a class="sourceLine" id="cb18-9" data-line-number="9"></a>
<a class="sourceLine" id="cb18-10" data-line-number="10"><span class="kw">newtype</span> <span class="dt">Expr</span> <span class="fu">=</span> <span class="dt">Expr</span> {<span class="ot"> runExpr ::</span> <span class="dt">ExprF</span> <span class="dt">Expr</span> }</a>
<a class="sourceLine" id="cb18-11" data-line-number="11"></a>
<a class="sourceLine" id="cb18-12" data-line-number="12"><span class="kw">instance</span> <span class="dt">Num</span> <span class="dt">Expr</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-13" data-line-number="13">  fromInteger <span class="fu">=</span> <span class="dt">Expr</span> <span class="fu">.</span> <span class="dt">LitF</span></a>
<a class="sourceLine" id="cb18-14" data-line-number="14">  x <span class="fu">+</span> y <span class="fu">=</span> <span class="dt">Expr</span> (x <span class="fu">:+:</span> y)</a>
<a class="sourceLine" id="cb18-15" data-line-number="15">  x <span class="fu">*</span> y <span class="fu">=</span> <span class="dt">Expr</span> (x <span class="fu">:*:</span> y)</a>
<a class="sourceLine" id="cb18-16" data-line-number="16">  </a>
<a class="sourceLine" id="cb18-17" data-line-number="17"><span class="kw">infixr</span> <span class="dv">8</span> <span class="fu">^*</span></a>
<a class="sourceLine" id="cb18-18" data-line-number="18"><span class="ot">(^*) ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></a>
<a class="sourceLine" id="cb18-19" data-line-number="19">x <span class="fu">^*</span> y <span class="fu">=</span> <span class="dt">Expr</span> (x <span class="fu">:^:</span> y)</a>
<a class="sourceLine" id="cb18-20" data-line-number="20"></a>
<a class="sourceLine" id="cb18-21" data-line-number="21"><span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Expr</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-22" data-line-number="22">  show <span class="fu">=</span></a>
<a class="sourceLine" id="cb18-23" data-line-number="23">    showExpr</a>
<a class="sourceLine" id="cb18-24" data-line-number="24">      (\x <span class="ot">-&gt;</span> <span class="st">&quot;(&quot;</span> <span class="fu">++</span> x <span class="fu">++</span> <span class="st">&quot;)&quot;</span>)</a>
<a class="sourceLine" id="cb18-25" data-line-number="25">      (index <span class="dt">ExprFAlg</span> {<span class="fu">..</span>} <span class="fu">.</span> runExpr)</a>
<a class="sourceLine" id="cb18-26" data-line-number="26">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-27" data-line-number="27">      litF <span class="fu">=</span> <span class="dt">ShowLit</span> <span class="fu">.</span> show</a>
<a class="sourceLine" id="cb18-28" data-line-number="28">      (<span class="fu">+:</span>) <span class="fu">=</span> <span class="dt">Binary</span> <span class="st">&quot; + &quot;</span> (<span class="dv">6</span>,<span class="dt">L</span>)</a>
<a class="sourceLine" id="cb18-29" data-line-number="29">      (<span class="fu">*:</span>) <span class="fu">=</span> <span class="dt">Binary</span> <span class="st">&quot; * &quot;</span> (<span class="dv">7</span>,<span class="dt">L</span>)</a>
<a class="sourceLine" id="cb18-30" data-line-number="30">      (<span class="fu">^:</span>) <span class="fu">=</span> <span class="dt">Binary</span> <span class="st">&quot; ^ &quot;</span> (<span class="dv">8</span>,<span class="dt">R</span>)</a></code></pre></div>
<p>Since we only specified <code class="sourceCode haskell"><span class="dt">Semigroup</span></code> in the definition of <code class="sourceCode haskell">showExpr</code>, we can use the more efficient difference-list definition of <code class="sourceCode haskell"><span class="dt">Show</span></code>:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Expr</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-2" data-line-number="2">    showsPrec _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb19-3" data-line-number="3">      appEndo <span class="fu">.</span> showExpr</a>
<a class="sourceLine" id="cb19-4" data-line-number="4">        (<span class="dt">Endo</span> <span class="fu">.</span> showParen <span class="dt">True</span> <span class="fu">.</span> appEndo)</a>
<a class="sourceLine" id="cb19-5" data-line-number="5">        (index <span class="dt">ExprFAlg</span> {<span class="fu">..</span>} <span class="fu">.</span> runExpr)</a>
<a class="sourceLine" id="cb19-6" data-line-number="6">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-7" data-line-number="7">        litF <span class="fu">=</span> <span class="dt">ShowLit</span> <span class="fu">.</span> <span class="dt">Endo</span> <span class="fu">.</span> shows</a>
<a class="sourceLine" id="cb19-8" data-line-number="8">        (<span class="fu">+:</span>) <span class="fu">=</span> <span class="dt">Binary</span> (<span class="dt">Endo</span> (<span class="st">&quot; + &quot;</span> <span class="fu">++</span>)) (<span class="dv">6</span>,<span class="dt">L</span>)</a>
<a class="sourceLine" id="cb19-9" data-line-number="9">        (<span class="fu">*:</span>) <span class="fu">=</span> <span class="dt">Binary</span> (<span class="dt">Endo</span> (<span class="st">&quot; * &quot;</span> <span class="fu">++</span>)) (<span class="dv">7</span>,<span class="dt">L</span>)</a>
<a class="sourceLine" id="cb19-10" data-line-number="10">        (<span class="fu">^:</span>) <span class="fu">=</span> <span class="dt">Binary</span> (<span class="dt">Endo</span> (<span class="st">&quot; ^ &quot;</span> <span class="fu">++</span>)) (<span class="dv">8</span>,<span class="dt">R</span>)</a>
<a class="sourceLine" id="cb19-11" data-line-number="11"></a>
<a class="sourceLine" id="cb19-12" data-line-number="12"><span class="dv">1</span> <span class="fu">^*</span> <span class="dv">2</span> <span class="fu">^*</span> <span class="dv">3</span>         <span class="co">-- 1 ^ 2 ^ 3</span></a>
<a class="sourceLine" id="cb19-13" data-line-number="13">(<span class="dv">1</span> <span class="fu">^*</span> <span class="dv">2</span>) <span class="fu">^*</span> <span class="dv">3</span>       <span class="co">-- (1 ^ 2) ^ 3</span></a>
<a class="sourceLine" id="cb19-14" data-line-number="14"><span class="dv">1</span> <span class="fu">*</span> <span class="dv">2</span> <span class="fu">+</span> <span class="dv">3</span><span class="ot">   ::</span> <span class="dt">Expr</span> <span class="co">-- 1 * 2 + 3</span></a>
<a class="sourceLine" id="cb19-15" data-line-number="15"><span class="dv">1</span> <span class="fu">*</span> (<span class="dv">2</span> <span class="fu">+</span> <span class="dv">3</span>)<span class="ot"> ::</span> <span class="dt">Expr</span> <span class="co">-- 1 * (2 + 3)</span></a></code></pre></div>
<div id="refs" class="references">
<div id="ref-ramsey_unparsing_1998">
<p>Ramsey, Norman. 1998. ‚ÄúUnparsing Expressions With Prefix and Postfix Operators.‚Äù <em>Software‚ÄîPractice &amp; Experience</em> 28 (12): 1327‚Äì1356. <a href="http://www.cs.tufts.edu/%7Enr/pubs/unparse-abstract.html">http://www.cs.tufts.edu/%7Enr/pubs/unparse-abstract.html</a>.</p>
</div>
</div>
]]></description>
    <pubDate>Thu, 30 Mar 2017 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2017-03-30-fun-with-recursion-schemes.html</guid>
    <dc:creator>Donnacha Ois√≠n Kidney</dc:creator>
</item>
<item>
    <title>Constrained Applicatives</title>
    <link>https://doisinkidney.com/posts/2017-03-08-constrained-applicatives.html</link>
    <description><![CDATA[<div class="info">
    Posted on March  8, 2017
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Applicative.html">Applicative</a>
    
</div>

<p>In Haskell restricted monads are monads which can‚Äôt contain every type. <code class="sourceCode haskell"><span class="dt">Set</span></code> is a good example. If you look in the documentation for <a href="https://hackage.haskell.org/package/containers-0.5.10.1/docs/Data-Set.html">Data.Set</a> you‚Äôll see several functions which correspond to functions in the Functor/Applicative/Monad typeclass hierarchy:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1">map<span class="ot"> ::</span> <span class="dt">Ord</span> b <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Set</span> a <span class="ot">-&gt;</span> <span class="dt">Set</span> b</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="ot">singleton ::</span> a <span class="ot">-&gt;</span> <span class="dt">Set</span> a</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">foldMap<span class="ot"> ::</span> <span class="dt">Ord</span> b <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Set</span> b) <span class="ot">-&gt;</span> <span class="dt">Set</span> a <span class="ot">-&gt;</span> <span class="dt">Set</span> b <span class="co">-- specialized</span></a></code></pre></div>
<p>Unfortunately, though, <code class="sourceCode haskell"><span class="dt">Set</span></code> can‚Äôt conform to <code class="sourceCode haskell"><span class="dt">Functor</span></code>, because the signature of <code class="sourceCode haskell">fmap</code> looks like this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1">fmap<span class="ot"> ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</a></code></pre></div>
<p>It doesn‚Äôt have an <code class="sourceCode haskell"><span class="dt">Ord</span></code> constraint.</p>
<p>This is annoying: when using <code class="sourceCode haskell"><span class="dt">Set</span></code>, lots of things have to be imported qualified, and you have to remember the slightly different names of extra functions like <code class="sourceCode haskell">map</code>. More importantly, you‚Äôve lost the ability to write generic code over <code class="sourceCode haskell"><span class="dt">Functor</span></code> or <code class="sourceCode haskell"><span class="dt">Monad</span></code> which will work on <code class="sourceCode haskell"><span class="dt">Set</span></code>.</p>
<p>There are a number of ways to get around this problem. <a href="http://okmij.org/ftp/Haskell/set-monad.html#set-cps">Here</a>, an approach using reflection-reification is explored. These are the types involved:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">SetC</span> a <span class="fu">=</span> </a>
<a class="sourceLine" id="cb3-2" data-line-number="2">       <span class="dt">SetC</span>{<span class="ot">unSetC ::</span> forall r<span class="fu">.</span> <span class="dt">Ord</span> r <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Set</span> r) <span class="ot">-&gt;</span> <span class="dt">Set</span> r}</a>
<a class="sourceLine" id="cb3-3" data-line-number="3"></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="ot">reifySet ::</span> <span class="dt">Ord</span> r <span class="ot">=&gt;</span> <span class="dt">SetC</span> r <span class="ot">-&gt;</span> <span class="dt">Set</span> r</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">reifySet m <span class="fu">=</span> unSetC m singleton</a>
<a class="sourceLine" id="cb3-6" data-line-number="6"></a>
<a class="sourceLine" id="cb3-7" data-line-number="7"><span class="ot">reflectSet ::</span> <span class="dt">Ord</span> r <span class="ot">=&gt;</span> <span class="dt">Set</span> r <span class="ot">-&gt;</span> <span class="dt">SetC</span> r</a>
<a class="sourceLine" id="cb3-8" data-line-number="8">reflectSet s <span class="fu">=</span> <span class="dt">SetC</span> <span class="fu">$</span> \k <span class="ot">-&gt;</span> S.foldr (\x r <span class="ot">-&gt;</span> k x <span class="ot">`union`</span> r) S.empty s</a></code></pre></div>
<p><code class="sourceCode haskell"><span class="dt">SetC</span></code> is just <code class="sourceCode haskell"><span class="dt">Cont</span></code> in disguise. In fact, we can generalize this pattern, using Constraint Kinds:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">FreeT</span> c m a <span class="fu">=</span> </a>
<a class="sourceLine" id="cb4-2" data-line-number="2">       <span class="dt">FreeT</span> {<span class="ot"> runFreeT ::</span> forall r<span class="fu">.</span> c r <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m r) <span class="ot">-&gt;</span> m r}</a>
<a class="sourceLine" id="cb4-3" data-line-number="3"></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="ot">reifySet ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">FreeT</span> <span class="dt">Ord</span> <span class="dt">Set</span> a <span class="ot">-&gt;</span> <span class="dt">Set</span> a</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">reifySet m <span class="fu">=</span> runFreeT m singleton</a>
<a class="sourceLine" id="cb4-6" data-line-number="6"></a>
<a class="sourceLine" id="cb4-7" data-line-number="7"><span class="ot">reflectSet ::</span> <span class="dt">Set</span> r <span class="ot">-&gt;</span> <span class="dt">FreeT</span> <span class="dt">Ord</span> <span class="dt">Set</span> r</a>
<a class="sourceLine" id="cb4-8" data-line-number="8">reflectSet s <span class="fu">=</span> <span class="dt">FreeT</span> <span class="fu">$</span> \k <span class="ot">-&gt;</span> S.foldr (\x r <span class="ot">-&gt;</span> k x <span class="ot">`union`</span> r) S.empty s</a></code></pre></div>
<p><code class="sourceCode haskell"><span class="dt">FreeT</span></code> looks an <em>awful lot</em> like <code class="sourceCode haskell"><span class="dt">ContT</span></code> by now. The type has some other interesting applications, though. For instance, this type:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">type</span> <span class="dt">FM</span> <span class="fu">=</span> <span class="dt">FreeT</span> <span class="dt">Monoid</span> <span class="dt">Identity</span></a></code></pre></div>
<p>Is the free monoid. If we use a transformers-style type synonym, the naming becomes even nicer:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Free</span> c <span class="fu">=</span> <span class="dt">FreeT</span> c <span class="dt">Identity</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="ot">runFree ::</span> c r <span class="ot">=&gt;</span> <span class="dt">Free</span> c a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">runFree xs f <span class="fu">=</span> runIdentity (runFreeT xs (pure <span class="fu">.</span> f))</a>
<a class="sourceLine" id="cb6-5" data-line-number="5"></a>
<a class="sourceLine" id="cb6-6" data-line-number="6"><span class="kw">instance</span> <span class="dt">Foldable</span> (<span class="dt">Free</span> <span class="dt">Monoid</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-7" data-line-number="7">  foldMap <span class="fu">=</span> flip runFree</a></code></pre></div>
<p>Check out <a href="https://hackage.haskell.org/package/free-functors">this package</a> for an implementation of the non-transformer <code class="sourceCode haskell"><span class="dt">Free</span></code>.</p>
<h2 id="different-classes">Different Classes</h2>
<p>This is still unsatisfying, though. Putting annotations around your code feels inelegant. The next solution is to replace the monad class altogether with our own, and turn on <code class="sourceCode haskell"><span class="fu">-</span><span class="dt">XRebindableSyntax</span></code>. There are a few ways to design this new class. One option is to use <a href="http://okmij.org/ftp/Haskell/types.html#restricted-datatypes">multi-parameter type classes</a>. Another solution is with an associated type:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  <span class="kw">type</span> <span class="dt">Suitable</span> f<span class="ot"> a ::</span> <span class="dt">Constraint</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="ot">  fmap ::</span> <span class="dt">Suitable</span> f b <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</a></code></pre></div>
<p>This is similar to the approach taken in the <a href="https://hackage.haskell.org/package/rmonad">rmonad</a> library, except that library doesn‚Äôt use constraint kinds (they weren‚Äôt available when the library was made), so it has to make do with a <code class="sourceCode haskell"><span class="dt">Suitable</span></code> class. Also, the signature for <code class="sourceCode haskell">fmap</code> in rmonad is:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">fmap<span class="ot"> ::</span> (<span class="dt">Suitable</span> f a, <span class="dt">Suitable</span> f b) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</a></code></pre></div>
<p>I don‚Äôt want to constrain <code class="sourceCode haskell">a</code>: I figure if you can get something <em>into</em> your monad, it <em>must</em> be suitable. And I really want to reduce the syntactic overhead of writing extra types next to your functions.</p>
<p>There‚Äôs also the <a href="https://hackage.haskell.org/package/supermonad-0.1/docs/Control-Supermonad-Constrained.html">supermonad</a> library out there which is much more general than any of these examples: it supports indexed monads as well as constrained.</p>
<p>Anyway,<code class="sourceCode haskell"><span class="dt">Monad</span></code> is defined similarly to <code class="sourceCode haskell"><span class="dt">Functor</span></code>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Functor</span> m <span class="ot">=&gt;</span> <span class="dt">Monad</span> m <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="ot">  return ::</span> <span class="dt">Suitable</span> m a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> m a</a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="ot">  (&gt;&gt;=) ::</span> <span class="dt">Suitable</span> m b <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b</a></code></pre></div>
<p>Again, I want to minimize the use of <code class="sourceCode haskell"><span class="dt">Suitable</span></code>, so for <code class="sourceCode haskell"><span class="fu">&gt;&gt;=</span></code> there‚Äôs only a constraint on <code class="sourceCode haskell">b</code>.</p>
<p>Finally, here‚Äôs the <code class="sourceCode haskell"><span class="dt">Set</span></code> instance:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">    <span class="kw">type</span> <span class="dt">Suitable</span> <span class="dt">Set</span> a <span class="fu">=</span> <span class="dt">Ord</span> a</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">    fmap <span class="fu">=</span> Set.map</a></code></pre></div>
<h2 id="monomorphic">Monomorphic</h2>
<p>With equality constraints, you can actually make <em>monomorphic</em> containers conform to these classes (or, at least, wrappers around them).</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2"></a>
<a class="sourceLine" id="cb11-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Text</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4">  <span class="dt">Text</span><span class="ot"> ::</span> <span class="dt">Text.Text</span> <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="dt">Char</span></a>
<a class="sourceLine" id="cb11-5" data-line-number="5"></a>
<a class="sourceLine" id="cb11-6" data-line-number="6"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Text</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-7" data-line-number="7">  <span class="kw">type</span> <span class="dt">Suitable</span> <span class="dt">Text</span> a <span class="fu">=</span> a <span class="fu">~</span> <span class="dt">Char</span></a>
<a class="sourceLine" id="cb11-8" data-line-number="8">  fmap f (<span class="dt">Text</span> xs) <span class="fu">=</span> <span class="dt">Text</span> (Text.map f xs)</a></code></pre></div>
<p>This pattern can be generalized with some more GADT magic:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Monomorphic</span> xs a b <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">        <span class="dt">Monomorphic</span><span class="ot"> ::</span> (a <span class="fu">~</span> b) <span class="ot">=&gt;</span> xs <span class="ot">-&gt;</span> <span class="dt">Monomorphic</span> xs a b</a>
<a class="sourceLine" id="cb12-3" data-line-number="3"></a>
<a class="sourceLine" id="cb12-4" data-line-number="4"><span class="kw">instance</span> (<span class="dt">MonoFunctor</span> xs, a <span class="fu">~</span> <span class="dt">Element</span> xs) <span class="ot">=&gt;</span> <span class="dt">Functor</span> (<span class="dt">Monomorphic</span> xs a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5">  <span class="kw">type</span> <span class="dt">Suitable</span> (<span class="dt">Monomorphic</span> xs a) b <span class="fu">=</span> a <span class="fu">~</span> b</a>
<a class="sourceLine" id="cb12-6" data-line-number="6">  fmap f (<span class="dt">Monomorphic</span> xs) <span class="fu">=</span> <span class="dt">Monomorphic</span> (omap f xs)</a></code></pre></div>
<p>Where <code class="sourceCode haskell">omap</code> comes from the <a href="https://hackage.haskell.org/package/mono-traversable">mono-traversable</a> package. You could go a little further, to <code class="sourceCode haskell"><span class="dt">Foldable</span></code>:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">instance</span> (<span class="dt">MonoFoldable</span> xs, element <span class="fu">~</span> <span class="dt">Element</span> xs) <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">         <span class="dt">Foldable</span> (<span class="dt">Monomorphic</span> xs element) <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">    foldr f b (<span class="dt">Monomorphic</span> xs) <span class="fu">=</span> ofoldr f b xs</a>
<a class="sourceLine" id="cb13-4" data-line-number="4">    foldMap f (<span class="dt">Monomorphic</span> xs) <span class="fu">=</span> ofoldMap f xs</a>
<a class="sourceLine" id="cb13-5" data-line-number="5">    foldl&#39; f b (<span class="dt">Monomorphic</span> xs) <span class="fu">=</span> ofoldl&#39; f b xs</a>
<a class="sourceLine" id="cb13-6" data-line-number="6">    toList (<span class="dt">Monomorphic</span> xs) <span class="fu">=</span> otoList xs</a>
<a class="sourceLine" id="cb13-7" data-line-number="7">    null (<span class="dt">Monomorphic</span> xs) <span class="fu">=</span> onull xs</a>
<a class="sourceLine" id="cb13-8" data-line-number="8">    length (<span class="dt">Monomorphic</span> xs) <span class="fu">=</span> olength xs</a>
<a class="sourceLine" id="cb13-9" data-line-number="9">    foldr1 f (<span class="dt">Monomorphic</span> xs) <span class="fu">=</span> ofoldr1Ex f xs</a>
<a class="sourceLine" id="cb13-10" data-line-number="10">    elem x (<span class="dt">Monomorphic</span> xs) <span class="fu">=</span> oelem x xs</a>
<a class="sourceLine" id="cb13-11" data-line-number="11">    maximum (<span class="dt">Monomorphic</span> xs) <span class="fu">=</span> maximumEx xs</a>
<a class="sourceLine" id="cb13-12" data-line-number="12">    minimum (<span class="dt">Monomorphic</span> xs) <span class="fu">=</span> minimumEx xs</a>
<a class="sourceLine" id="cb13-13" data-line-number="13">    sum (<span class="dt">Monomorphic</span> xs) <span class="fu">=</span> osum xs</a>
<a class="sourceLine" id="cb13-14" data-line-number="14">    product (<span class="dt">Monomorphic</span> xs) <span class="fu">=</span> oproduct xs</a></code></pre></div>
<h2 id="back-to-normal">Back to normal</h2>
<p>Changing the <code class="sourceCode haskell"><span class="dt">FreeT</span></code> type above a little, we can go back to normal functors and monads, and write more general reify and reflect functions:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">FreeT</span> m a <span class="fu">=</span> </a>
<a class="sourceLine" id="cb14-2" data-line-number="2">       <span class="dt">FreeT</span> {<span class="ot"> runFreeT ::</span> forall r<span class="fu">.</span> <span class="dt">Suitable</span> m r <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m r) <span class="ot">-&gt;</span> m r}</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">       </a>
<a class="sourceLine" id="cb14-4" data-line-number="4"><span class="ot">reify ::</span> (<span class="dt">Monad</span> m, <span class="dt">Suitable</span> m a) <span class="ot">=&gt;</span> <span class="dt">FreeT</span> m a <span class="ot">-&gt;</span> m a</a>
<a class="sourceLine" id="cb14-5" data-line-number="5">reify <span class="fu">=</span> flip runFreeT return</a>
<a class="sourceLine" id="cb14-6" data-line-number="6"></a>
<a class="sourceLine" id="cb14-7" data-line-number="7"><span class="ot">reflect ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> <span class="dt">FreeT</span> m a</a>
<a class="sourceLine" id="cb14-8" data-line-number="8">reflect x <span class="fu">=</span> <span class="dt">FreeT</span> (x <span class="fu">&gt;&gt;=</span>)</a></code></pre></div>
<p>So now our types, when wrapped, can conform to the Prelude‚Äôs <code class="sourceCode haskell"><span class="dt">Functor</span></code>. It would be nice if this type could be written like so:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="ot">reify ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">FreeT</span> (<span class="dt">Suitable</span> m) m a <span class="ot">-&gt;</span> m a</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">reify <span class="fu">=</span> flip runFreeT return</a>
<a class="sourceLine" id="cb15-3" data-line-number="3"></a>
<a class="sourceLine" id="cb15-4" data-line-number="4"><span class="ot">reflect ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> <span class="dt">FreeT</span> (<span class="dt">Suitable</span> m) m a</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">reflect x <span class="fu">=</span> <span class="dt">FreeT</span> (x <span class="fu">&gt;&gt;=</span>)</a></code></pre></div>
<p>But unfortunately type families cannot be partially applied.</p>
<h2 id="applicatives">Applicatives</h2>
<p>The classes above aren‚Äôt very modern: they‚Äôre missing applicative. This one is tricky:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Applicative</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2"><span class="ot">  pure ::</span> <span class="dt">Suitable</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb16-3" data-line-number="3"><span class="ot">  (&lt;*&gt;) ::</span> <span class="dt">Suitable</span> f b <span class="ot">=&gt;</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</a></code></pre></div>
<p>The issue is <code class="sourceCode haskell">f (a <span class="ot">-&gt;</span> b)</code>. There‚Äôs no <em>way</em> you‚Äôre getting some type like that into <code class="sourceCode haskell"><span class="dt">Set</span></code>. This means that <code class="sourceCode haskell"><span class="fu">&lt;*&gt;</span></code> is effectively useless. No problem, you think: define <code class="sourceCode haskell">liftA2</code> instead:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Applicative</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2"><span class="ot">  pure ::</span> <span class="dt">Suitable</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb17-3" data-line-number="3"><span class="ot">  liftA2 ::</span> <span class="dt">Suitable</span> f c <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f c</a>
<a class="sourceLine" id="cb17-4" data-line-number="4"></a>
<a class="sourceLine" id="cb17-5" data-line-number="5"><span class="ot">(&lt;*&gt;) ::</span> (<span class="dt">Applicative</span> f, <span class="dt">Suitable</span> f b) <span class="ot">=&gt;</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</a>
<a class="sourceLine" id="cb17-6" data-line-number="6">(<span class="fu">&lt;*&gt;</span>) <span class="fu">=</span> liftA2 (<span class="fu">$</span>)</a></code></pre></div>
<p>Great! Now we can use it with set. However, there‚Äôs no way (that I can see) to define the other lift functions: <code class="sourceCode haskell">liftA3</code>, etc. Of course, if <code class="sourceCode haskell"><span class="fu">&gt;&gt;=</span></code> is available, it‚Äôs as simple as:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1">liftA3 f xs ys zs <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2">  x <span class="ot">&lt;-</span> xs</a>
<a class="sourceLine" id="cb18-3" data-line-number="3">  y <span class="ot">&lt;-</span> ys</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">  z <span class="ot">&lt;-</span> zs</a>
<a class="sourceLine" id="cb18-5" data-line-number="5">  pure (f x y z)</a></code></pre></div>
<p>But now we can‚Äôt define it for non-monadic applicatives (square matrices, ZipLists, etc.). This also forces us to use <code class="sourceCode haskell"><span class="fu">&gt;&gt;=</span></code> when <code class="sourceCode haskell"><span class="fu">&lt;*&gt;</span></code> <a href="https://simonmar.github.io/posts/2015-10-20-Fun-With-Haxl-1.html">may have been more efficient</a>.</p>
<p>The functions we‚Äôre interested in defining look like this:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="ot">liftA2 ::</span> <span class="dt">Suitable</span> f c <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f c</a>
<a class="sourceLine" id="cb19-2" data-line-number="2"><span class="ot">liftA3 ::</span> <span class="dt">Suitable</span> f d <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f c <span class="ot">-&gt;</span> f d</a>
<a class="sourceLine" id="cb19-3" data-line-number="3"><span class="ot">liftA4 ::</span> <span class="dt">Suitable</span> f e <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> d <span class="ot">-&gt;</span> e) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f c <span class="ot">-&gt;</span> f d <span class="ot">-&gt;</span> f e</a></code></pre></div>
<p>There‚Äôs a clear pattern, but no obvious way to abstract over it. Type-level shenanigans to the rescue!</p>
<p>The pattern might be expressed like this:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="ot">liftA ::</span> <span class="dt">Func</span> args <span class="ot">-&gt;</span> <span class="dt">Func</span> lifted args</a></code></pre></div>
<p>We can store these types as heterogeneous lists:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:-</span></a>
<a class="sourceLine" id="cb21-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Vect</span> xs <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-3" data-line-number="3">  <span class="dt">Nil</span><span class="ot">  ::</span> <span class="dt">Vect</span> <span class="ch">&#39;[]</span></a>
<a class="sourceLine" id="cb21-4" data-line-number="4"><span class="ot">  (:-) ::</span> x <span class="ot">-&gt;</span> <span class="dt">Vect</span> xs <span class="ot">-&gt;</span> <span class="dt">Vect</span> (x <span class="ch">&#39;: xs)</span></a>
<a class="sourceLine" id="cb21-5" data-line-number="5"></a>
<a class="sourceLine" id="cb21-6" data-line-number="6"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:*</span></a>
<a class="sourceLine" id="cb21-7" data-line-number="7"><span class="kw">data</span> <span class="dt">AppVect</span> f xs <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-8" data-line-number="8">  <span class="dt">NilA</span><span class="ot"> ::</span> <span class="dt">AppVect</span> f <span class="ch">&#39;[]</span></a>
<a class="sourceLine" id="cb21-9" data-line-number="9"><span class="ot">  (:*) ::</span> f x <span class="ot">-&gt;</span> <span class="dt">AppVect</span> f xs <span class="ot">-&gt;</span> <span class="dt">AppVect</span> f (x <span class="ch">&#39;: xs)</span></a></code></pre></div>
<p>And <code class="sourceCode haskell">liftA</code> can be represented like this:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1">liftA</a>
<a class="sourceLine" id="cb22-2" data-line-number="2"><span class="ot">    ::</span> <span class="dt">Suitable</span> f b</a>
<a class="sourceLine" id="cb22-3" data-line-number="3">    <span class="ot">=&gt;</span> (<span class="dt">Vect</span> xs <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">AppVect</span> f xs <span class="ot">-&gt;</span> f b</a>
<a class="sourceLine" id="cb22-4" data-line-number="4"></a>
<a class="sourceLine" id="cb22-5" data-line-number="5">liftA2</a>
<a class="sourceLine" id="cb22-6" data-line-number="6"><span class="ot">    ::</span> <span class="dt">Suitable</span> f c</a>
<a class="sourceLine" id="cb22-7" data-line-number="7">    <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f c</a>
<a class="sourceLine" id="cb22-8" data-line-number="8">liftA2 f xs ys <span class="fu">=</span></a>
<a class="sourceLine" id="cb22-9" data-line-number="9">    liftA</a>
<a class="sourceLine" id="cb22-10" data-line-number="10">        (\(x <span class="fu">:-</span> y <span class="fu">:-</span> <span class="dt">Nil</span>) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb22-11" data-line-number="11">              f x y)</a>
<a class="sourceLine" id="cb22-12" data-line-number="12">        (xs <span class="fu">:*</span> ys <span class="fu">:*</span> <span class="dt">NilA</span>)</a>
<a class="sourceLine" id="cb22-13" data-line-number="13"></a>
<a class="sourceLine" id="cb22-14" data-line-number="14">liftA3</a>
<a class="sourceLine" id="cb22-15" data-line-number="15"><span class="ot">    ::</span> <span class="dt">Suitable</span> f d</a>
<a class="sourceLine" id="cb22-16" data-line-number="16">    <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f c <span class="ot">-&gt;</span> f d</a>
<a class="sourceLine" id="cb22-17" data-line-number="17">liftA3 f xs ys zs <span class="fu">=</span></a>
<a class="sourceLine" id="cb22-18" data-line-number="18">    liftA</a>
<a class="sourceLine" id="cb22-19" data-line-number="19">        (\(x <span class="fu">:-</span> y <span class="fu">:-</span> z <span class="fu">:-</span> <span class="dt">Nil</span>) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb22-20" data-line-number="20">              f x y z)</a>
<a class="sourceLine" id="cb22-21" data-line-number="21">        (xs <span class="fu">:*</span> ys <span class="fu">:*</span> zs <span class="fu">:*</span> <span class="dt">NilA</span>)</a></code></pre></div>
<p>Cool! For unrestricted applicatives, we can define <code class="sourceCode haskell">liftA</code> in terms of <code class="sourceCode haskell"><span class="fu">&lt;*&gt;</span></code>:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="ot">liftAP ::</span> (<span class="dt">Prelude.Applicative</span> f) </a>
<a class="sourceLine" id="cb23-2" data-line-number="2">       <span class="ot">=&gt;</span> (<span class="dt">Vect</span> xs <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (<span class="dt">AppVect</span> f xs <span class="ot">-&gt;</span> f b)</a>
<a class="sourceLine" id="cb23-3" data-line-number="3">liftAP f <span class="dt">NilA</span> <span class="fu">=</span> Prelude.pure (f <span class="dt">Nil</span>)</a>
<a class="sourceLine" id="cb23-4" data-line-number="4">liftAP f (x <span class="fu">:*</span> <span class="dt">NilA</span>) </a>
<a class="sourceLine" id="cb23-5" data-line-number="5">  <span class="fu">=</span> Prelude.fmap (f <span class="fu">.</span> (<span class="fu">:-</span><span class="dt">Nil</span>)) x</a>
<a class="sourceLine" id="cb23-6" data-line-number="6">liftAP f (x <span class="fu">:*</span> xs) </a>
<a class="sourceLine" id="cb23-7" data-line-number="7">  <span class="fu">=</span>  ((f <span class="fu">.</span>) <span class="fu">.</span> (<span class="fu">:-</span>)) <span class="fu">Prelude.&lt;$&gt;</span> x <span class="fu">Prelude.&lt;*&gt;</span> liftAP id xs</a></code></pre></div>
<p>And for types with a monad instance, we can define it in terms of <code class="sourceCode haskell"><span class="fu">&gt;&gt;=</span></code>:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="ot">liftAM ::</span> (<span class="dt">Monad</span> f, <span class="dt">Suitable</span> f b) </a>
<a class="sourceLine" id="cb24-2" data-line-number="2">       <span class="ot">=&gt;</span> (<span class="dt">Vect</span> xs <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (<span class="dt">AppVect</span> f xs <span class="ot">-&gt;</span> f b)</a>
<a class="sourceLine" id="cb24-3" data-line-number="3">liftAM f <span class="dt">NilA</span> <span class="fu">=</span> pure (f <span class="dt">Nil</span>)</a>
<a class="sourceLine" id="cb24-4" data-line-number="4">liftAM f (x <span class="fu">:*</span> <span class="dt">NilA</span>) <span class="fu">=</span> fmap (f <span class="fu">.</span> (<span class="fu">:-</span><span class="dt">Nil</span>)) x</a>
<a class="sourceLine" id="cb24-5" data-line-number="5">liftAM f (x <span class="fu">:*</span> xs) <span class="fu">=</span> x <span class="fu">&gt;&gt;=</span> \y <span class="ot">-&gt;</span> liftAM (f <span class="fu">.</span> (y<span class="fu">:-</span>)) xs</a></code></pre></div>
<h2 id="efficiency">Efficiency</h2>
<p>This approach is <em>really</em> slow. Every function wraps up its arguments in a <code class="sourceCode haskell"><span class="dt">Vect</span></code>, and it‚Äôs just generally awful.</p>
<p>What about <em>not</em> wrapping up the function? Type families can help here:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">FunType</span> (<span class="ot">xs ::</span> [<span class="fu">*</span>]) (<span class="ot">y ::</span> <span class="fu">*</span>)<span class="ot"> ::</span> <span class="fu">*</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-2" data-line-number="2">  <span class="dt">FunType</span> <span class="ch">&#39;[] y = y</span></a>
<a class="sourceLine" id="cb25-3" data-line-number="3">  <span class="dt">FunType</span> (x <span class="ch">&#39;: xs) y = x -&gt; FunType xs y</span></a></code></pre></div>
<p>It gets really difficult to define <code class="sourceCode haskell">liftA</code> using <code class="sourceCode haskell"><span class="fu">&lt;*&gt;</span></code> now, though. <code class="sourceCode haskell">liftAM</code>, on the other hand, is a breeze:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="ot">liftAM ::</span> <span class="dt">Monad</span> f <span class="ot">=&gt;</span> <span class="dt">FunType</span> xs a <span class="ot">-&gt;</span> <span class="dt">AppVect</span> f xs <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb26-2" data-line-number="2">liftAM f <span class="dt">Nil</span> <span class="fu">=</span> pure f</a>
<a class="sourceLine" id="cb26-3" data-line-number="3">liftAM f (x <span class="fu">:&lt;</span> xs) <span class="fu">=</span> x <span class="fu">&gt;&gt;=</span> \y <span class="ot">-&gt;</span> liftAM (f y) xs</a></code></pre></div>
<p>And no vector constructors on the right of the bind!</p>
<p>Still, no decent definition using <code class="sourceCode haskell"><span class="fu">&lt;*&gt;</span></code>. The problem is that we‚Äôre using a cons-list to represent a function‚Äôs arguments, but <code class="sourceCode haskell"><span class="fu">&lt;*&gt;</span></code> is left-associative, so it builds up arguments as a snoc list. Lets try using a snoc-list as the type family:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="kw">infixl</span> <span class="dv">5</span> <span class="fu">:&gt;</span></a>
<a class="sourceLine" id="cb27-2" data-line-number="2"><span class="kw">data</span> <span class="dt">AppVect</span> f xs <span class="kw">where</span></a>
<a class="sourceLine" id="cb27-3" data-line-number="3">  <span class="dt">Nil</span><span class="ot"> ::</span> <span class="dt">AppVect</span> f <span class="ch">&#39;[]</span></a>
<a class="sourceLine" id="cb27-4" data-line-number="4"><span class="ot">  (:&gt;) ::</span> <span class="dt">AppVect</span> f xs <span class="ot">-&gt;</span> f x <span class="ot">-&gt;</span> <span class="dt">AppVect</span> f (x <span class="ch">&#39;: xs)</span></a>
<a class="sourceLine" id="cb27-5" data-line-number="5"></a>
<a class="sourceLine" id="cb27-6" data-line-number="6"><span class="kw">type</span> family <span class="dt">FunType</span> (<span class="ot">xs ::</span> [<span class="fu">*</span>]) (<span class="ot">y ::</span> <span class="fu">*</span>)<span class="ot"> ::</span> <span class="fu">*</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb27-7" data-line-number="7">  <span class="dt">FunType</span> <span class="ch">&#39;[] y = y</span></a>
<a class="sourceLine" id="cb27-8" data-line-number="8">  <span class="dt">FunType</span> (x <span class="ch">&#39;: xs) y = FunType xs (x -&gt; y)</span></a>
<a class="sourceLine" id="cb27-9" data-line-number="9"></a>
<a class="sourceLine" id="cb27-10" data-line-number="10">liftA</a>
<a class="sourceLine" id="cb27-11" data-line-number="11"><span class="ot">    ::</span> <span class="dt">Suitable</span> f a</a>
<a class="sourceLine" id="cb27-12" data-line-number="12">    <span class="ot">=&gt;</span> <span class="dt">FunType</span> xs a <span class="ot">-&gt;</span> <span class="dt">AppVect</span> f xs <span class="ot">-&gt;</span> f a</a></code></pre></div>
<p><code class="sourceCode haskell">liftAP</code> now gets a natural definition:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1"><span class="ot">liftAP ::</span> <span class="dt">Prelude.Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">FunType</span> xs a <span class="ot">-&gt;</span> <span class="dt">AppVect</span> f xs <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb28-2" data-line-number="2">liftAP f <span class="dt">Nil</span> <span class="fu">=</span> Prelude.pure f</a>
<a class="sourceLine" id="cb28-3" data-line-number="3">liftAP f (<span class="dt">Nil</span> <span class="fu">:&gt;</span> xs) <span class="fu">=</span> Prelude.fmap f xs</a>
<a class="sourceLine" id="cb28-4" data-line-number="4">liftAP f (ys <span class="fu">:&gt;</span> xs) <span class="fu">=</span> liftAP f ys <span class="fu">Prelude.&lt;*&gt;</span> xs</a></code></pre></div>
<p>But what about <code class="sourceCode haskell">liftAM</code>? It‚Äôs much more difficult, fundamentally because <code class="sourceCode haskell"><span class="fu">&gt;&gt;=</span></code> builds up arguments as a cons-list. To convert between the two efficiently, we need to use the trick for reversing lists efficiently: build up the reversed list as you go.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" data-line-number="1"><span class="ot">liftAM ::</span> (<span class="dt">Monad</span> f, <span class="dt">Suitable</span> f a) <span class="ot">=&gt;</span> <span class="dt">FunType</span> xs a <span class="ot">-&gt;</span> <span class="dt">AppVect</span> f xs <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb29-2" data-line-number="2">liftAM <span class="fu">=</span> go pure <span class="kw">where</span></a>
<a class="sourceLine" id="cb29-3" data-line-number="3"><span class="ot">  go ::</span> (<span class="dt">Suitable</span> f b, <span class="dt">Monad</span> f) </a>
<a class="sourceLine" id="cb29-4" data-line-number="4">     <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> <span class="dt">FunType</span> xs a <span class="ot">-&gt;</span> <span class="dt">AppVect</span> f xs <span class="ot">-&gt;</span> f b</a>
<a class="sourceLine" id="cb29-5" data-line-number="5">  go f g <span class="dt">Nil</span> <span class="fu">=</span> f g</a>
<a class="sourceLine" id="cb29-6" data-line-number="6">  go f g (xs <span class="fu">:&gt;</span> x) <span class="fu">=</span> go (\c <span class="ot">-&gt;</span> x <span class="fu">&gt;&gt;=</span> f <span class="fu">.</span> c) g xs</a></code></pre></div>
<p>Using these definitions, we can make <code class="sourceCode haskell"><span class="dt">Set</span></code>, <code class="sourceCode haskell"><span class="dt">Text</span></code>, and all the rest of them applicatives, while preserving the applicative operations. Also, from my preliminary testing, there seems to be <em>no</em> overhead in using these new definitions for <code class="sourceCode haskell"><span class="fu">&lt;*&gt;</span></code>.</p>
<h2 id="normalized-embedding">Normalized Embedding</h2>
<p>In <span class="citation" data-cites="sculthorpe_constrained-monad_2013">Sculthorpe et al. (<a href="#ref-sculthorpe_constrained-monad_2013">2013</a>)</span>, there‚Äôs discussion of this type:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="kw">data</span> <span class="dt">NM</span><span class="ot"> ::</span> (<span class="fu">*</span> <span class="ot">-&gt;</span> <span class="dt">Constraint</span>) <span class="ot">-&gt;</span> (<span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-2" data-line-number="2">  <span class="dt">Return</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">NM</span> c t a</a>
<a class="sourceLine" id="cb30-3" data-line-number="3">  <span class="dt">Bind</span><span class="ot"> ::</span> c x <span class="ot">=&gt;</span> t x <span class="ot">-&gt;</span> (x <span class="ot">-&gt;</span> <span class="dt">NM</span> c t a) <span class="ot">-&gt;</span> <span class="dt">NM</span> c t a</a></code></pre></div>
<p>This type allows constrained monads to become normal monads. It can be used for the same purpose as the <code class="sourceCode haskell"><span class="dt">FreeT</span></code> type from above. In the paper, the free type is called <code class="sourceCode haskell"><span class="dt">RCodT</span></code>.</p>
<p>One way to look at the type is as a concrete representation of the monad class, with each method being a constructor.</p>
<p>You might wonder if there are similar constructs for functor and applicative. Functor is simple:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" data-line-number="1"><span class="kw">data</span> <span class="dt">NF</span><span class="ot"> ::</span> (<span class="fu">*</span> <span class="ot">-&gt;</span> <span class="dt">Constraint</span>) <span class="ot">-&gt;</span> (<span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb31-2" data-line-number="2">  <span class="dt">FMap</span><span class="ot"> ::</span> c x <span class="ot">=&gt;</span> (x <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> t x <span class="ot">-&gt;</span> <span class="dt">NF</span> c t a</a></code></pre></div>
<p>Again, this can conform to functor (and <em>only</em> functor), and can be interpreted when the final type is <code class="sourceCode haskell"><span class="dt">Suitable</span></code>.</p>
<p>Like above, it has a continuation version, <a href="https://hackage.haskell.org/package/kan-extensions-5.0.1/docs/Data-Functor-Yoneda.html">Yoneda</a>.</p>
<p>For applicatives, though, the situation is different. In the paper, they weren‚Äôt able to define a transformer for applicatives that could be interpreted in some restricted applicative. I needed one because I wanted to use <code class="sourceCode haskell"><span class="fu">-</span><span class="dt">XApplicativeDo</span></code> notation: the desugaring uses <code class="sourceCode haskell"><span class="fu">&lt;*&gt;</span></code>, not the <code class="sourceCode haskell">liftAn</code> functions, so I wanted to construct a free applicative using <code class="sourceCode haskell"><span class="fu">&lt;*&gt;</span></code>, and run it using the lift functions. What I managed to cobble to gether doesn‚Äôt <em>really</em> solve the problem, but it works for <code>-XApplicativeDo</code>!</p>
<p>The key with a lot of this was realizing that <code class="sourceCode haskell"><span class="fu">&lt;*&gt;</span></code> is <em>snoc</em>, not cons. Using a <a href="https://ro-che.info/articles/2013-03-31-flavours-of-free-applicative-functors">free applicative</a>:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Free</span> f a <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-2" data-line-number="2">  <span class="dt">Pure</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Free</span> f a</a>
<a class="sourceLine" id="cb32-3" data-line-number="3">  <span class="dt">Ap</span><span class="ot"> ::</span> <span class="dt">Free</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Free</span> f b</a>
<a class="sourceLine" id="cb32-4" data-line-number="4"></a>
<a class="sourceLine" id="cb32-5" data-line-number="5"><span class="kw">instance</span> <span class="dt">Prelude.Functor</span> (<span class="dt">Free</span> f) <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-6" data-line-number="6">  fmap f (<span class="dt">Pure</span> a) <span class="fu">=</span> <span class="dt">Pure</span> (f a)</a>
<a class="sourceLine" id="cb32-7" data-line-number="7">  fmap f (<span class="dt">Ap</span> x y) <span class="fu">=</span> <span class="dt">Ap</span> ((f <span class="fu">.</span>) <span class="fu">Prelude.&lt;$&gt;</span> x) y</a>
<a class="sourceLine" id="cb32-8" data-line-number="8"></a>
<a class="sourceLine" id="cb32-9" data-line-number="9"><span class="kw">instance</span> <span class="dt">Prelude.Applicative</span> (<span class="dt">Free</span> f) <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-10" data-line-number="10">  pure <span class="fu">=</span> <span class="dt">Pure</span></a>
<a class="sourceLine" id="cb32-11" data-line-number="11">  <span class="dt">Pure</span> f <span class="fu">&lt;*&gt;</span> y <span class="fu">=</span> Prelude.fmap f y</a>
<a class="sourceLine" id="cb32-12" data-line-number="12">  <span class="dt">Ap</span> x y <span class="fu">&lt;*&gt;</span> z <span class="fu">=</span> <span class="dt">Ap</span> (flip <span class="fu">Prelude.&lt;$&gt;</span> x <span class="fu">Prelude.&lt;*&gt;</span> z) y</a></code></pre></div>
<p>This type can conform to <code class="sourceCode haskell"><span class="dt">Applicative</span></code> and <code class="sourceCode haskell"><span class="dt">Functor</span></code> no problem. And all it needs to turn back into a constrained applicative is for the outer type to be suitable:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" data-line-number="1"><span class="ot">lift ::</span> f a <span class="ot">-&gt;</span> <span class="dt">Free</span> f a</a>
<a class="sourceLine" id="cb33-2" data-line-number="2">lift <span class="fu">=</span> <span class="dt">Ap</span> (<span class="dt">Pure</span> id)</a>
<a class="sourceLine" id="cb33-3" data-line-number="3"></a>
<a class="sourceLine" id="cb33-4" data-line-number="4">lower</a>
<a class="sourceLine" id="cb33-5" data-line-number="5"><span class="ot">    ::</span> forall f a c<span class="fu">.</span></a>
<a class="sourceLine" id="cb33-6" data-line-number="6">       <span class="dt">Free</span> f a</a>
<a class="sourceLine" id="cb33-7" data-line-number="7">    <span class="ot">-&gt;</span> (forall xs<span class="fu">.</span> <span class="dt">FunType</span> xs a <span class="ot">-&gt;</span> <span class="dt">AppVect</span> f xs <span class="ot">-&gt;</span> f c)</a>
<a class="sourceLine" id="cb33-8" data-line-number="8">    <span class="ot">-&gt;</span> f c</a>
<a class="sourceLine" id="cb33-9" data-line-number="9">lower (<span class="dt">Pure</span> x) f <span class="fu">=</span> f x <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb33-10" data-line-number="10">lower (<span class="dt">Ap</span> fs<span class="ot"> x ::</span> <span class="dt">Free</span> f a) f <span class="fu">=</span></a>
<a class="sourceLine" id="cb33-11" data-line-number="11">    lower fs (\ft av <span class="ot">-&gt;</span> f ft (av <span class="fu">:&gt;</span> x))</a>
<a class="sourceLine" id="cb33-12" data-line-number="12"></a>
<a class="sourceLine" id="cb33-13" data-line-number="13">lowerConstrained</a>
<a class="sourceLine" id="cb33-14" data-line-number="14"><span class="ot">    ::</span> (<span class="dt">Constrained.Applicative</span> f, <span class="dt">Suitable</span> f a)</a>
<a class="sourceLine" id="cb33-15" data-line-number="15">    <span class="ot">=&gt;</span> <span class="dt">Free</span> f a <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb33-16" data-line-number="16">lowerConstrained x <span class="fu">=</span> lower x liftA</a></code></pre></div>
<p>There‚Äôs probably a more efficient way to encode it, though.</p>
<div id="refs" class="references">
<div id="ref-sculthorpe_constrained-monad_2013">
<p>Sculthorpe, Neil, Jan Bracker, George Giorgidze, and Andy Gill. 2013. ‚ÄúThe Constrained-monad Problem.‚Äù In <em>Proceedings of the 18th ACM SIGPLAN International Conference on Functional Programming</em>, 287‚Äì298. ICFP ‚Äô13. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/2500365.2500602">10.1145/2500365.2500602</a>. <a href="http://ku-fpg.github.io/files/Sculthorpe-13-ConstrainedMonad.pdf" class="uri">http://ku-fpg.github.io/files/Sculthorpe-13-ConstrainedMonad.pdf</a>.</p>
</div>
</div>
]]></description>
    <pubDate>Wed, 08 Mar 2017 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2017-03-08-constrained-applicatives.html</guid>
    <dc:creator>Donnacha Ois√≠n Kidney</dc:creator>
</item>
<item>
    <title>Semirings</title>
    <link>https://doisinkidney.com/posts/2016-11-17-semirings-lhs.html</link>
    <description><![CDATA[<div class="info">
    Posted on November 17, 2016
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Semirings.html">Semirings</a>
    
</div>

<div class="sourceCode" id="cb1"><pre class="sourceCode haskell literate hidden_source"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving, TypeFamilies #-}</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="ot">{-# LANGUAGE DeriveFunctor, DeriveFoldable, DeriveTraversable #-}</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="ot">{-# LANGUAGE PatternSynonyms, ViewPatterns, LambdaCase #-}</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="ot">{-# LANGUAGE RankNTypes, FlexibleInstances, FlexibleContexts #-}</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="ot">{-# LANGUAGE OverloadedStrings, OverloadedLists, MonadComprehensions #-}</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="kw">module</span> <span class="dt">Semirings</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"></a>
<a class="sourceLine" id="cb1-9" data-line-number="9"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map.Strict</span> <span class="kw">as</span> <span class="dt">Map</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10"><span class="kw">import</span>           <span class="dt">Data.Map.Strict</span>      (<span class="dt">Map</span>)</a>
<a class="sourceLine" id="cb1-11" data-line-number="11"><span class="kw">import</span>           <span class="dt">Data.Monoid</span>  <span class="kw">hiding</span>  (<span class="dt">Endo</span>(..))</a>
<a class="sourceLine" id="cb1-12" data-line-number="12"><span class="kw">import</span>           <span class="dt">Data.Foldable</span> <span class="kw">hiding</span> (toList)</a>
<a class="sourceLine" id="cb1-13" data-line-number="13"><span class="kw">import</span>           <span class="dt">Control.Applicative</span></a>
<a class="sourceLine" id="cb1-14" data-line-number="14"><span class="kw">import</span>           <span class="dt">Control.Arrow</span>        (first)</a>
<a class="sourceLine" id="cb1-15" data-line-number="15"><span class="kw">import</span>           <span class="dt">Control.Monad.Cont</span></a>
<a class="sourceLine" id="cb1-16" data-line-number="16"><span class="kw">import</span>           <span class="dt">Data.Functor.Identity</span></a>
<a class="sourceLine" id="cb1-17" data-line-number="17"><span class="kw">import</span>           <span class="dt">GHC.Exts</span></a>
<a class="sourceLine" id="cb1-18" data-line-number="18"><span class="kw">import</span>           <span class="dt">Data.List</span> <span class="kw">hiding</span>     (insert)</a>
<a class="sourceLine" id="cb1-19" data-line-number="19"><span class="kw">import</span>           <span class="dt">Data.Maybe</span>           (mapMaybe)</a></code></pre></div>
<p>I‚Äôve been playing around a lot with semirings recently. A semiring is anything with addition, multiplication, zero and one. You can represent that in Haskell as:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Semiring</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="ot">  zero ::</span> a</a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="ot">  one  ::</span> a</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">  <span class="kw">infixl</span> <span class="dv">7</span> <span class="fu">&lt;.&gt;</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="ot">  (&lt;.&gt;) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">  <span class="kw">infixl</span> <span class="dv">6</span> <span class="fu">&lt;+&gt;</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7"><span class="ot">  (&lt;+&gt;) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a></code></pre></div>
<p>It‚Äôs kind of like a combination of two <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Monoid.html">monoids</a>. It has the normal monoid laws:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1">x <span class="fu">&lt;+&gt;</span> (y <span class="fu">&lt;+&gt;</span> z) <span class="fu">=</span> (x <span class="fu">&lt;+&gt;</span> y) <span class="fu">&lt;+&gt;</span> z</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">x <span class="fu">&lt;.&gt;</span> (y <span class="fu">&lt;.&gt;</span> z) <span class="fu">=</span> (x <span class="fu">&lt;.&gt;</span> y) <span class="fu">&lt;.&gt;</span> z</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">x <span class="fu">&lt;+&gt;</span> zero <span class="fu">=</span> zero <span class="fu">&lt;+&gt;</span> x <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">x <span class="fu">&lt;.&gt;</span> one  <span class="fu">=</span> one  <span class="fu">&lt;.&gt;</span> x <span class="fu">=</span> x</a></code></pre></div>
<p>And a few extra:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">x <span class="fu">&lt;+&gt;</span> y <span class="fu">=</span> y <span class="fu">&lt;+&gt;</span> x</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">x <span class="fu">&lt;.&gt;</span> (y <span class="fu">&lt;+&gt;</span> z) <span class="fu">=</span> (x <span class="fu">&lt;.&gt;</span> y) <span class="fu">&lt;+&gt;</span> (x <span class="fu">&lt;.&gt;</span> z)</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">(x <span class="fu">&lt;+&gt;</span> y) <span class="fu">&lt;.&gt;</span> z <span class="fu">=</span> (x <span class="fu">&lt;.&gt;</span> z) <span class="fu">&lt;+&gt;</span> (y <span class="fu">&lt;.&gt;</span> z)</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">zero <span class="fu">&lt;.&gt;</span> a <span class="fu">=</span> a <span class="fu">&lt;.&gt;</span> zero <span class="fu">=</span> zero</a></code></pre></div>
<p>I should note that what I‚Äôm calling a semiring here is often called a <a href="https://ncatlab.org/nlab/show/rig">rig</a>. I actually prefer the name ‚Äúrig‚Äù: a rig is a ring without <strong>n</strong>egatives (cute!); whereas a <em>semi</em>ring is a rig without neutral elements, which mirrors the definition of a semigroup. The nomenclature in this area is a bit of a mess, though, so I went with the more commonly-used name for the sake of googleability.</p>
<p>At first glance, it looks quite numeric. Indeed, <a href="https://pursuit.purescript.org/packages/purescript-prelude/1.1.0/docs/Data.Semiring">PureScript</a> uses it as the basis for its numeric hierarchy. (In my experience so far, it‚Äôs nicer to use than Haskell‚Äôs <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Num"><code class="sourceCode haskell"><span class="dt">Num</span></code></a>)</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Semiring</span> <span class="dt">Integer</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">  zero <span class="fu">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  one  <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">  (<span class="fu">&lt;+&gt;</span>) <span class="fu">=</span> (<span class="fu">+</span>)</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">  (<span class="fu">&lt;.&gt;</span>) <span class="fu">=</span> (<span class="fu">*</span>)</a>
<a class="sourceLine" id="cb5-6" data-line-number="6"></a>
<a class="sourceLine" id="cb5-7" data-line-number="7"><span class="kw">instance</span> <span class="dt">Semiring</span> <span class="dt">Double</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8">  zero <span class="fu">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb5-9" data-line-number="9">  one  <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb5-10" data-line-number="10">  (<span class="fu">&lt;+&gt;</span>) <span class="fu">=</span> (<span class="fu">+</span>)</a>
<a class="sourceLine" id="cb5-11" data-line-number="11">  (<span class="fu">&lt;.&gt;</span>) <span class="fu">=</span> (<span class="fu">*</span>)</a></code></pre></div>
<p>However, there are far more types which can form a valid <code class="sourceCode haskell"><span class="dt">Semiring</span></code> instance than can form a valid <code class="sourceCode haskell"><span class="dt">Num</span></code> instance: the <code class="sourceCode haskell">negate</code> method, for example, excludes types representing the natural numbers:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">ChurchNat</span> <span class="fu">=</span> <span class="dt">ChurchNat</span> </a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  {<span class="ot"> runNat ::</span> forall a<span class="fu">.</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a}</a>
<a class="sourceLine" id="cb6-3" data-line-number="3"> </a>
<a class="sourceLine" id="cb6-4" data-line-number="4"><span class="kw">data</span> <span class="dt">Nat</span> <span class="fu">=</span> <span class="dt">Zero</span> <span class="fu">|</span> <span class="dt">Succ</span> <span class="dt">Nat</span></a></code></pre></div>
<p>These form perfectly sensible semirings, though:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Semiring</span> <span class="dt">ChurchNat</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  zero <span class="fu">=</span> <span class="dt">ChurchNat</span> (const id)</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  one <span class="fu">=</span> <span class="dt">ChurchNat</span> (<span class="fu">$</span>)</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">  <span class="dt">ChurchNat</span> n <span class="fu">&lt;+&gt;</span> <span class="dt">ChurchNat</span> m <span class="fu">=</span> <span class="dt">ChurchNat</span> (\f <span class="ot">-&gt;</span> n f <span class="fu">.</span> m f)</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">  <span class="dt">ChurchNat</span> n <span class="fu">&lt;.&gt;</span> <span class="dt">ChurchNat</span> m <span class="fu">=</span> <span class="dt">ChurchNat</span> (n <span class="fu">.</span> m)</a>
<a class="sourceLine" id="cb7-6" data-line-number="6"></a>
<a class="sourceLine" id="cb7-7" data-line-number="7"><span class="kw">instance</span> <span class="dt">Semiring</span> <span class="dt">Nat</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-8" data-line-number="8">  zero <span class="fu">=</span> <span class="dt">Zero</span></a>
<a class="sourceLine" id="cb7-9" data-line-number="9">  one <span class="fu">=</span> <span class="dt">Succ</span> <span class="dt">Zero</span></a>
<a class="sourceLine" id="cb7-10" data-line-number="10">  <span class="dt">Zero</span> <span class="fu">&lt;+&gt;</span> x <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb7-11" data-line-number="11">  <span class="dt">Succ</span> x <span class="fu">&lt;+&gt;</span> y <span class="fu">=</span> <span class="dt">Succ</span> (x <span class="fu">&lt;+&gt;</span> y)</a>
<a class="sourceLine" id="cb7-12" data-line-number="12">  <span class="dt">Zero</span> <span class="fu">&lt;.&gt;</span> _ <span class="fu">=</span> <span class="dt">Zero</span></a>
<a class="sourceLine" id="cb7-13" data-line-number="13">  <span class="dt">Succ</span> <span class="dt">Zero</span> <span class="fu">&lt;.&gt;</span> x <span class="fu">=</span>x</a>
<a class="sourceLine" id="cb7-14" data-line-number="14">  <span class="dt">Succ</span> x <span class="fu">&lt;.&gt;</span> y <span class="fu">=</span> y <span class="fu">&lt;+&gt;</span> (x <span class="fu">&lt;.&gt;</span> y)</a></code></pre></div>
<p>The other missing method is <code class="sourceCode haskell">fromInteger</code>, which means decidedly non-numeric types are allowed:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Semiring</span> <span class="dt">Bool</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  zero <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  one  <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">  (<span class="fu">&lt;+&gt;</span>) <span class="fu">=</span> (<span class="fu">||</span>)</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">  (<span class="fu">&lt;.&gt;</span>) <span class="fu">=</span> (<span class="fu">&amp;&amp;</span>)</a></code></pre></div>
<p>We can provide a more general definition of the <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Monoid.html#t:Sum"><code class="sourceCode haskell"><span class="dt">Sum</span></code></a> and <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Monoid.html#t:Product"><code class="sourceCode haskell"><span class="dt">Product</span></code></a> newtypes from <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Monoid.html#g:3">Data.Monoid</a>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Add</span> a <span class="fu">=</span> <span class="dt">Add</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">  {<span class="ot"> getAdd ::</span> a</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Read</span>, <span class="dt">Show</span>, <span class="dt">Semiring</span>)</a>
<a class="sourceLine" id="cb9-4" data-line-number="4"></a>
<a class="sourceLine" id="cb9-5" data-line-number="5"><span class="kw">newtype</span> <span class="dt">Mul</span> a <span class="fu">=</span> <span class="dt">Mul</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6">  {<span class="ot"> getMul ::</span> a</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Read</span>, <span class="dt">Show</span>, <span class="dt">Semiring</span>)</a>
<a class="sourceLine" id="cb9-8" data-line-number="8"></a>
<a class="sourceLine" id="cb9-9" data-line-number="9"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Add</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-10" data-line-number="10">  fmap f (<span class="dt">Add</span> x) <span class="fu">=</span> <span class="dt">Add</span> (f x)</a>
<a class="sourceLine" id="cb9-11" data-line-number="11"></a>
<a class="sourceLine" id="cb9-12" data-line-number="12"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Add</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-13" data-line-number="13">  pure <span class="fu">=</span> <span class="dt">Add</span></a>
<a class="sourceLine" id="cb9-14" data-line-number="14">  <span class="dt">Add</span> f <span class="fu">&lt;*&gt;</span> <span class="dt">Add</span> x <span class="fu">=</span> <span class="dt">Add</span> (f x)</a></code></pre></div>
<p>I‚Äôm using <code class="sourceCode haskell"><span class="dt">Add</span></code> and <code class="sourceCode haskell"><span class="dt">Mul</span></code> here to avoid name clashing.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Semiring</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Add</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">  mempty <span class="fu">=</span> <span class="dt">Add</span> zero</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  <span class="dt">Add</span> x <span class="ot">`mappend`</span> <span class="dt">Add</span> y <span class="fu">=</span> <span class="dt">Add</span> (x <span class="fu">&lt;+&gt;</span> y)</a>
<a class="sourceLine" id="cb10-4" data-line-number="4"></a>
<a class="sourceLine" id="cb10-5" data-line-number="5"><span class="kw">instance</span> <span class="dt">Semiring</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Mul</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-6" data-line-number="6">  mempty <span class="fu">=</span> <span class="dt">Mul</span> one</a>
<a class="sourceLine" id="cb10-7" data-line-number="7">  <span class="dt">Mul</span> x <span class="ot">`mappend`</span> <span class="dt">Mul</span> y <span class="fu">=</span> <span class="dt">Mul</span> (x <span class="fu">&lt;.&gt;</span> y)</a>
<a class="sourceLine" id="cb10-8" data-line-number="8">  </a>
<a class="sourceLine" id="cb10-9" data-line-number="9"><span class="ot">add ::</span> (<span class="dt">Semiring</span> a, <span class="dt">Foldable</span> f) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb10-10" data-line-number="10">add <span class="fu">=</span> getAdd <span class="fu">.</span> foldMap <span class="dt">Add</span></a>
<a class="sourceLine" id="cb10-11" data-line-number="11"></a>
<a class="sourceLine" id="cb10-12" data-line-number="12"><span class="ot">mul ::</span> (<span class="dt">Semiring</span> a, <span class="dt">Foldable</span> f) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb10-13" data-line-number="13">mul <span class="fu">=</span> getMul <span class="fu">.</span> foldMap <span class="dt">Mul</span></a></code></pre></div>
<p><code class="sourceCode haskell">add</code> and <code class="sourceCode haskell">mul</code> are equivalent to <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Foldable.html#v:sum"><code class="sourceCode haskell">sum</code></a> and <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Foldable.html#v:product"><code class="sourceCode haskell">product</code></a>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell literate prop"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1">add xs <span class="fu">==</span> sum (<span class="ot">xs ::</span> [<span class="dt">Integer</span>])</a></code></pre></div>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell literate prop"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1">mul xs <span class="fu">==</span> product (<span class="ot">xs ::</span> [<span class="dt">Integer</span>])</a></code></pre></div>
<p>But they now work with a wider array of types: non-negative numbers, as we‚Äôve seen, but specialised to <code class="sourceCode haskell"><span class="dt">Bool</span></code> we get the familiar <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Monoid.html#t:Any"><code class="sourceCode haskell"><span class="dt">Any</span></code></a> and <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Monoid.html#t:All"><code class="sourceCode haskell"><span class="dt">All</span></code></a> newtypes (and their corresponding folds).</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell literate prop"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1">add xs <span class="fu">==</span> or (<span class="ot">xs ::</span> [<span class="dt">Bool</span>])</a></code></pre></div>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell literate prop"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1">mul xs <span class="fu">==</span> and (<span class="ot">xs ::</span> [<span class="dt">Bool</span>])</a></code></pre></div>
<p>So far, nothing amazing. We avoid a little bit of code duplication, that‚Äôs all.</p>
<h2 id="a-semiring-map">A Semiring Map</h2>
<p>In older versions of Python, <a href="https://www.python.org/dev/peps/pep-0218/">there was no native set type</a>. In its place, dictionaries were used, where the values would be booleans. In a similar fashion, before the <a href="https://docs.python.org/2/library/collections.html#collections.Counter">Counter</a> type was added in 2.7, the traditional way of representing a multiset was using a dictionary where the values were integers.</p>
<p>Using semirings, both of these data structures can have the same type:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">GeneralMap</span> a b <span class="fu">=</span> <span class="dt">GeneralMap</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2">  {<span class="ot"> getMap ::</span> <span class="dt">Map</span> a b</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">  } <span class="kw">deriving</span> (<span class="dt">Functor</span>, <span class="dt">Foldable</span>, <span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>)</a></code></pre></div>
<p>If operations are defined in terms of the <code class="sourceCode haskell"><span class="dt">Semiring</span></code> class, the same code will work on a set <em>and</em> a multiset:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="ot">insert ::</span> (<span class="dt">Ord</span> a, <span class="dt">Semiring</span> b) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a b <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a b</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">insert x <span class="fu">=</span> <span class="dt">GeneralMap</span> <span class="fu">.</span> Map.insertWith (<span class="fu">&lt;+&gt;</span>) x one <span class="fu">.</span> getMap</a>
<a class="sourceLine" id="cb16-3" data-line-number="3"></a>
<a class="sourceLine" id="cb16-4" data-line-number="4"><span class="ot">delete ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a b <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a b</a>
<a class="sourceLine" id="cb16-5" data-line-number="5">delete x <span class="fu">=</span> <span class="dt">GeneralMap</span> <span class="fu">.</span> Map.delete x <span class="fu">.</span> getMap</a></code></pre></div>
<p>How to get back the dictionary-like behaviour, then? Well, operations like <code class="sourceCode haskell">lookup</code> and <code class="sourceCode haskell">assoc</code> are better suited to a <code class="sourceCode haskell"><span class="dt">Monoid</span></code> constraint, rather than <code class="sourceCode haskell"><span class="dt">Semiring</span></code>:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1">lookup<span class="ot"> ::</span> (<span class="dt">Ord</span> a, <span class="dt">Monoid</span> b) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a b <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">lookup x <span class="fu">=</span> fold <span class="fu">.</span> Map.lookup x <span class="fu">.</span> getMap</a>
<a class="sourceLine" id="cb17-3" data-line-number="3"></a>
<a class="sourceLine" id="cb17-4" data-line-number="4"><span class="ot">assoc ::</span> (<span class="dt">Ord</span> a, <span class="dt">Applicative</span> f, <span class="dt">Monoid</span> (f b)) </a>
<a class="sourceLine" id="cb17-5" data-line-number="5">      <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a (f b) <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a (f b)</a>
<a class="sourceLine" id="cb17-6" data-line-number="6">assoc k v <span class="fu">=</span> <span class="dt">GeneralMap</span> <span class="fu">.</span> Map.insertWith mappend k (pure v) <span class="fu">.</span> getMap</a></code></pre></div>
<p><code class="sourceCode haskell">lookup</code> is a function which should work on sets and multisets: however <code class="sourceCode haskell"><span class="dt">Bool</span></code> and <code class="sourceCode haskell"><span class="dt">Integer</span></code> don‚Äôt have <code class="sourceCode haskell"><span class="dt">Monoid</span></code> instances. To fix this, we can use the <code class="sourceCode haskell"><span class="dt">Add</span></code> newtype from earlier. The interface for each of these data structures can now be expressed like this:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Set</span>      a   <span class="fu">=</span> <span class="dt">GeneralMap</span> a (<span class="dt">Add</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb18-2" data-line-number="2"><span class="kw">type</span> <span class="dt">MultiSet</span> a   <span class="fu">=</span> <span class="dt">GeneralMap</span> a (<span class="dt">Add</span> <span class="dt">Integer</span>)</a>
<a class="sourceLine" id="cb18-3" data-line-number="3"><span class="kw">type</span> <span class="dt">Map</span>      a b <span class="fu">=</span> <span class="dt">GeneralMap</span> a (<span class="dt">First</span> b)</a>
<a class="sourceLine" id="cb18-4" data-line-number="4"><span class="kw">type</span> <span class="dt">MultiMap</span> a b <span class="fu">=</span> <span class="dt">GeneralMap</span> a [b]</a></code></pre></div>
<p>And each of the functions on the <code class="sourceCode haskell"><span class="dt">GeneralMap</span></code> specialises like this:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="co">-- Set</span></a>
<a class="sourceLine" id="cb19-2" data-line-number="2"><span class="ot">insert ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Set</span> a <span class="ot">-&gt;</span> <span class="dt">Set</span> a</a>
<a class="sourceLine" id="cb19-3" data-line-number="3">lookup<span class="ot"> ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Set</span> a <span class="ot">-&gt;</span> <span class="dt">Add</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb19-4" data-line-number="4"><span class="ot">delete ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Set</span> a <span class="ot">-&gt;</span> <span class="dt">Set</span> a</a>
<a class="sourceLine" id="cb19-5" data-line-number="5"></a>
<a class="sourceLine" id="cb19-6" data-line-number="6"><span class="co">-- MultiSet</span></a>
<a class="sourceLine" id="cb19-7" data-line-number="7"><span class="ot">insert ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">MultiSet</span> a <span class="ot">-&gt;</span> <span class="dt">MultiSet</span> a</a>
<a class="sourceLine" id="cb19-8" data-line-number="8">lookup<span class="ot"> ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">MultiSet</span> a <span class="ot">-&gt;</span> <span class="dt">Add</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb19-9" data-line-number="9"><span class="ot">delete ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">MultiSet</span> a <span class="ot">-&gt;</span> <span class="dt">MultiSet</span> a</a>
<a class="sourceLine" id="cb19-10" data-line-number="10"></a>
<a class="sourceLine" id="cb19-11" data-line-number="11"><span class="co">-- Map</span></a>
<a class="sourceLine" id="cb19-12" data-line-number="12"><span class="ot">assoc  ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Map</span> a b <span class="ot">-&gt;</span> <span class="dt">Map</span> a b</a>
<a class="sourceLine" id="cb19-13" data-line-number="13">lookup<span class="ot"> ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Map</span> a b <span class="ot">-&gt;</span> <span class="dt">First</span> b</a>
<a class="sourceLine" id="cb19-14" data-line-number="14"><span class="ot">delete ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Map</span> a b <span class="ot">-&gt;</span> <span class="dt">Map</span> a b</a>
<a class="sourceLine" id="cb19-15" data-line-number="15"></a>
<a class="sourceLine" id="cb19-16" data-line-number="16"><span class="co">-- MultiMap</span></a>
<a class="sourceLine" id="cb19-17" data-line-number="17"><span class="ot">assoc  ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">MultiMap</span> a b <span class="ot">-&gt;</span> <span class="dt">MultiMap</span> a b</a>
<a class="sourceLine" id="cb19-18" data-line-number="18">lookup<span class="ot"> ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">MultiMap</span> a b <span class="ot">-&gt;</span> [b]</a>
<a class="sourceLine" id="cb19-19" data-line-number="19"><span class="ot">delete ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">MultiMap</span> a b <span class="ot">-&gt;</span> <span class="dt">MultiMap</span> a b</a></code></pre></div>
<p>This was actually where I first came across semirings: I was trying to avoid code duplication for a trie implementation. I wanted to get the Boom Hierarchy <span class="citation" data-cites="boom_further_1981">(<a href="#ref-boom_further_1981">1981</a>)</span> (plus maps) from the same underlying implementation.</p>
<p>It works <em>okay</em>. On the one hand, it‚Äôs nice that you don‚Äôt have to wrap the map type itself to get the different behaviour. There‚Äôs only one <code class="sourceCode haskell">delete</code> function, which works on sets, maps, multisets, etc. I don‚Äôt need to import the <code class="sourceCode haskell"><span class="dt">TrieSet</span></code> module qualified, to differentiate between the <em>four</em> <code class="sourceCode haskell">delete</code> functions I‚Äôve written.</p>
<p>On the other hand, the <code class="sourceCode haskell"><span class="dt">Add</span></code> wrapper is a pain: having <code class="sourceCode haskell">lookup</code> return the wrapped values is ugly, and the <code class="sourceCode haskell"><span class="dt">Applicative</span></code> constraint is unwieldy (we only use it for <code class="sourceCode haskell">pure</code>). Both of those problems could be solved by using something like the <a href="https://hackage.haskell.org/package/newtype-0.2/docs/Control-Newtype.html#t:Newtype"><code class="sourceCode haskell"><span class="dt">Newtype</span></code></a> or <a href="https://hackage.haskell.org/package/lens-4.15.1/docs/Control-Lens-Wrapped.html#t:Wrapped"><code class="sourceCode haskell"><span class="dt">Wrapped</span></code></a> class, which provide facilities for wrapping and unwrapping, but that might be overkill.</p>
<p>While <code class="sourceCode haskell"><span class="dt">Monoid</span></code> and <code class="sourceCode haskell"><span class="dt">Semiring</span></code> can take you pretty far, even to a <code class="sourceCode haskell"><span class="dt">Monoid</span></code> instance:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="ot">fromList ::</span> (<span class="dt">Ord</span> a, <span class="dt">Semiring</span> b, <span class="dt">Foldable</span> f) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a b</a>
<a class="sourceLine" id="cb20-2" data-line-number="2">fromList <span class="fu">=</span> foldr insert (<span class="dt">GeneralMap</span> Map.empty)</a>
<a class="sourceLine" id="cb20-3" data-line-number="3"></a>
<a class="sourceLine" id="cb20-4" data-line-number="4"><span class="ot">fromAssocs ::</span> (<span class="dt">Ord</span> a, <span class="dt">Applicative</span> f, <span class="dt">Monoid</span> (f b), <span class="dt">Foldable</span> t) </a>
<a class="sourceLine" id="cb20-5" data-line-number="5">           <span class="ot">=&gt;</span> t (a, b) <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a (f b)</a>
<a class="sourceLine" id="cb20-6" data-line-number="6">fromAssocs <span class="fu">=</span> foldr (uncurry assoc) (<span class="dt">GeneralMap</span> Map.empty)</a>
<a class="sourceLine" id="cb20-7" data-line-number="7"></a>
<a class="sourceLine" id="cb20-8" data-line-number="8"><span class="kw">instance</span> (<span class="dt">Ord</span> a, <span class="dt">Monoid</span> b) <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">GeneralMap</span> a b) <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-9" data-line-number="9">  mempty <span class="fu">=</span> <span class="dt">GeneralMap</span> Map.empty</a>
<a class="sourceLine" id="cb20-10" data-line-number="10">  mappend (<span class="dt">GeneralMap</span> x) (<span class="dt">GeneralMap</span> y) <span class="fu">=</span> </a>
<a class="sourceLine" id="cb20-11" data-line-number="11">    <span class="dt">GeneralMap</span> (Map.unionWith mappend x y)</a>
<a class="sourceLine" id="cb20-12" data-line-number="12"></a>
<a class="sourceLine" id="cb20-13" data-line-number="13"><span class="ot">singleton ::</span> <span class="dt">Semiring</span> b <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a b</a>
<a class="sourceLine" id="cb20-14" data-line-number="14">singleton x <span class="fu">=</span> <span class="dt">GeneralMap</span> (Map.singleton x one)</a></code></pre></div>
<p>They seem to fall down around functions like <code class="sourceCode haskell">intersection</code>:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="ot">intersection ::</span> (<span class="dt">Ord</span> a, <span class="dt">Semiring</span> b)</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">             <span class="ot">=&gt;</span> <span class="dt">GeneralMap</span> a b <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a b <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a b</a>
<a class="sourceLine" id="cb21-3" data-line-number="3">intersection (<span class="dt">GeneralMap</span> x) (<span class="dt">GeneralMap</span> y) <span class="fu">=</span></a>
<a class="sourceLine" id="cb21-4" data-line-number="4">  <span class="dt">GeneralMap</span> (Map.intersectionWith (<span class="fu">&lt;.&gt;</span>) x y)</a></code></pre></div>
<p>It works for sets, but it doesn‚Äôt make sense for multisets, and it doesn‚Äôt work for maps.</p>
<p>I couldn‚Äôt find a semiring for the map-like types which would give me a sensible intersection. I‚Äôm probably after a different algebraic structure.</p>
<h2 id="a-probability-semiring">A Probability Semiring</h2>
<p>While looking for a semiring to represent a valid intersection, I came across the probability semiring. It‚Äôs just the normal semiring over the rationals, with a lower bound of 0, and an upper of 1.</p>
<p>It‚Äôs useful in some cool ways: you can combine it with a list to get the probability monad <span class="citation" data-cites="erwig_functional_2006">(Erwig and Kollmansberger <a href="#ref-erwig_functional_2006">2006</a>)</span>. There‚Äôs an example in PureScript‚Äôs <a href="https://pursuit.purescript.org/packages/purescript-distributions/">Distributions</a> package.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Prob</span> s a <span class="fu">=</span> <span class="dt">Prob</span> {<span class="ot"> runProb ::</span> [(a,s)] }</a></code></pre></div>
<p>There are some drawbacks to this representation, performance-wise. In particular, there‚Äôs a combinatorial explosion on every monadic bind. One of the strategies to reduce this explosion is to use a map:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Prob</span> s a <span class="fu">=</span> <span class="dt">Prob</span> {<span class="ot"> runProb ::</span> <span class="dt">Map</span> a s }</a></code></pre></div>
<p>Because this doesn‚Äôt allow duplicate keys, it will flatten the association list on every bind. Unfortunately, the performance gain doesn‚Äôt always materialize, and in some cases there‚Äôs a performance <em>loss</em> <span class="citation" data-cites="larsen_memory_2011">(Larsen <a href="#ref-larsen_memory_2011">2011</a>)</span>. Also, the <code class="sourceCode haskell"><span class="dt">Ord</span></code> constraint on the keys prevents it from conforming to <code class="sourceCode haskell"><span class="dt">Monad</span></code> (at least not without <a href="http://okmij.org/ftp/Haskell/set-monad.html">difficulty</a>).</p>
<p>Interestingly, this type is exactly the same as the <code class="sourceCode haskell"><span class="dt">GeneralMap</span></code> from before. This is a theme I kept running into, actually: the <code class="sourceCode haskell"><span class="dt">GeneralMap</span></code> type represents not just maps, multimaps, sets, multisets, but also a whole host of other data structures.</p>
<h2 id="cont">Cont</h2>
<p>Edward Kmett had an interesting blog post about ‚ÄúFree Modules and Functional Linear Functionals‚Äù <span class="citation" data-cites="kmett_modules_2011">(<a href="#ref-kmett_modules_2011">2011</a><a href="#ref-kmett_modules_2011">b</a>)</span>. In it, he talked about this type:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">0</span> <span class="fu">$*</span></a>
<a class="sourceLine" id="cb24-2" data-line-number="2"><span class="kw">newtype</span> <span class="dt">Linear</span> r a <span class="fu">=</span> <span class="dt">Linear</span> {<span class="ot"> ($*) ::</span> (a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r }</a></code></pre></div>
<p>Also known as <a href="https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Cont.html#t:Cont"><code class="sourceCode haskell"><span class="dt">Cont</span></code></a>, the continuation monad. It can encode the probability monad:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="ot">fromProbs ::</span> (<span class="dt">Semiring</span> s, <span class="dt">Applicative</span> m) <span class="ot">=&gt;</span> [(a,s)] <span class="ot">-&gt;</span> <span class="dt">ContT</span> s m a</a>
<a class="sourceLine" id="cb25-2" data-line-number="2">fromProbs xs <span class="fu">=</span> <span class="dt">ContT</span> <span class="fu">$</span> \k <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb25-3" data-line-number="3">  foldr (\(x,s) a <span class="ot">-&gt;</span> liftA2 (<span class="fu">&lt;+&gt;</span>) (fmap (s<span class="fu">&lt;.&gt;</span>) (k x)) a) (pure zero) xs</a>
<a class="sourceLine" id="cb25-4" data-line-number="4"></a>
<a class="sourceLine" id="cb25-5" data-line-number="5"><span class="ot">probOfT ::</span> (<span class="dt">Semiring</span> r, <span class="dt">Applicative</span> m) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">ContT</span> r m a <span class="ot">-&gt;</span> m r</a>
<a class="sourceLine" id="cb25-6" data-line-number="6">probOfT e c <span class="fu">=</span> runContT c (\x <span class="ot">-&gt;</span> <span class="kw">if</span> e x <span class="kw">then</span> pure one <span class="kw">else</span> pure zero)</a>
<a class="sourceLine" id="cb25-7" data-line-number="7"></a>
<a class="sourceLine" id="cb25-8" data-line-number="8"><span class="ot">probOf ::</span> <span class="dt">Semiring</span> r <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Cont</span> r a <span class="ot">-&gt;</span> r</a>
<a class="sourceLine" id="cb25-9" data-line-number="9">probOf e <span class="fu">=</span> runIdentity <span class="fu">.</span> probOfT e</a>
<a class="sourceLine" id="cb25-10" data-line-number="10"></a>
<a class="sourceLine" id="cb25-11" data-line-number="11"><span class="ot">uniform ::</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">ContT</span> <span class="dt">Double</span> m a</a>
<a class="sourceLine" id="cb25-12" data-line-number="12">uniform xs <span class="fu">=</span></a>
<a class="sourceLine" id="cb25-13" data-line-number="13">  <span class="kw">let</span> s <span class="fu">=</span> <span class="fl">1.0</span> <span class="fu">/</span> fromIntegral (length xs)</a>
<a class="sourceLine" id="cb25-14" data-line-number="14">  <span class="kw">in</span> fromProbs (map (flip (,) s) xs)</a></code></pre></div>
<p>Multiplication isn‚Äôt paid for on every bind, making this (potentially) a more efficient implementation than both the map and the association list.</p>
<p>You can actually make the whole thing a semiring:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="kw">instance</span> (<span class="dt">Semiring</span> r, <span class="dt">Applicative</span> m) <span class="ot">=&gt;</span> <span class="dt">Semiring</span> (<span class="dt">ContT</span> r m a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb26-2" data-line-number="2">  one  <span class="fu">=</span> <span class="dt">ContT</span> (const (pure one))</a>
<a class="sourceLine" id="cb26-3" data-line-number="3">  zero <span class="fu">=</span> <span class="dt">ContT</span> (const (pure zero))</a>
<a class="sourceLine" id="cb26-4" data-line-number="4">  f <span class="fu">&lt;+&gt;</span> g <span class="fu">=</span> <span class="dt">ContT</span> (\k <span class="ot">-&gt;</span> liftA2 (<span class="fu">&lt;+&gt;</span>) (runContT f k) (runContT g k))</a>
<a class="sourceLine" id="cb26-5" data-line-number="5">  f <span class="fu">&lt;.&gt;</span> g <span class="fu">=</span> <span class="dt">ContT</span> (\k <span class="ot">-&gt;</span> liftA2 (<span class="fu">&lt;.&gt;</span>) (runContT f k) (runContT g k))</a></code></pre></div>
<p>Which gives you a lovely <code class="sourceCode haskell"><span class="dt">Alternative</span></code> instance:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="kw">instance</span> (<span class="dt">Semiring</span> r, <span class="dt">Applicative</span> m) <span class="ot">=&gt;</span> <span class="dt">Alternative</span> (<span class="dt">ContT</span> r m) <span class="kw">where</span></a>
<a class="sourceLine" id="cb27-2" data-line-number="2">  (<span class="fu">&lt;|&gt;</span>) <span class="fu">=</span> (<span class="fu">&lt;+&gt;</span>)</a>
<a class="sourceLine" id="cb27-3" data-line-number="3">  empty <span class="fu">=</span> zero</a></code></pre></div>
<p>This sheds some light on what was going on with the unsatisfactory <code class="sourceCode haskell">intersection</code> function on <code class="sourceCode haskell"><span class="dt">GeneralMap</span></code>: it‚Äôs actually <em>multiplication</em>. If you wanted to stretch the analogy and make <code class="sourceCode haskell"><span class="dt">GeneralMap</span></code> conform to <code class="sourceCode haskell"><span class="dt">Semiring</span></code>, you could use the empty map for <code class="sourceCode haskell">zero</code>, <code class="sourceCode haskell">mappend</code> for <code class="sourceCode haskell"><span class="fu">&lt;+&gt;</span></code>, but you‚Äôd run into trouble for <code class="sourceCode haskell">one</code>. <code class="sourceCode haskell">one</code> is the map where every possible key has a value of one. In other words, you‚Äôd have to enumerate over every possible value for the keys. Interestingly, there‚Äôs kind of the inverse problem for Cont: while it has an easy <code class="sourceCode haskell"><span class="dt">Semiring</span></code> instance, in order to <em>inspect</em> the values you have to enumerate over all the possible keys.</p>
<p>I now have a name for the probability monad / general map / Cont thing: a <em>covector</em>.</p>
<p>I think that the transformer version of Cont has a valid interpretation, also. If I ever understand <span class="citation" data-cites="hirschowitz_modules_2010">Hirschowitz and Maggesi (<a href="#ref-hirschowitz_modules_2010">2010</a>)</span> I‚Äôll put it into a later follow-up post.</p>
<h2 id="conditional-choice">Conditional choice</h2>
<p>As a short digression, you can beef up the <code class="sourceCode haskell"><span class="fu">&lt;|&gt;</span></code> operator a little, with something like <a href="http://zenzike.com/posts/2011-08-01-the-conditional-choice-operator">the conditional choice operator</a>:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1"><span class="kw">data</span> <span class="dt">BiWeighted</span> s <span class="fu">=</span> s <span class="fu">:|:</span> s</a>
<a class="sourceLine" id="cb28-2" data-line-number="2"><span class="kw">infixl</span> <span class="dv">8</span> <span class="fu">:|:</span></a>
<a class="sourceLine" id="cb28-3" data-line-number="3"></a>
<a class="sourceLine" id="cb28-4" data-line-number="4"><span class="ot">(|&gt;) ::</span> (<span class="dt">Applicative</span> m, <span class="dt">Semiring</span> s)</a>
<a class="sourceLine" id="cb28-5" data-line-number="5">     <span class="ot">=&gt;</span> <span class="dt">BiWeighted</span> s</a>
<a class="sourceLine" id="cb28-6" data-line-number="6">     <span class="ot">-&gt;</span> <span class="dt">ContT</span> s m a</a>
<a class="sourceLine" id="cb28-7" data-line-number="7">     <span class="ot">-&gt;</span> <span class="dt">ContT</span> s m a</a>
<a class="sourceLine" id="cb28-8" data-line-number="8">     <span class="ot">-&gt;</span> <span class="dt">ContT</span> s m a</a>
<a class="sourceLine" id="cb28-9" data-line-number="9">((lp <span class="fu">:|:</span> rp) <span class="fu">|&gt;</span> r) l <span class="fu">=</span></a>
<a class="sourceLine" id="cb28-10" data-line-number="10">  (mapContT<span class="fu">.</span>fmap<span class="fu">.</span>(<span class="fu">&lt;.&gt;</span>)) lp l <span class="fu">&lt;|&gt;</span> (mapContT<span class="fu">.</span>fmap<span class="fu">.</span>(<span class="fu">&lt;.&gt;</span>)) rp r</a>
<a class="sourceLine" id="cb28-11" data-line-number="11"><span class="co">--</span></a>
<a class="sourceLine" id="cb28-12" data-line-number="12"><span class="ot">(&lt;|) ::</span> <span class="dt">ContT</span> s m a</a>
<a class="sourceLine" id="cb28-13" data-line-number="13">     <span class="ot">-&gt;</span> (<span class="dt">ContT</span> s m a <span class="ot">-&gt;</span> <span class="dt">ContT</span> s m a)</a>
<a class="sourceLine" id="cb28-14" data-line-number="14">     <span class="ot">-&gt;</span> <span class="dt">ContT</span> s m a</a>
<a class="sourceLine" id="cb28-15" data-line-number="15">l <span class="fu">&lt;|</span> r <span class="fu">=</span> r l</a>
<a class="sourceLine" id="cb28-16" data-line-number="16"></a>
<a class="sourceLine" id="cb28-17" data-line-number="17"><span class="kw">infixr</span> <span class="dv">0</span> <span class="fu">&lt;|</span></a>
<a class="sourceLine" id="cb28-18" data-line-number="18"><span class="kw">infixr</span> <span class="dv">0</span> <span class="fu">|&gt;</span></a></code></pre></div>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" data-line-number="1">probOf (<span class="ch">&#39;a&#39;</span><span class="fu">==</span>) (uniform <span class="st">&quot;a&quot;</span> <span class="fu">&lt;|</span> <span class="fl">0.4</span> <span class="fu">:|:</span> <span class="fl">0.6</span> <span class="fu">|&gt;</span> uniform <span class="st">&quot;b&quot;</span>)</a>
<a class="sourceLine" id="cb29-2" data-line-number="2"><span class="fl">0.4</span></a></code></pre></div>
<h2 id="unleak">UnLeak</h2>
<p>If you fiddle around with the probability monad, you can break it apart in interesting ways. For instance, extracting the <code class="sourceCode haskell"><span class="dt">WriterT</span></code> monad transformer gives you:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="dt">WriterT</span> (<span class="dt">Product</span> <span class="dt">Double</span>) []</a></code></pre></div>
<p>Eric Kidd describes it as <code class="sourceCode haskell"><span class="dt">PerhapsT</span></code>: a <code class="sourceCode haskell"><span class="dt">Maybe</span></code> with attached probability in his <a href="http://www.randomhacks.net/2007/02/21/refactoring-probability-distributions/">excellent blog post</a> <span class="citation" data-cites="kidd_build_2007">(and his paper in <a href="#ref-kidd_build_2007">2007</a>)</span>.</p>
<p>Straight away, we can optimise this representation by transforming the <a href="https://mail.haskell.org/pipermail/libraries/2013-March/019528.html">leaky</a> <code class="sourceCode haskell"><span class="dt">WriterT</span></code> into a state monad:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">WeightedT</span> s m a <span class="fu">=</span> <span class="dt">WeightedT</span> </a>
<a class="sourceLine" id="cb31-2" data-line-number="2">  {<span class="ot"> getWeightedT ::</span> s <span class="ot">-&gt;</span> m (a, s)</a>
<a class="sourceLine" id="cb31-3" data-line-number="3">  } <span class="kw">deriving</span> <span class="dt">Functor</span></a>
<a class="sourceLine" id="cb31-4" data-line-number="4">  </a>
<a class="sourceLine" id="cb31-5" data-line-number="5"><span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="dt">WeightedT</span> s m) <span class="kw">where</span></a>
<a class="sourceLine" id="cb31-6" data-line-number="6">  pure x <span class="fu">=</span> <span class="dt">WeightedT</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> pure (x,s)</a>
<a class="sourceLine" id="cb31-7" data-line-number="7">  <span class="dt">WeightedT</span> fs <span class="fu">&lt;*&gt;</span> <span class="dt">WeightedT</span> xs <span class="fu">=</span> <span class="dt">WeightedT</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb31-8" data-line-number="8">    (f, p) <span class="ot">&lt;-</span> fs s</a>
<a class="sourceLine" id="cb31-9" data-line-number="9">    (x, t) <span class="ot">&lt;-</span> xs p</a>
<a class="sourceLine" id="cb31-10" data-line-number="10">    pure (f x, t)</a>
<a class="sourceLine" id="cb31-11" data-line-number="11">  </a>
<a class="sourceLine" id="cb31-12" data-line-number="12"><span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">WeightedT</span> s m) <span class="kw">where</span></a>
<a class="sourceLine" id="cb31-13" data-line-number="13">  <span class="dt">WeightedT</span> x <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">WeightedT</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb31-14" data-line-number="14">    (x, p) <span class="ot">&lt;-</span> x s</a>
<a class="sourceLine" id="cb31-15" data-line-number="15">    getWeightedT (f x) p</a></code></pre></div>
<p>I‚Äôm not sure yet, but I think this might have something to do with the isomorphism between <code class="sourceCode haskell"><span class="dt">Cont</span> ((<span class="ot">-&gt;</span>) s)</code> and <code>State s</code> <span class="citation" data-cites="kmett_free_2011">(Kmett <a href="#ref-kmett_free_2011">2011</a><a href="#ref-kmett_free_2011">a</a>)</span>.</p>
<p>You can even make it look like a normal (non-transformer) writer with some pattern synonyms:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Weighted</span> s <span class="fu">=</span> <span class="dt">WeightedT</span> s <span class="dt">Identity</span></a>
<a class="sourceLine" id="cb32-2" data-line-number="2"></a>
<a class="sourceLine" id="cb32-3" data-line-number="3">pattern <span class="dt">Weighted</span> w <span class="ot">&lt;-</span> (runIdentity <span class="fu">.</span> flip getWeightedT zero <span class="ot">-&gt;</span> w) <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-4" data-line-number="4">  <span class="dt">Weighted</span> (x,w) <span class="fu">=</span> <span class="dt">WeightedT</span> (\s <span class="ot">-&gt;</span> <span class="dt">Identity</span> (x, s <span class="fu">&lt;.&gt;</span> w) )</a></code></pre></div>
<p>And you can pretend that you‚Äôve just got a normal tuple:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" data-line-number="1"><span class="ot">half ::</span> a <span class="ot">-&gt;</span> <span class="dt">Weighted</span> <span class="dt">Double</span> a</a>
<a class="sourceLine" id="cb33-2" data-line-number="2">half x <span class="fu">=</span> <span class="dt">Weighted</span> (x, <span class="fl">0.5</span>)</a>
<a class="sourceLine" id="cb33-3" data-line-number="3"></a>
<a class="sourceLine" id="cb33-4" data-line-number="4"><span class="ot">runWeighted ::</span> <span class="dt">Semiring</span> s <span class="ot">=&gt;</span> <span class="dt">Weighted</span> s a <span class="ot">-&gt;</span> (a, s)</a>
<a class="sourceLine" id="cb33-5" data-line-number="5">runWeighted (<span class="dt">Weighted</span> w) <span class="fu">=</span> w</a>
<a class="sourceLine" id="cb33-6" data-line-number="6"></a>
<a class="sourceLine" id="cb33-7" data-line-number="7"><span class="ot">evalWeighted ::</span> <span class="dt">Semiring</span> s <span class="ot">=&gt;</span> <span class="dt">Weighted</span> s a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb33-8" data-line-number="8">evalWeighted (<span class="dt">Weighted</span> (x,_)) <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb33-9" data-line-number="9"></a>
<a class="sourceLine" id="cb33-10" data-line-number="10"><span class="ot">execWeighted ::</span> <span class="dt">Semiring</span> s <span class="ot">=&gt;</span> <span class="dt">Weighted</span> s a <span class="ot">-&gt;</span> s</a>
<a class="sourceLine" id="cb33-11" data-line-number="11">execWeighted (<span class="dt">Weighted</span> (_,s)) <span class="fu">=</span> s</a></code></pre></div>
<h2 id="free">Free</h2>
<p>Looking back at Cont, it is reminiscent of a particular encoding of the free monoid from <span class="citation" data-cites="doel_free_2015">Doel (<a href="#ref-doel_free_2015">2015</a>)</span>:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">FreeMonoid</span> a <span class="fu">=</span> <span class="dt">FreeMonoid</span></a>
<a class="sourceLine" id="cb34-2" data-line-number="2">  { forall m<span class="fu">.</span> <span class="dt">Monoid</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m) <span class="ot">-&gt;</span> m }</a></code></pre></div>
<p>So possibly covectors represent the free semiring, in some way.</p>
<p>Another encoding which looks free-ish is one of the efficient implementations of the probability monad from <span class="citation" data-cites="larsen_memory_2011">Larsen (<a href="#ref-larsen_memory_2011">2011</a>)</span>:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb35-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Dist</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb35-2" data-line-number="2">  <span class="dt">Certainly</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Dist</span> a <span class="co">-- only possible value</span></a>
<a class="sourceLine" id="cb35-3" data-line-number="3">  <span class="dt">Choice</span><span class="ot"> ::</span> <span class="dt">Probability</span> <span class="ot">-&gt;</span> <span class="dt">Dist</span> a <span class="ot">-&gt;</span> <span class="dt">Dist</span> a <span class="ot">-&gt;</span> <span class="dt">Dist</span> a</a>
<a class="sourceLine" id="cb35-4" data-line-number="4">  <span class="dt">Fmap</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Dist</span> a <span class="ot">-&gt;</span> <span class="dt">Dist</span> b</a>
<a class="sourceLine" id="cb35-5" data-line-number="5">  <span class="dt">Join</span><span class="ot"> ::</span> <span class="dt">Dist</span> (<span class="dt">Dist</span> a) <span class="ot">-&gt;</span> <span class="dt">Dist</span> a</a></code></pre></div>
<p>This looks an awful lot like a weighted <a href="https://hackage.haskell.org/package/free-4.12.4/docs/Control-Alternative-Free.html">free alternative</a>. Is it a free semiring, then?</p>
<p>Maybe. There‚Äôs a parallel between the relationship between monoids and semirings and applicatives and <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Applicative.html#t:Alternative"><code class="sourceCode haskell"><span class="dt">Alternative</span></code></a>s <span class="citation" data-cites="rivas_monoids_2015">(Rivas, Jaskelioff, and Schrijvers <a href="#ref-rivas_monoids_2015">2015</a>)</span>. In a way, where monads are monoids in the category of endofunctors, alternatives are <em>semirings</em> in the category of endofunctors.</p>
<p>This parallel probably isn‚Äôt what I first thought it was. First of all, the above paper uses near-semirings, not semirings. A near-semiring is a semiring where the requirements for left distribution of multiplication over addition and commutative addition are dropped. Secondly, the class which most mirrors near-semirings is <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Monad.html#t:MonadPlus"><code class="sourceCode haskell"><span class="dt">MonadPlus</span></code></a>, not alternative. (alternative doesn‚Äôt have annihilation) Thirdly, right distribution of multiplication over addition <em>isn‚Äôt</em> required <code class="sourceCode haskell"><span class="dt">MonadPlus</span></code>: it‚Äôs a further law required on top of the existing laws. Fourthly, most types in the Haskell ecosystem today which conform to <code class="sourceCode haskell"><span class="dt">MonadPlus</span></code> <em>don‚Äôt</em> conform to this extra law: in fact, those that do seem to be lists of some kind or another.</p>
<p>A further class is probably needed on top of the two already there, with the extra laws <span class="citation" data-cites="fischer_reinventing_2009">(called <code class="sourceCode haskell"><span class="dt">Nondet</span></code> in Fischer <a href="#ref-fischer_reinventing_2009">2009</a>)</span>.</p>
<p>An actual free near-semiring looks like this:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Free</span> f x <span class="fu">=</span> <span class="dt">Free</span> {<span class="ot"> unFree ::</span> [<span class="dt">FFree</span> f x] }</a>
<a class="sourceLine" id="cb36-2" data-line-number="2"><span class="kw">data</span> <span class="dt">FFree</span> f x <span class="fu">=</span> <span class="dt">Pure</span> x <span class="fu">|</span> <span class="dt">Con</span> (f (<span class="dt">Free</span> f x))</a></code></pre></div>
<p>Specialised to the <code class="sourceCode haskell"><span class="dt">Identity</span></code> monad, that becomes:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb37-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Forest</span> a <span class="fu">=</span> <span class="dt">Forest</span> {<span class="ot"> unForest ::</span> [<span class="dt">Tree</span> x] }</a>
<a class="sourceLine" id="cb37-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Tree</span> x <span class="fu">=</span> <span class="dt">Leaf</span> x <span class="fu">|</span> <span class="dt">Branch</span> (<span class="dt">Forest</span> x)</a></code></pre></div>
<p>De-specialised to the <a href="https://hackage.haskell.org/package/free-4.12.4/docs/Control-Monad-Trans-Free.html">free monad transformer</a>, it becomes:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb38-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">FreeT</span> f m a <span class="fu">=</span> <span class="dt">FreeT</span></a>
<a class="sourceLine" id="cb38-2" data-line-number="2">  {<span class="ot"> runFreeT ::</span> m (<span class="dt">FreeF</span> f a (<span class="dt">FreeT</span> f m a)) }</a>
<a class="sourceLine" id="cb38-3" data-line-number="3"></a>
<a class="sourceLine" id="cb38-4" data-line-number="4"><span class="kw">data</span> <span class="dt">FreeF</span> f a b</a>
<a class="sourceLine" id="cb38-5" data-line-number="5">  <span class="fu">=</span> <span class="dt">Pure</span> a</a>
<a class="sourceLine" id="cb38-6" data-line-number="6">  <span class="fu">|</span> <span class="dt">Free</span> (f b)</a>
<a class="sourceLine" id="cb38-7" data-line-number="7"></a>
<a class="sourceLine" id="cb38-8" data-line-number="8"><span class="kw">type</span> <span class="dt">FreeNearSemiring</span> f <span class="fu">=</span> <span class="dt">FreeT</span> f []</a></code></pre></div>
<p>These definitions all lend themselves to combinatorial search <span class="citation" data-cites="spivey_algebras_2009 fischer_reinventing_2009 piponi_monad_2009">(Spivey <a href="#ref-spivey_algebras_2009">2009</a>; Fischer <a href="#ref-fischer_reinventing_2009">2009</a>; Piponi <a href="#ref-piponi_monad_2009">2009</a>)</span>, with one extra operation needed: <code class="sourceCode haskell">wrap</code>.</p>
<h2 id="odds">Odds</h2>
<p>Does the <a href="/posts/2016-09-27-odds-lhs.html">odds monad</a> fit in to any of this?</p>
<p>While <code class="sourceCode haskell"><span class="dt">WriterT</span> (<span class="dt">Product</span> <span class="dt">Rational</span>) []</code> is a valid definition of the traditional probability monad, it‚Äôs <em>not</em> the same as the odds monad. If you take the odds monad, and parameterize it over the weight of the tail, you get this:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb39-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Odds</span> m a <span class="fu">=</span> <span class="dt">Certain</span> a <span class="fu">|</span> <span class="dt">Choice</span> (m (a, <span class="dt">Odds</span> a))</a></code></pre></div>
<p>Which looks remarkably like <a href="http://www.haskellforall.com/2016/07/list-transformer-beginner-friendly-listt.html"><code class="sourceCode haskell"><span class="dt">ListT</span></code> done right</a>:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb40-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">ListT</span> m a <span class="fu">=</span> <span class="dt">ListT</span> {<span class="ot"> next ::</span> m (<span class="dt">Step</span> m a) }</a>
<a class="sourceLine" id="cb40-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Step</span> m a <span class="fu">=</span> <span class="dt">Cons</span> a (<span class="dt">ListT</span> m a) <span class="fu">|</span> <span class="dt">Nil</span></a></code></pre></div>
<p>That suggests a relationship between probability and odds:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb41-1" data-line-number="1"><span class="dt">WriterT</span> (<span class="dt">Product</span>  <span class="dt">Rational</span>) [] <span class="fu">=</span> <span class="dt">Probability</span></a>
<a class="sourceLine" id="cb41-2" data-line-number="2"><span class="dt">ListT</span>   (<span class="dt">Weighted</span> <span class="dt">Rational</span>)    <span class="fu">=</span> <span class="dt">Odds</span></a></code></pre></div>
<p><code class="sourceCode haskell"><span class="dt">ListT</span></code> isn‚Äôt a perfect match, though: it allows empty lists. To correct this, you could use the <a href="https://hackage.haskell.org/package/free-4.12.4/docs/Control-Comonad-Cofree.html">Cofree Comonad</a>:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb42-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Cofree</span> f a <span class="fu">=</span> a <span class="fu">:&lt;</span> (f (<span class="dt">Cofree</span> f a))</a></code></pre></div>
<p>Subbing in <code class="sourceCode haskell"><span class="dt">Maybe</span></code> for <code class="sourceCode haskell">f</code>, you get a non-empty list. A <em>weighted</em> <code class="sourceCode haskell"><span class="dt">Maybe</span></code> is basically <a href="http://www.randomhacks.net/2007/02/21/refactoring-probability-distributions/"><code class="sourceCode haskell"><span class="dt">PerhapsT</span></code></a>, as was mentioned earlier.</p>
<h2 id="generalizing-semirings">Generalizing Semirings</h2>
<p>Types in haskell also form a semiring.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb43-1" data-line-number="1">(<span class="fu">&lt;.&gt;</span>) <span class="fu">=</span> (,)</a>
<a class="sourceLine" id="cb43-2" data-line-number="2">one <span class="fu">=</span> ()</a>
<a class="sourceLine" id="cb43-3" data-line-number="3"></a>
<a class="sourceLine" id="cb43-4" data-line-number="4">(<span class="fu">&lt;+&gt;</span>) <span class="fu">=</span> <span class="dt">Either</span></a>
<a class="sourceLine" id="cb43-5" data-line-number="5">zero <span class="fu">=</span> <span class="dt">Void</span></a></code></pre></div>
<p>There‚Äôs a subset of semirings which are <a href="https://en.wikipedia.org/wiki/Semiring#Star_semirings">star semirings</a>. They have an operation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>*</mo><annotation encoding="application/x-tex">*</annotation></semantics></math> such that:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>*</mo><mo>=</mo><mn>1</mn><mo>+</mo><mi>a</mi><mi>a</mi><mo>*</mo><mo>=</mo><mn>1</mn><mo>+</mo><mi>a</mi><mo>*</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">a* = 1 + aa* = 1 + a*a</annotation></semantics></math></p>
<p>Or, as a class:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb44-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Semiring</span> a <span class="ot">=&gt;</span> <span class="dt">StarSemiring</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb44-2" data-line-number="2"><span class="ot">  star ::</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb44-3" data-line-number="3">  star x <span class="fu">=</span> one <span class="fu">&lt;+&gt;</span> plus x</a>
<a class="sourceLine" id="cb44-4" data-line-number="4"><span class="ot">  plus ::</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb44-5" data-line-number="5">  plus x <span class="fu">=</span> x <span class="fu">&lt;.&gt;</span> star x</a></code></pre></div>
<p>Using this on types, you get:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb45-1" data-line-number="1">star a <span class="fu">=</span> <span class="dt">Either</span> () (a, star a)</a></code></pre></div>
<p>Which is just a standard list! Some pseudo-haskell on alternatives will give you:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb46-1" data-line-number="1"><span class="ot">star ::</span> (<span class="dt">Alternative</span> f, <span class="dt">Monoid</span> a) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb46-2" data-line-number="2">star x <span class="fu">=</span> (x <span class="fu">&lt;.&gt;</span> star x) <span class="fu">&lt;+&gt;</span> pure mempty <span class="kw">where</span></a>
<a class="sourceLine" id="cb46-3" data-line-number="3">  (<span class="fu">&lt;.&gt;</span>) <span class="fu">=</span> liftA2 mappend</a>
<a class="sourceLine" id="cb46-4" data-line-number="4">  (<span class="fu">&lt;+&gt;</span>) <span class="fu">=</span> <span class="fu">&lt;|&gt;</span></a></code></pre></div>
<p>Also known as <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Applicative.html#v:many"><code class="sourceCode haskell">many</code></a>. (although note that this breaks all the laws)</p>
<p>The <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>*</mo><annotation encoding="application/x-tex">*</annotation></semantics></math> for rationals is defined as <span class="citation" data-cites="droste_semirings_2009">(Droste and Kuich <a href="#ref-droste_semirings_2009">2009</a>, p8)</span>:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>*</mo><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd columnalign="left"><mfrac><mn>1</mn><mrow><mn>1</mn><mo>‚àí</mo><mi>a</mi></mrow></mfrac></mtd><mtd columnalign="left"><mspace width="1.0em"></mspace><mrow><mtext mathvariant="normal">if </mtext><mspace width="0.333em"></mspace></mrow></mtd><mtd columnalign="left"><mn>0</mn><mo>‚â§</mo><mi>a</mi><mo>&lt;</mo><mn>1</mn><mo>,</mo></mtd></mtr><mtr><mtd columnalign="left"><mi>‚àû</mi></mtd><mtd columnalign="left"><mspace width="1.0em"></mspace><mrow><mtext mathvariant="normal">if </mtext><mspace width="0.333em"></mspace></mrow></mtd><mtd columnalign="left"><mi>a</mi><mo>‚â•</mo><mn>1</mn><mi>.</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">a* = \begin{cases}
  \frac{1}{1 - a} &amp; \quad \text{if  } &amp; 0 \leq a \lt 1, \\
  \infty          &amp; \quad \text{if  } &amp; a \geq 1.
\end{cases}</annotation></semantics></math></p>
<p>So, combining the probability with the type-level business, the star of <code>Writer s a</code> is:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb47-1" data-line-number="1"><span class="dt">Either</span> (<span class="dv">1</span>, a) (a, s <span class="fu">/</span> (<span class="dv">1</span> <span class="fu">-</span> s), star (<span class="dt">Writer</span> s a))</a></code></pre></div>
<p>Or, to put it another way: the odds monad!</p>
<h2 id="endo">Endo</h2>
<p>An <a href="https://ncatlab.org/nlab/show/endomorphism">endomorphism</a> is a morphism from an object to itself. A less general definition (and the one <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Monoid.html#t:Endo">most often used</a> in Haskell) is a function of the type <code class="sourceCode haskell">a <span class="ot">-&gt;</span> a</code>:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb48-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Endo</span> a <span class="fu">=</span> <span class="dt">Endo</span> {<span class="ot"> appEndo ::</span> a <span class="ot">-&gt;</span> a }</a></code></pre></div>
<p>It forms a monoid under composition:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb49-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Monoid</span> (<span class="dt">Endo</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb49-2" data-line-number="2">  mempty <span class="fu">=</span> <span class="dt">Endo</span> id</a>
<a class="sourceLine" id="cb49-3" data-line-number="3">  mappend (<span class="dt">Endo</span> f) (<span class="dt">Endo</span> g) <span class="fu">=</span> <span class="dt">Endo</span> (f <span class="fu">.</span> g)</a></code></pre></div>
<p>If the underlying type is itself a commutative monoid, it also forms near-semiring:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb50-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Monoid</span> a <span class="ot">=&gt;</span> <span class="dt">Semiring</span> (<span class="dt">Endo</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb50-2" data-line-number="2">  <span class="dt">Endo</span> f <span class="fu">&lt;+&gt;</span> <span class="dt">Endo</span> g <span class="fu">=</span> <span class="dt">Endo</span> (\x <span class="ot">-&gt;</span> f x <span class="fu">&lt;&gt;</span> g x)</a>
<a class="sourceLine" id="cb50-3" data-line-number="3">  zero <span class="fu">=</span> <span class="dt">Endo</span> (const mempty)</a>
<a class="sourceLine" id="cb50-4" data-line-number="4">  one <span class="fu">=</span> <span class="dt">Endo</span> id</a>
<a class="sourceLine" id="cb50-5" data-line-number="5">  <span class="dt">Endo</span> f <span class="fu">&lt;.&gt;</span> <span class="dt">Endo</span> g <span class="fu">=</span> <span class="dt">Endo</span> (f <span class="fu">.</span> g)</a>
<a class="sourceLine" id="cb50-6" data-line-number="6">  </a>
<a class="sourceLine" id="cb50-7" data-line-number="7"><span class="kw">instance</span> (<span class="dt">Monoid</span> a, <span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">StarSemiring</span> (<span class="dt">Endo</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb50-8" data-line-number="8">  star (<span class="dt">Endo</span> f) <span class="fu">=</span> <span class="dt">Endo</span> converge <span class="kw">where</span></a>
<a class="sourceLine" id="cb50-9" data-line-number="9">    converge x <span class="fu">=</span> x <span class="fu">&lt;&gt;</span> (<span class="kw">if</span> y <span class="fu">==</span> mempty <span class="kw">then</span> y <span class="kw">else</span> converge y) <span class="kw">where</span></a>
<a class="sourceLine" id="cb50-10" data-line-number="10">      y <span class="fu">=</span> f x</a></code></pre></div>
<p>Here‚Äôs something interesting: there‚Äôs a similarity here to the semiring for church numerals. In fact, as far as I can tell, the functions are <em>exactly</em> the same when applied to endomorphisms of endomorphisms. To the extent that you could define church numerals with something as simple as this:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb51-1" data-line-number="1"><span class="kw">type</span> <span class="dt">ChurchEndoNat</span> <span class="fu">=</span> forall a<span class="fu">.</span> <span class="dt">Endo</span> (<span class="dt">Endo</span> a)</a></code></pre></div>
<p>And it works!</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb52-1" data-line-number="1">two,<span class="ot"> three ::</span> <span class="dt">ChurchEndoNat</span></a>
<a class="sourceLine" id="cb52-2" data-line-number="2">two <span class="fu">=</span> one <span class="fu">&lt;+&gt;</span> one</a>
<a class="sourceLine" id="cb52-3" data-line-number="3">three <span class="fu">=</span> one <span class="fu">&lt;+&gt;</span> two</a>
<a class="sourceLine" id="cb52-4" data-line-number="4"></a>
<a class="sourceLine" id="cb52-5" data-line-number="5"><span class="ot">unChurch ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">ChurchEndoNat</span> <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb52-6" data-line-number="6">unChurch f <span class="fu">=</span> appEndo (appEndo f (<span class="dt">Endo</span> (<span class="dv">1</span><span class="fu">+</span>))) <span class="dv">0</span></a></code></pre></div>
<div class="sourceCode" id="cb53"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell"><a class="sourceLine" id="cb53-1" data-line-number="1">unChurch (two <span class="fu">&lt;.&gt;</span> three)</a>
<a class="sourceLine" id="cb53-2" data-line-number="2"><span class="dv">6</span></a></code></pre></div>
<h2 id="regex">Regex</h2>
<p>One of the most important applications (and a source of much of the notation) is regular expressions. In fact, the free semiring looks like a haskell datatype for regular expressions:</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb54-1" data-line-number="1"><span class="kw">data</span> <span class="dt">FreeStar</span> a</a>
<a class="sourceLine" id="cb54-2" data-line-number="2"> <span class="fu">=</span> <span class="dt">Gen</span> a</a>
<a class="sourceLine" id="cb54-3" data-line-number="3"> <span class="fu">|</span> <span class="dt">Zer</span></a>
<a class="sourceLine" id="cb54-4" data-line-number="4"> <span class="fu">|</span> <span class="dt">One</span></a>
<a class="sourceLine" id="cb54-5" data-line-number="5"> <span class="fu">|</span> <span class="dt">FreeStar</span> a <span class="fu">:&lt;+&gt;</span> <span class="dt">FreeStar</span> a</a>
<a class="sourceLine" id="cb54-6" data-line-number="6"> <span class="fu">|</span> <span class="dt">FreeStar</span> a <span class="fu">:&lt;.&gt;</span> <span class="dt">FreeStar</span> a</a>
<a class="sourceLine" id="cb54-7" data-line-number="7"> <span class="fu">|</span> <span class="dt">Star</span> (<span class="dt">FreeStar</span> a)</a>
<a class="sourceLine" id="cb54-8" data-line-number="8"></a>
<a class="sourceLine" id="cb54-9" data-line-number="9"><span class="kw">instance</span> <span class="dt">Semiring</span> (<span class="dt">FreeStar</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb54-10" data-line-number="10">  (<span class="fu">&lt;+&gt;</span>) <span class="fu">=</span> (<span class="fu">:&lt;+&gt;</span>)</a>
<a class="sourceLine" id="cb54-11" data-line-number="11">  (<span class="fu">&lt;.&gt;</span>) <span class="fu">=</span> (<span class="fu">:&lt;.&gt;</span>)</a>
<a class="sourceLine" id="cb54-12" data-line-number="12">  zero <span class="fu">=</span> <span class="dt">Zer</span></a>
<a class="sourceLine" id="cb54-13" data-line-number="13">  one <span class="fu">=</span> <span class="dt">One</span></a>
<a class="sourceLine" id="cb54-14" data-line-number="14">  </a>
<a class="sourceLine" id="cb54-15" data-line-number="15"><span class="kw">instance</span> <span class="dt">StarSemiring</span> (<span class="dt">FreeStar</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb54-16" data-line-number="16">  star <span class="fu">=</span> <span class="dt">Star</span></a>
<a class="sourceLine" id="cb54-17" data-line-number="17">  </a>
<a class="sourceLine" id="cb54-18" data-line-number="18"><span class="ot">interpret ::</span> <span class="dt">StarSemiring</span> s <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> s) <span class="ot">-&gt;</span> <span class="dt">FreeStar</span> a <span class="ot">-&gt;</span> s</a>
<a class="sourceLine" id="cb54-19" data-line-number="19">interpret f <span class="fu">=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb54-20" data-line-number="20">  <span class="dt">Gen</span> x <span class="ot">-&gt;</span> f x</a>
<a class="sourceLine" id="cb54-21" data-line-number="21">  <span class="dt">Zer</span> <span class="ot">-&gt;</span> zero</a>
<a class="sourceLine" id="cb54-22" data-line-number="22">  <span class="dt">One</span> <span class="ot">-&gt;</span> one</a>
<a class="sourceLine" id="cb54-23" data-line-number="23">  l <span class="fu">:&lt;+&gt;</span> r <span class="ot">-&gt;</span> interpret f l <span class="fu">&lt;+&gt;</span> interpret f r</a>
<a class="sourceLine" id="cb54-24" data-line-number="24">  l <span class="fu">:&lt;.&gt;</span> r <span class="ot">-&gt;</span> interpret f l <span class="fu">&lt;.&gt;</span> interpret f r</a>
<a class="sourceLine" id="cb54-25" data-line-number="25">  <span class="dt">Star</span> x <span class="ot">-&gt;</span> star (interpret f x)</a></code></pre></div>
<p>Then, interpreting the regex is as simple as writing an interpreter (with some help from <code class="sourceCode haskell"><span class="dt">Endo</span></code>):</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb55-1" data-line-number="1"><span class="ot">asRegex ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> <span class="dt">FreeStar</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb55-2" data-line-number="2">asRegex fs <span class="fu">=</span> any null <span class="fu">.</span> appEndo (interpret f fs) <span class="fu">.</span> pure <span class="kw">where</span></a>
<a class="sourceLine" id="cb55-3" data-line-number="3">  f p <span class="fu">=</span> <span class="dt">Endo</span> <span class="fu">.</span> mapMaybe <span class="fu">$</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb55-4" data-line-number="4">    (x<span class="fu">:</span>xs) <span class="fu">|</span> p x <span class="ot">-&gt;</span> <span class="dt">Just</span> xs</a>
<a class="sourceLine" id="cb55-5" data-line-number="5">    _ <span class="ot">-&gt;</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb55-6" data-line-number="6"></a>
<a class="sourceLine" id="cb55-7" data-line-number="7"><span class="ot">char&#39; ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">FreeStar</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb55-8" data-line-number="8">char&#39; c <span class="fu">=</span> <span class="dt">Gen</span> (c<span class="fu">==</span>)</a></code></pre></div>
<p>Actually, you don‚Äôt need the free version at all!</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb56-1" data-line-number="1"><span class="ot">runRegex ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> <span class="dt">Endo</span> [[a]] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb56-2" data-line-number="2">runRegex fs <span class="fu">=</span> any null <span class="fu">.</span> appEndo fs <span class="fu">.</span> pure</a>
<a class="sourceLine" id="cb56-3" data-line-number="3"></a>
<a class="sourceLine" id="cb56-4" data-line-number="4"><span class="ot">char ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Endo</span> [[a]]</a>
<a class="sourceLine" id="cb56-5" data-line-number="5">char c <span class="fu">=</span> <span class="dt">Endo</span> <span class="fu">.</span> mapMaybe <span class="fu">$</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb56-6" data-line-number="6">  (x<span class="fu">:</span>xs) <span class="fu">|</span> c <span class="fu">==</span> x <span class="ot">-&gt;</span> <span class="dt">Just</span> xs</a>
<a class="sourceLine" id="cb56-7" data-line-number="7">  _ <span class="ot">-&gt;</span> <span class="dt">Nothing</span>  </a></code></pre></div>
<p>With some <code class="sourceCode haskell"><span class="fu">-</span><span class="dt">XOverloadedStrings</span></code> magic, you get a pretty nice interface:</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb57-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">IsString</span> (<span class="dt">Endo</span> [<span class="dt">String</span>]) <span class="kw">where</span></a>
<a class="sourceLine" id="cb57-2" data-line-number="2">  fromString <span class="fu">=</span> mul <span class="fu">.</span> map char <span class="fu">.</span> reverse</a>
<a class="sourceLine" id="cb57-3" data-line-number="3">  </a>
<a class="sourceLine" id="cb57-4" data-line-number="4"><span class="ot">(&lt;^&gt;) ::</span> <span class="dt">Semiring</span> s <span class="ot">=&gt;</span> s <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> s</a>
<a class="sourceLine" id="cb57-5" data-line-number="5">(<span class="fu">&lt;^&gt;</span>) <span class="fu">=</span> flip (<span class="fu">&lt;.&gt;</span>)</a>
<a class="sourceLine" id="cb57-6" data-line-number="6"></a>
<a class="sourceLine" id="cb57-7" data-line-number="7"><span class="ot">greet ::</span> <span class="dt">Endo</span> [<span class="dt">String</span>]</a>
<a class="sourceLine" id="cb57-8" data-line-number="8">greet <span class="fu">=</span> <span class="st">&quot;H&quot;</span> <span class="fu">&lt;^&gt;</span> (<span class="st">&quot;a&quot;</span> <span class="fu">&lt;+&gt;</span> <span class="st">&quot;e&quot;</span>) <span class="fu">&lt;^&gt;</span> <span class="st">&quot;llo&quot;</span></a></code></pre></div>
<div class="sourceCode" id="cb58"><pre class="sourceCode haskell literate example hidden_source"><code class="sourceCode haskell"><a class="sourceLine" id="cb58-1" data-line-number="1"><span class="fu">:</span>set <span class="fu">-</span><span class="dt">XOverloadedStrings</span></a></code></pre></div>
<div class="sourceCode" id="cb59"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell"><a class="sourceLine" id="cb59-1" data-line-number="1">runRegex greet <span class="st">&quot;Hello&quot;</span></a>
<a class="sourceLine" id="cb59-2" data-line-number="2"><span class="dt">True</span></a></code></pre></div>
<div class="sourceCode" id="cb60"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell"><a class="sourceLine" id="cb60-1" data-line-number="1">runRegex greet <span class="st">&quot;Hallo&quot;</span></a>
<a class="sourceLine" id="cb60-2" data-line-number="2"><span class="dt">True</span></a></code></pre></div>
<div class="sourceCode" id="cb61"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell"><a class="sourceLine" id="cb61-1" data-line-number="1">runRegex greet <span class="st">&quot;Halo&quot;</span></a>
<a class="sourceLine" id="cb61-2" data-line-number="2"><span class="dt">False</span></a></code></pre></div>
<h2 id="efficiency">Efficiency</h2>
<p>Of course, that‚Äôs about as slow as it gets when it comes to regexes. A faster representation is a <a href="https://swtch.com/~rsc/regexp/regexp1.html">nondeterministic finite automaton</a>. One such implementation in haskell is <a href="https://github.com/Gabriel439/slides/blob/master/regex/regex.md">Gabriel Gonzalez‚Äôs</a>.</p>
<p>The regex type in that example can be immediately made to conform to <code class="sourceCode haskell"><span class="dt">Semiring</span></code> and <code class="sourceCode haskell"><span class="dt">StarSemiring</span></code>. However, it might be more interesting to translate the <em>implementation</em> into using semirings. The type of a regex looks like this:</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb62-1" data-line-number="1"><span class="kw">type</span> <span class="dt">State</span> <span class="fu">=</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb62-2" data-line-number="2"></a>
<a class="sourceLine" id="cb62-3" data-line-number="3">{<span class="ot"> _startingStates         ::</span> <span class="dt">Set</span> <span class="dt">State</span></a>
<a class="sourceLine" id="cb62-4" data-line-number="4">,<span class="ot"> _transitionFunction     ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="ot">-&gt;</span> <span class="dt">Set</span> <span class="dt">State</span></a>
<a class="sourceLine" id="cb62-5" data-line-number="5">,<span class="ot"> _acceptingStates        ::</span> <span class="dt">Set</span> <span class="dt">State</span> }</a></code></pre></div>
<p>The set data structure jumps out as an opportunity to sub in arbitrary semirings.Swapping in the <code class="sourceCode haskell"><span class="dt">GeneralMap</span></code> is reasonably easy:</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb63-1" data-line-number="1"><span class="kw">type</span> <span class="dt">State</span> <span class="fu">=</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb63-2" data-line-number="2"></a>
<a class="sourceLine" id="cb63-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Regex</span> i s <span class="fu">=</span> <span class="dt">Regex</span></a>
<a class="sourceLine" id="cb63-4" data-line-number="4">  {<span class="ot"> _numberOfStates     ::</span> <span class="dt">Int</span> </a>
<a class="sourceLine" id="cb63-5" data-line-number="5">  ,<span class="ot"> _startingStates     ::</span> <span class="dt">GeneralMap</span> <span class="dt">State</span> s</a>
<a class="sourceLine" id="cb63-6" data-line-number="6">  ,<span class="ot"> _transitionFunction ::</span> i <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> <span class="dt">State</span> s</a>
<a class="sourceLine" id="cb63-7" data-line-number="7">  ,<span class="ot"> _acceptingStates    ::</span> <span class="dt">GeneralMap</span> <span class="dt">State</span> s }</a>
<a class="sourceLine" id="cb63-8" data-line-number="8"></a>
<a class="sourceLine" id="cb63-9" data-line-number="9"><span class="ot">isEnd ::</span> <span class="dt">Semiring</span> s <span class="ot">=&gt;</span> <span class="dt">Regex</span> i s <span class="ot">-&gt;</span> s</a>
<a class="sourceLine" id="cb63-10" data-line-number="10">isEnd (<span class="dt">Regex</span> _ as _ bs) <span class="fu">=</span> add (intersection as bs)</a>
<a class="sourceLine" id="cb63-11" data-line-number="11"></a>
<a class="sourceLine" id="cb63-12" data-line-number="12"><span class="ot">match ::</span> <span class="dt">Regex</span> <span class="dt">Char</span> (<span class="dt">Add</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb63-13" data-line-number="13">match r <span class="fu">=</span> getAdd <span class="fu">.</span> isEnd <span class="fu">.</span> foldl&#39; run r <span class="kw">where</span></a>
<a class="sourceLine" id="cb63-14" data-line-number="14">  run (<span class="dt">Regex</span> n (<span class="dt">GeneralMap</span> as) f bs) i <span class="fu">=</span> <span class="dt">Regex</span> n as&#39; f bs</a>
<a class="sourceLine" id="cb63-15" data-line-number="15">    <span class="kw">where</span> as&#39; <span class="fu">=</span> mconcat [ fmap (v<span class="fu">&lt;.&gt;</span>) (f i k)  <span class="fu">|</span> (k,v) <span class="ot">&lt;-</span> Map.assocs as ]</a>
<a class="sourceLine" id="cb63-16" data-line-number="16"></a>
<a class="sourceLine" id="cb63-17" data-line-number="17"></a>
<a class="sourceLine" id="cb63-18" data-line-number="18"><span class="ot">satisfy ::</span> <span class="dt">Semiring</span> s <span class="ot">=&gt;</span> (i <span class="ot">-&gt;</span> s) <span class="ot">-&gt;</span> <span class="dt">Regex</span> i (<span class="dt">Add</span> s)</a>
<a class="sourceLine" id="cb63-19" data-line-number="19">satisfy predicate <span class="fu">=</span> <span class="dt">Regex</span> <span class="dv">2</span> as f bs</a>
<a class="sourceLine" id="cb63-20" data-line-number="20">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb63-21" data-line-number="21">    as <span class="fu">=</span> singleton <span class="dv">0</span></a>
<a class="sourceLine" id="cb63-22" data-line-number="22">    bs <span class="fu">=</span> singleton <span class="dv">1</span></a>
<a class="sourceLine" id="cb63-23" data-line-number="23"></a>
<a class="sourceLine" id="cb63-24" data-line-number="24">    f i <span class="dv">0</span> <span class="fu">=</span> assoc <span class="dv">1</span> (predicate i) mempty</a>
<a class="sourceLine" id="cb63-25" data-line-number="25">    f _ _ <span class="fu">=</span> mempty</a>
<a class="sourceLine" id="cb63-26" data-line-number="26"></a>
<a class="sourceLine" id="cb63-27" data-line-number="27"><span class="ot">once ::</span> <span class="dt">Eq</span> i <span class="ot">=&gt;</span> i <span class="ot">-&gt;</span> <span class="dt">Regex</span> i (<span class="dt">Add</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb63-28" data-line-number="28">once x <span class="fu">=</span> satisfy (<span class="fu">==</span> x)</a>
<a class="sourceLine" id="cb63-29" data-line-number="29"></a>
<a class="sourceLine" id="cb63-30" data-line-number="30"><span class="ot">shift ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> <span class="dt">State</span> s <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> <span class="dt">State</span> s</a>
<a class="sourceLine" id="cb63-31" data-line-number="31">shift n <span class="fu">=</span> <span class="dt">GeneralMap</span> <span class="fu">.</span> Map.fromAscList <span class="fu">.</span> (map<span class="fu">.</span>first) (<span class="fu">+</span> n) <span class="fu">.</span> Map.toAscList <span class="fu">.</span> getMap</a>
<a class="sourceLine" id="cb63-32" data-line-number="32"></a>
<a class="sourceLine" id="cb63-33" data-line-number="33"><span class="kw">instance</span> (<span class="dt">Semiring</span> s, <span class="dt">Monoid</span> s) <span class="ot">=&gt;</span> <span class="dt">Semiring</span> (<span class="dt">Regex</span> i s) <span class="kw">where</span></a>
<a class="sourceLine" id="cb63-34" data-line-number="34"></a>
<a class="sourceLine" id="cb63-35" data-line-number="35">  one <span class="fu">=</span> <span class="dt">Regex</span> <span class="dv">1</span> (singleton <span class="dv">0</span>) (\_ _ <span class="ot">-&gt;</span> mempty) (singleton <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb63-36" data-line-number="36">  zero <span class="fu">=</span> <span class="dt">Regex</span> <span class="dv">0</span> mempty (\_ _ <span class="ot">-&gt;</span> mempty) mempty</a>
<a class="sourceLine" id="cb63-37" data-line-number="37"></a>
<a class="sourceLine" id="cb63-38" data-line-number="38">  <span class="dt">Regex</span> nL asL fL bsL <span class="fu">&lt;+&gt;</span> <span class="dt">Regex</span> nR asR fR bsR <span class="fu">=</span> <span class="dt">Regex</span> n as f bs</a>
<a class="sourceLine" id="cb63-39" data-line-number="39">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb63-40" data-line-number="40">      n  <span class="fu">=</span> nL <span class="fu">+</span> nR</a>
<a class="sourceLine" id="cb63-41" data-line-number="41">      as <span class="fu">=</span> mappend asL (shift nL asR)</a>
<a class="sourceLine" id="cb63-42" data-line-number="42">      bs <span class="fu">=</span> mappend bsL (shift nL bsR)</a>
<a class="sourceLine" id="cb63-43" data-line-number="43">      f i s <span class="fu">|</span> s <span class="fu">&lt;</span> nL    <span class="fu">=</span> fL i s</a>
<a class="sourceLine" id="cb63-44" data-line-number="44">            <span class="fu">|</span> otherwise <span class="fu">=</span> shift nL (fR i (s <span class="fu">-</span> nL))</a>
<a class="sourceLine" id="cb63-45" data-line-number="45"></a>
<a class="sourceLine" id="cb63-46" data-line-number="46">  <span class="dt">Regex</span> nL asL fL bsL <span class="fu">&lt;.&gt;</span> <span class="dt">Regex</span> nR asR fR bsR <span class="fu">=</span> <span class="dt">Regex</span> n as f bs <span class="kw">where</span></a>
<a class="sourceLine" id="cb63-47" data-line-number="47"></a>
<a class="sourceLine" id="cb63-48" data-line-number="48">    n <span class="fu">=</span> nL <span class="fu">+</span> nR</a>
<a class="sourceLine" id="cb63-49" data-line-number="49"></a>
<a class="sourceLine" id="cb63-50" data-line-number="50">    as <span class="fu">=</span> <span class="kw">let</span> ss <span class="fu">=</span> add (intersection asL bsL)</a>
<a class="sourceLine" id="cb63-51" data-line-number="51">         <span class="kw">in</span> mappend asL (fmap (ss<span class="fu">&lt;.&gt;</span>) (shift nL asR))</a>
<a class="sourceLine" id="cb63-52" data-line-number="52"></a>
<a class="sourceLine" id="cb63-53" data-line-number="53">    f i s <span class="fu">=</span></a>
<a class="sourceLine" id="cb63-54" data-line-number="54">        <span class="kw">if</span> s <span class="fu">&lt;</span> nL</a>
<a class="sourceLine" id="cb63-55" data-line-number="55">        <span class="kw">then</span> <span class="kw">let</span> ss <span class="fu">=</span> add (intersection r bsL)</a>
<a class="sourceLine" id="cb63-56" data-line-number="56">             <span class="kw">in</span> mappend r (fmap (ss<span class="fu">&lt;.&gt;</span>) (shift nL asR))</a>
<a class="sourceLine" id="cb63-57" data-line-number="57">        <span class="kw">else</span> shift nL (fR i (s <span class="fu">-</span> nL))</a>
<a class="sourceLine" id="cb63-58" data-line-number="58">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb63-59" data-line-number="59">        r <span class="fu">=</span> fL i s</a>
<a class="sourceLine" id="cb63-60" data-line-number="60">    bs <span class="fu">=</span> shift nL bsR</a>
<a class="sourceLine" id="cb63-61" data-line-number="61"></a>
<a class="sourceLine" id="cb63-62" data-line-number="62"><span class="kw">instance</span> (<span class="dt">StarSemiring</span> s, <span class="dt">Monoid</span> s) <span class="ot">=&gt;</span> <span class="dt">StarSemiring</span> (<span class="dt">Regex</span> i s) <span class="kw">where</span></a>
<a class="sourceLine" id="cb63-63" data-line-number="63">  star (<span class="dt">Regex</span> n as f bs) <span class="fu">=</span> <span class="dt">Regex</span> n as f&#39; as</a>
<a class="sourceLine" id="cb63-64" data-line-number="64">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb63-65" data-line-number="65">      f&#39; i s <span class="fu">=</span></a>
<a class="sourceLine" id="cb63-66" data-line-number="66">          <span class="kw">let</span> r <span class="fu">=</span> f i s</a>
<a class="sourceLine" id="cb63-67" data-line-number="67">              ss <span class="fu">=</span> add (intersection r bs)</a>
<a class="sourceLine" id="cb63-68" data-line-number="68">          <span class="kw">in</span> mappend r (fmap (ss<span class="fu">&lt;.&gt;</span>) as)</a>
<a class="sourceLine" id="cb63-69" data-line-number="69"></a>
<a class="sourceLine" id="cb63-70" data-line-number="70">  plus (<span class="dt">Regex</span> n as f bs) <span class="fu">=</span> <span class="dt">Regex</span> n as f&#39; bs</a>
<a class="sourceLine" id="cb63-71" data-line-number="71">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb63-72" data-line-number="72">      f&#39; i s <span class="fu">=</span></a>
<a class="sourceLine" id="cb63-73" data-line-number="73">          <span class="kw">let</span> r <span class="fu">=</span> f i s</a>
<a class="sourceLine" id="cb63-74" data-line-number="74">              ss <span class="fu">=</span> add (intersection r bs)</a>
<a class="sourceLine" id="cb63-75" data-line-number="75">          <span class="kw">in</span> mappend r (fmap (ss<span class="fu">&lt;.&gt;</span>) as)</a>
<a class="sourceLine" id="cb63-76" data-line-number="76"></a>
<a class="sourceLine" id="cb63-77" data-line-number="77"></a>
<a class="sourceLine" id="cb63-78" data-line-number="78"><span class="kw">instance</span> <span class="dt">IsString</span> (<span class="dt">Regex</span> <span class="dt">Char</span> (<span class="dt">Add</span> <span class="dt">Bool</span>)) <span class="kw">where</span></a>
<a class="sourceLine" id="cb63-79" data-line-number="79">  fromString <span class="fu">=</span> mul <span class="fu">.</span> map once</a></code></pre></div>
<p>This begins to show some of the real power of using semirings and covectors. We have a normal regular expression implementation when we use the covector over bools. Use the probability semiring, and you‚Äôve got probabilistic parsing.</p>
<p>Swap in the <a href="https://ncatlab.org/nlab/show/max-plus+algebra">tropical semiring</a>: a semiring over the reals where addition is the max function, and multiplication is addition of reals. Now you‚Äôve got a depth-first parser.</p>
<p>That‚Äôs how you might swap in different interpretations. How about swapping in different <em>implementations</em>? Well, there might be some use to swapping in the <a href="https://en.wikipedia.org/wiki/CYK_algorithm">CYK algorithm</a>, or the Gauss-Jordan-Floyd-Warshall-McNaughton-Yamada algorithm <span class="citation" data-cites="oconnor_very_2011">(O‚ÄôConnor <a href="#ref-oconnor_very_2011">2011</a>)</span>.</p>
<p>Alternatively, you can swap in the underlying data structure. Instead of a map, if you use an integer (each bit being a value, the keys being the bit position), you have a super-fast implementation (and the final implementation used in the original example). Finally, you could use a different representation of the state transfer function: a matrix.</p>
<h2 id="square-matrices">Square Matrices</h2>
<p>A square matrix can be understood as a map from pairs of indices to values. This lets us use it to represent the state transfer function. Take, for instance, a regular expression with three possible states. Its state transfer function might look like this:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">transfer</mtext><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd columnalign="left"><mn>1</mn><mspace width="1.0em"></mspace></mtd><mtd columnalign="left"><mo stretchy="false" form="prefix">{</mo><mn>2</mn><mo>,</mo><mn>3</mn><mo stretchy="false" form="postfix">}</mo></mtd></mtr><mtr><mtd columnalign="left"><mn>2</mn><mspace width="1.0em"></mspace></mtd><mtd columnalign="left"><mo stretchy="false" form="prefix">{</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo></mtd></mtr><mtr><mtd columnalign="left"><mn>3</mn><mspace width="1.0em"></mspace></mtd><mtd columnalign="left"><mi>‚àÖ</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\text{transfer} = \begin{cases}
1 \quad &amp; \{ 2, 3 \} \\
2 \quad &amp; \{ 1 \} \\
3 \quad &amp; \emptyset
\end{cases}</annotation></semantics></math></p>
<p>It has the type of:</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb64-1" data-line-number="1"><span class="dt">State</span> <span class="ot">-&gt;</span> <span class="dt">Set</span> <span class="dt">State</span></a></code></pre></div>
<p>Where <code class="sourceCode haskell"><span class="dt">State</span></code> is an integer. You can represent the set as a vector, where each position is a key, and each value is whether or not that key is present:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">transfer</mtext><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd columnalign="left"><mn>1</mn><mspace width="1.0em"></mspace></mtd><mtd columnalign="left"><mn>0</mn></mtd><mtd columnalign="left"><mn>1</mn></mtd><mtd columnalign="left"><mn>1</mn></mtd></mtr><mtr><mtd columnalign="left"><mn>2</mn><mspace width="1.0em"></mspace></mtd><mtd columnalign="left"><mn>1</mn></mtd><mtd columnalign="left"><mn>0</mn></mtd><mtd columnalign="left"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="left"><mn>3</mn><mspace width="1.0em"></mspace></mtd><mtd columnalign="left"><mn>0</mn></mtd><mtd columnalign="left"><mn>0</mn></mtd><mtd columnalign="left"><mn>0</mn></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\text{transfer} = \begin{cases}
1 \quad &amp; 0 &amp; 1 &amp; 1 \\
2 \quad &amp; 1 &amp; 0 &amp; 0 \\
3 \quad &amp; 0 &amp; 0 &amp; 0 \end{cases}</annotation></semantics></math></p>
<p>Then, the matrix representation is obvious:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">transfer</mtext><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center"><mn>0</mn></mtd><mtd columnalign="center"><mn>1</mn></mtd><mtd columnalign="center"><mn>1</mn></mtd></mtr><mtr><mtd columnalign="center"><mn>1</mn></mtd><mtd columnalign="center"><mn>0</mn></mtd><mtd columnalign="center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center"><mn>0</mn></mtd><mtd columnalign="center"><mn>0</mn></mtd><mtd columnalign="center"><mn>0</mn></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\text{transfer} = \left( \begin{array}{ccc}
0 &amp; 1 &amp; 1 \\
1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 \end{array} \right)</annotation></semantics></math></p>
<p>This is the semiring of square matrices. It is, of course, yet <em>another</em> covector. The ‚Äúkeys‚Äù are the transfers: <code class="sourceCode haskell"><span class="dv">1</span> <span class="ot">-&gt;</span> <span class="dv">2</span></code> or <code class="sourceCode haskell"><span class="dv">2</span> <span class="ot">-&gt;</span> <span class="dv">3</span></code>, represented by the indices of the matrix. The ‚Äúvalues‚Äù are whether or not that transfer is permitted.</p>
<p>The algorithms for the usual semiring operations on matrices like this are well-known and well-optimized. I haven‚Äôt yet benchmarked them in Haskell using the matrix libraries, so I don‚Äôt know how they compare to the other approaches. In the meantime, there‚Äôs an elegant list-based implementation in <span class="citation" data-cites="dolan_fun_2013">Dolan (<a href="#ref-dolan_fun_2013">2013</a>)</span>:</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb65-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Matrix</span> a <span class="fu">=</span> <span class="dt">Scalar</span> a</a>
<a class="sourceLine" id="cb65-2" data-line-number="2">              <span class="fu">|</span> <span class="dt">Matrix</span> [[a]]</a>
<a class="sourceLine" id="cb65-3" data-line-number="3">              </a>
<a class="sourceLine" id="cb65-4" data-line-number="4"><span class="ot">mjoin ::</span> (<span class="dt">Matrix</span> a, <span class="dt">Matrix</span> a, <span class="dt">Matrix</span> a, <span class="dt">Matrix</span> a) <span class="ot">-&gt;</span> <span class="dt">Matrix</span> a</a>
<a class="sourceLine" id="cb65-5" data-line-number="5">mjoin (<span class="dt">Matrix</span> ws, <span class="dt">Matrix</span> xs, <span class="dt">Matrix</span> ys, <span class="dt">Matrix</span> zs) <span class="fu">=</span></a>
<a class="sourceLine" id="cb65-6" data-line-number="6">  <span class="dt">Matrix</span> ((zipWith (<span class="fu">++</span>) ws xs) <span class="fu">++</span> (zipWith (<span class="fu">++</span>) ys zs))</a>
<a class="sourceLine" id="cb65-7" data-line-number="7">  </a>
<a class="sourceLine" id="cb65-8" data-line-number="8"><span class="ot">msplit ::</span> <span class="dt">Matrix</span> a <span class="ot">-&gt;</span> (<span class="dt">Matrix</span> a, <span class="dt">Matrix</span> a, <span class="dt">Matrix</span> a, <span class="dt">Matrix</span> a)</a>
<a class="sourceLine" id="cb65-9" data-line-number="9">msplit (<span class="dt">Matrix</span> (row<span class="fu">:</span>rows)) <span class="fu">=</span> </a>
<a class="sourceLine" id="cb65-10" data-line-number="10">  (<span class="dt">Matrix</span> [[first]], <span class="dt">Matrix</span> [top]</a>
<a class="sourceLine" id="cb65-11" data-line-number="11">  ,<span class="dt">Matrix</span> left,      <span class="dt">Matrix</span> rest )</a>
<a class="sourceLine" id="cb65-12" data-line-number="12">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb65-13" data-line-number="13">    (first<span class="fu">:</span>top) <span class="fu">=</span> row</a>
<a class="sourceLine" id="cb65-14" data-line-number="14">    (left,rest) <span class="fu">=</span> unzip (map (\(x<span class="fu">:</span>xs) <span class="ot">-&gt;</span> ([x],xs)) rows)</a>
<a class="sourceLine" id="cb65-15" data-line-number="15">    </a>
<a class="sourceLine" id="cb65-16" data-line-number="16"><span class="kw">instance</span> <span class="dt">Semiring</span> a <span class="ot">=&gt;</span> <span class="dt">Semiring</span> (<span class="dt">Matrix</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb65-17" data-line-number="17">  zero <span class="fu">=</span> <span class="dt">Scalar</span> zero</a>
<a class="sourceLine" id="cb65-18" data-line-number="18">  one <span class="fu">=</span> <span class="dt">Scalar</span> one</a>
<a class="sourceLine" id="cb65-19" data-line-number="19">  <span class="dt">Scalar</span> x <span class="fu">&lt;+&gt;</span> <span class="dt">Scalar</span> y <span class="fu">=</span> <span class="dt">Scalar</span> (x <span class="fu">&lt;+&gt;</span> y)</a>
<a class="sourceLine" id="cb65-20" data-line-number="20">  <span class="dt">Matrix</span> x <span class="fu">&lt;+&gt;</span> <span class="dt">Matrix</span> y <span class="fu">=</span></a>
<a class="sourceLine" id="cb65-21" data-line-number="21">    <span class="dt">Matrix</span> (zipWith (zipWith (<span class="fu">&lt;+&gt;</span>)) x y)</a>
<a class="sourceLine" id="cb65-22" data-line-number="22">  <span class="dt">Scalar</span> x <span class="fu">&lt;+&gt;</span> m <span class="fu">=</span> m <span class="fu">&lt;+&gt;</span> <span class="dt">Scalar</span> x</a>
<a class="sourceLine" id="cb65-23" data-line-number="23">  <span class="dt">Matrix</span> [[x]] <span class="fu">&lt;+&gt;</span> <span class="dt">Scalar</span> y <span class="fu">=</span> <span class="dt">Matrix</span> [[x <span class="fu">&lt;+&gt;</span> y]]</a>
<a class="sourceLine" id="cb65-24" data-line-number="24">  x <span class="fu">&lt;+&gt;</span> y <span class="fu">=</span> mjoin (first <span class="fu">&lt;+&gt;</span> y, top, left, rest <span class="fu">&lt;+&gt;</span> y)</a>
<a class="sourceLine" id="cb65-25" data-line-number="25">    <span class="kw">where</span> (first, top, left, rest) <span class="fu">=</span> msplit x</a>
<a class="sourceLine" id="cb65-26" data-line-number="26">  <span class="dt">Scalar</span> x <span class="fu">&lt;.&gt;</span> <span class="dt">Scalar</span> y <span class="fu">=</span> <span class="dt">Scalar</span> (x <span class="fu">&lt;.&gt;</span> y)</a>
<a class="sourceLine" id="cb65-27" data-line-number="27">  <span class="dt">Scalar</span> x <span class="fu">&lt;.&gt;</span> <span class="dt">Matrix</span> y <span class="fu">=</span> <span class="dt">Matrix</span> ((map<span class="fu">.</span>map) (x<span class="fu">&lt;.&gt;</span>) y)</a>
<a class="sourceLine" id="cb65-28" data-line-number="28">  <span class="dt">Matrix</span> x <span class="fu">&lt;.&gt;</span> <span class="dt">Scalar</span> y <span class="fu">=</span> <span class="dt">Matrix</span> ((map<span class="fu">.</span>map) (<span class="fu">&lt;.&gt;</span>y) x)</a>
<a class="sourceLine" id="cb65-29" data-line-number="29">  <span class="dt">Matrix</span> x <span class="fu">&lt;.&gt;</span> <span class="dt">Matrix</span> y <span class="fu">=</span> </a>
<a class="sourceLine" id="cb65-30" data-line-number="30">    <span class="dt">Matrix</span> [ [ foldl1 (<span class="fu">&lt;+&gt;</span>) (zipWith (<span class="fu">&lt;.&gt;</span>) row col) <span class="fu">|</span> col <span class="ot">&lt;-</span> cols ] </a>
<a class="sourceLine" id="cb65-31" data-line-number="31">           <span class="fu">|</span> row <span class="ot">&lt;-</span> x ] <span class="kw">where</span> cols <span class="fu">=</span> transpose y</a>
<a class="sourceLine" id="cb65-32" data-line-number="32"></a>
<a class="sourceLine" id="cb65-33" data-line-number="33"><span class="kw">instance</span> <span class="dt">StarSemiring</span> a <span class="ot">=&gt;</span> <span class="dt">StarSemiring</span> (<span class="dt">Matrix</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb65-34" data-line-number="34">  star (<span class="dt">Matrix</span> [[x]]) <span class="fu">=</span> <span class="dt">Matrix</span> [[star x]]</a>
<a class="sourceLine" id="cb65-35" data-line-number="35">  star m <span class="fu">=</span> mjoin (first&#39; <span class="fu">&lt;+&gt;</span> top&#39; <span class="fu">&lt;.&gt;</span> rest&#39; <span class="fu">&lt;.&gt;</span> left&#39;</a>
<a class="sourceLine" id="cb65-36" data-line-number="36">                 ,top&#39; <span class="fu">&lt;.&gt;</span> rest&#39;, rest&#39; <span class="fu">&lt;.&gt;</span> left&#39;, rest&#39;)</a>
<a class="sourceLine" id="cb65-37" data-line-number="37">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb65-38" data-line-number="38">      (first, top, left, rest) <span class="fu">=</span> msplit m</a>
<a class="sourceLine" id="cb65-39" data-line-number="39">      first&#39; <span class="fu">=</span> star first</a>
<a class="sourceLine" id="cb65-40" data-line-number="40">      top&#39; <span class="fu">=</span> first&#39; <span class="fu">&lt;.&gt;</span> top</a>
<a class="sourceLine" id="cb65-41" data-line-number="41">      left&#39; <span class="fu">=</span> left <span class="fu">&lt;.&gt;</span> first&#39;</a>
<a class="sourceLine" id="cb65-42" data-line-number="42">      rest&#39; <span class="fu">=</span> star (rest <span class="fu">&lt;+&gt;</span> left&#39; <span class="fu">&lt;.&gt;</span> top)</a></code></pre></div>
<h2 id="permutation-parsing">Permutation parsing</h2>
<p>A lot of the use from semirings comes from ‚Äúattaching‚Äù them to other values. Attaching a semiring to effects (in the form of an applicative) can give you <em>repetition</em> of those effects. The excellent <a href="http://hackage.haskell.org/package/ReplicateEffects">ReplicateEffects</a> library explores this concept in depth.</p>
<p>It‚Äôs based on this type:</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb66-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Replicate</span> a b</a>
<a class="sourceLine" id="cb66-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb66-3" data-line-number="3">  <span class="fu">|</span> <span class="dt">Cons</span> (<span class="dt">Maybe</span> b) (<span class="dt">Replicate</span> a (a <span class="ot">-&gt;</span> b))</a></code></pre></div>
<p>This type can be made to conform to <code class="sourceCode haskell"><span class="dt">Semiring</span></code> (and <code class="sourceCode haskell"><span class="dt">Starsemiring</span></code>, etc) trivially.</p>
<p>In the simplest case, it has the same behaviour as <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Monad.html#v:replicateM"><code class="sourceCode haskell">replicateM</code></a>. Even the more complex combinators, like <code class="sourceCode haskell">atLeast</code>, can be built on <code class="sourceCode haskell"><span class="dt">Alternative</span></code>:</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb67-1" data-line-number="1"><span class="ot">atLeast ::</span> <span class="dt">Alternative</span> f <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f [a]</a>
<a class="sourceLine" id="cb67-2" data-line-number="2">atLeast m f <span class="fu">=</span> go (max <span class="dv">0</span> m) <span class="kw">where</span></a>
<a class="sourceLine" id="cb67-3" data-line-number="3">  go <span class="dv">0</span> <span class="fu">=</span> many f</a>
<a class="sourceLine" id="cb67-4" data-line-number="4">  go n <span class="fu">=</span> liftA2 (<span class="fu">:</span>) f (go (n<span class="fu">-</span><span class="dv">1</span>))</a>
<a class="sourceLine" id="cb67-5" data-line-number="5">  </a>
<a class="sourceLine" id="cb67-6" data-line-number="6"><span class="ot">atMost ::</span> <span class="dt">Alternative</span> f <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f [a]</a>
<a class="sourceLine" id="cb67-7" data-line-number="7">atMost m f <span class="fu">=</span> go (max <span class="dv">0</span> m) <span class="kw">where</span></a>
<a class="sourceLine" id="cb67-8" data-line-number="8">  go <span class="dv">0</span> <span class="fu">=</span> pure []</a>
<a class="sourceLine" id="cb67-9" data-line-number="9">  go n <span class="fu">=</span> liftA2 (<span class="fu">:</span>) f (go (n<span class="fu">-</span><span class="dv">1</span>)) <span class="fu">&lt;|&gt;</span> pure []</a></code></pre></div>
<p>There are two main benefits over using the standard alternative implementation. First, you can choose greedy or lazy evaluation of the effects <em>after</em> the replication is built.</p>
<p>Secondly, the <em>order</em> of the effects doesn‚Äôt have to be specified. This allows you to execute permutations of the effects, in a permutation parser, for instance. The permutation is totally decoupled from the declaration of the repetition (it‚Äôs in a totally separate library, in fact: <a href="http://hackage.haskell.org/package/PermuteEffects">PermuteEffects</a>). Its construction is reminiscent of the <a href="https://hackage.haskell.org/package/free-4.12.4/docs/Control-Alternative-Free.html#t:AltF">free alternative</a>.</p>
<p>Having the replicate type conform to <code class="sourceCode haskell"><span class="dt">Semiring</span></code> is all well and good: what I‚Äôm interested in is seeing if its implementation is another semiring-based object in disguise. I‚Äôll revisit this in a later post.</p>
<h2 id="algebraic-search">Algebraic Search</h2>
<p>List comprehension notation is one of my all-time favourite bits of syntactic sugar. It seems almost <em>too</em> declarative to have a reasonable implementation strategy. The vast majority of the time, it actually works in a sensible way. There are exceptions, though. Take a reasonable definition of a list of Pythagorean triples:</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb68-1" data-line-number="1">[ (x,y,z) <span class="fu">|</span> x <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span>], y <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span>], z <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span>], x<span class="fu">*</span>x <span class="fu">+</span> y<span class="fu">*</span>y <span class="fu">==</span> z<span class="fu">*</span>z ]</a></code></pre></div>
<p>This expression will diverge without yielding a single triple. It will search through every possible value for <code class="sourceCode haskell">z</code> before incrementing either <code class="sourceCode haskell">x</code> or <code class="sourceCode haskell">y</code>. Since there are infinite values for <code class="sourceCode haskell">z</code>, it will never find a triple. In other words, vanilla list comprehensions in Haskell perform depth-first search.</p>
<p>In order to express other kinds of search (either breadth-first or depth-bounded), different monads are needed. These monads are explored in <span class="citation" data-cites="fischer_reinventing_2009">Fischer (<a href="#ref-fischer_reinventing_2009">2009</a>)</span> and <span class="citation" data-cites="spivey_algebras_2009">Spivey (<a href="#ref-spivey_algebras_2009">2009</a>)</span>.</p>
<p>You can actually use the <em>exact</em> same notation as above with arbitrary alternative monads using <code class="sourceCode haskell"><span class="fu">-</span><span class="dt">XMonadComprehensions</span></code> and <code class="sourceCode haskell"><span class="fu">-</span><span class="dt">XOverloadedLists</span></code>.</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb69-1" data-line-number="1"><span class="ot">trips ::</span> ( <span class="dt">Alternative</span> m</a>
<a class="sourceLine" id="cb69-2" data-line-number="2">         , <span class="dt">Monad</span> m</a>
<a class="sourceLine" id="cb69-3" data-line-number="3">         , <span class="dt">IsList</span> (m <span class="dt">Integer</span>)</a>
<a class="sourceLine" id="cb69-4" data-line-number="4">         , <span class="dt">Enum</span> (<span class="dt">Item</span> (m <span class="dt">Integer</span>))</a>
<a class="sourceLine" id="cb69-5" data-line-number="5">         , <span class="dt">Num</span> (<span class="dt">Item</span> (m <span class="dt">Integer</span>)))</a>
<a class="sourceLine" id="cb69-6" data-line-number="6">      <span class="ot">=&gt;</span> m (<span class="dt">Integer</span>,<span class="dt">Integer</span>,<span class="dt">Integer</span>)</a>
<a class="sourceLine" id="cb69-7" data-line-number="7">trips <span class="fu">=</span> [ (x,y,z) <span class="fu">|</span> x <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span>], y <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span>], z <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span>], x<span class="fu">*</span>x <span class="fu">+</span> y<span class="fu">*</span>y <span class="fu">==</span> z<span class="fu">*</span>z ]</a></code></pre></div>
<p>So then, here‚Äôs the challenge: swap in different <code class="sourceCode haskell">m</code>s via a type annotation, and prevent <code class="sourceCode haskell">trips</code> from diverging before getting any triples.</p>
<p>As one example, here‚Äôs some code adapted from <span class="citation" data-cites="fischer_reinventing_2009">Fischer (<a href="#ref-fischer_reinventing_2009">2009</a>)</span>:</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb70-1" data-line-number="1"><span class="kw">instance</span> (<span class="dt">Monoid</span> r, <span class="dt">Applicative</span> m) <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">ContT</span> r m a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb70-2" data-line-number="2">  mempty <span class="fu">=</span> <span class="dt">ContT</span> (const (pure mempty))</a>
<a class="sourceLine" id="cb70-3" data-line-number="3">  mappend (<span class="dt">ContT</span> f) (<span class="dt">ContT</span> g) <span class="fu">=</span> <span class="dt">ContT</span> (\x <span class="ot">-&gt;</span> liftA2 mappend (f x) (g x))</a>
<a class="sourceLine" id="cb70-4" data-line-number="4">  </a>
<a class="sourceLine" id="cb70-5" data-line-number="5"><span class="kw">newtype</span> <span class="dt">List</span> a <span class="fu">=</span> <span class="dt">List</span> </a>
<a class="sourceLine" id="cb70-6" data-line-number="6">  {<span class="ot"> runList ::</span> forall m<span class="fu">.</span> <span class="dt">Monoid</span> m <span class="ot">=&gt;</span> <span class="dt">Cont</span> m a } <span class="kw">deriving</span> <span class="dt">Functor</span></a>
<a class="sourceLine" id="cb70-7" data-line-number="7"></a>
<a class="sourceLine" id="cb70-8" data-line-number="8"><span class="kw">instance</span> <span class="dt">Foldable</span> <span class="dt">List</span> <span class="kw">where</span> foldMap <span class="fu">=</span> flip (runCont<span class="fu">.</span>runList)</a>
<a class="sourceLine" id="cb70-9" data-line-number="9">  </a>
<a class="sourceLine" id="cb70-10" data-line-number="10"><span class="kw">instance</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">List</span> a) <span class="kw">where</span> show <span class="fu">=</span> show <span class="fu">.</span> foldr (<span class="fu">:</span>) []</a>
<a class="sourceLine" id="cb70-11" data-line-number="11"></a>
<a class="sourceLine" id="cb70-12" data-line-number="12"><span class="kw">instance</span> <span class="dt">Monoid</span> (<span class="dt">List</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb70-13" data-line-number="13">  mappend (<span class="dt">List</span> x) (<span class="dt">List</span> y) <span class="fu">=</span> <span class="dt">List</span> (mappend x y)</a>
<a class="sourceLine" id="cb70-14" data-line-number="14">  mempty <span class="fu">=</span> <span class="dt">List</span> mempty</a>
<a class="sourceLine" id="cb70-15" data-line-number="15">  </a>
<a class="sourceLine" id="cb70-16" data-line-number="16"><span class="kw">instance</span> <span class="dt">Monoid</span> a <span class="ot">=&gt;</span> <span class="dt">Semiring</span> (<span class="dt">List</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb70-17" data-line-number="17">  zero <span class="fu">=</span> mempty</a>
<a class="sourceLine" id="cb70-18" data-line-number="18">  (<span class="fu">&lt;+&gt;</span>) <span class="fu">=</span> mappend</a>
<a class="sourceLine" id="cb70-19" data-line-number="19">  (<span class="fu">&lt;.&gt;</span>) <span class="fu">=</span> liftA2 mappend</a>
<a class="sourceLine" id="cb70-20" data-line-number="20">  one <span class="fu">=</span> pure mempty</a>
<a class="sourceLine" id="cb70-21" data-line-number="21"></a>
<a class="sourceLine" id="cb70-22" data-line-number="22"><span class="ot">bfs ::</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb70-23" data-line-number="23">bfs <span class="fu">=</span> toList <span class="fu">.</span> fold <span class="fu">.</span> levels <span class="fu">.</span> anyOf</a>
<a class="sourceLine" id="cb70-24" data-line-number="24"></a>
<a class="sourceLine" id="cb70-25" data-line-number="25"><span class="kw">newtype</span> <span class="dt">Levels</span> a <span class="fu">=</span> <span class="dt">Levels</span> {<span class="ot"> levels ::</span> [<span class="dt">List</span> a] } <span class="kw">deriving</span> <span class="dt">Functor</span></a>
<a class="sourceLine" id="cb70-26" data-line-number="26"></a>
<a class="sourceLine" id="cb70-27" data-line-number="27"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Levels</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb70-28" data-line-number="28">  pure x <span class="fu">=</span> <span class="dt">Levels</span> [pure x]</a>
<a class="sourceLine" id="cb70-29" data-line-number="29">  <span class="dt">Levels</span> fs <span class="fu">&lt;*&gt;</span> <span class="dt">Levels</span> xs <span class="fu">=</span> <span class="dt">Levels</span> [ f <span class="fu">&lt;*&gt;</span> x <span class="fu">|</span> f <span class="ot">&lt;-</span> fs, x <span class="ot">&lt;-</span> xs ]</a>
<a class="sourceLine" id="cb70-30" data-line-number="30">  </a>
<a class="sourceLine" id="cb70-31" data-line-number="31"><span class="kw">instance</span> <span class="dt">Alternative</span> <span class="dt">Levels</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb70-32" data-line-number="32">  empty <span class="fu">=</span> <span class="dt">Levels</span> []</a>
<a class="sourceLine" id="cb70-33" data-line-number="33">  <span class="dt">Levels</span> x <span class="fu">&lt;|&gt;</span> <span class="dt">Levels</span> y <span class="fu">=</span> <span class="dt">Levels</span> (mempty <span class="fu">:</span> merge x y)</a>
<a class="sourceLine" id="cb70-34" data-line-number="34"></a>
<a class="sourceLine" id="cb70-35" data-line-number="35"><span class="kw">instance</span> <span class="dt">IsList</span> (<span class="dt">List</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb70-36" data-line-number="36">  <span class="kw">type</span> <span class="dt">Item</span> (<span class="dt">List</span> a) <span class="fu">=</span> a</a>
<a class="sourceLine" id="cb70-37" data-line-number="37">  fromList <span class="fu">=</span> anyOf</a>
<a class="sourceLine" id="cb70-38" data-line-number="38">  toList <span class="fu">=</span> foldr (<span class="fu">:</span>) []</a>
<a class="sourceLine" id="cb70-39" data-line-number="39">  </a>
<a class="sourceLine" id="cb70-40" data-line-number="40"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">List</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb70-41" data-line-number="41">  pure x <span class="fu">=</span> <span class="dt">List</span> (pure x)</a>
<a class="sourceLine" id="cb70-42" data-line-number="42">  (<span class="fu">&lt;*&gt;</span>) <span class="fu">=</span> ap</a>
<a class="sourceLine" id="cb70-43" data-line-number="43"></a>
<a class="sourceLine" id="cb70-44" data-line-number="44"><span class="kw">instance</span> <span class="dt">Alternative</span> <span class="dt">List</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb70-45" data-line-number="45">  empty <span class="fu">=</span> mempty</a>
<a class="sourceLine" id="cb70-46" data-line-number="46">  (<span class="fu">&lt;|&gt;</span>) <span class="fu">=</span> mappend</a>
<a class="sourceLine" id="cb70-47" data-line-number="47"></a>
<a class="sourceLine" id="cb70-48" data-line-number="48"><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">List</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb70-49" data-line-number="49">  x <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> foldMap f x</a>
<a class="sourceLine" id="cb70-50" data-line-number="50"></a>
<a class="sourceLine" id="cb70-51" data-line-number="51"><span class="ot">anyOf ::</span> (<span class="dt">Alternative</span> m, <span class="dt">Foldable</span> f) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> m a</a>
<a class="sourceLine" id="cb70-52" data-line-number="52">anyOf <span class="fu">=</span> getAlt <span class="fu">.</span> foldMap (<span class="dt">Alt</span> <span class="fu">.</span> pure)</a>
<a class="sourceLine" id="cb70-53" data-line-number="53"></a>
<a class="sourceLine" id="cb70-54" data-line-number="54"><span class="ot">merge ::</span> [<span class="dt">List</span> a] <span class="ot">-&gt;</span> [<span class="dt">List</span> a] <span class="ot">-&gt;</span> [<span class="dt">List</span> a]</a>
<a class="sourceLine" id="cb70-55" data-line-number="55">merge []      ys    <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb70-56" data-line-number="56">merge xs      []    <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb70-57" data-line-number="57">merge (x<span class="fu">:</span>xs) (y<span class="fu">:</span>ys) <span class="fu">=</span> mappend x y <span class="fu">:</span> merge xs ys</a></code></pre></div>
<div class="sourceCode" id="cb71"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell"><a class="sourceLine" id="cb71-1" data-line-number="1">take <span class="dv">3</span> (bfs trips)</a>
<a class="sourceLine" id="cb71-2" data-line-number="2">[(<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>),(<span class="dv">4</span>,<span class="dv">3</span>,<span class="dv">5</span>),(<span class="dv">6</span>,<span class="dv">8</span>,<span class="dv">10</span>)]</a></code></pre></div>
<p>The only relevance to semirings is the merge function. The semiring over lists is the semiring over polynomials:</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb72-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Semiring</span> a <span class="ot">=&gt;</span> <span class="dt">Semiring</span> [a] <span class="kw">where</span></a>
<a class="sourceLine" id="cb72-2" data-line-number="2">  one <span class="fu">=</span> [one]</a>
<a class="sourceLine" id="cb72-3" data-line-number="3">  zero <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb72-4" data-line-number="4">  [] <span class="fu">&lt;+&gt;</span> ys <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb72-5" data-line-number="5">  xs <span class="fu">&lt;+&gt;</span> [] <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb72-6" data-line-number="6">  (x<span class="fu">:</span>xs) <span class="fu">&lt;+&gt;</span> (y<span class="fu">:</span>ys) <span class="fu">=</span> (x <span class="fu">&lt;+&gt;</span> y) <span class="fu">:</span> (xs <span class="fu">&lt;+&gt;</span> ys)</a>
<a class="sourceLine" id="cb72-7" data-line-number="7">  [] <span class="fu">&lt;.&gt;</span> _ <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb72-8" data-line-number="8">  _ <span class="fu">&lt;.&gt;</span> [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb72-9" data-line-number="9">  (x<span class="fu">:</span>xs) <span class="fu">&lt;.&gt;</span> (y<span class="fu">:</span>ys) <span class="fu">=</span></a>
<a class="sourceLine" id="cb72-10" data-line-number="10">    (x <span class="fu">&lt;.&gt;</span> y) <span class="fu">:</span> (map (x <span class="fu">&lt;.&gt;</span>) ys <span class="fu">&lt;+&gt;</span> map (<span class="fu">&lt;.&gt;</span> y) xs <span class="fu">&lt;+&gt;</span> (xs <span class="fu">&lt;.&gt;</span> ys))</a></code></pre></div>
<p>The <code class="sourceCode haskell"><span class="fu">&lt;+&gt;</span></code> is the same as the <code class="sourceCode haskell">merge</code> function. I think the <code class="sourceCode haskell"><span class="fu">&lt;.&gt;</span></code> might be a more valid definition of the <code class="sourceCode haskell"><span class="fu">&lt;*&gt;</span></code> function, also.</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb73-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Levels</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb73-2" data-line-number="2">  pure x <span class="fu">=</span> <span class="dt">Levels</span> [pure x]</a>
<a class="sourceLine" id="cb73-3" data-line-number="3">  <span class="dt">Levels</span> [] <span class="fu">&lt;*&gt;</span> _ <span class="fu">=</span> <span class="dt">Levels</span> []</a>
<a class="sourceLine" id="cb73-4" data-line-number="4">  _ <span class="fu">&lt;*&gt;</span> <span class="dt">Levels</span> [] <span class="fu">=</span> <span class="dt">Levels</span> []</a>
<a class="sourceLine" id="cb73-5" data-line-number="5">  <span class="dt">Levels</span> (f<span class="fu">:</span>fs) <span class="fu">&lt;*&gt;</span> <span class="dt">Levels</span> (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="dt">Levels</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb73-6" data-line-number="6">    (f <span class="fu">&lt;*&gt;</span> x) <span class="fu">:</span> levels (<span class="dt">Levels</span> (fmap (f <span class="fu">&lt;*&gt;</span>) xs) </a>
<a class="sourceLine" id="cb73-7" data-line-number="7">             <span class="fu">&lt;|&gt;</span> <span class="dt">Levels</span> (fmap (<span class="fu">&lt;*&gt;</span> x) fs)</a>
<a class="sourceLine" id="cb73-8" data-line-number="8">             <span class="fu">&lt;|&gt;</span> (<span class="dt">Levels</span> fs <span class="fu">&lt;*&gt;</span> <span class="dt">Levels</span> xs))</a></code></pre></div>
<h2 id="conclusion">Conclusion</h2>
<p>I‚Äôve only scratched the surface of this abstraction. There are several other interesting semirings: polynomials, logs, Viterbi, ≈Åukasiewicz, languages, multisets, bidirectional parsers, etc. Hopefully I‚Äôll eventually be able to put this stuff into a library or something. In the meantime, I definitely will write some posts on the application to context-free parsing, bidirectional parsing (I just read <span class="citation" data-cites="breitner_showcasing_2016">Breitner (<a href="#ref-breitner_showcasing_2016">2016</a>)</span>) and search.</p>
<h2 id="references" class="unnumbered">References</h2>
<div id="refs" class="references">
<div id="ref-boom_further_1981">
<p>Boom, H. J. 1981. ‚ÄúFurther thoughts on Abstracto.‚Äù <em>Working Paper ELC-9, IFIP WG 2.1</em>. <a href="http://www.kestrel.edu/home/people/meertens/publications/papers/Abstracto_reader.pdf" class="uri">http://www.kestrel.edu/home/people/meertens/publications/papers/Abstracto_reader.pdf</a>.</p>
</div>
<div id="ref-breitner_showcasing_2016">
<p>Breitner, Joachim. 2016. ‚ÄúShowcasing Applicative.‚Äù <em>Joachim Breitner‚Äôs Blog</em>. <a href="http://www.joachim-breitner.de/blog/710-Showcasing_Applicative" class="uri">http://www.joachim-breitner.de/blog/710-Showcasing_Applicative</a>.</p>
</div>
<div id="ref-doel_free_2015">
<p>Doel, Dan. 2015. ‚ÄúFree Monoids in Haskell.‚Äù <em>The Comonad.Reader</em>. <a href="http://comonad.com/reader/2015/free-monoids-in-haskell/" class="uri">http://comonad.com/reader/2015/free-monoids-in-haskell/</a>.</p>
</div>
<div id="ref-dolan_fun_2013">
<p>Dolan, Stephen. 2013. ‚ÄúFun with semirings: A functional pearl on the abuse of linear algebra.‚Äù In, 48:101. ACM Press. doi:<a href="https://doi.org/10.1145/2500365.2500613">10.1145/2500365.2500613</a>. <a href="https://www.cl.cam.ac.uk/~sd601/papers/semirings.pdf" class="uri">https://www.cl.cam.ac.uk/~sd601/papers/semirings.pdf</a>.</p>
</div>
<div id="ref-droste_semirings_2009">
<p>Droste, Manfred, and Werner Kuich. 2009. ‚ÄúSemirings and Formal Power Series.‚Äù In <em>Handbook of Weighted Automata</em>, ed by. Manfred Droste, Werner Kuich, and Heiko Vogler, 1:3‚Äì28. Monographs in Theoretical Computer Science. An EATCS Series. Berlin, Heidelberg: Springer Berlin Heidelberg. <a href="http://staff.mmcs.sfedu.ru/~ulysses/Edu/Marktoberdorf_2009/working_material/Esparsa/Kuich.%20Semirings%20and%20FPS.pdf">http://staff.mmcs.sfedu.ru/~ulysses/Edu/Marktoberdorf_2009/working_material/Esparsa/Kuich.%20Semirings%20and%20FPS.pdf</a>.</p>
</div>
<div id="ref-erwig_functional_2006">
<p>Erwig, Martin, and Steve Kollmansberger. 2006. ‚ÄúFunctional pearls: Probabilistic functional programming in Haskell.‚Äù <em>Journal of Functional Programming</em> 16 (1): 21‚Äì34. doi:<a href="https://doi.org/10.1017/S0956796805005721">10.1017/S0956796805005721</a>. <a href="http://web.engr.oregonstate.edu/~erwig/papers/abstracts.html#JFP06a" class="uri">http://web.engr.oregonstate.edu/~erwig/papers/abstracts.html#JFP06a</a>.</p>
</div>
<div id="ref-fischer_reinventing_2009">
<p>Fischer, Sebastian. 2009. ‚ÄúReinventing Haskell Backtracking.‚Äù In <em>Informatik 2009, Im Fokus das Leben (ATPS‚Äô09)</em>. GI Edition. <a href="http://www-ps.informatik.uni-kiel.de/~sebf/data/pub/atps09.pdf" class="uri">http://www-ps.informatik.uni-kiel.de/~sebf/data/pub/atps09.pdf</a>.</p>
</div>
<div id="ref-hirschowitz_modules_2010">
<p>Hirschowitz, Andr√©, and Marco Maggesi. 2010. ‚ÄúModules over monads and initial semantics.‚Äù <em>Information and Computation</em> 208 (5). Special Issue: 14th Workshop on Logic, Language, Information and Computation (WoLLIC 2007) (May): 545‚Äì564. doi:<a href="https://doi.org/10.1016/j.ic.2009.07.003">10.1016/j.ic.2009.07.003</a>. <a href="https://pdfs.semanticscholar.org/3e0c/c79e8cda9246cb954da6fd8aaaa394fecdc3.pdf" class="uri">https://pdfs.semanticscholar.org/3e0c/c79e8cda9246cb954da6fd8aaaa394fecdc3.pdf</a>.</p>
</div>
<div id="ref-kidd_build_2007">
<p>Kidd, Eric. 2007. ‚ÄúBuild your own probability monads.‚Äù <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.129.9502&amp;rep=rep1&amp;type=pdf" class="uri">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.129.9502&amp;rep=rep1&amp;type=pdf</a>.</p>
</div>
<div id="ref-kmett_free_2011">
<p>Kmett, Edward. 2011a. ‚ÄúFree Monads for Less (Part 2 of 3): Yoneda.‚Äù <em>The Comonad.Reader</em>. <a href="http://comonad.com/reader/2011/free-monads-for-less-2/" class="uri">http://comonad.com/reader/2011/free-monads-for-less-2/</a>.</p>
</div>
<div id="ref-kmett_modules_2011">
<p>‚Äî‚Äî‚Äî. 2011b. ‚ÄúModules and Functional Linear Functionals.‚Äù <em>The Comonad.Reader</em>. <a href="http://comonad.com/reader/2011/free-modules-and-functional-linear-functionals/" class="uri">http://comonad.com/reader/2011/free-modules-and-functional-linear-functionals/</a>.</p>
</div>
<div id="ref-larsen_memory_2011">
<p>Larsen, Ken Friis. 2011. ‚ÄúMemory Efficient Implementation of Probability Monads.‚Äù <a href="http://www.diku.dk/~kflarsen/t/ProbMonad-unpublished.pdf" class="uri">http://www.diku.dk/~kflarsen/t/ProbMonad-unpublished.pdf</a>.</p>
</div>
<div id="ref-oconnor_very_2011">
<p>O‚ÄôConnor, Russell. 2011. ‚ÄúA Very General Method of Computing Shortest Paths.‚Äù <em>Russell O‚ÄôConnor‚Äôs Blog</em>. <a href="http://r6.ca/blog/20110808T035622Z.html" class="uri">http://r6.ca/blog/20110808T035622Z.html</a>.</p>
</div>
<div id="ref-piponi_monad_2009">
<p>Piponi, Dan. 2009. ‚ÄúA Monad for Combinatorial Search with Heuristics.‚Äù <em>A Neighborhood of Infinity</em>. <a href="http://blog.sigfpe.com/2009/07/monad-for-combinatorial-search-with.html" class="uri">http://blog.sigfpe.com/2009/07/monad-for-combinatorial-search-with.html</a>.</p>
</div>
<div id="ref-rivas_monoids_2015">
<p>Rivas, Exequiel, Mauro Jaskelioff, and Tom Schrijvers. 2015. ‚ÄúFrom monoids to near-semirings: The essence of MonadPlus and Alternative.‚Äù In <em>Proceedings of the 17th International Symposium on Principles and Practice of Declarative Programming</em>, 196‚Äì207. ACM. doi:<a href="https://doi.org/10.1145/2790449.2790514">10.1145/2790449.2790514</a>. <a href="http://www.fceia.unr.edu.ar/~mauro/pubs/FromMonoidstoNearsemirings.pdf" class="uri">http://www.fceia.unr.edu.ar/~mauro/pubs/FromMonoidstoNearsemirings.pdf</a>.</p>
</div>
<div id="ref-spivey_algebras_2009">
<p>Spivey, J. Michael. 2009. ‚ÄúAlgebras for combinatorial search.‚Äù <em>Journal of Functional Programming</em> 19 (3-4) (July): 469‚Äì487. doi:<a href="https://doi.org/10.1017/S0956796809007321">10.1017/S0956796809007321</a>. <a href="https://pdfs.semanticscholar.org/db3e/373bb6e7e7837ebc524da0a25903958554ed.pdf" class="uri">https://pdfs.semanticscholar.org/db3e/373bb6e7e7837ebc524da0a25903958554ed.pdf</a>.</p>
</div>
</div>
]]></description>
    <pubDate>Thu, 17 Nov 2016 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2016-11-17-semirings-lhs.html</guid>
    <dc:creator>Donnacha Ois√≠n Kidney</dc:creator>
</item>
<item>
    <title>Probability Trees</title>
    <link>https://doisinkidney.com/posts/2016-09-30-prob-trees-lhs.html</link>
    <description><![CDATA[<div class="info">
    Posted on September 30, 2016
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Probability.html">Probability</a>
    
</div>

<div class="sourceCode" id="cb1"><pre class="sourceCode haskell literate hidden_source"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">{-# language DeriveFunctor, DeriveFoldable #-}</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="ot">{-# language PatternSynonyms, ViewPatterns #-}</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="kw">module</span> <span class="dt">ProbTree</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="kw">import</span> <span class="dt">Data.Monoid</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map.Strict</span> <span class="kw">as</span> <span class="dt">Map</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"><span class="kw">import</span> <span class="dt">Data.Map.Strict</span> (<span class="dt">Map</span>)</a>
<a class="sourceLine" id="cb1-9" data-line-number="9"><span class="kw">import</span> <span class="dt">Control.Arrow</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10"><span class="kw">import</span> <span class="dt">Data.Ratio</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11"><span class="kw">import</span> <span class="dt">Data.Foldable</span></a></code></pre></div>
<p>Previously, I tried to figure out how to make the probability monad more ‚Äúlisty‚Äù. I read a little more about the topic <span class="citation" data-cites="erwig_functional_2006 kidd_build_2007">(especially Erwig and Kollmansberger <a href="#ref-erwig_functional_2006">2006</a>; and Kidd <a href="#ref-kidd_build_2007">2007</a>)</span>.</p>
<p>I then thought about what a probability monad would look like if it was based on other data structures. I feel like the standard version really wants to be:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">ProperProb</span> a <span class="fu">=</span> <span class="dt">ProperProb</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  {<span class="ot"> yes ::</span> <span class="dt">Map</span> a (<span class="dt">Product</span> <span class="dt">Rational</span>) }</a></code></pre></div>
<p>But of course a monad instance isn‚Äôt allowed.</p>
<p>Similar to a map, though, is a binary tree:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">data</span> <span class="dt">BinaryTree</span> a <span class="fu">=</span> <span class="dt">Leaf</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">                  <span class="fu">|</span> <span class="dt">Node</span> (<span class="dt">BinaryTree</span> a) a (<span class="dt">BinaryTree</span> a)</a></code></pre></div>
<p>And it feels better for probability - <em>flatter</em>, somehow. Transmuting it into a probability-thing:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Odds</span> a <span class="fu">=</span> <span class="dt">Certain</span> a</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">            <span class="fu">|</span> <span class="dt">Choice</span> (<span class="dt">Odds</span> a) <span class="dt">Rational</span> (<span class="dt">Odds</span> a)</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">            <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Functor</span>, <span class="dt">Foldable</span>, <span class="dt">Show</span>)</a></code></pre></div>
<p>That looks good to me. A choice between two different branches feels more natural than a choice between a head and a tail.</p>
<p>The fold is similar to before, with an unfold for good measure:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">foldOdds ::</span> (b <span class="ot">-&gt;</span> <span class="dt">Rational</span> <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">foldOdds f b <span class="fu">=</span> r <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  r (<span class="dt">Certain</span> x) <span class="fu">=</span> b x</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">  r (<span class="dt">Choice</span> xs p ys) <span class="fu">=</span> f (r xs) p (r ys)</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">  </a>
<a class="sourceLine" id="cb5-6" data-line-number="6"><span class="ot">unfoldOdds ::</span> (b <span class="ot">-&gt;</span> <span class="dt">Either</span> a (b,<span class="dt">Rational</span>,b)) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Odds</span> a</a>
<a class="sourceLine" id="cb5-7" data-line-number="7">unfoldOdds f <span class="fu">=</span> r <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8">  r b <span class="fu">=</span> <span class="kw">case</span> f b <span class="kw">of</span></a>
<a class="sourceLine" id="cb5-9" data-line-number="9">    <span class="dt">Left</span> a <span class="ot">-&gt;</span> <span class="dt">Certain</span> a</a>
<a class="sourceLine" id="cb5-10" data-line-number="10">    <span class="dt">Right</span> (x,p,y) <span class="ot">-&gt;</span> <span class="dt">Choice</span> (r x) p (r y)</a>
<a class="sourceLine" id="cb5-11" data-line-number="11">  </a>
<a class="sourceLine" id="cb5-12" data-line-number="12"><span class="ot">fi ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb5-13" data-line-number="13">fi <span class="dt">True</span>  t _ <span class="fu">=</span> t</a>
<a class="sourceLine" id="cb5-14" data-line-number="14">fi <span class="dt">False</span> _ f <span class="fu">=</span> f</a></code></pre></div>
<p>I changed the pattern synonym a little:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="ot">unRatio ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Rational</span> <span class="ot">-&gt;</span> (a,a)</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">unRatio <span class="fu">=</span> numerator   <span class="fu">&amp;&amp;&amp;</span> denominator </a>
<a class="sourceLine" id="cb6-4" data-line-number="4">      <span class="fu">&gt;&gt;&gt;</span> fromInteger <span class="fu">***</span> fromInteger</a>
<a class="sourceLine" id="cb6-5" data-line-number="5"></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">pattern n <span class="fu">:%</span> d <span class="ot">&lt;-</span> (unRatio <span class="ot">-&gt;</span> (n,d))</a></code></pre></div>
<p>Then, the <code class="sourceCode haskell">probOf</code> function:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">probOf ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">probOf e <span class="fu">=</span> foldOdds f b <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  b x <span class="fu">=</span> fi (e <span class="fu">==</span> x) <span class="dv">1</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">  f x (n<span class="fu">:%</span>d) y <span class="fu">=</span> (x <span class="fu">*</span> n <span class="fu">+</span> y <span class="fu">*</span> d) <span class="fu">/</span> (n <span class="fu">+</span> d)</a></code></pre></div>
<p>This version doesn‚Äôt have the option for short-circuiting on the first value it finds.</p>
<p>For generating from lists, you can try to evenly divide the list among each branch.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">fromListOdds ::</span> (([b], <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Integer</span>) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Odds</span> a)</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">fromListOdds fr e <span class="fu">=</span> r <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  r [] <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">  r xs <span class="fu">=</span> <span class="dt">Just</span> (unfoldOdds f (xs, length xs))</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">  f ([x],_) <span class="fu">=</span> <span class="dt">Left</span> (e x)</a>
<a class="sourceLine" id="cb8-6" data-line-number="6">  f (xs ,n) <span class="fu">=</span> <span class="dt">Right</span> ((ys,l), fr (ys,l) <span class="fu">%</span> fr (zs,r), (zs,r)) <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-7" data-line-number="7">    l <span class="fu">=</span> n <span class="ot">`div`</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8">    r <span class="fu">=</span> n <span class="fu">-</span> l</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">    (ys,zs) <span class="fu">=</span> splitAt l xs</a>
<a class="sourceLine" id="cb8-10" data-line-number="10"></a>
<a class="sourceLine" id="cb8-11" data-line-number="11"><span class="ot">equalOdds ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Odds</span> a)</a>
<a class="sourceLine" id="cb8-12" data-line-number="12">equalOdds <span class="fu">=</span> fromListOdds (fromIntegral <span class="fu">.</span> snd) id</a>
<a class="sourceLine" id="cb8-13" data-line-number="13"></a>
<a class="sourceLine" id="cb8-14" data-line-number="14"><span class="ot">fromDistrib ::</span> [(a,<span class="dt">Integer</span>)] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Odds</span> a)</a>
<a class="sourceLine" id="cb8-15" data-line-number="15">fromDistrib <span class="fu">=</span> fromListOdds (sum <span class="fu">.</span> map snd <span class="fu">.</span> fst) fst</a></code></pre></div>
<p>What‚Äôs really nice about this version is the fact that the old <code class="sourceCode haskell">append</code> is just the <code class="sourceCode haskell"><span class="dt">Choice</span></code> constructor, leaving the instances to be really nice:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">flatten ::</span> <span class="dt">Odds</span> (<span class="dt">Odds</span> a) <span class="ot">-&gt;</span> <span class="dt">Odds</span> a</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">flatten <span class="fu">=</span> foldOdds <span class="dt">Choice</span> id</a>
<a class="sourceLine" id="cb9-3" data-line-number="3"></a>
<a class="sourceLine" id="cb9-4" data-line-number="4"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Odds</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  pure <span class="fu">=</span> <span class="dt">Certain</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6">  fs <span class="fu">&lt;*&gt;</span> xs <span class="fu">=</span> flatten (fmap (<span class="fu">&lt;$&gt;</span> xs) fs)</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">  </a>
<a class="sourceLine" id="cb9-8" data-line-number="8"><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Odds</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-9" data-line-number="9">  x <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> flatten (f <span class="fu">&lt;$&gt;</span> x)</a></code></pre></div>
<p>Finally, as a bonus, to remove duplicates:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">lcd ::</span> <span class="dt">Foldable</span> f <span class="ot">=&gt;</span> f <span class="dt">Rational</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">lcd <span class="fu">=</span> foldl&#39; (\a e <span class="ot">-&gt;</span> lcm a (denominator e)) <span class="dv">1</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3"></a>
<a class="sourceLine" id="cb10-4" data-line-number="4"><span class="ot">toDistrib ::</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> [(a,<span class="dt">Integer</span>)]</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">toDistrib <span class="fu">=</span> factorOut <span class="fu">.</span> foldOdds f b <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-6" data-line-number="6">  b x <span class="fu">=</span> [(x,<span class="dv">1</span>)]</a>
<a class="sourceLine" id="cb10-7" data-line-number="7">  f l p r <span class="fu">=</span> (map<span class="fu">.</span>fmap) (n<span class="fu">%</span>t<span class="fu">*</span>) l <span class="fu">++</span> (map<span class="fu">.</span>fmap) (d<span class="fu">%</span>t<span class="fu">*</span>) r <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-8" data-line-number="8">    n <span class="fu">=</span> numerator p</a>
<a class="sourceLine" id="cb10-9" data-line-number="9">    d <span class="fu">=</span> denominator p</a>
<a class="sourceLine" id="cb10-10" data-line-number="10">    t <span class="fu">=</span> n <span class="fu">+</span> d</a>
<a class="sourceLine" id="cb10-11" data-line-number="11">  factorOut xs <span class="fu">=</span> (map<span class="fu">.</span>fmap) (numerator <span class="fu">.</span> (lcd&#39;<span class="fu">*</span>)) xs <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-12" data-line-number="12">    lcd&#39; <span class="fu">=</span> fromIntegral <span class="fu">.</span> lcd <span class="fu">.</span> map snd <span class="fu">$</span> xs</a>
<a class="sourceLine" id="cb10-13" data-line-number="13"></a>
<a class="sourceLine" id="cb10-14" data-line-number="14"><span class="ot">counts ::</span> (<span class="dt">Ord</span> a, <span class="dt">Num</span> n) <span class="ot">=&gt;</span> [(a,n)] <span class="ot">-&gt;</span> [(a,n)]</a>
<a class="sourceLine" id="cb10-15" data-line-number="15">counts <span class="fu">=</span> </a>
<a class="sourceLine" id="cb10-16" data-line-number="16">  Map.assocs <span class="fu">.</span> </a>
<a class="sourceLine" id="cb10-17" data-line-number="17">  Map.fromListWith (<span class="fu">+</span>)</a>
<a class="sourceLine" id="cb10-18" data-line-number="18">      </a>
<a class="sourceLine" id="cb10-19" data-line-number="19"><span class="ot">compress ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Odds</span> a</a>
<a class="sourceLine" id="cb10-20" data-line-number="20">compress xs <span class="fu">=</span> <span class="kw">let</span> <span class="dt">Just</span> ys <span class="fu">=</span> (fromDistrib <span class="fu">.</span> counts <span class="fu">.</span> toDistrib) xs <span class="kw">in</span> ys</a></code></pre></div>
<p>After reading yet more on this, I found that the main issue with the monad is its performance. Two articles in particular: <span class="citation" data-cites="larsen_memory_2011">Larsen (<a href="#ref-larsen_memory_2011">2011</a>)</span>, and <span class="citation" data-cites="scibior_practical_2015">≈öcibior, Ghahramani, and Gordon (<a href="#ref-scibior_practical_2015">2015</a>)</span>, refer to a GADT implementation of the monad which maximises laziness.</p>
<h3 id="references" class="unnumbered">References</h3>
<div id="refs" class="references">
<div id="ref-erwig_functional_2006">
<p>Erwig, Martin, and Steve Kollmansberger. 2006. ‚ÄúFunctional pearls: Probabilistic functional programming in Haskell.‚Äù <em>Journal of Functional Programming</em> 16 (1): 21‚Äì34. doi:<a href="https://doi.org/10.1017/S0956796805005721">10.1017/S0956796805005721</a>.</p>
</div>
<div id="ref-kidd_build_2007">
<p>Kidd, Eric. 2007. ‚ÄúBuild your own probability monads.‚Äù</p>
</div>
<div id="ref-larsen_memory_2011">
<p>Larsen, Ken Friis. 2011. ‚ÄúMemory Efficient Implementation of Probability Monads.‚Äù</p>
</div>
<div id="ref-scibior_practical_2015">
<p>≈öcibior, Adam, Zoubin Ghahramani, and Andrew D. Gordon. 2015. ‚ÄúPractical Probabilistic Programming with Monads.‚Äù In <em>Proceedings of the 2015 ACM SIGPLAN Symposium on Haskell</em>, 50:165‚Äì176. Haskell ‚Äô15. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/2804302.2804317">10.1145/2804302.2804317</a>.</p>
</div>
</div>
]]></description>
    <pubDate>Fri, 30 Sep 2016 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2016-09-30-prob-trees-lhs.html</guid>
    <dc:creator>Donnacha Ois√≠n Kidney</dc:creator>
</item>
<item>
    <title>A Different Probability Monad</title>
    <link>https://doisinkidney.com/posts/2016-09-27-odds-lhs.html</link>
    <description><![CDATA[<div class="info">
    Posted on September 27, 2016
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Probability.html">Probability</a>
    
</div>

<p>One of the more unusual monads is the ‚Äúprobability monad‚Äù:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell literate hidden_source"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">{-# language PatternSynonyms, ViewPatterns #-}</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="ot">{-# language DeriveFunctor, DeriveFoldable #-}</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="ot">{-# language BangPatterns #-}</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="kw">module</span> <span class="dt">Prob</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="kw">import</span> <span class="dt">Control.Arrow</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"><span class="kw">import</span> <span class="dt">Data.Ratio</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9"><span class="kw">import</span> <span class="dt">Data.Foldable</span></a></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Probability</span> a <span class="fu">=</span> <span class="dt">Probability</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  {<span class="ot"> runProb ::</span> [(a,<span class="dt">Rational</span>)] }</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  </a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="kw">data</span> <span class="dt">Coin</span> <span class="fu">=</span> <span class="dt">Heads</span> <span class="fu">|</span> <span class="dt">Tails</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"></a>
<a class="sourceLine" id="cb2-6" data-line-number="6"><span class="ot">toss ::</span> <span class="dt">Probability</span> <span class="dt">Coin</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">toss <span class="fu">=</span> <span class="dt">Probability</span> [(<span class="dt">Heads</span>, <span class="dv">1</span> <span class="fu">%</span> <span class="dv">2</span>), (<span class="dt">Tails</span>, <span class="dv">1</span> <span class="fu">%</span> <span class="dv">2</span>)]</a></code></pre></div>
<p>Although it‚Äôs a little inefficient, it‚Äôs an elegant representation. I‚Äôve written about it before <a href="2015-08-03-monty-hall.html">here</a>.</p>
<p>It has some notable deficiencies, though. For instance: the user has to constantly check that all the probabilities add up to one. Its list can be empty, which doesn‚Äôt make sense. Also, individual outcomes can appear more than once in the same list.</p>
<p>A first go a fixing the problem might look something like this:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Distrib</span> a <span class="fu">=</span> <span class="dt">Distrib</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  {<span class="ot"> runDist ::</span> [(a,<span class="dt">Rational</span>)] }</a>
<a class="sourceLine" id="cb3-3" data-line-number="3"></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="ot">tossProb ::</span> <span class="dt">Distrib</span> <span class="dt">Coin</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">tossProb <span class="fu">=</span> <span class="dt">Distrib</span> [(<span class="dt">Heads</span>, <span class="dv">1</span>), (<span class="dt">Tails</span>, <span class="dv">1</span>)]</a></code></pre></div>
<p>The type is the same as before: it‚Äôs the semantics which have changed. The second field of the tuples no longer have to add up to one. The list can still be empty, though, and now finding the probability of, say, the head, looks like this:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">probHead ::</span> <span class="dt">Distrib</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">probHead (<span class="dt">Distrib</span> xs<span class="fu">@</span>((_,p)<span class="fu">:</span>_)) <span class="fu">=</span> p <span class="fu">/</span> sum [ q <span class="fu">|</span> (_,q) <span class="ot">&lt;-</span> xs ]</a></code></pre></div>
<p>Infinite lists aren‚Äôt possible, either.</p>
<p>One other way to look at the problem is to mimic the structure of cons-lists. Something like this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Odds</span> a <span class="fu">=</span> <span class="dt">Certainly</span> a</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">            <span class="fu">|</span> <span class="dt">Odds</span> a <span class="dt">Rational</span> (<span class="dt">Odds</span> a)</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">            <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Functor</span>, <span class="dt">Foldable</span>, <span class="dt">Show</span>)</a></code></pre></div>
<p>Here, the <code class="sourceCode haskell"><span class="dt">Odds</span></code> constructor (analogous to <code class="sourceCode haskell">(<span class="fu">:</span>)</code>) contains the betting-style odds of the head element vs. <em>the rest of the list</em>. The coin from before is represented by:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">tossOdds ::</span> <span class="dt">Odds</span> <span class="dt">Coin</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">tossOdds <span class="fu">=</span> <span class="dt">Odds</span> <span class="dt">Heads</span> (<span class="dv">1</span> <span class="fu">%</span> <span class="dv">1</span>) (<span class="dt">Certainly</span> <span class="dt">Tails</span>)</a></code></pre></div>
<p>This representation has tons of nice properties. First, let‚Äôs use some pattern-synonym magic for rationals:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1">pattern<span class="ot"> (:%) ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Rational</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">pattern n <span class="fu">:%</span> d <span class="ot">&lt;-</span> (numerator <span class="fu">&amp;&amp;&amp;</span> denominator <span class="ot">-&gt;</span> (n,d)) <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  n <span class="fu">:%</span> d <span class="fu">=</span> n <span class="fu">%</span> d</a></code></pre></div>
<p>Then, finding the probability of the head element is this:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">probHeadOdds ::</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">probHeadOdds (<span class="dt">Certainly</span> _) <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">probHeadOdds (<span class="dt">Odds</span> _ (n <span class="fu">:%</span> d) _) <span class="fu">=</span> n <span class="fu">:%</span> (n <span class="fu">+</span> d)</a></code></pre></div>
<p>The representation can handle infinite lists no problem:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1">probHeadOdds (<span class="dt">Odds</span> <span class="ch">&#39;a&#39;</span> (<span class="dv">1</span> <span class="fu">:%</span> <span class="dv">1</span>) undefined)</a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="dv">1</span> <span class="fu">%</span> <span class="dv">2</span></a></code></pre></div>
<p>Taking the tail preserves semantics, also. To do some more involved manipulation, a fold helper is handy:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">foldOdds ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Rational</span> <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">foldOdds f b <span class="fu">=</span> r <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  r (<span class="dt">Certainly</span> x) <span class="fu">=</span> b x</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">  r (<span class="dt">Odds</span> x p xs) <span class="fu">=</span> f x p (r xs)</a></code></pre></div>
<p>You can use this function to find the probability of a given item:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">probOfEvent ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2">probOfEvent e <span class="fu">=</span> foldOdds f b <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  b x <span class="fu">=</span> <span class="kw">if</span> e <span class="fu">==</span> x <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4">  f x n r <span class="fu">=</span> (<span class="kw">if</span> e <span class="fu">==</span> x <span class="kw">then</span> n <span class="kw">else</span> r) <span class="fu">/</span> (n <span class="fu">+</span> <span class="dv">1</span>)</a></code></pre></div>
<p>This assumes that each item only occurs once. A function which combines multiple events might look like this:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="ot">probOf ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">probOf p <span class="fu">=</span> foldOdds f b <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">  b x <span class="fu">=</span> <span class="kw">if</span> p x <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">  f x n r <span class="fu">=</span> (<span class="kw">if</span> p x <span class="kw">then</span> r <span class="fu">+</span> n <span class="kw">else</span> r) <span class="fu">/</span> (n <span class="fu">+</span> <span class="dv">1</span>)</a></code></pre></div>
<p>Some utility functions to create <code class="sourceCode haskell"><span class="dt">Odds</span></code>:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="ot">equalOdds ::</span> <span class="dt">Foldable</span> f <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Odds</span> a)</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">equalOdds xs <span class="fu">=</span> <span class="kw">case</span> length xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">  <span class="dv">0</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4">  n <span class="ot">-&gt;</span> <span class="dt">Just</span> (foldr f undefined xs (n <span class="fu">-</span> <span class="dv">1</span>)) <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5">    f y a <span class="dv">0</span> <span class="fu">=</span> <span class="dt">Certainly</span> y</a>
<a class="sourceLine" id="cb13-6" data-line-number="6">    f y a n <span class="fu">=</span> <span class="dt">Odds</span> y (<span class="dv">1</span> <span class="fu">%</span> fromIntegral n) (a (n <span class="fu">-</span> <span class="dv">1</span>))</a>
<a class="sourceLine" id="cb13-7" data-line-number="7"></a>
<a class="sourceLine" id="cb13-8" data-line-number="8"><span class="ot">fromDistrib ::</span> [(a,<span class="dt">Integer</span>)] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Odds</span> a)</a>
<a class="sourceLine" id="cb13-9" data-line-number="9">fromDistrib [] <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb13-10" data-line-number="10">fromDistrib xs <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span> f (tot<span class="fu">*</span>lst) xs <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-11" data-line-number="11">  (tot,lst) <span class="fu">=</span> foldl&#39; (\(<span class="fu">!</span>t,_) e <span class="ot">-&gt;</span> (t<span class="fu">+</span>e,e)) (<span class="dv">0</span>,undefined) (map snd xs)</a>
<a class="sourceLine" id="cb13-12" data-line-number="12">  f _ [(x,_)] <span class="fu">=</span> <span class="dt">Certainly</span> x</a>
<a class="sourceLine" id="cb13-13" data-line-number="13">  f n ((x,p)<span class="fu">:</span>xs) <span class="fu">=</span> <span class="dt">Odds</span> x (mp <span class="fu">%</span> np) (f np xs) <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-14" data-line-number="14">    mp <span class="fu">=</span> p <span class="fu">*</span> lst</a>
<a class="sourceLine" id="cb13-15" data-line-number="15">    np <span class="fu">=</span> n <span class="fu">-</span> mp</a>
<a class="sourceLine" id="cb13-16" data-line-number="16">                  </a>
<a class="sourceLine" id="cb13-17" data-line-number="17"><span class="ot">probOfEach ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span></a>
<a class="sourceLine" id="cb13-18" data-line-number="18">probOfEach x xs <span class="fu">=</span> probOf (x<span class="fu">==</span>) xs</a>
<a class="sourceLine" id="cb13-19" data-line-number="19"></a>
<a class="sourceLine" id="cb13-20" data-line-number="20"><span class="ot">propOf ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Rational</span></a>
<a class="sourceLine" id="cb13-21" data-line-number="21">propOf _ [] <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb13-22" data-line-number="22">propOf x xs <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">.</span> uncurry (<span class="fu">%</span>) <span class="fu">$</span></a>
<a class="sourceLine" id="cb13-23" data-line-number="23">  foldl&#39; (\(<span class="fu">!</span>n,<span class="fu">!</span>m) e <span class="ot">-&gt;</span> (<span class="kw">if</span> x <span class="fu">==</span> e <span class="kw">then</span> n<span class="fu">+</span><span class="dv">1</span> <span class="kw">else</span> n, m<span class="fu">+</span><span class="dv">1</span>)) (<span class="dv">0</span>,<span class="dv">0</span>) xs</a></code></pre></div>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell literate prop"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1">propOf x xs <span class="fu">==</span> fmap (probOfEach x) (equalOdds xs)</a></code></pre></div>
<p>And finally, the instances:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="ot">append ::</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span> <span class="ot">-&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Odds</span> a</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">append <span class="fu">=</span> foldOdds f <span class="dt">Odds</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-3" data-line-number="3">  f e r a p ys <span class="fu">=</span> <span class="dt">Odds</span> e ip (a op ys) <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-4" data-line-number="4">    ip <span class="fu">=</span> p <span class="fu">*</span> r <span class="fu">/</span> (p <span class="fu">+</span> r <span class="fu">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">    op <span class="fu">=</span> p <span class="fu">/</span> (r <span class="fu">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb15-6" data-line-number="6"></a>
<a class="sourceLine" id="cb15-7" data-line-number="7"><span class="ot">flatten ::</span> <span class="dt">Odds</span> (<span class="dt">Odds</span> a) <span class="ot">-&gt;</span> <span class="dt">Odds</span> a</a>
<a class="sourceLine" id="cb15-8" data-line-number="8">flatten <span class="fu">=</span> foldOdds append id</a>
<a class="sourceLine" id="cb15-9" data-line-number="9"></a>
<a class="sourceLine" id="cb15-10" data-line-number="10"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Odds</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-11" data-line-number="11">  pure <span class="fu">=</span> <span class="dt">Certainly</span></a>
<a class="sourceLine" id="cb15-12" data-line-number="12">  fs <span class="fu">&lt;*&gt;</span> xs <span class="fu">=</span> flatten (fmap (<span class="fu">&lt;$&gt;</span> xs) fs)</a>
<a class="sourceLine" id="cb15-13" data-line-number="13">  </a>
<a class="sourceLine" id="cb15-14" data-line-number="14"><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Odds</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-15" data-line-number="15">  x <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> flatten (f <span class="fu">&lt;$&gt;</span> x)</a></code></pre></div>
]]></description>
    <pubDate>Tue, 27 Sep 2016 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2016-09-27-odds-lhs.html</guid>
    <dc:creator>Donnacha Ois√≠n Kidney</dc:creator>
</item>
<item>
    <title>Revisiting a Trie in Haskell</title>
    <link>https://doisinkidney.com/posts/2016-09-26-revisiting-trie-lhs.html</link>
    <description><![CDATA[<div class="info">
    Posted on September 26, 2016
</div>
<div class="info">
    
        Part 2 of a <a href="/series/tries.html">2-part series on tries</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Data%20Structures.html">Data Structures</a>
    
</div>

<h1 id="conforming-to-foldable">Conforming to Foldable</h1>
<p>When I ended the last post, I had a nice <code class="sourceCode haskell"><span class="dt">Trie</span></code> datatype, with plenty of functions, but I couldn‚Äôt get it to conform to the standard Haskell classes. The problem was to do with the type variables in the Trie:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell literate hidden_source"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">{-# language GADTs, FlexibleInstances, TypeFamilies #-}</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="ot">{-# language DeriveFoldable, DeriveFunctor, DeriveTraversable #-}</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="ot">{-# language FunctionalDependencies, FlexibleInstances #-}</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="kw">module</span> <span class="dt">Tries</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map.Strict</span> <span class="kw">as</span> <span class="dt">Map</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"><span class="kw">import</span> <span class="dt">Data.Map.Strict</span> (<span class="dt">Map</span>)</a>
<a class="sourceLine" id="cb1-9" data-line-number="9"><span class="kw">import</span> <span class="dt">Data.Foldable</span> <span class="kw">hiding</span> (toList)</a>
<a class="sourceLine" id="cb1-10" data-line-number="10"><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (lookup)</a>
<a class="sourceLine" id="cb1-11" data-line-number="11"><span class="kw">import</span> <span class="dt">Data.Monoid</span></a>
<a class="sourceLine" id="cb1-12" data-line-number="12"><span class="kw">import</span> <span class="dt">GHC.Exts</span> (<span class="dt">IsList</span>(..))</a></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> <span class="dt">OldTrie</span> a <span class="fu">=</span> <span class="dt">OldTrie</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  {<span class="ot"> otEndHere  ::</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  ,<span class="ot"> otChildren ::</span> <span class="dt">Map</span> a (<span class="dt">OldTrie</span> a) }</a></code></pre></div>
<p>Although the type variable is <code class="sourceCode haskell">a</code>, the trie really contains <em>lists</em> of <code class="sourceCode haskell">a</code>s. At least, that‚Äôs what‚Äôs reflected in functions like <code class="sourceCode haskell">insert</code>, <code class="sourceCode haskell">member</code>, etc.:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">member ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Ord</span> a) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">OldTrie</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">member <span class="fu">=</span> foldr f otEndHere <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">  f e a <span class="fu">=</span> maybe <span class="dt">False</span> a <span class="fu">.</span> Map.lookup e <span class="fu">.</span> otChildren</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">  </a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="ot">otInsert ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Ord</span> a) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">OldTrie</span> a <span class="ot">-&gt;</span> <span class="dt">OldTrie</span> a</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">otInsert <span class="fu">=</span> foldr f b <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7">  b (<span class="dt">OldTrie</span> _ c) <span class="fu">=</span> <span class="dt">OldTrie</span> <span class="dt">True</span> c</a>
<a class="sourceLine" id="cb3-8" data-line-number="8">  f e a (<span class="dt">OldTrie</span> n c) <span class="fu">=</span> <span class="dt">OldTrie</span> n (Map.alter (<span class="dt">Just</span> <span class="fu">.</span> a <span class="fu">.</span> fold) e c)</a>
<a class="sourceLine" id="cb3-9" data-line-number="9">  </a>
<a class="sourceLine" id="cb3-10" data-line-number="10"><span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">OldTrie</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-11" data-line-number="11">  mempty <span class="fu">=</span> <span class="dt">OldTrie</span> <span class="dt">False</span> mempty</a>
<a class="sourceLine" id="cb3-12" data-line-number="12">  <span class="dt">OldTrie</span> v c <span class="ot">`mappend`</span> <span class="dt">OldTrie</span> t d <span class="fu">=</span> </a>
<a class="sourceLine" id="cb3-13" data-line-number="13">    <span class="dt">OldTrie</span> (v <span class="fu">||</span> t) (Map.unionWith (<span class="fu">&lt;&gt;</span>) c d)</a></code></pre></div>
<p>Realistically, the type which the trie contains is more like:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="dt">Foldable</span> f <span class="ot">=&gt;</span> <span class="dt">Trie</span> (f a)</a></code></pre></div>
<p>That signature strongly hints at GADTs, as was indicated by <a href="http://stackoverflow.com/questions/33469157/foldable-instance-for-a-trie-set">this stackoverflow answer</a>. The particular GADT which is applicable here is this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">data</span> <span class="dt">TrieSet</span> a <span class="kw">where</span> <span class="dt">TrieSet</span><span class="ot"> ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Map</span> a (<span class="dt">TrieSet</span> [a]) <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> [a]</a></code></pre></div>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell literate hidden_source"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">tsEndHere ::</span> <span class="dt">TrieSet</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">tsEndHere (<span class="dt">TrieSet</span> e _) <span class="fu">=</span> e</a>
<a class="sourceLine" id="cb6-3" data-line-number="3"></a>
<a class="sourceLine" id="cb6-4" data-line-number="4"><span class="ot">tsChildren ::</span> <span class="dt">TrieSet</span> [a] <span class="ot">-&gt;</span> <span class="dt">Map</span> a (<span class="dt">TrieSet</span> [a])</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">tsChildren (<span class="dt">TrieSet</span> _ c) <span class="fu">=</span> c</a>
<a class="sourceLine" id="cb6-6" data-line-number="6"></a>
<a class="sourceLine" id="cb6-7" data-line-number="7"><span class="ot">tsInsert ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Ord</span> a) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> [a] <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> [a]</a>
<a class="sourceLine" id="cb6-8" data-line-number="8">tsInsert <span class="fu">=</span> foldr f b <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-9" data-line-number="9"><span class="ot">  b ::</span> <span class="dt">TrieSet</span> [a] <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> [a]</a>
<a class="sourceLine" id="cb6-10" data-line-number="10"><span class="ot">  f ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> (<span class="dt">TrieSet</span> [a] <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> [a]) <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> [a] <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> [a]</a>
<a class="sourceLine" id="cb6-11" data-line-number="11"></a>
<a class="sourceLine" id="cb6-12" data-line-number="12">  b (<span class="dt">TrieSet</span> _ c) <span class="fu">=</span> <span class="dt">TrieSet</span> <span class="dt">True</span> c</a>
<a class="sourceLine" id="cb6-13" data-line-number="13">  f e a (<span class="dt">TrieSet</span> n c) <span class="fu">=</span> <span class="dt">TrieSet</span> n (Map.alter (<span class="dt">Just</span> <span class="fu">.</span> a <span class="fu">.</span> fold) e c)</a>
<a class="sourceLine" id="cb6-14" data-line-number="14">  </a>
<a class="sourceLine" id="cb6-15" data-line-number="15"><span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">TrieSet</span> [a]) <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-16" data-line-number="16">  mempty <span class="fu">=</span> <span class="dt">TrieSet</span> <span class="dt">False</span> Map.empty</a>
<a class="sourceLine" id="cb6-17" data-line-number="17">  <span class="dt">TrieSet</span> v c <span class="ot">`mappend`</span> <span class="dt">TrieSet</span> t d <span class="fu">=</span> </a>
<a class="sourceLine" id="cb6-18" data-line-number="18">    <span class="dt">TrieSet</span> (v <span class="fu">||</span> t) (Map.unionWith (<span class="fu">&lt;&gt;</span>) c d)</a></code></pre></div>
<p>Why lists and not a general <code class="sourceCode haskell"><span class="dt">Foldable</span></code>? Well, for the particular use I had in mind (conforming to the <code class="sourceCode haskell"><span class="dt">Foldable</span></code> typeclass), I need <code class="sourceCode haskell">(<span class="fu">:</span>)</code>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Foldable</span> <span class="dt">TrieSet</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  foldr f b (<span class="dt">TrieSet</span> e c) <span class="fu">=</span> <span class="kw">if</span> e <span class="kw">then</span> f [] r <span class="kw">else</span> r <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">    r <span class="fu">=</span> Map.foldrWithKey (flip <span class="fu">.</span> g <span class="fu">.</span> (<span class="fu">:</span>)) b c</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">    g k <span class="fu">=</span> foldr (f <span class="fu">.</span> k)</a></code></pre></div>
<p>With some more helper functions, the interface becomes pretty nice:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">TrieSet</span> [a]) <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  showsPrec d t <span class="fu">=</span> </a>
<a class="sourceLine" id="cb8-3" data-line-number="3">    showParen </a>
<a class="sourceLine" id="cb8-4" data-line-number="4">      (d <span class="fu">&gt;</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">      (showString <span class="st">&quot;fromList &quot;</span> <span class="fu">.</span> shows (foldr (<span class="fu">:</span>) [] t))</a>
<a class="sourceLine" id="cb8-6" data-line-number="6"></a>
<a class="sourceLine" id="cb8-7" data-line-number="7"><span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">IsList</span> (<span class="dt">TrieSet</span> [a]) <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8">  <span class="kw">type</span> <span class="dt">Item</span> (<span class="dt">TrieSet</span> [a]) <span class="fu">=</span> [a]</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">  fromList <span class="fu">=</span> foldr tsInsert mempty</a>
<a class="sourceLine" id="cb8-10" data-line-number="10">  toList <span class="fu">=</span> foldr (<span class="fu">:</span>) []</a></code></pre></div>
<p>The trie has the side-effect of lexicographically sorting what it‚Äôs given:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell literate example hidden_source"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="fu">:</span>set <span class="fu">-</span><span class="dt">XGADTs</span></a></code></pre></div>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">fromList [<span class="st">&quot;ced&quot;</span>, <span class="st">&quot;abc&quot;</span>, <span class="st">&quot;ced&quot;</span>, <span class="st">&quot;cb&quot;</span>, <span class="st">&quot;ab&quot;</span>]<span class="ot"> ::</span> <span class="dt">TrieSet</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">fromList [<span class="st">&quot;ab&quot;</span>,<span class="st">&quot;abc&quot;</span>,<span class="st">&quot;cb&quot;</span>,<span class="st">&quot;ced&quot;</span>]</a></code></pre></div>
<h1 id="further-generalizing">Further Generalizing</h1>
<p>Most implementations of tries that I‚Äôve seen are map-like data structures, rather than set-like. In other words, instead of holding a <code class="sourceCode haskell"><span class="dt">Bool</span></code> at the value position, it holds a <code class="sourceCode haskell"><span class="dt">Maybe</span></code> something.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Trie</span> a b <span class="fu">=</span> <span class="dt">Trie</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2">  {<span class="ot"> endHere  ::</span> b</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  ,<span class="ot"> children ::</span> <span class="dt">Map</span> a (<span class="dt">Trie</span> a b) </a>
<a class="sourceLine" id="cb11-4" data-line-number="4">  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>, <span class="dt">Functor</span>, <span class="dt">Foldable</span>, <span class="dt">Traversable</span>)</a></code></pre></div>
<p>This is a much more straightforward datatype. <code class="sourceCode haskell"><span class="dt">Foldable</span></code> can even be automatically derived.</p>
<p>However, I haven‚Äôt made the <code class="sourceCode haskell">endHere</code> field a <code class="sourceCode haskell"><span class="dt">Maybe</span> a</code>. I want to be able to write something like this:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">type</span> <span class="dt">TrieSet</span> [a] <span class="fu">=</span> <span class="dt">Trie</span> a <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="kw">type</span> <span class="dt">TrieMap</span> a b <span class="fu">=</span> <span class="dt">Trie</span> a (<span class="dt">Maybe</span> b)</a></code></pre></div>
<p>And have it automatically choose the implementation of the functions I need<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>.</p>
<p>To do that, though, I‚Äôll need to write the base functions, agnostic of the type of <code>b</code>. I <em>can</em> rely on something like <code class="sourceCode haskell"><span class="dt">Monoid</span></code>, though:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">instance</span> (<span class="dt">Ord</span> a, <span class="dt">Monoid</span> b) <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Trie</span> a b) <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">  mempty <span class="fu">=</span> <span class="dt">Trie</span> mempty Map.empty</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">  mappend (<span class="dt">Trie</span> v k) (<span class="dt">Trie</span> t l) <span class="fu">=</span> </a>
<a class="sourceLine" id="cb13-4" data-line-number="4">    <span class="dt">Trie</span> (v <span class="fu">&lt;&gt;</span> t) (Map.unionWith (<span class="fu">&lt;&gt;</span>) k l)</a></code></pre></div>
<p>In fact, quite a lot of functions naturally lend themselves to this fold + monoid style:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1">lookup<span class="ot"> ::</span> (<span class="dt">Ord</span> a, <span class="dt">Monoid</span> b, <span class="dt">Foldable</span> f) </a>
<a class="sourceLine" id="cb14-2" data-line-number="2">       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Trie</span> a b <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">lookup <span class="fu">=</span> foldr f endHere <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-4" data-line-number="4">  f e a <span class="fu">=</span> foldMap a <span class="fu">.</span> Map.lookup e <span class="fu">.</span> children</a>
<a class="sourceLine" id="cb14-5" data-line-number="5"></a>
<a class="sourceLine" id="cb14-6" data-line-number="6"><span class="ot">insert&#39; ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Ord</span> a, <span class="dt">Monoid</span> b) </a>
<a class="sourceLine" id="cb14-7" data-line-number="7">       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Trie</span> a b <span class="ot">-&gt;</span> <span class="dt">Trie</span> a b</a>
<a class="sourceLine" id="cb14-8" data-line-number="8">insert&#39; xs v <span class="fu">=</span> foldr f b xs <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-9" data-line-number="9">  b (<span class="dt">Trie</span> p c) <span class="fu">=</span> <span class="dt">Trie</span> (v <span class="fu">&lt;&gt;</span> p) c</a>
<a class="sourceLine" id="cb14-10" data-line-number="10">  f e a (<span class="dt">Trie</span> n c) <span class="fu">=</span> </a>
<a class="sourceLine" id="cb14-11" data-line-number="11">    <span class="dt">Trie</span> n (Map.alter (<span class="dt">Just</span> <span class="fu">.</span> a <span class="fu">.</span> fold) e c) </a></code></pre></div>
<p>A monoid is needed for the values, though, and neither <code class="sourceCode haskell"><span class="dt">Bool</span></code> nor <code class="sourceCode haskell"><span class="ot">‚àÄ</span> a<span class="fu">.</span> <span class="dt">Maybe</span> a</code> conform to <code class="sourceCode haskell"><span class="dt">Monoid</span></code>. Looking back to the implementation of the trie-set, the <code class="sourceCode haskell">(<span class="fu">||</span>)</code> function has been replaced by <code class="sourceCode haskell">mappend</code>. There <em>is</em> a newtype wrapper in <code class="sourceCode haskell"><span class="dt">Data.Monoid</span></code> which has exactly this behaviour, though: <code class="sourceCode haskell"><span class="dt">Any</span></code>.</p>
<p>Using that, the type signatures specialize to:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="kw">type</span> <span class="dt">TrieSet</span> a <span class="fu">=</span> <span class="dt">Trie</span> a <span class="dt">Any</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2">lookup<span class="ot"> ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) </a>
<a class="sourceLine" id="cb15-3" data-line-number="3">       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> a <span class="ot">-&gt;</span> <span class="dt">Any</span></a>
<a class="sourceLine" id="cb15-4" data-line-number="4"><span class="ot">insert ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) </a>
<a class="sourceLine" id="cb15-5" data-line-number="5">       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Any</span> <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> a <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> a</a></code></pre></div>
<p>Similarly, for <code class="sourceCode haskell"><span class="dt">Maybe</span></code>, there‚Äôs both <code class="sourceCode haskell"><span class="dt">First</span></code> and <code class="sourceCode haskell"><span class="dt">Last</span></code>. They have the behaviour:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell literate prop"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="dt">First</span> (<span class="dt">Just</span> x) <span class="fu">&lt;&gt;</span> <span class="dt">First</span> (<span class="dt">Just</span> y) <span class="fu">==</span> <span class="dt">First</span> (<span class="dt">Just</span> x)</a></code></pre></div>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell literate prop"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="dt">Last</span>  (<span class="dt">Just</span> x) <span class="fu">&lt;&gt;</span> <span class="dt">Last</span>  (<span class="dt">Just</span> y) <span class="fu">==</span> <span class="dt">Last</span>  (<span class="dt">Just</span> y)</a></code></pre></div>
<p>I think it makes more sense for a value inserted into a map to overwrite whatever was there before. Since the newer value is on the left in the <code class="sourceCode haskell">mappend</code>, then, <code class="sourceCode haskell"><span class="dt">First</span></code> makes most sense.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="kw">type</span> <span class="dt">TrieMap</span> a b <span class="fu">=</span> <span class="dt">Trie</span> a (<span class="dt">First</span> b)</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">lookup<span class="ot"> ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">TrieMap</span> a b <span class="ot">-&gt;</span> <span class="dt">First</span> b</a>
<a class="sourceLine" id="cb18-3" data-line-number="3"><span class="ot">insert ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) </a>
<a class="sourceLine" id="cb18-4" data-line-number="4">       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">First</span> b <span class="ot">-&gt;</span> <span class="dt">TrieMap</span> a b <span class="ot">-&gt;</span> <span class="dt">TrieMap</span> a b</a></code></pre></div>
<p>There are some other ways that you can interpret the monoid. For instance, subbing in <code class="sourceCode haskell"><span class="dt">Sum</span> <span class="dt">Int</span></code> gives you a bag-like trie:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="kw">type</span> <span class="dt">TrieBag</span> a <span class="fu">=</span> <span class="dt">Trie</span> a (<span class="dt">Sum</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">lookup<span class="ot"> ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">TrieBag</span> a <span class="ot">-&gt;</span> <span class="dt">Sum</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb19-3" data-line-number="3"><span class="ot">insert ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) </a>
<a class="sourceLine" id="cb19-4" data-line-number="4">       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Sum</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">TrieBag</span> a <span class="ot">-&gt;</span> <span class="dt">TrieBag</span> a</a></code></pre></div>
<p>This is a set which can store multiple copies of each member. Turned the other way around, a map which stores many values for each key looks like this:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="kw">type</span> <span class="dt">TrieBin</span> a b <span class="fu">=</span> <span class="dt">Trie</span> a [b]</a>
<a class="sourceLine" id="cb20-2" data-line-number="2">lookup<span class="ot"> ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">TrieBin</span> a b <span class="ot">-&gt;</span> [b]</a>
<a class="sourceLine" id="cb20-3" data-line-number="3"><span class="ot">insert ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) </a>
<a class="sourceLine" id="cb20-4" data-line-number="4">       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> <span class="dt">TrieBin</span> a b <span class="ot">-&gt;</span> <span class="dt">TrieBin</span> a b</a></code></pre></div>
<p>This method so far isn‚Äôt really satisfying, though. Really, the <code class="sourceCode haskell">insert</code> signatures should look like this:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="ot">insert ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) </a>
<a class="sourceLine" id="cb21-2" data-line-number="2">       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">TrieMap</span> a b <span class="ot">-&gt;</span> <span class="dt">TrieMap</span> a b</a>
<a class="sourceLine" id="cb21-3" data-line-number="3"><span class="ot">insert ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f)</a>
<a class="sourceLine" id="cb21-4" data-line-number="4">       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">TrieBin</span> a b <span class="ot">-&gt;</span> <span class="dt">TrieBin</span> a b</a></code></pre></div>
<p>Modifying insert slightly, you can get exactly that:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="ot">insert ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Ord</span> a, <span class="dt">Applicative</span> c, <span class="dt">Monoid</span> (c b)) </a>
<a class="sourceLine" id="cb22-2" data-line-number="2">       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Trie</span> a (c b) <span class="ot">-&gt;</span> <span class="dt">Trie</span> a (c b)</a>
<a class="sourceLine" id="cb22-3" data-line-number="3">insert xs v <span class="fu">=</span> foldr f b xs <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-4" data-line-number="4">  b (<span class="dt">Trie</span> p c) <span class="fu">=</span> <span class="dt">Trie</span> (pure v <span class="fu">&lt;&gt;</span> p) c</a>
<a class="sourceLine" id="cb22-5" data-line-number="5">  f e a (<span class="dt">Trie</span> n c) <span class="fu">=</span> <span class="dt">Trie</span> n (Map.alter (<span class="dt">Just</span> <span class="fu">.</span> a <span class="fu">.</span> fold) e c)</a></code></pre></div>
<p><code class="sourceCode haskell">pure</code> from <code class="sourceCode haskell"><span class="dt">Applicative</span></code> is needed for the ‚Äúembedding‚Äù.</p>
<p>Similarly, the ‚Äúinserting‚Äù for the set-like types isn‚Äôt really right. The value argument is out of place. This should be the signature:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="ot">add ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) </a>
<a class="sourceLine" id="cb23-2" data-line-number="2">    <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> a <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> a</a>
<a class="sourceLine" id="cb23-3" data-line-number="3"><span class="ot">add ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f)</a>
<a class="sourceLine" id="cb23-4" data-line-number="4">    <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">TrieBin</span> a <span class="ot">-&gt;</span> <span class="dt">TrieBin</span> a</a></code></pre></div>
<p>In particular, while we have an ‚Äúempty‚Äù thing (0, False) for monoids, we need a ‚Äúone‚Äù thing (1, True) for this function. A semiring<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a> gives this exact method:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Monoid</span> a <span class="ot">=&gt;</span> <span class="dt">Semiring</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-2" data-line-number="2"><span class="ot">  one ::</span> a</a>
<a class="sourceLine" id="cb24-3" data-line-number="3"><span class="ot">  mul ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb24-4" data-line-number="4">  </a>
<a class="sourceLine" id="cb24-5" data-line-number="5"><span class="kw">instance</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Semiring</span> (<span class="dt">Sum</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-6" data-line-number="6">  one <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb24-7" data-line-number="7">  mul <span class="fu">=</span> (<span class="fu">*</span>)</a>
<a class="sourceLine" id="cb24-8" data-line-number="8"></a>
<a class="sourceLine" id="cb24-9" data-line-number="9"><span class="kw">instance</span> <span class="dt">Semiring</span> <span class="dt">Any</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-10" data-line-number="10">  one <span class="fu">=</span> <span class="dt">Any</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb24-11" data-line-number="11">  <span class="dt">Any</span> x <span class="ot">`mul`</span> <span class="dt">Any</span> y <span class="fu">=</span> <span class="dt">Any</span> (x <span class="fu">&amp;&amp;</span> y)</a></code></pre></div>
<p>This class is kind of like a combination of both monoid wrappers for both <code class="sourceCode haskell"><span class="dt">Int</span></code> and <code class="sourceCode haskell"><span class="dt">Bool</span></code>. You could take advantage of that:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1"></a>
<a class="sourceLine" id="cb25-2" data-line-number="2"><span class="kw">class</span> (<span class="dt">Monoid</span> add, <span class="dt">Monoid</span> mult)</a>
<a class="sourceLine" id="cb25-3" data-line-number="3">  <span class="ot">=&gt;</span> <span class="dt">SemiringIso</span> a add mult <span class="fu">|</span> a <span class="ot">-&gt;</span> add, a <span class="ot">-&gt;</span> mult <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-4" data-line-number="4"><span class="ot">    toAdd    ::</span> a <span class="ot">-&gt;</span> add</a>
<a class="sourceLine" id="cb25-5" data-line-number="5"><span class="ot">    fromAdd  ::</span> add <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb25-6" data-line-number="6"><span class="ot">    toMult   ::</span> a <span class="ot">-&gt;</span> mult</a>
<a class="sourceLine" id="cb25-7" data-line-number="7"><span class="ot">    fromMult ::</span> mult <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb25-8" data-line-number="8">  </a>
<a class="sourceLine" id="cb25-9" data-line-number="9">(<span class="fu">&lt;+&gt;</span>),<span class="ot"> (&lt;.&gt;) ::</span> <span class="dt">SemiringIso</span> a add mult <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb25-10" data-line-number="10"></a>
<a class="sourceLine" id="cb25-11" data-line-number="11">x <span class="fu">&lt;+&gt;</span> y <span class="fu">=</span> fromAdd  (toAdd  x <span class="fu">&lt;&gt;</span> toAdd  y)</a>
<a class="sourceLine" id="cb25-12" data-line-number="12">x <span class="fu">&lt;.&gt;</span> y <span class="fu">=</span> fromMult (toMult x <span class="fu">&lt;&gt;</span> toMult y)</a>
<a class="sourceLine" id="cb25-13" data-line-number="13"></a>
<a class="sourceLine" id="cb25-14" data-line-number="14"><span class="kw">instance</span> <span class="dt">SemiringIso</span> <span class="dt">Int</span> (<span class="dt">Sum</span> <span class="dt">Int</span>) (<span class="dt">Product</span> <span class="dt">Int</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-15" data-line-number="15">  toAdd    <span class="fu">=</span> <span class="dt">Sum</span></a>
<a class="sourceLine" id="cb25-16" data-line-number="16">  fromAdd  <span class="fu">=</span> getSum</a>
<a class="sourceLine" id="cb25-17" data-line-number="17">  toMult   <span class="fu">=</span> <span class="dt">Product</span></a>
<a class="sourceLine" id="cb25-18" data-line-number="18">  fromMult <span class="fu">=</span> getProduct</a>
<a class="sourceLine" id="cb25-19" data-line-number="19"></a>
<a class="sourceLine" id="cb25-20" data-line-number="20"><span class="kw">instance</span> <span class="dt">SemiringIso</span> <span class="dt">Bool</span> <span class="dt">Any</span> <span class="dt">All</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-21" data-line-number="21">  toAdd    <span class="fu">=</span> <span class="dt">Any</span></a>
<a class="sourceLine" id="cb25-22" data-line-number="22">  fromAdd  <span class="fu">=</span> getAny</a>
<a class="sourceLine" id="cb25-23" data-line-number="23">  toMult   <span class="fu">=</span> <span class="dt">All</span></a>
<a class="sourceLine" id="cb25-24" data-line-number="24">  fromMult <span class="fu">=</span> getAll</a></code></pre></div>
<p>But it seems like overkill.</p>
<p>Anyway, assuming that we have the functions from <code class="sourceCode haskell"><span class="dt">Semiring</span></code>, here‚Äôs the <code>add</code> function:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="ot">add ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Ord</span> a, <span class="dt">Semiring</span> b) </a>
<a class="sourceLine" id="cb26-2" data-line-number="2">    <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Trie</span> a b <span class="ot">-&gt;</span> <span class="dt">Trie</span> a b</a>
<a class="sourceLine" id="cb26-3" data-line-number="3">add xs <span class="fu">=</span> foldr f b xs <span class="kw">where</span></a>
<a class="sourceLine" id="cb26-4" data-line-number="4">  b (<span class="dt">Trie</span> p c) <span class="fu">=</span> <span class="dt">Trie</span> (one <span class="fu">&lt;&gt;</span> p) c</a>
<a class="sourceLine" id="cb26-5" data-line-number="5">  f e a (<span class="dt">Trie</span> n c) <span class="fu">=</span> </a>
<a class="sourceLine" id="cb26-6" data-line-number="6">    <span class="dt">Trie</span> n (Map.alter (<span class="dt">Just</span> <span class="fu">.</span> a <span class="fu">.</span> fold) e c)</a></code></pre></div>
<p>Now, expressions can be built up without specifying the specific monoid implementation, and the whole behaviour can be changed with a type signature:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell literate hidden_source"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="kw">instance</span> (<span class="dt">Ord</span> a, <span class="dt">Semiring</span> b) <span class="ot">=&gt;</span> <span class="dt">IsList</span> (<span class="dt">Trie</span> a b) <span class="kw">where</span></a>
<a class="sourceLine" id="cb27-2" data-line-number="2">  <span class="kw">type</span> <span class="dt">Item</span> (<span class="dt">Trie</span> a b) <span class="fu">=</span> [a]</a>
<a class="sourceLine" id="cb27-3" data-line-number="3">  fromList <span class="fu">=</span> foldr add mempty</a>
<a class="sourceLine" id="cb27-4" data-line-number="4">  toList <span class="fu">=</span> undefined</a>
<a class="sourceLine" id="cb27-5" data-line-number="5"><span class="ot">ans ::</span> <span class="dt">Semiring</span> b <span class="ot">=&gt;</span> b</a></code></pre></div>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1">ans <span class="fu">=</span> lookup <span class="st">&quot;abc&quot;</span> (fromList [<span class="st">&quot;abc&quot;</span>, <span class="st">&quot;def&quot;</span>, <span class="st">&quot;abc&quot;</span>, <span class="st">&quot;ghi&quot;</span>])</a></code></pre></div>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" data-line-number="1"><span class="ot">ans ::</span> <span class="dt">Sum</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb29-2" data-line-number="2"><span class="dt">Sum</span> {getSum <span class="fu">=</span> <span class="dv">2</span>}</a></code></pre></div>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="ot">ans ::</span> <span class="dt">Any</span></a>
<a class="sourceLine" id="cb30-2" data-line-number="2"><span class="dt">Any</span> {getAny <span class="fu">=</span> <span class="dt">True</span>}</a></code></pre></div>
<p>Slightly fuller implementations of all of these are available <a href="https://github.com/oisdk/hstrie">here</a>.</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Kind of like <a href="https://www.youtube.com/watch?v=3U3lV5VPmOU">program inference in lieu of type inference</a><a href="#fnref1" class="footnote-back">‚Ü©</a></p></li>
<li id="fn2"><p>This isn‚Äôt really a very good definition of semiring. While Haskell doesn‚Äôt have this class in base, <a href="https://github.com/purescript/purescript-prelude/blob/master/src/Data/Semiring.purs">Purescript has it in their prelude.</a><a href="#fnref2" class="footnote-back">‚Ü©</a></p></li>
</ol>
</section>
]]></description>
    <pubDate>Mon, 26 Sep 2016 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2016-09-26-revisiting-trie-lhs.html</guid>
    <dc:creator>Donnacha Ois√≠n Kidney</dc:creator>
</item>
<item>
    <title>Lenses are Static Selectors</title>
    <link>https://doisinkidney.com/posts/2016-06-16-lenses-are-static-selectors.html</link>
    <description><![CDATA[<div class="info">
    Posted on June 16, 2016
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Swift.html">Swift</a>
    
</div>

<p>So I don‚Äôt really know what <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/KeyValueCoding/Articles/KeyValueCoding.html">KVC</a> is, or much about <code class="sourceCode scala">performSelector</code> functions. <a href="http://inessential.com/2016/05/20/updating_local_objects_with_server_objec">This</a> blogpost, from Brent Simmons, let me know a little bit about why I would want to use them.</p>
<p>It centred around removing code repetition of this type:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">if</span> localObject.<span class="fu">foo</span> != serverObject.<span class="fu">foo</span> {</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  localObject.<span class="fu">foo</span> = serverObject.<span class="fu">foo</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">}</a>
<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="kw">if</span> localObject.<span class="fu">bar</span> != serverObject.<span class="fu">bar</span> {</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">  localObject.<span class="fu">bar</span> = serverObject.<span class="fu">bar</span> <span class="co">// There was an (intentional)</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">}                                    <span class="co">// bug here in the original post</span></a></code></pre></div>
<p>To clean up the code, Brent used selector methods. At first, I was a little uncomfortable with the solution. As far as I could tell, the basis of a lot of this machinery used functions with types like this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb2-1" data-line-number="1">func <span class="fu">get</span>(fromSelector: String) -&gt; AnyObject?</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">func <span class="fu">set</span>(forSelector: String) -&gt; ()</a></code></pre></div>
<p>Which <em>seems</em> to be extremely dynamic. Stringly-typed and all that. Except that there are two different things going on here. One is the dynamic stuff; the ability to get rid of types when you need to. The other, though, has <em>nothing</em> to do with types. The other idea is being able to pass around something which can access the property (or method) of an object. Let‚Äôs look at the code that was being repeated:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">if</span> localObject.<span class="fu">foo</span> != serverObject.<span class="fu">foo</span> {</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  localObject.<span class="fu">foo</span> = serverObject.<span class="fu">foo</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">}</a>
<a class="sourceLine" id="cb3-4" data-line-number="4"></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="kw">if</span> localObject.<span class="fu">bar</span> != serverObject.<span class="fu">bar</span> {</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">  localObject.<span class="fu">bar</span> = serverObject.<span class="fu">bar</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7">}</a></code></pre></div>
<p>The logical, obvious thing to do here is try refactor out the common elements. In fact, the only things that <em>differ</em> between the two actions above are the <code class="sourceCode scala">foo</code> and <code class="sourceCode scala">bar</code>. It would be great to be able to write a function like this:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb4-1" data-line-number="1">func <span class="fu">checkThenUpdate</span>(selector) {</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  <span class="kw">if</span> localObject.<span class="fu">selector</span> != serverObject.<span class="fu">selector</span> {</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">    localObject.<span class="fu">selector</span> = serverObject.<span class="fu">selector</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">  }</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">}</a></code></pre></div>
<p>And then maybe a single line like this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb5-1" data-line-number="1">[foo, bar, baz].<span class="fu">forEach</span>(checkThenUpdate)</a></code></pre></div>
<p>That‚Äôs pretty obviously better. It‚Äôs just good programming: when faced with repetition, find the repeated part, and abstract it out. Is it more <em>dynamic</em> than the repetition, though? I don‚Äôt think so. All you have to figure out is an appropriate type for the selector, and you can keep all of your static checking. To me, it seems a lot like a <a href="https://hackage.haskell.org/package/lens">lens</a>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb6-1" data-line-number="1">struct Lens&lt;Whole, Part&gt; {</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  let get: Whole -&gt; Part</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  let set: (Whole, Part) -&gt; Whole</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">}</a></code></pre></div>
<p>(This is a lens similar to the ones used in the <a href="http://hackage.haskell.org/package/data-lens">data-lens</a> library, in contrast to van Laarhoven lenses, or LensFamilies. LensFamilies are used in the <a href="https://hackage.haskell.org/package/lens">lens</a> package, and they allow you to change the type of the <code class="sourceCode scala">Part</code>. They‚Äôre also just normal functions, rather than a separate type, so you can manipulate them in a pretty standard way. Swift‚Äôs type system isn‚Äôt able to model those lenses, though, unfortunately.) It has two things: a getter and a setter. The getter is pretty obvious: it takes the object, and returns the property. The setter is a little more confusing. It‚Äôs taking an object, and the new property you want to stick in to the object, and returns the object with that property updated. For instance, if we were to make a <code class="sourceCode scala">Person</code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb7-1" data-line-number="1">struct LocalPerson {</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  <span class="kw">var</span> age: Int</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  <span class="kw">var</span> name: String</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">}</a></code></pre></div>
<p>We could then have a lens for the <code class="sourceCode scala">name</code> field like this:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb8-1" data-line-number="1">let localName: Lens&lt;LocalPerson,String&gt; = <span class="fu">Lens</span>(</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  get: { p in p.<span class="fu">name</span> },</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  set: { (oldPerson,newName) in</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">    <span class="kw">var</span> newPerson = oldPerson</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">    newPerson.<span class="fu">name</span> = newName</a>
<a class="sourceLine" id="cb8-6" data-line-number="6">    <span class="kw">return</span> newPerson</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">  }</a>
<a class="sourceLine" id="cb8-8" data-line-number="8">)</a></code></pre></div>
<p>And you‚Äôd use it like this:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb9-1" data-line-number="1">let caoimhe = <span class="fu">LocalPerson</span>(age: <span class="dv">46</span>, name: <span class="st">&quot;caoimhe&quot;</span>)</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">localName.<span class="fu">get</span>(caoimhe) <span class="co">// 46</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">localName.<span class="fu">set</span>(caoimhe, <span class="st">&quot;breifne&quot;</span>) <span class="co">// LocalPerson(age: 46, name: &quot;breifne&quot;)</span></a></code></pre></div>
<p>Straight away, we‚Äôre able to do (something) like the <code class="sourceCode scala">checkThenUpdate</code> function:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb10-1" data-line-number="1">func checkThenUpdate</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">  &lt;A: Equatable&gt;</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  (localLens: Lens&lt;LocalPerson,A&gt;, serverLens: Lens&lt;ServerPerson,A&gt;) {</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">  let serverProp = serverLens.<span class="fu">get</span>(serverObject)</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">  <span class="kw">if</span> localLens.<span class="fu">get</span>(localObject) != serverProp {</a>
<a class="sourceLine" id="cb10-6" data-line-number="6">    localObject = localLens.<span class="fu">set</span>(localObject,serverProp)</a>
<a class="sourceLine" id="cb10-7" data-line-number="7">  }</a>
<a class="sourceLine" id="cb10-8" data-line-number="8">}</a></code></pre></div>
<p>And it could be called pretty tersely:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="fu">checkThenUpdate</span>(localName, serverLens: serverName)</a></code></pre></div>
<p>The biggest problem with this approach, obviously, is the boilerplate. In Haskell, that‚Äôs solved with Template Haskell, so the lens code is generated for you. (I‚Äôd love to see something like that in Swift) There‚Äôs a protocol-oriented spin on lenses, also. One of the variants on lenses in Haskell are called ‚Äúclassy-lenses‚Äù. That‚Äôs where, instead of just generating a lens with the same name as the field it looks into, you generate a typeclass (protocol) for anything with that lens. In Swift, it might work something like this:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb12-1" data-line-number="1">struct Place {</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">  <span class="kw">var</span> name: String</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">}</a>
<a class="sourceLine" id="cb12-4" data-line-number="4"></a>
<a class="sourceLine" id="cb12-5" data-line-number="5"><span class="co">// Instead of just having a lens for the name field, have a whole protocol</span></a>
<a class="sourceLine" id="cb12-6" data-line-number="6"><span class="co">// for things with a name field:</span></a>
<a class="sourceLine" id="cb12-7" data-line-number="7"></a>
<a class="sourceLine" id="cb12-8" data-line-number="8">protocol HasName {</a>
<a class="sourceLine" id="cb12-9" data-line-number="9">  associatedtype Name</a>
<a class="sourceLine" id="cb12-10" data-line-number="10">  static <span class="kw">var</span> name: Lens&lt;Self,Name&gt; { get }</a>
<a class="sourceLine" id="cb12-11" data-line-number="11">  <span class="kw">var</span> name: Name { get set }</a>
<a class="sourceLine" id="cb12-12" data-line-number="12">}</a>
<a class="sourceLine" id="cb12-13" data-line-number="13"></a>
<a class="sourceLine" id="cb12-14" data-line-number="14"><span class="co">// Because the mutable property is included in the protocol, you can rely on</span></a>
<a class="sourceLine" id="cb12-15" data-line-number="15"><span class="co">// it in extensions:</span></a>
<a class="sourceLine" id="cb12-16" data-line-number="16"></a>
<a class="sourceLine" id="cb12-17" data-line-number="17">extension HasName {</a>
<a class="sourceLine" id="cb12-18" data-line-number="18">  static <span class="kw">var</span> name: Lens&lt;Self,Name&gt; {</a>
<a class="sourceLine" id="cb12-19" data-line-number="19">    <span class="kw">return</span> <span class="fu">Lens</span>(</a>
<a class="sourceLine" id="cb12-20" data-line-number="20">      get: {$<span class="fl">0.</span>name},</a>
<a class="sourceLine" id="cb12-21" data-line-number="21">      set: { (w,p) in </a>
<a class="sourceLine" id="cb12-22" data-line-number="22">        <span class="kw">var</span> n = w</a>
<a class="sourceLine" id="cb12-23" data-line-number="23">        n.<span class="fu">name</span> = p</a>
<a class="sourceLine" id="cb12-24" data-line-number="24">        <span class="kw">return</span> n</a>
<a class="sourceLine" id="cb12-25" data-line-number="25">      }</a>
<a class="sourceLine" id="cb12-26" data-line-number="26">    )</a>
<a class="sourceLine" id="cb12-27" data-line-number="27">  }</a>
<a class="sourceLine" id="cb12-28" data-line-number="28">  <span class="kw">var</span> name: Name {</a>
<a class="sourceLine" id="cb12-29" data-line-number="29">    get { <span class="kw">return</span> Self.<span class="fu">name</span>.<span class="fu">get</span>(self) }</a>
<a class="sourceLine" id="cb12-30" data-line-number="30">    set { self = Self.<span class="fu">name</span>.<span class="fu">set</span>(self,newValue) }</a>
<a class="sourceLine" id="cb12-31" data-line-number="31">  }</a>
<a class="sourceLine" id="cb12-32" data-line-number="32">}</a>
<a class="sourceLine" id="cb12-33" data-line-number="33"></a>
<a class="sourceLine" id="cb12-34" data-line-number="34"><span class="co">// This way, you can provide either the lens or the property, and you get the</span></a>
<a class="sourceLine" id="cb12-35" data-line-number="35"><span class="co">// other for free.</span></a>
<a class="sourceLine" id="cb12-36" data-line-number="36"></a>
<a class="sourceLine" id="cb12-37" data-line-number="37">extension Place: HasName {}</a>
<a class="sourceLine" id="cb12-38" data-line-number="38"></a>
<a class="sourceLine" id="cb12-39" data-line-number="39"><span class="co">// Then, you can rely on that protocol, and all of the types:</span></a>
<a class="sourceLine" id="cb12-40" data-line-number="40"></a>
<a class="sourceLine" id="cb12-41" data-line-number="41">func checkEqualOnNames</a>
<a class="sourceLine" id="cb12-42" data-line-number="42">  &lt;A,B where A: HasName, B: HasName, A.<span class="fu">Name</span>: Equatable, A.<span class="fu">Name</span> == B.<span class="fu">Name</span>&gt;</a>
<a class="sourceLine" id="cb12-43" data-line-number="43">  (x: A, _ y: B) -&gt; Bool {</a>
<a class="sourceLine" id="cb12-44" data-line-number="44">    <span class="kw">return</span> x.<span class="fu">name</span> == y.<span class="fu">name</span></a>
<a class="sourceLine" id="cb12-45" data-line-number="45">}</a></code></pre></div>
<p>This protocol lets you do a kind of static <code class="sourceCode scala">respondsToSelector</code>, with all of the types intact. Other people have spoken about the other things you can do with lenses in Swift (<a href="https://www.youtube.com/watch?v=ofjehH9f-CU">Brandon Williams - Lenses in Swift</a>), like composing them together, chaining operations, etc. (One other thing they can emulate is <a href="https://gist.github.com/erica/6794d48d917e2084d6ed">method cascading</a>) Unfortunately, in current Swift, the boilerplate makes all of this a little unpleasant. Still, they‚Äôre an interesting idea, and they show how a good type system needn‚Äôt always get in the way.</p>
]]></description>
    <pubDate>Thu, 16 Jun 2016 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2016-06-16-lenses-are-static-selectors.html</guid>
    <dc:creator>Donnacha Ois√≠n Kidney</dc:creator>
</item>
<item>
    <title>Folding Two Things at Once</title>
    <link>https://doisinkidney.com/posts/2016-04-17-folding-two-at-once.html</link>
    <description><![CDATA[<div class="info">
    Posted on April 17, 2016
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Recursion%20Schemes.html">Recursion Schemes</a>
    
</div>

<p>There‚Äôs a whole family of Haskell brainteasers surrounding one function: <code class="sourceCode haskell">foldr</code>. The general idea is to convert some function on lists which uses recursion into one that uses <code class="sourceCode haskell">foldr</code>. <code class="sourceCode haskell">map</code>, for instance:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1">map<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">map f <span class="fu">=</span> foldr (\e a <span class="ot">-&gt;</span> f e <span class="fu">:</span> a) []</a></code></pre></div>
<p>Some can get a little trickier. <code class="sourceCode haskell">dropWhile</code>, for instance. (See <a href="https://wiki.haskell.org/wikiupload/1/14/TMR-Issue6.pdf">here</a> and <a href="http://www.cs.nott.ac.uk/~pszgmh/fold.pdf">here</a> for interesting articles on that one in particular.)</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1">dropWhile<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">dropWhile p <span class="fu">=</span> fst <span class="fu">.</span> foldr f ([],[]) <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  f e <span class="fu">~</span>(xs,ys) <span class="fu">=</span> (<span class="kw">if</span> p e <span class="kw">then</span> xs <span class="kw">else</span> zs, zs) <span class="kw">where</span> zs <span class="fu">=</span> e <span class="fu">:</span> ys</a></code></pre></div>
<h2 id="zip">Zip</h2>
<p>One function which was a little harder to convert than it first seemed was <code class="sourceCode haskell">zip</code>.</p>
<p>Here‚Äôs the first (non) solution:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1">zip<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a,b)]</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">zip <span class="fu">=</span> foldr f (const []) <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">  f x xs (y<span class="fu">:</span>ys) <span class="fu">=</span> (x,y) <span class="fu">:</span> xs ys</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">  f _ _  [] <span class="fu">=</span> []</a></code></pre></div>
<p>The problem with the above isn‚Äôt that it doesn‚Äôt work: it does. The problem is that it‚Äôs not <em>really</em> using <code class="sourceCode haskell">foldr</code>. It‚Äôs only using it on the first list: there‚Äôs still a manual uncons being performed on the second. Ideally, I would want the function to look something like this:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">zip<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a,b)]</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">zip xs ys <span class="fu">=</span> foldr f (\_ _ <span class="ot">-&gt;</span> []) xs (foldr g (const []) ys)</a></code></pre></div>
<p>The best solution I found online only dealt with <code class="sourceCode haskell"><span class="dt">Fold</span></code>s, not <code class="sourceCode haskell"><span class="dt">Foldable</span></code>s. You can read it <a href="http://okmij.org/ftp/Haskell/zip-folds.lhs">here</a>.</p>
<h2 id="recursive-types">Recursive Types</h2>
<p>Reworking the solution online for <code class="sourceCode haskell"><span class="dt">Foldable</span></code>s, the initial intuition is to have the <code class="sourceCode haskell">foldr</code> on the <code class="sourceCode haskell">ys</code> produce a function which takes an element of the <code class="sourceCode haskell">xs</code>, and returns a function which takes an element of the <code class="sourceCode haskell">xs</code>, and so on, finally returning the created list. The <em>problem</em> with that approach is the types involved:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1">zip<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a,b)]</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">zip xs <span class="fu">=</span> foldr f (const []) xs <span class="fu">.</span> foldr g (\_ _ <span class="ot">-&gt;</span> []) <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  g e2 r2 e1 r1 <span class="fu">=</span> (e1,e2) <span class="fu">:</span> (r1 r2)</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">  f e r x <span class="fu">=</span> x e r</a></code></pre></div>
<p>You get the error:</p>
<blockquote>
<p><code class="sourceCode haskell"><span class="dt">Occurs</span> check<span class="fu">:</span> cannot construct the infinite <span class="kw">type</span><span class="fu">:</span> t0 <span class="fu">~</span> a <span class="ot">-&gt;</span> (t0 <span class="ot">-&gt;</span> [(a, b)]) <span class="ot">-&gt;</span> [(a, b)]</code>.</p>
</blockquote>
<p>Haskell‚Äôs typechecker doesn‚Äôt allow for infinitely recursive types.</p>
<p>You‚Äôll be familiar with this problem if you‚Äôve ever tried to encode the Y-combinator, or if you‚Äôve fiddled around with the recursion-schemes package. You might also be familiar with the solution: a <code class="sourceCode haskell"><span class="kw">newtype</span></code>, encapsulating the recursion. In this case, the <code class="sourceCode haskell"><span class="kw">newtype</span></code> looks very similar to the signature for <code class="sourceCode haskell">foldr</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">RecFold</span> a b <span class="fu">=</span> </a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  <span class="dt">RecFold</span> {<span class="ot"> runRecFold ::</span> a <span class="ot">-&gt;</span> (<span class="dt">RecFold</span> a b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b }</a></code></pre></div>
<p>Now you can insert and remove the <code class="sourceCode haskell"><span class="dt">RecFold</span></code> wrapper, helping the typechecker to understand the recursive types as it goes:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1">zip<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a,b)]</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">zip xs <span class="fu">=</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  foldr f (const []) xs <span class="fu">.</span> <span class="dt">RecFold</span> <span class="fu">.</span> foldr g (\_ _ <span class="ot">-&gt;</span> []) <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">    g e2 r2 e1 r1 <span class="fu">=</span> (e1,e2) <span class="fu">:</span> (r1 (<span class="dt">RecFold</span> r2))</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">    f e r x <span class="fu">=</span> runRecFold x e r</a></code></pre></div>
<p>As an aside, the performance characteristics of the <code class="sourceCode haskell"><span class="kw">newtype</span></code> wrapper are totally opaque to me. There may be significant improvements by using <code class="sourceCode haskell">coerce</code> from <a href="https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Coerce.html">Data.Coerce</a>, but I haven‚Äôt looked into it.</p>
<h2 id="generalised-zips">Generalised Zips</h2>
<p>The immediate temptation from the function above is to generalise it. First to <code class="sourceCode haskell">zipWith</code>, obviously:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">zipWith<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [c]</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">zipWith c xs <span class="fu">=</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  foldr f (const []) xs <span class="fu">.</span> <span class="dt">RecFold</span> <span class="fu">.</span> foldr g (\_ _ <span class="ot">-&gt;</span> []) <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">    g e2 r2 e1 r1 <span class="fu">=</span> c e1 e2 <span class="fu">:</span> (r1 (<span class="dt">RecFold</span> r2))</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">    f e r x <span class="fu">=</span> runRecFold x e r</a></code></pre></div>
<p>What‚Äôs maybe a little more interesting, though, would be a <code class="sourceCode haskell">foldr</code> on two lists. Something which folds through both at once, using a supplied combining function:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">foldr2 ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Foldable</span> g)</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">       <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> c)</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">       <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> g b <span class="ot">-&gt;</span> c</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">foldr2 c i xs <span class="fu">=</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  foldr f (const i) xs <span class="fu">.</span> <span class="dt">RecFold</span> <span class="fu">.</span> foldr g (\_ _ <span class="ot">-&gt;</span> i) <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6">    g e2 r2 e1 r1 <span class="fu">=</span> c e1 e2 (r1 (<span class="dt">RecFold</span> r2))</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">    f e r x <span class="fu">=</span> runRecFold x e r</a></code></pre></div>
<p>Of course, once you can do two, you can do three:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">foldr3 ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Foldable</span> g, <span class="dt">Foldable</span> h)</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">       <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> d <span class="ot">-&gt;</span> d)</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">       <span class="ot">-&gt;</span> d <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> g b <span class="ot">-&gt;</span> h c <span class="ot">-&gt;</span> d</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">foldr3 c i xs ys <span class="fu">=</span></a>
<a class="sourceLine" id="cb10-5" data-line-number="5">  foldr f (const i) xs <span class="fu">.</span> <span class="dt">RecFold</span> <span class="fu">.</span> foldr2 g (\_ _ <span class="ot">-&gt;</span> i) ys <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-6" data-line-number="6">    g e2 e3 r2 e1 r1 <span class="fu">=</span> c e1 e2 e3 (r1 (<span class="dt">RecFold</span> r2))</a>
<a class="sourceLine" id="cb10-7" data-line-number="7">    f e r x <span class="fu">=</span> runRecFold x e r</a></code></pre></div>
<p>And so on.</p>
<p>There‚Äôs the added benefit that the above functions work on much more than just lists.</p>
<h2 id="catamorphisms">Catamorphisms</h2>
<p>Getting a little formal about the above functions, a <code class="sourceCode haskell">fold</code> can be described as a catamorphism. This is a name for a pattern of breaking down some recursive structure. There‚Äôs a bunch of them in the <a href="https://hackage.haskell.org/package/recursion-schemes-4.1.2/docs/Data-Functor-Foldable.html">recursion-schemes</a> package. The question is, then: can you express the above as a kind of catamorphism? Initially, using the same techniques as before, you can:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">RecF</span> f a <span class="fu">=</span> <span class="dt">RecF</span> {<span class="ot"> unRecF ::</span> <span class="dt">Base</span> f (<span class="dt">RecF</span> f a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a }</a>
<a class="sourceLine" id="cb11-2" data-line-number="2"></a>
<a class="sourceLine" id="cb11-3" data-line-number="3"><span class="ot">zipo ::</span> (<span class="dt">Functor</span><span class="fu">.</span><span class="dt">Foldable</span> f, <span class="dt">Functor</span><span class="fu">.</span><span class="dt">Foldable</span> g)</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">     <span class="ot">=&gt;</span> (<span class="dt">Base</span> f (<span class="dt">RecF</span> g c) <span class="ot">-&gt;</span> <span class="dt">Base</span> g (<span class="dt">RecF</span> g c <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> c)</a>
<a class="sourceLine" id="cb11-5" data-line-number="5">     <span class="ot">-&gt;</span> f <span class="ot">-&gt;</span> g <span class="ot">-&gt;</span> c</a>
<a class="sourceLine" id="cb11-6" data-line-number="6">zipo alg xs ys <span class="fu">=</span> cata (flip unRecF) ys (cata (<span class="dt">RecF</span> <span class="fu">.</span> alg) xs)</a></code></pre></div>
<p>Then, coming full circle, you get a quite nice encoding of <code class="sourceCode haskell">zip</code>:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1">zip<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a,b)]</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">zip <span class="fu">=</span> zipo alg <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">  alg <span class="dt">Nil</span> _ <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb12-4" data-line-number="4">  alg _ <span class="dt">Nil</span> <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">  alg (<span class="dt">Cons</span> x xs) (<span class="dt">Cons</span> y ys) <span class="fu">=</span> (x, y) <span class="fu">:</span> ys xs</a></code></pre></div>
<p>However, the <code class="sourceCode haskell"><span class="dt">RecF</span></code> is a little ugly. In fact, it‚Äôs possible to write the above without any recursive types, using the RankNTypes extension. (It‚Äôs possible that you could do the same with <code class="sourceCode haskell">foldr2</code> as well, but I haven‚Äôt figured it out yet)</p>
<p>You can actually use a <code class="sourceCode haskell"><span class="kw">newtype</span></code> that‚Äôs provided by the recursion-schemes library as-is. It‚Äôs <code class="sourceCode haskell"><span class="dt">Mu</span></code>. This is required for an encoding of the Y-combinator. It‚Äôs usually presented in this form:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Mu</span> a <span class="fu">=</span> <span class="dt">Roll</span> {<span class="ot"> unroll ::</span> <span class="dt">Mu</span> a <span class="ot">-&gt;</span> a }</a></code></pre></div>
<p>However, in the recursion-schemes package, its definition looks like this:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Mu</span> f <span class="fu">=</span> <span class="dt">Mu</span> (forall a<span class="fu">.</span> (f a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a)</a></code></pre></div>
<p>No recursion! The <code class="sourceCode haskell">zipo</code> combinator above can be written using <code class="sourceCode haskell"><span class="dt">Mu</span></code> like so:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="ot">zipo ::</span> (<span class="dt">Functor</span><span class="fu">.</span><span class="dt">Foldable</span> f, <span class="dt">Functor</span><span class="fu">.</span><span class="dt">Foldable</span> g)</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">     <span class="ot">=&gt;</span> (<span class="dt">Base</span> f (<span class="dt">Mu</span> (<span class="dt">Base</span> g) <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> <span class="dt">Base</span> g (<span class="dt">Mu</span> (<span class="dt">Base</span> g)) <span class="ot">-&gt;</span> c)</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">     <span class="ot">-&gt;</span> f <span class="ot">-&gt;</span> g <span class="ot">-&gt;</span> c</a>
<a class="sourceLine" id="cb15-4" data-line-number="4">zipo alg xs <span class="fu">=</span> cata (\x <span class="ot">-&gt;</span> alg x <span class="fu">.</span> project) xs <span class="fu">.</span> refix</a></code></pre></div>
<p>And the new version of <code class="sourceCode haskell">zip</code> has a slightly more natural order of arguments:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1">zip<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a,b)]</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">zip <span class="fu">=</span> zipo alg <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3">  alg <span class="dt">Nil</span> _ <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">  alg _ <span class="dt">Nil</span> <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb16-5" data-line-number="5">  alg (<span class="dt">Cons</span> x xs) (<span class="dt">Cons</span> y ys) <span class="fu">=</span> (x,y) <span class="fu">:</span> xs ys</a></code></pre></div>
<h2 id="zipping-into">Zipping Into</h2>
<p>There‚Äôs one more issue, though, that‚Äôs slightly tangential. A lot of the time, the attraction of rewriting functions using folds and catamorphisms is that the function becomes more general: it no longer is restricted to lists. For <code class="sourceCode haskell">zip</code>, however, there‚Äôs still a pesky list left in the signature:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1">zip<span class="ot"> ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Foldable</span> g) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> g b <span class="ot">-&gt;</span> [(a,b)]</a></code></pre></div>
<p>It would be a little nicer to be able to zip through something <em>preserving</em> the structure of one of the things being zipped through. For no reason in particular, let‚Äôs assume we‚Äôll preserve the structure of the first argument. The function will have to account for the second argument running out before the first, though. A <code class="sourceCode haskell"><span class="dt">Maybe</span></code> can account for that:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="ot">zipInto ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Foldable</span> g) </a>
<a class="sourceLine" id="cb18-2" data-line-number="2">        <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b <span class="ot">-&gt;</span> c) </a>
<a class="sourceLine" id="cb18-3" data-line-number="3">        <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> g b <span class="ot">-&gt;</span> f c</a></code></pre></div>
<p>If the second argument runs out, <code class="sourceCode haskell"><span class="dt">Nothing</span></code> will be passed to the combining function.</p>
<p>It‚Äôs clear that this isn‚Äôt a <em>fold</em> over the first argument, it‚Äôs a <em>traversal</em>. A first go at the function uses the state monad, but restricts the second argument to a list:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="ot">zipInto ::</span> <span class="dt">Traversable</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> f c</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">zipInto c xs ys <span class="fu">=</span> evalState (traverse f xs) ys <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-3" data-line-number="3">  f x <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb19-4" data-line-number="4">    h <span class="ot">&lt;-</span> gets uncons</a>
<a class="sourceLine" id="cb19-5" data-line-number="5">    <span class="kw">case</span> h <span class="kw">of</span> </a>
<a class="sourceLine" id="cb19-6" data-line-number="6">      <span class="dt">Just</span> (y,t) <span class="ot">-&gt;</span> <span class="kw">do</span> </a>
<a class="sourceLine" id="cb19-7" data-line-number="7">        put t</a>
<a class="sourceLine" id="cb19-8" data-line-number="8">        pure (c x (<span class="dt">Just</span> y))</a>
<a class="sourceLine" id="cb19-9" data-line-number="9">      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> pure (c x <span class="dt">Nothing</span>)</a></code></pre></div>
<p>That code can be cleaned up a little:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="ot">zipInto ::</span> <span class="dt">Traversable</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> f c </a>
<a class="sourceLine" id="cb20-2" data-line-number="2">zipInto c <span class="fu">=</span> evalState <span class="fu">.</span> traverse (state <span class="fu">.</span> f <span class="fu">.</span> c) <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-3" data-line-number="3">  f x [] <span class="fu">=</span> (x <span class="dt">Nothing</span>, [])</a>
<a class="sourceLine" id="cb20-4" data-line-number="4">  f x (y<span class="fu">:</span>ys) <span class="fu">=</span> (x (<span class="dt">Just</span> y), ys)</a></code></pre></div>
<p>But really, the uncons needs to go. Another <code class="sourceCode haskell"><span class="kw">newtype</span></code> wrapper is needed, and here‚Äôs the end result:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">RecAccu</span> a b <span class="fu">=</span></a>
<a class="sourceLine" id="cb21-2" data-line-number="2">  <span class="dt">RecAccu</span> {<span class="ot"> runRecAccu ::</span> a <span class="ot">-&gt;</span> (<span class="dt">RecAccu</span> a b, b) }</a>
<a class="sourceLine" id="cb21-3" data-line-number="3">  </a>
<a class="sourceLine" id="cb21-4" data-line-number="4"><span class="ot">zipInto ::</span> (<span class="dt">Traversable</span> t, <span class="dt">Foldable</span> f)</a>
<a class="sourceLine" id="cb21-5" data-line-number="5">        <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> t c</a>
<a class="sourceLine" id="cb21-6" data-line-number="6">zipInto f xs <span class="fu">=</span></a>
<a class="sourceLine" id="cb21-7" data-line-number="7">  snd <span class="fu">.</span> flip (mapAccumL runRecAccu) xs <span class="fu">.</span> <span class="dt">RecAccu</span> <span class="fu">.</span> foldr h i <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-8" data-line-number="8">    i e <span class="fu">=</span> (<span class="dt">RecAccu</span> i, f e <span class="dt">Nothing</span>)</a>
<a class="sourceLine" id="cb21-9" data-line-number="9">    h e2 a e1 <span class="fu">=</span> (<span class="dt">RecAccu</span> a, f e1 (<span class="dt">Just</span> e2))</a></code></pre></div>
]]></description>
    <pubDate>Sun, 17 Apr 2016 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2016-04-17-folding-two-at-once.html</guid>
    <dc:creator>Donnacha Ois√≠n Kidney</dc:creator>
</item>
<item>
    <title>A Trie in Haskell</title>
    <link>https://doisinkidney.com/posts/2015-10-06-haskell-trie-lhs.html</link>
    <description><![CDATA[<div class="info">
    Posted on October  6, 2015
</div>
<div class="info">
    
        Part 1 of a <a href="/series/tries.html">2-part series on tries</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Data%20Structures.html">Data Structures</a>
    
</div>

<h2 id="basic-ops">Basic Ops</h2>
<p>A Trie is one of those data structures that I find myself writing very early on in almost every language I try to learn. It‚Äôs elegant and interesting, and easy enough to implement.</p>
<p>I usually write a version that is a set-like data structure, rather than a mapping type, for simplicity‚Äôs sake. It stores sequences, in a prefix-tree structure. It has a map (dictionary) where the keys are the first element of every sequence it stores, and the values are the Tries which store the rest of the sequence. It also has a boolean tag, representing whether or not the current Trie is a Trie on which a sequence ends. Here‚Äôs what the type looks like in Haskell:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell literate hidden_source"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">module</span> <span class="dt">Trie</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map.Strict</span> <span class="kw">as</span> <span class="dt">Map</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="kw">import</span> <span class="dt">Data.Map.Strict</span> (<span class="dt">Map</span>)</a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (null)</a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="kw">import</span> <span class="dt">Data.Maybe</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="kw">import</span> <span class="dt">Control.Monad</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"><span class="kw">import</span> <span class="dt">Data.Foldable</span> (fold)</a></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Trie</span> a <span class="fu">=</span> <span class="dt">Trie</span> {<span class="ot"> endHere ::</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">                   ,<span class="ot"> getTrie ::</span> <span class="dt">Map</span> a (<span class="dt">Trie</span> a)</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">                   } <span class="kw">deriving</span> (<span class="dt">Eq</span>)</a></code></pre></div>
<p>Now, inserting into the Trie is easy. You just <code class="sourceCode haskell">uncons</code> on a list, and insert the head into the map, with the value being the tail inserted into whatever existed at that key before:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">empty ::</span> <span class="dt">Trie</span> a</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">empty <span class="fu">=</span> <span class="dt">Trie</span> <span class="dt">False</span> Map.empty</a>
<a class="sourceLine" id="cb3-3" data-line-number="3"></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="ot">insertRec ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Trie</span> a</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">insertRec [] (<span class="dt">Trie</span> _ m)     <span class="fu">=</span> <span class="dt">Trie</span> <span class="dt">True</span> m</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">insertRec (x<span class="fu">:</span>xs) (<span class="dt">Trie</span> e m) <span class="fu">=</span> </a>
<a class="sourceLine" id="cb3-7" data-line-number="7">  <span class="dt">Trie</span> e (Map.alter (<span class="dt">Just</span> <span class="fu">.</span> insertRec xs <span class="fu">.</span> fromMaybe empty) x m)</a></code></pre></div>
<p>Searching is simple, also. For the empty list, you just check if the Trie has its <code class="sourceCode haskell">endHere</code> tag set to <code class="sourceCode haskell"><span class="dt">True</span></code>, otherwise, you uncons, search the map, and query the Trie with the tail if it eas found, or just return <code class="sourceCode haskell"><span class="dt">False</span></code> if it was not:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">memberRec ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">memberRec [] (<span class="dt">Trie</span> e _)     <span class="fu">=</span> e</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">memberRec (x<span class="fu">:</span>xs) (<span class="dt">Trie</span> _ m) <span class="fu">=</span> </a>
<a class="sourceLine" id="cb4-4" data-line-number="4">  fromMaybe <span class="dt">False</span> (memberRec xs <span class="fu">&lt;$&gt;</span> Map.lookup x m)</a></code></pre></div>
<p>Here‚Äôs my problem. <em>Both</em> of those functions have the same pattern:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1">f []     <span class="fu">=</span> <span class="fu">...</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">f (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="fu">...</span></a></code></pre></div>
<p>Any good Haskeller should be <em>begging</em> for a fold at this stage. But it proved a little trickier than I‚Äôd imagined. Take <code class="sourceCode haskell">member</code>, for instance. You want to fold over a list, with the base case being the tag on the Trie:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">member ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">member <span class="fu">=</span> foldr f base <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  base <span class="fu">=</span> <span class="fu">???</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">  f e a <span class="fu">=</span> Map.lookup e <span class="fu">???</span></a></code></pre></div>
<p>Where do you get the base case from, though? You have to specify it from the beginning, but the variable you‚Äôre looking for is nested deeply into the Trie. How can you look into the Trie, without traversing the list, to find the tag, <em>at the beginning of the function?</em></p>
<p>That had been my issue for a while. Every time I cam back to writing a Trie, I would see the pattern, try and write <code class="sourceCode haskell">insert</code> and <code class="sourceCode haskell">member</code> with a fold, and remember again the trouble I had had with it in the past. Recently, though, I saw a different problem, that gave me an idea for a solution.</p>
<h2 id="the-highest-order">The Highest Order</h2>
<blockquote>
<p>Rewrite <code class="sourceCode haskell">dropWhile</code> using <code class="sourceCode haskell">foldr</code></p>
</blockquote>
<p>It‚Äôs a (semi) well-known puzzle, that‚Äôs maybe a little more difficult than it seems at first. Here, for instance, was my first attempt at it:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">dropWhileWrong ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">dropWhileWrong p <span class="fu">=</span> foldr f [] <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  f e a <span class="fu">|</span> p e       <span class="fu">=</span> a</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">        <span class="fu">|</span> otherwise <span class="fu">=</span> e<span class="fu">:</span>a</a></code></pre></div>
<p>Yeah. That‚Äôs <code class="sourceCode haskell">filter</code>, not <code class="sourceCode haskell">dropWhile</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">dropWhileWrong (<span class="fu">&lt;</span><span class="dv">5</span>) [<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">6</span>, <span class="dv">3</span>, <span class="dv">1</span>]</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">[<span class="dv">6</span>]</a></code></pre></div>
<p>Here was my final solution:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">dropWhileCount ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">dropWhileCount p l <span class="fu">=</span> drop (foldr f <span class="dv">0</span> l) l <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  f e a <span class="fu">|</span> p e       <span class="fu">=</span> a <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4">        <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dv">0</span></a></code></pre></div>
<p>After the problem I found <a href="https://wiki.haskell.org/wikiupload/1/14/TMR-Issue6.pdf">this</a> issue of The Monad Reader, which talks about the same problem. In my <code class="sourceCode haskell">drop</code> version, I had been counting the number of items to drop as I went, adding one for every element that passed the test. The corresponding version in the article had been building up <code class="sourceCode haskell">tail</code> functions, using <code class="sourceCode haskell"><span class="fu">.</span></code> to add them together:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">dropWhileTail ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">dropWhileTail p l <span class="fu">=</span> (foldr f id l) l <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  f e a <span class="fu">|</span> p e       <span class="fu">=</span> tail <span class="fu">.</span> a</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">        <span class="fu">|</span> otherwise <span class="fu">=</span> id</a></code></pre></div>
<p>A quick visit to <a href="http://pointfree.io">pointfree.io</a> can generate some monadic pointsfree magic:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">dropWhilePf ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">dropWhilePf p <span class="fu">=</span> join (foldr f id) <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  f e a <span class="fu">|</span> p e       <span class="fu">=</span> tail <span class="fu">.</span> a</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">        <span class="fu">|</span> otherwise <span class="fu">=</span> id</a></code></pre></div>
<p>Now, the final version in the article did <em>not</em> use this technique, as it was very inefficient. It used some cleverness beyond the scope of this post. The second-from-last version I quite liked, though:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="ot">dropWhileFp ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">dropWhileFp p l <span class="fu">=</span> foldr f l l <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">  f e a <span class="fu">|</span> p e       <span class="fu">=</span> tail a</a>
<a class="sourceLine" id="cb12-4" data-line-number="4">        <span class="fu">|</span> otherwise <span class="fu">=</span> l</a></code></pre></div>
<p>However, the idea of building up a function in a fold gave me an idea for adapting it to some of the Trie functions.</p>
<h2 id="folding-inwards">Folding Inwards</h2>
<p>Let‚Äôs start with <code class="sourceCode haskell">member</code>. It needs to fold over a list, and generate a function which acts on a Trie:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="ot">member ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">member <span class="fu">=</span> foldr f base</a></code></pre></div>
<p>The <code class="sourceCode haskell">base</code> is the function being built up: the final part of the function chain. Each part of the function is generated based on each element of the list, and then chained with the base using <code class="sourceCode haskell"><span class="fu">.</span></code>:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1">member <span class="fu">=</span> foldr f base <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2">  f e a <span class="fu">=</span> <span class="fu">???</span> <span class="fu">.</span> a </a></code></pre></div>
<p>The base here is what‚Äôs called when the list is empty. Here‚Äôs what it looked like in the explicit recursion version:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1">member [] (<span class="dt">Trie</span> e _) <span class="fu">=</span> e</a></code></pre></div>
<p>We could simplify this by using record syntax, and <code class="sourceCode haskell">getTrie</code>:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1">member [] t <span class="fu">=</span> getTrie t</a></code></pre></div>
<p>And this has an obvious pointsfree version:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1">member [] <span class="fu">=</span> getTrie</a></code></pre></div>
<p>That fits for the base case. It‚Äôs just a function:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1">member <span class="fu">=</span> foldr f endHere <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2">  f e a <span class="fu">=</span> <span class="fu">???</span> <span class="fu">.</span> a </a></code></pre></div>
<p>Then, how to combine it. That‚Äôs easy enough, actually. It accesses the map, searches it for the key, and calls the accumulating function on it. If it‚Äôs not found in the map, just return <code class="sourceCode haskell"><span class="dt">False</span></code>. Here it is:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="ot">member ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb19-2" data-line-number="2">member <span class="fu">=</span> foldr f endHere <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-3" data-line-number="3">  f e a <span class="fu">=</span> fromMaybe <span class="dt">False</span> <span class="fu">.</span> fmap a <span class="fu">.</span> Map.lookup e <span class="fu">.</span> getTrie</a></code></pre></div>
<p>One of the other standard functions for a Trie is returning the ‚Äúcompletions‚Äù for a given sequence. It‚Äôs a very similar function to <code class="sourceCode haskell">member</code>, actually: instead of calling <code class="sourceCode haskell">endHere</code> on the final Trie found, though, just return the Trie itself. And the thing to return if any given element of the sequence isn‚Äôt found is just an empty Trie:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="ot">complete ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Trie</span> a</a>
<a class="sourceLine" id="cb20-2" data-line-number="2">complete <span class="fu">=</span> foldr f id <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-3" data-line-number="3">  f e a <span class="fu">=</span> fromMaybe empty <span class="fu">.</span> fmap a <span class="fu">.</span> Map.lookup e <span class="fu">.</span> getTrie </a></code></pre></div>
<p>In fact, you could abstract out the commonality here:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="ot">follow ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> c <span class="ot">-&gt;</span> (<span class="dt">Trie</span> a <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> c</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">follow ifMiss onEnd <span class="fu">=</span> foldr f onEnd <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-3" data-line-number="3">  f e a <span class="fu">=</span> fromMaybe ifMiss <span class="fu">.</span> fmap a <span class="fu">.</span> Map.lookup e <span class="fu">.</span> getTrie </a>
<a class="sourceLine" id="cb21-4" data-line-number="4">  </a>
<a class="sourceLine" id="cb21-5" data-line-number="5"><span class="ot">memberAbs ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb21-6" data-line-number="6">memberAbs <span class="fu">=</span> follow <span class="dt">False</span> endHere</a>
<a class="sourceLine" id="cb21-7" data-line-number="7"></a>
<a class="sourceLine" id="cb21-8" data-line-number="8"><span class="ot">completeAbs ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Trie</span> a</a>
<a class="sourceLine" id="cb21-9" data-line-number="9">completeAbs <span class="fu">=</span> follow empty id</a></code></pre></div>
<h2 id="folding-in-and-out">Folding in and out</h2>
<p><code class="sourceCode haskell">insert</code> is another deal entirely. In <code class="sourceCode haskell">member</code>, the fold was tunneling into a Trie, applying the accumulator function to successively deeper Tries, and returning a result based on the final Trie. <code class="sourceCode haskell">insert</code> needs to do the same tunneling - but the Trie returned needs to be the <em>outer</em> Trie.</p>
<p>It turns out it‚Äôs not that difficult. Instead of ‚Äúbuilding up a function‚Äù that is then applied to a Trie, here a function is ‚Äúsent‚Äù into the inner Tries. The cool thing here is that the function being sent hasn‚Äôt been generated yet.</p>
<p>Here‚Äôs some more illustration of what I mean. Start off with the normal <code class="sourceCode haskell">foldr</code>:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="ot">insert ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Trie</span> a</a>
<a class="sourceLine" id="cb22-2" data-line-number="2">insert <span class="fu">=</span> foldr f (\(<span class="dt">Trie</span> _ m) <span class="ot">-&gt;</span> <span class="dt">Trie</span> <span class="dt">True</span> m)</a></code></pre></div>
<p>With the final function to be applied being one that just flips the <code class="sourceCode haskell">endHere</code> tag to <code class="sourceCode haskell"><span class="dt">True</span></code>. Then <code class="sourceCode haskell">f</code>: this is going to act <em>over</em> the map of the Trie that it‚Äôs called on. It‚Äôs useful to define a function just for that:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="ot">overMap ::</span> <span class="dt">Ord</span> b </a>
<a class="sourceLine" id="cb23-2" data-line-number="2">        <span class="ot">=&gt;</span> (<span class="dt">Map.Map</span> a (<span class="dt">Trie</span> a)</a>
<a class="sourceLine" id="cb23-3" data-line-number="3">        <span class="ot">-&gt;</span> <span class="dt">Map.Map</span> b (<span class="dt">Trie</span> b))</a>
<a class="sourceLine" id="cb23-4" data-line-number="4">        <span class="ot">-&gt;</span> <span class="dt">Trie</span> a</a>
<a class="sourceLine" id="cb23-5" data-line-number="5">        <span class="ot">-&gt;</span> <span class="dt">Trie</span> b</a>
<a class="sourceLine" id="cb23-6" data-line-number="6">overMap f (<span class="dt">Trie</span> e m) <span class="fu">=</span> <span class="dt">Trie</span> e (f m)</a></code></pre></div>
<p>Then, it will look up the next element of the sequence in the Trie, and apply the accumulating function to it. (if it‚Äôs not found it will provide an empty Trie instead) Simple!</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell literate hidden_source"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Trie</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-2" data-line-number="2">  mempty <span class="fu">=</span> <span class="dt">Trie</span> <span class="dt">False</span> Map.empty</a>
<a class="sourceLine" id="cb24-3" data-line-number="3">  <span class="dt">Trie</span> v k <span class="ot">`mappend`</span> <span class="dt">Trie</span> t l <span class="fu">=</span></a>
<a class="sourceLine" id="cb24-4" data-line-number="4">    <span class="dt">Trie</span> (v <span class="fu">||</span> t) (Map.unionWith mappend k l)</a></code></pre></div>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="ot">insert ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Trie</span> a</a>
<a class="sourceLine" id="cb25-2" data-line-number="2">insert <span class="fu">=</span> foldr f (\(<span class="dt">Trie</span> _ m) <span class="ot">-&gt;</span> <span class="dt">Trie</span> <span class="dt">True</span> m) <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-3" data-line-number="3">  f e a <span class="fu">=</span> </a>
<a class="sourceLine" id="cb25-4" data-line-number="4">    overMap (Map.alter (<span class="dt">Just</span> <span class="fu">.</span> a <span class="fu">.</span> fold) e)</a></code></pre></div>
<p>I think this is really cool: with just a <code class="sourceCode haskell">foldr</code>, you‚Äôre burrowing into a Trie, changing it, and burrowing back out again.</p>
<h2 id="removal">Removal</h2>
<p>This is always the tricky one with a Trie. You <em>can</em> just follow a given sequence down to its tag, and flip it from on to off. But that doesn‚Äôt remove the sequence itself from the Trie. So maybe you just delete the sequence - but that doesn‚Äôt work either. How do you know that there are no other sequences stored below the one you were examining?</p>
<p>What you need to do is to send a function into the Trie, and have it report back as to whether or not it stores other sequences below it. So this version of <code class="sourceCode haskell">foldr</code> is going to burrow into the Trie, like <code class="sourceCode haskell">member</code>; maintain the outer Trie, like <code class="sourceCode haskell">insert</code>; but <em>also</em> send messages back up to the outer functions. Cool!</p>
<p>The way to do the ‚Äúmessage sending‚Äù is with <code class="sourceCode haskell"><span class="dt">Maybe</span></code>. If the function you send into the Trie to delete the end of the sequence returns <code class="sourceCode haskell"><span class="dt">Nothing</span></code>, then it signifies that you can delete that member. Luckily, the <code class="sourceCode haskell">alter</code> function on <code class="sourceCode haskell"><span class="dt">Data.Map</span></code> works well with this:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="ot">alter ::</span> <span class="dt">Ord</span> k </a>
<a class="sourceLine" id="cb26-2" data-line-number="2">      <span class="ot">=&gt;</span> (<span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a)</a>
<a class="sourceLine" id="cb26-3" data-line-number="3">      <span class="ot">-&gt;</span> k</a>
<a class="sourceLine" id="cb26-4" data-line-number="4">      <span class="ot">-&gt;</span> <span class="dt">Map</span> k a</a>
<a class="sourceLine" id="cb26-5" data-line-number="5">      <span class="ot">-&gt;</span> <span class="dt">Map</span> k a</a></code></pre></div>
<p>Its first argument is a function which is given the result of looking up its <em>second</em> argument. If the function returns <code class="sourceCode haskell"><span class="dt">Nothing</span></code>, that key-value pair in the map is deleted (if it was there). If it returns <code class="sourceCode haskell"><span class="dt">Just</span></code> something, though, that key-value pair is added. In the delete function, we can chain the accumulating function with <code class="sourceCode haskell"><span class="fu">=&lt;&lt;</span></code>. This will skip the rest of the accumulation if any part of the sequence isn‚Äôt found. The actual function we‚Äôre chaining on is <code class="sourceCode haskell">nilIfEmpty</code>, which checks if a given Trie is empty, and returns <code class="sourceCode haskell"><span class="dt">Just</span></code> the Trie if it‚Äôs not, or <code class="sourceCode haskell"><span class="dt">Nothing</span></code> otherwise.</p>
<p>Here‚Äôs the finished version:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="ot">delete ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Trie</span> a</a>
<a class="sourceLine" id="cb27-2" data-line-number="2">delete <span class="fu">=</span> (fromMaybe empty <span class="fu">.</span>) <span class="fu">.</span> foldr f i <span class="kw">where</span></a>
<a class="sourceLine" id="cb27-3" data-line-number="3">  i (<span class="dt">Trie</span> _ m) <span class="fu">|</span> Map.null m  <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb27-4" data-line-number="4">               <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Just</span> (<span class="dt">Trie</span> <span class="dt">False</span> m)</a>
<a class="sourceLine" id="cb27-5" data-line-number="5">  f e a <span class="fu">=</span> nilIfEmpty <span class="fu">.</span> overMap (Map.alter (a <span class="fu">=&lt;&lt;</span>) e) </a>
<a class="sourceLine" id="cb27-6" data-line-number="6">  </a>
<a class="sourceLine" id="cb27-7" data-line-number="7">null<span class="ot"> ::</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb27-8" data-line-number="8">null (<span class="dt">Trie</span> e m) <span class="fu">=</span> (not e) <span class="fu">&amp;&amp;</span> (Map.null m)</a>
<a class="sourceLine" id="cb27-9" data-line-number="9"></a>
<a class="sourceLine" id="cb27-10" data-line-number="10"><span class="ot">nilIfEmpty ::</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Trie</span> a)</a>
<a class="sourceLine" id="cb27-11" data-line-number="11">nilIfEmpty t <span class="fu">|</span> null t    <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb27-12" data-line-number="12">             <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Just</span> t</a></code></pre></div>
<h2 id="folding-the-foldable">Folding the Foldable</h2>
<p>So how about folding the Trie itself? Same trick: build up a function with a fold. This time, a fold over the map, not a list. And the function being built up is a cons operation. When you hit a <code class="sourceCode haskell"><span class="dt">True</span></code> tag, fire off an empty list to the built-up function, allowing it to evaluate:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1"><span class="ot">foldrTrie ::</span> ([a] <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb28-2" data-line-number="2">foldrTrie f i (<span class="dt">Trie</span> a m) <span class="fu">=</span> Map.foldrWithKey ff s m <span class="kw">where</span></a>
<a class="sourceLine" id="cb28-3" data-line-number="3">  s    <span class="fu">=</span> <span class="kw">if</span> a <span class="kw">then</span> f [] i <span class="kw">else</span> i</a>
<a class="sourceLine" id="cb28-4" data-line-number="4">  ff k <span class="fu">=</span> flip (foldrTrie <span class="fu">$</span> f <span class="fu">.</span> (k <span class="fu">:</span>))</a></code></pre></div>
<p>Unfortunately, <a href="http://stackoverflow.com/questions/33469157/foldable-instance-for-a-trie-set">it‚Äôs not easy</a> to make the Trie <em>conform</em> to <code class="sourceCode haskell"><span class="dt">Foldable</span></code>. It is possible, and it‚Äôs what I‚Äôm currently trying to figure out, but it‚Äôs non-trivial.</p>
]]></description>
    <pubDate>Tue, 06 Oct 2015 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2015-10-06-haskell-trie-lhs.html</guid>
    <dc:creator>Donnacha Ois√≠n Kidney</dc:creator>
</item>
<item>
    <title>Faking dependent types in Swift</title>
    <link>https://doisinkidney.com/posts/2015-09-06-dependent-types.html</link>
    <description><![CDATA[<div class="info">
    Posted on September  6, 2015
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Swift.html">Swift</a>, <a href="/tags/Dependent%20Types.html">Dependent Types</a>
    
</div>

<p><a href="https://en.wikipedia.org/wiki/Dependent_type">Dependent types</a> are types ‚Äúthat depend on values‚Äù. Say you had a function <code class="sourceCode scala">f</code> that took an integer. If you can write that function whereby it returns a value of type <code class="sourceCode scala">A</code> when that integer is even, or a type <code class="sourceCode scala">B</code> if the integer is odd, then you‚Äôre working with dependent types. (I think. I‚Äôm not sure: if I‚Äôve got it wrong <a href="https://twitter.com/oisdk">tweet me</a>.)</p>
<h2 id="dependent-pretendance">Dependent Pretendance</h2>
<p>As far as I can tell, this is not possible in Swift. All variables are statically typed, and those types must be found at compile-time. As long as you‚Äôre not messing around with casting:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb1-1" data-line-number="1">struct A {}</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">struct B {}</a>
<a class="sourceLine" id="cb1-3" data-line-number="3"></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">func <span class="fu">f</span>(i: Int) -&gt; AnyObject {</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">  <span class="kw">return</span> i % <span class="dv">2</span> == <span class="dv">0</span> ? <span class="fu">A</span>() as! AnyObject : <span class="fu">B</span>() as! AnyObject</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">}</a></code></pre></div>
<p>You won‚Äôt be able to manage it.</p>
<p>Now, sum types can give you something that <em>looks</em> like dependent types:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb2-1" data-line-number="1">struct A {}</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">struct B {}</a>
<a class="sourceLine" id="cb2-3" data-line-number="3"></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">enum SumType {</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">  <span class="kw">case</span> <span class="fu">Even</span>(A), <span class="fu">Odd</span>(B)</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">}</a>
<a class="sourceLine" id="cb2-7" data-line-number="7"></a>
<a class="sourceLine" id="cb2-8" data-line-number="8">func <span class="fu">f</span>(i: Int) -&gt; SumType {</a>
<a class="sourceLine" id="cb2-9" data-line-number="9">  <span class="kw">return</span> i % <span class="dv">2</span> == <span class="dv">0</span> ? .<span class="fu">Even</span>(<span class="fu">A</span>()) : .<span class="fu">Odd</span>(<span class="fu">B</span>())</a>
<a class="sourceLine" id="cb2-10" data-line-number="10">}</a></code></pre></div>
<p>But that doesn‚Äôt fit the description: the thing returned is of type <code class="sourceCode scala">SumType</code>, <em>not</em> <code class="sourceCode scala">A</code> or <code class="sourceCode scala">B</code>.</p>
<p>That‚Äôs fine, though. As with all of these highfalutin mathematical concepts in programming, you can steal some of the cool and fun <em>patterns</em> from your Haskells and Lisps and Idrises and implement them in whatever language you want.</p>
<p>As it happens, implementing this stuff in Swift gets you even <em>further</em> away from the formal definition of dependent types. Instead of allowing types to be decided at runtime, you end up forcing even <em>more</em> resolution and computation to happen at compile-time. Take ‚Äúnumbers-as-types‚Äù, for instance:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb3-1" data-line-number="1">protocol Nat { <span class="fu">init</span>() }</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">struct Zero : Nat {}</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">protocol NonZero: Nat { typealias Pred: Nat }</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">struct Succ&lt;N : Nat&gt; : NonZero { typealias Pred = N }</a></code></pre></div>
<p>Once you encode some numbers by hand:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb4-1" data-line-number="1">typealias One   = Succ&lt;Zero&gt;</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">typealias Two   = Succ&lt;One&gt;</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">typealias Three = Succ&lt;Two&gt;</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">typealias Four  = Succ&lt;Three&gt;</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">typealias Five  = Succ&lt;Four&gt;</a>
<a class="sourceLine" id="cb4-6" data-line-number="6">typealias Six   = Succ&lt;Five&gt;</a>
<a class="sourceLine" id="cb4-7" data-line-number="7">typealias Seven = Succ&lt;Six&gt;</a>
<a class="sourceLine" id="cb4-8" data-line-number="8">typealias Eight = Succ&lt;Seven&gt;</a>
<a class="sourceLine" id="cb4-9" data-line-number="9">typealias Nine  = Succ&lt;Eight&gt;</a></code></pre></div>
<p>You get thinking about exactly <em>how much</em> computation you can achieve at compile time:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb5-1" data-line-number="1">Sum&lt;One, Two&gt;.<span class="fu">Result</span>    <span class="co">// Three</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">Comp&lt;Five, Nine&gt;.<span class="fu">Result</span> <span class="co">// LT</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">Comp&lt;Four, Four&gt;.<span class="fu">Result</span> <span class="co">// EQ</span></a></code></pre></div>
<h2 id="sum-types-divide-types-multiply-types">Sum types, divide types, multiply types</h2>
<p>What I wanted, ideally, was some basic ‚ÄúAlgebraic data types‚Äù. (Today. Today was the day I made the worst pun.) I wanted to be able to add the type <code class="sourceCode scala">One</code> to the type <code class="sourceCode scala">Two</code> and get the type <code class="sourceCode scala">Three</code>. Once you can manage those, multiplication, division and all kinds of silliness are possible. I set myself some rules: all calculations must be performed at compile-time, and all calculations must work with arbitrary values.</p>
<p>I‚Äôve not been able to manage, unfortunately. If someone could figure out how to do it, I would <a href="https://twitter.com/oisdk">love to hear it</a>. I‚Äôve been stealing ideas from <a href="http://strictlypositive.org/faking.ps.gz">Faking It: Simulating Dependent Types in Haskell</a> mainly.</p>
<p>Here‚Äôs the kind of code that made me think it was possible:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb6-1" data-line-number="1">let ar = [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>].<span class="fu">reverse</span>()</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">let se = <span class="fu">AnySequence</span>([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>]).<span class="fu">reverse</span>()</a></code></pre></div>
<p>The types returned by those two methods are different. This is all to do with that protocol-oriented-programming business: the compiler will try to select the most specialised version of a method to use. So in the example above, since an array can just be indexed backwards, the compiler uses a method that returns a lazy <code class="sourceCode scala">ReverseRandomAccessCollection</code>. However, for the <code class="sourceCode scala">AnySequence</code>, the <code class="sourceCode scala">reverse</code> method has to create a whole new array.</p>
<p>With that in mind, we can make a protocol:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb7-1" data-line-number="1">protocol BinaryOp {</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  typealias A: Nat</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  typealias B: Nat</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">}</a></code></pre></div>
<p>Then, we can extend it, like this:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb8-1" data-line-number="1">struct EQ {}</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">extension BinaryOp where A == B {</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  typealias Result = EQ</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">}</a></code></pre></div>
<p>So far, so good! The compiler will add that method to all types that conform to the <code class="sourceCode scala">where</code> clause. So if there is a concrete type that conforms to <code>BinaryOp</code>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb9-1" data-line-number="1">struct Comp&lt;E0: Nat, E1: Nat&gt; : BinaryOp {</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">  typealias A = E0</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  typealias B = E1</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">}</a></code></pre></div>
<p>Only instances where <code class="sourceCode scala">A</code> and <code class="sourceCode scala">B</code> are equal will get the type alias:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb10-1" data-line-number="1">Comp&lt;One, One&gt;.<span class="fu">Result</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">Comp&lt;One, Two&gt;.<span class="fu">Result</span> <span class="co">// Error</span></a></code></pre></div>
<p>But that‚Äôs not ideal. We want something that returns <code class="sourceCode scala">NEQ</code> when the types are not the same. Easy enough, right?</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb11-1" data-line-number="1">struct NEQ {}</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">extension BinaryOp {</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  typealias Result = NEQ</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">}</a></code></pre></div>
<p>But there‚Äôs an error: <code class="sourceCode scala">invalid redeclaration of &#39;Result&#39;</code>. The compiler won‚Äôt allow polymorphism with typealiases. It <em>does</em> allow polymorphism with properties, though:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb12-1" data-line-number="1">extension BinaryOp {</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">  <span class="kw">var</span> r: EQ { <span class="kw">return</span> <span class="fu">EQ</span>() }</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">}</a>
<a class="sourceLine" id="cb12-4" data-line-number="4">extension BinaryOp where A == B {</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">  <span class="kw">var</span> r: NEQ { <span class="kw">return</span> <span class="fu">NEQ</span>() }</a>
<a class="sourceLine" id="cb12-6" data-line-number="6">}</a></code></pre></div>
<p>This is already a less elegant solution than the typealiases, since we‚Äôre going to have to initialise things. All of the type information is available at compile-time, though, so I‚Äôve not broken any of my rules.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb13-1" data-line-number="1">Comp&lt;One, One&gt;().<span class="fu">r</span> <span class="co">// EQ</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">Comp&lt;One, Two&gt;().<span class="fu">r</span> <span class="co">// NEQ</span></a></code></pre></div>
<p>How about something more complex? Instead of <code class="sourceCode scala">EQ</code> and <code class="sourceCode scala">NEQ</code>, maybe <code class="sourceCode scala">LT</code>, <code class="sourceCode scala">GT</code>, and <code>EQ</code>?</p>
<p>It‚Äôs hard to see how it would work. Well, here‚Äôs the base case:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb14-1" data-line-number="1">extension BinaryOp where A == B {</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">  <span class="kw">var</span> r: EQ { <span class="kw">return</span> <span class="fu">EQ</span>() }</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">}</a></code></pre></div>
<p>Then, any non-zero is bigger than zero:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb15-1" data-line-number="1">struct LT {}</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">extension BinaryOp where A == Zero, B : NonZero {</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">  <span class="kw">var</span> r: LT { <span class="kw">return</span> <span class="fu">LT</span>() }</a>
<a class="sourceLine" id="cb15-4" data-line-number="4">}</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">struct GT {}</a>
<a class="sourceLine" id="cb15-6" data-line-number="6">extension BinaryOp where A : NonZero, B == Zero {</a>
<a class="sourceLine" id="cb15-7" data-line-number="7">  <span class="kw">var</span> r: GT { <span class="kw">return</span> <span class="fu">GT</span>() }</a>
<a class="sourceLine" id="cb15-8" data-line-number="8">}</a></code></pre></div>
<p>If both <code class="sourceCode scala">A</code> and <code class="sourceCode scala">B</code> are nonzero, they should have a <code class="sourceCode scala">Pred</code> typealias, which we can use, recursively:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb16-1" data-line-number="1">extension BinaryOp where A : NonZero, B : NonZero {</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">  <span class="kw">var</span> r: ?? {</a>
<a class="sourceLine" id="cb16-3" data-line-number="3">    <span class="kw">return</span> Comp&lt;A.<span class="fu">Pred</span>, B.<span class="fu">Pred</span>&gt;().<span class="fu">r</span></a>
<a class="sourceLine" id="cb16-4" data-line-number="4">  }</a>
<a class="sourceLine" id="cb16-5" data-line-number="5">}</a></code></pre></div>
<p>This doesn‚Äôt work. I‚Äôm fairly sure this is a definitive dead end. Here‚Äôs the error: <code class="sourceCode scala">ambiguous reference to member <span class="ch">&#39;r&#39;</span></code>. The problem is that that error encapsulates exactly what I‚Äôm trying to achieve: I <em>want</em> the reference to be ambiguous, so it <em>depends</em> on the types of <code class="sourceCode scala">A</code> and <code class="sourceCode scala">B</code>. Most other routes I went down hit similar roadblocks:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb17-1" data-line-number="1">protocol BinaryOp {</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">  typealias A: Nat</a>
<a class="sourceLine" id="cb17-3" data-line-number="3">  typealias B: Nat</a>
<a class="sourceLine" id="cb17-4" data-line-number="4">  typealias Result</a>
<a class="sourceLine" id="cb17-5" data-line-number="5">  <span class="kw">var</span> r: Result { get }</a>
<a class="sourceLine" id="cb17-6" data-line-number="6">}</a></code></pre></div>
<p>The idea here was that you could have various implementations of <code class="sourceCode scala">r</code>, so that the <code class="sourceCode scala">Result</code> typealias would be inferred. The problem is the compiler wants to figure out what <code class="sourceCode scala">Result</code> is when you make a type that conforms to the protocol, so every type will get the default implementation.</p>
<p>Yet more versions I tried all hit the <code class="sourceCode scala">ambiguous</code> error, which makes me think this kind of thing is fundamentally impossible in Swift‚Äôs current form.</p>
<p>So I‚Äôve got to break one of the rules: no more arbitrary numbers.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb18-1" data-line-number="1">struct AddOne&lt;N : Nat&gt; {</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">  typealias Result = Succ&lt;N&gt;</a>
<a class="sourceLine" id="cb18-3" data-line-number="3">}</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">struct AddTwo&lt;N : Nat&gt; {</a>
<a class="sourceLine" id="cb18-5" data-line-number="5">  typealias Result = Succ&lt;AddOne&lt;N&gt;.<span class="fu">Result</span>&gt;</a>
<a class="sourceLine" id="cb18-6" data-line-number="6">}</a></code></pre></div>
<p>And so on. Or:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb19-1" data-line-number="1">extension Binary where A == B {</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">  <span class="kw">var</span> sub: Zero { <span class="kw">return</span> <span class="fu">Zero</span>() }</a>
<a class="sourceLine" id="cb19-3" data-line-number="3">  <span class="kw">var</span> com: EQ { <span class="kw">return</span> <span class="fu">EQ</span>() }</a>
<a class="sourceLine" id="cb19-4" data-line-number="4">}</a>
<a class="sourceLine" id="cb19-5" data-line-number="5">extension Binary where A == Succ&lt;B&gt; {</a>
<a class="sourceLine" id="cb19-6" data-line-number="6">  <span class="kw">var</span> sub: One { <span class="kw">return</span> <span class="fu">One</span>() }</a>
<a class="sourceLine" id="cb19-7" data-line-number="7">  <span class="kw">var</span> com: GT { <span class="kw">return</span> <span class="fu">GT</span>() }</a>
<a class="sourceLine" id="cb19-8" data-line-number="8">}</a></code></pre></div>
<p>Which can give you subtraction.</p>
<h2 id="lets-pretend-to-be-useful">Let‚Äôs Pretend to be Useful</h2>
<p>All of that stuff is interesting, but very <em>very</em> far from being useful.</p>
<p>The <a href="https://bigonotetaking.wordpress.com/2015/09/04/in-which-i-misunderstand-dependent-types/">length-indexed list from the other day</a> probably is useful, though. As well as being kind of cool and safe, there are some (minor) optimisations it can do.</p>
<p>The other dependent type staple is the heterogenous list.</p>
<p>Now, this isn‚Äôt just any heterogenous list: we‚Äôre not writing Python here. This is a <em>statically typed</em> heterogenous list. Swift has a construct very similar to this already: a tuple!</p>
<p>But tuples aren‚Äôt very extensible:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb20-1" data-line-number="1">extension Tuple where First : Comparable {...</a>
<a class="sourceLine" id="cb20-2" data-line-number="2">extension Tuple where Count == Two {...</a></code></pre></div>
<p>And you can‚Äôt work with them in terms that most lists can:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb21-1" data-line-number="1">(<span class="dv">1</span>, <span class="st">&quot;a&quot;</span>, <span class="fl">2.0</span>) + (<span class="st">&quot;b&quot;</span>, <span class="dv">-3</span>)</a></code></pre></div>
<p>So that‚Äôs where another tuple type can come in. A la <a href="https://twitter.com/rob_rix/status/633262294336729088">Rob Rix</a>, we could make a right-recursive tuple, terminated by <code class="sourceCode scala">()</code>. There‚Äôll be one overarching protocol:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb22-1" data-line-number="1">protocol _AnyTuple : CustomStringConvertible {</a>
<a class="sourceLine" id="cb22-2" data-line-number="2">  <span class="kw">var</span> tDesc: String { get }</a>
<a class="sourceLine" id="cb22-3" data-line-number="3">  <span class="kw">var</span> count: Int { get }</a>
<a class="sourceLine" id="cb22-4" data-line-number="4">  typealias Arity : Nat</a>
<a class="sourceLine" id="cb22-5" data-line-number="5">}</a></code></pre></div>
<p>And the empty tuple:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb23-1" data-line-number="1">struct EmptyTuple {}</a>
<a class="sourceLine" id="cb23-2" data-line-number="2"></a>
<a class="sourceLine" id="cb23-3" data-line-number="3">extension EmptyTuple : _AnyTuple {</a>
<a class="sourceLine" id="cb23-4" data-line-number="4">  <span class="kw">var</span> description: String { <span class="kw">return</span> <span class="st">&quot;()&quot;</span> }</a>
<a class="sourceLine" id="cb23-5" data-line-number="5">  <span class="kw">var</span> tDesc: String { <span class="kw">return</span>  <span class="st">&quot;)&quot;</span> }</a>
<a class="sourceLine" id="cb23-6" data-line-number="6">  <span class="kw">var</span> count: Int { <span class="kw">return</span> <span class="dv">0</span> }</a>
<a class="sourceLine" id="cb23-7" data-line-number="7">  typealias Arity = Zero</a>
<a class="sourceLine" id="cb23-8" data-line-number="8">}</a></code></pre></div>
<p>The descriptions are just there to give us a pretty printout. Here‚Äôs the tuple struct:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb24-1" data-line-number="1">struct NonEmptyTuple&lt;Element, Tail : _AnyTuple&gt; { <span class="kw">var</span> (head, tail): (Element, Tail) }</a>
<a class="sourceLine" id="cb24-2" data-line-number="2"></a>
<a class="sourceLine" id="cb24-3" data-line-number="3">extension NonEmptyTuple : _AnyTuple {</a>
<a class="sourceLine" id="cb24-4" data-line-number="4">  <span class="kw">var</span> count: Int { <span class="kw">return</span> tail.<span class="fu">count</span> + <span class="dv">1</span> }</a>
<a class="sourceLine" id="cb24-5" data-line-number="5">  <span class="kw">var</span> description: String {</a>
<a class="sourceLine" id="cb24-6" data-line-number="6">    <span class="kw">return</span> <span class="st">&quot;(&quot;</span> + String(reflecting: head) + tail.<span class="fu">tDesc</span></a>
<a class="sourceLine" id="cb24-7" data-line-number="7">  }</a>
<a class="sourceLine" id="cb24-8" data-line-number="8">  <span class="kw">var</span> tDesc: String {</a>
<a class="sourceLine" id="cb24-9" data-line-number="9">    <span class="kw">return</span> <span class="st">&quot;, &quot;</span> + String(reflecting: head) + tail.<span class="fu">tDesc</span></a>
<a class="sourceLine" id="cb24-10" data-line-number="10">  }</a>
<a class="sourceLine" id="cb24-11" data-line-number="11">  typealias Arity = Succ&lt;Tail.<span class="fu">Arity</span>&gt;</a>
<a class="sourceLine" id="cb24-12" data-line-number="12">}</a></code></pre></div>
<p>Now, to build a tuple. Since it‚Äôs right-recursive, it might look like this:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="dv">1</span> , <span class="st">&quot;a&quot;</span> , <span class="fl">4.0</span> , ()</a></code></pre></div>
<p>But there are two problems with that: first, the comma is not overloadable. That‚Äôs probably a good thing. Second, it doesn‚Äôt really look like a tuple.</p>
<p><a href="https://twitter.com/jckarter/status/639953308401057793">Joe Groff</a> solved the first problem (albeit by committing a mortal sin). Just use a unicode comma! The only one I could find that works has the delightful name of Hypodiastole.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb26-1" data-line-number="1">infix operator ‚∏í { associativity right precedence <span class="dv">90</span> }</a></code></pre></div>
<p>Trying to find it in the character viewer each time was a pain, though. So I went with the boring vertical bar.</p>
<p>The second problem can be solved with some sneaky overloading. Here‚Äôs what these functions look like:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb27-1" data-line-number="1">infix operator | { associativity right precedence <span class="dv">90</span> }</a>
<a class="sourceLine" id="cb27-2" data-line-number="2"></a>
<a class="sourceLine" id="cb27-3" data-line-number="3">func |&lt;E, T:_AnyTuple&gt;(lhs: E, rhs: T) -&gt; NonEmptyTuple&lt;E, T&gt; {</a>
<a class="sourceLine" id="cb27-4" data-line-number="4">  <span class="kw">return</span> <span class="fu">NonEmptyTuple</span>(head: lhs, tail: rhs)</a>
<a class="sourceLine" id="cb27-5" data-line-number="5">}</a>
<a class="sourceLine" id="cb27-6" data-line-number="6"></a>
<a class="sourceLine" id="cb27-7" data-line-number="7">func |&lt;E, T&gt;(lhs: E, rhs: T) -&gt; NonEmptyTuple&lt;E, NonEmptyTuple&lt;T, EmptyTuple&gt;&gt; {</a>
<a class="sourceLine" id="cb27-8" data-line-number="8">  <span class="kw">return</span> <span class="fu">NonEmptyTuple</span>(head: lhs, tail: <span class="fu">NonEmptyTuple</span>(head: rhs, tail: <span class="fu">EmptyTuple</span>()))</a>
<a class="sourceLine" id="cb27-9" data-line-number="9">}</a></code></pre></div>
<p>We can now, finally, build a Tuple:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb28-1" data-line-number="1">(<span class="dv">1</span> | <span class="fl">2.0</span> | <span class="st">&quot;a&quot;</span> ) <span class="co">// (1, 2.0, &quot;a&quot;)</span></a></code></pre></div>
<p>One little wrinkle with protocols, though. If you try this:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb29-1" data-line-number="1">extension NonEmptyTuple where Arity == Two {...</a></code></pre></div>
<p>There‚Äôs an error: <code class="sourceCode scala">neither <span class="kw">type</span> in same-<span class="kw">type</span> refers to a generic parameter or associated <span class="kw">type</span></code>. Generally speaking, <code class="sourceCode scala">==</code> requirements in struct extensions don‚Äôt work. However, they do work on protocols. So a wrapper protocol is needed:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb30-1" data-line-number="1">protocol Tuple : _AnyTuple {</a>
<a class="sourceLine" id="cb30-2" data-line-number="2">  typealias Head</a>
<a class="sourceLine" id="cb30-3" data-line-number="3">  typealias Tail : _AnyTuple</a>
<a class="sourceLine" id="cb30-4" data-line-number="4">  typealias Arity : NonZero</a>
<a class="sourceLine" id="cb30-5" data-line-number="5">  <span class="kw">var</span> head : Head { get }</a>
<a class="sourceLine" id="cb30-6" data-line-number="6">  <span class="kw">var</span> tail : Tail { get }</a>
<a class="sourceLine" id="cb30-7" data-line-number="7">}</a>
<a class="sourceLine" id="cb30-8" data-line-number="8"></a>
<a class="sourceLine" id="cb30-9" data-line-number="9">extension NonEmptyTuple : Tuple {}</a></code></pre></div>
<p>Alright. Time to work with it.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb31-1" data-line-number="1">extension Tuple where</a>
<a class="sourceLine" id="cb31-2" data-line-number="2">  Head : IntegerArithmeticType,</a>
<a class="sourceLine" id="cb31-3" data-line-number="3">  Tail : Tuple,</a>
<a class="sourceLine" id="cb31-4" data-line-number="4">  Tail.<span class="fu">Head</span> : IntegerArithmeticType,</a>
<a class="sourceLine" id="cb31-5" data-line-number="5">  Arity == Two {</a>
<a class="sourceLine" id="cb31-6" data-line-number="6">  func <span class="fu">matSum</span>(<span class="kw">with</span>: Self) -&gt; NonEmptyTuple&lt;Head, NonEmptyTuple&lt;Tail.<span class="fu">Head</span>, EmptyTuple&gt;&gt; {</a>
<a class="sourceLine" id="cb31-7" data-line-number="7">    let a = head + <span class="kw">with</span>.<span class="fu">head</span></a>
<a class="sourceLine" id="cb31-8" data-line-number="8">    let b = tail.<span class="fu">head</span> + <span class="kw">with</span>.<span class="fu">tail</span>.<span class="fu">head</span></a>
<a class="sourceLine" id="cb31-9" data-line-number="9">    <span class="kw">return</span> (a | b)</a>
<a class="sourceLine" id="cb31-10" data-line-number="10">  }</a>
<a class="sourceLine" id="cb31-11" data-line-number="11">}</a>
<a class="sourceLine" id="cb31-12" data-line-number="12"></a>
<a class="sourceLine" id="cb31-13" data-line-number="13">(<span class="dv">1</span> | <span class="dv">4</span>).<span class="fu">matSum</span>(<span class="dv">3</span> | <span class="dv">2</span>) <span class="co">// (4, 6)</span></a></code></pre></div>
<p>The basic advantage of this heterogenous list in Swift is its extensibility: you can treat tuples of length 2 as a type, or tuples where the third element is comparable as a type, and so on.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb32-1" data-line-number="1">extension Tuple where Tail : Tuple, Tail.<span class="fu">Head</span> : Comparable {</a>
<a class="sourceLine" id="cb32-2" data-line-number="2">  func isSecondLessThan</a>
<a class="sourceLine" id="cb32-3" data-line-number="3">    &lt;T : Tuple where T.<span class="fu">Tail</span> : Tuple, T.<span class="fu">Tail</span>.<span class="fu">Head</span> == Tail.<span class="fu">Head</span>&gt;</a>
<a class="sourceLine" id="cb32-4" data-line-number="4">    (<span class="kw">with</span>: T) -&gt; Bool {</a>
<a class="sourceLine" id="cb32-5" data-line-number="5">    <span class="kw">return</span> tail.<span class="fu">head</span> &lt; <span class="kw">with</span>.<span class="fu">tail</span>.<span class="fu">head</span></a>
<a class="sourceLine" id="cb32-6" data-line-number="6">  }</a>
<a class="sourceLine" id="cb32-7" data-line-number="7">}</a>
<a class="sourceLine" id="cb32-8" data-line-number="8"></a>
<a class="sourceLine" id="cb32-9" data-line-number="9">let a = (<span class="dv">1</span> | <span class="fl">3.0</span> | <span class="st">&quot;a&quot;</span> | <span class="dv">43</span>)</a>
<a class="sourceLine" id="cb32-10" data-line-number="10">let b = (<span class="st">&quot;c&quot;</span> | <span class="fl">4.0</span> | <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb32-11" data-line-number="11"></a>
<a class="sourceLine" id="cb32-12" data-line-number="12">a.<span class="fu">isSecondLessThan</span>(b)</a></code></pre></div>
<p>Most of this stuff is madness. The custom infix unicode operator should have tipped you off to that: but it‚Äôs not to say that <em>nothing</em> here is useful. Compile-time warnings are great. I think the fixed-length array works. But this tuple stuff is too hacky: it only becomes useful if there are some low-level changes to the language.</p>
<p>What‚Äôs really useful, though, is <em>thinking</em> about types with dependency in mind. Getting familiar with what is and isn‚Äôt possible to write between the <code class="sourceCode scala">where</code> and the <code class="sourceCode scala">{</code> in an extension gives you a good idea of how powerful protocols and their specialisations are.</p>
<p>For some extra reading, check out <a href="https://ghc.haskell.org/trac/ghc/wiki/DependentHaskell">DependentHaskell</a>, <a href="https://wiki.haskell.org/Heterogenous_collections">Heterogenous Collections in Haskell</a>, and <a href="http://programmers.stackexchange.com/questions/132835/is-there-a-specific-purpose-for-heterogeneous-lists">Strongly Typed Heterogenous Collections</a>. I‚Äôm muddling my way through seeing what‚Äôs possible with length-indexed lists, heterogenous lists, and numeral types <a href="https://github.com/oisdk/PretendDependSwift">over here</a>, if you‚Äôre interested.</p>
]]></description>
    <pubDate>Sun, 06 Sep 2015 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2015-09-06-dependent-types.html</guid>
    <dc:creator>Donnacha Ois√≠n Kidney</dc:creator>
</item>
<item>
    <title>Using Protocols to Build a (very) Generic Deque</title>
    <link>https://doisinkidney.com/posts/2015-08-24-generic-deque.html</link>
    <description><![CDATA[<div class="info">
    Posted on August 24, 2015
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Swift.html">Swift</a>, <a href="/tags/Data%20Structures.html">Data Structures</a>
    
</div>

<p>(Download the playground to use the code and see the outputs)</p>
<p>This post is an update on a <a href="https://bigonotetaking.wordpress.com/2015/08/09/yet-another-root-of-all-evil/">previous implementation of a Deque</a>. A full implementation of this Deque is available <a href="https://github.com/oisdk/SwiftDataStructures/blob/master/SwiftDataStructures/Deque.swift">here</a>.</p>
<p>A Deque is a data structure comprised of two stacks, facing opposite directions. In this way, operations at either end of the Deque have the same complexity as operations on one end of the underlying stack. This implementation uses two arrays, with the front reversed: appending, prepending, and removal of the first and last elements are all (amortized) O(1).</p>
<p>The standard library has three <code class="sourceCode scala">Array</code> structs: <code class="sourceCode scala">Array</code>, <code class="sourceCode scala">ArraySlice</code>, and <code class="sourceCode scala">ContiguousArray</code>. They all have the same interface, with different underlying implementations. An <code class="sourceCode scala">Array</code> is a standard vector-like structure, which allows O(1) amortized appending, fast iteration, etc. A <code class="sourceCode scala">ContiguousArray</code> has stricter rules about contiguity, but it‚Äôs not bridged to Objective-C.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb1-1" data-line-number="1">let array  = [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>]</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">let cArray: ContiguousArray = [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>]</a></code></pre></div>
<p>An <code class="sourceCode scala">ArraySlice</code> is a reference into an <code class="sourceCode scala">Array</code> or <code class="sourceCode scala">ContiguousArray</code>, for more efficient slicing. All the information an <code class="sourceCode scala">ArraySlice</code> contains is the beginning and end points of the slice (as well as any changes made to the slice separate from the array)</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb2-1" data-line-number="1">let slice = array[<span class="dv">0</span>..&lt;<span class="dv">6</span>]</a></code></pre></div>
<p>To replicate these semantics in a Deque requires three separate structs: one with an <code class="sourceCode scala">Array</code> as the stack, another with an <code class="sourceCode scala">ArraySlice</code> as the stack, and a third with a <code class="sourceCode scala">ContiguousArray</code>. The standard library seems to duplicate the structs, along with their methods and properties.</p>
<p>It would be much nicer to just define a protocol that represented the <em>difference</em> between the deque types: then you could just write the methods and properties once, on top of it. Something like this:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb3-1" data-line-number="1">protocol DequeType {</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  typealias Container : RangeReplaceableCollectionType, MutableSliceable</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">  <span class="kw">var</span> front: Container { get set }</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">  <span class="kw">var</span> back : Container { get set }</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">  <span class="fu">init</span>()</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">}</a></code></pre></div>
<p>There‚Äôs one problem with this: both stacks need to be made public. It would be much nicer to hide the stacks (especially since an invariant needs to be checked and maintained on every mutation). If anyone has an idea of how to accomplish that, <a href="https://twitter.com/oisdk">tweet me</a>.</p>
<p>The first method to implement is a subscript. Indexing is difficult, because the front stack will be reversed, so the index used to get in to the Deque will need to be translated into an equivalent index in the array.</p>
<p>Any (valid) index will point into either the front or back queue, and the transformations applied to it in each case is different. If it‚Äôs in the front, the end result will look like <code class="sourceCode scala">front[front.<span class="fu">endIndex</span> - <span class="dv">1</span> - i]</code>, whereas if it‚Äôs in the back, it should be <code class="sourceCode scala">back[i - front.<span class="fu">endIndex</span>]</code>. There‚Äôs nothing specified about the Containers except that they‚Äôre <code class="sourceCode scala">RangeReplaceableCollectionType</code> and <code class="sourceCode scala">MutableSliceable</code>, so the index types will have to be as generic as possible. (you could specify <code class="sourceCode scala">where Index == Int</code>, but that‚Äôs more specific than needed, and not very extensible.)</p>
<p>Both of those transformations are subtractions, an operation that‚Äôs possible on <code>RandomAccessIndexType</code>s with the <code class="sourceCode scala">advancedBy</code> method. <code class="sourceCode scala">advancedBy</code> takes the associated <code class="sourceCode scala">Distance</code> type of the <code class="sourceCode scala">RandomAccessIndexType</code>. That‚Äôs enough information to figure out that the Deque‚Äôs index type must be the same as the Distance of the Index of the Container.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb4-1" data-line-number="1">extension DequeType {</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  typealias Index = Container.<span class="fu">Index</span>.<span class="fu">Distance</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">}</a></code></pre></div>
<p>The method that will translate an index into the relevant index in the stacks will return an enum:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb5-1" data-line-number="1">public enum IndexLocation&lt;I&gt; {</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">  <span class="kw">case</span> <span class="fu">Front</span>(I), <span class="fu">Back</span>(I)</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">}</a></code></pre></div>
<p>Then, the translate method itself:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb6-1" data-line-number="1">extension DequeType where</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  Container.<span class="fu">Index</span> : RandomAccessIndexType,</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  Container.<span class="fu">Index</span>.<span class="fu">Distance</span> : ForwardIndexType {</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">  </a>
<a class="sourceLine" id="cb6-5" data-line-number="5">  <span class="kw">private</span> func <span class="fu">translate</span>(i: Container.<span class="fu">Index</span>.<span class="fu">Distance</span>)</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">    -&gt; IndexLocation&lt;Container.<span class="fu">Index</span>&gt; {</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">    <span class="kw">return</span> i &lt; front.<span class="fu">count</span> ?</a>
<a class="sourceLine" id="cb6-8" data-line-number="8">      .<span class="fu">Front</span>(front.<span class="fu">endIndex</span>.<span class="fu">predecessor</span>().<span class="fu">advancedBy</span>(-i)) :</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">      .<span class="fu">Back</span>(back.<span class="fu">startIndex</span>.<span class="fu">advancedBy</span>(i - front.<span class="fu">count</span>))</a>
<a class="sourceLine" id="cb6-10" data-line-number="10">  }</a>
<a class="sourceLine" id="cb6-11" data-line-number="11">}</a></code></pre></div>
<p>This performs two steps: 1. Check which stack it‚Äôs in. 2. Subtract in the appropriate order</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb7-1" data-line-number="1">let d: Deque = [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>] <span class="co">// [1, 2, 3 | 4, 5, 6]</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">d.<span class="fu">translate</span>(<span class="dv">0</span>) <span class="co">// Front: 2</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">d.<span class="fu">translate</span>(<span class="dv">4</span>) <span class="co">// Back: 1</span></a></code></pre></div>
<p>This means that the logic for converting distance to index is separated from the logic for actual indexing. Great! Here‚Äôs the indexing:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb8-1" data-line-number="1">extension DequeType where</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  Container.<span class="fu">Index</span> : RandomAccessIndexType,</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  Container.<span class="fu">Index</span>.<span class="fu">Distance</span> : ForwardIndexType {</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">  <span class="kw">var</span> startIndex: Container.<span class="fu">Index</span>.<span class="fu">Distance</span> { <span class="kw">return</span> <span class="dv">0</span> }</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">  <span class="kw">var</span> endIndex  : Container.<span class="fu">Index</span>.<span class="fu">Distance</span> { <span class="kw">return</span> front.<span class="fu">count</span> + back.<span class="fu">count</span> }</a>
<a class="sourceLine" id="cb8-6" data-line-number="6">  <span class="fu">subscript</span>(i: Container.<span class="fu">Index</span>.<span class="fu">Distance</span>) -&gt; Container.<span class="fu">Generator</span>.<span class="fu">Element</span> {</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">    get {</a>
<a class="sourceLine" id="cb8-8" data-line-number="8">      switch <span class="fu">translate</span>(i) {</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">      <span class="kw">case</span> let .<span class="fu">Front</span>(i): <span class="kw">return</span> front[i]</a>
<a class="sourceLine" id="cb8-10" data-line-number="10">      <span class="kw">case</span> let .<span class="fu">Back</span>(i): <span class="kw">return</span> back[i]</a>
<a class="sourceLine" id="cb8-11" data-line-number="11">      }</a>
<a class="sourceLine" id="cb8-12" data-line-number="12">    } set {</a>
<a class="sourceLine" id="cb8-13" data-line-number="13">      switch <span class="fu">translate</span>(i) {</a>
<a class="sourceLine" id="cb8-14" data-line-number="14">      <span class="kw">case</span> let .<span class="fu">Front</span>(i): front[i] = newValue</a>
<a class="sourceLine" id="cb8-15" data-line-number="15">      <span class="kw">case</span> let .<span class="fu">Back</span>(i): back[i] = newValue</a>
<a class="sourceLine" id="cb8-16" data-line-number="16">      }</a>
<a class="sourceLine" id="cb8-17" data-line-number="17">    }</a>
<a class="sourceLine" id="cb8-18" data-line-number="18">  }</a>
<a class="sourceLine" id="cb8-19" data-line-number="19">}</a></code></pre></div>
<p>This makes things much easier to test and debug.</p>
<p>Here‚Äôs where the power of protocols becomes obvious. If you go back to the original definition of <code class="sourceCode scala">DequeType</code>, you can add <code class="sourceCode scala">Indexable</code>. It may seem like now only indexable things can conform, but what happens in practice is that when <code class="sourceCode scala">Indexable</code> looks for its requirements, <em>it can use the implementations in DequeType</em>. That means that we‚Äôve just made anything that can conform to <code class="sourceCode scala">DequeType</code> indexable. That‚Äôs awesome.</p>
<p>Next job is ranged indices. This is a good bit more complicated than the individual indices, so it definitely will benefit from being separated into a translate method:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb9-1" data-line-number="1">extension DequeType where</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">  Container.<span class="fu">Index</span> : RandomAccessIndexType,</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  Container.<span class="fu">Index</span>.<span class="fu">Distance</span> : BidirectionalIndexType {</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">  </a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  <span class="kw">private</span> func translate</a>
<a class="sourceLine" id="cb9-6" data-line-number="6">    (i: Range&lt;Container.<span class="fu">Index</span>.<span class="fu">Distance</span>&gt;)</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">    -&gt; IndexRangeLocation&lt;Container.<span class="fu">Index</span>&gt; {</a>
<a class="sourceLine" id="cb9-8" data-line-number="8">      <span class="kw">if</span> i.<span class="fu">endIndex</span> &lt;= front.<span class="fu">count</span> {</a>
<a class="sourceLine" id="cb9-9" data-line-number="9">        let s = front.<span class="fu">endIndex</span>.<span class="fu">advancedBy</span>(-i.<span class="fu">endIndex</span>)</a>
<a class="sourceLine" id="cb9-10" data-line-number="10">        <span class="kw">if</span> s == front.<span class="fu">startIndex</span> &amp;&amp; i.<span class="fu">isEmpty</span> { <span class="kw">return</span> .<span class="fu">Between</span> }</a>
<a class="sourceLine" id="cb9-11" data-line-number="11">        let e = front.<span class="fu">endIndex</span>.<span class="fu">advancedBy</span>(-i.<span class="fu">startIndex</span>)</a>
<a class="sourceLine" id="cb9-12" data-line-number="12">        <span class="kw">return</span> .<span class="fu">Front</span>(s..&lt;e)</a>
<a class="sourceLine" id="cb9-13" data-line-number="13">      }</a>
<a class="sourceLine" id="cb9-14" data-line-number="14">      <span class="kw">if</span> i.<span class="fu">startIndex</span> &gt;= front.<span class="fu">count</span> {</a>
<a class="sourceLine" id="cb9-15" data-line-number="15">        let s = back.<span class="fu">startIndex</span>.<span class="fu">advancedBy</span>(i.<span class="fu">startIndex</span> - front.<span class="fu">count</span>)</a>
<a class="sourceLine" id="cb9-16" data-line-number="16">        let e = back.<span class="fu">startIndex</span>.<span class="fu">advancedBy</span>(i.<span class="fu">endIndex</span> - front.<span class="fu">count</span>)</a>
<a class="sourceLine" id="cb9-17" data-line-number="17">        <span class="kw">return</span> .<span class="fu">Back</span>(s..&lt;e)</a>
<a class="sourceLine" id="cb9-18" data-line-number="18">      }</a>
<a class="sourceLine" id="cb9-19" data-line-number="19">      let f = front.<span class="fu">startIndex</span>..&lt;front.<span class="fu">endIndex</span>.<span class="fu">advancedBy</span>(-i.<span class="fu">startIndex</span>)</a>
<a class="sourceLine" id="cb9-20" data-line-number="20">      let b = back.<span class="fu">startIndex</span>..&lt;back.<span class="fu">startIndex</span>.<span class="fu">advancedBy</span>(i.<span class="fu">endIndex</span> - front.<span class="fu">count</span>)</a>
<a class="sourceLine" id="cb9-21" data-line-number="21">      <span class="kw">return</span> .<span class="fu">Over</span>(f, b)</a>
<a class="sourceLine" id="cb9-22" data-line-number="22">  }</a>
<a class="sourceLine" id="cb9-23" data-line-number="23">}</a>
<a class="sourceLine" id="cb9-24" data-line-number="24"></a>
<a class="sourceLine" id="cb9-25" data-line-number="25">let otherDeque: Deque = [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>] <span class="co">// [0, 1, 2 | 3, 4, 5]</span></a>
<a class="sourceLine" id="cb9-26" data-line-number="26"></a>
<a class="sourceLine" id="cb9-27" data-line-number="27">otherDeque.<span class="fu">translate</span>(<span class="dv">0</span>...<span class="dv">2</span>) <span class="co">// Front: 0..&lt;3</span></a>
<a class="sourceLine" id="cb9-28" data-line-number="28">otherDeque.<span class="fu">translate</span>(<span class="dv">4</span>...<span class="dv">5</span>) <span class="co">// Back: 1..&lt;3</span></a>
<a class="sourceLine" id="cb9-29" data-line-number="29">otherDeque.<span class="fu">translate</span>(<span class="dv">2</span>...<span class="dv">5</span>) <span class="co">// Over: 0..&lt;1, 0..&lt;3</span></a>
<a class="sourceLine" id="cb9-30" data-line-number="30">otherDeque.<span class="fu">translate</span>(<span class="dv">3</span>..&lt;<span class="dv">3</span>) <span class="co">// Between</span></a></code></pre></div>
<p>The invariant that must be maintained in the deque is this: if either stack has more than one element, the other cannot be empty. If the invariant is violated, the longer stack is reversed, and put in place of the shorter.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb10-1" data-line-number="1">public enum Balance {</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">  <span class="kw">case</span> FrontEmpty, BackEmpty, Balanced</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">}</a>
<a class="sourceLine" id="cb10-4" data-line-number="4"></a>
<a class="sourceLine" id="cb10-5" data-line-number="5">extension DequeType {</a>
<a class="sourceLine" id="cb10-6" data-line-number="6">  </a>
<a class="sourceLine" id="cb10-7" data-line-number="7">  public <span class="kw">var</span> balance: Balance {</a>
<a class="sourceLine" id="cb10-8" data-line-number="8">    <span class="fu">let</span> (f, b) = (front.<span class="fu">count</span>, back.<span class="fu">count</span>)</a>
<a class="sourceLine" id="cb10-9" data-line-number="9">    <span class="kw">if</span> f == <span class="dv">0</span> {</a>
<a class="sourceLine" id="cb10-10" data-line-number="10">      <span class="kw">if</span> b &gt; <span class="dv">1</span> {</a>
<a class="sourceLine" id="cb10-11" data-line-number="11">        <span class="kw">return</span> .<span class="fu">FrontEmpty</span></a>
<a class="sourceLine" id="cb10-12" data-line-number="12">      }</a>
<a class="sourceLine" id="cb10-13" data-line-number="13">    } <span class="kw">else</span> <span class="kw">if</span> b == <span class="dv">0</span> {</a>
<a class="sourceLine" id="cb10-14" data-line-number="14">      <span class="kw">if</span> f &gt; <span class="dv">1</span> {</a>
<a class="sourceLine" id="cb10-15" data-line-number="15">        <span class="kw">return</span> .<span class="fu">BackEmpty</span></a>
<a class="sourceLine" id="cb10-16" data-line-number="16">      }</a>
<a class="sourceLine" id="cb10-17" data-line-number="17">    }</a>
<a class="sourceLine" id="cb10-18" data-line-number="18">    <span class="kw">return</span> .<span class="fu">Balanced</span></a>
<a class="sourceLine" id="cb10-19" data-line-number="19">  }</a>
<a class="sourceLine" id="cb10-20" data-line-number="20">  </a>
<a class="sourceLine" id="cb10-21" data-line-number="21">  public <span class="kw">var</span> isBalanced: Bool {</a>
<a class="sourceLine" id="cb10-22" data-line-number="22">    <span class="kw">return</span> balance == .<span class="fu">Balanced</span></a>
<a class="sourceLine" id="cb10-23" data-line-number="23">  }</a>
<a class="sourceLine" id="cb10-24" data-line-number="24">}</a></code></pre></div>
<p>A deque is a good data structure for certain uses, especially those that require popping and appending from either end. <code class="sourceCode scala"><span class="fu">popFirst</span>()</code> and <code class="sourceCode scala"><span class="fu">popLast</span>()</code> aren‚Äôt included in the standard <code class="sourceCode scala">RangeReplaceableCollectionType</code>, though, so we‚Äôll have to add our own.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb11-1" data-line-number="1">extension RangeReplaceableCollectionType where Index : BidirectionalIndexType {</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">  <span class="kw">private</span> mutating func <span class="fu">popLast</span>() -&gt; Generator.<span class="fu">Element</span>? {</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">    <span class="kw">return</span> isEmpty ? nil : <span class="fu">removeLast</span>()</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">  }</a>
<a class="sourceLine" id="cb11-5" data-line-number="5">}</a>
<a class="sourceLine" id="cb11-6" data-line-number="6"></a>
<a class="sourceLine" id="cb11-7" data-line-number="7"><span class="kw">var</span> mutableDeque: Deque = [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>]</a>
<a class="sourceLine" id="cb11-8" data-line-number="8">mutableDeque.<span class="fu">popLast</span>() <span class="co">// 5</span></a>
<a class="sourceLine" id="cb11-9" data-line-number="9">mutableDeque           <span class="co">// [0, 1, 2 | 3, 4]</span></a>
<a class="sourceLine" id="cb11-10" data-line-number="10"></a>
<a class="sourceLine" id="cb11-11" data-line-number="11">extension DequeType where Container.<span class="fu">Index</span> : BidirectionalIndexType {</a>
<a class="sourceLine" id="cb11-12" data-line-number="12">  public mutating func <span class="fu">popLast</span>() -&gt; Container.<span class="fu">Generator</span>.<span class="fu">Element</span>? {</a>
<a class="sourceLine" id="cb11-13" data-line-number="13">    <span class="kw">return</span> back.<span class="fu">popLast</span>()</a>
<a class="sourceLine" id="cb11-14" data-line-number="14">  }</a>
<a class="sourceLine" id="cb11-15" data-line-number="15">}</a></code></pre></div>
<p>The method needs to include <code class="sourceCode scala"><span class="fu">check</span>()</code>, which we can do with <code>defer</code></p>
<div class="sourceCode" id="cb12"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb12-1" data-line-number="1">mutating func <span class="fu">popLast</span>() -&gt; Container.<span class="fu">Generator</span>.<span class="fu">Element</span>? {</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">  defer { <span class="fu">check</span>() }</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">  <span class="kw">return</span> back.<span class="fu">popLast</span>()</a>
<a class="sourceLine" id="cb12-4" data-line-number="4">}</a>
<a class="sourceLine" id="cb12-5" data-line-number="5"></a>
<a class="sourceLine" id="cb12-6" data-line-number="6">mutableDeque.<span class="fu">popLast</span>() <span class="co">// 4</span></a>
<a class="sourceLine" id="cb12-7" data-line-number="7">mutableDeque           <span class="co">// [0, 1, 2 | 3]</span></a>
<a class="sourceLine" id="cb12-8" data-line-number="8">mutableDeque.<span class="fu">popLast</span>() <span class="co">// 3</span></a>
<a class="sourceLine" id="cb12-9" data-line-number="9">mutableDeque           <span class="co">// [0 | 1, 2]</span></a></code></pre></div>
<p>You also can‚Äôt just pop from the back queue in <code class="sourceCode scala"><span class="fu">popLast</span>()</code>, because it may be the case that the front stack has one element left</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb13-1" data-line-number="1">mutating func <span class="fu">popLast</span>() -&gt; Container.<span class="fu">Generator</span>.<span class="fu">Element</span>? {</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">  defer { <span class="fu">check</span>() }</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">  <span class="kw">return</span> back.<span class="fu">popLast</span>() ?? front.<span class="fu">popLast</span>()</a>
<a class="sourceLine" id="cb13-4" data-line-number="4">}</a>
<a class="sourceLine" id="cb13-5" data-line-number="5"></a>
<a class="sourceLine" id="cb13-6" data-line-number="6">mutableDeque.<span class="fu">popLast</span>() <span class="co">// 2</span></a>
<a class="sourceLine" id="cb13-7" data-line-number="7">mutableDeque.<span class="fu">popLast</span>() <span class="co">// 1</span></a>
<a class="sourceLine" id="cb13-8" data-line-number="8">mutableDeque           <span class="co">// [0|]</span></a>
<a class="sourceLine" id="cb13-9" data-line-number="9">mutableDeque.<span class="fu">popLast</span>() <span class="co">// 0</span></a>
<a class="sourceLine" id="cb13-10" data-line-number="10">mutableDeque           <span class="co">// [|]</span></a>
<a class="sourceLine" id="cb13-11" data-line-number="11">mutableDeque.<span class="fu">popLast</span>() <span class="co">// nil</span></a></code></pre></div>
<p>The rest of the Deque was easy, with little to no repetition. Using protocols in this way was really surprisingly powerful: now, you can define a <code class="sourceCode scala">DequeType</code>, with full access to all of the collection methods, all the way up to <code class="sourceCode scala">RangeReplaceableCollectionType</code>, in five lines:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb14-1" data-line-number="1">public struct Deque&lt;Element&gt; : DequeType {</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">  public <span class="kw">var</span> front, back: [Element]</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">  public typealias SubSequence = DequeSlice&lt;Element&gt;</a>
<a class="sourceLine" id="cb14-4" data-line-number="4">  public <span class="fu">init</span>() { (front, back) = ([], []) }</a>
<a class="sourceLine" id="cb14-5" data-line-number="5">}</a>
<a class="sourceLine" id="cb14-6" data-line-number="6"></a>
<a class="sourceLine" id="cb14-7" data-line-number="7">public struct DequeSlice&lt;Element&gt; : DequeType {</a>
<a class="sourceLine" id="cb14-8" data-line-number="8">  public <span class="kw">var</span> front, back: ArraySlice&lt;Element&gt;</a>
<a class="sourceLine" id="cb14-9" data-line-number="9">  public typealias SubSequence = DequeSlice</a>
<a class="sourceLine" id="cb14-10" data-line-number="10">  public <span class="fu">init</span>() { (front, back) = ([], []) }</a>
<a class="sourceLine" id="cb14-11" data-line-number="11">}</a></code></pre></div>
<p>There‚Äôs no performance hit, there‚Äôs no safety problems. I only have one version of code to test, one version to change, one version to read. It‚Äôs completely extensible: you could use any kind of stack for the front and back. Even another Deque, if you were so inclined:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb15-1" data-line-number="1">struct DequeDeque&lt;Element&gt; : DequeType {</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">  <span class="kw">var</span> front, back: Deque&lt;Element&gt;</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">  typealias SubSequence = DequeDequeSlice&lt;Element&gt;</a>
<a class="sourceLine" id="cb15-4" data-line-number="4">  <span class="fu">init</span>() { front = <span class="fu">Deque</span>(); back = <span class="fu">Deque</span>() }</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">}</a>
<a class="sourceLine" id="cb15-6" data-line-number="6"></a>
<a class="sourceLine" id="cb15-7" data-line-number="7">struct DequeDequeSlice&lt;Element&gt; : DequeType {</a>
<a class="sourceLine" id="cb15-8" data-line-number="8">  <span class="kw">var</span> front, back: DequeSlice&lt;Element&gt;</a>
<a class="sourceLine" id="cb15-9" data-line-number="9">  typealias SubSequence = DequeDequeSlice</a>
<a class="sourceLine" id="cb15-10" data-line-number="10">  <span class="fu">init</span>() { front = <span class="fu">DequeSlice</span>(); back = <span class="fu">DequeSlice</span>() }</a>
<a class="sourceLine" id="cb15-11" data-line-number="11">}</a>
<a class="sourceLine" id="cb15-12" data-line-number="12"></a>
<a class="sourceLine" id="cb15-13" data-line-number="13">let dd: DequeDeque = [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>]</a>
<a class="sourceLine" id="cb15-14" data-line-number="14">dd.<span class="fu">front</span> <span class="co">// [4 | 3, 2, 1]</span></a>
<a class="sourceLine" id="cb15-15" data-line-number="15">dd.<span class="fu">back</span>  <span class="co">// [5 | 6, 7, 8]</span></a></code></pre></div>
<p>Woo protocols!</p>
]]></description>
    <pubDate>Mon, 24 Aug 2015 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2015-08-24-generic-deque.html</guid>
    <dc:creator>Donnacha Ois√≠n Kidney</dc:creator>
</item>
<item>
    <title>A Trie in Swift</title>
    <link>https://doisinkidney.com/posts/2015-08-11-swift-trie.html</link>
    <description><![CDATA[<div class="info">
    Posted on August 11, 2015
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Swift.html">Swift</a>, <a href="/tags/Data%20Structures.html">Data Structures</a>
    
</div>

<p>If you google ‚Äúcool data structures‚Äù you‚Äôll get¬†<a href="http://stackoverflow.com/questions/500607/what-are-the-lesser-known-but-useful-data-structures">this</a> as your first result. It‚Äôs a stackoverflow question: ‚ÄúWhat are the lesser known but useful data structures?‚Äù. And the top answer is a Trie. I read up on them, and found out a lot of cool things about their use (as well as finding out that I‚Äôm now the kind of person who googles¬†‚Äúcool data structures‚Äù). So I rocked on up to my playground, and got writing.</p>
<p>A Trie is a prefix tree. It‚Äôs another recursive data structure: each Trie contains other children Tries, identifiable by their prefixes.</p>
<p>It‚Äôs a bit of a hipster data structure, not very widely used, but it‚Äôs got some useful applications. It‚Äôs got set-like operations, with insertion and searching each at <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math>, where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> is the length of the sequence being searched for. A Set is the only way to go for hashable, unordered elements. But, if you‚Äôve got <em>sequences</em> of hashable elements, a Trie might be for you. (one thing to note is that Sets are hashable themselves, so if the sequences you want to store are unordered, a Set of Sets is more applicable)</p>
<figure>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/be/Trie_example.svg/1092px-Trie_example.svg.png" alt="A trie for keys" /><figcaption>A trie for keys</figcaption>
</figure>
<p>In Swift, we can do this by having every Trie contain a dictionary of prefixes and Tries. Something like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb1-1" data-line-number="1">public struct Trie&lt;Element : Hashable&gt; {</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  <span class="kw">private</span> <span class="kw">var</span> children: [Element:Trie&lt;Element&gt;]</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">}</a></code></pre></div>
<p>We don‚Äôt run into the problem of structs not being allowed to be recursive here, because we don‚Äôt directly store a Trie within a Trie - we store a <em>dictionary</em>, and therefore a reference to the child Tries. In this dictionary, the keys correspond to the prefixes. So how do we fill it up? Like lists, we can use the decomposition properties of generators:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb2-1" data-line-number="1">extension Trie {</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  <span class="kw">private</span> init&lt;G : GeneratorType where G.<span class="fu">Element</span> == Element&gt;(<span class="kw">var</span> gen: G) {</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">    <span class="kw">if</span> let head = gen.<span class="fu">next</span>() {</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">      children = [head:<span class="fu">Trie</span>(gen:gen)]</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">    } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">      children = [:]</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">    }</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">  }</a>
<a class="sourceLine" id="cb2-9" data-line-number="9">  public init</a>
<a class="sourceLine" id="cb2-10" data-line-number="10">    &lt;S : SequenceType where S.<span class="fu">Generator</span>.<span class="fu">Element</span> == Element&gt;</a>
<a class="sourceLine" id="cb2-11" data-line-number="11">    (_ seq: S) {</a>
<a class="sourceLine" id="cb2-12" data-line-number="12">      self.<span class="fu">init</span>(gen: seq.<span class="fu">generate</span>())</a>
<a class="sourceLine" id="cb2-13" data-line-number="13">  }</a>
<a class="sourceLine" id="cb2-14" data-line-number="14">}</a></code></pre></div>
<p>That‚Äôs not really enough. That can store one sequence, but we need an <code class="sourceCode scala">insert</code> function. Here ya go:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb3-1" data-line-number="1">extension Trie {</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  <span class="kw">private</span> mutating func insert</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">    &lt;G : GeneratorType where G.<span class="fu">Element</span> == Element&gt;</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">    (<span class="kw">var</span> gen: G) {</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">      <span class="kw">if</span> let head = gen.<span class="fu">next</span>() {</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">        children[head]?.<span class="fu">insert</span>(gen) ?? {children[head] = <span class="fu">Trie</span>(gen: gen)}()</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">      }</a>
<a class="sourceLine" id="cb3-8" data-line-number="8">  }</a>
<a class="sourceLine" id="cb3-9" data-line-number="9">  public mutating func insert</a>
<a class="sourceLine" id="cb3-10" data-line-number="10">    &lt;S : SequenceType where S.<span class="fu">Generator</span>.<span class="fu">Element</span> == Element&gt;</a>
<a class="sourceLine" id="cb3-11" data-line-number="11">    (seq: S) {</a>
<a class="sourceLine" id="cb3-12" data-line-number="12">      <span class="fu">insert</span>(seq.<span class="fu">generate</span>())</a>
<a class="sourceLine" id="cb3-13" data-line-number="13">  }</a>
<a class="sourceLine" id="cb3-14" data-line-number="14">}</a></code></pre></div>
<p>There‚Äôs a line in there that some may find offensive:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb4-1" data-line-number="1">children[head]?.<span class="fu">insert</span>(gen) ?? {children[head] = <span class="fu">Trie</span>(gen: gen)}()</a></code></pre></div>
<p>And, to be honest, I‚Äôm not a huge fan of it myself. It‚Äôs making use of the fact that you can call mutating methods on optionals with chaining. When you do it in this example, the optional is returned by the dictionary lookup: we then want to mutate that value, if it‚Äôs there, with an insertion.</p>
<p>If it‚Äôs <em>not</em> there, though, we want to add it in, so we‚Äôve got to have some way of understanding and dealing with that. We could try and extract the child Trie, like this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">if</span> let head = gen.<span class="fu">next</span>() {</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">  <span class="kw">if</span> <span class="kw">var</span> child = children[head] {</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">    child.<span class="fu">insert</span>(gen)</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">  } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">    children[head] = <span class="fu">Trie</span>(gen: gen)</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">  }</a>
<a class="sourceLine" id="cb5-7" data-line-number="7">}</a></code></pre></div>
<p>But the child there is just a copy of the actual child in the Trie we want to mutate. We could then set it back to the dictionary entry - but at this stage it feels like a lot of extra, inefficient work.</p>
<p>So, you can make use of the fact the functions which don‚Äôt return anything actually <em>do</em> return something: a special value called <code class="sourceCode scala">Void</code>, or <code class="sourceCode scala">()</code>. Except that, in this case, it‚Äôs <code class="sourceCode scala">()?</code> (or <code class="sourceCode scala">Optional&amp;lt;Void&amp;gt;</code>). We‚Äôre not interested in the void itself, obviously, just whether or not it‚Äôs <code class="sourceCode scala">nil</code>. So, one way you could use it would be like this:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">if</span> let _ = children[head]?.<span class="fu">insert</span>(gen) { <span class="kw">return</span> }</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">children[head] = <span class="fu">Trie</span>(gen: gen)</a></code></pre></div>
<p>Or, to use <code class="sourceCode scala">guard</code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb7-1" data-line-number="1">guard let _ = children[head]?.<span class="fu">insert</span>(gen) <span class="kw">else</span> { children[head] = <span class="fu">Trie</span>(gen: gen) }</a></code></pre></div>
<p>But I think the nil coalescing operator is a little clearer, without the distraction of <code class="sourceCode scala">let</code> or <code class="sourceCode scala">_</code>.</p>
<p>This data structure, as you can see, has a very different feel to the list. For a start, it‚Äôs much more mutable, with in-place mutating methods being a little easier than methods that return a new Trie. Also, laziness is pretty much out of the question: almost every imaginable useful method would involve evaluation of the entire Trie. (if anyone <em>does</em> have a useful way of thinking about Tries lazily, I‚Äôd love to hear it)</p>
<p>The contains function, the most important of them all, is here:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb8-1" data-line-number="1">extension Trie {</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  <span class="kw">private</span> func contains</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">    &lt;G : GeneratorType where G.<span class="fu">Element</span> == Element&gt;</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">    (<span class="kw">var</span> gen: G) -&gt; Bool {</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">      <span class="kw">return</span> gen.<span class="fu">next</span>().<span class="fu">map</span>{self.<span class="fu">children</span>[$<span class="dv">0</span>]?.<span class="fu">contains</span>(gen) ?? <span class="kw">false</span>} ?? <span class="kw">true</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">  }</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">  public func contains</a>
<a class="sourceLine" id="cb8-8" data-line-number="8">    &lt;S : SequenceType where S.<span class="fu">Generator</span>.<span class="fu">Element</span> == Element&gt;</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">    (seq: S) -&gt; Bool {</a>
<a class="sourceLine" id="cb8-10" data-line-number="10">      <span class="kw">return</span> <span class="fu">contains</span>(seq.<span class="fu">generate</span>())</a>
<a class="sourceLine" id="cb8-11" data-line-number="11">  }</a>
<a class="sourceLine" id="cb8-12" data-line-number="12">}</a></code></pre></div>
<p>So this uses more generators. If the generator is empty (<code class="sourceCode scala">gen.<span class="fu">next</span>()</code> returns <code class="sourceCode scala">nil</code>), then the Trie contains that sequence, as we have not yet found a dictionary without that element. Within the <code class="sourceCode scala"><span class="fu">map</span>()</code> we search for the next element from the generator. If <em>that</em> returns <code class="sourceCode scala">nil</code>, then the Trie doesn‚Äôt contain that sequence. Finally, if none of that works, return whether or not the child Trie contains the rest of the generator. Let‚Äôs try it out:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">var</span> jo = <span class="fu">Trie</span>([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>])</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">jo.<span class="fu">insert</span>([<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>])</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">jo.<span class="fu">insert</span>([<span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>])</a>
<a class="sourceLine" id="cb9-4" data-line-number="4"></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">jo.<span class="fu">contains</span>([<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>]) <span class="co">// true</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6">jo.<span class="fu">contains</span>([<span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">3</span>]) <span class="co">// false</span></a></code></pre></div>
<p>There‚Äôs a catch. The <code class="sourceCode scala">contains</code> method doesn‚Äôt work as we‚Äôd like it to:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb10-1" data-line-number="1">jo.<span class="fu">contains</span>([<span class="dv">1</span>, <span class="dv">2</span>]) <span class="co">// true</span></a></code></pre></div>
<p>Because we return <code class="sourceCode scala"><span class="kw">true</span></code> <em>whenever</em> the generator runs out, our Trie ‚Äúcontains‚Äù every prefix of the sequences that have been inserted. This is not what we want. One way to solve this may be to return <code class="sourceCode scala"><span class="kw">true</span></code> only if the last Trie found has no children. Something like this:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb11-1" data-line-number="1">extension Trie {</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">  <span class="kw">private</span> func contains</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">    &lt;G : GeneratorType where G.<span class="fu">Element</span> == Element&gt;</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">    (<span class="kw">var</span> gen: G) -&gt; Bool {</a>
<a class="sourceLine" id="cb11-5" data-line-number="5">      <span class="kw">return</span> gen.<span class="fu">next</span>().<span class="fu">map</span>{self.<span class="fu">children</span>[$<span class="dv">0</span>]?.<span class="fu">contains</span>(gen) ?? <span class="kw">false</span>} ?? children.<span class="fu">isEmpty</span></a>
<a class="sourceLine" id="cb11-6" data-line-number="6">  }</a>
<a class="sourceLine" id="cb11-7" data-line-number="7">}</a></code></pre></div>
<p>But this doesn‚Äôt really work either. what if we did <code class="sourceCode scala">jo.<span class="fu">insert</span>([<span class="dv">1</span>, <span class="dv">2</span>])</code>? Now, if we check if the Trie contains <code class="sourceCode scala">[<span class="dv">1</span>, <span class="dv">2</span>]</code>, we‚Äôll get back <code class="sourceCode scala"><span class="kw">false</span></code>.</p>
<p>It‚Äôs time for flags. We need to add an extra variable to our Trie: a Boolean, which describes whether or not that Trie represents the end of a sequence.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb12-1" data-line-number="1">public struct Trie&lt;Element : Hashable&gt; {</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">  <span class="kw">private</span> <span class="kw">var</span> children: [Element:Trie&lt;Element&gt;]</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">  <span class="kw">private</span> <span class="kw">var</span> endHere : Bool</a>
<a class="sourceLine" id="cb12-4" data-line-number="4">}</a></code></pre></div>
<p>We‚Äôll also need to change our <code class="sourceCode scala">insert</code> and <code class="sourceCode scala">init</code> functions, so that when the generator returns <code class="sourceCode scala">nil</code>, <code class="sourceCode scala">endHere</code> gets initialised to <code class="sourceCode scala"><span class="kw">true</span></code>.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb13-1" data-line-number="1">extension Trie {</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">  <span class="kw">private</span> init&lt;G : GeneratorType where G.<span class="fu">Element</span> == Element&gt;(<span class="kw">var</span> gen: G) {</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">    <span class="kw">if</span> let head = gen.<span class="fu">next</span>() {</a>
<a class="sourceLine" id="cb13-4" data-line-number="4">      (children, endHere) = ([head:<span class="fu">Trie</span>(gen:gen)], <span class="kw">false</span>)</a>
<a class="sourceLine" id="cb13-5" data-line-number="5">    } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb13-6" data-line-number="6">      (children, endHere) = ([:], <span class="kw">true</span>)</a>
<a class="sourceLine" id="cb13-7" data-line-number="7">    }</a>
<a class="sourceLine" id="cb13-8" data-line-number="8">  }</a>
<a class="sourceLine" id="cb13-9" data-line-number="9">}</a>
<a class="sourceLine" id="cb13-10" data-line-number="10"></a>
<a class="sourceLine" id="cb13-11" data-line-number="11">extension Trie {</a>
<a class="sourceLine" id="cb13-12" data-line-number="12">  <span class="kw">private</span> mutating func insert</a>
<a class="sourceLine" id="cb13-13" data-line-number="13">    &lt;G : GeneratorType where G.<span class="fu">Element</span> == Element&gt;</a>
<a class="sourceLine" id="cb13-14" data-line-number="14">    (<span class="kw">var</span> gen: G) {</a>
<a class="sourceLine" id="cb13-15" data-line-number="15">      <span class="kw">if</span> let head = gen.<span class="fu">next</span>() {</a>
<a class="sourceLine" id="cb13-16" data-line-number="16">        children[head]?.<span class="fu">insert</span>(gen) ?? {children[head] = <span class="fu">Trie</span>(gen: gen)}()</a>
<a class="sourceLine" id="cb13-17" data-line-number="17">      } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb13-18" data-line-number="18">        endHere = <span class="kw">true</span></a>
<a class="sourceLine" id="cb13-19" data-line-number="19">      }</a>
<a class="sourceLine" id="cb13-20" data-line-number="20">  }</a>
<a class="sourceLine" id="cb13-21" data-line-number="21">}</a></code></pre></div>
<p>And the contains function now returns <code class="sourceCode scala">endHere</code>, instead of true:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb14-1" data-line-number="1">public extension Trie {</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">  <span class="kw">private</span> func contains</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">    &lt;G : GeneratorType where G.<span class="fu">Element</span> == Element&gt;</a>
<a class="sourceLine" id="cb14-4" data-line-number="4">    (<span class="kw">var</span> gen: G) -&gt; Bool {</a>
<a class="sourceLine" id="cb14-5" data-line-number="5">      <span class="kw">return</span> gen.<span class="fu">next</span>().<span class="fu">map</span>{self.<span class="fu">children</span>[$<span class="dv">0</span>]?.<span class="fu">contains</span>(gen) ?? <span class="kw">false</span>} ?? endHere</a>
<a class="sourceLine" id="cb14-6" data-line-number="6">  }</a>
<a class="sourceLine" id="cb14-7" data-line-number="7">}</a></code></pre></div>
<p>While we‚Äôre improving the <code class="sourceCode scala">contains</code> function, we could use <code class="sourceCode scala">guard</code> to make it much more readable:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb15-1" data-line-number="1">public extension Trie {</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">  <span class="kw">private</span> func contains&lt;</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">    G : GeneratorType where G.<span class="fu">Element</span> == Element</a>
<a class="sourceLine" id="cb15-4" data-line-number="4">    &gt;(<span class="kw">var</span> gen: G) -&gt; Bool {</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">      guard let head = gen.<span class="fu">next</span>() <span class="kw">else</span> { <span class="kw">return</span> endHere }</a>
<a class="sourceLine" id="cb15-6" data-line-number="6">      <span class="kw">return</span> children[head]?.<span class="fu">contains</span>(gen) ?? <span class="kw">false</span></a>
<a class="sourceLine" id="cb15-7" data-line-number="7">  }</a>
<a class="sourceLine" id="cb15-8" data-line-number="8">}</a></code></pre></div>
<p><a href="https://twitter.com/chriseidhof/status/629215881843884032">Chris Eidhof gave me this idea.</a> (Apparently there‚Äôs a Trie implementation in <a href="http://www.objc.io/books/fpinswift/">Functional Programming in Swift</a>, his book. I‚Äôve not read it, but it‚Äôs on my list. If <a href="http://www.objc.io/books/advanced-swift/">Advanced Swift</a>is anything to go by, it should be fantastic.)</p>
<p>The objective of this Trie is to replicate all of the Set methods: Union, Intersect, etc. Most of those are manageable to build from just <code class="sourceCode scala">insert</code>, <code class="sourceCode scala">init</code>, and <code class="sourceCode scala">contains</code>, but there‚Äôs one other function that comes in handy: <code class="sourceCode scala">remove</code>.</p>
<p>Remove is deceptively difficult. You could just walk to the end of your given sequence to remove, and switch <code class="sourceCode scala">endHere</code> from <code class="sourceCode scala"><span class="kw">true</span></code> to <code class="sourceCode scala"><span class="kw">false</span></code>, but that‚Äôs kind of cheating. I mean, you‚Äôll be storing the same amount of information that way after a removal. No, what you need is something that deletes branches of a tree that aren‚Äôt being used any more.</p>
<p>Again, this is a little complicated. You can‚Äôt just find the head of the sequence you want to remove, and then delete all children: you may be deleting other entries along with that. You <em>also</em> can‚Äôt just delete when a given Trie only contains one child: that child may branch off subsequently, or it may contain prefixes for the sequence you want to remove.</p>
<p>Crucially, all of the information telling you whether or not you can delete a given entry in a given Trie will come from the <em>children</em> of that Trie. What I decided to go with was this: I‚Äôll have some mutating method that does the work recursively. However, this method also <em>returns</em> a value, representing some important information for whatever called it. In this case, the <code class="sourceCode scala">remove</code> method would remove, as you‚Äôd imagine, but it will also return a Boolean, signifying whether the Trie it was called on can be removed. Since I used the normal structure of having a private method take a generator, and then a public wrapper method take a sequence, I could have the public method just discard the Boolean.</p>
<p>Let‚Äôs go through it. Here‚Äôs the signature:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="kw">private</span> mutating func remove&lt;</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">  G : GeneratorType where G.<span class="fu">Element</span> == Element</a>
<a class="sourceLine" id="cb16-3" data-line-number="3">  &gt;(<span class="kw">var</span> g: G) -&gt; Bool {</a></code></pre></div>
<p>No surprises there. Similar to the other methods. Then, get the head from the generator:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw">if</span> let head = g.<span class="fu">next</span>() {</a></code></pre></div>
<p>Within that if block is the meat of the logic, so I might skip to what happens if <code class="sourceCode scala">g.<span class="fu">next</span>()</code> returns <code class="sourceCode scala">nil</code> for the start:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="kw">private</span> mutating func remove&lt;</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">  G : GeneratorType where G.<span class="fu">Element</span> == Element</a>
<a class="sourceLine" id="cb18-3" data-line-number="3">  &gt;(<span class="kw">var</span> g: G) -&gt; Bool {</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">    <span class="kw">if</span> let head = g.<span class="fu">next</span>() {...}</a>
<a class="sourceLine" id="cb18-5" data-line-number="5">    endHere = <span class="kw">false</span></a>
<a class="sourceLine" id="cb18-6" data-line-number="6">    <span class="kw">return</span> children.<span class="fu">isEmpty</span></a>
<a class="sourceLine" id="cb18-7" data-line-number="7">}</a></code></pre></div>
<p>So the sequence being removed has ended. That means that whatever Trie you‚Äôre on should have its <code class="sourceCode scala">endHere</code> set to <code class="sourceCode scala"><span class="kw">false</span></code>. To the user of the Trie, that‚Äôs all that matters: from now on, if the contains method on that Trie is used with that sequence, it will return false.</p>
<p>However, to find out if you can delete the data itself, it returns <code class="sourceCode scala">children.<span class="fu">isEmpty</span></code>. If it has no children, it does not hold any other sequences or information, so it can be deleted.</p>
<p>Now for inside the if block:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb19-1" data-line-number="1">guard children[head]?.<span class="fu">remove</span>(g) == <span class="kw">true</span> <span class="kw">else</span> { <span class="kw">return</span> <span class="kw">false</span> }</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">children.<span class="fu">removeValueForKey</span>(head)</a>
<a class="sourceLine" id="cb19-3" data-line-number="3"><span class="kw">return</span> !endHere &amp;&amp; children.<span class="fu">isEmpty</span></a></code></pre></div>
<p>So it calls <code class="sourceCode scala">remove</code> on the child Trie corresponding to <code class="sourceCode scala">head</code>. That guard statement will fail for two distinct reasons: if <code class="sourceCode scala">children</code> doesn‚Äôt contain <code class="sourceCode scala">head</code>, then the sequence being removed wasn‚Äôt in the Trie in the first place. The method will then return false, so that no removal or mutation is done.</p>
<p>If it <em>does</em> contain <code class="sourceCode scala">head</code>, but the Bool returned from the remove method is <code class="sourceCode scala"><span class="kw">false</span></code>, that means that its <em>child</em> is not removable, so it is also not removable, so it should return <code class="sourceCode scala"><span class="kw">false</span></code>.</p>
<p>Otherwise, it will remove that member (<code class="sourceCode scala">children.<span class="fu">removeValueForKey</span>(head)</code>). Then, the Trie can decide whether or not it itself is removable: <code class="sourceCode scala"><span class="kw">return</span> !endHere &amp;amp;&amp;amp; children.<span class="fu">isEmpty</span></code>. If the <code class="sourceCode scala">endHere</code> is set to true, then it is the end of some sequence: it is not removable. Otherwise, it‚Äôs removable if it has no children. Here‚Äôs the whole thing, with its public version:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb20-1" data-line-number="1">extension Trie {</a>
<a class="sourceLine" id="cb20-2" data-line-number="2">  <span class="kw">private</span> mutating func remove&lt;</a>
<a class="sourceLine" id="cb20-3" data-line-number="3">    G : GeneratorType where G.<span class="fu">Element</span> == Element</a>
<a class="sourceLine" id="cb20-4" data-line-number="4">    &gt;(<span class="kw">var</span> g: G) -&gt; Bool { <span class="co">// Return value signifies whether or not it can be removed</span></a>
<a class="sourceLine" id="cb20-5" data-line-number="5">      <span class="kw">if</span> let head = g.<span class="fu">next</span>() {</a>
<a class="sourceLine" id="cb20-6" data-line-number="6">        guard children[head]?.<span class="fu">remove</span>(g) == <span class="kw">true</span> <span class="kw">else</span> { <span class="kw">return</span> <span class="kw">false</span> }</a>
<a class="sourceLine" id="cb20-7" data-line-number="7">        children.<span class="fu">removeValueForKey</span>(head)</a>
<a class="sourceLine" id="cb20-8" data-line-number="8">        <span class="kw">return</span> !endHere &amp;&amp; children.<span class="fu">isEmpty</span></a>
<a class="sourceLine" id="cb20-9" data-line-number="9">      }</a>
<a class="sourceLine" id="cb20-10" data-line-number="10">      endHere = <span class="kw">false</span></a>
<a class="sourceLine" id="cb20-11" data-line-number="11">      <span class="kw">return</span> children.<span class="fu">isEmpty</span></a>
<a class="sourceLine" id="cb20-12" data-line-number="12">  }</a>
<a class="sourceLine" id="cb20-13" data-line-number="13">  public mutating func remove&lt;</a>
<a class="sourceLine" id="cb20-14" data-line-number="14">    S : SequenceType where S.<span class="fu">Generator</span>.<span class="fu">Element</span> == Element</a>
<a class="sourceLine" id="cb20-15" data-line-number="15">    &gt;(seq: S) {</a>
<a class="sourceLine" id="cb20-16" data-line-number="16">      <span class="fu">remove</span>(seq.<span class="fu">generate</span>())</a>
<a class="sourceLine" id="cb20-17" data-line-number="17">  }</a>
<a class="sourceLine" id="cb20-18" data-line-number="18">}</a></code></pre></div>
<p>That was a little heavy. And kind of ugly. Let‚Äôs lighten things up for a second, with one of the loveliest <code class="sourceCode scala">count</code> properties I‚Äôve seen:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb21-1" data-line-number="1">extension Trie {</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">  public <span class="kw">var</span> count: Int {</a>
<a class="sourceLine" id="cb21-3" data-line-number="3">    <span class="kw">return</span> children.<span class="fu">values</span>.<span class="fu">reduce</span>(endHere ? <span class="dv">1</span> : <span class="dv">0</span>) { $<span class="dv">0</span> + $<span class="fl">1.</span>count }</a>
<a class="sourceLine" id="cb21-4" data-line-number="4">  }</a>
<a class="sourceLine" id="cb21-5" data-line-number="5">}</a></code></pre></div>
<p>All it‚Äôs really doing is counting the instances of a <code class="sourceCode scala"><span class="kw">true</span></code> <code class="sourceCode scala">endHere</code>. If the current Trie is an end, then it knows that it adds one to the count (<code class="sourceCode scala">endHere ? <span class="dv">1</span> : <span class="dv">0</span></code>), and it adds that to the sum of the counts of its children.</p>
<p>Now then. <code class="sourceCode scala">SequenceType</code>. <a href="http://airspeedvelocity.net/2015/07/22/a-persistent-tree-using-indirect-enums-in-swift/">Getting tree-like structures to conform to <code class="sourceCode scala">SequenceType</code> is a bit of a pain</a>, mainly because of their recursiveness. Getting a linear representation is easy enough:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb22-1" data-line-number="1">extension Trie {</a>
<a class="sourceLine" id="cb22-2" data-line-number="2">  public <span class="kw">var</span> contents: [[Element]] {</a>
<a class="sourceLine" id="cb22-3" data-line-number="3">    <span class="kw">return</span> children.<span class="fu">flatMap</span> {</a>
<a class="sourceLine" id="cb22-4" data-line-number="4">      (head: Element, child: Trie&lt;Element&gt;) -&gt; [[Element]] in</a>
<a class="sourceLine" id="cb22-5" data-line-number="5">      child.<span class="fu">contents</span>.<span class="fu">map</span> { [head] + $<span class="dv">0</span> } + (child.<span class="fu">endHere</span> ? [[head]] : [])</a>
<a class="sourceLine" id="cb22-6" data-line-number="6">    }</a>
<a class="sourceLine" id="cb22-7" data-line-number="7">  }</a>
<a class="sourceLine" id="cb22-8" data-line-number="8">}</a></code></pre></div>
<p>And then you could just return the generate method from that for your Trie‚Äôs generate method.</p>
<p>The problem is that it‚Äôs not very proper: you‚Äôre translating your data structure into another data structure just to iterate through it. What you really want is something that generates each element on demand.</p>
<p>But it gets ugly quick. You‚Äôve got to do a lot of stuff by hand which it isn‚Äôt nice to do by hand, and you‚Äôve got to employ some dirty tricks (like using closures as a kind of homemade <code class="sourceCode scala">indirect</code>). At any rate, here it is:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb23-1" data-line-number="1">public struct TrieGenerator&lt;Element : Hashable&gt; : GeneratorType {</a>
<a class="sourceLine" id="cb23-2" data-line-number="2">  <span class="kw">private</span> <span class="kw">var</span> children: DictionaryGenerator&lt;Element, Trie&lt;Element&gt;&gt;</a>
<a class="sourceLine" id="cb23-3" data-line-number="3">  <span class="kw">private</span> <span class="kw">var</span> curHead : Element?</a>
<a class="sourceLine" id="cb23-4" data-line-number="4">  <span class="kw">private</span> <span class="kw">var</span> curEnd  : Bool = <span class="kw">false</span></a>
<a class="sourceLine" id="cb23-5" data-line-number="5">  <span class="kw">private</span> <span class="kw">var</span> innerGen: (() -&gt; [Element]?)?</a>
<a class="sourceLine" id="cb23-6" data-line-number="6">  <span class="kw">private</span> mutating func <span class="fu">update</span>() {</a>
<a class="sourceLine" id="cb23-7" data-line-number="7">    guard <span class="fu">let</span> (head, child) = children.<span class="fu">next</span>() <span class="kw">else</span> { innerGen = nil; <span class="kw">return</span> }</a>
<a class="sourceLine" id="cb23-8" data-line-number="8">    curHead = head</a>
<a class="sourceLine" id="cb23-9" data-line-number="9">    <span class="kw">var</span> g = child.<span class="fu">generate</span>()</a>
<a class="sourceLine" id="cb23-10" data-line-number="10">    innerGen = {g.<span class="fu">next</span>()}</a>
<a class="sourceLine" id="cb23-11" data-line-number="11">    curEnd = child.<span class="fu">endHere</span></a>
<a class="sourceLine" id="cb23-12" data-line-number="12">  }</a>
<a class="sourceLine" id="cb23-13" data-line-number="13">  public mutating func <span class="fu">next</span>() -&gt; [Element]? {</a>
<a class="sourceLine" id="cb23-14" data-line-number="14">    <span class="kw">for</span> ; innerGen != nil; <span class="fu">update</span>() {</a>
<a class="sourceLine" id="cb23-15" data-line-number="15">      <span class="kw">if</span> let next = innerGen!() {</a>
<a class="sourceLine" id="cb23-16" data-line-number="16">        <span class="kw">return</span> [curHead!] + next</a>
<a class="sourceLine" id="cb23-17" data-line-number="17">      } <span class="kw">else</span> <span class="kw">if</span> curEnd {</a>
<a class="sourceLine" id="cb23-18" data-line-number="18">        curEnd = <span class="kw">false</span></a>
<a class="sourceLine" id="cb23-19" data-line-number="19">        <span class="kw">return</span> [curHead!]</a>
<a class="sourceLine" id="cb23-20" data-line-number="20">      }</a>
<a class="sourceLine" id="cb23-21" data-line-number="21">    }</a>
<a class="sourceLine" id="cb23-22" data-line-number="22">    <span class="kw">return</span> nil</a>
<a class="sourceLine" id="cb23-23" data-line-number="23">  }</a>
<a class="sourceLine" id="cb23-24" data-line-number="24">  <span class="kw">private</span> <span class="fu">init</span>(_ from: Trie&lt;Element&gt;) {</a>
<a class="sourceLine" id="cb23-25" data-line-number="25">    children = from.<span class="fu">children</span>.<span class="fu">generate</span>()</a>
<a class="sourceLine" id="cb23-26" data-line-number="26">    <span class="fu">update</span>()</a>
<a class="sourceLine" id="cb23-27" data-line-number="27">  }</a>
<a class="sourceLine" id="cb23-28" data-line-number="28">}</a></code></pre></div>
<p>It‚Äôs got a similar logic to the lazy flatMap I did from a while ago.</p>
<p>The code is all available <a href="https://github.com/oisdk/SwiftTrie">here</a>,¬†as a playground, or <a href="https://github.com/oisdk/SwiftSequence">here</a>,¬†in SwiftSequence, where it‚Äôs accompanied by some tests.</p>
]]></description>
    <pubDate>Tue, 11 Aug 2015 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2015-08-11-swift-trie.html</guid>
    <dc:creator>Donnacha Ois√≠n Kidney</dc:creator>
</item>
<item>
    <title>Monty Hall</title>
    <link>https://doisinkidney.com/posts/2015-08-03-monty-hall.html</link>
    <description><![CDATA[<div class="info">
    Posted on August  3, 2015
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Swift.html">Swift</a>, <a href="/tags/Probability.html">Probability</a>
    
</div>

<p>The Monty Hall problem is a great example of how counter-intuitive probability can sometimes be. It goes something like this: say you‚Äôre on a gameshow, with the chance to win a car. You‚Äôre shown three doors, and the car is behind one, goats behind the other two. You pick a door, say the leftmost, but then the host of the gameshow stops you before it‚Äôs opened. He opens one of the two doors you didn‚Äôt pick, revealing a goat. He then asks you if you‚Äôd like to change your decision. So? Do you?</p>
<p>Perhaps surprisingly, you <em>should</em> change your decision. Your chances of winning a car go from 1/3 to 2/3.</p>
<p>If you‚Äôve not thought for a while about the problem, the answer above might sound instinctively wrong. A few <a href="http://www.thomashanning.com/swift-playground-the-monty-hall-problem/">blog posts</a> over the past few weeks have made an effort to put some concrete numbers to the statistics, running simulations of each possibility, and counting up the amount of wins and losses.</p>
<p>I was still a little unsatisfied, though. I mean, showing me the actual numbers is fine, but I‚Äôd like something a little more <em>proof</em>-y. You can get close with a diagram:</p>
<p><img src="/images/monty-hall-tree.png" /></p>
<p>Which makes it pretty clear what‚Äôs going on: since the host <em>has</em> to show a goat when he opens a door, if you‚Äôve picked a goat, then the only door left after the host opens one is the car. That means that if you switch and pick a goat, you <em>have</em> to win. So if you decide to switch, then what you want to do is pick a <em>goat</em> first, and the chances of that are 2/3.</p>
<p>It would be far cooler if you could get some representation of that diagram in code, though.</p>
<p>Turns out we can! In Swift and Haskell (I‚Äôm branching out) you can represent probability in a list-like structure, with each element of the list being a tuple of some value and that value‚Äôs probability. All the probabilities in the list itself should add up to one. Here‚Äôs what it looks like in Swift:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb1-1" data-line-number="1">struct Prob&lt;Element&gt; {</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  <span class="kw">private</span> let contents: [(Element, Double)]</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">}</a></code></pre></div>
<p>and Haskell:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Prob</span> a <span class="fu">=</span> <span class="dt">Prob</span> {<span class="ot"> getProb ::</span> [(a,<span class="dt">Rational</span>)] } <span class="kw">deriving</span> <span class="dt">Show</span>  </a></code></pre></div>
<p>Being a list kind of thing, ideally you‚Äôd want to be able to transform the elements, with a map kind of thing:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb3-1" data-line-number="1">extension Prob {</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  func fmap&lt;T&gt;(f: Element -&gt; T) -&gt; Prob&lt;T&gt; {</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">    <span class="kw">return</span> Prob&lt;T&gt;(contents.<span class="fu">map</span> { (v,p) <span class="fu">in</span> (<span class="fu">f</span>(v), p) })</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">  }</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">}</a></code></pre></div>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Prob</span> <span class="kw">where</span>  </a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  fmap f (<span class="dt">Prob</span> xs) <span class="fu">=</span> <span class="dt">Prob</span> [(f x,p)<span class="fu">|</span>(x,p) <span class="ot">&lt;-</span> xs]</a></code></pre></div>
<p>So far, though, the probability information is kind of superfluous. There‚Äôs not even a decent way to generate it. How about we get it from a list, where we assume all things in the list have equal chances of happening:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb5-1" data-line-number="1">extension CollectionType where Index.<span class="fu">Distance</span> == Int {</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">  <span class="kw">var</span> equalProbs: Prob&lt;Generator.<span class="fu">Element</span>&gt; {</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">    let p = <span class="fl">1.0</span> / Double(count)</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">    <span class="kw">return</span> Prob&lt;Generator.<span class="fu">Element</span>&gt;(map { v <span class="fu">in</span> (v,p) })</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">  }</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">}</a></code></pre></div>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">equalProbs ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Prob</span> a</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">equalProbs x <span class="fu">=</span> <span class="dt">Prob</span> <span class="fu">$</span> map (flip (,) (<span class="dv">1</span><span class="fu">%</span>n))  x</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  <span class="kw">where</span> n <span class="fu">=</span> fromIntegral (length x)</a></code></pre></div>
<p>Which is <em>fine</em>, I suppose, but still not very interesting. What we want is the idea of ‚Äúbranching‚Äù - like in the diagram. ‚ÄúIf event A happens, then event B has X chance of happening, and event C has Y chance of happening‚Äù.</p>
<p>The normal rules of probability apply: the <em>overall</em> probability of B happening is equal to the probability of A multiplied by X. You could have several layers of branching from B and C onwards, with this multiplication happening at each stage.</p>
<p>You could represent this in code with a function <code>f</code>, which takes an event (A) and returns a new bunch of probabilities (B and C). Then, to get the overall probability of each, you‚Äôd have to <em>flatten</em> it. What you want, then, is a function that travels over a list of events and their probabilities, applying <code>f</code> to each, and flattening the result, by <em>multiplying</em> the probabilities of the inner lists by the probability of the event which generated it.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb7-1" data-line-number="1">extension Prob {</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  func flatMap&lt;T&gt;(f: Element -&gt; Prob&lt;T&gt;) -&gt; Prob&lt;T&gt; {</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">    <span class="kw">return</span> Prob&lt;T&gt;(contents.<span class="fu">flatMap</span> { (v,p) in</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">      <span class="fu">f</span>(v).<span class="fu">contents</span>.<span class="fu">map</span> { (x,ip) <span class="fu">in</span> (x,p*ip) }</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">    })</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">  }</a>
<a class="sourceLine" id="cb7-7" data-line-number="7">}</a></code></pre></div>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Prob</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  return <span class="fu">=</span> pure</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  <span class="dt">Prob</span> xs <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> </a>
<a class="sourceLine" id="cb8-4" data-line-number="4">    <span class="dt">Prob</span> [(y,px<span class="fu">*</span>py)<span class="fu">|</span>(x,px) <span class="ot">&lt;-</span> xs, (y,py) <span class="ot">&lt;-</span> getProb(f x)]</a></code></pre></div>
<p>Hey look! The M-word. Never mind that. Anyway‚Ä¶</p>
<p>Now we have enough tools to stimulate some basic probabilities. Let‚Äôs say you‚Äôre playing a game, which begins with a coin flip. If you get heads on the coin flip, it confers some advantage, and you have a 70% chance of winning. Otherwise, you‚Äôve a 50% chance.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb9-1" data-line-number="1">enum Coin: String   { <span class="kw">case</span> H, T }</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">enum Result: String { <span class="kw">case</span> Win, Lose }</a>
<a class="sourceLine" id="cb9-3" data-line-number="3"></a>
<a class="sourceLine" id="cb9-4" data-line-number="4">func <span class="fu">play</span>(c: Coin) -&gt; Prob&lt;Result&gt; {</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  switch c {</a>
<a class="sourceLine" id="cb9-6" data-line-number="6">  <span class="kw">case</span> .<span class="fu">H</span>: <span class="kw">return</span> <span class="fu">Prob</span>([(.<span class="fu">Win</span>,<span class="fl">0.7</span>),(.<span class="fu">Lose</span>,<span class="fl">0.3</span>)])</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">  <span class="kw">case</span> .<span class="fu">T</span>: <span class="kw">return</span> [.<span class="fu">Win</span>,.<span class="fu">Lose</span>].<span class="fu">equalProbs</span></a>
<a class="sourceLine" id="cb9-8" data-line-number="8">  }</a>
<a class="sourceLine" id="cb9-9" data-line-number="9">}</a>
<a class="sourceLine" id="cb9-10" data-line-number="10"></a>
<a class="sourceLine" id="cb9-11" data-line-number="11">[Coin.<span class="fu">H</span>,.<span class="fu">T</span>]</a>
<a class="sourceLine" id="cb9-12" data-line-number="12">  .<span class="fu">equalProbs</span></a>
<a class="sourceLine" id="cb9-13" data-line-number="13">  .<span class="fu">flatMap</span>(play)</a>
<a class="sourceLine" id="cb9-14" data-line-number="14"></a>
<a class="sourceLine" id="cb9-15" data-line-number="15"><span class="co">// 0.35: Result.Win</span></a>
<a class="sourceLine" id="cb9-16" data-line-number="16"><span class="co">// 0.15: Result.Lose</span></a>
<a class="sourceLine" id="cb9-17" data-line-number="17"><span class="co">// 0.25: Result.Win</span></a>
<a class="sourceLine" id="cb9-18" data-line-number="18"><span class="co">// 0.25: Result.Lose</span></a></code></pre></div>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Coin</span>   <span class="fu">=</span> <span class="dt">H</span> <span class="fu">|</span> <span class="dt">T</span> <span class="kw">deriving</span> <span class="dt">Show</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Result</span> <span class="fu">=</span> <span class="dt">Win</span> <span class="fu">|</span> <span class="dt">Lose</span> <span class="kw">deriving</span> <span class="dt">Show</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3"></a>
<a class="sourceLine" id="cb10-4" data-line-number="4"><span class="kw">let</span> play <span class="dt">H</span> <span class="fu">=</span> <span class="dt">Prob</span> [(<span class="dt">Win</span>,<span class="dv">7</span><span class="fu">%</span><span class="dv">10</span>),(<span class="dt">Lose</span>,<span class="dv">3</span><span class="fu">%</span><span class="dv">10</span>)]</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">    play <span class="dt">T</span> <span class="fu">=</span> equalProbs [<span class="dt">Win</span>,<span class="dt">Lose</span>]</a>
<a class="sourceLine" id="cb10-6" data-line-number="6"></a>
<a class="sourceLine" id="cb10-7" data-line-number="7">equalProbs [<span class="dt">H</span>,<span class="dt">T</span>] <span class="fu">&gt;&gt;=</span> play</a></code></pre></div>
<p>There‚Äôs an obvious problem: duplicates. We need some way to <em>combine</em> the results by adding their probabilities together. To be honest, this was the least interesting part, so I‚Äôll just dump the code here:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb11-1" data-line-number="1">public enum Ordering { <span class="kw">case</span> LT, EQ, GT }</a>
<a class="sourceLine" id="cb11-2" data-line-number="2"></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">extension SequenceType {</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">  <span class="kw">private</span> typealias A = Generator.<span class="fu">Element</span></a>
<a class="sourceLine" id="cb11-5" data-line-number="5">  public func <span class="fu">mergeBy</span>( comp: (A, A) -&gt; Ordering</a>
<a class="sourceLine" id="cb11-6" data-line-number="6">                     , _ merge: (A, A) -&gt; A) -&gt; [A] {</a>
<a class="sourceLine" id="cb11-7" data-line-number="7">    <span class="kw">var</span> result: [A] = []</a>
<a class="sourceLine" id="cb11-8" data-line-number="8">    <span class="kw">for</span> h in <span class="fu">sort</span>({ e in <span class="fu">comp</span>(e) == .<span class="fu">LT</span> }) {</a>
<a class="sourceLine" id="cb11-9" data-line-number="9">      <span class="kw">if</span> <span class="kw">case</span> .<span class="fu">EQ</span>? = result.<span class="fu">last</span>.<span class="fu">map</span>({e in <span class="fu">comp</span>(h,e)}) {</a>
<a class="sourceLine" id="cb11-10" data-line-number="10">        result.<span class="fu">append</span>(<span class="fu">merge</span>(result.<span class="fu">removeLast</span>(),h))</a>
<a class="sourceLine" id="cb11-11" data-line-number="11">      } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb11-12" data-line-number="12">        result.<span class="fu">append</span>(h)</a>
<a class="sourceLine" id="cb11-13" data-line-number="13">      }</a>
<a class="sourceLine" id="cb11-14" data-line-number="14">    }</a>
<a class="sourceLine" id="cb11-15" data-line-number="15">    <span class="kw">return</span> result</a>
<a class="sourceLine" id="cb11-16" data-line-number="16">  }</a>
<a class="sourceLine" id="cb11-17" data-line-number="17">}</a>
<a class="sourceLine" id="cb11-18" data-line-number="18"></a>
<a class="sourceLine" id="cb11-19" data-line-number="19">extension Prob {</a>
<a class="sourceLine" id="cb11-20" data-line-number="20">  public func mergeProbs</a>
<a class="sourceLine" id="cb11-21" data-line-number="21">    (comp: (Element,Element) -&gt; Ordering) -&gt; Prob {</a>
<a class="sourceLine" id="cb11-22" data-line-number="22">      <span class="kw">return</span> <span class="fu">Prob</span>(contents:</a>
<a class="sourceLine" id="cb11-23" data-line-number="23">        contents.<span class="fu">mergeBy</span>( {(a,b) in <span class="fu">comp</span>(a<span class="fl">.0</span>,b<span class="fl">.0</span>)}</a>
<a class="sourceLine" id="cb11-24" data-line-number="24">                        , {(a,b) <span class="fu">in</span> (a<span class="fl">.0</span>,a<span class="fl">.1</span>+b<span class="fl">.1</span>)})</a>
<a class="sourceLine" id="cb11-25" data-line-number="25">    )</a>
<a class="sourceLine" id="cb11-26" data-line-number="26">  }</a>
<a class="sourceLine" id="cb11-27" data-line-number="27">}</a></code></pre></div>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="ot">eqing ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Ordering</span>) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">eqing c <span class="fu">=</span> (\a b <span class="ot">-&gt;</span> <span class="kw">case</span> c a b <span class="kw">of</span> <span class="dt">EQ</span> <span class="ot">-&gt;</span> <span class="dt">True</span> </a>
<a class="sourceLine" id="cb12-3" data-line-number="3">                                 _  <span class="ot">-&gt;</span> <span class="dt">False</span>)</a>
<a class="sourceLine" id="cb12-4" data-line-number="4"></a>
<a class="sourceLine" id="cb12-5" data-line-number="5"><span class="ot">mergeBy ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Ordering</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb12-6" data-line-number="6">mergeBy m c <span class="fu">=</span> (foldl1&#39; m <span class="fu">&lt;$&gt;</span>) <span class="fu">.</span> groupBy (eqing c) <span class="fu">.</span> sortBy c</a>
<a class="sourceLine" id="cb12-7" data-line-number="7"></a>
<a class="sourceLine" id="cb12-8" data-line-number="8"><span class="ot">mergeProbs ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Prob</span> a <span class="ot">-&gt;</span> <span class="dt">Prob</span> a</a>
<a class="sourceLine" id="cb12-9" data-line-number="9">mergeProbs <span class="fu">=</span></a>
<a class="sourceLine" id="cb12-10" data-line-number="10">  <span class="dt">Prob</span> <span class="fu">.</span> mergeBy (fmap <span class="fu">.</span> (<span class="fu">+</span>) <span class="fu">.</span> snd) (comparing fst) <span class="fu">.</span> getProb</a></code></pre></div>
<p>Now we get some nicer probabilities, though:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb13-1" data-line-number="1">func <span class="fu">comp</span>(a: Result, b:Result) -&gt; Ordering {</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">  <span class="fu">switch</span> (a,b) {</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">  <span class="kw">case</span> (.<span class="fu">Win</span>,.<span class="fu">Win</span>),(.<span class="fu">Lose</span>,.<span class="fu">Lose</span>): <span class="kw">return</span> .<span class="fu">EQ</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4">  <span class="kw">case</span> (.<span class="fu">Lose</span>,.<span class="fu">Win</span>): <span class="kw">return</span> .<span class="fu">LT</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5">  <span class="kw">case</span> (.<span class="fu">Win</span>,.<span class="fu">Lose</span>): <span class="kw">return</span> .<span class="fu">GT</span></a>
<a class="sourceLine" id="cb13-6" data-line-number="6">  }</a>
<a class="sourceLine" id="cb13-7" data-line-number="7">}</a>
<a class="sourceLine" id="cb13-8" data-line-number="8"></a>
<a class="sourceLine" id="cb13-9" data-line-number="9">[Coin.<span class="fu">H</span>,.<span class="fu">T</span>]</a>
<a class="sourceLine" id="cb13-10" data-line-number="10">  .<span class="fu">equalProbs</span></a>
<a class="sourceLine" id="cb13-11" data-line-number="11">  .<span class="fu">flatMap</span>(play)</a>
<a class="sourceLine" id="cb13-12" data-line-number="12">  .<span class="fu">mergeProbs</span>(comp)</a>
<a class="sourceLine" id="cb13-13" data-line-number="13"></a>
<a class="sourceLine" id="cb13-14" data-line-number="14"><span class="co">// 0.4: Result.Lose</span></a>
<a class="sourceLine" id="cb13-15" data-line-number="15"><span class="co">// 0.6: Result.Win</span></a></code></pre></div>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Ord</span> <span class="dt">Result</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2">  compare <span class="dt">Win</span> <span class="dt">Lose</span> <span class="fu">=</span> <span class="dt">GT</span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3">  compare <span class="dt">Lose</span> <span class="dt">Win</span> <span class="fu">=</span> <span class="dt">LT</span></a>
<a class="sourceLine" id="cb14-4" data-line-number="4">  compare _    _   <span class="fu">=</span> <span class="dt">EQ</span></a>
<a class="sourceLine" id="cb14-5" data-line-number="5">  </a>
<a class="sourceLine" id="cb14-6" data-line-number="6">mergeProbs ( equalProbs [<span class="dt">H</span>,<span class="dt">T</span>] <span class="fu">&gt;&gt;=</span> play )</a></code></pre></div>
<p>And you can see what effect a loaded coin would have on your chances:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="fu">Prob</span>([(Coin.<span class="fu">H</span>,<span class="fl">0.7</span>),(.<span class="fu">T</span>,<span class="fl">0.3</span>)])</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">  .<span class="fu">flatMap</span>(play)</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">  .<span class="fu">mergeProbs</span>(comp)</a>
<a class="sourceLine" id="cb15-4" data-line-number="4"></a>
<a class="sourceLine" id="cb15-5" data-line-number="5"><span class="co">// 0.36: Result.Lose</span></a>
<a class="sourceLine" id="cb15-6" data-line-number="6"><span class="co">// 0.64: Result.Win</span></a></code></pre></div>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1">mergeProbs ( <span class="dt">Prob</span> [(<span class="dt">H</span>,<span class="dv">7</span><span class="fu">%</span><span class="dv">10</span>),(<span class="dt">T</span>,<span class="dv">3</span><span class="fu">%</span><span class="dv">10</span>)] <span class="fu">&gt;&gt;=</span> play )</a></code></pre></div>
<p>So how does this apply to Monty Hall? Well, we‚Äôve actually done most of the work already. We‚Äôll represent the doors as an Int, and the choice by an enum.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb17-1" data-line-number="1">public enum Choice { <span class="kw">case</span> Switch, Stick }</a></code></pre></div>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Choice</span> <span class="fu">=</span> <span class="dt">Switch</span> <span class="fu">|</span> <span class="dt">Stick</span></a></code></pre></div>
<p>Then, a <code class="sourceCode scala">chances</code> function. The logic here is a bit dense. First of all, if you‚Äôre going to stick, it doesn‚Äôt matter how many doors the host opens: your chance of getting a car is <code>1/n</code>, where <code>n</code> is the number of doors. However, if you‚Äôre going to switch, two things need to happen: you need to <em>not</em> pick the car on your first choice, <em>and</em> you need to pick the car on your second choice. The chance of picking the car on your second choice (if the one you picked on your first choice <em>wasn‚Äôt</em> the car) is the one over the number of doors, minus the number of doors the host opens, minus one.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb19-1" data-line-number="1">public func <span class="fu">chances</span>(n: Int, _ p: Int, _ c: Choice)(_ d: Int)</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">  -&gt; Prob&lt;Bool&gt; {</a>
<a class="sourceLine" id="cb19-3" data-line-number="3">    switch c {</a>
<a class="sourceLine" id="cb19-4" data-line-number="4">    <span class="kw">case</span> .<span class="fu">Stick</span> : <span class="kw">return</span> (<span class="dv">1</span>...<span class="fu">n</span>).<span class="fu">equalProbs</span>.<span class="fu">fmap</span>(==d)</a>
<a class="sourceLine" id="cb19-5" data-line-number="5">    <span class="kw">case</span> .<span class="fu">Switch</span>:</a>
<a class="sourceLine" id="cb19-6" data-line-number="6">      let notFirst = <span class="fu">chances</span>(n,p,.<span class="fu">Stick</span>)(d).<span class="fu">fmap</span>(!)</a>
<a class="sourceLine" id="cb19-7" data-line-number="7">      let second =</a>
<a class="sourceLine" id="cb19-8" data-line-number="8">        <span class="fu">Repeat</span>(count: (n-p)-<span class="dv">2</span>, repeatedValue: <span class="kw">false</span>) + [<span class="kw">true</span>]</a>
<a class="sourceLine" id="cb19-9" data-line-number="9">      <span class="kw">return</span> notFirst.<span class="fu">flatMap</span> { f in </a>
<a class="sourceLine" id="cb19-10" data-line-number="10">        second.<span class="fu">equalProbs</span>.<span class="fu">fmap</span> { s in f &amp;&amp; s } </a>
<a class="sourceLine" id="cb19-11" data-line-number="11">      }</a>
<a class="sourceLine" id="cb19-12" data-line-number="12">  }</a>
<a class="sourceLine" id="cb19-13" data-line-number="13">}</a></code></pre></div>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="ot">chances ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Choice</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Prob</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2">chances n _ <span class="dt">Stick</span>  d <span class="fu">=</span> fmap (<span class="fu">==</span>d) (equalProbs [<span class="dv">1</span><span class="fu">..</span>n])</a>
<a class="sourceLine" id="cb20-3" data-line-number="3">chances n p <span class="dt">Switch</span> d <span class="fu">=</span> </a>
<a class="sourceLine" id="cb20-4" data-line-number="4">  (<span class="fu">&amp;&amp;</span>) <span class="fu">.</span> not          <span class="fu">&lt;$&gt;</span></a>
<a class="sourceLine" id="cb20-5" data-line-number="5">  chances n p <span class="dt">Stick</span> d <span class="fu">&lt;*&gt;</span></a>
<a class="sourceLine" id="cb20-6" data-line-number="6">  (equalProbs <span class="fu">$</span> <span class="dt">True</span> <span class="fu">:</span> replicate (n<span class="fu">-</span>p<span class="fu">-</span><span class="dv">2</span>) <span class="dt">False</span>)</a></code></pre></div>
<p>Finally, the <code>chanceOfCar</code> function:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb21-1" data-line-number="1">public func chanceOfCar</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">  (n: Int, _ p: Int, _ s: Choice)</a>
<a class="sourceLine" id="cb21-3" data-line-number="3">  -&gt; Prob&lt;Bool&gt; {</a>
<a class="sourceLine" id="cb21-4" data-line-number="4">    <span class="kw">return</span> (<span class="dv">1</span>...<span class="fu">n</span>)</a>
<a class="sourceLine" id="cb21-5" data-line-number="5">      .<span class="fu">equalProbs</span></a>
<a class="sourceLine" id="cb21-6" data-line-number="6">      .<span class="fu">flatMap</span>(<span class="fu">chances</span>(n,p,s))</a>
<a class="sourceLine" id="cb21-7" data-line-number="7">      .<span class="fu">mergeProbs</span>(comp)</a>
<a class="sourceLine" id="cb21-8" data-line-number="8">}</a></code></pre></div>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="ot">chanceOfCar ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Choice</span> <span class="ot">-&gt;</span> <span class="dt">Prob</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb22-2" data-line-number="2">chanceOfCar n p s <span class="fu">=</span> mergeProbs <span class="fu">$</span></a>
<a class="sourceLine" id="cb22-3" data-line-number="3">                    equalProbs [<span class="dv">1</span><span class="fu">..</span>n] <span class="fu">&gt;&gt;=</span> </a>
<a class="sourceLine" id="cb22-4" data-line-number="4">                    chances n p s</a></code></pre></div>
<p>Which returns, as you‚Äôd expect, 1/3 chance of car if you stick, and 2/3 if you switch.</p>
<p>One of the final cool things you can do with this is change the number of doors, and the number of doors the host opens, and see what happens:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="fu">chanceOfCar</span>(<span class="dv">6</span>, <span class="dv">2</span>, .<span class="fu">Switch</span>) </a>
<a class="sourceLine" id="cb23-2" data-line-number="2"><span class="co">// 0.833333333333334: false, 0.166666666666667: true</span></a></code></pre></div>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1">chanceOfCar <span class="dv">8</span> <span class="dv">3</span> <span class="dt">Switch</span> <span class="fu">//</span> <span class="dv">7</span> <span class="fu">%</span> <span class="dv">32</span></a></code></pre></div>
<p>The advantage gets less and less, but never goes away.</p>
<p>If you check out the <a href="https://en.wikipedia.org/wiki/Monty_Hall_problem#N_doors">Wikipedia</a> entry on the problem, the formula for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>N</mi><annotation encoding="application/x-tex">N</annotation></semantics></math>-doors is given: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mrow><mi>N</mi><mo>‚àí</mo><mn>1</mn></mrow><mrow><mi>N</mi><mo stretchy="false" form="prefix">(</mo><mi>N</mi><mo>‚àí</mo><mi>p</mi><mo>‚àí</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow></mfrac><annotation encoding="application/x-tex">\frac{N‚àí1}{N(N‚àíp‚àí1)}</annotation></semantics></math>.</p>
<p>We can plug that straight in to our versions, to see if they‚Äôre correct:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="kw">let</span> sample <span class="fu">=</span> [(n,p)<span class="fu">|</span> n <span class="ot">&lt;-</span> [<span class="dv">3</span><span class="fu">..</span><span class="dv">20</span>], p <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span>(n<span class="fu">-</span><span class="dv">2</span>)]] </a>
<a class="sourceLine" id="cb25-2" data-line-number="2"><span class="kw">let</span> expect <span class="fu">=</span> fmap frmla sample</a>
<a class="sourceLine" id="cb25-3" data-line-number="3">             <span class="kw">where</span><span class="ot"> frmla ::</span> (<span class="dt">Integer</span>,<span class="dt">Integer</span>) <span class="ot">-&gt;</span> <span class="dt">Rational</span></a>
<a class="sourceLine" id="cb25-4" data-line-number="4">                   frmla (n,p) <span class="fu">=</span> (n <span class="fu">-</span> <span class="dv">1</span>)<span class="fu">%</span>(n<span class="fu">*</span>(n<span class="fu">-</span>p<span class="fu">-</span><span class="dv">1</span>))</a>
<a class="sourceLine" id="cb25-5" data-line-number="5"></a>
<a class="sourceLine" id="cb25-6" data-line-number="6"><span class="kw">let</span> actual <span class="fu">=</span> fmap t sample <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-7" data-line-number="7">  t (n,p) <span class="fu">=</span> truePrb <span class="fu">$</span> getProb <span class="fu">$</span> chanceOfCar n p <span class="dt">Switch</span></a>
<a class="sourceLine" id="cb25-8" data-line-number="8">  truePrb <span class="fu">=</span> fromJust <span class="fu">.</span> (fmap snd) <span class="fu">.</span> (find fst)</a>
<a class="sourceLine" id="cb25-9" data-line-number="9"></a>
<a class="sourceLine" id="cb25-10" data-line-number="10">expect <span class="fu">==</span> actual</a></code></pre></div>
<p>And it works! (I didn‚Äôt try the Swift version, because of floating-point inaccuracies)</p>
<p>You can see the code used <a href="https://github.com/oisdk/Monty-Hall">here</a>.</p>
]]></description>
    <pubDate>Mon, 03 Aug 2015 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2015-08-03-monty-hall.html</guid>
    <dc:creator>Donnacha Ois√≠n Kidney</dc:creator>
</item>
<item>
    <title>Deques, Queues, and Lists in Swift with Indirect</title>
    <link>https://doisinkidney.com/posts/2015-07-29-swift-queues.html</link>
    <description><![CDATA[<div class="info">
    Posted on July 29, 2015
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Swift.html">Swift</a>, <a href="/tags/Data%20Structures.html">Data Structures</a>
    
</div>

<p>Recursive enums have finally arrived. Woo! The first thing to do with these is to make a recursive list:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb1-1" data-line-number="1">public enum List&lt;Element&gt; {</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  <span class="kw">case</span> Nil</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  indirect <span class="kw">case</span> <span class="fu">Cons</span>(head: Element, tail: List&lt;Element&gt;)</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">}</a></code></pre></div>
<p>The <code class="sourceCode scala">head</code> stores the element, and <code class="sourceCode scala">tail</code> is a reference to the rest of the list. As you can imagine, getting at the <code class="sourceCode scala">head</code> is pretty easy, while accessing elements further along is more difficult. There‚Äôs a common pattern for dealing with these recursive structures: if you have a function that performs some transformation on a list, it will take the <code class="sourceCode scala">head</code>, perform that transformation on it, and then call itself recursively on the <code class="sourceCode scala">tail</code>. If it‚Äôs given an empty list, it returns an empty list. For instance, here‚Äôs the <code class="sourceCode haskell">map</code> function, defined in Haskell:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1">map _ []     <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">map f (x<span class="fu">:</span>xs) <span class="fu">=</span> f x <span class="fu">:</span> map f xs</a></code></pre></div>
<p>The two lines are analogous to a switch statement in Swift. The parameters for <code class="sourceCode haskell">map</code> are a transformation function and a list. So, the first line has <code class="sourceCode haskell">_</code> (wildcard) for the function, and <code class="sourceCode haskell">[]</code> (empty) for the list, meaning it will match any function and an empty list. It returns an empty list.</p>
<p>The second line matches a function (which it assigns the name <code class="sourceCode scala">f</code>) and then decomposes the list it‚Äôs given into a head (<code class="sourceCode scala">x</code>) and tail (<code class="sourceCode scala">xs</code>). It then calls <code class="sourceCode scala">f</code> on the head, and prepends (the <code class="sourceCode scala">:</code> operator is prepends, also called ‚Äúcons‚Äù by convention) the result to itself called recursively on the tail.</p>
<p>With switch statements and the <code class="sourceCode scala">indirect</code> keyword, we‚Äôre getting pretty close to that level of brevity (terseness?) in Swift:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb3-1" data-line-number="1">extension List {</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  public func map&lt;T&gt;(@noescape transform: Element -&gt; T) -&gt; List&lt;T&gt; {</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">    switch self {</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">    <span class="kw">case</span> .<span class="fu">Nil</span>: <span class="kw">return</span> .<span class="fu">Nil</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">    <span class="kw">case</span> let .<span class="fu">Cons</span>(head, tail): <span class="kw">return</span></a>
<a class="sourceLine" id="cb3-6" data-line-number="6">      .<span class="fu">Cons</span>(head: <span class="fu">transform</span>(head), tail: tail.<span class="fu">map</span>(transform))</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">    }</a>
<a class="sourceLine" id="cb3-8" data-line-number="8">  }</a>
<a class="sourceLine" id="cb3-9" data-line-number="9">}</a></code></pre></div>
<p>We can define our own ‚Äúcons‚Äù, to clean it up a little. We‚Äôre not allowed to use <code class="sourceCode scala">:</code>, so I went with <code class="sourceCode scala">|&gt;</code>, which is, in my mind, reasonably representative of ‚Äúcons‚Äù.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb4-1" data-line-number="1">infix operator |&gt; {</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  associativity right</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  precedence <span class="dv">100</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">}</a>
<a class="sourceLine" id="cb4-5" data-line-number="5"></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">public func |&gt; &lt;T&gt;(lhs: T, rhs: List&lt;T&gt;) -&gt; List&lt;T&gt; {</a>
<a class="sourceLine" id="cb4-7" data-line-number="7">  <span class="kw">return</span> .<span class="fu">Cons</span>(head: lhs, tail: rhs)</a>
<a class="sourceLine" id="cb4-8" data-line-number="8">}</a>
<a class="sourceLine" id="cb4-9" data-line-number="9"></a>
<a class="sourceLine" id="cb4-10" data-line-number="10">extension List {</a>
<a class="sourceLine" id="cb4-11" data-line-number="11">  public func map&lt;T&gt;(@noescape transform: Element -&gt; T) -&gt; List&lt;T&gt; {</a>
<a class="sourceLine" id="cb4-12" data-line-number="12">    switch self {</a>
<a class="sourceLine" id="cb4-13" data-line-number="13">    <span class="kw">case</span> .<span class="fu">Nil</span>: <span class="kw">return</span> .<span class="fu">Nil</span></a>
<a class="sourceLine" id="cb4-14" data-line-number="14">    <span class="kw">case</span> let .<span class="fu">Cons</span>(head, tail):</a>
<a class="sourceLine" id="cb4-15" data-line-number="15">      <span class="kw">return</span> <span class="fu">transform</span>(head) |&gt; tail.<span class="fu">map</span>(transform)</a>
<a class="sourceLine" id="cb4-16" data-line-number="16">    }</a>
<a class="sourceLine" id="cb4-17" data-line-number="17">  }</a>
<a class="sourceLine" id="cb4-18" data-line-number="18">}</a></code></pre></div>
<p>Pretty soon you can start doing some elegant and exciting things with lists. The recursive pattern is <em>very</em> well suited to higher-order functions and other FP staples. Take, for instance, the <code class="sourceCode scala">reduce</code> function:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb5-1" data-line-number="1">extension List {</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">  public func reduce&lt;T&gt;(initial: T, @noescape combine: (T, Element) -&gt; T) -&gt; T {</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">    switch self {</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">    <span class="kw">case</span> .<span class="fu">Nil</span>: <span class="kw">return</span> initial</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">    <span class="kw">case</span> let .<span class="fu">Cons</span>(h, t):</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">      <span class="kw">return</span> t.<span class="fu">reduce</span>(<span class="fu">combine</span>(initial, h), combine: combine)</a>
<a class="sourceLine" id="cb5-7" data-line-number="7">    }</a>
<a class="sourceLine" id="cb5-8" data-line-number="8">  }</a>
<a class="sourceLine" id="cb5-9" data-line-number="9">}</a></code></pre></div>
<p>Or a transposing function:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb6-1" data-line-number="1">func transpose&lt;T&gt;(mat: List&lt;List&lt;T&gt;&gt;) -&gt; List&lt;List&lt;T&gt;&gt; {</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  switch mat {</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  <span class="kw">case</span> let .<span class="fu">Cons</span>(x, xs) where x.<span class="fu">isEmpty</span>: <span class="kw">return</span> <span class="fu">transpose</span>(xs)</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">  <span class="kw">case</span> let .<span class="fu">Cons</span>(.<span class="fu">Cons</span>(x, xs), xss):</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">    <span class="kw">return</span> (x |&gt; xss.<span class="fu">flatMap</span>{$<span class="fl">0.f</span>irst}) |&gt;</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">      <span class="fu">transpose</span>(xs |&gt; xss.<span class="fu">map</span>{$<span class="fl">0.</span>tail})</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">  default: <span class="kw">return</span> .<span class="fu">Nil</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">  }</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">}</a>
<a class="sourceLine" id="cb6-10" data-line-number="10"></a>
<a class="sourceLine" id="cb6-11" data-line-number="11">let jo: List&lt;List&lt;Int&gt;&gt; = [[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>], [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>], [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]]</a>
<a class="sourceLine" id="cb6-12" data-line-number="12"><span class="fu">transpose</span>(jo) <span class="co">// [[1, 1, 1], [2, 2, 2], [3, 3, 3]]</span></a></code></pre></div>
<p>You can do <code class="sourceCode scala">foldr</code>, which is like <code class="sourceCode scala">reduce</code>, but works in reverse:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb7-1" data-line-number="1">extension List {</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  func foldr&lt;T&gt;(initial: T, @noescape combine: (element: Element, accumulator: T) -&gt; T) -&gt; T {</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">    switch self {</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">    <span class="kw">case</span> .<span class="fu">Nil</span>: <span class="kw">return</span> initial</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">    <span class="kw">case</span> let .<span class="fu">Cons</span>(x, xs):</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">      <span class="kw">return</span> <span class="fu">combine</span>(</a>
<a class="sourceLine" id="cb7-7" data-line-number="7">        element: x,</a>
<a class="sourceLine" id="cb7-8" data-line-number="8">        accumulator: xs.<span class="fu">foldr</span>(initial, combine: combine)</a>
<a class="sourceLine" id="cb7-9" data-line-number="9">      )</a>
<a class="sourceLine" id="cb7-10" data-line-number="10">    }</a>
<a class="sourceLine" id="cb7-11" data-line-number="11">  }</a>
<a class="sourceLine" id="cb7-12" data-line-number="12">}</a></code></pre></div>
<p>Using <code class="sourceCode scala">foldr</code>, you can get all of the non-empty subsequences of a list:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb8-1" data-line-number="1">extension List {</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  <span class="kw">var</span> subsequences: List&lt;List&lt;Element&gt;&gt; {</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">    switch self {</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">    <span class="kw">case</span> .<span class="fu">Nil</span>: <span class="kw">return</span> .<span class="fu">Nil</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5">    <span class="kw">case</span> let .<span class="fu">Cons</span>(x, xs):</a>
<a class="sourceLine" id="cb8-6" data-line-number="6">      <span class="kw">return</span> [x] |&gt; xs.<span class="fu">subsequences</span>.<span class="fu">foldr</span>([]) {</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">        (ys, r) in ys |&gt; (x |&gt; ys) |&gt; r</a>
<a class="sourceLine" id="cb8-8" data-line-number="8">      }</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">    }</a>
<a class="sourceLine" id="cb8-10" data-line-number="10">  }</a>
<a class="sourceLine" id="cb8-11" data-line-number="11">}</a>
<a class="sourceLine" id="cb8-12" data-line-number="12">let jo: List = [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]</a>
<a class="sourceLine" id="cb8-13" data-line-number="13">jo.<span class="fu">subsequences</span> <span class="co">// [[1], [2], [1, 2], [1, 3], [2, 3], [1, 2, 3]]</span></a></code></pre></div>
<p>(these examples are all translated from the Haskell standard library) Lists are extremely fun, and some functions you would have found yourself writing on 10-15 lines can be got into 2-3. To get a better feel for playing around with lists, it‚Äôs useful to have them conform to some protocols that make them easier to work with in a playground.</p>
<p>For instance, making a list currently looks like this:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb9-1" data-line-number="1">let jo: List = <span class="dv">1</span> |&gt; <span class="dv">2</span> |&gt; <span class="dv">3</span> |&gt; .<span class="fu">Nil</span></a></code></pre></div>
<p>Which is fine, and better than:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb10-1" data-line-number="1">let jo: List = .<span class="fu">Cons</span>(head: <span class="dv">1</span>, tail: .<span class="fu">Cons</span>(head: <span class="dv">2</span>, tail: .<span class="fu">Cons</span>(head: <span class="dv">3</span>, tail: .<span class="fu">Nil</span>)))</a></code></pre></div>
<p>but still not fantastic. The obvious next step is making <code class="sourceCode scala">List</code> <code class="sourceCode scala">ArrayLiteralConvertible</code>, but there‚Äôs a small catch. We don‚Äôt have an <code class="sourceCode scala">append</code> function for lists (yet). So we can‚Äôt, off the bat, do something like this:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb11-1" data-line-number="1">extension List : ArrayLiteralConvertible {</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">  public <span class="fu">init</span>(arrayLiteral: Element...) {</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">    <span class="kw">var</span> ret: List&lt;Element&gt; = .<span class="fu">Nil</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4">    <span class="kw">for</span> el in arrayLiteral { ret.<span class="fu">append</span>(el) }</a>
<a class="sourceLine" id="cb11-5" data-line-number="5">    self = ret</a>
<a class="sourceLine" id="cb11-6" data-line-number="6">  }</a>
<a class="sourceLine" id="cb11-7" data-line-number="7">}</a></code></pre></div>
<p>And nor do I think we‚Äôd want to. Operations on the end of lists are slow: you have to walk along the entire list every time.</p>
<p>We could <em>reverse</em> the sequence we want to turn into a list, and prepend as we go. But‚Ä¶ that‚Äôs inefficient too. Sure, <code class="sourceCode scala">Array</code>s are fast to reverse, but other sequences aren‚Äôt. For those that can‚Äôt be reversed lazily, you‚Äôre storing an extra sequence in memory unnecessarily.</p>
<p>But there‚Äôs something that we can use: generators. In Swift, generators are like super-imperative, crazy-unsafe recursive lists. When you can the <code class="sourceCode scala"><span class="fu">next</span>()</code> method on a generator, you get the ‚Äúhead‚Äù back. Crucially, though: <em>the generator is left with the tail</em>. Making use of this fact too often will lead to bugs, but if we wrap it up in <code class="sourceCode scala"><span class="kw">private</span></code>, it‚Äôs a perfect fit:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb12-1" data-line-number="1">extension List {</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">  <span class="kw">private</span> init&lt;G : GeneratorType where G.<span class="fu">Element</span> == Element&gt;(<span class="kw">var</span> gen: G) {</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">    <span class="kw">if</span> let head = gen.<span class="fu">next</span>() {</a>
<a class="sourceLine" id="cb12-4" data-line-number="4">      self = head |&gt; List(gen: gen)</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">    } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb12-6" data-line-number="6">      self = .<span class="fu">Nil</span></a>
<a class="sourceLine" id="cb12-7" data-line-number="7">    }</a>
<a class="sourceLine" id="cb12-8" data-line-number="8">  }</a>
<a class="sourceLine" id="cb12-9" data-line-number="9">}</a></code></pre></div>
<p>The potential bug here is kind of interesting. If, instead of an infix operator for cons, we‚Äôd had a method on <code class="sourceCode scala">List</code> that did the same thing:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb13-1" data-line-number="1">extension List {</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">  public func <span class="fu">prepended</span>(<span class="kw">with</span>: Element) -&gt; List&lt;Element&gt; {</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">    <span class="kw">return</span> .<span class="fu">Cons</span>(head: <span class="kw">with</span>, tail: self)</a>
<a class="sourceLine" id="cb13-4" data-line-number="4">  }</a>
<a class="sourceLine" id="cb13-5" data-line-number="5">}</a></code></pre></div>
<p>We‚Äôd be able to curry that function in a <code class="sourceCode scala"><span class="fu">map</span>()</code>, and get an <code class="sourceCode scala">init</code> function that‚Äôs very pretty:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb14-1" data-line-number="1">extension List {</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">  <span class="kw">private</span> init&lt;G : GeneratorType where G.<span class="fu">Element</span> == Element&gt;(<span class="kw">var</span> g: G) {</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">    self = g.<span class="fu">next</span>().<span class="fu">map</span>(List(g: g).<span class="fu">prepended</span>) ?? .<span class="fu">Nil</span></a>
<a class="sourceLine" id="cb14-4" data-line-number="4">  }</a>
<a class="sourceLine" id="cb14-5" data-line-number="5">}</a></code></pre></div>
<p>But it won‚Äôt run. Since the recursive call to the function is curried, it‚Äôs resolved before the <code class="sourceCode scala">g.<span class="fu">next</span>()</code> part. Which means that, regardless of whether <code class="sourceCode scala">g</code> returns <code class="sourceCode scala">nil</code> or not, the call will be made, causing an infinite loop of sadness. To fix it, you have to make the order of operations clear: <em>do not</em> make a recursive call if <code class="sourceCode scala">g.<span class="fu">next</span>()</code> returns <code class="sourceCode scala">nil</code>.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb15-1" data-line-number="1">extension List {</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">  <span class="kw">private</span> init&lt;G : GeneratorType where G.<span class="fu">Element</span> == Element&gt;(<span class="kw">var</span> gen: G) {</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">    <span class="kw">if</span> let head = gen.<span class="fu">next</span>() {</a>
<a class="sourceLine" id="cb15-4" data-line-number="4">      self = head |&gt; List(gen: gen)</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">    } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb15-6" data-line-number="6">      self = .<span class="fu">Nil</span></a>
<a class="sourceLine" id="cb15-7" data-line-number="7">    }</a>
<a class="sourceLine" id="cb15-8" data-line-number="8">  }</a>
<a class="sourceLine" id="cb15-9" data-line-number="9">  public init&lt;S : SequenceType where S.<span class="fu">Generator</span>.<span class="fu">Element</span> == Element&gt;(_ seq: S) {</a>
<a class="sourceLine" id="cb15-10" data-line-number="10">    self = List(gen: seq.<span class="fu">generate</span>())</a>
<a class="sourceLine" id="cb15-11" data-line-number="11">  }</a>
<a class="sourceLine" id="cb15-12" data-line-number="12">}</a>
<a class="sourceLine" id="cb15-13" data-line-number="13"></a>
<a class="sourceLine" id="cb15-14" data-line-number="14">extension List : ArrayLiteralConvertible {</a>
<a class="sourceLine" id="cb15-15" data-line-number="15">  public <span class="fu">init</span>(arrayLiteral: Element...) {</a>
<a class="sourceLine" id="cb15-16" data-line-number="16">    self = List(arrayLiteral.<span class="fu">generate</span>())</a>
<a class="sourceLine" id="cb15-17" data-line-number="17">  }</a>
<a class="sourceLine" id="cb15-18" data-line-number="18">}</a></code></pre></div>
<p>This all makes it easy to initialise a list. Being able to <em>see</em> the list and its contents is also important. Currently, we‚Äôve got this mess:</p>
<p><img class="aligncenter size-full wp-image-404" src="https://bigonotetaking.files.wordpress.com/2015/07/screen-shot-2015-07-29-at-12-12-56.png" alt="Screen Shot 2015-07-29 at 12.12.56" width="660" height="39" /></p>
<p>When what we really want is a comma-separated list of the contents. We also probably want some demarcation at either end, so it‚Äôs easier to recognise nested lists. I‚Äôm not sure what the best demarcation would be: ideally it should be different to an Array‚Äôs square brackets, but not confusing either. I went with <code class="sourceCode scala">[:</code> and <code class="sourceCode scala">:]</code> in the end, though I‚Äôm not terribly happy about it:</p>
<p><img class="aligncenter size-full wp-image-406" src="https://bigonotetaking.files.wordpress.com/2015/07/screen-shot-2015-07-29-at-12-27-53.png" alt="Screen Shot 2015-07-29 at 12.27.53" width="522" height="32" /></p>
<p>To get that printout on the right-hand-side of your playground, you need to make your type¬†<code class="sourceCode scala">CustomDebugStringConvertible</code>. There‚Äôs one one interesting problem with this: how do you know the contents of your list are printable? You can‚Äôt extend your struct to have conditional conformance, like this:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb16-1" data-line-number="1">extension List (where Element : CustomDebugStringConvertible) : CustomDebugStringConvertible {...</a></code></pre></div>
<p>However, you can‚Äôt just get a string representation of something that doesn‚Äôt have one. Luckily, <code class="sourceCode scala">String</code> has an initialiser that takes <em>anything</em>. It uses runtime reflection to do so. Here‚Äôs what the extension ends up looking like:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb17-1" data-line-number="1">extension List : CustomDebugStringConvertible {</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">  public <span class="kw">var</span> debugDescription: String {</a>
<a class="sourceLine" id="cb17-3" data-line-number="3">    return<span class="st">&quot;[:&quot;</span> + <span class="st">&quot;, &quot;</span>.<span class="fu">join</span>(map{String(reflecting: $<span class="dv">0</span>)}) + <span class="st">&quot;:]&quot;</span></a>
<a class="sourceLine" id="cb17-4" data-line-number="4">  }</a>
<a class="sourceLine" id="cb17-5" data-line-number="5">}</a></code></pre></div>
<p>To use the <code class="sourceCode scala"><span class="fu">join</span>()</code> function, of course, <code class="sourceCode scala">List</code> needs to conform to <code class="sourceCode scala">SequenceType</code>. We‚Äôll need some generator that swaps out the current <code class="sourceCode scala">List</code> struct on each iteration, and returns the head. You <em>could</em> just use <code class="sourceCode scala">anyGenerator</code> but, since it‚Äôs a class, it‚Äôs significantly slower than defining a new struct.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb18-1" data-line-number="1">public struct ListGenerator&lt;Element&gt; : GeneratorType, SequenceType {</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">  <span class="kw">private</span> <span class="kw">var</span> list: List&lt;Element&gt;</a>
<a class="sourceLine" id="cb18-3" data-line-number="3">  public mutating func <span class="fu">next</span>() -&gt; Element? {</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">    switch list {</a>
<a class="sourceLine" id="cb18-5" data-line-number="5">    <span class="kw">case</span> .<span class="fu">Nil</span>: <span class="kw">return</span> nil</a>
<a class="sourceLine" id="cb18-6" data-line-number="6">    <span class="kw">case</span> let .<span class="fu">Cons</span>(head, tail):</a>
<a class="sourceLine" id="cb18-7" data-line-number="7">      list = tail</a>
<a class="sourceLine" id="cb18-8" data-line-number="8">      <span class="kw">return</span> head</a>
<a class="sourceLine" id="cb18-9" data-line-number="9">    }</a>
<a class="sourceLine" id="cb18-10" data-line-number="10">  }</a>
<a class="sourceLine" id="cb18-11" data-line-number="11">  public func <span class="fu">generate</span>() -&gt; ListGenerator { <span class="kw">return</span> self }</a>
<a class="sourceLine" id="cb18-12" data-line-number="12">}</a>
<a class="sourceLine" id="cb18-13" data-line-number="13"></a>
<a class="sourceLine" id="cb18-14" data-line-number="14">extension List : SequenceType {</a>
<a class="sourceLine" id="cb18-15" data-line-number="15">  public func <span class="fu">generate</span>() -&gt; ListGenerator&lt;Element&gt; {</a>
<a class="sourceLine" id="cb18-16" data-line-number="16">    <span class="kw">return</span> <span class="fu">ListGenerator</span>(list: self)</a>
<a class="sourceLine" id="cb18-17" data-line-number="17">  }</a>
<a class="sourceLine" id="cb18-18" data-line-number="18">}</a></code></pre></div>
<p>And you‚Äôve got a <code class="sourceCode scala">SequenceType</code> that‚Äôs normal-looking and easy to work with.</p>
<h3 id="laziness">Laziness</h3>
<p>I‚Äôm not sure if this is entirely relevant here, but I <em>do</em> like laziness, so I thought I‚Äôd make a version of <code class="sourceCode scala">List</code> that was lazy. It turns out it‚Äôs easy to do: in fact, it was possible before <code class="sourceCode scala">indirect</code> enums. So, starting with the standard <code class="sourceCode scala">List</code> definition:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb19-1" data-line-number="1">public enum LazyList&lt;Element&gt; {</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">  <span class="kw">case</span> Nil</a>
<a class="sourceLine" id="cb19-3" data-line-number="3">  indirect <span class="kw">case</span> <span class="fu">Cons</span>(head: Element, tail: LazyList&lt;Element&gt;)</a>
<a class="sourceLine" id="cb19-4" data-line-number="4">}</a></code></pre></div>
<p>Let‚Äôs make it lazy. The main idea would be to defer the resolution of <code class="sourceCode scala">tail</code>. What we really want is for tail to be a function that <em>returns</em> a list, rather than a list itself.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb20-1" data-line-number="1">public enum LazyList&lt;Element&gt; {</a>
<a class="sourceLine" id="cb20-2" data-line-number="2">  <span class="kw">case</span> Nil</a>
<a class="sourceLine" id="cb20-3" data-line-number="3">  <span class="kw">case</span> <span class="fu">Cons</span>(head: Element, tail: () -&gt; LazyList&lt;Element&gt;)</a>
<a class="sourceLine" id="cb20-4" data-line-number="4">}</a></code></pre></div>
<p>This is the reason that <code class="sourceCode scala">indirect</code> isn‚Äôt needed: because tail isn‚Äôt a list, all that‚Äôs stored in the enum is the reference to the function. This is what <code class="sourceCode scala">indirect</code> does automatically, or what the <code class="sourceCode scala">Box</code> struct did manually.</p>
<p>There are some more wrinkles with laziness. For instance, our old infix operator won‚Äôt work:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb21-1" data-line-number="1">public func |&gt; &lt;T&gt;(lhs: T, rhs: LazyList&lt;T&gt;) -&gt; LazyList&lt;T&gt; {</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">  <span class="kw">return</span> .<span class="fu">Cons</span>(head: lhs, tail: rhs)</a>
<a class="sourceLine" id="cb21-3" data-line-number="3">}</a></code></pre></div>
<p>Again, because tail is meant to be a function that returns a list, not a list itself. This <em>would</em> work, but not in the way we intend it:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb22-1" data-line-number="1">public func |&gt; &lt;T&gt;(lhs: T, rhs: LazyList&lt;T&gt;) -&gt; LazyList&lt;T&gt; {</a>
<a class="sourceLine" id="cb22-2" data-line-number="2">  <span class="kw">return</span> .<span class="fu">Cons</span>(head: lhs, tail: {rhs})</a>
<a class="sourceLine" id="cb22-3" data-line-number="3">}</a></code></pre></div>
<p>Whatever‚Äôs to the right-hand-side of the operator will get resolved, and <em>then</em> put into the closure, which we don‚Äôt want. For instance, this:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb23-1" data-line-number="1">func <span class="fu">printAndGiveList</span>() -&gt; LazyList&lt;Int&gt; {</a>
<a class="sourceLine" id="cb23-2" data-line-number="2">  <span class="fu">print</span>(<span class="dv">2</span>)</a>
<a class="sourceLine" id="cb23-3" data-line-number="3">  <span class="kw">return</span> .<span class="fu">Nil</span></a>
<a class="sourceLine" id="cb23-4" data-line-number="4">}</a>
<a class="sourceLine" id="cb23-5" data-line-number="5"></a>
<a class="sourceLine" id="cb23-6" data-line-number="6"><span class="dv">2</span> |&gt; <span class="dv">1</span> |&gt; <span class="fu">printAndGiveList</span>()</a></code></pre></div>
<p>Will give you a ‚Äú<code class="sourceCode scala">LazyList</code>‚Äù, but 2 gets printed, meaning that it‚Äôs not <em>really</em> behaving lazily.</p>
<p><code class="sourceCode scala">@autoclosure</code> to the rescue! This is a little annotation you put before your parameters that can let you decide when to evaluate the argument.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb24-1" data-line-number="1">public func |&gt; &lt;T&gt;(lhs: T, @<span class="fu">autoclosure</span>(escaping) rhs: () -&gt; LazyList&lt;T&gt;) -&gt; LazyList&lt;T&gt; {</a>
<a class="sourceLine" id="cb24-2" data-line-number="2">  <span class="kw">return</span> .<span class="fu">Cons</span>(head: lhs, tail: rhs)</a>
<a class="sourceLine" id="cb24-3" data-line-number="3">}</a></code></pre></div>
<p>The <code class="sourceCode scala">escaping</code> in the brackets is needed to signify that the closure will last longer than the lifetime of the scope it is declared in. If you test this new version with the <code class="sourceCode scala"><span class="fu">printAndGiveList</span>()</code> function, you‚Äôll see that 2 does <em>not</em> get printed. In fact, the behaviour of this operator lets us use a lot of the same code from the strict list, <em>without</em> the strictness. (The generator initialiser, for instance: the same code, if used to initialise a lazy list, will work. In fact, if the underlying sequence that the generator comes from is lazy, <em>that laziness is maintained in the lazy list</em>. That‚Äôs pretty cool.)</p>
<p>There‚Äôs an interesting point to be made, here. The usual definition for a lazy programming language is one in which functions do not evaluate their arguments until they need to. In contrast, eager languages evaluate function arguments before the body of the function. This kind of makes it seem that you could treat Swift as a totally lazy language‚Ä¶</p>
<p>At any rate, this new-and-improved operator works exactly as we want it. It‚Äôs properly lazy. The rest is easy: every time <code class="sourceCode scala">tail</code> was used in <code class="sourceCode scala">List</code>, replace it with <code class="sourceCode scala"><span class="fu">tail</span>()</code>.</p>
<h3 id="the-deque">The Deque</h3>
<p>Lists are useful. They let you operate on their first element in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math> time, which makes a lot of sense, since you often find yourself starting there.</p>
<p>They‚Äôve got some disadvantages, though: for one, to get to the nth element, you have to walk along n elements in the list. So while operations of the <em>start</em> are fast, operations on the end are painfully slow. And forget about efficient indexing.</p>
<p>This is where a Deque comes in. When you need to operate on two ends of a collection, a Deque is what you want to be using. Removal of the first and last element, prepending, and appending are all <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math>.</p>
<p>It‚Äôs made up of two lists: one for the front half, and one, in reverse, for the back half. With that information we‚Äôve enough to get a definition down:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb25-1" data-line-number="1">public struct Deque&lt;Element&gt; {</a>
<a class="sourceLine" id="cb25-2" data-line-number="2">  <span class="kw">private</span> <span class="kw">var</span> front, back: List&lt;Element&gt;</a>
<a class="sourceLine" id="cb25-3" data-line-number="3">}</a></code></pre></div>
<p>You‚Äôve got to do similar things that you did to the list to get an easy-to-work-with struct. <code class="sourceCode scala">CustomDebugStringConvertible</code>, <code class="sourceCode scala">ArrayLiteralConvertible</code>, etc. It‚Äôs not tremendously interesting, so here it is:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb26-1" data-line-number="1">extension Deque : CustomDebugStringConvertible {</a>
<a class="sourceLine" id="cb26-2" data-line-number="2">  public <span class="kw">var</span> debugDescription: String {</a>
<a class="sourceLine" id="cb26-3" data-line-number="3">    <span class="kw">return</span></a>
<a class="sourceLine" id="cb26-4" data-line-number="4">      <span class="st">&quot;, &quot;</span>.<span class="fu">join</span>(front.<span class="fu">map</span>{String(reflecting: $<span class="dv">0</span>)}) +</a>
<a class="sourceLine" id="cb26-5" data-line-number="5">      <span class="st">&quot; | &quot;</span> +</a>
<a class="sourceLine" id="cb26-6" data-line-number="6">      <span class="st">&quot;, &quot;</span>.<span class="fu">join</span>(back.<span class="fu">reverse</span>().<span class="fu">map</span>{String(reflecting: $<span class="dv">0</span>)})</a>
<a class="sourceLine" id="cb26-7" data-line-number="7">  }</a>
<a class="sourceLine" id="cb26-8" data-line-number="8">}</a>
<a class="sourceLine" id="cb26-9" data-line-number="9"></a>
<a class="sourceLine" id="cb26-10" data-line-number="10">extension Deque {</a>
<a class="sourceLine" id="cb26-11" data-line-number="11">  public <span class="fu">init</span>(array: [Element]) {</a>
<a class="sourceLine" id="cb26-12" data-line-number="12">    let half = array.<span class="fu">endIndex</span> / <span class="dv">2</span></a>
<a class="sourceLine" id="cb26-13" data-line-number="13">    front = List(array[<span class="dv">0</span>..&lt;half])</a>
<a class="sourceLine" id="cb26-14" data-line-number="14">    back = List(array[half..&lt;array.<span class="fu">endIndex</span>].<span class="fu">reverse</span>())</a>
<a class="sourceLine" id="cb26-15" data-line-number="15">  }</a>
<a class="sourceLine" id="cb26-16" data-line-number="16">}</a>
<a class="sourceLine" id="cb26-17" data-line-number="17"></a>
<a class="sourceLine" id="cb26-18" data-line-number="18">extension Deque : ArrayLiteralConvertible {</a>
<a class="sourceLine" id="cb26-19" data-line-number="19">  public <span class="fu">init</span>(arrayLiteral: Element...) {</a>
<a class="sourceLine" id="cb26-20" data-line-number="20">    self.<span class="fu">init</span>(array: arrayLiteral)</a>
<a class="sourceLine" id="cb26-21" data-line-number="21">  }</a>
<a class="sourceLine" id="cb26-22" data-line-number="22">}</a>
<a class="sourceLine" id="cb26-23" data-line-number="23"></a>
<a class="sourceLine" id="cb26-24" data-line-number="24">extension Deque {</a>
<a class="sourceLine" id="cb26-25" data-line-number="25">  public init&lt;S : SequenceType where S.<span class="fu">Generator</span>.<span class="fu">Element</span> == Element&gt;(_ seq: S) {</a>
<a class="sourceLine" id="cb26-26" data-line-number="26">    self.<span class="fu">init</span>(array: Array(seq))</a>
<a class="sourceLine" id="cb26-27" data-line-number="27">  }</a>
<a class="sourceLine" id="cb26-28" data-line-number="28">}</a></code></pre></div>
<p>The debug output puts a <code class="sourceCode scala">|</code> between the two lists:</p>
<p><img class="aligncenter size-full wp-image-395" src="https://bigonotetaking.files.wordpress.com/2015/07/screen-shot-2015-07-28-at-21-32-44.png" alt="Screen Shot 2015-07-28 at 21.32.44" width="660" height="29" /></p>
<p>This makes it clear how the performance characteristics come about: because the second half is a reversed list, all of the operations on the end of the Deque are operations on the beginning of a list. And that‚Äôs where lists are fast.</p>
<p>But there‚Äôs an obvious issue. Say we take that list, and start removing the first element from it:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb27-1" data-line-number="1">let a = an.<span class="fu">tail</span> <span class="co">// 2, 3 | 4, 5, 6</span></a>
<a class="sourceLine" id="cb27-2" data-line-number="2">let b = a.<span class="fu">tail</span>  <span class="co">// 3 | 4, 5, 6</span></a>
<a class="sourceLine" id="cb27-3" data-line-number="3">let c = b.<span class="fu">tail</span>  <span class="co">// | 4, 5, 6</span></a>
<a class="sourceLine" id="cb27-4" data-line-number="4">let d = c.<span class="fu">tail</span>  <span class="co">// ?????</span></a></code></pre></div>
<p>The front will end up being empty. The solution to this is the second important element to a Deque. It needs an invariant: if its number of elements is greater than one, neither the front list nor the back will be empty. When the invariant gets violated, it needs to fix it. We can check that the invariant has been upheld with a <code class="sourceCode scala">switch</code> statement:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb28-1" data-line-number="1">extension Deque {</a>
<a class="sourceLine" id="cb28-2" data-line-number="2">  <span class="kw">private</span> mutating func <span class="fu">check</span>() {</a>
<a class="sourceLine" id="cb28-3" data-line-number="3">    <span class="fu">switch</span> (front, back) {</a>
<a class="sourceLine" id="cb28-4" data-line-number="4">    <span class="kw">case</span> (.<span class="fu">Nil</span>, let .<span class="fu">Cons</span>(head, tail)) where !tail.<span class="fu">isEmpty</span>: <span class="fu">fix</span>()</a>
<a class="sourceLine" id="cb28-5" data-line-number="5">    <span class="kw">case</span> (let .<span class="fu">Cons</span>(head, tail), .<span class="fu">Nil</span>) where !tail.<span class="fu">isEmpty</span>: <span class="fu">fix</span>()</a>
<a class="sourceLine" id="cb28-6" data-line-number="6">    default:</a>
<a class="sourceLine" id="cb28-7" data-line-number="7">      <span class="kw">return</span></a>
<a class="sourceLine" id="cb28-8" data-line-number="8">    }</a>
<a class="sourceLine" id="cb28-9" data-line-number="9">  }</a>
<a class="sourceLine" id="cb28-10" data-line-number="10">}</a></code></pre></div>
<p>The first case is the front is empty, and the back has more than one element, and the second case is the back is empty, and the front has more than one element. To fix it, just chop off the tail of the non-empty list, reverse it, and assign it to the empty list:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb29-1" data-line-number="1">extension Deque {</a>
<a class="sourceLine" id="cb29-2" data-line-number="2">  <span class="kw">private</span> mutating func <span class="fu">check</span>() {</a>
<a class="sourceLine" id="cb29-3" data-line-number="3">    <span class="fu">switch</span> (front, back) {</a>
<a class="sourceLine" id="cb29-4" data-line-number="4">    <span class="kw">case</span> (.<span class="fu">Nil</span>, let .<span class="fu">Cons</span>(head, tail)) where !tail.<span class="fu">isEmpty</span>:</a>
<a class="sourceLine" id="cb29-5" data-line-number="5">      (front, back) = (tail.<span class="fu">reverse</span>(), [head])</a>
<a class="sourceLine" id="cb29-6" data-line-number="6">    <span class="kw">case</span> (let .<span class="fu">Cons</span>(head, tail), .<span class="fu">Nil</span>) where !tail.<span class="fu">isEmpty</span>:</a>
<a class="sourceLine" id="cb29-7" data-line-number="7">      (back, front) = (tail.<span class="fu">reverse</span>(), [head])</a>
<a class="sourceLine" id="cb29-8" data-line-number="8">    default:</a>
<a class="sourceLine" id="cb29-9" data-line-number="9">      <span class="kw">return</span></a>
<a class="sourceLine" id="cb29-10" data-line-number="10">    }</a>
<a class="sourceLine" id="cb29-11" data-line-number="11">  }</a>
<a class="sourceLine" id="cb29-12" data-line-number="12">}</a></code></pre></div>
<p>Now, wherever we have a mutating method that may cause a violation of the invariant, this <code class="sourceCode scala">check</code> is called. One particularly cool way to do this is by using <code class="sourceCode scala">didSet</code>:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb30-1" data-line-number="1">public struct Deque&lt;Element&gt; {</a>
<a class="sourceLine" id="cb30-2" data-line-number="2">  <span class="kw">private</span> <span class="kw">var</span> front: List&lt;Element&gt; { didSet { <span class="fu">check</span>() } }</a>
<a class="sourceLine" id="cb30-3" data-line-number="3">  <span class="kw">private</span> <span class="kw">var</span> back : List&lt;Element&gt; { didSet { <span class="fu">check</span>() } }</a>
<a class="sourceLine" id="cb30-4" data-line-number="4">}</a></code></pre></div>
<p>This will call <code class="sourceCode scala"><span class="fu">check</span>()</code> whenever either list is mutated, ensuring you can‚Äôt forget. If a <em>new</em> Deque is initialised, though, it won‚Äôt be called. I don‚Äôt trust myself to remember the <code class="sourceCode scala"><span class="fu">check</span>()</code> on every init, so we can put it into the initialiser:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb31-1" data-line-number="1">  <span class="kw">private</span> <span class="fu">init</span>(_ front: List&lt;Element&gt;, _ back: List&lt;Element&gt;) {</a>
<a class="sourceLine" id="cb31-2" data-line-number="2">    (self.<span class="fu">front</span>, self.<span class="fu">back</span>) = (front, back)</a>
<a class="sourceLine" id="cb31-3" data-line-number="3">    <span class="fu">check</span>()</a>
<a class="sourceLine" id="cb31-4" data-line-number="4">  }</a></code></pre></div>
<p>This is the only initialiser so far, so it‚Äôs the only one I‚Äôm allowed to call. However, there may be some cases where I <em>know</em> that the front and back are balanced. So I want a separate initialiser for those, for efficiency‚Äôs sake. But it‚Äôs got to be called <code class="sourceCode scala">init</code> no matter what, so how can I specify that I want to use the non-checking initialiser, over the checking one? I could have a function called something like <code class="sourceCode scala">initialiseFromBalanced</code> that returns a Deque, but I don‚Äôt like that. You could¬†use labelled arguments. <a href="http://ericasadun.com/2015/06/01/swift-safe-array-indexing-my-favorite-thing-of-the-new-week/">Erica Sadun has a cool post on using them with subscripts</a>, and here‚Äôs what it would look like with <code class="sourceCode scala">init</code>:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb32-1" data-line-number="1">extension Deque {</a>
<a class="sourceLine" id="cb32-2" data-line-number="2">  <span class="kw">private</span> <span class="fu">init</span>(balancedFront: List&lt;Element&gt;, balancedBack: List&lt;Element&gt;) {</a>
<a class="sourceLine" id="cb32-3" data-line-number="3">    (front, back) = (balancedFront, balancedBack)</a>
<a class="sourceLine" id="cb32-4" data-line-number="4">  }</a>
<a class="sourceLine" id="cb32-5" data-line-number="5">}</a></code></pre></div>
<p>So now we have a default initialiser that automatically balances the Deque, and a specialised one that takes two lists already balanced.</p>
<p>There is an extra function on lists in the <code class="sourceCode scala"><span class="fu">check</span>()</code> function: <code class="sourceCode scala"><span class="fu">reverse</span>()</code>. There are a load of different ways to do it. If you‚Äôre in the mood for golf:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb33-1" data-line-number="1">let joanne: List = [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>]</a>
<a class="sourceLine" id="cb33-2" data-line-number="2">joanne.<span class="fu">reduce</span>(.<span class="fu">Nil</span>) { $<span class="dv">1</span> |&gt; $<span class="dv">0</span> } <span class="co">// 6, 5, 4, 3, 2, 1</span></a></code></pre></div>
<p>Or, if you‚Äôd like to keep it recursive:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb34-1" data-line-number="1">extension List {</a>
<a class="sourceLine" id="cb34-2" data-line-number="2">  <span class="kw">private</span> func <span class="fu">reverse</span>(other: List&lt;Element&gt;) -&gt; List&lt;Element&gt; {</a>
<a class="sourceLine" id="cb34-3" data-line-number="3">    switch self {</a>
<a class="sourceLine" id="cb34-4" data-line-number="4">    <span class="kw">case</span> .<span class="fu">Nil</span>: <span class="kw">return</span> other</a>
<a class="sourceLine" id="cb34-5" data-line-number="5">    <span class="kw">case</span> let .<span class="fu">Cons</span>(head, tail): <span class="kw">return</span> tail.<span class="fu">reverse</span>(head |&gt; other)</a>
<a class="sourceLine" id="cb34-6" data-line-number="6">    }</a>
<a class="sourceLine" id="cb34-7" data-line-number="7">  }</a>
<a class="sourceLine" id="cb34-8" data-line-number="8">  public func <span class="fu">reverse</span>() -&gt; List&lt;Element&gt; {</a>
<a class="sourceLine" id="cb34-9" data-line-number="9">    <span class="kw">return</span> <span class="fu">reverse</span>(.<span class="fu">Nil</span>)</a>
<a class="sourceLine" id="cb34-10" data-line-number="10">  }</a>
<a class="sourceLine" id="cb34-11" data-line-number="11">}</a></code></pre></div>
<p>Obviously, you want to avoid this operation as much as possible. We‚Äôll have to bear that in mind when we‚Äôre adding other functions.</p>
<p>So what kind of operations do we want on Deques? Well, <code class="sourceCode scala"><span class="fu">removeFirst</span>()</code> and <code class="sourceCode scala"><span class="fu">removeLast</span>()</code> would be a start:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb35-1" data-line-number="1">extension Deque {</a>
<a class="sourceLine" id="cb35-2" data-line-number="2">  public mutating func <span class="fu">removeFirst</span>() -&gt; Element {</a>
<a class="sourceLine" id="cb35-3" data-line-number="3">    <span class="kw">return</span> front.<span class="fu">removeFirst</span>()</a>
<a class="sourceLine" id="cb35-4" data-line-number="4">  }</a>
<a class="sourceLine" id="cb35-5" data-line-number="5">  public mutating func <span class="fu">removeLast</span>() -&gt; Element {</a>
<a class="sourceLine" id="cb35-6" data-line-number="6">    <span class="kw">return</span> back.<span class="fu">removeFirst</span>()</a>
<a class="sourceLine" id="cb35-7" data-line-number="7">  }</a>
<a class="sourceLine" id="cb35-8" data-line-number="8">}</a></code></pre></div>
<p>And the function on lists:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb36-1" data-line-number="1">extension List {</a>
<a class="sourceLine" id="cb36-2" data-line-number="2">  public mutating func <span class="fu">removeFirst</span>() -&gt; Element {</a>
<a class="sourceLine" id="cb36-3" data-line-number="3">    switch self {</a>
<a class="sourceLine" id="cb36-4" data-line-number="4">    <span class="kw">case</span> .<span class="fu">Nil</span>: <span class="fu">fatalError</span>(<span class="st">&quot;Cannot call removeFirst() on an empty list&quot;</span>)</a>
<a class="sourceLine" id="cb36-5" data-line-number="5">    <span class="kw">case</span> let .<span class="fu">Cons</span>(head, tail):</a>
<a class="sourceLine" id="cb36-6" data-line-number="6">      self = tail</a>
<a class="sourceLine" id="cb36-7" data-line-number="7">      <span class="kw">return</span> head</a>
<a class="sourceLine" id="cb36-8" data-line-number="8">    }</a>
<a class="sourceLine" id="cb36-9" data-line-number="9">  }</a>
<a class="sourceLine" id="cb36-10" data-line-number="10">}</a></code></pre></div>
<p>The other functions are easy enough to figure out: <code class="sourceCode scala"><span class="fu">dropFirst</span>()</code>, <code class="sourceCode scala"><span class="fu">dropLast</span>()</code>, etc. And, since it conforms to <code class="sourceCode scala">SequenceType</code>, it gets all of the sequence methods from the standard library, as well. However, those methods are designed for other kinds of sequences - <code class="sourceCode scala">Array</code>s, <code class="sourceCode scala">String.<span class="fu">CharacterView</span></code>s, etc. There are <em>much</em> more efficient ways to do most of them. <code class="sourceCode scala">reverse</code>, for instance, is just this:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb37-1" data-line-number="1">extension Deque {</a>
<a class="sourceLine" id="cb37-2" data-line-number="2">  public func <span class="fu">reverse</span>() -&gt; Deque&lt;Element&gt; {</a>
<a class="sourceLine" id="cb37-3" data-line-number="3">    <span class="kw">return</span> <span class="fu">Deque</span>(balancedFront: back, balancedBack: front)</a>
<a class="sourceLine" id="cb37-4" data-line-number="4">  }</a>
<a class="sourceLine" id="cb37-5" data-line-number="5">}</a></code></pre></div>
<p>(Since reverse can‚Äôt change the number of elements in either list, we can use the initialiser that takes a balanced front and back.) Other methods like <code class="sourceCode scala"><span class="fu">map</span>()</code>, <code class="sourceCode scala"><span class="fu">filter</span>()</code>, etc., will just give you back an array. If we wanted to keep the Deque, we‚Äôd have to convert it back, which involves reversing, which is expensive. So we should do our own methods for those:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb38-1" data-line-number="1">extension Deque {</a>
<a class="sourceLine" id="cb38-2" data-line-number="2">  public func map&lt;T&gt;(@noescape transform: Element -&gt; T) -&gt; Deque&lt;T&gt; {</a>
<a class="sourceLine" id="cb38-3" data-line-number="3">    <span class="kw">return</span> Deque&lt;T&gt;(</a>
<a class="sourceLine" id="cb38-4" data-line-number="4">      balancedFront: front.<span class="fu">map</span>(transform),</a>
<a class="sourceLine" id="cb38-5" data-line-number="5">      balancedBack : back .<span class="fu">map</span>(transform)</a>
<a class="sourceLine" id="cb38-6" data-line-number="6">    )</a>
<a class="sourceLine" id="cb38-7" data-line-number="7">  }</a>
<a class="sourceLine" id="cb38-8" data-line-number="8">}</a>
<a class="sourceLine" id="cb38-9" data-line-number="9"></a>
<a class="sourceLine" id="cb38-10" data-line-number="10">extension Deque {</a>
<a class="sourceLine" id="cb38-11" data-line-number="11">  public func <span class="fu">filter</span>(@noescape includeElement: Element -&gt; Bool) -&gt; Deque&lt;Element&gt; {</a>
<a class="sourceLine" id="cb38-12" data-line-number="12">    <span class="kw">return</span> <span class="fu">Deque</span>(front.<span class="fu">filter</span>(includeElement), back.<span class="fu">filter</span>(includeElement))</a>
<a class="sourceLine" id="cb38-13" data-line-number="13">  }</a>
<a class="sourceLine" id="cb38-14" data-line-number="14">}</a></code></pre></div>
<p><code class="sourceCode scala"><span class="fu">filter</span>()</code> changes the number of elements in each list, which could cause violation of the invariant. So we use the unlabelled initialiser, which automatically <code class="sourceCode scala"><span class="fu">check</span>()</code>s.</p>
<p>Notice that we don‚Äôt have to do any reversing here. This is a huge efficiency gain, but you‚Äôve got to bear in mind that we‚Äôre assuming the order of execution of the closures for <code class="sourceCode scala">filter</code> and <code class="sourceCode scala">map</code> don‚Äôt matter. This¬†isn‚Äôt always the case. Take this function, which is supposed to skip two elements of a sequence:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb39-1" data-line-number="1"><span class="kw">var</span> i = <span class="dv">0</span></a>
<a class="sourceLine" id="cb39-2" data-line-number="2">[Int](<span class="dv">1</span>...<span class="dv">10</span>).<span class="fu">filter</span> { _ in i++ % <span class="dv">3</span> == <span class="dv">0</span> } <span class="co">// [1, 4, 7, 10]</span></a></code></pre></div>
<p>It won‚Äôt work for a Deque:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb40-1" data-line-number="1"><span class="fu">Deque</span>(<span class="dv">1</span>...<span class="dv">10</span>).<span class="fu">filter</span> { _ in i++ % <span class="dv">3</span> == <span class="dv">0</span> } <span class="co">// 1, 4 | 6, 9</span></a></code></pre></div>
<p>There‚Äôs been talk of a <code class="sourceCode scala">@pure</code> attribute. The idea is this: put it before your function or closure name, and the compiler will verify that it has no side effects. It can only use its arguments as variables, or call other <code class="sourceCode scala">@pure</code> functions. It would be very useful here, as it wouldn‚Äôt allow the <code class="sourceCode scala">i</code> to be used by <code class="sourceCode scala">filter</code>. Without it, you‚Äôll probably just have to mention in the docs that the order of execution is not knowable.</p>
<p>For completeness‚Äô sake, there are also <code class="sourceCode scala"><span class="fu">flatMap</span>()</code>s for the Deque, implemented in a similar fashion to the functions above:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb41-1" data-line-number="1">extension Deque {</a>
<a class="sourceLine" id="cb41-2" data-line-number="2">  public func flatMap&lt;T&gt;(@noescape transform: Element -&gt; Deque&lt;T&gt;) -&gt; Deque&lt;T&gt; {</a>
<a class="sourceLine" id="cb41-3" data-line-number="3">    <span class="kw">return</span> Deque&lt;T&gt;(</a>
<a class="sourceLine" id="cb41-4" data-line-number="4">      front.<span class="fu">flatMap</span>{List(<span class="fu">transform</span>($<span class="dv">0</span>))},</a>
<a class="sourceLine" id="cb41-5" data-line-number="5">      back .<span class="fu">flatMap</span>{List(<span class="fu">transform</span>($<span class="dv">0</span>).<span class="fu">reverse</span>())}</a>
<a class="sourceLine" id="cb41-6" data-line-number="6">    )</a>
<a class="sourceLine" id="cb41-7" data-line-number="7">  }</a>
<a class="sourceLine" id="cb41-8" data-line-number="8"></a>
<a class="sourceLine" id="cb41-9" data-line-number="9">  public func flatMap&lt;T&gt;(@noescape transform: Element -&gt; T?) -&gt; Deque&lt;T&gt; {</a>
<a class="sourceLine" id="cb41-10" data-line-number="10">    <span class="kw">return</span> Deque&lt;T&gt;(</a>
<a class="sourceLine" id="cb41-11" data-line-number="11">      front.<span class="fu">flatMap</span>(transform),</a>
<a class="sourceLine" id="cb41-12" data-line-number="12">      back .<span class="fu">flatMap</span>(transform)</a>
<a class="sourceLine" id="cb41-13" data-line-number="13">    )</a>
<a class="sourceLine" id="cb41-14" data-line-number="14">  }</a>
<a class="sourceLine" id="cb41-15" data-line-number="15">}</a></code></pre></div>
<p>All of this code is available as a playground, <a href="https://github.com/oisdk/Deques-Queues-and-Lists-in-Swift-with-indirect">here</a>. These two structs are also implemented a little more fully in <a href="https://github.com/oisdk/SwiftSequence">SwiftSequence</a>.</p>
<p>Since the only real constitutive part of the Deque is a list, it‚Äôs probably possible to implement it lazily, by just substituting in <code class="sourceCode scala">LazyList</code>s. Or, if you were feeling adventurous, you could have one of the lists lazy, and one strict. This isn‚Äôt as crazy as it sounds: <code class="sourceCode scala"><span class="fu">reverse</span>()</code> can <em>only</em> be performed eagerly, since the entire list needs to be walked to get to the last element. So the front and back lists have different functions (slightly). Also, because of the lazy initialisation of <code class="sourceCode scala">LazyList</code>, swapping between lazy and strict needn‚Äôt be very expensive. I‚Äôll leave it up to someone else to try, though.</p>
]]></description>
    <pubDate>Wed, 29 Jul 2015 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2015-07-29-swift-queues.html</guid>
    <dc:creator>Donnacha Ois√≠n Kidney</dc:creator>
</item>
<item>
    <title>A Strategy for Swift Protocols</title>
    <link>https://doisinkidney.com/posts/2015-07-17-swift-protocols-a-strategy.html</link>
    <description><![CDATA[<div class="info">
    Posted on July 17, 2015
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Swift.html">Swift</a>
    
</div>

<h3 id="a-misguided-over-simplified-strategy">A Misguided, Over-Simplified Strategy</h3>
<h1 id="it-makes-sense-to-me-so">It Makes Sense to Me, so‚Ä¶</h1>
<p>So I‚Äôve been drinking the Protocol-Oriented-Programming gatorade for a while now. I‚Äôve taken it to the extreme a little: you won‚Äôt find a class in pretty much any of my code these days. So, before I pull it back a little, I thought I‚Äôd put down my strategy so far for how to handle these protocol things.</p>
<p>To give you an idea of where I‚Äôm coming from: I never really understood object-oriented programming. It never clicked with me. I mean, I know the basic ideas, but they were never internalised. On the other hand, functional programming¬†was a breeze (by comparison). I should be clear: by FP I don‚Äôt really mean¬†monads or functors or applicative functors and monoids and commands and arrows and lenses and flux capacitors. I think everyone has a relatively difficult time wrapping their heads around that stuff.</p>
<p>I mean the¬†<em>patterns</em> you see in FP. Pure functions - of course - but other things, also. Things that aren‚Äôt strictly FP, but just tend to be found among the FP: type classes, currying, immutability, declarative-ness, laziness, higher-order functions. Contrast that to the patterns you find in OOP: the delegate pattern, class inheritance, single-dependancy whatnot (I can‚Äôt even name them because I‚Äôm sure I‚Äôm mixing up and misunderstanding them).</p>
<p>Now, there are probably good reasons why I understand FP a little easier than OOP (or I think I do). OOP was what I saw first: when I began coding, it was in OOP. By the time I tried to understand, say, higher-order functions, I had already gotten my head around functions, types, variables, etc. Whereas when I first read ‚ÄúPython is an¬†<em>object-oriented</em> programming language‚Äù, I had written my first hello world a few weeks before.</p>
<p>On top of that, I‚Äôm a hobbyist - I don‚Äôt like making things that really work, because that‚Äôs annoying. I am¬†<em>very good</em> at finding you Fibonacci numbers. I don‚Äôt need to know about state, or IO, so I‚Äôm perfectly fine in the clean, pleasant world of FP (or semi-FP).</p>
<p>So what about protocols, then? Well, now that you know what kind of person you‚Äôre listening to, it might make sense when I say this: protocols are¬†<em>awesome</em>. They make¬†<em>so much</em> sense. I can‚Äôt believe we were ever doing things any other way.</p>
<p>Are protocols FP? Kind of. The first implementation of something protocol-like was probably in Haskell, with type classes. But OOP had a very similar system soon after, in the form of generics. And Dave Abrahams, who works on Swift, was the main guy for templates in C++ for a long time.¬†They‚Äôre not FP in the traditional sense, but they¬†<em>are</em>¬†FP in the sense that I understand it: they‚Äôre a certain kind of style/technique. And they fit right in with the rest of the styles and techniques of FP.</p>
<h1 id="how-to-do-it">How to do it</h1>
<p>Anyway, I should get to my strategy for using them. Here‚Äôs my ridiculously oversimplified (mis)understanding of how you should see them: protocols describe¬†<em>abilities</em> and¬†<em>talents</em>. God that‚Äôs pretentious. Lemme try again: a protocol represents something a type¬†<em>can</em>¬†do, and¬†<em>how well</em> it can do it. That‚Äôs a bit better.</p>
<p>Let‚Äôs look to the standard library for our examples here. Say you want to make a method that emulates Python‚Äôs slicing, where you can hop over elements of a sequence. Something like:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb1-1" data-line-number="1">public extension SequenceType {</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  func <span class="fu">hop</span>(n: Int) -&gt; [Generator.<span class="fu">Element</span>] {</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">    <span class="kw">var</span> i = n - <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">    <span class="kw">return</span> self.<span class="fu">filter</span> {</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">      _ -&gt; Bool in</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">      <span class="kw">if</span> ++i == n {</a>
<a class="sourceLine" id="cb1-7" data-line-number="7">        i = <span class="dv">0</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">        <span class="kw">return</span> <span class="kw">true</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9">      } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb1-10" data-line-number="10">        <span class="kw">return</span> <span class="kw">false</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11">      }</a>
<a class="sourceLine" id="cb1-12" data-line-number="12">    }</a>
<a class="sourceLine" id="cb1-13" data-line-number="13">  }</a>
<a class="sourceLine" id="cb1-14" data-line-number="14">}</a>
<a class="sourceLine" id="cb1-15" data-line-number="15">[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>].<span class="fu">hop</span>(<span class="dv">2</span>) <span class="co">// [1, 3, 5]</span></a></code></pre></div>
<p>We‚Äôre in protocol-land right away: <code class="sourceCode scala">SequenceType</code>. This is an ‚Äúability‚Äù. The method exists on everything with the¬†<em>ability</em> to act like a sequence. That means arrays, sets, dictionaries, strings. Actually, a better example of the ‚Äúability‚Äù would be this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb2-1" data-line-number="1">extension IntegerArithmeticType {</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  func <span class="dt">double</span>() -&gt; Self {</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">    <span class="kw">return</span> self + self</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">  }</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">}</a>
<a class="sourceLine" id="cb2-6" data-line-number="6"></a>
<a class="sourceLine" id="cb2-7" data-line-number="7"><span class="fl">2.</span><span class="dt">double</span>() <span class="co">// 4</span></a></code></pre></div>
<p>Goodness gracious that‚Äôs contrived. But anyway, you get the idea. Anything that can do integer arithmetic gets that method.</p>
<p>Now, back to the hop method. Maybe it‚Äôs very expensive to actually retrieve every intermediate element and then discard it - that‚Äôs what filter is doing, after all. Why not just do an index lookup?</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb3-1" data-line-number="1">public extension CollectionType {</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  func <span class="fu">hop</span>(n: Index.<span class="fu">Distance</span>) -&gt; [Generator.<span class="fu">Element</span>] {</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">    </a>
<a class="sourceLine" id="cb3-4" data-line-number="4">    <span class="kw">var</span> ar: [Generator.<span class="fu">Element</span>] = []</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">    </a>
<a class="sourceLine" id="cb3-6" data-line-number="6">    <span class="kw">for</span> <span class="kw">var</span> i = startIndex; </a>
<a class="sourceLine" id="cb3-7" data-line-number="7">        indices.<span class="fu">contains</span>(i); </a>
<a class="sourceLine" id="cb3-8" data-line-number="8">        i = <span class="fu">advance</span>(i, n) {</a>
<a class="sourceLine" id="cb3-9" data-line-number="9">          ar.<span class="fu">append</span>(self[i])</a>
<a class="sourceLine" id="cb3-10" data-line-number="10">    }</a>
<a class="sourceLine" id="cb3-11" data-line-number="11">    </a>
<a class="sourceLine" id="cb3-12" data-line-number="12">    <span class="kw">return</span> ar</a>
<a class="sourceLine" id="cb3-13" data-line-number="13">  }</a>
<a class="sourceLine" id="cb3-14" data-line-number="14">}</a></code></pre></div>
<p>There we go! Everything can¬†<em>do</em> the hop method, but <code class="sourceCode scala">CollectionType</code>s can do it¬†<em>well</em>. In fact, some <code class="sourceCode scala">CollectionType</code>s can do it very well indeed:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb4-1" data-line-number="1">public extension CollectionType where Index : RandomAccessIndexType {  </a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  func <span class="fu">hop</span>(n: Index.<span class="fu">Stride</span>) -&gt; [Generator.<span class="fu">Element</span>] {</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">    <span class="kw">return</span> <span class="fu">stride</span>(from: startIndex, to: endIndex, by: n).<span class="fu">map</span>{self[$<span class="dv">0</span>]}</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">  }</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">}</a></code></pre></div>
<p>You see this kind of thing all around the standard library, but most prominently with the index types. If something is able to do something, it gets the bare-bones, inefficient implementation. Then, for types with all the bells and whistles, you get the clever, blazing-fast version. And to the user, all you see is some easy-looking <code class="sourceCode scala"><span class="fu">indexOf</span>()</code> function.</p>
<p>So here‚Äôs how I think you should be doing your APIs: if at all possible, write your function as a method. Write the most bare-bones, slow version of it you possibly can that still makes sense. Then, specialise where it suits.</p>
<p>(I realise now that I may have just described a design pattern that was very obvious to everyone but me. Ah, well)</p>
<h1 id="the-why">The Why</h1>
<p>There are pretty major advantages to this. Your two other options are generally class inheritance, or global functions with generics. <a href="https://developer.apple.com/videos/wwdc/2015/?id=408">The best video from WWDC</a>¬†talks about class inheritance, so I‚Äôll stay away from that. In contrast to global functions, here are the advantages:</p>
<h2 id="more-discoverable">More discoverable</h2>
<p>Hit dot after whatever thing you‚Äôre interested in, and the little list of available goodies pops up. It‚Äôs also easy to find in the documentation (what kind of methods do I have on sequences? vs.¬†Right, here‚Äôs the page for the global functions, cmd-f ‚ÄúSequence‚Äù‚Ä¶ hmm, <code class="sourceCode scala">indexOf</code> isn‚Äôt here‚Ä¶)</p>
<h2 id="function-compositionish">Function composition(ish)</h2>
<p>We currently have this:</p>
<pre><code>g(f(x))</code></pre>
<p>Now, if we were in Haskell-land, you could write:</p>
<pre><code>(g . f) x</code></pre>
<p>But we‚Äôre not. However, if f is a method on x, and g is a method on whatever if returned by f, you can have:</p>
<pre><code>x.f().g()</code></pre>
<p>Maybe a bit of a bad example, but <a href="http://airspeedvelocity.net/2015/06/23/protocol-extensions-and-the-death-of-the-pipe-forward-operator/">combine that with <code class="sourceCode scala">flatMap</code> and laziness and you‚Äôve got some handsome-looking, powerful functions right there.</a></p>
<h2 id="easy-to-build-hierarchies">Easy-to-build hierarchies</h2>
<p>I find myself often getting a bit philosophical around all of these protocols (‚Äúyeah, but what does it¬†<em>mean</em> to be <code class="sourceCode scala">IntegerLiteralConvertible</code>? I mean, aren‚Äôt we¬†<em>all</em>¬†<code class="sourceCode scala">IntegerLiteralConvertible</code>, in a way?‚Äù, ‚ÄúWoah‚Äù). I see places where I can extend a previous method to things I hadn‚Äôt even thought of applying it to. And with the quicklook, and the way the documentation is structured, none of this stuff becomes complicated.</p>
<p>Obviously this is a little bit of a straw man - there are some obvious cases where protocol extensions don‚Äôt make a lot of sense. Having ‚Äúdouble‚Äù as an extension on <code class="sourceCode scala">IntegerArithmeticType</code> is sheer silliness - but I think something like <code class="sourceCode scala"><span class="fu">sqrt</span>()</code> would be odd, as well. If only because it decreases readability, I‚Äôm not sure that those kinds of things are good ideas. At the end of the day, you‚Äôre a reasonable, intelligent person, and you know where this stuff works. Just have it knocking around in your brain, so when you come across something that doesn‚Äôt work¬†<em>quite right</em>, you‚Äôll have protocol extensions as one of your other options.</p>
<p>If you want to see an example of protocols taken to the nth degree, the examples I‚Äôve had here are taken from my library, <a href="https://github.com/oisdk/SwiftSequence">SwiftSequence</a>.</p>
<p>If you‚Äôve kept reading this far, I‚Äôm going to I‚Äôm going to really test your patience with this next bit:</p>
<h1 id="what-do-i-want">What do I want?</h1>
<h2 id="beef-up-some-of-the-meta-language">Beef up some of the meta-language</h2>
<p>You know the tiny little meta-language for protocol extensions? The one that exists between the angle brackets, after the where?</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb8-1" data-line-number="1"></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">extension SomeProtocol <span class="fu">where</span> (This bit) {...</a>
<a class="sourceLine" id="cb8-3" data-line-number="3"></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">func f&lt;T : SomeProtocol <span class="fu">where</span> (This bit, also)...</a></code></pre></div>
<p>That needs to get more powerful. Swift is big on doing loads of stuff at compile-time, and that little meta-language is effectively a script that runs as your code compiles. When it‚Äôs between the angle brackets it‚Äôs ugly, and it seems like too small a place for a lot of code, but if you start doing anything complex with it, you hit its limits quickly. Say you want to write a recursive function that works with slices. This is the absolute minimum in the angle brackets you need:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb9-1" data-line-number="1">&lt;  </a>
<a class="sourceLine" id="cb9-2" data-line-number="2">  S : Sliceable where S.<span class="fu">SubSlice</span> : Sliceable,  </a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  S.<span class="fu">SubSlice</span>.<span class="fu">Generator</span>.<span class="fu">Element</span> == S.<span class="fu">Generator</span>.<span class="fu">Element</span>,  </a>
<a class="sourceLine" id="cb9-4" data-line-number="4">  S.<span class="fu">SubSlice</span>.<span class="fu">SubSlice</span> == S.<span class="fu">SubSlice</span>  </a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  &gt;</a></code></pre></div>
<p>And if you need anything complex, well‚Ä¶</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb10-1" data-line-number="1">func bSearch&lt;</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">  S : Sliceable where S.<span class="fu">SubSlice</span> : Sliceable,</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  S.<span class="fu">SubSlice</span>.<span class="fu">Generator</span>.<span class="fu">Element</span> == S.<span class="fu">Generator</span>.<span class="fu">Element</span>,</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">  S.<span class="fu">SubSlice</span>.<span class="fu">SubSlice</span> == S.<span class="fu">SubSlice</span>,</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">  S.<span class="fu">Generator</span>.<span class="fu">Element</span> : Comparable,</a>
<a class="sourceLine" id="cb10-6" data-line-number="6">  S.<span class="fu">Index</span> : IntegerArithmeticType,</a>
<a class="sourceLine" id="cb10-7" data-line-number="7">  S.<span class="fu">Index</span> : IntegerLiteralConvertible,</a>
<a class="sourceLine" id="cb10-8" data-line-number="8">  S.<span class="fu">SubSlice</span>.<span class="fu">Index</span> == S.<span class="fu">Index</span></a>
<a class="sourceLine" id="cb10-9" data-line-number="9">  &gt;(el: S.<span class="fu">Generator</span>.<span class="fu">Element</span>, list: S) -&gt; S.<span class="fu">Generator</span>.<span class="fu">Element</span>? {</a>
<a class="sourceLine" id="cb10-10" data-line-number="10"></a>
<a class="sourceLine" id="cb10-11" data-line-number="11">    <span class="kw">if</span> list.<span class="fu">isEmpty</span> { <span class="kw">return</span> nil }</a>
<a class="sourceLine" id="cb10-12" data-line-number="12"></a>
<a class="sourceLine" id="cb10-13" data-line-number="13">    let midInd = list.<span class="fu">endIndex</span> / <span class="dv">2</span></a>
<a class="sourceLine" id="cb10-14" data-line-number="14"></a>
<a class="sourceLine" id="cb10-15" data-line-number="15">    let midEl: S.<span class="fu">Generator</span>.<span class="fu">Element</span> = list[midInd] </a>
<a class="sourceLine" id="cb10-16" data-line-number="16">    <span class="co">// type inference giving me some bugs here</span></a>
<a class="sourceLine" id="cb10-17" data-line-number="17"></a>
<a class="sourceLine" id="cb10-18" data-line-number="18">    <span class="kw">if</span> midEl == el {</a>
<a class="sourceLine" id="cb10-19" data-line-number="19">      <span class="kw">return</span> el</a>
<a class="sourceLine" id="cb10-20" data-line-number="20">    }</a>
<a class="sourceLine" id="cb10-21" data-line-number="21"></a>
<a class="sourceLine" id="cb10-22" data-line-number="22">    <span class="kw">return</span> midEl &lt; el ?</a>
<a class="sourceLine" id="cb10-23" data-line-number="23">      <span class="fu">bSearch</span>(el, list: list[midInd+<span class="dv">1</span>..&lt;list.<span class="fu">endIndex</span>]) :</a>
<a class="sourceLine" id="cb10-24" data-line-number="24">      <span class="fu">bSearch</span>(el, list: list[<span class="dv">0</span>..&lt;midInd])</a>
<a class="sourceLine" id="cb10-25" data-line-number="25">}</a></code></pre></div>
<p>Yeah. And it‚Äôs only going to get more and more complex: with every new beta, more functions become methods. This protocol business is going to cause more and more function signatures to end up looking like that. With that in mind, two things, in particular, need to go into the meta-language:</p>
<ul>
<li><p>A way to summarise all of those protocols into one. Like, I should be able to declare a protocol that‚Äôs just other protocols put together:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb11-1" data-line-number="1">protocol RecursiveSliceable:</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">  Sliceable where SubSlice : Sliceable,</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  SubSlice.<span class="fu">Generator</span>.<span class="fu">Element</span> == Generator.<span class="fu">Element</span>,</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">  SubSlice.<span class="fu">SubSlice</span> == SubSlice</a>
<a class="sourceLine" id="cb11-5" data-line-number="5"></a>
<a class="sourceLine" id="cb11-6" data-line-number="6">protocol RecursiveSliceableIntegerIndices:</a>
<a class="sourceLine" id="cb11-7" data-line-number="7">  RecursiveSliceable where</a>
<a class="sourceLine" id="cb11-8" data-line-number="8">  Index : IntegerArithmeticType,</a>
<a class="sourceLine" id="cb11-9" data-line-number="9">  Index : IntegerLiteralConvertible,</a>
<a class="sourceLine" id="cb11-10" data-line-number="10">  SubSlice.<span class="fu">Index</span> == Index</a>
<a class="sourceLine" id="cb11-11" data-line-number="11"></a>
<a class="sourceLine" id="cb11-12" data-line-number="12">func bSearch&lt;</a>
<a class="sourceLine" id="cb11-13" data-line-number="13">  S : RecursiveSliceableIntegerIndices where</a>
<a class="sourceLine" id="cb11-14" data-line-number="14">  S.<span class="fu">Generator</span>.<span class="fu">Element</span> : Comparable</a>
<a class="sourceLine" id="cb11-15" data-line-number="15">  &gt;(seq: S)...</a></code></pre></div></li>
<li><p>Support for expressions, statements and whatnot, all of which get evaluated at compile-time.</p></li>
</ul>
<h2 id="more-pop-in-the-standard-library">More POP in the Standard Library</h2>
<p>The standard library, at the moment, still has not fully crossed over to the protocol way of doing things. It‚Äôs probably more to do with resource pressure than anything else, but I‚Äôm worried that some areas may not get the full protocol treatment. I‚Äôm talking about sequences. Currently, there are structs¬†like <code class="sourceCode scala">AnySequence</code>, which represent the old, dark days of Swift 1.2. In its¬†description:</p>
<blockquote>
<p>A type-erased sequence.</p>
</blockquote>
<blockquote>
<p>Forwards operations to an arbitrary underlying sequence having the same¬†<code>Element</code>¬†type, hiding the specifics of the underlying¬†<code class="sourceCode scala">SequenceType</code>.</p>
</blockquote>
<p>That‚Äôs no good. You shouldn‚Äôt have to erase types - your methods and functions should act on <code class="sourceCode scala">SequenceType</code>, regardless of which <code class="sourceCode scala">SequenceType</code> it is. I‚Äôm not suggesting you should get rid of that struct - it‚Äôs trivial to come up with cases where it‚Äôs needed - I‚Äôm saying you shouldn‚Äôt be using it if you don‚Äôt have to. And in one particular area of the Swift standard library, they use structs where (I feel) they should be using protocols: <code class="sourceCode scala">LazySequence</code>. It‚Äôs a wrapper struct, mainly used for functional-style methods like <code class="sourceCode scala">map</code> and <code class="sourceCode scala">filter</code> that can act lazily.¬†<em>Why isn‚Äôt it a protocol</em>?! Currently, the lazy versions of <code class="sourceCode scala">map</code> and <code class="sourceCode scala">filter</code> are defined as methods on <code class="sourceCode scala">LazySequence</code>. What they return is a <code class="sourceCode scala">MapSequenceView</code> <em>wrapped</em> in <code class="sourceCode scala">LazySequence</code>. That way, you can chain map and filter, keeping things lazy. But why not make <code class="sourceCode scala">LazySequenceType</code> a protocol, and have <code class="sourceCode scala">MapSequenceView</code> conform to it? There‚Äôs more - <code class="sourceCode scala">LazyRandomAccessCollection</code>, <code class="sourceCode scala">LazyForwardCollection</code>, etc.¬†<em>These should all be protocols</em>. It‚Äôs a nightmare to try and deal with these things: if you want to write a lazy method on a sequence, you have to write one for <code class="sourceCode scala">LazySequence</code>, then one for <code class="sourceCode scala">LazyForwardCollection</code>, and so on. It would be so much easier to have.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb12-1" data-line-number="1">extension LazySequenceType where </a>
<a class="sourceLine" id="cb12-2" data-line-number="2">  Self: CollectionType, </a>
<a class="sourceLine" id="cb12-3" data-line-number="3">  Index: RandomAccessIndexType</a></code></pre></div>
<p>I really don‚Äôt know why it‚Äôs not this way. Again, the Swift team may well¬†<em>want</em> to do it, but just hasn‚Äôt got round to it. I hope so. A very optimistic voice in my mind¬†does keep whispering, though: ‚Äú<em>they‚Äôre just waiting for recursive enums, so they can introduce lazy lists‚Ä¶ they‚Äôve been working on a whole load of lazy sequence functions‚Ä¶ pattern matching‚Ä¶ uncons‚Ä¶</em>‚Äù</p>
]]></description>
    <pubDate>Fri, 17 Jul 2015 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2015-07-17-swift-protocols-a-strategy.html</guid>
    <dc:creator>Donnacha Ois√≠n Kidney</dc:creator>
</item>

    </channel>
</rss>
