<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>Donnacha Oisín Kidney's Blog</title>
        <link>https://doisinkidney.com</link>
        <description><![CDATA[Mainly writing about programming]]></description>
        <atom:link href="https://doisinkidney.com/rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Sat, 14 Dec 2019 00:00:00 UT</lastBuildDate>
        <item>
    <title>Lazy Constructive Numbers and the Stern-Brocot Tree</title>
    <link>https://doisinkidney.com/posts/2019-12-14-stern-brocot.html</link>
    <description><![CDATA[<div class="info">
    Posted on December 14, 2019
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Agda.html">Agda</a>
    
</div>

<p>In dependently typed languages, it’s often important to figure out a good “low-level” representation for some concept. The natural numbers, for instance:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Nat</span> <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">|</span> <span class="dt">S</span> <span class="dt">Nat</span></a></code></pre></div>
<p>For “real” applications, of course, these numbers are offensively inefficient, in terms of both space and time. But that’s not what I’m after here: I’m looking for a type which best describes the essence of the natural numbers, and that can be used to prove and think about them. In that sense, this representation is second to none: it’s basically the simplest possible type which <em>can</em> represent the naturals.</p>
<p>Let’s nail down that idea a little better. What do we mean when a type is a “good” representation for some concept.</p>
<ul>
<li><p>There should be no redundancy. The type for the natural numbers above has this property: every natural number as one (and only one) canonical representative in <code>Nat</code>. Compare that to the following possible representation for the integers:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Int</span> <span class="fu">=</span> <span class="dt">Neg</span> <span class="dt">Nat</span> <span class="fu">|</span> <span class="dt">Pos</span> <span class="dt">Nat</span></a></code></pre></div>
<p>There are two ways to represent <code>0</code> here: as <code>Pos Z</code> or <code>Neg Z</code>.</p>
<p>Of course, you can quotient out the redundancy in Cubical Agda, or normalise on construction every time, but either of these workarounds gets your representation a demerit.</p></li>
<li><p>Operations should be definable simply and directly on the representation. Points docked for converting to and from some non-normalised form.</p></li>
<li><p>That conversion, however, can exist, and ideally should exist, in some fundamental way. You should be able to establish an efficient isomorphism with other representations of the same concept.</p></li>
<li><p>Properties about the type should correspond to intuitive properties about the representation. For <code>Nat</code> above, this means things like order: the usual order on the natural numbers again has a straightforward analogue on <code>Nat</code>.</p></li>
</ul>
<p>With that laundry list of requirements, it’s no wonder that it’s often tricky to figure out the “right” type for a concept.</p>
<p>In this post, I’m going to talk about a type for the rational numbers, and I’m going to try satisfy those requirements as best I can.</p>
<h1 id="the-rationals-as-a-pair-of-numbers">The Rationals as a Pair of Numbers</h1>
<p>Our first attempt at representing the rationals might use a fraction:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Frac</span> <span class="fu">=</span> <span class="dt">Integer</span> <span class="fu">:/</span> <span class="dt">Integer</span></a></code></pre></div>
<p>This obviously fails the redundancy property. The fractions <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mn>1</mn><mn>2</mn></mfrac><annotation encoding="application/x-tex">\frac{1}{2}</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mn>2</mn><mn>4</mn></mfrac><annotation encoding="application/x-tex">\frac{2}{4}</annotation></semantics></math> represent the same number, but have different underlying values.</p>
<p>So the type isn’t suitable as a potential representation for the rationals. That’s not to say that this type is useless: far from it! Indeed, Haskell’s <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ratio.html">Data.Ratio</a> uses something quite like this to implement rationals.</p>
<p>If you’re going to deal with redundant elements, there are two broad ways to deal with it. Data.Ratio’s approach is to normalise on construction, and only export a constructor which does this. This gives you a pretty good guarantee that there won’t be any unreduced fractions lying around in you program. Agda’s standard library also uses an approach like this, although the fact that the numerator and denominator are coprime is statically verified by way of a proof carried in the type.</p>
<p>The other way to deal with redundancy is by quotient. In Haskell, that kind of means doing the following:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Eq</span> <span class="dt">Frac</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  (x <span class="fu">:/</span> xd) <span class="fu">==</span> (y <span class="fu">:/</span> yd) <span class="fu">=</span> (x <span class="fu">*</span> yd) <span class="fu">==</span> (y <span class="fu">*</span> xd)</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  </a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="kw">instance</span> <span class="dt">Ord</span> <span class="dt">Frac</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5">  compare (x <span class="fu">:/</span> xd) (y <span class="fu">:/</span> yd) <span class="fu">=</span> compare (x <span class="fu">*</span> yd) (y <span class="fu">*</span> xd)</a></code></pre></div>
<p>We don’t have real quotient types in Haskell, but this gets the idea across: we haven’t normalised our representation internally, but as far as anyone <em>using</em> the type is concerned, they shouldn’t be able to tell the difference between <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mn>1</mn><mn>2</mn></mfrac><annotation encoding="application/x-tex">\frac{1}{2}</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mn>2</mn><mn>4</mn></mfrac><annotation encoding="application/x-tex">\frac{2}{4}</annotation></semantics></math>.</p>
<p>Th <code>Num</code> instance is pretty much just a restating of the axioms for fractions.</p>
<details>
<p><summary> <code>Num</code> instance for <code>Frac</code>. </summary></p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Num</span> <span class="dt">Frac</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">  fromInteger n <span class="fu">=</span> n <span class="fu">:/</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  (x <span class="fu">:/</span> xd) <span class="fu">*</span> (y <span class="fu">:/</span> yd) <span class="fu">=</span> (x <span class="fu">*</span> y) <span class="fu">:/</span> (xd <span class="fu">*</span> yd)</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">  (x <span class="fu">:/</span> xd) <span class="fu">+</span> (y <span class="fu">:/</span> yd) <span class="fu">=</span> (x <span class="fu">*</span> yd <span class="fu">+</span> y <span class="fu">*</span> xd) <span class="fu">:/</span> (xd <span class="fu">*</span> yd)</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">  signum (n <span class="fu">:/</span> d) <span class="fu">=</span> signum (n <span class="fu">*</span> d) <span class="fu">:/</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6">  abs n <span class="fu">=</span> signum n <span class="fu">*</span> n</a>
<a class="sourceLine" id="cb5-7" data-line-number="7">  (x <span class="fu">:/</span> xd) <span class="fu">-</span> (y <span class="fu">:/</span> yd) <span class="fu">=</span> (x <span class="fu">*</span> yd <span class="fu">-</span> y <span class="fu">*</span> xd) <span class="fu">:/</span> (xd <span class="fu">*</span> yd)</a></code></pre></div>
</details>
<p>Cubical Agda, of course, <em>does</em> have real quotient types. There, the <code>Eq</code> instance becomes a path constructor.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">data</span> ℚ <span class="ot">:</span> Type₀ <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  <span class="ot">_</span>÷<span class="ot">_</span> <span class="ot">:</span> <span class="ot">(</span>n d <span class="ot">:</span> ℕ<span class="ot">)</span> <span class="ot">→</span> ℚ</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  reduce <span class="ot">:</span> <span class="ot">∀</span> xⁿ xᵈ yⁿ yᵈ <span class="ot">→</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">           xⁿ ℕ* yᵈ ≡ yⁿ ℕ* xᵈ <span class="ot">→</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">           xⁿ ÷ xᵈ ≡ yⁿ ÷ yᵈ</a></code></pre></div>
<p>But we’ll leave the Agda stuff for another post.</p>
<h1 id="the-rationals-as-a-trace-of-euclids-algorithm">The Rationals as a Trace of Euclid’s Algorithm</h1>
<p>Now we get to the cool stuff. To reduce a fraction, we usually do something like getting the greatest common divisor of each operand. One nice way to do that is to use Euclid’s algorithm:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1">gcd<span class="ot"> ::</span> <span class="dt">Natural</span> <span class="ot">-&gt;</span> <span class="dt">Natural</span> <span class="ot">-&gt;</span> <span class="dt">Natural</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">gcd n m <span class="fu">=</span> <span class="kw">case</span> compare n m <span class="kw">of</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  <span class="dt">EQ</span> <span class="ot">-&gt;</span> n</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">  <span class="dt">LT</span> <span class="ot">-&gt;</span> gcd n (m <span class="fu">-</span> n)</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">  <span class="dt">GT</span> <span class="ot">-&gt;</span> gcd (n <span class="fu">-</span> m) m</a></code></pre></div>
<p>Let’s run that function on three different inputs: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mn>2</mn><mn>3</mn></mfrac><annotation encoding="application/x-tex">\frac{2}{3}</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mn>4</mn><mn>6</mn></mfrac><annotation encoding="application/x-tex">\frac{4}{6}</annotation></semantics></math>, and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mn>5</mn><mn>6</mn></mfrac><annotation encoding="application/x-tex">\frac{5}{6}</annotation></semantics></math>.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">gcd <span class="dv">2</span> <span class="dv">3</span> <span class="ot">=&gt;</span> <span class="kw">case</span> compare <span class="dv">2</span> <span class="dv">3</span> <span class="kw">of</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  <span class="dt">LT</span> <span class="ot">-&gt;</span> gcd <span class="dv">2</span> (<span class="dv">3</span> <span class="fu">-</span> <span class="dv">2</span>) <span class="ot">=&gt;</span> <span class="kw">case</span> compare <span class="dv">2</span> <span class="dv">1</span> <span class="kw">of</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">    <span class="dt">GT</span> <span class="ot">-&gt;</span> gcd (<span class="dv">2</span> <span class="fu">-</span> <span class="dv">1</span>) <span class="dv">1</span> <span class="ot">=&gt;</span> <span class="kw">case</span> compare <span class="dv">1</span> <span class="dv">1</span> <span class="kw">of</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">      <span class="dt">EQ</span> <span class="ot">-&gt;</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5"></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">gcd <span class="dv">4</span> <span class="dv">6</span> <span class="ot">=&gt;</span> <span class="kw">case</span> compare <span class="dv">4</span> <span class="dv">6</span> <span class="kw">of</span></a>
<a class="sourceLine" id="cb8-7" data-line-number="7">  <span class="dt">LT</span> <span class="ot">-&gt;</span> gcd <span class="dv">4</span> (<span class="dv">6</span> <span class="fu">-</span> <span class="dv">4</span>) <span class="ot">=&gt;</span> <span class="kw">case</span> compare <span class="dv">4</span> <span class="dv">2</span> <span class="kw">of</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8">    <span class="dt">GT</span> <span class="ot">-&gt;</span> gcd (<span class="dv">4</span> <span class="fu">-</span> <span class="dv">2</span>) <span class="dv">2</span> <span class="ot">=&gt;</span> <span class="kw">case</span> compare <span class="dv">2</span> <span class="dv">2</span> <span class="kw">of</span></a>
<a class="sourceLine" id="cb8-9" data-line-number="9">      <span class="dt">EQ</span> <span class="ot">-&gt;</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb8-10" data-line-number="10"></a>
<a class="sourceLine" id="cb8-11" data-line-number="11">gcd <span class="dv">5</span> <span class="dv">6</span> <span class="ot">=&gt;</span> <span class="kw">case</span> compare <span class="dv">5</span> <span class="dv">6</span> <span class="kw">of</span></a>
<a class="sourceLine" id="cb8-12" data-line-number="12">  <span class="dt">LT</span> <span class="ot">-&gt;</span> gcd <span class="dv">5</span> (<span class="dv">6</span> <span class="fu">-</span> <span class="dv">5</span>) <span class="ot">=&gt;</span> <span class="kw">case</span> compare <span class="dv">5</span> <span class="dv">1</span> <span class="kw">of</span></a>
<a class="sourceLine" id="cb8-13" data-line-number="13">    <span class="dt">GT</span> <span class="ot">-&gt;</span> gcd (<span class="dv">5</span> <span class="fu">-</span> <span class="dv">1</span>) <span class="dv">1</span> <span class="ot">=&gt;</span> <span class="kw">case</span> compare <span class="dv">4</span> <span class="dv">1</span> <span class="kw">of</span></a>
<a class="sourceLine" id="cb8-14" data-line-number="14">      <span class="dt">GT</span> <span class="ot">-&gt;</span> gcd (<span class="dv">4</span> <span class="fu">-</span> <span class="dv">1</span>) <span class="dv">1</span> <span class="ot">=&gt;</span> <span class="kw">case</span> compare <span class="dv">3</span> <span class="dv">1</span> <span class="kw">of</span></a>
<a class="sourceLine" id="cb8-15" data-line-number="15">        <span class="dt">GT</span> <span class="ot">-&gt;</span> gcd (<span class="dv">3</span> <span class="fu">-</span> <span class="dv">1</span>) <span class="dv">1</span> <span class="ot">=&gt;</span> <span class="kw">case</span> compare <span class="dv">2</span> <span class="dv">1</span> <span class="kw">of</span></a>
<a class="sourceLine" id="cb8-16" data-line-number="16">          <span class="dt">GT</span> <span class="ot">-&gt;</span> gcd (<span class="dv">2</span> <span class="fu">-</span> <span class="dv">1</span>) <span class="dv">1</span> <span class="ot">=&gt;</span> <span class="kw">case</span> compare <span class="dv">1</span> <span class="dv">1</span> <span class="kw">of</span></a>
<a class="sourceLine" id="cb8-17" data-line-number="17">            <span class="dt">EQ</span> <span class="ot">-&gt;</span> <span class="dv">1</span></a></code></pre></div>
<p>Those all return the right things, but that’s not what’s interesting here: look at the chain of comparison results. For the two fractions which are equivalent, their <em>chains</em> are equal.</p>
<p>This turns out to hold in general. Every rational number can be (uniquely!) represented as a list of bits, where each bit is a comparison result from Euclid’s algorithm.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Bit</span> <span class="fu">=</span> <span class="dt">O</span> <span class="fu">|</span> <span class="dt">I</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"></a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="kw">type</span> <span class="dt">Rational</span> <span class="fu">=</span> [<span class="dt">Bit</span>]</a>
<a class="sourceLine" id="cb9-4" data-line-number="4"></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">abs<span class="ot"> ::</span> <span class="dt">Frac</span> <span class="ot">-&gt;</span> <span class="dt">Rational</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6">abs <span class="fu">=</span> unfoldr f</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-8" data-line-number="8">    f (n <span class="fu">:/</span> d) <span class="fu">=</span> <span class="kw">case</span> compare n d <span class="kw">of</span></a>
<a class="sourceLine" id="cb9-9" data-line-number="9">      <span class="dt">EQ</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb9-10" data-line-number="10">      <span class="dt">LT</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> (<span class="dt">O</span>, n <span class="fu">:/</span> (d <span class="fu">-</span> n))</a>
<a class="sourceLine" id="cb9-11" data-line-number="11">      <span class="dt">GT</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> (<span class="dt">I</span>, (n <span class="fu">-</span> d) <span class="fu">:/</span> d)</a></code></pre></div>
<p>And since we used <code>unfoldr</code>, it’s easy to reverse the algorithm to convert from the representation to a pair of numbers.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">rep ::</span> <span class="dt">Rational</span> <span class="ot">-&gt;</span> <span class="dt">Frac</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">rep <span class="fu">=</span> foldr f (<span class="dv">1</span> <span class="fu">:/</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4">    f <span class="dt">I</span> (n <span class="fu">:/</span> d) <span class="fu">=</span> (n <span class="fu">+</span> d) <span class="fu">:/</span> d</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">    f <span class="dt">O</span> (n <span class="fu">:/</span> d) <span class="fu">=</span> n <span class="fu">:/</span> (n <span class="fu">+</span> d)</a></code></pre></div>
<p>Now <code>abs . rep</code> is the identity function, and <code>rep . abs</code> reduces a fraction! We have identified an isomorphism between our type (a list of bits) and the rational numbers!</p>
<p>Well, between the positive rational numbers. Not to worry: we can add a sign before it. And, because our type doesn’t actually include 0, we don’t get the duplicate 0 problems we did with <code>Int</code>.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Q</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">Neg</span> <span class="dt">Rational</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  <span class="fu">|</span> <span class="dt">Zero</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4">  <span class="fu">|</span> <span class="dt">Pos</span> <span class="dt">Rational</span> </a></code></pre></div>
<p>We can also define some operations on the type, by converting back and forth.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Num</span> <span class="dt">Rational</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">  fromInteger n <span class="fu">=</span> abs (n <span class="fu">:/</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">  </a>
<a class="sourceLine" id="cb12-4" data-line-number="4">  xs <span class="fu">+</span> ys <span class="fu">=</span> abs (rep xs <span class="fu">+</span> rep ys)</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">  xs <span class="fu">*</span> ys <span class="fu">=</span> abs (rep xs <span class="fu">*</span> rep ys)</a>
<a class="sourceLine" id="cb12-6" data-line-number="6">  xs <span class="fu">-</span> ys <span class="fu">=</span> abs (rep xs <span class="fu">-</span> rep ys)</a></code></pre></div>
<h1 id="rationals-as-a-path-into-the-stern-brocot-tree">Rationals as a Path into The Stern-Brocot Tree</h1>
<p>So we have a construction that has our desired property of canonicity. Even better, there’s a reasonably efficient algorithm to convert to and from it! Our next task will be examining the representation itself, and seeing what information we can get from it.</p>
<p>To do so we’ll turn to the subject of the title of this post: the <a href="https://en.wikipedia.org/wiki/Stern%E2%80%93Brocot_tree">Stern-Brocot tree</a>.</p>
<figure>
<img src="https://upload.wikimedia.org/wikipedia/commons/3/37/SternBrocotTree.svg" alt="The Stern-Brocot Tree. By Aaron Rotenberg, CC BY-SA 3.0, from Wikimedia Commons." /><figcaption>The Stern-Brocot Tree. By Aaron Rotenberg, CC BY-SA 3.0, from Wikimedia Commons.</figcaption>
</figure>
<p>This tree, pictured above, has some incredible properties:</p>
<ul>
<li>It contains every rational number (in reduced form) exactly once.</li>
<li>It is a binary search tree.</li>
</ul>
<p>Both of these properties make it an excellent candidate for basing a representation on. As it turns out, that’s what we already did! Our list of bits above is precisely a path into the Stern-Brocot tree, where every <code>O</code> is a left turn and every <code>I</code> right.</p>
<h1 id="incrementalising">Incrementalising</h1>
<p>The most important fact we’ve gleaned so far from the Stern-Brocot tree is that our representation is lexicographically ordered. While that may not seem like much, it turns our list of bits into a progressively-narrowing interval, which generates more and more accurate estimates of the true value. When we see a <code>O</code> at the head of the list, we know that the result must be smaller than <code>1</code>; what follows will tell us on what side of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mn>1</mn><mn>2</mn></mfrac><annotation encoding="application/x-tex">\frac{1}{2}</annotation></semantics></math> the answer lies, and so on.</p>
<p>This turns out to be quite a useful property: we often don’t need <em>exact</em> precision for some calculation, but rather some approximate answer. It’s even rarer still that we know exactly how much precision we need for a given expression (which is what floating point demands). Usually, the precision we need changes quite dynamically. If a particular number plays a more influential role in some expression, for instance, its precision is more important than the others!</p>
<p>By producing a lazy list of bits, however, we can allow the <em>consumer</em> to specify the precision they need, by demanding those bits as they go along. (In the literature, this kind of thing is referred to as “lazy exact arithmetic”, and it’s quite fascinating. The representation presented here, however, is not very suitable for any real computation: it’s incredibly slow. There is a paper on the topic: <span class="citation" data-cites="niquiExactArithmeticStern2007">Niqui (<a href="#ref-niquiExactArithmeticStern2007">2007</a>)</span>, which examines the Stern-Brocot numbers in Coq).</p>
<p>In proofs, the benefit is even more pronounced: finding out that a number is in a given range by just inspecting the first element of the list gives an excellent recursion strategy. We can do case analysis on: “what if it’s 1”, “what if it’s less than 1”, and “what if it’s greater than 1”, which is quite intuitive.</p>
<p>There’s one problem: our evaluation function is defined as a <code>foldr</code>, and forces the accumulator at every step. We will need to figure out another evaluator which folds from the left.</p>
<h1 id="intervals">Intervals</h1>
<p>So let’s look more at the “interval” interpretation of the Stern-Brocot tree. The first interval is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mn>0</mn><mn>1</mn></mfrac><mo>,</mo><mfrac><mn>1</mn><mn>0</mn></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\left(\frac{0}{1},\frac{1}{0}\right)</annotation></semantics></math>: neither of these values are actually members of the type, which is why we’re not breaking any major rules with the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mn>1</mn><mn>0</mn></mfrac><annotation encoding="application/x-tex">\frac{1}{0}</annotation></semantics></math>. To move left (to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mn>1</mn><mn>2</mn></mfrac><annotation encoding="application/x-tex">\frac{1}{2}</annotation></semantics></math> in the diagram), we need to use a peculiar operation called “child’s addition”, often denoted with a <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>⊕</mo><annotation encoding="application/x-tex">\oplus</annotation></semantics></math>.</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>a</mi><mi>b</mi></mfrac><mo>⊕</mo><mfrac><mi>c</mi><mi>d</mi></mfrac><mo>=</mo><mfrac><mrow><mi>a</mi><mo>+</mo><mi>c</mi></mrow><mrow><mi>b</mi><mo>+</mo><mi>d</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex"> \frac{a}{b} \oplus \frac{c}{d} = \frac{a+c}{b+d} </annotation></semantics></math></p>
<p>The name comes from the fact that it’s a very common mistaken definition of addition on fractions.</p>
<p>Right, next steps: to move <em>left</em> in an interval, we do the following:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">left</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mstyle mathvariant="italic"><mi>𝑙</mi><mi>𝑏</mi></mstyle><mo>,</mo><mstyle mathvariant="italic"><mi>𝑢</mi><mi>𝑏</mi></mstyle><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mstyle mathvariant="italic"><mi>𝑙</mi><mi>𝑏</mi></mstyle><mo>,</mo><mstyle mathvariant="italic"><mi>𝑙</mi><mi>𝑏</mi></mstyle><mo>⊕</mo><mstyle mathvariant="italic"><mi>𝑢</mi><mi>𝑏</mi></mstyle><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex"> \text{left} \left(\mathit{lb},\mathit{ub} \right) = \left( \mathit{lb}, \mathit{lb} \oplus \mathit{ub} \right) </annotation></semantics></math></p>
<p>In other words, we narrow the right-hand-side of the interval. To move right is the opposite:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">right</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mstyle mathvariant="italic"><mi>𝑙</mi><mi>𝑏</mi></mstyle><mo>,</mo><mstyle mathvariant="italic"><mi>𝑢</mi><mi>𝑏</mi></mstyle><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mstyle mathvariant="italic"><mi>𝑙</mi><mi>𝑏</mi></mstyle><mo>⊕</mo><mstyle mathvariant="italic"><mi>𝑢</mi><mi>𝑏</mi></mstyle><mo>,</mo><mstyle mathvariant="italic"><mi>𝑢</mi><mi>𝑏</mi></mstyle><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex"> \text{right} \left(\mathit{lb},\mathit{ub} \right) = \left( \mathit{lb}
\oplus \mathit{ub} , \mathit{ub} \right) </annotation></semantics></math></p>
<p>And finally, when we hit the end of the sequence, we take the <em>mediant</em> value.</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">mediant</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mstyle mathvariant="italic"><mi>𝑙</mi><mi>𝑏</mi></mstyle><mo>,</mo><mstyle mathvariant="italic"><mi>𝑢</mi><mi>𝑏</mi></mstyle><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mstyle mathvariant="italic"><mi>𝑙</mi><mi>𝑏</mi></mstyle><mo>⊕</mo><mstyle mathvariant="italic"><mi>𝑟</mi><mi>𝑏</mi></mstyle></mrow><annotation encoding="application/x-tex"> \text{mediant}\left(\mathit{lb} , \mathit{ub}\right) = \mathit{lb} \oplus
\mathit{rb} </annotation></semantics></math></p>
<p>From this, we get a straightforward left fold which can compute our fraction.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1">infix <span class="dv">6</span> <span class="fu">:-:</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Interval</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">  <span class="fu">=</span> (<span class="fu">:-:</span>)</a>
<a class="sourceLine" id="cb13-4" data-line-number="4">  {<span class="ot"> lb ::</span> <span class="dt">Frac</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5">  ,<span class="ot"> ub ::</span> <span class="dt">Frac</span></a>
<a class="sourceLine" id="cb13-6" data-line-number="6">  }</a>
<a class="sourceLine" id="cb13-7" data-line-number="7"></a>
<a class="sourceLine" id="cb13-8" data-line-number="8"><span class="ot">mediant ::</span> <span class="dt">Interval</span> <span class="ot">-&gt;</span> <span class="dt">Frac</span></a>
<a class="sourceLine" id="cb13-9" data-line-number="9">mediant (b <span class="fu">:/</span> d <span class="fu">:-:</span> a <span class="fu">:/</span> c) <span class="fu">=</span> (a<span class="fu">+</span>b) <span class="fu">:/</span> (c<span class="fu">+</span>d)</a>
<a class="sourceLine" id="cb13-10" data-line-number="10"></a>
<a class="sourceLine" id="cb13-11" data-line-number="11">left,<span class="ot"> right ::</span> <span class="dt">Interval</span> <span class="ot">-&gt;</span> <span class="dt">Interval</span></a>
<a class="sourceLine" id="cb13-12" data-line-number="12">left  x <span class="fu">=</span> lb x <span class="fu">:-:</span> mediant x</a>
<a class="sourceLine" id="cb13-13" data-line-number="13">right x <span class="fu">=</span> mediant x <span class="fu">:-:</span> ub x</a>
<a class="sourceLine" id="cb13-14" data-line-number="14"></a>
<a class="sourceLine" id="cb13-15" data-line-number="15"><span class="ot">rep&#39; ::</span> [<span class="dt">Bit</span>] <span class="ot">-&gt;</span> <span class="dt">Frac</span></a>
<a class="sourceLine" id="cb13-16" data-line-number="16">rep&#39; <span class="fu">=</span> mediant <span class="fu">.</span> foldl f ((<span class="dv">0</span> <span class="fu">:/</span> <span class="dv">1</span>) <span class="fu">:-:</span> (<span class="dv">1</span> <span class="fu">:/</span> <span class="dv">0</span>))</a>
<a class="sourceLine" id="cb13-17" data-line-number="17">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-18" data-line-number="18">    f a <span class="dt">I</span> <span class="fu">=</span> right a</a>
<a class="sourceLine" id="cb13-19" data-line-number="19">    f a <span class="dt">O</span> <span class="fu">=</span> left a</a></code></pre></div>
<h1 id="monoids-and-matrices">Monoids and Matrices</h1>
<p>Before diving in and using this new evaluator to incrementalise our functions, let’s take a look at what’s going on behind the scenes of the “interval narrowing” idea.</p>
<p>It turns out that the “interval” is really a <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>×</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2\times2</annotation></semantics></math> square matrix in disguise (albeit a little reordered).</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mi>a</mi><mi>b</mi></mfrac><mo>,</mo><mfrac><mi>c</mi><mi>d</mi></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center"><mi>c</mi></mtd><mtd columnalign="center"><mi>a</mi></mtd></mtr><mtr><mtd columnalign="center"><mi>d</mi></mtd><mtd columnalign="center"><mi>b</mi></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex"> \left( \frac{a}{b} , \frac{c}{d} \right) =
\left(
\begin{matrix} 
  c &amp; a \\ 
  d &amp; b
\end{matrix} 
\right)
</annotation></semantics></math></p>
<p>Seen in this way, the beginning interval—<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mn>0</mn><mn>1</mn></mfrac><mo>,</mo><mfrac><mn>1</mn><mn>0</mn></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\left(\frac{0}{1} , \frac{1}{0}\right)</annotation></semantics></math>—is actually the identity matrix. Also, the two values in the second row of the tree correspond to special matrices which we will refer to as <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>.</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center"><mn>1</mn></mtd><mtd columnalign="center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center"><mn>1</mn></mtd><mtd columnalign="center"><mn>1</mn></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.278em"></mspace><mi>R</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center"><mn>1</mn></mtd><mtd columnalign="center"><mn>1</mn></mtd></mtr><mtr><mtd columnalign="center"><mn>0</mn></mtd><mtd columnalign="center"><mn>1</mn></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex"> L = 
\left(
\begin{matrix} 
  1 &amp; 0 \\ 
  1 &amp; 1
\end{matrix} 
\right) \;
R = 
\left(
\begin{matrix} 
  1 &amp; 1 \\ 
  0 &amp; 1
\end{matrix} 
\right)
</annotation></semantics></math></p>
<p>It turns out that the left and right functions we defined earlier correspond to multiplication by these matrices.</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">left</mtext><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>x</mi><mi>L</mi></mrow><annotation encoding="application/x-tex"> \text{left}(x) = xL </annotation></semantics></math> <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">right</mtext><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>x</mi><mi>R</mi></mrow><annotation encoding="application/x-tex"> \text{right}(x) = xR </annotation></semantics></math></p>
<p>Since matrix multiplication is associative, what we have here is a monoid. <code>mempty</code> is the open interval at the beginning, and <code>mappend</code> is matrix multiplication. This is the property that lets us incrementalise the whole thing, by the way: associativity allows us to decide when to start and stop the calculation.</p>
<h1 id="incrementalising-1">Incrementalising!</h1>
<p>We now have all the parts we need. First, we will write an evaluator that returns increasingly precise intervals. Our friend <code>scanl</code> fits the requirement precisely.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="ot">approximate ::</span> [<span class="dt">Bit</span>] <span class="ot">-&gt;</span> [<span class="dt">Interval</span>]</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">approximate <span class="fu">=</span> scanl f mempty</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-4" data-line-number="4">    f i <span class="dt">I</span> <span class="fu">=</span> right i</a>
<a class="sourceLine" id="cb14-5" data-line-number="5">    f i <span class="dt">O</span> <span class="fu">=</span> left  i</a></code></pre></div>
<p>Next, we will need to combine two of these lists with some operation on fractions.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="ot">interleave ::</span> (<span class="dt">Frac</span> <span class="ot">-&gt;</span> <span class="dt">Frac</span> <span class="ot">-&gt;</span> <span class="dt">Frac</span>)</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">           <span class="ot">-&gt;</span> [<span class="dt">Interval</span>]</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">           <span class="ot">-&gt;</span> [<span class="dt">Interval</span>]</a>
<a class="sourceLine" id="cb15-4" data-line-number="4">           <span class="ot">-&gt;</span> [<span class="dt">Interval</span>]</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">interleave (<span class="fu">*</span>) [xi] ys <span class="fu">=</span> map (\y <span class="ot">-&gt;</span> x <span class="fu">*</span> lb y <span class="fu">:-:</span> x <span class="fu">*</span> ub y) ys</a>
<a class="sourceLine" id="cb15-6" data-line-number="6">  <span class="kw">where</span> x <span class="fu">=</span> mediant xi</a>
<a class="sourceLine" id="cb15-7" data-line-number="7">interleave (<span class="fu">*</span>) (x<span class="fu">:</span>xs) ys<span class="fu">@</span>(y<span class="fu">:</span>_) <span class="fu">=</span></a>
<a class="sourceLine" id="cb15-8" data-line-number="8">  (((<span class="fu">*</span>) <span class="ot">`on`</span> lb) x y <span class="fu">:-:</span> ((<span class="fu">*</span>) <span class="ot">`on`</span> ub) x y) <span class="fu">:</span> interleave (<span class="fu">*</span>) ys xs</a></code></pre></div>
<p>The operation must respect orders in the proper way for this to be valid.</p>
<p>This pops one bit from each list in turn: one of the many possible optimisations would be to pull more information from the more informative value, in some clever way.</p>
<p>Finally, we have a function which incrementally runs some binary operator lazily on a list of bits.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="ot">quad ::</span> (<span class="dt">Frac</span> <span class="ot">-&gt;</span> <span class="dt">Frac</span> <span class="ot">-&gt;</span> <span class="dt">Frac</span>)</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">     <span class="ot">-&gt;</span> [<span class="dt">Bit</span>]</a>
<a class="sourceLine" id="cb16-3" data-line-number="3">     <span class="ot">-&gt;</span> [<span class="dt">Bit</span>]</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">     <span class="ot">-&gt;</span> [<span class="dt">Bit</span>]</a>
<a class="sourceLine" id="cb16-5" data-line-number="5">quad (<span class="fu">*</span>) xs ys <span class="fu">=</span> foldr f (unfoldr p) zs mempty</a>
<a class="sourceLine" id="cb16-6" data-line-number="6">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-7" data-line-number="7">    zs <span class="fu">=</span> (interleave (<span class="fu">*</span>) <span class="ot">`on`</span> approximate) xs ys</a>
<a class="sourceLine" id="cb16-8" data-line-number="8">    </a>
<a class="sourceLine" id="cb16-9" data-line-number="9">    f x xs c</a>
<a class="sourceLine" id="cb16-10" data-line-number="10">      <span class="fu">|</span> mediant c <span class="fu">&lt;</span> lb x <span class="fu">=</span> <span class="dt">I</span> <span class="fu">:</span> f x xs (right c)</a>
<a class="sourceLine" id="cb16-11" data-line-number="11">      <span class="fu">|</span> mediant c <span class="fu">&gt;</span> ub x <span class="fu">=</span> <span class="dt">O</span> <span class="fu">:</span> f x xs (left  c)</a>
<a class="sourceLine" id="cb16-12" data-line-number="12">      <span class="fu">|</span> otherwise <span class="fu">=</span> xs c</a>
<a class="sourceLine" id="cb16-13" data-line-number="13">        </a>
<a class="sourceLine" id="cb16-14" data-line-number="14">    t <span class="fu">=</span> mediant (last zs)</a>
<a class="sourceLine" id="cb16-15" data-line-number="15">    </a>
<a class="sourceLine" id="cb16-16" data-line-number="16">    p c <span class="fu">=</span> <span class="kw">case</span> compare (mediant c) t <span class="kw">of</span></a>
<a class="sourceLine" id="cb16-17" data-line-number="17">      <span class="dt">LT</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> (<span class="dt">I</span>, right c)</a>
<a class="sourceLine" id="cb16-18" data-line-number="18">      <span class="dt">GT</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> (<span class="dt">O</span>, left  c)</a>
<a class="sourceLine" id="cb16-19" data-line-number="19">      <span class="dt">EQ</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></a></code></pre></div>
<p>The function only ever inspects the next bit when it absolutely needs to.</p>
<p>The helper function <code>f</code> here is the “incremental” version. <code>p</code> takes over when the precision of the input is exhausted.</p>
<p>We can use this to write an addition function (with some added special cases to speed things up).</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="ot">add ::</span> [<span class="dt">Bit</span>] <span class="ot">-&gt;</span> [<span class="dt">Bit</span>] <span class="ot">-&gt;</span> [<span class="dt">Bit</span>]</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">add [] ys <span class="fu">=</span> <span class="dt">I</span> <span class="fu">:</span> ys</a>
<a class="sourceLine" id="cb17-3" data-line-number="3">add xs [] <span class="fu">=</span> <span class="dt">I</span> <span class="fu">:</span> xs</a>
<a class="sourceLine" id="cb17-4" data-line-number="4">add (<span class="dt">I</span><span class="fu">:</span>xs) ys <span class="fu">=</span> <span class="dt">I</span> <span class="fu">:</span> add xs ys</a>
<a class="sourceLine" id="cb17-5" data-line-number="5">add xs (<span class="dt">I</span><span class="fu">:</span>ys) <span class="fu">=</span> <span class="dt">I</span> <span class="fu">:</span> add xs ys</a>
<a class="sourceLine" id="cb17-6" data-line-number="6">add xs ys <span class="fu">=</span> quad (<span class="fu">+</span>) xs ys</a></code></pre></div>
<p>We (could) also try and optimise the times we look for a new bit. Above we have noticed every case where one of the rationals is preceded by a whole part. After you encounter two <code>O</code>s, in addition if the two strings are inverses of each other the result will be 1. i.e. <code>OOIOOI</code> + <code>OIOIIO</code> = <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mn>1</mn><mn>1</mn></mfrac><annotation encoding="application/x-tex">\frac{1}{1}</annotation></semantics></math>. We could try and spot this, only testing with comparison of the mediant when the bits are the same. You’ve doubtless spotted some other possible optimisations: I have yet to look into them!</p>
<h1 id="inverting-functions">Inverting Functions</h1>
<p>One of the other applications of lazy rationals is that they can begin to <em>look</em> like the real numbers. For instance, the <code>p</code> helper function above is basically defined extensionally. Instead of stating the value of the number, we give a function which tells us when we’ve made something too big or too small (which sounds an awful lot like a Dedekind cut to my ears). Here’s a function which <em>inverts</em> a given function on fractions, for instance.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="ot">inv ::</span> (<span class="dt">Frac</span> <span class="ot">-&gt;</span> <span class="dt">Frac</span>) <span class="ot">-&gt;</span> [<span class="dt">Bit</span>] <span class="ot">-&gt;</span> [<span class="dt">Bit</span>]</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">inv o n <span class="fu">=</span> unfoldr f mempty</a>
<a class="sourceLine" id="cb18-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-4" data-line-number="4">    t <span class="fu">=</span> fromQ n</a>
<a class="sourceLine" id="cb18-5" data-line-number="5">    </a>
<a class="sourceLine" id="cb18-6" data-line-number="6">    f c <span class="fu">=</span> <span class="kw">case</span> compare (o (mediant c)) t <span class="kw">of</span></a>
<a class="sourceLine" id="cb18-7" data-line-number="7">      <span class="dt">LT</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> (<span class="dt">I</span>, right c)</a>
<a class="sourceLine" id="cb18-8" data-line-number="8">      <span class="dt">GT</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> (<span class="dt">O</span>, left  c)</a>
<a class="sourceLine" id="cb18-9" data-line-number="9">      <span class="dt">EQ</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></a></code></pre></div>
<p>Of course, the function has to satisfy all kinds of extra properties that I haven’t really thought a lot about yet, but no matter. We can use it to invert a squaring function:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1">sqrt<span class="ot"> ::</span> [<span class="dt">Bit</span>] <span class="ot">-&gt;</span> [<span class="dt">Bit</span>]</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">sqrt <span class="fu">=</span> inv (\x <span class="ot">-&gt;</span> x <span class="fu">*</span> x)</a></code></pre></div>
<p>And we can use <em>this</em> to get successive approximations to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msqrt><mn>2</mn></msqrt><annotation encoding="application/x-tex">\sqrt{2}</annotation></semantics></math>!</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1">root2Approx</a>
<a class="sourceLine" id="cb20-2" data-line-number="2">  <span class="fu">=</span> map (toDouble <span class="fu">.</span> mediant) (approximate (sqrt (abs (<span class="dv">2</span> <span class="fu">:/</span> <span class="dv">1</span>))))</a>
<a class="sourceLine" id="cb20-3" data-line-number="3">  </a>
<a class="sourceLine" id="cb20-4" data-line-number="4"><span class="fu">&gt;&gt;&gt;</span> mapM_ print root2Approx</a>
<a class="sourceLine" id="cb20-5" data-line-number="5"><span class="fl">1.0</span></a>
<a class="sourceLine" id="cb20-6" data-line-number="6"><span class="fl">2.0</span></a>
<a class="sourceLine" id="cb20-7" data-line-number="7"><span class="fl">1.5</span></a>
<a class="sourceLine" id="cb20-8" data-line-number="8"><span class="fl">1.3333333333333333</span></a>
<a class="sourceLine" id="cb20-9" data-line-number="9"><span class="fl">1.4</span></a>
<a class="sourceLine" id="cb20-10" data-line-number="10"><span class="fl">1.4285714285714286</span></a>
<a class="sourceLine" id="cb20-11" data-line-number="11"><span class="fl">1.4166666666666667</span></a>
<a class="sourceLine" id="cb20-12" data-line-number="12"><span class="fl">1.411764705882353</span></a>
<a class="sourceLine" id="cb20-13" data-line-number="13"><span class="fl">1.4137931034482758</span></a>
<a class="sourceLine" id="cb20-14" data-line-number="14"><span class="fl">1.4146341463414633</span></a>
<a class="sourceLine" id="cb20-15" data-line-number="15"><span class="fu">...</span></a></code></pre></div>
<h1 id="conclusions-and-related-work">Conclusions and Related Work</h1>
<p>Using the Stern-Brocot tree to represent the rationals was formalised in Coq in <span class="citation" data-cites="bertotSimpleCanonicalRepresentation2003">Bertot (<a href="#ref-bertotSimpleCanonicalRepresentation2003">2003</a>)</span>. The corresponding lazy operations are formalised in <a href="https://github.com/coq-community/qarith-stern-brocot">QArith</a>. Its theory and implementation is described in <span class="citation" data-cites="niquiExactArithmeticStern2007">Niqui (<a href="#ref-niquiExactArithmeticStern2007">2007</a>)</span>. Unfortunately, I found most of the algorithms impenetrably complex, so I can’t really judge how they compare to the ones I have here.</p>
<p>I mentioned that one of the reasons you might want lazy rational arithmetic is that it can help with certain proofs. While this is true, in general the two main reasons people reach for lazy arithmetic is efficiency and as a way to get to the real numbers.</p>
<p>From the perspective of efficiency, the Stern-Brocot tree is probably a bad idea. You may have noticed that the right branch of the tree contains all the whole numbers: this means that the whole part is encoded in unary. Beyond that, we generally have to convert to some fraction in order to do any calculation, which is massively expensive.</p>
<p>The problem is that bits in the same position in different numbers don’t necessarily correspond to the same quantities. In base 10, for instance, the numbers 561 and 1024 have values in the “ones” position of 1 and 4, respectively. We can work with those two values independent of the rest of the number, which can lead to quicker algorithms.</p>
<p>Looking at the Stern-Brocot encoding, the numbers <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mn>2</mn><mn>3</mn></mfrac><annotation encoding="application/x-tex">\frac{2}{3}</annotation></semantics></math> and 3 are represented by <code>OI</code> and <code>II</code>, respectively. That second <code>I</code> in each, despite being in the same position, corresponds to <em>different values</em>: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mn>1</mn><mn>3</mn></mfrac><annotation encoding="application/x-tex">\frac{1}{3}</annotation></semantics></math> in the first, and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mn>3</mn><mn>2</mn></mfrac><annotation encoding="application/x-tex">\frac{3}{2}</annotation></semantics></math> in the second.</p>
<p>Solutions to both of these problems necessitate losing the one-to-one property of the representation. We could improve the size of the representation of terms by having our <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math> matrices be the following <span class="citation" data-cites="kurkaExactRealArithmetic2014">(Krka <a href="#ref-kurkaExactRealArithmetic2014">2014</a>)</span>:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center"><mn>1</mn></mtd><mtd columnalign="center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center"><mn>1</mn></mtd><mtd columnalign="center"><mn>2</mn></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.278em"></mspace><mi>R</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center"><mn>2</mn></mtd><mtd columnalign="center"><mn>1</mn></mtd></mtr><mtr><mtd columnalign="center"><mn>0</mn></mtd><mtd columnalign="center"><mn>1</mn></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex"> L = \left( 
\begin{matrix}
  1 &amp; 0 \\
  1 &amp; 2
\end{matrix}
\right) \;
 R = \left( 
\begin{matrix}
  2 &amp; 1 \\
  0 &amp; 1
\end{matrix}
\right) </annotation></semantics></math></p>
<p>But now there will be gaps in the tree. This basically means we’ll have to use infinite repeating bits to represent terms like <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mn>1</mn><mn>2</mn></mfrac><annotation encoding="application/x-tex">\frac{1}{2}</annotation></semantics></math>.</p>
<p>We could solve the other problem by throwing out the Stern-Brocot tree entirely and using a more traditional positional number system. Again, this introduces redundancy: in order to represent some fraction which doesn’t divide properly into the base of the number system you have to use repeating decimals.</p>
<p>The second reason for lazy rational arithmetic is that it can be a crucial component in building a constructive interpretation of the real numbers. This in particular is an area of real excitement at the moment: HoTT has opened up some interesting avenues that weren’t possible before for constructing the reals <span class="citation" data-cites="bauerRealNumbersHomotopy2016">(Bauer <a href="#ref-bauerRealNumbersHomotopy2016">2016</a>)</span>.</p>
<p>In a future post, I might present a formalisation of these numbers in Agda. I also intend to look at the dyadic numbers.</p>
<p>Update 26/12/2019: thanks Anton Felix Lorenzen and Joseph C. Sible for spotting some mistakes in this post.</p>
<h1 id="references" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-bauerRealNumbersHomotopy2016">
<p>Bauer, Andrej. 2016. “The real numbers in homotopy type theory.” Faro, Portugal. <a href="http://math.andrej.com/wp-content/uploads/2016/06/hott-reals-cca2016.pdf" class="uri">http://math.andrej.com/wp-content/uploads/2016/06/hott-reals-cca2016.pdf</a>.</p>
</div>
<div id="ref-bertotSimpleCanonicalRepresentation2003">
<p>Bertot, Yves. 2003. “A simple canonical representation of rational numbers.” <em>Electronic Notes in Theoretical Computer Science</em> 85 (7). Mathematics, Logic and Computation (Satellite Event of ICALP 2003) (September): 1–16. doi:<a href="https://doi.org/10.1016/S1571-0661(04)80754-0">10.1016/S1571-0661(04)80754-0</a>. <a href="http://www.sciencedirect.com/science/article/pii/S1571066104807540" class="uri">http://www.sciencedirect.com/science/article/pii/S1571066104807540</a>.</p>
</div>
<div id="ref-kurkaExactRealArithmetic2014">
<p>Krka, Petr. 2014. “Exact real arithmetic for interval number systems.” <em>Theoretical Computer Science</em> 542 (July): 32–43. doi:<a href="https://doi.org/10.1016/j.tcs.2014.04.030">10.1016/j.tcs.2014.04.030</a>. <a href="http://www.sciencedirect.com/science/article/pii/S0304397514003351" class="uri">http://www.sciencedirect.com/science/article/pii/S0304397514003351</a>.</p>
</div>
<div id="ref-niquiExactArithmeticStern2007">
<p>Niqui, Milad. 2007. “Exact arithmetic on the SternBrocot tree.” <em>Journal of Discrete Algorithms</em> 5 (2). 2004 Symposium on String Processing and Information Retrieval (June): 356–379. doi:<a href="https://doi.org/10.1016/j.jda.2005.03.007">10.1016/j.jda.2005.03.007</a>. <a href="http://www.sciencedirect.com/science/article/pii/S1570866706000311" class="uri">http://www.sciencedirect.com/science/article/pii/S1570866706000311</a>.</p>
</div>
</div>
]]></description>
    <pubDate>Sat, 14 Dec 2019 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2019-12-14-stern-brocot.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>A Small Proof that Fin is Injective</title>
    <link>https://doisinkidney.com/posts/2019-11-15-small-proof-fin-inj.html</link>
    <description><![CDATA[<div class="info">
    Posted on November 15, 2019
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Agda.html">Agda</a>
    
</div>

<details>
<p><summary>Imports etc.</summary></p>
<pre class="Agda"><a id="115" class="Symbol">{-#</a> <a id="119" class="Keyword">OPTIONS</a> <a id="127" class="Pragma">--safe</a> <a id="134" class="Pragma">--without-K</a> <a id="146" class="Symbol">#-}</a>

<a id="151" class="Keyword">module</a> <a id="158" href="" class="Module">Post</a> <a id="163" class="Keyword">where</a>

<a id="170" class="Keyword">open</a> <a id="175" class="Keyword">import</a> <a id="182" href="../code/fininj/Data.Fin.html" class="Module">Data.Fin</a>                              <a id="220" class="Keyword">using</a> <a id="226" class="Symbol">(</a><a id="227" href="../code/fininj/Data.Fin.Base.html#1061" class="Datatype">Fin</a><a id="230" class="Symbol">;</a> <a id="232" href="../code/fininj/Data.Fin.Base.html#1114" class="InductiveConstructor">suc</a><a id="235" class="Symbol">;</a> <a id="237" href="../code/fininj/Data.Fin.Base.html#1083" class="InductiveConstructor">zero</a><a id="241" class="Symbol">;</a> <a id="243" href="../code/fininj/Data.Fin.Properties.html#1997" class="../code/fininj/Function Operator">_≟_</a><a id="246" class="Symbol">)</a>
<a id="248" class="Keyword">open</a> <a id="253" class="Keyword">import</a> <a id="260" href="../code/fininj/Data.Nat.html" class="Module">Data.Nat</a>                              <a id="298" class="Keyword">using</a> <a id="304" class="Symbol">(</a><a id="305" href="../code/fininj/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a><a id="306" class="Symbol">;</a> <a id="308" href="../code/fininj/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a><a id="311" class="Symbol">;</a> <a id="313" href="../code/fininj/Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a><a id="317" class="Symbol">;</a> <a id="319" href="../code/fininj/Agda.Builtin.Nat.html#298" class="Primitive Operator">_+_</a><a id="322" class="Symbol">;</a> <a id="324" href="../code/fininj/Data.Nat.Base.html#3697" class="../code/fininj/Function">compare</a><a id="331" class="Symbol">;</a> <a id="333" href="../code/fininj/Data.Nat.Base.html#3620" class="InductiveConstructor">equal</a><a id="338" class="Symbol">;</a> <a id="340" href="../code/fininj/Data.Nat.Base.html#3653" class="InductiveConstructor">greater</a><a id="347" class="Symbol">;</a> <a id="349" href="../code/fininj/Data.Nat.Base.html#3575" class="InductiveConstructor">less</a><a id="353" class="Symbol">)</a>
<a id="355" class="Keyword">open</a> <a id="360" class="Keyword">import</a> <a id="367" href="../code/fininj/Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a>                   <a id="405" class="Keyword">using</a> <a id="411" class="Symbol">(</a><a id="412" href="../code/fininj/Data.Nat.Properties.html#12828" class="../code/fininj/Function">+-comm</a><a id="418" class="Symbol">)</a>
<a id="420" class="Keyword">open</a> <a id="425" class="Keyword">import</a> <a id="432" href="../code/fininj/Data.Bool.html" class="Module">Data.Bool</a>                             <a id="470" class="Keyword">using</a> <a id="476" class="Symbol">(</a><a id="477" href="../code/fininj/Data.Bool.Base.html#932" class="../code/fininj/Function">not</a><a id="480" class="Symbol">;</a> <a id="482" href="../code/fininj/Data.Bool.Base.html#1451" class="../code/fininj/Function">T</a><a id="483" class="Symbol">)</a>
<a id="485" class="Keyword">open</a> <a id="490" class="Keyword">import</a> <a id="497" href="../code/fininj/Relation.Nullary.html" class="Module">Relation.Nullary</a>                      <a id="535" class="Keyword">using</a> <a id="541" class="Symbol">(</a><a id="542" href="../code/fininj/Relation.Nullary.html#1645">yes</a><a id="545" class="Symbol">;</a> <a id="547" href="../code/fininj/Relation.Nullary.html#1682">no</a><a id="549" class="Symbol">;</a> <a id="551" href="../code/fininj/Relation.Nullary.html#1578" class="Field">does</a><a id="555" class="Symbol">;</a> <a id="557" href="../code/fininj/Relation.Nullary.html#653" class="../code/fininj/Function Operator">¬_</a><a id="559" class="Symbol">)</a>
<a id="561" class="Keyword">open</a> <a id="566" class="Keyword">import</a> <a id="573" href="../code/fininj/Data.Product.html" class="Module">Data.Product</a>                          <a id="611" class="Keyword">using</a> <a id="617" class="Symbol">(</a><a id="618" href="../code/fininj/Agda.Builtin.Sigma.html#139" class="Record">Σ</a><a id="619" class="Symbol">;</a> <a id="621" href="../code/fininj/Data.Product.html#916" class="../code/fininj/Function">Σ-syntax</a><a id="629" class="Symbol">;</a> <a id="631" href="../code/fininj/Agda.Builtin.Sigma.html#225" class="Field">proj₁</a><a id="636" class="Symbol">;</a> <a id="638" href="../code/fininj/Agda.Builtin.Sigma.html#237" class="Field">proj₂</a><a id="643" class="Symbol">;</a> <a id="645" href="../code/fininj/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">_,_</a><a id="648" class="Symbol">)</a>
<a id="650" class="Keyword">open</a> <a id="655" class="Keyword">import</a> <a id="662" href="../code/fininj/Data.Unit.html" class="Module">Data.Unit</a>                             <a id="700" class="Keyword">using</a> <a id="706" class="Symbol">(</a><a id="707" href="../code/fininj/Agda.Builtin.Unit.html#174" class="InductiveConstructor">tt</a><a id="709" class="Symbol">;</a> <a id="711" href="../code/fininj/Agda.Builtin.Unit.html#137" class="Record">⊤</a><a id="712" class="Symbol">)</a>
<a id="714" class="Keyword">open</a> <a id="719" class="Keyword">import</a> <a id="726" href="../code/fininj/Function.html" class="Module">Function</a>                              <a id="764" class="Keyword">using</a> <a id="770" class="Symbol">(</a><a id="771" href="../code/fininj/Function.Base.html#992" class="../code/fininj/Function Operator">_∘_</a><a id="774" class="Symbol">;</a> <a id="776" href="../code/fininj/Function.Base.html#615" class="../code/fininj/Function">id</a><a id="778" class="Symbol">;</a> <a id="780" href="../code/fininj/Function.Base.html#3828" class="../code/fininj/Function Operator">_⟨_⟩_</a><a id="785" class="Symbol">)</a>
<a id="787" class="Keyword">open</a> <a id="792" class="Keyword">import</a> <a id="799" href="../code/fininj/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="837" class="Keyword">using</a> <a id="843" class="Symbol">(</a><a id="844" href="../code/fininj/Relation.Binary.PropositionalEquality.Core.html#1076" class="../code/fininj/Function">subst</a><a id="849" class="Symbol">;</a> <a id="851" href="../code/fininj/Relation.Binary.PropositionalEquality.Core.html#1025" class="../code/fininj/Function">trans</a><a id="856" class="Symbol">;</a> <a id="858" href="../code/fininj/Relation.Binary.PropositionalEquality.Core.html#1131" class="../code/fininj/Function">cong</a><a id="862" class="Symbol">;</a> <a id="864" href="../code/fininj/Relation.Binary.PropositionalEquality.Core.html#980" class="../code/fininj/Function">sym</a><a id="867" class="Symbol">;</a> <a id="869" href="../code/fininj/Agda.Builtin.Equality.html#125" class="Datatype Operator">_≡_</a><a id="872" class="Symbol">;</a> <a id="874" href="../code/fininj/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a><a id="878" class="Symbol">;</a> <a id="880" href="../code/fininj/Relation.Binary.PropositionalEquality.Core.html#840" class="../code/fininj/Function Operator">_≢_</a><a id="883" class="Symbol">)</a>
<a id="885" class="Keyword">open</a> <a id="890" class="Keyword">import</a> <a id="897" href="../code/fininj/Data.Empty.html" class="Module">Data.Empty</a>                            <a id="935" class="Keyword">using</a> <a id="941" class="Symbol">(</a><a id="942" href="../code/fininj/Data.Empty.html#275" class="../code/fininj/Function">⊥-elim</a><a id="948" class="Symbol">;</a> <a id="950" href="../code/fininj/Data.Empty.html#260" class="Datatype">⊥</a><a id="951" class="Symbol">)</a>

<a id="954" class="Keyword">variable</a> <a id="963" href="#963" class="Generalizable">n</a> <a id="965" href="#965" class="Generalizable">m</a> <a id="967" class="Symbol">:</a> <a id="969" href="../code/fininj/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a>
</pre>
</details>
<p>Here’s a puzzle: can you prove that <code>Fin</code> is injective? That’s the type constructor, by the way, not the type itself. Here’s the type of the proof we want:</p>
<pre class="Agda"><a id="Goal"></a><a id="1153" href="#1153" class="../code/fininj/Function">Goal</a> <a id="1158" class="Symbol">:</a> <a id="1160" class="PrimitiveType">Set₁</a>
<a id="1165" href="#1153" class="../code/fininj/Function">Goal</a> <a id="1170" class="Symbol">=</a> <a id="1172" class="Symbol">∀</a> <a id="1174" class="Symbol">{</a><a id="1175" href="#1175" class="Bound">n</a> <a id="1177" href="#1177" class="Bound">m</a><a id="1178" class="Symbol">}</a> <a id="1180" class="Symbol">→</a> <a id="1182" href="../code/fininj/Data.Fin.Base.html#1061" class="Datatype">Fin</a> <a id="1186" href="#1175" class="Bound">n</a> <a id="1188" href="../code/fininj/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="1190" href="../code/fininj/Data.Fin.Base.html#1061" class="Datatype">Fin</a> <a id="1194" href="#1177" class="Bound">m</a> <a id="1196" class="Symbol">→</a> <a id="1198" href="#1175" class="Bound">n</a> <a id="1200" href="../code/fininj/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="1202" href="#1177" class="Bound">m</a>
</pre>
<p>I’m going to present a proof of this lemma that has a couple interesting features. You should try it yourself before reading on, though: it’s difficult, but great practice for understanding Agda’s type system.</p>
<p>First off, I should say that it’s not really a “new” proof: it’s basically <a href="https://github.com/AndrasKovacs/misc-stuff/blob/db1b6f8699870ba25986c5408f1dddbded663b7c/agda/FinInj.agda">Andras Kovac’s proof</a>, with one key change. That proof, as well as this one, goes <code>--without-K</code>: because I actually use this proof in some work I’m doing in Cubical Agda at the moment, this was non optional. It does make things significantly harder, and disallows nice tricks like the <a href="https://github.com/effectfully/random-stuff/blob/8907dda8cbba29073e6c9720e9b05f47be864440/Fin-injective.agda">ones used by effectfully</a>.</p>
<h1 id="computational-inequalities">Computational Inequalities</h1>
<p>The trick we’re going to use comes courtesy of <a href="https://personal.cis.strath.ac.uk/james.wood.100/blog/html/VecMat.html">James Wood</a>. The central idea is the following type:</p>
<pre class="Agda"><a id="_≢ᶠ_"></a><a id="2239" href="#2239" class="../code/fininj/Function Operator">_≢ᶠ_</a> <a id="2244" class="Symbol">:</a> <a id="2246" href="../code/fininj/Data.Fin.Base.html#1061" class="Datatype">Fin</a> <a id="2250" href="#963" class="Generalizable">n</a> <a id="2252" class="Symbol">→</a> <a id="2254" href="../code/fininj/Data.Fin.Base.html#1061" class="Datatype">Fin</a> <a id="2258" href="#963" class="Generalizable">n</a> <a id="2260" class="Symbol">→</a> <a id="2262" class="PrimitiveType">Set</a>
<a id="2266" href="#2266" class="Bound">x</a> <a id="2268" href="#2239" class="../code/fininj/Function Operator">≢ᶠ</a> <a id="2271" href="#2271" class="Bound">y</a> <a id="2273" class="Symbol">=</a> <a id="2275" href="../code/fininj/Data.Bool.Base.html#1451" class="../code/fininj/Function">T</a> <a id="2277" class="Symbol">(</a><a id="2278" href="../code/fininj/Data.Bool.Base.html#932" class="../code/fininj/Function">not</a> <a id="2282" class="Symbol">(</a><a id="2283" href="../code/fininj/Relation.Nullary.html#1578" class="Field">does</a> <a id="2288" class="Symbol">(</a><a id="2289" href="#2266" class="Bound">x</a> <a id="2291" href="../code/fininj/Data.Fin.Properties.html#1997" class="../code/fininj/Function Operator">≟</a> <a id="2293" href="#2271" class="Bound">y</a><a id="2294" class="Symbol">)))</a>
</pre>
<p>This proof of inequality of <code>Fin</code>s is different from the usual definition, which might be something like:</p>
<pre class="Agda"><a id="_≢ᶠ′_"></a><a id="2418" href="#2418" class="../code/fininj/Function Operator">_≢ᶠ′_</a> <a id="2424" class="Symbol">:</a> <a id="2426" href="../code/fininj/Data.Fin.Base.html#1061" class="Datatype">Fin</a> <a id="2430" href="#963" class="Generalizable">n</a> <a id="2432" class="Symbol">→</a> <a id="2434" href="../code/fininj/Data.Fin.Base.html#1061" class="Datatype">Fin</a> <a id="2438" href="#963" class="Generalizable">n</a> <a id="2440" class="Symbol">→</a> <a id="2442" class="PrimitiveType">Set</a>
<a id="2446" href="#2446" class="Bound">x</a> <a id="2448" href="#2418" class="../code/fininj/Function Operator">≢ᶠ′</a> <a id="2452" href="#2452" class="Bound">y</a> <a id="2454" class="Symbol">=</a> <a id="2456" href="#2446" class="Bound">x</a> <a id="2458" href="../code/fininj/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="2460" href="#2452" class="Bound">y</a> <a id="2462" class="Symbol">→</a> <a id="2464" href="../code/fininj/Data.Empty.html#260" class="Datatype">⊥</a>
</pre>
<p>Our definition is based on the decidable equality of two <code>Fin</code>s. It also uses the standard library’s new <code>Dec</code> type. Basically, we get better computation behaviour from our definition. It behaves as if it were defined like so:</p>
<pre class="Agda"><a id="_≢ᶠ″_"></a><a id="2707" href="#2707" class="../code/fininj/Function Operator">_≢ᶠ″_</a> <a id="2713" class="Symbol">:</a> <a id="2715" href="../code/fininj/Data.Fin.Base.html#1061" class="Datatype">Fin</a> <a id="2719" href="#963" class="Generalizable">n</a> <a id="2721" class="Symbol">→</a> <a id="2723" href="../code/fininj/Data.Fin.Base.html#1061" class="Datatype">Fin</a> <a id="2727" href="#963" class="Generalizable">n</a> <a id="2729" class="Symbol">→</a> <a id="2731" class="PrimitiveType">Set</a>
<a id="2735" href="../code/fininj/Data.Fin.Base.html#1083" class="InductiveConstructor">zero</a>  <a id="2741" href="#2707" class="../code/fininj/Function Operator">≢ᶠ″</a> <a id="2745" href="../code/fininj/Data.Fin.Base.html#1083" class="InductiveConstructor">zero</a>  <a id="2751" class="Symbol">=</a> <a id="2753" href="../code/fininj/Data.Empty.html#260" class="Datatype">⊥</a>
<a id="2755" href="../code/fininj/Data.Fin.Base.html#1083" class="InductiveConstructor">zero</a>  <a id="2761" href="#2707" class="../code/fininj/Function Operator">≢ᶠ″</a> <a id="2765" href="../code/fininj/Data.Fin.Base.html#1114" class="InductiveConstructor">suc</a> <a id="2769" href="#2769" class="Bound">y</a> <a id="2771" class="Symbol">=</a> <a id="2773" href="../code/fininj/Agda.Builtin.Unit.html#137" class="Record">⊤</a>
<a id="2775" href="../code/fininj/Data.Fin.Base.html#1114" class="InductiveConstructor">suc</a> <a id="2779" href="#2779" class="Bound">x</a> <a id="2781" href="#2707" class="../code/fininj/Function Operator">≢ᶠ″</a> <a id="2785" href="../code/fininj/Data.Fin.Base.html#1083" class="InductiveConstructor">zero</a>  <a id="2791" class="Symbol">=</a> <a id="2793" href="../code/fininj/Agda.Builtin.Unit.html#137" class="Record">⊤</a>
<a id="2795" href="../code/fininj/Data.Fin.Base.html#1114" class="InductiveConstructor">suc</a> <a id="2799" href="#2799" class="Bound">x</a> <a id="2801" href="#2707" class="../code/fininj/Function Operator">≢ᶠ″</a> <a id="2805" href="../code/fininj/Data.Fin.Base.html#1114" class="InductiveConstructor">suc</a> <a id="2809" href="#2809" class="Bound">y</a> <a id="2811" class="Symbol">=</a> <a id="2813" href="#2799" class="Bound">x</a> <a id="2815" href="#2707" class="../code/fininj/Function Operator">≢ᶠ″</a> <a id="2819" href="#2809" class="Bound">y</a>
</pre>
<p>The benefit of this, in contrast to <code>_≢ᶠ′_</code>, is that each case becomes a definitional equality we don’t have to prove. Compare the two following proofs of congruence under <code>suc</code>:</p>
<pre class="Agda"><a id="cong-suc″"></a><a id="3014" href="#3014" class="../code/fininj/Function">cong-suc″</a> <a id="3024" class="Symbol">:</a> <a id="3026" class="Symbol">∀</a> <a id="3028" class="Symbol">{</a><a id="3029" href="#3029" class="Bound">x</a> <a id="3031" href="#3031" class="Bound">y</a> <a id="3033" class="Symbol">:</a> <a id="3035" href="../code/fininj/Data.Fin.Base.html#1061" class="Datatype">Fin</a> <a id="3039" href="#963" class="Generalizable">n</a><a id="3040" class="Symbol">}</a> <a id="3042" class="Symbol">→</a> <a id="3044" href="#3029" class="Bound">x</a> <a id="3046" href="#2707" class="../code/fininj/Function Operator">≢ᶠ″</a> <a id="3050" href="#3031" class="Bound">y</a> <a id="3052" class="Symbol">→</a> <a id="3054" href="../code/fininj/Data.Fin.Base.html#1114" class="InductiveConstructor">suc</a> <a id="3058" href="#3029" class="Bound">x</a> <a id="3060" href="#2707" class="../code/fininj/Function Operator">≢ᶠ″</a> <a id="3064" href="../code/fininj/Data.Fin.Base.html#1114" class="InductiveConstructor">suc</a> <a id="3068" href="#3031" class="Bound">y</a>
<a id="3070" href="#3014" class="../code/fininj/Function">cong-suc″</a> <a id="3080" href="#3080" class="Bound">p</a> <a id="3082" class="Symbol">=</a> <a id="3084" href="#3080" class="Bound">p</a>

<a id="cong-suc′"></a><a id="3087" href="#3087" class="../code/fininj/Function">cong-suc′</a> <a id="3097" class="Symbol">:</a> <a id="3099" class="Symbol">∀</a> <a id="3101" class="Symbol">{</a><a id="3102" href="#3102" class="Bound">x</a> <a id="3104" href="#3104" class="Bound">y</a> <a id="3106" class="Symbol">:</a> <a id="3108" href="../code/fininj/Data.Fin.Base.html#1061" class="Datatype">Fin</a> <a id="3112" href="#963" class="Generalizable">n</a><a id="3113" class="Symbol">}</a> <a id="3115" class="Symbol">→</a> <a id="3117" href="#3102" class="Bound">x</a> <a id="3119" href="#2418" class="../code/fininj/Function Operator">≢ᶠ′</a> <a id="3123" href="#3104" class="Bound">y</a> <a id="3125" class="Symbol">→</a> <a id="3127" href="../code/fininj/Data.Fin.Base.html#1114" class="InductiveConstructor">suc</a> <a id="3131" href="#3102" class="Bound">x</a> <a id="3133" href="#2418" class="../code/fininj/Function Operator">≢ᶠ′</a> <a id="3137" href="../code/fininj/Data.Fin.Base.html#1114" class="InductiveConstructor">suc</a> <a id="3141" href="#3104" class="Bound">y</a>
<a id="3143" href="#3087" class="../code/fininj/Function">cong-suc′</a> <a id="3153" class="Symbol">{</a><a id="3154" class="Argument">n</a> <a id="3156" class="Symbol">=</a> <a id="3158" href="../code/fininj/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="3162" href="#3162" class="Bound">n</a><a id="3163" class="Symbol">}</a> <a id="3165" href="#3165" class="Bound">p</a> <a id="3167" href="#3167" class="Bound">q</a> <a id="3169" class="Symbol">=</a> <a id="3171" href="#3165" class="Bound">p</a> <a id="3173" class="Symbol">(</a><a id="3174" href="../code/fininj/Relation.Binary.PropositionalEquality.Core.html#1131" class="../code/fininj/Function">cong</a> <a id="3179" href="#3198" class="../code/fininj/Function">fpred</a> <a id="3185" href="#3167" class="Bound">q</a><a id="3186" class="Symbol">)</a>
  <a id="3190" class="Keyword">where</a>
  <a id="3198" href="#3198" class="../code/fininj/Function">fpred</a> <a id="3204" class="Symbol">:</a> <a id="3206" href="../code/fininj/Data.Fin.Base.html#1061" class="Datatype">Fin</a> <a id="3210" class="Symbol">(</a><a id="3211" href="../code/fininj/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="3215" class="Symbol">(</a><a id="3216" href="../code/fininj/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="3220" href="#3162" class="Bound">n</a><a id="3221" class="Symbol">))</a> <a id="3224" class="Symbol">→</a> <a id="3226" href="../code/fininj/Data.Fin.Base.html#1061" class="Datatype">Fin</a> <a id="3230" class="Symbol">(</a><a id="3231" href="../code/fininj/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="3235" href="#3162" class="Bound">n</a><a id="3236" class="Symbol">)</a>
  <a id="3240" href="#3198" class="../code/fininj/Function">fpred</a> <a id="3246" class="Symbol">(</a><a id="3247" href="../code/fininj/Data.Fin.Base.html#1114" class="InductiveConstructor">suc</a> <a id="3251" href="#3251" class="Bound">x</a><a id="3252" class="Symbol">)</a> <a id="3254" class="Symbol">=</a> <a id="3256" href="#3251" class="Bound">x</a>
  <a id="3260" href="#3198" class="../code/fininj/Function">fpred</a> <a id="3266" href="../code/fininj/Data.Fin.Base.html#1083" class="InductiveConstructor">zero</a> <a id="3271" class="Symbol">=</a> <a id="3273" href="../code/fininj/Data.Fin.Base.html#1083" class="InductiveConstructor">zero</a>
</pre>
<h1 id="the-proof">The Proof</h1>
<p>First, we will describe an “injection” for functions from <code>Fin</code>s to <code>Fin</code>s.</p>
<pre class="Agda"><a id="_F↣_"></a><a id="3381" href="#3381" class="../code/fininj/Function Operator">_F↣_</a> <a id="3386" class="Symbol">:</a> <a id="3388" href="../code/fininj/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="3390" class="Symbol">→</a> <a id="3392" href="../code/fininj/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="3394" class="Symbol">→</a> <a id="3396" class="PrimitiveType">Set</a>
<a id="3400" href="#3400" class="Bound">n</a> <a id="3402" href="#3381" class="../code/fininj/Function Operator">F↣</a> <a id="3405" href="#3405" class="Bound">m</a> <a id="3407" class="Symbol">=</a> <a id="3409" href="../code/fininj/Data.Product.html#916" class="../code/fininj/Function">Σ[</a> <a id="3412" href="#3412" class="Bound">f</a> <a id="3414" href="../code/fininj/Data.Product.html#916" class="../code/fininj/Function">∈</a> <a id="3416" class="Symbol">(</a><a id="3417" href="../code/fininj/Data.Fin.Base.html#1061" class="Datatype">Fin</a> <a id="3421" href="#3400" class="Bound">n</a> <a id="3423" class="Symbol">→</a> <a id="3425" href="../code/fininj/Data.Fin.Base.html#1061" class="Datatype">Fin</a> <a id="3429" href="#3405" class="Bound">m</a><a id="3430" class="Symbol">)</a> <a id="3432" href="../code/fininj/Data.Product.html#916" class="../code/fininj/Function">]</a> <a id="3434" class="Symbol">∀</a> <a id="3436" class="Symbol">{</a><a id="3437" href="#3437" class="Bound">x</a> <a id="3439" href="#3439" class="Bound">y</a><a id="3440" class="Symbol">}</a> <a id="3442" class="Symbol">→</a> <a id="3444" href="#3437" class="Bound">x</a> <a id="3446" href="#2239" class="../code/fininj/Function Operator">≢ᶠ</a> <a id="3449" href="#3439" class="Bound">y</a> <a id="3451" class="Symbol">→</a> <a id="3453" href="#3412" class="Bound">f</a> <a id="3455" href="#3437" class="Bound">x</a> <a id="3457" href="#2239" class="../code/fininj/Function Operator">≢ᶠ</a> <a id="3460" href="#3412" class="Bound">f</a> <a id="3462" href="#3439" class="Bound">y</a>
</pre>
<p>We’re using the negated from of injectivity here, which is usually avoided in constructive settings. It actually works a little better for us here, though. Since we’re working in the domain of <code>Fin</code>s, and since our proof is prop-valued, it’s almost like we’re working in classical logic.</p>
<p>Next, we have the workhorse of the proof, the <code>shrink</code> lemma:</p>
<pre class="Agda"><a id="shift"></a><a id="3829" href="#3829" class="../code/fininj/Function">shift</a> <a id="3835" class="Symbol">:</a> <a id="3837" class="Symbol">(</a><a id="3838" href="#3838" class="Bound">x</a> <a id="3840" href="#3840" class="Bound">y</a> <a id="3842" class="Symbol">:</a> <a id="3844" href="../code/fininj/Data.Fin.Base.html#1061" class="Datatype">Fin</a> <a id="3848" class="Symbol">(</a><a id="3849" href="../code/fininj/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="3853" href="#963" class="Generalizable">n</a><a id="3854" class="Symbol">))</a> <a id="3857" class="Symbol">→</a> <a id="3859" href="#3838" class="Bound">x</a> <a id="3861" href="#2239" class="../code/fininj/Function Operator">≢ᶠ</a> <a id="3864" href="#3840" class="Bound">y</a> <a id="3866" class="Symbol">→</a> <a id="3868" href="../code/fininj/Data.Fin.Base.html#1061" class="Datatype">Fin</a> <a id="3872" href="#963" class="Generalizable">n</a>
<a id="3874" href="#3829" class="../code/fininj/Function">shift</a>         <a id="3888" href="../code/fininj/Data.Fin.Base.html#1083" class="InductiveConstructor">zero</a>    <a id="3896" class="Symbol">(</a><a id="3897" href="../code/fininj/Data.Fin.Base.html#1114" class="InductiveConstructor">suc</a> <a id="3901" href="#3901" class="Bound">y</a><a id="3902" class="Symbol">)</a> <a id="3904" href="#3904" class="Bound">x≢y</a> <a id="3908" class="Symbol">=</a> <a id="3910" href="#3901" class="Bound">y</a>
<a id="3912" href="#3829" class="../code/fininj/Function">shift</a> <a id="3918" class="Symbol">{</a><a id="3919" href="../code/fininj/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="3923" class="Symbol">_}</a> <a id="3926" class="Symbol">(</a><a id="3927" href="../code/fininj/Data.Fin.Base.html#1114" class="InductiveConstructor">suc</a> <a id="3931" href="#3931" class="Bound">x</a><a id="3932" class="Symbol">)</a> <a id="3934" href="../code/fininj/Data.Fin.Base.html#1083" class="InductiveConstructor">zero</a>    <a id="3942" href="#3942" class="Bound">x≢y</a> <a id="3946" class="Symbol">=</a> <a id="3948" href="../code/fininj/Data.Fin.Base.html#1083" class="InductiveConstructor">zero</a>
<a id="3953" href="#3829" class="../code/fininj/Function">shift</a> <a id="3959" class="Symbol">{</a><a id="3960" href="../code/fininj/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="3964" class="Symbol">_}</a> <a id="3967" class="Symbol">(</a><a id="3968" href="../code/fininj/Data.Fin.Base.html#1114" class="InductiveConstructor">suc</a> <a id="3972" href="#3972" class="Bound">x</a><a id="3973" class="Symbol">)</a> <a id="3975" class="Symbol">(</a><a id="3976" href="../code/fininj/Data.Fin.Base.html#1114" class="InductiveConstructor">suc</a> <a id="3980" href="#3980" class="Bound">y</a><a id="3981" class="Symbol">)</a> <a id="3983" href="#3983" class="Bound">x≢y</a> <a id="3987" class="Symbol">=</a> <a id="3989" href="../code/fininj/Data.Fin.Base.html#1114" class="InductiveConstructor">suc</a> <a id="3993" class="Symbol">(</a><a id="3994" href="#3829" class="../code/fininj/Function">shift</a> <a id="4000" href="#3972" class="Bound">x</a> <a id="4002" href="#3980" class="Bound">y</a> <a id="4004" href="#3983" class="Bound">x≢y</a><a id="4007" class="Symbol">)</a>

<a id="shift-inj"></a><a id="4010" href="#4010" class="../code/fininj/Function">shift-inj</a> <a id="4020" class="Symbol">:</a> <a id="4022" class="Symbol">∀</a> <a id="4024" class="Symbol">(</a><a id="4025" href="#4025" class="Bound">x</a> <a id="4027" href="#4027" class="Bound">y</a> <a id="4029" href="#4029" class="Bound">z</a> <a id="4031" class="Symbol">:</a> <a id="4033" href="../code/fininj/Data.Fin.Base.html#1061" class="Datatype">Fin</a> <a id="4037" class="Symbol">(</a><a id="4038" href="../code/fininj/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="4042" href="#963" class="Generalizable">n</a><a id="4043" class="Symbol">))</a> <a id="4046" href="#4046" class="Bound">y≢x</a> <a id="4050" href="#4050" class="Bound">z≢x</a> <a id="4054" class="Symbol">→</a> <a id="4056" href="#4027" class="Bound">y</a> <a id="4058" href="#2239" class="../code/fininj/Function Operator">≢ᶠ</a> <a id="4061" href="#4029" class="Bound">z</a> <a id="4063" class="Symbol">→</a> <a id="4065" href="#3829" class="../code/fininj/Function">shift</a> <a id="4071" href="#4025" class="Bound">x</a> <a id="4073" href="#4027" class="Bound">y</a> <a id="4075" href="#4046" class="Bound">y≢x</a> <a id="4079" href="#2239" class="../code/fininj/Function Operator">≢ᶠ</a> <a id="4082" href="#3829" class="../code/fininj/Function">shift</a> <a id="4088" href="#4025" class="Bound">x</a> <a id="4090" href="#4029" class="Bound">z</a> <a id="4092" href="#4050" class="Bound">z≢x</a>
<a id="4096" href="#4010" class="../code/fininj/Function">shift-inj</a>         <a id="4114" href="../code/fininj/Data.Fin.Base.html#1083" class="InductiveConstructor">zero</a>    <a id="4122" class="Symbol">(</a><a id="4123" href="../code/fininj/Data.Fin.Base.html#1114" class="InductiveConstructor">suc</a> <a id="4127" href="#4127" class="Bound">y</a><a id="4128" class="Symbol">)</a> <a id="4130" class="Symbol">(</a><a id="4131" href="../code/fininj/Data.Fin.Base.html#1114" class="InductiveConstructor">suc</a> <a id="4135" href="#4135" class="Bound">z</a><a id="4136" class="Symbol">)</a> <a id="4138" href="#4138" class="Bound">y≢x</a> <a id="4142" href="#4142" class="Bound">z≢x</a> <a id="4146" href="#4146" class="Bound">neq</a> <a id="4150" class="Symbol">=</a> <a id="4152" href="#4146" class="Bound">neq</a>
<a id="4156" href="#4010" class="../code/fininj/Function">shift-inj</a> <a id="4166" class="Symbol">{</a><a id="4167" href="../code/fininj/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="4171" class="Symbol">_}</a> <a id="4174" class="Symbol">(</a><a id="4175" href="../code/fininj/Data.Fin.Base.html#1114" class="InductiveConstructor">suc</a> <a id="4179" href="#4179" class="Bound">x</a><a id="4180" class="Symbol">)</a> <a id="4182" href="../code/fininj/Data.Fin.Base.html#1083" class="InductiveConstructor">zero</a>    <a id="4190" class="Symbol">(</a><a id="4191" href="../code/fininj/Data.Fin.Base.html#1114" class="InductiveConstructor">suc</a> <a id="4195" href="#4195" class="Bound">z</a><a id="4196" class="Symbol">)</a> <a id="4198" href="#4198" class="Bound">y≢x</a> <a id="4202" href="#4202" class="Bound">z≢x</a> <a id="4206" href="#4206" class="Bound">neq</a> <a id="4210" class="Symbol">=</a> <a id="4212" href="../code/fininj/Agda.Builtin.Unit.html#174" class="InductiveConstructor">tt</a>
<a id="4215" href="#4010" class="../code/fininj/Function">shift-inj</a> <a id="4225" class="Symbol">{</a><a id="4226" href="../code/fininj/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="4230" class="Symbol">_}</a> <a id="4233" class="Symbol">(</a><a id="4234" href="../code/fininj/Data.Fin.Base.html#1114" class="InductiveConstructor">suc</a> <a id="4238" href="#4238" class="Bound">x</a><a id="4239" class="Symbol">)</a> <a id="4241" class="Symbol">(</a><a id="4242" href="../code/fininj/Data.Fin.Base.html#1114" class="InductiveConstructor">suc</a> <a id="4246" href="#4246" class="Bound">y</a><a id="4247" class="Symbol">)</a> <a id="4249" href="../code/fininj/Data.Fin.Base.html#1083" class="InductiveConstructor">zero</a>    <a id="4257" href="#4257" class="Bound">y≢x</a> <a id="4261" href="#4261" class="Bound">z≢x</a> <a id="4265" href="#4265" class="Bound">neq</a> <a id="4269" class="Symbol">=</a> <a id="4271" href="../code/fininj/Agda.Builtin.Unit.html#174" class="InductiveConstructor">tt</a>
<a id="4274" href="#4010" class="../code/fininj/Function">shift-inj</a> <a id="4284" class="Symbol">{</a><a id="4285" href="../code/fininj/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="4289" class="Symbol">_}</a> <a id="4292" class="Symbol">(</a><a id="4293" href="../code/fininj/Data.Fin.Base.html#1114" class="InductiveConstructor">suc</a> <a id="4297" href="#4297" class="Bound">x</a><a id="4298" class="Symbol">)</a> <a id="4300" class="Symbol">(</a><a id="4301" href="../code/fininj/Data.Fin.Base.html#1114" class="InductiveConstructor">suc</a> <a id="4305" href="#4305" class="Bound">y</a><a id="4306" class="Symbol">)</a> <a id="4308" class="Symbol">(</a><a id="4309" href="../code/fininj/Data.Fin.Base.html#1114" class="InductiveConstructor">suc</a> <a id="4313" href="#4313" class="Bound">z</a><a id="4314" class="Symbol">)</a> <a id="4316" href="#4316" class="Bound">y≢x</a> <a id="4320" href="#4320" class="Bound">z≢x</a> <a id="4324" href="#4324" class="Bound">neq</a> <a id="4328" class="Symbol">=</a> <a id="4330" href="#4010" class="../code/fininj/Function">shift-inj</a> <a id="4340" href="#4297" class="Bound">x</a> <a id="4342" href="#4305" class="Bound">y</a> <a id="4344" href="#4313" class="Bound">z</a> <a id="4346" href="#4316" class="Bound">y≢x</a> <a id="4350" href="#4320" class="Bound">z≢x</a> <a id="4354" href="#4324" class="Bound">neq</a>

<a id="shrink"></a><a id="4359" href="#4359" class="../code/fininj/Function">shrink</a> <a id="4366" class="Symbol">:</a> <a id="4368" href="../code/fininj/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="4372" href="#963" class="Generalizable">n</a> <a id="4374" href="#3381" class="../code/fininj/Function Operator">F↣</a> <a id="4377" href="../code/fininj/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="4381" href="#965" class="Generalizable">m</a> <a id="4383" class="Symbol">→</a> <a id="4385" href="#963" class="Generalizable">n</a> <a id="4387" href="#3381" class="../code/fininj/Function Operator">F↣</a> <a id="4390" href="#965" class="Generalizable">m</a>
<a id="4392" href="#4359" class="../code/fininj/Function">shrink</a> <a id="4399" class="Symbol">(</a><a id="4400" href="#4400" class="Bound">f</a> <a id="4402" href="../code/fininj/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="4404" href="#4404" class="Bound">inj</a><a id="4407" class="Symbol">)</a> <a id="4409" class="Symbol">.</a><a id="4410" href="../code/fininj/Agda.Builtin.Sigma.html#225" class="Field">proj₁</a> <a id="4416" href="#4416" class="Bound">x</a> <a id="4418" class="Symbol">=</a> <a id="4420" href="#3829" class="../code/fininj/Function">shift</a> <a id="4426" class="Symbol">(</a><a id="4427" href="#4400" class="Bound">f</a> <a id="4429" href="../code/fininj/Data.Fin.Base.html#1083" class="InductiveConstructor">zero</a><a id="4433" class="Symbol">)</a> <a id="4435" class="Symbol">(</a><a id="4436" href="#4400" class="Bound">f</a> <a id="4438" class="Symbol">(</a><a id="4439" href="../code/fininj/Data.Fin.Base.html#1114" class="InductiveConstructor">suc</a> <a id="4443" href="#4416" class="Bound">x</a><a id="4444" class="Symbol">))</a> <a id="4447" class="Symbol">(</a><a id="4448" href="#4404" class="Bound">inj</a> <a id="4452" href="../code/fininj/Agda.Builtin.Unit.html#174" class="InductiveConstructor">tt</a><a id="4454" class="Symbol">)</a>
<a id="4456" href="#4359" class="../code/fininj/Function">shrink</a> <a id="4463" class="Symbol">(</a><a id="4464" href="#4464" class="Bound">f</a> <a id="4466" href="../code/fininj/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="4468" href="#4468" class="Bound">inj</a><a id="4471" class="Symbol">)</a> <a id="4473" class="Symbol">.</a><a id="4474" href="../code/fininj/Agda.Builtin.Sigma.html#237" class="Field">proj₂</a> <a id="4480" href="#4480" class="Bound">p</a> <a id="4482" class="Symbol">=</a> <a id="4484" href="#4010" class="../code/fininj/Function">shift-inj</a> <a id="4494" class="Symbol">(</a><a id="4495" href="#4464" class="Bound">f</a> <a id="4497" href="../code/fininj/Data.Fin.Base.html#1083" class="InductiveConstructor">zero</a><a id="4501" class="Symbol">)</a> <a id="4503" class="Symbol">(</a><a id="4504" href="#4464" class="Bound">f</a> <a id="4506" class="Symbol">(</a><a id="4507" href="../code/fininj/Data.Fin.Base.html#1114" class="InductiveConstructor">suc</a> <a id="4511" class="Symbol">_))</a> <a id="4515" class="Symbol">(</a><a id="4516" href="#4464" class="Bound">f</a> <a id="4518" class="Symbol">(</a><a id="4519" href="../code/fininj/Data.Fin.Base.html#1114" class="InductiveConstructor">suc</a> <a id="4523" class="Symbol">_))</a> <a id="4527" class="Symbol">(</a><a id="4528" href="#4468" class="Bound">inj</a> <a id="4532" href="../code/fininj/Agda.Builtin.Unit.html#174" class="InductiveConstructor">tt</a><a id="4534" class="Symbol">)</a> <a id="4536" class="Symbol">(</a><a id="4537" href="#4468" class="Bound">inj</a> <a id="4541" href="../code/fininj/Agda.Builtin.Unit.html#174" class="InductiveConstructor">tt</a><a id="4543" class="Symbol">)</a> <a id="4545" class="Symbol">(</a><a id="4546" href="#4468" class="Bound">inj</a> <a id="4550" href="#4480" class="Bound">p</a><a id="4551" class="Symbol">)</a>
</pre>
<p>This will give us the inductive step for the overall proof. Notice the absence of any <code>cong</code>s or the like: the computation behaviour of <code>≢ᶠ</code> saves us on that particular front. Also we don’t have to use <code>⊥-elim</code> at any point: again, because of the computation behaviour of <code>≢ᶠ</code>, Agda knows that certain cases are unreachable, so we don’t even have to define them.</p>
<p>Next, we derive the proof that a <code>Fin</code> cannot inject into a smaller <code>Fin</code>.</p>
<pre class="Agda"><a id="¬plus-inj"></a><a id="5006" href="#5006" class="../code/fininj/Function">¬plus-inj</a> <a id="5016" class="Symbol">:</a> <a id="5018" class="Symbol">∀</a> <a id="5020" href="#5020" class="Bound">n</a> <a id="5022" href="#5022" class="Bound">m</a> <a id="5024" class="Symbol">→</a> <a id="5026" href="../code/fininj/Relation.Nullary.html#653" class="../code/fininj/Function Operator">¬</a> <a id="5028" class="Symbol">(</a><a id="5029" href="../code/fininj/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="5033" class="Symbol">(</a><a id="5034" href="#5020" class="Bound">n</a> <a id="5036" href="../code/fininj/Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="5038" href="#5022" class="Bound">m</a><a id="5039" class="Symbol">)</a> <a id="5041" href="#3381" class="../code/fininj/Function Operator">F↣</a> <a id="5044" href="#5022" class="Bound">m</a><a id="5045" class="Symbol">)</a>
<a id="5047" href="#5006" class="../code/fininj/Function">¬plus-inj</a> <a id="5057" href="../code/fininj/Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a>    <a id="5065" class="Symbol">(</a><a id="5066" href="../code/fininj/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="5070" href="#5070" class="Bound">m</a><a id="5071" class="Symbol">)</a> <a id="5073" href="#5073" class="Bound">inj</a>       <a id="5083" class="Symbol">=</a> <a id="5085" href="#5006" class="../code/fininj/Function">¬plus-inj</a> <a id="5095" href="../code/fininj/Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a> <a id="5100" href="#5070" class="Bound">m</a> <a id="5102" class="Symbol">(</a><a id="5103" href="#4359" class="../code/fininj/Function">shrink</a> <a id="5110" href="#5073" class="Bound">inj</a><a id="5113" class="Symbol">)</a>
<a id="5115" href="#5006" class="../code/fininj/Function">¬plus-inj</a> <a id="5125" class="Symbol">(</a><a id="5126" href="../code/fininj/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="5130" href="#5130" class="Bound">n</a><a id="5131" class="Symbol">)</a> <a id="5133" href="#5133" class="Bound">m</a>       <a id="5141" class="Symbol">(</a><a id="5142" href="#5142" class="Bound">f</a> <a id="5144" href="../code/fininj/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="5146" href="#5146" class="Bound">inj</a><a id="5149" class="Symbol">)</a> <a id="5151" class="Symbol">=</a> <a id="5153" href="#5006" class="../code/fininj/Function">¬plus-inj</a> <a id="5163" href="#5130" class="Bound">n</a> <a id="5165" href="#5133" class="Bound">m</a> <a id="5167" class="Symbol">(</a><a id="5168" href="#5142" class="Bound">f</a> <a id="5170" href="../code/fininj/Function.Base.html#992" class="../code/fininj/Function Operator">∘</a> <a id="5172" href="../code/fininj/Data.Fin.Base.html#1114" class="InductiveConstructor">suc</a> <a id="5176" href="../code/fininj/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="5178" href="#5146" class="Bound">inj</a><a id="5181" class="Symbol">)</a>
<a id="5183" href="#5006" class="../code/fininj/Function">¬plus-inj</a> <a id="5193" href="../code/fininj/Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a>    <a id="5201" href="../code/fininj/Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a>    <a id="5209" class="Symbol">(</a><a id="5210" href="#5210" class="Bound">f</a> <a id="5212" href="../code/fininj/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="5214" class="Symbol">_)</a> <a id="5217" class="Keyword">with</a> <a id="5222" href="#5210" class="Bound">f</a> <a id="5224" href="../code/fininj/Data.Fin.Base.html#1083" class="InductiveConstructor">zero</a>
<a id="5229" class="Symbol">...</a> <a id="5233" class="Symbol">|</a> <a id="5235" class="Symbol">()</a>
</pre>
<p>That’s actually the bulk of the proof done: the rest is Lego, joining up the pieces and types. First, we give the normal definition of injectivity:</p>
<pre class="Agda"><a id="Injective"></a><a id="5400" href="#5400" class="../code/fininj/Function">Injective</a> <a id="5410" class="Symbol">:</a> <a id="5412" class="Symbol">∀</a> <a id="5414" class="Symbol">{</a><a id="5415" href="#5415" class="Bound">a</a> <a id="5417" href="#5417" class="Bound">b</a><a id="5418" class="Symbol">}</a> <a id="5420" class="Symbol">{</a><a id="5421" href="#5421" class="Bound">A</a> <a id="5423" class="Symbol">:</a> <a id="5425" class="PrimitiveType">Set</a> <a id="5429" href="#5415" class="Bound">a</a><a id="5430" class="Symbol">}</a> <a id="5432" class="Symbol">{</a><a id="5433" href="#5433" class="Bound">B</a> <a id="5435" class="Symbol">:</a> <a id="5437" class="PrimitiveType">Set</a> <a id="5441" href="#5417" class="Bound">b</a><a id="5442" class="Symbol">}</a> <a id="5444" class="Symbol">→</a> <a id="5446" class="Symbol">(</a><a id="5447" href="#5421" class="Bound">A</a> <a id="5449" class="Symbol">→</a> <a id="5451" href="#5433" class="Bound">B</a><a id="5452" class="Symbol">)</a> <a id="5454" class="Symbol">→</a> <a id="5456" class="PrimitiveType">Set</a> <a id="5460" class="Symbol">_</a>
<a id="5462" href="#5400" class="../code/fininj/Function">Injective</a> <a id="5472" href="#5472" class="Bound">f</a> <a id="5474" class="Symbol">=</a> <a id="5476" class="Symbol">∀</a> <a id="5478" class="Symbol">{</a><a id="5479" href="#5479" class="Bound">x</a> <a id="5481" href="#5481" class="Bound">y</a><a id="5482" class="Symbol">}</a> <a id="5484" class="Symbol">→</a> <a id="5486" href="#5472" class="Bound">f</a> <a id="5488" href="#5479" class="Bound">x</a> <a id="5490" href="../code/fininj/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="5492" href="#5472" class="Bound">f</a> <a id="5494" href="#5481" class="Bound">y</a> <a id="5496" class="Symbol">→</a> <a id="5498" href="#5479" class="Bound">x</a> <a id="5500" href="../code/fininj/Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="5502" href="#5481" class="Bound">y</a>

<a id="_↣_"></a><a id="5505" href="#5505" class="../code/fininj/Function Operator">_↣_</a> <a id="5509" class="Symbol">:</a> <a id="5511" class="Symbol">∀</a> <a id="5513" class="Symbol">{</a><a id="5514" href="#5514" class="Bound">a</a> <a id="5516" href="#5516" class="Bound">b</a><a id="5517" class="Symbol">}</a> <a id="5519" class="Symbol">→</a> <a id="5521" class="PrimitiveType">Set</a> <a id="5525" href="#5514" class="Bound">a</a> <a id="5527" class="Symbol">→</a> <a id="5529" class="PrimitiveType">Set</a> <a id="5533" href="#5516" class="Bound">b</a> <a id="5535" class="Symbol">→</a> <a id="5537" class="PrimitiveType">Set</a> <a id="5541" class="Symbol">_</a>
<a id="5543" href="#5543" class="Bound">A</a> <a id="5545" href="#5505" class="../code/fininj/Function Operator">↣</a> <a id="5547" href="#5547" class="Bound">B</a> <a id="5549" class="Symbol">=</a> <a id="5551" href="../code/fininj/Agda.Builtin.Sigma.html#139" class="Record">Σ</a> <a id="5553" class="Symbol">(</a><a id="5554" href="#5543" class="Bound">A</a> <a id="5556" class="Symbol">→</a> <a id="5558" href="#5547" class="Bound">B</a><a id="5559" class="Symbol">)</a> <a id="5561" href="#5400" class="../code/fininj/Function">Injective</a>
</pre>
<p>Then we convert from one to the other:</p>
<pre class="Agda"><a id="toFin-inj"></a><a id="5624" href="#5624" class="../code/fininj/Function">toFin-inj</a> <a id="5634" class="Symbol">:</a> <a id="5636" class="Symbol">(</a><a id="5637" href="../code/fininj/Data.Fin.Base.html#1061" class="Datatype">Fin</a> <a id="5641" href="#963" class="Generalizable">n</a> <a id="5643" href="#5505" class="../code/fininj/Function Operator">↣</a> <a id="5645" href="../code/fininj/Data.Fin.Base.html#1061" class="Datatype">Fin</a> <a id="5649" href="#965" class="Generalizable">m</a><a id="5650" class="Symbol">)</a> <a id="5652" class="Symbol">→</a> <a id="5654" href="#963" class="Generalizable">n</a> <a id="5656" href="#3381" class="../code/fininj/Function Operator">F↣</a> <a id="5659" href="#965" class="Generalizable">m</a>
<a id="5661" href="#5624" class="../code/fininj/Function">toFin-inj</a> <a id="5671" href="#5671" class="Bound">f</a> <a id="5673" class="Symbol">.</a><a id="5674" href="../code/fininj/Agda.Builtin.Sigma.html#225" class="Field">proj₁</a> <a id="5680" class="Symbol">=</a> <a id="5682" href="#5671" class="Bound">f</a> <a id="5684" class="Symbol">.</a><a id="5685" href="../code/fininj/Agda.Builtin.Sigma.html#225" class="Field">proj₁</a>
<a id="5691" href="#5624" class="../code/fininj/Function">toFin-inj</a> <a id="5701" class="Symbol">(</a><a id="5702" href="#5702" class="Bound">f</a> <a id="5704" href="../code/fininj/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="5706" href="#5706" class="Bound">inj</a><a id="5709" class="Symbol">)</a> <a id="5711" class="Symbol">.</a><a id="5712" href="../code/fininj/Agda.Builtin.Sigma.html#237" class="Field">proj₂</a> <a id="5718" class="Symbol">{</a><a id="5719" href="#5719" class="Bound">x</a><a id="5720" class="Symbol">}</a> <a id="5722" class="Symbol">{</a><a id="5723" href="#5723" class="Bound">y</a><a id="5724" class="Symbol">}</a> <a id="5726" href="#5726" class="Bound">x≢ᶠy</a> <a id="5731" class="Keyword">with</a> <a id="5736" href="#5719" class="Bound">x</a> <a id="5738" href="../code/fininj/Data.Fin.Properties.html#1997" class="../code/fininj/Function Operator">≟</a> <a id="5740" href="#5723" class="Bound">y</a> <a id="5742" class="Symbol">|</a> <a id="5744" href="#5702" class="Bound">f</a> <a id="5746" href="#5719" class="Bound">x</a> <a id="5748" href="../code/fininj/Data.Fin.Properties.html#1997" class="../code/fininj/Function Operator">≟</a> <a id="5750" href="#5702" class="Bound">f</a> <a id="5752" href="#5723" class="Bound">y</a>
<a id="5754" class="Symbol">...</a> <a id="5758" class="Symbol">|</a> <a id="5760" href="../code/fininj/Relation.Nullary.html#1682" class="InductiveConstructor">no</a> <a id="5763" href="#5763" class="Bound">¬p</a> <a id="5766" class="Symbol">|</a> <a id="5768" href="../code/fininj/Relation.Nullary.html#1645" class="InductiveConstructor">yes</a> <a id="5772" href="#5772" class="Bound">p</a> <a id="5774" class="Symbol">=</a> <a id="5776" href="#5763" class="Bound">¬p</a> <a id="5779" class="Symbol">(</a><a id="5780" class="Bound">inj</a> <a id="5784" href="#5772" class="Bound">p</a><a id="5785" class="Symbol">)</a>
<a id="5787" class="Symbol">...</a> <a id="5791" class="Symbol">|</a> <a id="5793" href="../code/fininj/Relation.Nullary.html#1682" class="InductiveConstructor">no</a> <a id="5796" class="Symbol">_</a>  <a id="5799" class="Symbol">|</a> <a id="5801" href="../code/fininj/Relation.Nullary.html#1682" class="InductiveConstructor">no</a> <a id="5804" class="Symbol">_</a>  <a id="5807" class="Symbol">=</a> <a id="5809" href="../code/fininj/Agda.Builtin.Unit.html#174" class="InductiveConstructor">tt</a>
</pre>
<p>And finally we have our proof:</p>
<pre class="Agda"><a id="n≢sn+m"></a><a id="5857" href="#5857" class="../code/fininj/Function">n≢sn+m</a> <a id="5864" class="Symbol">:</a> <a id="5866" class="Symbol">∀</a> <a id="5868" href="#5868" class="Bound">n</a> <a id="5870" href="#5870" class="Bound">m</a> <a id="5872" class="Symbol">→</a> <a id="5874" href="../code/fininj/Data.Fin.Base.html#1061" class="Datatype">Fin</a> <a id="5878" href="#5868" class="Bound">n</a> <a id="5880" href="../code/fininj/Relation.Binary.PropositionalEquality.Core.html#840" class="../code/fininj/Function Operator">≢</a> <a id="5882" href="../code/fininj/Data.Fin.Base.html#1061" class="Datatype">Fin</a> <a id="5886" class="Symbol">(</a><a id="5887" href="../code/fininj/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="5891" class="Symbol">(</a><a id="5892" href="#5868" class="Bound">n</a> <a id="5894" href="../code/fininj/Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="5896" href="#5870" class="Bound">m</a><a id="5897" class="Symbol">))</a>
<a id="5900" href="#5857" class="../code/fininj/Function">n≢sn+m</a> <a id="5907" href="#5907" class="Bound">n</a> <a id="5909" href="#5909" class="Bound">m</a> <a id="5911" href="#5911" class="Bound">n≡m</a> <a id="5915" class="Symbol">=</a>
  <a id="5919" href="#5006" class="../code/fininj/Function">¬plus-inj</a> <a id="5929" href="#5909" class="Bound">m</a> <a id="5931" href="#5907" class="Bound">n</a> <a id="5933" class="Symbol">(</a><a id="5934" href="#5624" class="../code/fininj/Function">toFin-inj</a> <a id="5944" class="Symbol">(</a><a id="5945" href="../code/fininj/Relation.Binary.PropositionalEquality.Core.html#1076" class="../code/fininj/Function">subst</a> <a id="5951" class="Symbol">(</a><a id="5952" href="#5505" class="../code/fininj/Function Operator">_↣</a> <a id="5955" href="../code/fininj/Data.Fin.Base.html#1061" class="Datatype">Fin</a> <a id="5959" href="#5907" class="Bound">n</a><a id="5960" class="Symbol">)</a>
                             <a id="5991" class="Symbol">(</a><a id="5992" href="#5911" class="Bound">n≡m</a> <a id="5996" href="../code/fininj/Function.Base.html#3828" class="../code/fininj/Function Operator">⟨</a> <a id="5998" href="../code/fininj/Relation.Binary.PropositionalEquality.Core.html#1025" class="../code/fininj/Function">trans</a> <a id="6004" href="../code/fininj/Function.Base.html#3828" class="../code/fininj/Function Operator">⟩</a> <a id="6006" href="../code/fininj/Relation.Binary.PropositionalEquality.Core.html#1131" class="../code/fininj/Function">cong</a> <a id="6011" class="Symbol">(</a><a id="6012" href="../code/fininj/Data.Fin.Base.html#1061" class="Datatype">Fin</a> <a id="6016" href="../code/fininj/Function.Base.html#992" class="../code/fininj/Function Operator">∘</a> <a id="6018" href="../code/fininj/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a><a id="6021" class="Symbol">)</a> <a id="6023" class="Symbol">(</a><a id="6024" href="../code/fininj/Data.Nat.Properties.html#12828" class="../code/fininj/Function">+-comm</a> <a id="6031" href="#5907" class="Bound">n</a> <a id="6033" href="#5909" class="Bound">m</a><a id="6034" class="Symbol">))</a>
                             <a id="6066" class="Symbol">(</a><a id="6067" href="../code/fininj/Function.Base.html#615" class="../code/fininj/Function">id</a> <a id="6070" href="../code/fininj/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="6072" href="../code/fininj/Function.Base.html#615" class="../code/fininj/Function">id</a><a id="6074" class="Symbol">)))</a>

<a id="Fin-inj"></a><a id="6079" href="#6079" class="../code/fininj/Function">Fin-inj</a> <a id="6087" class="Symbol">:</a> <a id="6089" href="#5400" class="../code/fininj/Function">Injective</a> <a id="6099" href="../code/fininj/Data.Fin.Base.html#1061" class="Datatype">Fin</a>
<a id="6103" href="#6079" class="../code/fininj/Function">Fin-inj</a> <a id="6111" class="Symbol">{</a><a id="6112" href="#6112" class="Bound">n</a><a id="6113" class="Symbol">}</a> <a id="6115" class="Symbol">{</a><a id="6116" href="#6116" class="Bound">m</a><a id="6117" class="Symbol">}</a> <a id="6119" href="#6119" class="Bound">n≡m</a> <a id="6123" class="Keyword">with</a> <a id="6128" href="../code/fininj/Data.Nat.Base.html#3697" class="../code/fininj/Function">compare</a> <a id="6136" href="#6112" class="Bound">n</a> <a id="6138" href="#6116" class="Bound">m</a>
<a id="6140" class="Symbol">...</a> <a id="6144" class="Symbol">|</a> <a id="6146" href="../code/fininj/Data.Nat.Base.html#3620" class="InductiveConstructor">equal</a> <a id="6152" class="Symbol">_</a> <a id="6154" class="Symbol">=</a> <a id="6156" href="../code/fininj/Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
<a id="6161" class="Symbol">...</a> <a id="6165" class="Symbol">|</a> <a id="6167" href="../code/fininj/Data.Nat.Base.html#3575" class="InductiveConstructor">less</a>    <a id="6175" class="Bound">n</a> <a id="6177" href="#6177" class="Bound">k</a> <a id="6179" class="Symbol">=</a> <a id="6181" href="../code/fininj/Data.Empty.html#275" class="../code/fininj/Function">⊥-elim</a> <a id="6188" class="Symbol">(</a><a id="6189" href="#5857" class="../code/fininj/Function">n≢sn+m</a> <a id="6196" class="Bound">n</a> <a id="6198" href="#6177" class="Bound">k</a> <a id="6200" class="Bound">n≡m</a><a id="6203" class="Symbol">)</a>
<a id="6205" class="Symbol">...</a> <a id="6209" class="Symbol">|</a> <a id="6211" href="../code/fininj/Data.Nat.Base.html#3653" class="InductiveConstructor">greater</a> <a id="6219" class="Bound">m</a> <a id="6221" href="#6221" class="Bound">k</a> <a id="6223" class="Symbol">=</a> <a id="6225" href="../code/fininj/Data.Empty.html#275" class="../code/fininj/Function">⊥-elim</a> <a id="6232" class="Symbol">(</a><a id="6233" href="#5857" class="../code/fininj/Function">n≢sn+m</a> <a id="6240" class="Bound">m</a> <a id="6242" href="#6221" class="Bound">k</a> <a id="6244" class="Symbol">(</a><a id="6245" href="../code/fininj/Relation.Binary.PropositionalEquality.Core.html#980" class="../code/fininj/Function">sym</a> <a id="6249" class="Bound">n≡m</a><a id="6252" class="Symbol">))</a>

<a id="6256" href="#6256" class="../code/fininj/Function">_</a> <a id="6258" class="Symbol">:</a> <a id="6260" href="#1153" class="../code/fininj/Function">Goal</a>
<a id="6265" class="Symbol">_</a> <a id="6267" class="Symbol">=</a> <a id="6269" href="#6079" class="../code/fininj/Function">Fin-inj</a>
</pre>
<p>All in all, the proof is about 36 lines, which is pretty short for what it does.</p>
]]></description>
    <pubDate>Fri, 15 Nov 2019 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2019-11-15-small-proof-fin-inj.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>How to do Binary Random-Access Lists Simply</title>
    <link>https://doisinkidney.com/posts/2019-11-02-how-to-binary-random-access-list.html</link>
    <description><![CDATA[<div class="info">
    Posted on November  2, 2019
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Agda.html">Agda</a>
    
</div>

<p>“Heterogeneous Random-Access Lists” by Wouter Swierstra <span class="citation" data-cites="swierstraHeterogeneousRandomaccessLists2019">(<a href="#ref-swierstraHeterogeneousRandomaccessLists2019">2019</a>)</span> describes how to write a simple binary random-access list <span class="citation" data-cites="okasakiPurelyFunctionalRandomaccess1995">(Okasaki <a href="#ref-okasakiPurelyFunctionalRandomaccess1995">1995</a>)</span> to use as a heterogeneous tuple. If you haven’t tried to implement the data structure described in the paper before, you might not realise the just how <em>elegant</em> the implementation is. The truth is that arriving at the definitions presented is difficult: behind every simple function is a litany of complex and ugly alternatives that had to be tried and discarded first before settling on the final answer.</p>
<p>In this post I want to go through a very similar structure, with special focus on the “wrong turns” in implementation which can lead to headache.</p>
<!--
<pre class="Agda"><a id="768" class="Symbol">{-#</a> <a id="772" class="Keyword">OPTIONS</a> <a id="780" class="Pragma">--cubical</a> <a id="790" class="Pragma">--safe</a> <a id="797" class="Symbol">#-}</a>

<a id="802" class="Keyword">open</a> <a id="807" class="Keyword">import</a> <a id="814" href="../code/binary/Prelude.html" class="Module">Prelude</a>

<a id="823" class="Keyword">variable</a>
  <a id="834" href="#834" class="Generalizable">t</a> <a id="836" class="Symbol">:</a> <a id="838" href="../code/binary/Agda.Primitive.html#408" class="Postulate">Level</a>
  <a id="846" href="#846" class="Generalizable">T</a> <a id="848" class="Symbol">:</a> <a id="850" href="../code/binary/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="852" class="Symbol">→</a> <a id="854" class="PrimitiveType">Set</a> <a id="858" href="#834" class="Generalizable">t</a>
  <a id="862" href="#862" class="Generalizable">p</a> <a id="864" class="Symbol">:</a> <a id="866" href="../code/binary/Agda.Primitive.html#408" class="Postulate">Level</a>
  <a id="874" href="#874" class="Generalizable">P</a> <a id="876" class="Symbol">:</a> <a id="878" class="PrimitiveType">Set</a> <a id="882" href="#862" class="Generalizable">p</a>
</pre>-->
<h1 id="two-proofs-on-ℕ-and-how-to-avoid-them">Two Proofs on ℕ, and How to Avoid Them</h1>
<p>Here are a couple of important identities on ℕ:</p>
<pre class="Agda"><a id="+0"></a><a id="992" href="#992" class="Function">+0</a> <a id="995" class="Symbol">:</a> <a id="997" class="Symbol">∀</a> <a id="999" href="#999" class="Bound">n</a> <a id="1001" class="Symbol">→</a> <a id="1003" href="#999" class="Bound">n</a> <a id="1005" href="../code/binary/Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="1007" href="../code/binary/Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a> <a id="1012" href="../code/binary/Agda.Builtin.Cubical.Path.html#353" class="Function Operator">≡</a> <a id="1014" href="#999" class="Bound">n</a>
<a id="1016" href="#992" class="Function">+0</a> <a id="1019" href="../code/binary/Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a>    <a id="1027" class="Symbol">=</a> <a id="1029" href="../code/binary/Cubical.Foundations.Prelude.html#856" class="Function">refl</a>
<a id="1034" href="#992" class="Function">+0</a> <a id="1037" class="Symbol">(</a><a id="1038" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="1042" href="#1042" class="Bound">n</a><a id="1043" class="Symbol">)</a> <a id="1045" class="Symbol">=</a> <a id="1047" href="../code/binary/Cubical.Foundations.Prelude.html#1057" class="Function">cong</a> <a id="1052" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="1056" class="Symbol">(</a><a id="1057" href="#992" class="Function">+0</a> <a id="1060" href="#1042" class="Bound">n</a><a id="1061" class="Symbol">)</a>

<a id="+-suc"></a><a id="1064" href="#1064" class="Function">+-suc</a> <a id="1070" class="Symbol">:</a> <a id="1072" class="Symbol">∀</a> <a id="1074" href="#1074" class="Bound">n</a> <a id="1076" href="#1076" class="Bound">m</a> <a id="1078" class="Symbol">→</a> <a id="1080" href="#1074" class="Bound">n</a> <a id="1082" href="../code/binary/Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="1084" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="1088" href="#1076" class="Bound">m</a> <a id="1090" href="../code/binary/Agda.Builtin.Cubical.Path.html#353" class="Function Operator">≡</a> <a id="1092" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="1096" href="#1074" class="Bound">n</a> <a id="1098" href="../code/binary/Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="1100" href="#1076" class="Bound">m</a>
<a id="1102" href="#1064" class="Function">+-suc</a> <a id="1108" href="../code/binary/Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a>    <a id="1116" href="#1116" class="Bound">m</a> <a id="1118" class="Symbol">=</a> <a id="1120" href="../code/binary/Cubical.Foundations.Prelude.html#856" class="Function">refl</a>
<a id="1125" href="#1064" class="Function">+-suc</a> <a id="1131" class="Symbol">(</a><a id="1132" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="1136" href="#1136" class="Bound">n</a><a id="1137" class="Symbol">)</a> <a id="1139" href="#1139" class="Bound">m</a> <a id="1141" class="Symbol">=</a> <a id="1143" href="../code/binary/Cubical.Foundations.Prelude.html#1057" class="Function">cong</a> <a id="1148" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="1152" class="Symbol">(</a><a id="1153" href="#1064" class="Function">+-suc</a> <a id="1159" href="#1136" class="Bound">n</a> <a id="1161" href="#1139" class="Bound">m</a><a id="1162" class="Symbol">)</a>
</pre>
<p>These two show up all the time as proof obligations from the compiler (i.e. “couldn’t match type <code>n + suc m</code> with <code>suc n + m</code>”). The solution is obvious, right? <code>subst</code> in one of the proofs above and you’re on your way. Wait! There might be a better way.</p>
<p>We’re going to look at reversing a vector as an example. We have a normal-looking length-indexed vector:</p>
<pre class="Agda"><a id="1539" class="Keyword">infixr</a> <a id="1546" class="Number">5</a> <a id="1548" href="#7886" class="InductiveConstructor Operator">_∷_</a>
<a id="1552" class="Keyword">data</a> <a id="Vec"></a><a id="1557" href="#1557" class="Datatype">Vec</a> <a id="1561" class="Symbol">(</a><a id="1562" href="#1562" class="Bound">A</a> <a id="1564" class="Symbol">:</a> <a id="1566" class="PrimitiveType">Set</a> <a id="1570" href="../code/binary/Prelude.html#454" class="Generalizable">a</a><a id="1571" class="Symbol">)</a> <a id="1573" class="Symbol">:</a> <a id="1575" href="../code/binary/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="1577" class="Symbol">→</a> <a id="1579" class="PrimitiveType">Set</a> <a id="1583" href="#1570" class="Bound">a</a> <a id="1585" class="Keyword">where</a>
  <a id="Vec.[]"></a><a id="1593" href="#1593" class="InductiveConstructor">[]</a> <a id="1596" class="Symbol">:</a> <a id="1598" href="#1557" class="Datatype">Vec</a> <a id="1602" href="#1562" class="Bound">A</a> <a id="1604" href="../code/binary/Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a>
  <a id="Vec._∷_"></a><a id="1611" href="#1611" class="InductiveConstructor Operator">_∷_</a> <a id="1615" class="Symbol">:</a> <a id="1617" href="#1562" class="Bound">A</a> <a id="1619" class="Symbol">→</a> <a id="1621" href="#1557" class="Datatype">Vec</a> <a id="1625" href="#1562" class="Bound">A</a> <a id="1627" href="../code/binary/Prelude.html#506" class="Generalizable">n</a> <a id="1629" class="Symbol">→</a> <a id="1631" href="#1557" class="Datatype">Vec</a> <a id="1635" href="#1562" class="Bound">A</a> <a id="1637" class="Symbol">(</a><a id="1638" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="1642" href="../code/binary/Prelude.html#506" class="Generalizable">n</a><a id="1643" class="Symbol">)</a>
</pre>
<p>Reversing a list is easy: we do it the standard way, in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n)</annotation></semantics></math> time, with an accumulator:</p>
<pre class="Agda"><a id="list-reverse"></a><a id="1759" href="#1759" class="Function">list-reverse</a> <a id="1772" class="Symbol">:</a> <a id="1774" href="../code/binary/Prelude.html#760" class="Datatype">List</a> <a id="1779" href="../code/binary/Prelude.html#470" class="Generalizable">A</a> <a id="1781" class="Symbol">→</a> <a id="1783" href="../code/binary/Prelude.html#760" class="Datatype">List</a> <a id="1788" href="../code/binary/Prelude.html#470" class="Generalizable">A</a>
<a id="1790" href="#1759" class="Function">list-reverse</a> <a id="1803" class="Symbol">=</a> <a id="1805" href="#1821" class="Function">go</a> <a id="1808" href="../code/binary/Prelude.html#793" class="InductiveConstructor">[]</a>
  <a id="1813" class="Keyword">where</a>
  <a id="1821" href="#1821" class="Function">go</a> <a id="1824" class="Symbol">:</a> <a id="1826" href="../code/binary/Prelude.html#760" class="Datatype">List</a> <a id="1831" href="../code/binary/Prelude.html#470" class="Generalizable">A</a> <a id="1833" class="Symbol">→</a> <a id="1835" href="../code/binary/Prelude.html#760" class="Datatype">List</a> <a id="1840" href="../code/binary/Prelude.html#470" class="Generalizable">A</a> <a id="1842" class="Symbol">→</a> <a id="1844" href="../code/binary/Prelude.html#760" class="Datatype">List</a> <a id="1849" href="../code/binary/Prelude.html#470" class="Generalizable">A</a>
  <a id="1853" href="#1821" class="Function">go</a> <a id="1856" href="#1856" class="Bound">acc</a> <a id="1860" href="../code/binary/Prelude.html#793" class="InductiveConstructor">[]</a> <a id="1863" class="Symbol">=</a> <a id="1865" href="#1856" class="Bound">acc</a>
  <a id="1871" href="#1821" class="Function">go</a> <a id="1874" href="#1874" class="Bound">acc</a> <a id="1878" class="Symbol">(</a><a id="1879" href="#1879" class="Bound">x</a> <a id="1881" href="../code/binary/Prelude.html#807" class="InductiveConstructor Operator">∷</a> <a id="1883" href="#1883" class="Bound">xs</a><a id="1885" class="Symbol">)</a> <a id="1887" class="Symbol">=</a> <a id="1889" href="#1821" class="Function">go</a> <a id="1892" class="Symbol">(</a><a id="1893" href="#1879" class="Bound">x</a> <a id="1895" href="../code/binary/Prelude.html#807" class="InductiveConstructor Operator">∷</a> <a id="1897" href="#1874" class="Bound">acc</a><a id="1900" class="Symbol">)</a> <a id="1902" href="#1883" class="Bound">xs</a>
</pre>
<p>Transferring over to a vector and we see our friends <code>+-suc</code> and <code>+0</code>.</p>
<pre class="Agda"><a id="vec-reverse₁"></a><a id="1990" href="#1990" class="Function">vec-reverse₁</a> <a id="2003" class="Symbol">:</a> <a id="2005" href="#1557" class="Datatype">Vec</a> <a id="2009" href="../code/binary/Prelude.html#470" class="Generalizable">A</a> <a id="2011" href="../code/binary/Prelude.html#506" class="Generalizable">n</a> <a id="2013" class="Symbol">→</a> <a id="2015" href="#1557" class="Datatype">Vec</a> <a id="2019" href="../code/binary/Prelude.html#470" class="Generalizable">A</a> <a id="2021" href="../code/binary/Prelude.html#506" class="Generalizable">n</a>
<a id="2023" href="#1990" class="Function">vec-reverse₁</a> <a id="2036" href="#2036" class="Bound">xs</a> <a id="2039" class="Symbol">=</a> <a id="2041" href="../code/binary/Cubical.Foundations.Prelude.html#4264" class="Function">subst</a> <a id="2047" class="Symbol">(</a><a id="2048" href="#1557" class="Datatype">Vec</a> <a id="2052" class="Symbol">_)</a> <a id="2055" class="Symbol">(</a><a id="2056" href="#992" class="Function">+0</a> <a id="2059" class="Symbol">_)</a> <a id="2062" class="Symbol">(</a><a id="2063" href="#2083" class="Function">go</a> <a id="2066" href="#1593" class="InductiveConstructor">[]</a> <a id="2069" href="#2036" class="Bound">xs</a><a id="2071" class="Symbol">)</a>
  <a id="2075" class="Keyword">where</a>
  <a id="2083" href="#2083" class="Function">go</a> <a id="2086" class="Symbol">:</a> <a id="2088" href="#1557" class="Datatype">Vec</a> <a id="2092" href="../code/binary/Prelude.html#470" class="Generalizable">A</a> <a id="2094" href="../code/binary/Prelude.html#506" class="Generalizable">n</a> <a id="2096" class="Symbol">→</a> <a id="2098" href="#1557" class="Datatype">Vec</a> <a id="2102" href="../code/binary/Prelude.html#470" class="Generalizable">A</a> <a id="2104" href="../code/binary/Prelude.html#508" class="Generalizable">m</a> <a id="2106" class="Symbol">→</a> <a id="2108" href="#1557" class="Datatype">Vec</a> <a id="2112" href="../code/binary/Prelude.html#470" class="Generalizable">A</a> <a id="2114" class="Symbol">(</a><a id="2115" href="../code/binary/Prelude.html#508" class="Generalizable">m</a> <a id="2117" href="../code/binary/Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="2119" href="../code/binary/Prelude.html#506" class="Generalizable">n</a><a id="2120" class="Symbol">)</a>
  <a id="2124" href="#2083" class="Function">go</a> <a id="2127" href="#2127" class="Bound">acc</a> <a id="2131" href="#1593" class="InductiveConstructor">[]</a> <a id="2134" class="Symbol">=</a> <a id="2136" href="#2127" class="Bound">acc</a>
  <a id="2142" href="#2083" class="Function">go</a> <a id="2145" href="#2145" class="Bound">acc</a> <a id="2149" class="Symbol">(</a><a id="2150" href="#2150" class="Bound">x</a> <a id="2152" href="#1611" class="InductiveConstructor Operator">∷</a> <a id="2154" href="#2154" class="Bound">xs</a><a id="2156" class="Symbol">)</a> <a id="2158" class="Symbol">=</a> <a id="2160" href="../code/binary/Cubical.Foundations.Prelude.html#4264" class="Function">subst</a> <a id="2166" class="Symbol">(</a><a id="2167" href="#1557" class="Datatype">Vec</a> <a id="2171" class="Symbol">_)</a> <a id="2174" class="Symbol">(</a><a id="2175" href="#1064" class="Function">+-suc</a> <a id="2181" class="Symbol">_</a> <a id="2183" class="Symbol">_)</a> <a id="2186" class="Symbol">(</a><a id="2187" href="#2083" class="Function">go</a> <a id="2190" class="Symbol">(</a><a id="2191" href="#2150" class="Bound">x</a> <a id="2193" href="#1611" class="InductiveConstructor Operator">∷</a> <a id="2195" href="#2145" class="Bound">acc</a><a id="2198" class="Symbol">)</a> <a id="2200" href="#2154" class="Bound">xs</a><a id="2202" class="Symbol">)</a>
</pre>
<p>The solution, as with so many things, is to use a fold instead of explicit recursion. Folds on vectors are a little more aggressively typed than those on lists:</p>
<pre class="Agda"><a id="vec-foldr"></a><a id="2378" href="#2378" class="Function">vec-foldr</a> <a id="2388" class="Symbol">:</a> <a id="2390" class="Symbol">(</a><a id="2391" href="#2391" class="Bound">B</a> <a id="2393" class="Symbol">:</a> <a id="2395" href="../code/binary/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="2397" class="Symbol">→</a> <a id="2399" href="../code/binary/Cubical.Core.Primitives.html#957" class="Function">Type</a> <a id="2404" href="../code/binary/Prelude.html#456" class="Generalizable">b</a><a id="2405" class="Symbol">)</a>
          <a id="2417" class="Symbol">→</a> <a id="2419" class="Symbol">(∀</a> <a id="2422" class="Symbol">{</a><a id="2423" href="#2423" class="Bound">n</a><a id="2424" class="Symbol">}</a> <a id="2426" class="Symbol">→</a> <a id="2428" href="../code/binary/Prelude.html#470" class="Generalizable">A</a> <a id="2430" class="Symbol">→</a> <a id="2432" href="#2391" class="Bound">B</a> <a id="2434" href="#2423" class="Bound">n</a> <a id="2436" class="Symbol">→</a> <a id="2438" href="#2391" class="Bound">B</a> <a id="2440" class="Symbol">(</a><a id="2441" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="2445" href="#2423" class="Bound">n</a><a id="2446" class="Symbol">))</a>
          <a id="2459" class="Symbol">→</a> <a id="2461" href="#2391" class="Bound">B</a> <a id="2463" href="../code/binary/Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a>
          <a id="2478" class="Symbol">→</a> <a id="2480" href="#1557" class="Datatype">Vec</a> <a id="2484" href="../code/binary/Prelude.html#470" class="Generalizable">A</a> <a id="2486" href="../code/binary/Prelude.html#506" class="Generalizable">n</a>
          <a id="2498" class="Symbol">→</a> <a id="2500" href="#2391" class="Bound">B</a> <a id="2502" href="../code/binary/Prelude.html#506" class="Generalizable">n</a>
<a id="2504" href="#2378" class="Function">vec-foldr</a> <a id="2514" href="#2514" class="Bound">B</a> <a id="2516" href="#2516" class="Bound">f</a> <a id="2518" href="#2518" class="Bound">b</a> <a id="2520" href="#1593" class="InductiveConstructor">[]</a> <a id="2523" class="Symbol">=</a> <a id="2525" href="#2518" class="Bound">b</a>
<a id="2527" href="#2378" class="Function">vec-foldr</a> <a id="2537" href="#2537" class="Bound">B</a> <a id="2539" href="#2539" class="Bound">f</a> <a id="2541" href="#2541" class="Bound">b</a> <a id="2543" class="Symbol">(</a><a id="2544" href="#2544" class="Bound">x</a> <a id="2546" href="#1611" class="InductiveConstructor Operator">∷</a> <a id="2548" href="#2548" class="Bound">xs</a><a id="2550" class="Symbol">)</a> <a id="2552" class="Symbol">=</a> <a id="2554" href="#2539" class="Bound">f</a> <a id="2556" href="#2544" class="Bound">x</a> <a id="2558" class="Symbol">(</a><a id="2559" href="#2378" class="Function">vec-foldr</a> <a id="2569" href="#2537" class="Bound">B</a> <a id="2571" href="#2539" class="Bound">f</a> <a id="2573" href="#2541" class="Bound">b</a> <a id="2575" href="#2548" class="Bound">xs</a><a id="2577" class="Symbol">)</a>
</pre>
<p>We allow the output type to be indexed by the list of the vector. This is a good thing, bear in mind: we need that extra information to properly type <code>reverse</code>.</p>
<p>For reverse, unfortunately, we need a <em>left</em>-leaning fold, which is a little trickier to implement than <code>vec-foldr</code>.</p>
<pre class="Agda"><a id="vec-foldl"></a><a id="2872" href="#2872" class="Function">vec-foldl</a> <a id="2882" class="Symbol">:</a> <a id="2884" class="Symbol">(</a><a id="2885" href="#2885" class="Bound">B</a> <a id="2887" class="Symbol">:</a> <a id="2889" href="../code/binary/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="2891" class="Symbol">→</a> <a id="2893" class="PrimitiveType">Set</a> <a id="2897" href="../code/binary/Prelude.html#456" class="Generalizable">b</a><a id="2898" class="Symbol">)</a>
          <a id="2910" class="Symbol">→</a> <a id="2912" class="Symbol">(∀</a> <a id="2915" class="Symbol">{</a><a id="2916" href="#2916" class="Bound">n</a><a id="2917" class="Symbol">}</a> <a id="2919" class="Symbol">→</a> <a id="2921" href="#2885" class="Bound">B</a> <a id="2923" href="#2916" class="Bound">n</a> <a id="2925" class="Symbol">→</a> <a id="2927" href="../code/binary/Prelude.html#470" class="Generalizable">A</a> <a id="2929" class="Symbol">→</a> <a id="2931" href="#2885" class="Bound">B</a> <a id="2933" class="Symbol">(</a><a id="2934" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="2938" href="#2916" class="Bound">n</a><a id="2939" class="Symbol">))</a>
          <a id="2952" class="Symbol">→</a> <a id="2954" href="#2885" class="Bound">B</a> <a id="2956" href="../code/binary/Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a>
          <a id="2971" class="Symbol">→</a> <a id="2973" href="#1557" class="Datatype">Vec</a> <a id="2977" href="../code/binary/Prelude.html#470" class="Generalizable">A</a> <a id="2979" href="../code/binary/Prelude.html#506" class="Generalizable">n</a>
          <a id="2991" class="Symbol">→</a> <a id="2993" href="#2885" class="Bound">B</a> <a id="2995" href="../code/binary/Prelude.html#506" class="Generalizable">n</a>
<a id="2997" href="#2872" class="Function">vec-foldl</a> <a id="3007" href="#3007" class="Bound">B</a> <a id="3009" href="#3009" class="Bound">f</a> <a id="3011" href="#3011" class="Bound">b</a> <a id="3013" href="#1593" class="InductiveConstructor">[]</a> <a id="3016" class="Symbol">=</a> <a id="3018" href="#3011" class="Bound">b</a>
<a id="3020" href="#2872" class="Function">vec-foldl</a> <a id="3030" href="#3030" class="Bound">B</a> <a id="3032" href="#3032" class="Bound">f</a> <a id="3034" href="#3034" class="Bound">b</a> <a id="3036" class="Symbol">(</a><a id="3037" href="#3037" class="Bound">x</a> <a id="3039" href="#1611" class="InductiveConstructor Operator">∷</a> <a id="3041" href="#3041" class="Bound">xs</a><a id="3043" class="Symbol">)</a> <a id="3045" class="Symbol">=</a> <a id="3047" href="#2872" class="Function">vec-foldl</a> <a id="3057" class="Symbol">(</a><a id="3058" href="#3030" class="Bound">B</a> <a id="3060" href="../code/binary/Prelude.html#942" class="Function Operator">∘</a> <a id="3062" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a><a id="3065" class="Symbol">)</a> <a id="3067" href="#3032" class="Bound">f</a> <a id="3069" class="Symbol">(</a><a id="3070" href="#3032" class="Bound">f</a> <a id="3072" href="#3034" class="Bound">b</a> <a id="3074" href="#3037" class="Bound">x</a><a id="3075" class="Symbol">)</a> <a id="3077" href="#3041" class="Bound">xs</a>
</pre>
<p>With this we can finally <code>reverse</code>.</p>
<pre class="Agda"><a id="vec-reverse"></a><a id="3130" href="#3130" class="Function">vec-reverse</a> <a id="3142" class="Symbol">:</a> <a id="3144" href="#1557" class="Datatype">Vec</a> <a id="3148" href="../code/binary/Prelude.html#470" class="Generalizable">A</a> <a id="3150" href="../code/binary/Prelude.html#506" class="Generalizable">n</a> <a id="3152" class="Symbol">→</a> <a id="3154" href="#1557" class="Datatype">Vec</a> <a id="3158" href="../code/binary/Prelude.html#470" class="Generalizable">A</a> <a id="3160" href="../code/binary/Prelude.html#506" class="Generalizable">n</a>
<a id="3162" href="#3130" class="Function">vec-reverse</a> <a id="3174" class="Symbol">=</a> <a id="3176" href="#2872" class="Function">vec-foldl</a> <a id="3186" class="Symbol">(</a><a id="3187" href="#1557" class="Datatype">Vec</a> <a id="3191" class="Symbol">_)</a> <a id="3194" class="Symbol">(λ</a> <a id="3197" href="#3197" class="Bound">xs</a> <a id="3200" href="#3200" class="Bound">x</a> <a id="3202" class="Symbol">→</a> <a id="3204" href="#3200" class="Bound">x</a> <a id="3206" href="#1611" class="InductiveConstructor Operator">∷</a> <a id="3208" href="#3197" class="Bound">xs</a><a id="3210" class="Symbol">)</a> <a id="3212" href="#1593" class="InductiveConstructor">[]</a>
</pre>
<p>The real trick in this function is that the type of the return value changes as we fold. If you think about it, it’s the same optimisation that we make for the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n)</annotation></semantics></math> reverse on lists: the <code>B</code> type above is the “difference list” in types, allowing us to append on to the end without <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n^2)</annotation></semantics></math> proofs.</p>
<p>As an aside, this same trick can let us type the convolve-TABA <span class="citation" data-cites="danvyThereBackAgain2005 fonerThereBackAgain2016">(Danvy and Goldberg <a href="#ref-danvyThereBackAgain2005">2005</a>; Foner <a href="#ref-fonerThereBackAgain2016">2016</a>)</span> function quite simply:</p>
<pre class="Agda"><a id="convolve"></a><a id="3636" href="#3636" class="Function">convolve</a> <a id="3645" class="Symbol">:</a> <a id="3647" href="#1557" class="Datatype">Vec</a> <a id="3651" href="../code/binary/Prelude.html#470" class="Generalizable">A</a> <a id="3653" href="../code/binary/Prelude.html#506" class="Generalizable">n</a> <a id="3655" class="Symbol">→</a> <a id="3657" href="#1557" class="Datatype">Vec</a> <a id="3661" href="../code/binary/Prelude.html#482" class="Generalizable">B</a> <a id="3663" href="../code/binary/Prelude.html#506" class="Generalizable">n</a> <a id="3665" class="Symbol">→</a> <a id="3667" href="#1557" class="Datatype">Vec</a> <a id="3671" class="Symbol">(</a><a id="3672" href="../code/binary/Prelude.html#470" class="Generalizable">A</a> <a id="3674" href="../code/binary/Prelude.html#621" class="Function Operator">×</a> <a id="3676" href="../code/binary/Prelude.html#482" class="Generalizable">B</a><a id="3677" class="Symbol">)</a> <a id="3679" href="../code/binary/Prelude.html#506" class="Generalizable">n</a>
<a id="3681" href="#3636" class="Function">convolve</a> <a id="3690" class="Symbol">=</a>
  <a id="3694" href="#2872" class="Function">vec-foldl</a>
    <a id="3708" class="Symbol">(λ</a> <a id="3711" href="#3711" class="Bound">n</a> <a id="3713" class="Symbol">→</a> <a id="3715" href="#1557" class="Datatype">Vec</a> <a id="3719" class="Symbol">_</a> <a id="3721" href="#3711" class="Bound">n</a> <a id="3723" class="Symbol">→</a> <a id="3725" href="#1557" class="Datatype">Vec</a> <a id="3729" class="Symbol">_</a> <a id="3731" href="#3711" class="Bound">n</a><a id="3732" class="Symbol">)</a>
    <a id="3738" class="Symbol">(λ</a> <a id="3741" class="Symbol">{</a> <a id="3743" href="#3743" class="Bound">k</a> <a id="3745" href="#3745" class="Bound">x</a> <a id="3747" class="Symbol">(</a><a id="3748" href="#3748" class="Bound">y</a> <a id="3750" href="#1611" class="InductiveConstructor Operator">∷</a> <a id="3752" href="#3752" class="Bound">ys</a><a id="3754" class="Symbol">)</a> <a id="3756" class="Symbol">→</a> <a id="3758" class="Symbol">(</a><a id="3759" href="#3745" class="Bound">x</a> <a id="3761" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="3763" href="#3748" class="Bound">y</a><a id="3764" class="Symbol">)</a> <a id="3766" href="#1611" class="InductiveConstructor Operator">∷</a> <a id="3768" href="#3743" class="Bound">k</a> <a id="3770" href="#3752" class="Bound">ys</a><a id="3772" class="Symbol">})</a>
    <a id="3779" class="Symbol">(λ</a> <a id="3782" href="#3782" class="Bound">_</a> <a id="3784" class="Symbol">→</a> <a id="3786" href="#1593" class="InductiveConstructor">[]</a><a id="3788" class="Symbol">)</a>
</pre>
<h1 id="binary-numbers">Binary Numbers</h1>
<p>Binary numbers come up a lot in dependently-typed programming languages: they offer an alternative representation of ℕ that’s tolerably efficient (well, depending on who’s doing the tolerating). In contrast to the Peano numbers, though, there are a huge number of ways to implement them.</p>
<p>I’m going to recommend one particular implementation over the others, but before I do I want to define a function on ℕ:</p>
<pre class="Agda"><a id="2*"></a><a id="4231" href="#4231" class="Function">2*</a> <a id="4234" class="Symbol">:</a> <a id="4236" href="../code/binary/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="4238" class="Symbol">→</a> <a id="4240" href="../code/binary/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a>
<a id="4242" href="#4231" class="Function">2*</a> <a id="4245" href="../code/binary/Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a> <a id="4250" class="Symbol">=</a> <a id="4252" href="../code/binary/Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a>
<a id="4257" href="#4231" class="Function">2*</a> <a id="4260" class="Symbol">(</a><a id="4261" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="4265" href="#4265" class="Bound">n</a><a id="4266" class="Symbol">)</a> <a id="4268" class="Symbol">=</a> <a id="4270" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="4274" class="Symbol">(</a><a id="4275" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="4279" class="Symbol">(</a><a id="4280" href="#4231" class="Function">2*</a> <a id="4283" href="#4265" class="Bound">n</a><a id="4284" class="Symbol">))</a>
</pre>
<p>In all of the implementations of binary numbers we’ll need a function like this. It is absolutely crucial that it is defined in the way above: the other obvious definition (<code>2* n = n + n</code>) is a nightmare for proofs.</p>
<p>Right, now on to some actual binary numbers. The obvious way (a list of bits) is insufficient, as it allows multiple representations of the same number (because of the trailing zeroes). Picking a more clever implementation is tricky, though. One way splits it into two types:</p>
<pre class="Agda"><a id="4794" class="Keyword">module</a> <a id="OneTerminated"></a><a id="4801" href="#4801" class="Module">OneTerminated</a> <a id="4815" class="Keyword">where</a>
  <a id="4823" class="Keyword">infixl</a> <a id="4830" class="Number">5</a> <a id="4832" href="#4893" class="InductiveConstructor Operator">_0ᵇ</a> <a id="4836" href="#4897" class="InductiveConstructor Operator">_1ᵇ</a>
  <a id="4842" class="Keyword">infixr</a> <a id="4849" class="Number">4</a> <a id="4851" href="#4949" class="InductiveConstructor Operator">𝕓_</a>

  <a id="4857" class="Keyword">data</a> <a id="OneTerminated.𝔹⁺"></a><a id="4862" href="#4862" class="Datatype">𝔹⁺</a> <a id="4865" class="Symbol">:</a> <a id="4867" class="PrimitiveType">Set</a> <a id="4871" class="Keyword">where</a>
    <a id="OneTerminated.𝔹⁺.1ᵇ"></a><a id="4881" href="#4881" class="InductiveConstructor">1ᵇ</a> <a id="4884" class="Symbol">:</a> <a id="4886" href="#4862" class="Datatype">𝔹⁺</a>
    <a id="OneTerminated.𝔹⁺._0ᵇ"></a><a id="4893" href="#4893" class="InductiveConstructor Operator">_0ᵇ</a> <a id="OneTerminated.𝔹⁺._1ᵇ"></a><a id="4897" href="#4897" class="InductiveConstructor Operator">_1ᵇ</a> <a id="4901" class="Symbol">:</a> <a id="4903" href="#4862" class="Datatype">𝔹⁺</a> <a id="4906" class="Symbol">→</a> <a id="4908" href="#4862" class="Datatype">𝔹⁺</a>

  <a id="4914" class="Keyword">data</a> <a id="OneTerminated.𝔹"></a><a id="4919" href="#4919" class="Datatype">𝔹</a> <a id="4921" class="Symbol">:</a> <a id="4923" class="PrimitiveType">Set</a> <a id="4927" class="Keyword">where</a>
    <a id="OneTerminated.𝔹.𝕓0ᵇ"></a><a id="4937" href="#4937" class="InductiveConstructor">𝕓0ᵇ</a> <a id="4941" class="Symbol">:</a> <a id="4943" href="#4919" class="Datatype">𝔹</a>
    <a id="OneTerminated.𝔹.𝕓_"></a><a id="4949" href="#4949" class="InductiveConstructor Operator">𝕓_</a> <a id="4952" class="Symbol">:</a> <a id="4954" href="#4862" class="Datatype">𝔹⁺</a> <a id="4957" class="Symbol">→</a> <a id="4959" href="#4919" class="Datatype">𝔹</a>
</pre>
<p>𝔹⁺ is the strictly positive natural numbers (i.e. the naturals starting from 1). 𝔹 adds a zero to that set. This removes the possibility for trailing zeroes, thereby making this representation unique for every natural number.</p>
<details>
<p><summary>Evaluation is pretty standard</summary></p>
<pre class="Agda">  <a id="OneTerminated.⟦_⇓⟧⁺"></a><a id="5262" href="#5262" class="Function Operator">⟦_⇓⟧⁺</a> <a id="5268" class="Symbol">:</a> <a id="5270" href="#4862" class="Datatype">𝔹⁺</a> <a id="5273" class="Symbol">→</a> <a id="5275" href="../code/binary/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a>
  <a id="5279" href="#5262" class="Function Operator">⟦</a> <a id="5281" href="#4881" class="InductiveConstructor">1ᵇ</a>   <a id="5286" href="#5262" class="Function Operator">⇓⟧⁺</a> <a id="5290" class="Symbol">=</a> <a id="5292" class="Number">1</a>
  <a id="5296" href="#5262" class="Function Operator">⟦</a> <a id="5298" href="#5298" class="Bound">x</a> <a id="5300" href="#4893" class="InductiveConstructor Operator">0ᵇ</a> <a id="5303" href="#5262" class="Function Operator">⇓⟧⁺</a> <a id="5307" class="Symbol">=</a>      <a id="5314" href="#4231" class="Function">2*</a> <a id="5317" href="#5262" class="Function Operator">⟦</a> <a id="5319" href="#5298" class="Bound">x</a> <a id="5321" href="#5262" class="Function Operator">⇓⟧⁺</a>
  <a id="5327" href="#5262" class="Function Operator">⟦</a> <a id="5329" href="#5329" class="Bound">x</a> <a id="5331" href="#4897" class="InductiveConstructor Operator">1ᵇ</a> <a id="5334" href="#5262" class="Function Operator">⇓⟧⁺</a> <a id="5338" class="Symbol">=</a> <a id="5340" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="5344" class="Symbol">(</a><a id="5345" href="#4231" class="Function">2*</a> <a id="5348" href="#5262" class="Function Operator">⟦</a> <a id="5350" href="#5329" class="Bound">x</a> <a id="5352" href="#5262" class="Function Operator">⇓⟧⁺</a><a id="5355" class="Symbol">)</a>

  <a id="OneTerminated.⟦_⇓⟧"></a><a id="5360" href="#5360" class="Function Operator">⟦_⇓⟧</a> <a id="5365" class="Symbol">:</a> <a id="5367" href="#4919" class="Datatype">𝔹</a> <a id="5369" class="Symbol">→</a> <a id="5371" href="../code/binary/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a>
  <a id="5375" href="#5360" class="Function Operator">⟦</a> <a id="5377" href="#4937" class="InductiveConstructor">𝕓0ᵇ</a>  <a id="5382" href="#5360" class="Function Operator">⇓⟧</a> <a id="5385" class="Symbol">=</a> <a id="5387" class="Number">0</a>
  <a id="5391" href="#5360" class="Function Operator">⟦</a> <a id="5393" href="#4949" class="InductiveConstructor Operator">𝕓</a> <a id="5395" href="#5395" class="Bound">x</a>  <a id="5398" href="#5360" class="Function Operator">⇓⟧</a> <a id="5401" class="Symbol">=</a> <a id="5403" href="#5262" class="Function Operator">⟦</a> <a id="5405" href="#5395" class="Bound">x</a> <a id="5407" href="#5262" class="Function Operator">⇓⟧⁺</a>
</pre>
</details>
<p>The odd syntax lets us write binary numbers in the natural way:</p>
<pre class="Agda">  <a id="5503" href="#5503" class="Function">_</a> <a id="5505" class="Symbol">:</a> <a id="5507" href="#5360" class="Function Operator">⟦</a> <a id="5509" href="#4949" class="InductiveConstructor Operator">𝕓</a> <a id="5511" href="#4881" class="InductiveConstructor">1ᵇ</a> <a id="5514" href="#4893" class="InductiveConstructor Operator">0ᵇ</a> <a id="5517" href="#4897" class="InductiveConstructor Operator">1ᵇ</a> <a id="5520" href="#5360" class="Function Operator">⇓⟧</a> <a id="5523" href="../code/binary/Agda.Builtin.Cubical.Path.html#353" class="Function Operator">≡</a> <a id="5525" class="Number">5</a>
  <a id="5529" class="Symbol">_</a> <a id="5531" class="Symbol">=</a> <a id="5533" href="../code/binary/Cubical.Foundations.Prelude.html#856" class="Function">refl</a>

  <a id="5541" href="#5541" class="Function">_</a> <a id="5543" class="Symbol">:</a> <a id="5545" href="#5360" class="Function Operator">⟦</a> <a id="5547" href="#4949" class="InductiveConstructor Operator">𝕓</a> <a id="5549" href="#4881" class="InductiveConstructor">1ᵇ</a> <a id="5552" href="#4893" class="InductiveConstructor Operator">0ᵇ</a> <a id="5555" href="#4893" class="InductiveConstructor Operator">0ᵇ</a> <a id="5558" href="#4897" class="InductiveConstructor Operator">1ᵇ</a> <a id="5561" href="#5360" class="Function Operator">⇓⟧</a> <a id="5564" href="../code/binary/Agda.Builtin.Cubical.Path.html#353" class="Function Operator">≡</a> <a id="5566" class="Number">9</a>
  <a id="5570" class="Symbol">_</a> <a id="5572" class="Symbol">=</a> <a id="5574" href="../code/binary/Cubical.Foundations.Prelude.html#856" class="Function">refl</a>
</pre>
<p>I would actually recommend this representation for most use-cases, especially when you’re using binary numbers “as binary numbers”, rather than as an abstract type for faster computation.</p>
<p>Another clever representation is one I wrote about before: the “gapless” representation. This is far too much trouble for what it’s worth.</p>
<p>Finally, my favourite representation at the moment is <em>zeroless</em>. It has a unique representation for each number, just like the two above, but it is still a list of bits. The difference is that the bits here are 1 and 2, not 0 and 1. I like to reuse types in combination with pattern synonyms (rather than defining new types), as it can often make parallels between different functions clearer.</p>
<pre class="Agda"><a id="Bit"></a><a id="6317" href="#6317" class="Function">Bit</a> <a id="6321" class="Symbol">:</a> <a id="6323" class="PrimitiveType">Set</a>
<a id="6327" href="#6317" class="Function">Bit</a> <a id="6331" class="Symbol">=</a> <a id="6333" href="../code/binary/Prelude.html#1369" class="Datatype">Bool</a>

<a id="6339" class="Keyword">pattern</a> <a id="1ᵇ"></a><a id="6347" href="#6347" class="InductiveConstructor">1ᵇ</a> <a id="6350" class="Symbol">=</a> <a id="6352" href="../code/binary/Prelude.html#1388" class="InductiveConstructor">false</a>
<a id="6358" class="Keyword">pattern</a> <a id="2ᵇ"></a><a id="6366" href="#6366" class="InductiveConstructor">2ᵇ</a> <a id="6369" class="Symbol">=</a> <a id="6371" href="../code/binary/Prelude.html#1403" class="InductiveConstructor">true</a>

<a id="𝔹"></a><a id="6377" href="#6377" class="Function">𝔹</a> <a id="6379" class="Symbol">:</a> <a id="6381" class="PrimitiveType">Set</a>
<a id="6385" href="#6377" class="Function">𝔹</a> <a id="6387" class="Symbol">=</a> <a id="6389" href="../code/binary/Prelude.html#760" class="Datatype">List</a> <a id="6394" href="#6317" class="Function">Bit</a>
</pre>
<!--
<pre class="Agda"><a id="6416" class="Keyword">variable</a>
  <a id="6427" href="#6427" class="Generalizable">d</a> <a id="6429" class="Symbol">:</a> <a id="6431" href="#6317" class="Function">Bit</a>
  <a id="6437" href="#6437" class="Generalizable">ds</a> <a id="6440" class="Symbol">:</a> <a id="6442" href="#6377" class="Function">𝔹</a>
</pre>-->
<p>Functions like <code>inc</code> are not difficult to implement:</p>
<pre class="Agda"><a id="inc"></a><a id="6515" href="#6515" class="Function">inc</a> <a id="6519" class="Symbol">:</a> <a id="6521" href="#6377" class="Function">𝔹</a> <a id="6523" class="Symbol">→</a> <a id="6525" href="#6377" class="Function">𝔹</a>
<a id="6527" href="#6515" class="Function">inc</a> <a id="6531" href="../code/binary/Prelude.html#793" class="InductiveConstructor">[]</a> <a id="6534" class="Symbol">=</a> <a id="6536" href="#6347" class="InductiveConstructor">1ᵇ</a> <a id="6539" href="../code/binary/Prelude.html#807" class="InductiveConstructor Operator">∷</a> <a id="6541" href="../code/binary/Prelude.html#793" class="InductiveConstructor">[]</a>
<a id="6544" href="#6515" class="Function">inc</a> <a id="6548" class="Symbol">(</a><a id="6549" href="#6347" class="InductiveConstructor">1ᵇ</a> <a id="6552" href="../code/binary/Prelude.html#807" class="InductiveConstructor Operator">∷</a> <a id="6554" href="#6554" class="Bound">xs</a><a id="6556" class="Symbol">)</a> <a id="6558" class="Symbol">=</a> <a id="6560" href="#6366" class="InductiveConstructor">2ᵇ</a> <a id="6563" href="../code/binary/Prelude.html#807" class="InductiveConstructor Operator">∷</a> <a id="6565" href="#6554" class="Bound">xs</a>
<a id="6568" href="#6515" class="Function">inc</a> <a id="6572" class="Symbol">(</a><a id="6573" href="#6366" class="InductiveConstructor">2ᵇ</a> <a id="6576" href="../code/binary/Prelude.html#807" class="InductiveConstructor Operator">∷</a> <a id="6578" href="#6578" class="Bound">xs</a><a id="6580" class="Symbol">)</a> <a id="6582" class="Symbol">=</a> <a id="6584" href="#6347" class="InductiveConstructor">1ᵇ</a> <a id="6587" href="../code/binary/Prelude.html#807" class="InductiveConstructor Operator">∷</a> <a id="6589" href="#6515" class="Function">inc</a> <a id="6593" href="#6578" class="Bound">xs</a>
</pre>
<p>And evaluation:</p>
<pre class="Agda"><a id="_∷⇓_"></a><a id="6626" href="#6626" class="Function Operator">_∷⇓_</a> <a id="6631" class="Symbol">:</a> <a id="6633" href="#6317" class="Function">Bit</a> <a id="6637" class="Symbol">→</a> <a id="6639" href="../code/binary/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="6641" class="Symbol">→</a> <a id="6643" href="../code/binary/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a>
<a id="6645" href="#6347" class="InductiveConstructor">1ᵇ</a> <a id="6648" href="#6626" class="Function Operator">∷⇓</a> <a id="6651" href="#6651" class="Bound">xs</a> <a id="6654" class="Symbol">=</a>      <a id="6661" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="6665" class="Symbol">(</a><a id="6666" href="#4231" class="Function">2*</a> <a id="6669" href="#6651" class="Bound">xs</a><a id="6671" class="Symbol">)</a>
<a id="6673" href="#6366" class="InductiveConstructor">2ᵇ</a> <a id="6676" href="#6626" class="Function Operator">∷⇓</a> <a id="6679" href="#6679" class="Bound">xs</a> <a id="6682" class="Symbol">=</a> <a id="6684" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="6688" class="Symbol">(</a><a id="6689" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="6693" class="Symbol">(</a><a id="6694" href="#4231" class="Function">2*</a> <a id="6697" href="#6679" class="Bound">xs</a><a id="6699" class="Symbol">))</a>

<a id="⟦_⇓⟧"></a><a id="6703" href="#6703" class="Function Operator">⟦_⇓⟧</a> <a id="6708" class="Symbol">:</a> <a id="6710" href="#6377" class="Function">𝔹</a> <a id="6712" class="Symbol">→</a> <a id="6714" href="../code/binary/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a>
<a id="6716" href="#6703" class="Function Operator">⟦_⇓⟧</a> <a id="6721" class="Symbol">=</a> <a id="6723" href="../code/binary/Prelude.html#834" class="Function">foldr</a> <a id="6729" href="#6626" class="Function Operator">_∷⇓_</a> <a id="6734" href="../code/binary/Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a>
</pre>
<p>Since we’re working in Cubical Agda, we might as well go on and prove that 𝔹 is isomorphic to ℕ. I’ll include the proof here for completeness, but it’s not relevant to the rest of the post (although it is very short, as a consequence of the simple definitions).</p>
<details>
<p><summary>Proof that 𝔹 and ℕ are isomorphic</summary></p>
<pre class="Agda"><a id="⟦_⇑⟧"></a><a id="7079" href="#7079" class="Function Operator">⟦_⇑⟧</a> <a id="7084" class="Symbol">:</a> <a id="7086" href="../code/binary/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="7088" class="Symbol">→</a> <a id="7090" href="#6377" class="Function">𝔹</a>
<a id="7092" href="#7079" class="Function Operator">⟦</a> <a id="7094" href="../code/binary/Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a>  <a id="7100" href="#7079" class="Function Operator">⇑⟧</a> <a id="7103" class="Symbol">=</a> <a id="7105" href="../code/binary/Prelude.html#793" class="InductiveConstructor">[]</a>
<a id="7108" href="#7079" class="Function Operator">⟦</a> <a id="7110" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="7114" href="#7114" class="Bound">n</a> <a id="7116" href="#7079" class="Function Operator">⇑⟧</a> <a id="7119" class="Symbol">=</a> <a id="7121" href="#6515" class="Function">inc</a> <a id="7125" href="#7079" class="Function Operator">⟦</a> <a id="7127" href="#7114" class="Bound">n</a> <a id="7129" href="#7079" class="Function Operator">⇑⟧</a>

<a id="2*⇔1ᵇ∷"></a><a id="7133" href="#7133" class="Function">2*⇔1ᵇ∷</a> <a id="7140" class="Symbol">:</a> <a id="7142" class="Symbol">∀</a> <a id="7144" href="#7144" class="Bound">n</a> <a id="7146" class="Symbol">→</a> <a id="7148" href="#6515" class="Function">inc</a> <a id="7152" href="#7079" class="Function Operator">⟦</a> <a id="7154" href="#4231" class="Function">2*</a> <a id="7157" href="#7144" class="Bound">n</a> <a id="7159" href="#7079" class="Function Operator">⇑⟧</a> <a id="7162" href="../code/binary/Agda.Builtin.Cubical.Path.html#353" class="Function Operator">≡</a> <a id="7164" href="#6347" class="InductiveConstructor">1ᵇ</a> <a id="7167" href="../code/binary/Prelude.html#807" class="InductiveConstructor Operator">∷</a> <a id="7169" href="#7079" class="Function Operator">⟦</a> <a id="7171" href="#7144" class="Bound">n</a> <a id="7173" href="#7079" class="Function Operator">⇑⟧</a>
<a id="7176" href="#7133" class="Function">2*⇔1ᵇ∷</a> <a id="7183" href="../code/binary/Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a> <a id="7188" class="Symbol">=</a> <a id="7190" href="../code/binary/Cubical.Foundations.Prelude.html#856" class="Function">refl</a>
<a id="7195" href="#7133" class="Function">2*⇔1ᵇ∷</a> <a id="7202" class="Symbol">(</a><a id="7203" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="7207" href="#7207" class="Bound">n</a><a id="7208" class="Symbol">)</a> <a id="7210" class="Symbol">=</a> <a id="7212" href="../code/binary/Cubical.Foundations.Prelude.html#1057" class="Function">cong</a> <a id="7217" class="Symbol">(</a><a id="7218" href="#6515" class="Function">inc</a> <a id="7222" href="../code/binary/Prelude.html#942" class="Function Operator">∘</a> <a id="7224" href="#6515" class="Function">inc</a><a id="7227" class="Symbol">)</a> <a id="7229" class="Symbol">(</a><a id="7230" href="#7133" class="Function">2*⇔1ᵇ∷</a> <a id="7237" href="#7207" class="Bound">n</a><a id="7238" class="Symbol">)</a>

<a id="𝔹→ℕ→𝔹"></a><a id="7241" href="#7241" class="Function">𝔹→ℕ→𝔹</a> <a id="7247" class="Symbol">:</a> <a id="7249" class="Symbol">∀</a> <a id="7251" href="#7251" class="Bound">n</a> <a id="7253" class="Symbol">→</a> <a id="7255" href="#7079" class="Function Operator">⟦</a> <a id="7257" href="#6703" class="Function Operator">⟦</a> <a id="7259" href="#7251" class="Bound">n</a> <a id="7261" href="#6703" class="Function Operator">⇓⟧</a> <a id="7264" href="#7079" class="Function Operator">⇑⟧</a> <a id="7267" href="../code/binary/Agda.Builtin.Cubical.Path.html#353" class="Function Operator">≡</a> <a id="7269" href="#7251" class="Bound">n</a>
<a id="7271" href="#7241" class="Function">𝔹→ℕ→𝔹</a> <a id="7277" href="../code/binary/Prelude.html#793" class="InductiveConstructor">[]</a> <a id="7280" class="Symbol">=</a> <a id="7282" href="../code/binary/Cubical.Foundations.Prelude.html#856" class="Function">refl</a>
<a id="7287" href="#7241" class="Function">𝔹→ℕ→𝔹</a> <a id="7293" class="Symbol">(</a><a id="7294" href="#6347" class="InductiveConstructor">1ᵇ</a> <a id="7297" href="../code/binary/Prelude.html#807" class="InductiveConstructor Operator">∷</a> <a id="7299" href="#7299" class="Bound">xs</a><a id="7301" class="Symbol">)</a> <a id="7303" class="Symbol">=</a>           <a id="7315" href="#7133" class="Function">2*⇔1ᵇ∷</a> <a id="7322" href="#6703" class="Function Operator">⟦</a> <a id="7324" href="#7299" class="Bound">xs</a> <a id="7327" href="#6703" class="Function Operator">⇓⟧</a>  <a id="7331" href="../code/binary/Cubical.Foundations.Prelude.html#1705" class="Function Operator">;</a> <a id="7333" href="../code/binary/Cubical.Foundations.Prelude.html#1057" class="Function">cong</a> <a id="7338" class="Symbol">(</a><a id="7339" href="#6347" class="InductiveConstructor">1ᵇ</a> <a id="7342" href="../code/binary/Prelude.html#807" class="InductiveConstructor Operator">∷_</a><a id="7344" class="Symbol">)</a> <a id="7346" class="Symbol">(</a><a id="7347" href="#7241" class="Function">𝔹→ℕ→𝔹</a> <a id="7353" href="#7299" class="Bound">xs</a><a id="7355" class="Symbol">)</a>
<a id="7357" href="#7241" class="Function">𝔹→ℕ→𝔹</a> <a id="7363" class="Symbol">(</a><a id="7364" href="#6366" class="InductiveConstructor">2ᵇ</a> <a id="7367" href="../code/binary/Prelude.html#807" class="InductiveConstructor Operator">∷</a> <a id="7369" href="#7369" class="Bound">xs</a><a id="7371" class="Symbol">)</a> <a id="7373" class="Symbol">=</a> <a id="7375" href="../code/binary/Cubical.Foundations.Prelude.html#1057" class="Function">cong</a> <a id="7380" href="#6515" class="Function">inc</a> <a id="7384" class="Symbol">(</a><a id="7385" href="#7133" class="Function">2*⇔1ᵇ∷</a> <a id="7392" href="#6703" class="Function Operator">⟦</a> <a id="7394" href="#7369" class="Bound">xs</a> <a id="7397" href="#6703" class="Function Operator">⇓⟧</a><a id="7399" class="Symbol">)</a> <a id="7401" href="../code/binary/Cubical.Foundations.Prelude.html#1705" class="Function Operator">;</a> <a id="7403" href="../code/binary/Cubical.Foundations.Prelude.html#1057" class="Function">cong</a> <a id="7408" class="Symbol">(</a><a id="7409" href="#6366" class="InductiveConstructor">2ᵇ</a> <a id="7412" href="../code/binary/Prelude.html#807" class="InductiveConstructor Operator">∷_</a><a id="7414" class="Symbol">)</a> <a id="7416" class="Symbol">(</a><a id="7417" href="#7241" class="Function">𝔹→ℕ→𝔹</a> <a id="7423" href="#7369" class="Bound">xs</a><a id="7425" class="Symbol">)</a>

<a id="inc⇔suc"></a><a id="7428" href="#7428" class="Function">inc⇔suc</a> <a id="7436" class="Symbol">:</a> <a id="7438" class="Symbol">∀</a> <a id="7440" href="#7440" class="Bound">n</a> <a id="7442" class="Symbol">→</a> <a id="7444" href="#6703" class="Function Operator">⟦</a> <a id="7446" href="#6515" class="Function">inc</a> <a id="7450" href="#7440" class="Bound">n</a> <a id="7452" href="#6703" class="Function Operator">⇓⟧</a> <a id="7455" href="../code/binary/Agda.Builtin.Cubical.Path.html#353" class="Function Operator">≡</a> <a id="7457" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="7461" href="#6703" class="Function Operator">⟦</a> <a id="7463" href="#7440" class="Bound">n</a> <a id="7465" href="#6703" class="Function Operator">⇓⟧</a>
<a id="7468" href="#7428" class="Function">inc⇔suc</a> <a id="7476" href="../code/binary/Prelude.html#793" class="InductiveConstructor">[]</a> <a id="7479" class="Symbol">=</a> <a id="7481" href="../code/binary/Cubical.Foundations.Prelude.html#856" class="Function">refl</a>
<a id="7486" href="#7428" class="Function">inc⇔suc</a> <a id="7494" class="Symbol">(</a><a id="7495" href="#6347" class="InductiveConstructor">1ᵇ</a> <a id="7498" href="../code/binary/Prelude.html#807" class="InductiveConstructor Operator">∷</a> <a id="7500" href="#7500" class="Bound">xs</a><a id="7502" class="Symbol">)</a> <a id="7504" class="Symbol">=</a> <a id="7506" href="../code/binary/Cubical.Foundations.Prelude.html#856" class="Function">refl</a>
<a id="7511" href="#7428" class="Function">inc⇔suc</a> <a id="7519" class="Symbol">(</a><a id="7520" href="#6366" class="InductiveConstructor">2ᵇ</a> <a id="7523" href="../code/binary/Prelude.html#807" class="InductiveConstructor Operator">∷</a> <a id="7525" href="#7525" class="Bound">xs</a><a id="7527" class="Symbol">)</a> <a id="7529" class="Symbol">=</a> <a id="7531" href="../code/binary/Cubical.Foundations.Prelude.html#1057" class="Function">cong</a> <a id="7536" class="Symbol">(</a><a id="7537" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="7541" href="../code/binary/Prelude.html#942" class="Function Operator">∘</a> <a id="7543" href="#4231" class="Function">2*</a><a id="7545" class="Symbol">)</a> <a id="7547" class="Symbol">(</a><a id="7548" href="#7428" class="Function">inc⇔suc</a> <a id="7556" href="#7525" class="Bound">xs</a><a id="7558" class="Symbol">)</a>

<a id="ℕ→𝔹→ℕ"></a><a id="7561" href="#7561" class="Function">ℕ→𝔹→ℕ</a> <a id="7567" class="Symbol">:</a> <a id="7569" class="Symbol">∀</a> <a id="7571" href="#7571" class="Bound">n</a> <a id="7573" class="Symbol">→</a> <a id="7575" href="#6703" class="Function Operator">⟦</a> <a id="7577" href="#7079" class="Function Operator">⟦</a> <a id="7579" href="#7571" class="Bound">n</a> <a id="7581" href="#7079" class="Function Operator">⇑⟧</a> <a id="7584" href="#6703" class="Function Operator">⇓⟧</a> <a id="7587" href="../code/binary/Agda.Builtin.Cubical.Path.html#353" class="Function Operator">≡</a> <a id="7589" href="#7571" class="Bound">n</a>
<a id="7591" href="#7561" class="Function">ℕ→𝔹→ℕ</a> <a id="7597" href="../code/binary/Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a>    <a id="7605" class="Symbol">=</a> <a id="7607" href="../code/binary/Cubical.Foundations.Prelude.html#856" class="Function">refl</a>
<a id="7612" href="#7561" class="Function">ℕ→𝔹→ℕ</a> <a id="7618" class="Symbol">(</a><a id="7619" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="7623" href="#7623" class="Bound">n</a><a id="7624" class="Symbol">)</a> <a id="7626" class="Symbol">=</a> <a id="7628" href="#7428" class="Function">inc⇔suc</a> <a id="7636" href="#7079" class="Function Operator">⟦</a> <a id="7638" href="#7623" class="Bound">n</a> <a id="7640" href="#7079" class="Function Operator">⇑⟧</a> <a id="7643" href="../code/binary/Cubical.Foundations.Prelude.html#1705" class="Function Operator">;</a> <a id="7645" href="../code/binary/Cubical.Foundations.Prelude.html#1057" class="Function">cong</a> <a id="7650" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="7654" class="Symbol">(</a><a id="7655" href="#7561" class="Function">ℕ→𝔹→ℕ</a> <a id="7661" href="#7623" class="Bound">n</a><a id="7662" class="Symbol">)</a>

<a id="𝔹⇔ℕ"></a><a id="7665" href="#7665" class="Function">𝔹⇔ℕ</a> <a id="7669" class="Symbol">:</a> <a id="7671" href="#6377" class="Function">𝔹</a> <a id="7673" href="../code/binary/Prelude.html#416" class="Function Operator">⇔</a> <a id="7675" href="../code/binary/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a>
<a id="7677" href="#7665" class="Function">𝔹⇔ℕ</a> <a id="7681" class="Symbol">=</a> <a id="7683" href="../code/binary/Cubical.Foundations.Isomorphism.html#710" class="InductiveConstructor">iso</a> <a id="7687" href="#6703" class="Function Operator">⟦_⇓⟧</a> <a id="7692" href="#7079" class="Function Operator">⟦_⇑⟧</a> <a id="7697" href="#7561" class="Function">ℕ→𝔹→ℕ</a> <a id="7703" href="#7241" class="Function">𝔹→ℕ→𝔹</a>
</pre>
</details>
<h1 id="binary-arrays">Binary Arrays</h1>
<p>Now on to the data structure. Here’s its type.</p>
<pre class="Agda"><a id="7799" class="Keyword">infixr</a> <a id="7806" class="Number">5</a> <a id="7808" href="#7956" class="InductiveConstructor Operator">_1∷_</a> <a id="7813" href="#7994" class="InductiveConstructor Operator">_2∷_</a>
<a id="7818" class="Keyword">data</a> <a id="Array"></a><a id="7823" href="#7823" class="Datatype">Array</a> <a id="7829" class="Symbol">(</a><a id="7830" href="#7830" class="Bound">T</a> <a id="7832" class="Symbol">:</a> <a id="7834" href="../code/binary/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="7836" class="Symbol">→</a> <a id="7838" href="../code/binary/Cubical.Core.Primitives.html#957" class="Function">Type</a> <a id="7843" href="../code/binary/Prelude.html#454" class="Generalizable">a</a><a id="7844" class="Symbol">)</a> <a id="7846" class="Symbol">:</a> <a id="7848" href="#6377" class="Function">𝔹</a> <a id="7850" class="Symbol">→</a> <a id="7852" href="../code/binary/Cubical.Core.Primitives.html#957" class="Function">Type</a> <a id="7857" href="#7843" class="Bound">a</a> <a id="7859" class="Keyword">where</a>
  <a id="Array.[]"></a><a id="7867" href="#7867" class="InductiveConstructor">[]</a>  <a id="7871" class="Symbol">:</a> <a id="7873" href="#7823" class="Datatype">Array</a> <a id="7879" href="#7830" class="Bound">T</a> <a id="7881" href="../code/binary/Prelude.html#793" class="InductiveConstructor">[]</a>
  <a id="Array._∷_"></a><a id="7886" href="#7886" class="InductiveConstructor Operator">_∷_</a> <a id="7890" class="Symbol">:</a> <a id="7892" href="#7830" class="Bound">T</a> <a id="7894" class="Symbol">(</a><a id="7895" href="../code/binary/Prelude.html#1416" class="Function">bool</a> <a id="7900" class="Number">0</a> <a id="7902" class="Number">1</a> <a id="7904" href="#6427" class="Generalizable">d</a><a id="7905" class="Symbol">)</a> <a id="7907" class="Symbol">→</a> <a id="7909" href="#7823" class="Datatype">Array</a> <a id="7915" class="Symbol">(</a><a id="7916" href="#7830" class="Bound">T</a> <a id="7918" href="../code/binary/Prelude.html#942" class="Function Operator">∘</a> <a id="7920" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a><a id="7923" class="Symbol">)</a> <a id="7925" href="#6437" class="Generalizable">ds</a> <a id="7928" class="Symbol">→</a> <a id="7930" href="#7823" class="Datatype">Array</a> <a id="7936" href="#7830" class="Bound">T</a> <a id="7938" class="Symbol">(</a><a id="7939" href="#6427" class="Generalizable">d</a> <a id="7941" href="../code/binary/Prelude.html#807" class="InductiveConstructor Operator">∷</a> <a id="7943" href="#6437" class="Generalizable">ds</a><a id="7945" class="Symbol">)</a>

<a id="7948" class="Keyword">pattern</a> <a id="_1∷_"></a><a id="7956" href="#7956" class="InductiveConstructor Operator">_1∷_</a> <a id="7961" href="#7981" class="Bound">x</a> <a id="7963" href="#7983" class="Bound">xs</a> <a id="7966" class="Symbol">=</a> <a id="7968" class="InductiveConstructor Operator">_∷_</a> <a id="7972" class="Symbol">{</a>d <a id="7975" class="Symbol">=</a> <a id="7977" href="#6347" class="InductiveConstructor">1ᵇ</a><a id="7979" class="Symbol">}</a> <a id="7981" href="#7981" class="Bound">x</a> <a id="7983" href="#7983" class="Bound">xs</a>
<a id="7986" class="Keyword">pattern</a> <a id="_2∷_"></a><a id="7994" href="#7994" class="InductiveConstructor Operator">_2∷_</a> <a id="7999" href="#8019" class="Bound">x</a> <a id="8001" href="#8021" class="Bound">xs</a> <a id="8004" class="Symbol">=</a> <a id="8006" class="InductiveConstructor Operator">_∷_</a> <a id="8010" class="Symbol">{</a>d <a id="8013" class="Symbol">=</a> <a id="8015" href="#6366" class="InductiveConstructor">2ᵇ</a><a id="8017" class="Symbol">}</a> <a id="8019" href="#8019" class="Bound">x</a> <a id="8021" href="#8021" class="Bound">xs</a>
</pre>
<p>So it is a list-like structure, which contains elements of type <code>T</code>. <code>T</code> is the type of trees in the array: making the array generic over the types of trees is a slight departure from the norm. Usually, we would just use a perfect tree or something:</p>
<pre class="Agda"><a id="8288" class="Keyword">module</a> <a id="Prelim"></a><a id="8295" href="#8295" class="Module">Prelim</a> <a id="8302" class="Keyword">where</a>
  <a id="Prelim.Perfect"></a><a id="8310" href="#8310" class="Function">Perfect</a> <a id="8318" class="Symbol">:</a> <a id="8320" class="PrimitiveType">Set</a> <a id="8324" href="../code/binary/Prelude.html#454" class="Generalizable">a</a> <a id="8326" class="Symbol">→</a> <a id="8328" href="../code/binary/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="8330" class="Symbol">→</a> <a id="8332" class="PrimitiveType">Set</a> <a id="8336" href="../code/binary/Prelude.html#454" class="Generalizable">a</a>
  <a id="8340" href="#8310" class="Function">Perfect</a> <a id="8348" href="#8348" class="Bound">A</a> <a id="8350" href="../code/binary/Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a> <a id="8355" class="Symbol">=</a> <a id="8357" href="#8348" class="Bound">A</a>
  <a id="8361" href="#8310" class="Function">Perfect</a> <a id="8369" href="#8369" class="Bound">A</a> <a id="8371" class="Symbol">(</a><a id="8372" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="8376" href="#8376" class="Bound">n</a><a id="8377" class="Symbol">)</a> <a id="8379" class="Symbol">=</a> <a id="8381" href="#8310" class="Function">Perfect</a> <a id="8389" class="Symbol">(</a><a id="8390" href="#8369" class="Bound">A</a> <a id="8392" href="../code/binary/Prelude.html#621" class="Function Operator">×</a> <a id="8394" href="#8369" class="Bound">A</a><a id="8395" class="Symbol">)</a> <a id="8397" href="#8376" class="Bound">n</a>
</pre>
<p>By making the tree type a parameter, though, we actually <em>simplify</em> some of the code for manipulating the tree. It’s basically the same trick as the type-changing parameter in <code>vec-foldl</code>.</p>
<p>As well as that, of course, we can use the array with more exotic tree types. With binomial trees, for example, we get a binomial heap:</p>
<pre class="Agda"><a id="8739" class="Keyword">mutual</a>
  <a id="8748" class="Keyword">data</a> <a id="BinomNode"></a><a id="8753" href="#8753" class="Datatype">BinomNode</a> <a id="8763" class="Symbol">(</a><a id="8764" href="#8764" class="Bound">A</a> <a id="8766" class="Symbol">:</a> <a id="8768" class="PrimitiveType">Set</a> <a id="8772" href="../code/binary/Prelude.html#454" class="Generalizable">a</a><a id="8773" class="Symbol">)</a> <a id="8775" class="Symbol">:</a> <a id="8777" href="../code/binary/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="8779" class="Symbol">→</a> <a id="8781" class="PrimitiveType">Set</a> <a id="8785" href="#8772" class="Bound">a</a> <a id="8787" class="Keyword">where</a>
    <a id="BinomNode.binom-leaf"></a><a id="8797" href="#8797" class="InductiveConstructor">binom-leaf</a>   <a id="8810" class="Symbol">:</a> <a id="8812" href="#8753" class="Datatype">BinomNode</a> <a id="8822" href="#8764" class="Bound">A</a> <a id="8824" class="Number">0</a>
    <a id="BinomNode.binom-branch"></a><a id="8830" href="#8830" class="InductiveConstructor">binom-branch</a> <a id="8843" class="Symbol">:</a> <a id="8845" href="#8899" class="Function">Binomial</a> <a id="8854" href="#8764" class="Bound">A</a> <a id="8856" href="../code/binary/Prelude.html#506" class="Generalizable">n</a> <a id="8858" class="Symbol">→</a> <a id="8860" href="#8753" class="Datatype">BinomNode</a> <a id="8870" href="#8764" class="Bound">A</a> <a id="8872" href="../code/binary/Prelude.html#506" class="Generalizable">n</a> <a id="8874" class="Symbol">→</a> <a id="8876" href="#8753" class="Datatype">BinomNode</a> <a id="8886" href="#8764" class="Bound">A</a> <a id="8888" class="Symbol">(</a><a id="8889" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="8893" href="../code/binary/Prelude.html#506" class="Generalizable">n</a><a id="8894" class="Symbol">)</a>

  <a id="Binomial"></a><a id="8899" href="#8899" class="Function">Binomial</a> <a id="8908" class="Symbol">:</a> <a id="8910" class="PrimitiveType">Set</a> <a id="8914" href="../code/binary/Prelude.html#454" class="Generalizable">a</a> <a id="8916" class="Symbol">→</a> <a id="8918" href="../code/binary/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="8920" class="Symbol">→</a> <a id="8922" class="PrimitiveType">Set</a> <a id="8926" href="../code/binary/Prelude.html#454" class="Generalizable">a</a>
  <a id="8930" href="#8899" class="Function">Binomial</a> <a id="8939" href="#8939" class="Bound">A</a> <a id="8941" href="#8941" class="Bound">n</a> <a id="8943" class="Symbol">=</a> <a id="8945" href="#8939" class="Bound">A</a> <a id="8947" href="../code/binary/Prelude.html#621" class="Function Operator">×</a> <a id="8949" href="#8753" class="Datatype">BinomNode</a> <a id="8959" href="#8939" class="Bound">A</a> <a id="8961" href="#8941" class="Bound">n</a>
</pre>
<p>But we’ll stick to the random-access lists for now.</p>
<h1 id="top-down-and-bottom-up-trees">Top-down and Bottom-up Trees</h1>
<p>The perfect trees above are actually a specific instance of a more general data type: exponentiations of functors.</p>
<pre class="Agda"><a id="_^_"></a><a id="9177" href="#9177" class="Function Operator">_^_</a> <a id="9181" class="Symbol">:</a> <a id="9183" class="Symbol">(</a><a id="9184" class="PrimitiveType">Set</a> <a id="9188" href="../code/binary/Prelude.html#454" class="Generalizable">a</a> <a id="9190" class="Symbol">→</a> <a id="9192" class="PrimitiveType">Set</a> <a id="9196" href="../code/binary/Prelude.html#454" class="Generalizable">a</a><a id="9197" class="Symbol">)</a> <a id="9199" class="Symbol">→</a> <a id="9201" href="../code/binary/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="9203" class="Symbol">→</a> <a id="9205" class="PrimitiveType">Set</a> <a id="9209" href="../code/binary/Prelude.html#454" class="Generalizable">a</a> <a id="9211" class="Symbol">→</a> <a id="9213" class="PrimitiveType">Set</a> <a id="9217" href="../code/binary/Prelude.html#454" class="Generalizable">a</a>
<a id="9219" class="Symbol">(</a><a id="9220" href="#9220" class="Bound">F</a> <a id="9222" href="#9177" class="Function Operator">^</a> <a id="9224" href="../code/binary/Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a> <a id="9229" class="Symbol">)</a> <a id="9231" href="#9231" class="Bound">A</a> <a id="9233" class="Symbol">=</a> <a id="9235" href="#9231" class="Bound">A</a>
<a id="9237" class="Symbol">(</a><a id="9238" href="#9238" class="Bound">F</a> <a id="9240" href="#9177" class="Function Operator">^</a> <a id="9242" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="9246" href="#9246" class="Bound">n</a><a id="9247" class="Symbol">)</a> <a id="9249" href="#9249" class="Bound">A</a> <a id="9251" class="Symbol">=</a> <a id="9253" class="Symbol">(</a><a id="9254" href="#9238" class="Bound">F</a> <a id="9256" href="#9177" class="Function Operator">^</a> <a id="9258" href="#9246" class="Bound">n</a><a id="9259" class="Symbol">)</a> <a id="9261" class="Symbol">(</a><a id="9262" href="#9238" class="Bound">F</a> <a id="9264" href="#9249" class="Bound">A</a><a id="9265" class="Symbol">)</a>

<a id="Nest"></a><a id="9268" href="#9268" class="Function">Nest</a> <a id="9273" class="Symbol">:</a> <a id="9275" class="Symbol">(</a><a id="9276" class="PrimitiveType">Set</a> <a id="9280" href="../code/binary/Prelude.html#454" class="Generalizable">a</a> <a id="9282" class="Symbol">→</a> <a id="9284" class="PrimitiveType">Set</a> <a id="9288" href="../code/binary/Prelude.html#454" class="Generalizable">a</a><a id="9289" class="Symbol">)</a> <a id="9291" class="Symbol">→</a> <a id="9293" class="PrimitiveType">Set</a> <a id="9297" href="../code/binary/Prelude.html#454" class="Generalizable">a</a> <a id="9299" class="Symbol">→</a> <a id="9301" href="../code/binary/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="9303" class="Symbol">→</a> <a id="9305" class="PrimitiveType">Set</a> <a id="9309" href="../code/binary/Prelude.html#454" class="Generalizable">a</a>
<a id="9311" href="#9268" class="Function">Nest</a> <a id="9316" href="#9316" class="Bound">F</a> <a id="9318" href="#9318" class="Bound">A</a> <a id="9320" href="#9320" class="Bound">n</a> <a id="9322" class="Symbol">=</a> <a id="9324" class="Symbol">(</a><a id="9325" href="#9316" class="Bound">F</a> <a id="9327" href="#9177" class="Function Operator">^</a> <a id="9329" href="#9320" class="Bound">n</a><a id="9330" class="Symbol">)</a> <a id="9332" href="#9318" class="Bound">A</a>

<a id="Pair"></a><a id="9335" href="#9335" class="Function">Pair</a> <a id="9340" class="Symbol">:</a> <a id="9342" class="PrimitiveType">Set</a> <a id="9346" href="../code/binary/Prelude.html#454" class="Generalizable">a</a> <a id="9348" class="Symbol">→</a> <a id="9350" class="PrimitiveType">Set</a> <a id="9354" href="../code/binary/Prelude.html#454" class="Generalizable">a</a>
<a id="9356" href="#9335" class="Function">Pair</a> <a id="9361" href="#9361" class="Bound">A</a> <a id="9363" class="Symbol">=</a> <a id="9365" href="#9361" class="Bound">A</a> <a id="9367" href="../code/binary/Prelude.html#621" class="Function Operator">×</a> <a id="9369" href="#9361" class="Bound">A</a>

<a id="Perfect"></a><a id="9372" href="#9372" class="Function">Perfect</a> <a id="9380" class="Symbol">:</a> <a id="9382" class="PrimitiveType">Set</a> <a id="9386" href="../code/binary/Prelude.html#454" class="Generalizable">a</a> <a id="9388" class="Symbol">→</a> <a id="9390" href="../code/binary/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="9392" class="Symbol">→</a> <a id="9394" class="PrimitiveType">Set</a> <a id="9398" href="../code/binary/Prelude.html#454" class="Generalizable">a</a>
<a id="9400" href="#9372" class="Function">Perfect</a> <a id="9408" class="Symbol">=</a> <a id="9410" href="#9268" class="Function">Nest</a> <a id="9415" href="#9335" class="Function">Pair</a>
</pre>
<!--

<pre class="Agda"><a id="9439" class="Keyword">variable</a>
  <a id="9450" href="#9450" class="Generalizable">F</a> <a id="9452" class="Symbol">:</a> <a id="9454" class="PrimitiveType">Set</a> <a id="9458" href="../code/binary/Prelude.html#454" class="Generalizable">a</a> <a id="9460" class="Symbol">→</a> <a id="9462" class="PrimitiveType">Set</a> <a id="9466" href="../code/binary/Prelude.html#454" class="Generalizable">a</a>
</pre>
-->
<p>It’s a nested datatype, built in a bottom-up way. This is in contrast to, say, the binomial trees above, which are top-down.</p>
<h1 id="construction">Construction</h1>
<p>Our first function on the array is <code>cons</code>, which inserts an element:</p>
<pre class="Agda"><a id="cons"></a><a id="9698" href="#9698" class="Function">cons</a> <a id="9703" class="Symbol">:</a> <a id="9705" class="Symbol">(∀</a> <a id="9708" href="#9708" class="Bound">n</a> <a id="9710" class="Symbol">→</a> <a id="9712" href="#846" class="Generalizable">T</a> <a id="9714" href="#9708" class="Bound">n</a> <a id="9716" class="Symbol">→</a> <a id="9718" href="#846" class="Generalizable">T</a> <a id="9720" href="#9708" class="Bound">n</a> <a id="9722" class="Symbol">→</a> <a id="9724" href="#846" class="Generalizable">T</a> <a id="9726" class="Symbol">(</a><a id="9727" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="9731" href="#9708" class="Bound">n</a><a id="9732" class="Symbol">))</a>
     <a id="9740" class="Symbol">→</a> <a id="9742" href="#846" class="Generalizable">T</a> <a id="9744" class="Number">0</a> <a id="9746" class="Symbol">→</a> <a id="9748" href="#7823" class="Datatype">Array</a> <a id="9754" href="#846" class="Generalizable">T</a> <a id="9756" href="#6437" class="Generalizable">ds</a> <a id="9759" class="Symbol">→</a> <a id="9761" href="#7823" class="Datatype">Array</a> <a id="9767" href="#846" class="Generalizable">T</a> <a id="9769" class="Symbol">(</a><a id="9770" href="#6515" class="Function">inc</a> <a id="9774" href="#6437" class="Generalizable">ds</a><a id="9776" class="Symbol">)</a>
<a id="9778" href="#9698" class="Function">cons</a> <a id="9783" href="#9783" class="Bound">branch</a> <a id="9790" href="#9790" class="Bound">x</a> <a id="9792" href="#7867" class="InductiveConstructor">[]</a> <a id="9795" class="Symbol">=</a> <a id="9797" href="#9790" class="Bound">x</a> <a id="9799" href="#7956" class="InductiveConstructor Operator">1∷</a> <a id="9802" href="#7867" class="InductiveConstructor">[]</a>
<a id="9805" href="#9698" class="Function">cons</a> <a id="9810" href="#9810" class="Bound">branch</a> <a id="9817" href="#9817" class="Bound">x</a> <a id="9819" class="Symbol">(</a><a id="9820" href="#9820" class="Bound">y</a> <a id="9822" href="#7956" class="InductiveConstructor Operator">1∷</a> <a id="9825" href="#9825" class="Bound">ys</a><a id="9827" class="Symbol">)</a> <a id="9829" class="Symbol">=</a> <a id="9831" href="#9810" class="Bound">branch</a> <a id="9838" class="Number">0</a> <a id="9840" href="#9817" class="Bound">x</a> <a id="9842" href="#9820" class="Bound">y</a> <a id="9844" href="#7994" class="InductiveConstructor Operator">2∷</a> <a id="9847" href="#9825" class="Bound">ys</a>
<a id="9850" href="#9698" class="Function">cons</a> <a id="9855" href="#9855" class="Bound">branch</a> <a id="9862" href="#9862" class="Bound">x</a> <a id="9864" class="Symbol">(</a><a id="9865" href="#9865" class="Bound">y</a> <a id="9867" href="#7994" class="InductiveConstructor Operator">2∷</a> <a id="9870" href="#9870" class="Bound">ys</a><a id="9872" class="Symbol">)</a> <a id="9874" class="Symbol">=</a> <a id="9876" href="#9862" class="Bound">x</a> <a id="9878" href="#7956" class="InductiveConstructor Operator">1∷</a> <a id="9881" href="#9698" class="Function">cons</a> <a id="9886" class="Symbol">(</a><a id="9887" href="#9855" class="Bound">branch</a> <a id="9894" href="../code/binary/Prelude.html#942" class="Function Operator">∘</a> <a id="9896" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a><a id="9899" class="Symbol">)</a> <a id="9901" href="#9865" class="Bound">y</a> <a id="9903" href="#9870" class="Bound">ys</a>
</pre>
<p>Since we’re generic over the type of trees, we need to pass in the “branch” constructor (or function) for whatever tree type we end up using. Here’s how we’d implement such a branch function for perfect trees.</p>
<pre class="Agda"><a id="perf-branch"></a><a id="10130" href="#10130" class="Function">perf-branch</a> <a id="10142" class="Symbol">:</a> <a id="10144" class="Symbol">∀</a> <a id="10146" href="#10146" class="Bound">n</a> <a id="10148" class="Symbol">→</a> <a id="10150" href="#9372" class="Function">Perfect</a> <a id="10158" href="../code/binary/Prelude.html#470" class="Generalizable">A</a> <a id="10160" href="#10146" class="Bound">n</a> <a id="10162" class="Symbol">→</a> <a id="10164" href="#9372" class="Function">Perfect</a> <a id="10172" href="../code/binary/Prelude.html#470" class="Generalizable">A</a> <a id="10174" href="#10146" class="Bound">n</a> <a id="10176" class="Symbol">→</a> <a id="10178" href="#9372" class="Function">Perfect</a> <a id="10186" href="../code/binary/Prelude.html#470" class="Generalizable">A</a> <a id="10188" class="Symbol">(</a><a id="10189" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="10193" href="#10146" class="Bound">n</a><a id="10194" class="Symbol">)</a>
<a id="10196" href="#10130" class="Function">perf-branch</a> <a id="10208" href="../code/binary/Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a> <a id="10213" class="Symbol">=</a> <a id="10215" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">_,_</a>
<a id="10219" href="#10130" class="Function">perf-branch</a> <a id="10231" class="Symbol">(</a><a id="10232" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="10236" href="#10236" class="Bound">n</a><a id="10237" class="Symbol">)</a> <a id="10239" class="Symbol">=</a> <a id="10241" href="#10130" class="Function">perf-branch</a> <a id="10253" href="#10236" class="Bound">n</a>
</pre>
<p>One issue here is that the <code>perf-branch</code> function probably doesn’t optimise to the correct complexity, because the <code>n</code> has to be scrutinised repeatedly. The alternative is to define a <code>cons</code> for nested types, like so:</p>
<pre class="Agda"><a id="nest-cons"></a><a id="10487" href="#10487" class="Function">nest-cons</a> <a id="10497" class="Symbol">:</a> <a id="10499" class="Symbol">(∀</a> <a id="10502" class="Symbol">{</a><a id="10503" href="#10503" class="Bound">A</a><a id="10504" class="Symbol">}</a> <a id="10506" class="Symbol">→</a> <a id="10508" href="#10503" class="Bound">A</a> <a id="10510" class="Symbol">→</a> <a id="10512" href="#10503" class="Bound">A</a> <a id="10514" class="Symbol">→</a> <a id="10516" href="#9450" class="Generalizable">F</a> <a id="10518" href="#10503" class="Bound">A</a><a id="10519" class="Symbol">)</a> <a id="10521" class="Symbol">→</a> <a id="10523" href="../code/binary/Prelude.html#470" class="Generalizable">A</a> <a id="10525" class="Symbol">→</a> <a id="10527" href="#7823" class="Datatype">Array</a> <a id="10533" class="Symbol">(</a><a id="10534" href="#9268" class="Function">Nest</a> <a id="10539" href="#9450" class="Generalizable">F</a> <a id="10541" href="../code/binary/Prelude.html#470" class="Generalizable">A</a><a id="10542" class="Symbol">)</a> <a id="10544" href="#6437" class="Generalizable">ds</a> <a id="10547" class="Symbol">→</a> <a id="10549" href="#7823" class="Datatype">Array</a> <a id="10555" class="Symbol">(</a><a id="10556" href="#9268" class="Function">Nest</a> <a id="10561" href="#9450" class="Generalizable">F</a> <a id="10563" href="../code/binary/Prelude.html#470" class="Generalizable">A</a><a id="10564" class="Symbol">)</a> <a id="10566" class="Symbol">(</a><a id="10567" href="#6515" class="Function">inc</a> <a id="10571" href="#6437" class="Generalizable">ds</a><a id="10573" class="Symbol">)</a>
<a id="10575" href="#10487" class="Function">nest-cons</a> <a id="10585" href="#10585" class="Bound Operator">_∙_</a> <a id="10589" href="#10589" class="Bound">x</a> <a id="10591" href="#7867" class="InductiveConstructor">[]</a> <a id="10594" class="Symbol">=</a> <a id="10596" href="#10589" class="Bound">x</a> <a id="10598" href="#7886" class="InductiveConstructor Operator">∷</a> <a id="10600" href="#7867" class="InductiveConstructor">[]</a>
<a id="10603" href="#10487" class="Function">nest-cons</a> <a id="10613" href="#10613" class="Bound Operator">_∙_</a> <a id="10617" href="#10617" class="Bound">x</a> <a id="10619" class="Symbol">(</a><a id="10620" href="#10620" class="Bound">y</a> <a id="10622" href="#7956" class="InductiveConstructor Operator">1∷</a> <a id="10625" href="#10625" class="Bound">ys</a><a id="10627" class="Symbol">)</a> <a id="10629" class="Symbol">=</a> <a id="10631" class="Symbol">(</a><a id="10632" href="#10617" class="Bound">x</a> <a id="10634" href="#10613" class="Bound Operator">∙</a> <a id="10636" href="#10620" class="Bound">y</a><a id="10637" class="Symbol">)</a> <a id="10639" href="#7994" class="InductiveConstructor Operator">2∷</a> <a id="10642" href="#10625" class="Bound">ys</a>
<a id="10645" href="#10487" class="Function">nest-cons</a> <a id="10655" href="#10655" class="Bound Operator">_∙_</a> <a id="10659" href="#10659" class="Bound">x</a> <a id="10661" class="Symbol">(</a><a id="10662" href="#10662" class="Bound">y</a> <a id="10664" href="#7994" class="InductiveConstructor Operator">2∷</a> <a id="10667" href="#10667" class="Bound">ys</a><a id="10669" class="Symbol">)</a> <a id="10671" class="Symbol">=</a> <a id="10673" href="#10659" class="Bound">x</a> <a id="10675" href="#7886" class="InductiveConstructor Operator">∷</a> <a id="10677" href="#10487" class="Function">nest-cons</a> <a id="10687" href="#10655" class="Bound Operator">_∙_</a> <a id="10691" href="#10662" class="Bound">y</a> <a id="10693" href="#10667" class="Bound">ys</a>

<a id="perf-cons"></a><a id="10697" href="#10697" class="Function">perf-cons</a> <a id="10707" class="Symbol">:</a> <a id="10709" href="../code/binary/Prelude.html#470" class="Generalizable">A</a> <a id="10711" class="Symbol">→</a> <a id="10713" href="#7823" class="Datatype">Array</a> <a id="10719" class="Symbol">(</a><a id="10720" href="#9372" class="Function">Perfect</a> <a id="10728" href="../code/binary/Prelude.html#470" class="Generalizable">A</a><a id="10729" class="Symbol">)</a> <a id="10731" href="#6437" class="Generalizable">ds</a> <a id="10734" class="Symbol">→</a> <a id="10736" href="#7823" class="Datatype">Array</a> <a id="10742" class="Symbol">(</a><a id="10743" href="#9372" class="Function">Perfect</a> <a id="10751" href="../code/binary/Prelude.html#470" class="Generalizable">A</a><a id="10752" class="Symbol">)</a> <a id="10754" class="Symbol">(</a><a id="10755" href="#6515" class="Function">inc</a> <a id="10759" href="#6437" class="Generalizable">ds</a><a id="10761" class="Symbol">)</a>
<a id="10763" href="#10697" class="Function">perf-cons</a> <a id="10773" class="Symbol">=</a> <a id="10775" href="#10487" class="Function">nest-cons</a> <a id="10785" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">_,_</a>
</pre>
<h1 id="indexing">Indexing</h1>
<p>Again, we’re going to keep things general, allowing multiple index types. For those index types we’ll need a type like <code>Fin</code> but for binary numbers.</p>
<pre class="Agda"><a id="10964" class="Keyword">data</a> <a id="Fin𝔹"></a><a id="10969" href="#10969" class="Datatype">Fin𝔹</a> <a id="10974" class="Symbol">(</a><a id="10975" href="#10975" class="Bound">A</a> <a id="10977" class="Symbol">:</a> <a id="10979" class="PrimitiveType">Set</a> <a id="10983" href="../code/binary/Prelude.html#454" class="Generalizable">a</a><a id="10984" class="Symbol">)</a> <a id="10986" class="Symbol">:</a> <a id="10988" href="#6377" class="Function">𝔹</a> <a id="10990" class="Symbol">→</a> <a id="10992" href="../code/binary/Cubical.Core.Primitives.html#957" class="Function">Type</a> <a id="10997" href="#10983" class="Bound">a</a> <a id="10999" class="Keyword">where</a>
  <a id="Fin𝔹.here₁"></a><a id="11007" href="#11007" class="InductiveConstructor">here₁</a> <a id="11013" class="Symbol">:</a>                       <a id="11037" href="#10969" class="Datatype">Fin𝔹</a> <a id="11042" href="#10975" class="Bound">A</a> <a id="11044" class="Symbol">(</a><a id="11045" href="#6347" class="InductiveConstructor">1ᵇ</a> <a id="11048" href="../code/binary/Prelude.html#807" class="InductiveConstructor Operator">∷</a> <a id="11050" href="#6437" class="Generalizable">ds</a><a id="11052" class="Symbol">)</a>
  <a id="Fin𝔹.here₂"></a><a id="11056" href="#11056" class="InductiveConstructor">here₂</a> <a id="11062" class="Symbol">:</a> <a id="11064" class="Symbol">(</a><a id="11065" href="#11065" class="Bound">i</a> <a id="11067" class="Symbol">:</a> <a id="11069" href="#10975" class="Bound">A</a><a id="11070" class="Symbol">)</a>             <a id="11084" class="Symbol">→</a> <a id="11086" href="#10969" class="Datatype">Fin𝔹</a> <a id="11091" href="#10975" class="Bound">A</a> <a id="11093" class="Symbol">(</a><a id="11094" href="#6366" class="InductiveConstructor">2ᵇ</a> <a id="11097" href="../code/binary/Prelude.html#807" class="InductiveConstructor Operator">∷</a> <a id="11099" href="#6437" class="Generalizable">ds</a><a id="11101" class="Symbol">)</a>
  <a id="Fin𝔹.there"></a><a id="11105" href="#11105" class="InductiveConstructor">there</a> <a id="11111" class="Symbol">:</a> <a id="11113" class="Symbol">(</a><a id="11114" href="#11114" class="Bound">i</a> <a id="11116" class="Symbol">:</a> <a id="11118" href="#10975" class="Bound">A</a><a id="11119" class="Symbol">)</a> <a id="11121" class="Symbol">→</a> <a id="11123" href="#10969" class="Datatype">Fin𝔹</a> <a id="11128" href="#10975" class="Bound">A</a> <a id="11130" href="#6437" class="Generalizable">ds</a> <a id="11133" class="Symbol">→</a> <a id="11135" href="#10969" class="Datatype">Fin𝔹</a> <a id="11140" href="#10975" class="Bound">A</a> <a id="11142" class="Symbol">(</a><a id="11143" href="#6427" class="Generalizable">d</a>  <a id="11146" href="../code/binary/Prelude.html#807" class="InductiveConstructor Operator">∷</a> <a id="11148" href="#6437" class="Generalizable">ds</a><a id="11150" class="Symbol">)</a>

<a id="lookup"></a><a id="11153" href="#11153" class="Function">lookup</a> <a id="11160" class="Symbol">:</a> <a id="11162" class="Symbol">(∀</a> <a id="11165" class="Symbol">{</a><a id="11166" href="#11166" class="Bound">n</a><a id="11167" class="Symbol">}</a> <a id="11169" class="Symbol">→</a> <a id="11171" href="#874" class="Generalizable">P</a> <a id="11173" class="Symbol">→</a> <a id="11175" href="#846" class="Generalizable">T</a> <a id="11177" class="Symbol">(</a><a id="11178" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="11182" href="#11166" class="Bound">n</a><a id="11183" class="Symbol">)</a> <a id="11185" class="Symbol">→</a> <a id="11187" href="#846" class="Generalizable">T</a> <a id="11189" href="#11166" class="Bound">n</a><a id="11190" class="Symbol">)</a>
       <a id="11199" class="Symbol">→</a> <a id="11201" href="#7823" class="Datatype">Array</a> <a id="11207" href="#846" class="Generalizable">T</a> <a id="11209" href="#6437" class="Generalizable">ds</a>
       <a id="11219" class="Symbol">→</a> <a id="11221" href="#10969" class="Datatype">Fin𝔹</a> <a id="11226" href="#874" class="Generalizable">P</a> <a id="11228" href="#6437" class="Generalizable">ds</a>
       <a id="11238" class="Symbol">→</a> <a id="11240" href="#846" class="Generalizable">T</a> <a id="11242" class="Number">0</a>
<a id="11244" href="#11153" class="Function">lookup</a> <a id="11251" href="#11251" class="Bound">ind</a> <a id="11255" class="Symbol">(</a><a id="11256" href="#11256" class="Bound">x</a> <a id="11258" href="#7886" class="InductiveConstructor Operator">∷</a> <a id="11260" href="#11260" class="Bound">xs</a><a id="11262" class="Symbol">)</a> <a id="11264" href="#11007" class="InductiveConstructor">here₁</a> <a id="11270" class="Symbol">=</a> <a id="11272" href="#11256" class="Bound">x</a>
<a id="11274" href="#11153" class="Function">lookup</a> <a id="11281" href="#11281" class="Bound">ind</a> <a id="11285" class="Symbol">(</a><a id="11286" href="#11286" class="Bound">x</a> <a id="11288" href="#7886" class="InductiveConstructor Operator">∷</a> <a id="11290" href="#11290" class="Bound">xs</a><a id="11292" class="Symbol">)</a> <a id="11294" class="Symbol">(</a><a id="11295" href="#11056" class="InductiveConstructor">here₂</a> <a id="11301" href="#11301" class="Bound">i</a><a id="11302" class="Symbol">)</a> <a id="11304" class="Symbol">=</a> <a id="11306" href="#11281" class="Bound">ind</a> <a id="11310" href="#11301" class="Bound">i</a> <a id="11312" href="#11286" class="Bound">x</a>
<a id="11314" href="#11153" class="Function">lookup</a> <a id="11321" href="#11321" class="Bound">ind</a> <a id="11325" class="Symbol">(</a><a id="11326" href="#11326" class="Bound">x</a> <a id="11328" href="#7886" class="InductiveConstructor Operator">∷</a> <a id="11330" href="#11330" class="Bound">xs</a><a id="11332" class="Symbol">)</a> <a id="11334" class="Symbol">(</a><a id="11335" href="#11105" class="InductiveConstructor">there</a> <a id="11341" href="#11341" class="Bound">i</a> <a id="11343" href="#11343" class="Bound">is</a><a id="11345" class="Symbol">)</a> <a id="11347" class="Symbol">=</a> <a id="11349" href="#11321" class="Bound">ind</a> <a id="11353" href="#11341" class="Bound">i</a> <a id="11355" class="Symbol">(</a><a id="11356" href="#11153" class="Function">lookup</a> <a id="11363" href="#11321" class="Bound">ind</a> <a id="11367" href="#11330" class="Bound">xs</a> <a id="11370" href="#11343" class="Bound">is</a><a id="11372" class="Symbol">)</a>

<a id="nest-lookup"></a><a id="11375" href="#11375" class="Function">nest-lookup</a> <a id="11387" class="Symbol">:</a> <a id="11389" class="Symbol">(∀</a> <a id="11392" class="Symbol">{</a><a id="11393" href="#11393" class="Bound">A</a><a id="11394" class="Symbol">}</a> <a id="11396" class="Symbol">→</a> <a id="11398" href="#874" class="Generalizable">P</a> <a id="11400" class="Symbol">→</a> <a id="11402" href="#9450" class="Generalizable">F</a> <a id="11404" href="#11393" class="Bound">A</a> <a id="11406" class="Symbol">→</a> <a id="11408" href="#11393" class="Bound">A</a><a id="11409" class="Symbol">)</a>
            <a id="11423" class="Symbol">→</a> <a id="11425" href="#7823" class="Datatype">Array</a> <a id="11431" class="Symbol">(</a><a id="11432" href="#9268" class="Function">Nest</a> <a id="11437" href="#9450" class="Generalizable">F</a> <a id="11439" href="../code/binary/Prelude.html#470" class="Generalizable">A</a><a id="11440" class="Symbol">)</a> <a id="11442" href="#6437" class="Generalizable">ds</a>
            <a id="11457" class="Symbol">→</a> <a id="11459" href="#10969" class="Datatype">Fin𝔹</a> <a id="11464" href="#874" class="Generalizable">P</a> <a id="11466" href="#6437" class="Generalizable">ds</a>
            <a id="11481" class="Symbol">→</a> <a id="11483" href="../code/binary/Prelude.html#470" class="Generalizable">A</a>
<a id="11485" href="#11375" class="Function">nest-lookup</a> <a id="11497" href="#11497" class="Bound">ind</a> <a id="11501" class="Symbol">(</a><a id="11502" href="#11502" class="Bound">x</a> <a id="11504" href="#7886" class="InductiveConstructor Operator">∷</a> <a id="11506" href="#11506" class="Bound">xs</a><a id="11508" class="Symbol">)</a> <a id="11510" href="#11007" class="InductiveConstructor">here₁</a> <a id="11516" class="Symbol">=</a> <a id="11518" href="#11502" class="Bound">x</a>
<a id="11520" href="#11375" class="Function">nest-lookup</a> <a id="11532" href="#11532" class="Bound">ind</a> <a id="11536" class="Symbol">(</a><a id="11537" href="#11537" class="Bound">x</a> <a id="11539" href="#7886" class="InductiveConstructor Operator">∷</a> <a id="11541" href="#11541" class="Bound">xs</a><a id="11543" class="Symbol">)</a> <a id="11545" class="Symbol">(</a><a id="11546" href="#11056" class="InductiveConstructor">here₂</a> <a id="11552" href="#11552" class="Bound">i</a><a id="11553" class="Symbol">)</a> <a id="11555" class="Symbol">=</a> <a id="11557" href="#11532" class="Bound">ind</a> <a id="11561" href="#11552" class="Bound">i</a> <a id="11563" href="#11537" class="Bound">x</a>
<a id="11565" href="#11375" class="Function">nest-lookup</a> <a id="11577" href="#11577" class="Bound">ind</a> <a id="11581" class="Symbol">(</a><a id="11582" href="#11582" class="Bound">x</a> <a id="11584" href="#7886" class="InductiveConstructor Operator">∷</a> <a id="11586" href="#11586" class="Bound">xs</a><a id="11588" class="Symbol">)</a> <a id="11590" class="Symbol">(</a><a id="11591" href="#11105" class="InductiveConstructor">there</a> <a id="11597" href="#11597" class="Bound">i</a> <a id="11599" href="#11599" class="Bound">is</a><a id="11601" class="Symbol">)</a> <a id="11603" class="Symbol">=</a> <a id="11605" href="#11577" class="Bound">ind</a> <a id="11609" href="#11597" class="Bound">i</a> <a id="11611" class="Symbol">(</a><a id="11612" href="#11375" class="Function">nest-lookup</a> <a id="11624" href="#11577" class="Bound">ind</a> <a id="11628" href="#11586" class="Bound">xs</a> <a id="11631" href="#11599" class="Bound">is</a><a id="11633" class="Symbol">)</a>
</pre>
<p>We’ll once more use perfect to show how these generic functions can be concretised. For the index types into a perfect tree, we will use a <code>Bool</code>.</p>
<pre class="Agda"><a id="perf-lookup"></a><a id="11797" href="#11797" class="Function">perf-lookup</a> <a id="11809" class="Symbol">:</a> <a id="11811" href="#7823" class="Datatype">Array</a> <a id="11817" class="Symbol">(</a><a id="11818" href="#9372" class="Function">Perfect</a> <a id="11826" href="../code/binary/Prelude.html#470" class="Generalizable">A</a><a id="11827" class="Symbol">)</a> <a id="11829" href="#6437" class="Generalizable">ds</a> <a id="11832" class="Symbol">→</a> <a id="11834" href="#10969" class="Datatype">Fin𝔹</a> <a id="11839" href="../code/binary/Prelude.html#1369" class="Datatype">Bool</a> <a id="11844" href="#6437" class="Generalizable">ds</a> <a id="11847" class="Symbol">→</a> <a id="11849" href="../code/binary/Prelude.html#470" class="Generalizable">A</a>
<a id="11851" href="#11797" class="Function">perf-lookup</a> <a id="11863" class="Symbol">=</a> <a id="11865" href="#11375" class="Function">nest-lookup</a> <a id="11877" class="Symbol">(</a><a id="11878" href="../code/binary/Prelude.html#1416" class="Function">bool</a> <a id="11883" href="../code/binary/Agda.Builtin.Sigma.html#225" class="Field">fst</a> <a id="11887" href="../code/binary/Agda.Builtin.Sigma.html#237" class="Field">snd</a><a id="11890" class="Symbol">)</a>
</pre>
<h1 id="folding">Folding</h1>
<p>This next function is quite difficult to get right: a fold. We want to consume the binary array into a unary, cons-list type thing. Similarly to <code>foldl</code> on vectors, we will need to change the return type as we fold, but we will <em>also</em> need to convert from binary to unary, <em>as we fold</em>. The key ingredient is the following function:</p>
<pre class="Agda"><a id="2^_*_"></a><a id="12250" href="#12250" class="Function Operator">2^_*_</a> <a id="12256" class="Symbol">:</a> <a id="12258" href="../code/binary/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="12260" class="Symbol">→</a> <a id="12262" href="../code/binary/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="12264" class="Symbol">→</a> <a id="12266" href="../code/binary/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a>
<a id="12268" href="#12250" class="Function Operator">2^</a> <a id="12271" href="../code/binary/Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a>  <a id="12277" href="#12250" class="Function Operator">*</a> <a id="12279" href="#12279" class="Bound">n</a> <a id="12281" class="Symbol">=</a> <a id="12283" href="#12279" class="Bound">n</a>
<a id="12285" href="#12250" class="Function Operator">2^</a> <a id="12288" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="12292" href="#12292" class="Bound">m</a> <a id="12294" href="#12250" class="Function Operator">*</a> <a id="12296" href="#12296" class="Bound">n</a> <a id="12298" class="Symbol">=</a> <a id="12300" href="#4231" class="Function">2*</a> <a id="12303" class="Symbol">(</a><a id="12304" href="#12250" class="Function Operator">2^</a> <a id="12307" href="#12292" class="Bound">m</a> <a id="12309" href="#12250" class="Function Operator">*</a> <a id="12311" href="#12296" class="Bound">n</a><a id="12312" class="Symbol">)</a>
</pre>
<p>It will let us do the type-change-as-you-go trick from <code>foldl</code>, but in a binary setting. Here’s <code>foldr</code>:</p>
<pre class="Agda"><a id="array-foldr"></a><a id="12433" href="#12433" class="Function">array-foldr</a> <a id="12445" class="Symbol">:</a> <a id="12447" class="Symbol">(</a><a id="12448" href="#12448" class="Bound">B</a> <a id="12450" class="Symbol">:</a> <a id="12452" href="../code/binary/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="12454" class="Symbol">→</a> <a id="12456" href="../code/binary/Cubical.Core.Primitives.html#957" class="Function">Type</a> <a id="12461" href="../code/binary/Prelude.html#456" class="Generalizable">b</a><a id="12462" class="Symbol">)</a>
            <a id="12476" class="Symbol">→</a> <a id="12478" class="Symbol">(∀</a> <a id="12481" href="#12481" class="Bound">n</a> <a id="12483" class="Symbol">{</a><a id="12484" href="#12484" class="Bound">m</a><a id="12485" class="Symbol">}</a> <a id="12487" class="Symbol">→</a> <a id="12489" href="#846" class="Generalizable">T</a> <a id="12491" href="#12481" class="Bound">n</a> <a id="12493" class="Symbol">→</a> <a id="12495" href="#12448" class="Bound">B</a> <a id="12497" class="Symbol">(</a><a id="12498" href="#12250" class="Function Operator">2^</a> <a id="12501" href="#12481" class="Bound">n</a> <a id="12503" href="#12250" class="Function Operator">*</a> <a id="12505" href="#12484" class="Bound">m</a><a id="12506" class="Symbol">)</a> <a id="12508" class="Symbol">→</a> <a id="12510" href="#12448" class="Bound">B</a> <a id="12512" class="Symbol">(</a><a id="12513" href="#12250" class="Function Operator">2^</a> <a id="12516" href="#12481" class="Bound">n</a> <a id="12518" href="#12250" class="Function Operator">*</a> <a id="12520" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="12524" href="#12484" class="Bound">m</a><a id="12525" class="Symbol">))</a>
            <a id="12540" class="Symbol">→</a> <a id="12542" href="#12448" class="Bound">B</a> <a id="12544" class="Number">0</a> <a id="12546" class="Symbol">→</a> <a id="12548" href="#7823" class="Datatype">Array</a> <a id="12554" href="#846" class="Generalizable">T</a> <a id="12556" href="#6437" class="Generalizable">ds</a> <a id="12559" class="Symbol">→</a> <a id="12561" href="#12448" class="Bound">B</a> <a id="12563" href="#6703" class="Function Operator">⟦</a> <a id="12565" href="#6437" class="Generalizable">ds</a> <a id="12568" href="#6703" class="Function Operator">⇓⟧</a>
<a id="12571" href="#12433" class="Function">array-foldr</a> <a id="12583" href="#12583" class="Bound">B</a> <a id="12585" href="#12585" class="Bound">c</a> <a id="12587" href="#12587" class="Bound">b</a> <a id="12589" href="#7867" class="InductiveConstructor">[]</a>        <a id="12599" class="Symbol">=</a> <a id="12601" href="#12587" class="Bound">b</a>
<a id="12603" href="#12433" class="Function">array-foldr</a> <a id="12615" href="#12615" class="Bound">B</a> <a id="12617" href="#12617" class="Bound">c</a> <a id="12619" href="#12619" class="Bound">b</a> <a id="12621" class="Symbol">(</a><a id="12622" href="#12622" class="Bound">x</a> <a id="12624" href="#7956" class="InductiveConstructor Operator">1∷</a> <a id="12627" href="#12627" class="Bound">xs</a><a id="12629" class="Symbol">)</a> <a id="12631" class="Symbol">=</a> <a id="12633" href="#12617" class="Bound">c</a> <a id="12635" class="Number">0</a> <a id="12637" href="#12622" class="Bound">x</a> <a id="12639" class="Symbol">(</a><a id="12640" href="#12433" class="Function">array-foldr</a> <a id="12652" class="Symbol">(</a><a id="12653" href="#12615" class="Bound">B</a> <a id="12655" href="../code/binary/Prelude.html#942" class="Function Operator">∘</a> <a id="12657" href="#4231" class="Function">2*</a><a id="12659" class="Symbol">)</a> <a id="12661" class="Symbol">(</a><a id="12662" href="#12617" class="Bound">c</a> <a id="12664" href="../code/binary/Prelude.html#942" class="Function Operator">∘</a> <a id="12666" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a><a id="12669" class="Symbol">)</a> <a id="12671" href="#12619" class="Bound">b</a> <a id="12673" href="#12627" class="Bound">xs</a><a id="12675" class="Symbol">)</a>
<a id="12677" href="#12433" class="Function">array-foldr</a> <a id="12689" href="#12689" class="Bound">B</a> <a id="12691" href="#12691" class="Bound">c</a> <a id="12693" href="#12693" class="Bound">b</a> <a id="12695" class="Symbol">(</a><a id="12696" href="#12696" class="Bound">x</a> <a id="12698" href="#7994" class="InductiveConstructor Operator">2∷</a> <a id="12701" href="#12701" class="Bound">xs</a><a id="12703" class="Symbol">)</a> <a id="12705" class="Symbol">=</a> <a id="12707" href="#12691" class="Bound">c</a> <a id="12709" class="Number">1</a> <a id="12711" href="#12696" class="Bound">x</a> <a id="12713" class="Symbol">(</a><a id="12714" href="#12433" class="Function">array-foldr</a> <a id="12726" class="Symbol">(</a><a id="12727" href="#12689" class="Bound">B</a> <a id="12729" href="../code/binary/Prelude.html#942" class="Function Operator">∘</a> <a id="12731" href="#4231" class="Function">2*</a><a id="12733" class="Symbol">)</a> <a id="12735" class="Symbol">(</a><a id="12736" href="#12691" class="Bound">c</a> <a id="12738" href="../code/binary/Prelude.html#942" class="Function Operator">∘</a> <a id="12740" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a><a id="12743" class="Symbol">)</a> <a id="12745" href="#12693" class="Bound">b</a> <a id="12747" href="#12701" class="Bound">xs</a><a id="12749" class="Symbol">)</a>
</pre>
<p>And, as you should expect, here’s how to use this in combination with the perfect trees. Here we’ll build a binary random access list from a vector, and convert back to a vector.</p>
<pre class="Agda"><a id="perf-foldr"></a><a id="12944" href="#12944" class="Function">perf-foldr</a> <a id="12955" class="Symbol">:</a> <a id="12957" class="Symbol">(</a><a id="12958" href="#12958" class="Bound">B</a> <a id="12960" class="Symbol">:</a> <a id="12962" href="../code/binary/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="12964" class="Symbol">→</a> <a id="12966" href="../code/binary/Cubical.Core.Primitives.html#957" class="Function">Type</a> <a id="12971" href="../code/binary/Prelude.html#456" class="Generalizable">b</a><a id="12972" class="Symbol">)</a>
           <a id="12985" class="Symbol">→</a> <a id="12987" class="Symbol">(∀</a> <a id="12990" class="Symbol">{</a><a id="12991" href="#12991" class="Bound">n</a><a id="12992" class="Symbol">}</a> <a id="12994" class="Symbol">→</a> <a id="12996" href="../code/binary/Prelude.html#470" class="Generalizable">A</a> <a id="12998" class="Symbol">→</a> <a id="13000" href="#12958" class="Bound">B</a> <a id="13002" href="#12991" class="Bound">n</a> <a id="13004" class="Symbol">→</a> <a id="13006" href="#12958" class="Bound">B</a> <a id="13008" class="Symbol">(</a><a id="13009" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="13013" href="#12991" class="Bound">n</a><a id="13014" class="Symbol">))</a>
           <a id="13028" class="Symbol">→</a> <a id="13030" class="Symbol">∀</a> <a id="13032" href="#13032" class="Bound">n</a> <a id="13034" class="Symbol">{</a><a id="13035" href="#13035" class="Bound">m</a><a id="13036" class="Symbol">}</a>
           <a id="13049" class="Symbol">→</a> <a id="13051" href="#9372" class="Function">Perfect</a> <a id="13059" href="../code/binary/Prelude.html#470" class="Generalizable">A</a> <a id="13061" href="#13032" class="Bound">n</a>
           <a id="13074" class="Symbol">→</a> <a id="13076" href="#12958" class="Bound">B</a> <a id="13078" class="Symbol">(</a><a id="13079" href="#12250" class="Function Operator">2^</a> <a id="13082" href="#13032" class="Bound">n</a> <a id="13084" href="#12250" class="Function Operator">*</a> <a id="13086" href="#13035" class="Bound">m</a><a id="13087" class="Symbol">)</a>
           <a id="13100" class="Symbol">→</a> <a id="13102" href="#12958" class="Bound">B</a> <a id="13104" class="Symbol">(</a><a id="13105" href="#12250" class="Function Operator">2^</a> <a id="13108" href="#13032" class="Bound">n</a> <a id="13110" href="#12250" class="Function Operator">*</a> <a id="13112" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="13116" href="#13035" class="Bound">m</a><a id="13117" class="Symbol">)</a>
<a id="13119" href="#12944" class="Function">perf-foldr</a> <a id="13130" href="#13130" class="Bound">B</a> <a id="13132" href="#13132" class="Bound">f</a> <a id="13134" href="../code/binary/Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a> <a id="13139" class="Symbol">=</a> <a id="13141" href="#13132" class="Bound">f</a>
<a id="13143" href="#12944" class="Function">perf-foldr</a> <a id="13154" href="#13154" class="Bound">B</a> <a id="13156" href="#13156" class="Bound">f</a> <a id="13158" class="Symbol">(</a><a id="13159" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="13163" href="#13163" class="Bound">n</a><a id="13164" class="Symbol">)</a> <a id="13166" class="Symbol">=</a>
  <a id="13170" href="#12944" class="Function">perf-foldr</a> <a id="13181" class="Symbol">(</a><a id="13182" href="#13154" class="Bound">B</a> <a id="13184" href="../code/binary/Prelude.html#942" class="Function Operator">∘</a> <a id="13186" href="#4231" class="Function">2*</a><a id="13188" class="Symbol">)</a> <a id="13190" class="Symbol">(λ</a> <a id="13193" class="Symbol">{</a> <a id="13195" class="Symbol">(</a><a id="13196" href="#13196" class="Bound">x</a> <a id="13198" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="13200" href="#13200" class="Bound">y</a><a id="13201" class="Symbol">)</a> <a id="13203" href="#13203" class="Bound">zs</a> <a id="13206" class="Symbol">→</a> <a id="13208" href="#13156" class="Bound">f</a> <a id="13210" href="#13196" class="Bound">x</a> <a id="13212" class="Symbol">(</a><a id="13213" href="#13156" class="Bound">f</a> <a id="13215" href="#13200" class="Bound">y</a> <a id="13217" href="#13203" class="Bound">zs</a><a id="13219" class="Symbol">)</a> <a id="13221" class="Symbol">})</a> <a id="13224" href="#13163" class="Bound">n</a>

<a id="toVec"></a><a id="13227" href="#13227" class="Function">toVec</a> <a id="13233" class="Symbol">:</a> <a id="13235" href="#7823" class="Datatype">Array</a> <a id="13241" class="Symbol">(</a><a id="13242" href="#9372" class="Function">Perfect</a> <a id="13250" href="../code/binary/Prelude.html#470" class="Generalizable">A</a><a id="13251" class="Symbol">)</a> <a id="13253" href="#6437" class="Generalizable">ds</a> <a id="13256" class="Symbol">→</a> <a id="13258" href="#1557" class="Datatype">Vec</a> <a id="13262" href="../code/binary/Prelude.html#470" class="Generalizable">A</a> <a id="13264" href="#6703" class="Function Operator">⟦</a> <a id="13266" href="#6437" class="Generalizable">ds</a> <a id="13269" href="#6703" class="Function Operator">⇓⟧</a>
<a id="13272" href="#13227" class="Function">toVec</a> <a id="13278" class="Symbol">=</a> <a id="13280" href="#12433" class="Function">array-foldr</a> <a id="13292" class="Symbol">(</a><a id="13293" href="#1557" class="Datatype">Vec</a> <a id="13297" class="Symbol">_)</a> <a id="13300" class="Symbol">(</a><a id="13301" href="#12944" class="Function">perf-foldr</a> <a id="13312" class="Symbol">(</a><a id="13313" href="#1557" class="Datatype">Vec</a> <a id="13317" class="Symbol">_)</a> <a id="13320" href="#1611" class="InductiveConstructor Operator">_∷_</a><a id="13323" class="Symbol">)</a> <a id="13325" href="#1593" class="InductiveConstructor">[]</a>

<a id="fromVec"></a><a id="13329" href="#13329" class="Function">fromVec</a> <a id="13337" class="Symbol">:</a> <a id="13339" href="#1557" class="Datatype">Vec</a> <a id="13343" href="../code/binary/Prelude.html#470" class="Generalizable">A</a> <a id="13345" href="../code/binary/Prelude.html#506" class="Generalizable">n</a> <a id="13347" class="Symbol">→</a> <a id="13349" href="#7823" class="Datatype">Array</a> <a id="13355" class="Symbol">(</a><a id="13356" href="#9372" class="Function">Perfect</a> <a id="13364" href="../code/binary/Prelude.html#470" class="Generalizable">A</a><a id="13365" class="Symbol">)</a> <a id="13367" href="#7079" class="Function Operator">⟦</a> <a id="13369" href="../code/binary/Prelude.html#506" class="Generalizable">n</a> <a id="13371" href="#7079" class="Function Operator">⇑⟧</a>
<a id="13374" href="#13329" class="Function">fromVec</a> <a id="13382" class="Symbol">=</a> <a id="13384" href="#2378" class="Function">vec-foldr</a> <a id="13394" class="Symbol">(</a><a id="13395" href="#7823" class="Datatype">Array</a> <a id="13401" class="Symbol">(</a><a id="13402" href="#9372" class="Function">Perfect</a> <a id="13410" class="Symbol">_)</a> <a id="13413" href="../code/binary/Prelude.html#942" class="Function Operator">∘</a> <a id="13415" href="#7079" class="Function Operator">⟦_⇑⟧</a><a id="13419" class="Symbol">)</a> <a id="13421" href="#10697" class="Function">perf-cons</a> <a id="13431" href="#7867" class="InductiveConstructor">[]</a>
</pre>
<h1 id="lenses">Lenses</h1>
<p>That’s the end of the “simple” stuff! The binary random-access list I’ve presented above is about as simple as I can get it.</p>
<p>In this section, I want to look at some more complex (and more fun) things you can do with it. First: lenses.</p>
<p>Lenses aren’t super ergonomic in dependently-typed languages, but they do come with some advantages. The lens laws are quite strong, for instance, meaning that often by constructing programs using a lot of lenses gives us certain properties “for free”. Here, for instance, we can define the lenses for indexing.</p>
<pre class="Agda"><a id="14007" class="Keyword">open</a> <a id="14012" class="Keyword">import</a> <a id="14019" href="../code/binary/Lenses.html" class="Module">Lenses</a>
</pre>
<details>
<p><summary>Lenses into the head and tail of an array</summary></p>
<pre class="Agda"><a id="head"></a><a id="14111" href="#14111" class="Function">head</a> <a id="14116" class="Symbol">:</a> <a id="14118" href="../code/binary/Lenses.html#203" class="Record">Lens</a> <a id="14123" class="Symbol">(</a><a id="14124" href="#7823" class="Datatype">Array</a> <a id="14130" href="#846" class="Generalizable">T</a> <a id="14132" class="Symbol">(</a><a id="14133" href="#6427" class="Generalizable">d</a> <a id="14135" href="../code/binary/Prelude.html#807" class="InductiveConstructor Operator">∷</a> <a id="14137" href="#6437" class="Generalizable">ds</a><a id="14139" class="Symbol">))</a> <a id="14142" class="Symbol">(</a><a id="14143" href="#846" class="Generalizable">T</a> <a id="14145" class="Symbol">(</a><a id="14146" href="../code/binary/Prelude.html#1416" class="Function">bool</a> <a id="14151" class="Number">0</a> <a id="14153" class="Number">1</a> <a id="14155" href="#6427" class="Generalizable">d</a><a id="14156" class="Symbol">))</a>
<a id="14159" href="#14111" class="Function">head</a> <a id="14164" class="Symbol">.</a><a id="14165" href="../code/binary/Lenses.html#265" class="Field">into</a> <a id="14170" class="Symbol">(</a><a id="14171" href="#14171" class="Bound">x</a> <a id="14173" href="#7886" class="InductiveConstructor Operator">∷</a> <a id="14175" class="Symbol">_</a> <a id="14177" class="Symbol">)</a> <a id="14179" class="Symbol">.</a><a id="14180" href="../code/binary/Lenses.html#150" class="Field">get</a> <a id="14184" class="Symbol">=</a> <a id="14186" href="#14171" class="Bound">x</a>
<a id="14188" href="#14111" class="Function">head</a> <a id="14193" class="Symbol">.</a><a id="14194" href="../code/binary/Lenses.html#265" class="Field">into</a> <a id="14199" class="Symbol">(_</a> <a id="14202" href="#7886" class="InductiveConstructor Operator">∷</a> <a id="14204" href="#14204" class="Bound">xs</a><a id="14206" class="Symbol">)</a> <a id="14208" class="Symbol">.</a><a id="14209" href="../code/binary/Lenses.html#162" class="Field">set</a> <a id="14213" href="#14213" class="Bound">x</a> <a id="14215" class="Symbol">=</a> <a id="14217" href="#14213" class="Bound">x</a> <a id="14219" href="#7886" class="InductiveConstructor Operator">∷</a> <a id="14221" href="#14204" class="Bound">xs</a>
<a id="14224" href="#14111" class="Function">head</a> <a id="14229" class="Symbol">.</a><a id="14230" href="../code/binary/Lenses.html#293" class="Field">get-set</a> <a id="14238" class="Symbol">(_</a> <a id="14241" href="#7886" class="InductiveConstructor Operator">∷</a> <a id="14243" class="Symbol">_)</a> <a id="14246" class="Symbol">_</a> <a id="14248" class="Symbol">=</a> <a id="14250" href="../code/binary/Cubical.Foundations.Prelude.html#856" class="Function">refl</a>
<a id="14255" href="#14111" class="Function">head</a> <a id="14260" class="Symbol">.</a><a id="14261" href="../code/binary/Lenses.html#345" class="Field">set-get</a> <a id="14269" class="Symbol">(_</a> <a id="14272" href="#7886" class="InductiveConstructor Operator">∷</a> <a id="14274" class="Symbol">_)</a> <a id="14277" class="Symbol">=</a> <a id="14279" href="../code/binary/Cubical.Foundations.Prelude.html#856" class="Function">refl</a>
<a id="14284" href="#14111" class="Function">head</a> <a id="14289" class="Symbol">.</a><a id="14290" href="../code/binary/Lenses.html#395" class="Field">set-set</a> <a id="14298" class="Symbol">(_</a> <a id="14301" href="#7886" class="InductiveConstructor Operator">∷</a> <a id="14303" class="Symbol">_)</a> <a id="14306" class="Symbol">_</a> <a id="14308" class="Symbol">_</a> <a id="14310" class="Symbol">=</a> <a id="14312" href="../code/binary/Cubical.Foundations.Prelude.html#856" class="Function">refl</a>

<a id="tail"></a><a id="14318" href="#14318" class="Function">tail</a> <a id="14323" class="Symbol">:</a> <a id="14325" href="../code/binary/Lenses.html#203" class="Record">Lens</a> <a id="14330" class="Symbol">(</a><a id="14331" href="#7823" class="Datatype">Array</a> <a id="14337" href="#846" class="Generalizable">T</a> <a id="14339" class="Symbol">(</a><a id="14340" href="#6427" class="Generalizable">d</a> <a id="14342" href="../code/binary/Prelude.html#807" class="InductiveConstructor Operator">∷</a> <a id="14344" href="#6437" class="Generalizable">ds</a><a id="14346" class="Symbol">))</a> <a id="14349" class="Symbol">(</a><a id="14350" href="#7823" class="Datatype">Array</a> <a id="14356" class="Symbol">(</a><a id="14357" href="#846" class="Generalizable">T</a> <a id="14359" href="../code/binary/Prelude.html#942" class="Function Operator">∘</a> <a id="14361" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a><a id="14364" class="Symbol">)</a> <a id="14366" href="#6437" class="Generalizable">ds</a><a id="14368" class="Symbol">)</a>
<a id="14370" href="#14318" class="Function">tail</a> <a id="14375" class="Symbol">.</a><a id="14376" href="../code/binary/Lenses.html#265" class="Field">into</a> <a id="14381" class="Symbol">(_</a> <a id="14384" href="#7886" class="InductiveConstructor Operator">∷</a> <a id="14386" href="#14386" class="Bound">xs</a><a id="14388" class="Symbol">)</a> <a id="14390" class="Symbol">.</a><a id="14391" href="../code/binary/Lenses.html#150" class="Field">get</a> <a id="14395" class="Symbol">=</a> <a id="14397" href="#14386" class="Bound">xs</a>
<a id="14400" href="#14318" class="Function">tail</a> <a id="14405" class="Symbol">.</a><a id="14406" href="../code/binary/Lenses.html#265" class="Field">into</a> <a id="14411" class="Symbol">(</a><a id="14412" href="#14412" class="Bound">x</a> <a id="14414" href="#7886" class="InductiveConstructor Operator">∷</a> <a id="14416" class="Symbol">_</a> <a id="14418" class="Symbol">)</a> <a id="14420" class="Symbol">.</a><a id="14421" href="../code/binary/Lenses.html#162" class="Field">set</a> <a id="14425" href="#14425" class="Bound">xs</a> <a id="14428" class="Symbol">=</a> <a id="14430" href="#14412" class="Bound">x</a> <a id="14432" href="#7886" class="InductiveConstructor Operator">∷</a> <a id="14434" href="#14425" class="Bound">xs</a>
<a id="14437" href="#14318" class="Function">tail</a> <a id="14442" class="Symbol">.</a><a id="14443" href="../code/binary/Lenses.html#293" class="Field">get-set</a> <a id="14451" class="Symbol">(_</a> <a id="14454" href="#7886" class="InductiveConstructor Operator">∷</a> <a id="14456" class="Symbol">_)</a> <a id="14459" class="Symbol">_</a> <a id="14461" class="Symbol">=</a> <a id="14463" href="../code/binary/Cubical.Foundations.Prelude.html#856" class="Function">refl</a>
<a id="14468" href="#14318" class="Function">tail</a> <a id="14473" class="Symbol">.</a><a id="14474" href="../code/binary/Lenses.html#345" class="Field">set-get</a> <a id="14482" class="Symbol">(_</a> <a id="14485" href="#7886" class="InductiveConstructor Operator">∷</a> <a id="14487" class="Symbol">_)</a> <a id="14490" class="Symbol">=</a> <a id="14492" href="../code/binary/Cubical.Foundations.Prelude.html#856" class="Function">refl</a>
<a id="14497" href="#14318" class="Function">tail</a> <a id="14502" class="Symbol">.</a><a id="14503" href="../code/binary/Lenses.html#395" class="Field">set-set</a> <a id="14511" class="Symbol">(_</a> <a id="14514" href="#7886" class="InductiveConstructor Operator">∷</a> <a id="14516" class="Symbol">_)</a> <a id="14519" class="Symbol">_</a> <a id="14521" class="Symbol">_</a> <a id="14523" class="Symbol">=</a> <a id="14525" href="../code/binary/Cubical.Foundations.Prelude.html#856" class="Function">refl</a>
</pre>
</details>
<pre class="Agda"><a id="nest-lens"></a><a id="14555" href="#14555" class="Function">nest-lens</a> <a id="14565" class="Symbol">:</a> <a id="14567" class="Symbol">(∀</a> <a id="14570" class="Symbol">{</a><a id="14571" href="#14571" class="Bound">A</a><a id="14572" class="Symbol">}</a> <a id="14574" class="Symbol">→</a> <a id="14576" href="#874" class="Generalizable">P</a> <a id="14578" class="Symbol">→</a> <a id="14580" href="../code/binary/Lenses.html#203" class="Record">Lens</a> <a id="14585" class="Symbol">(</a><a id="14586" href="#9450" class="Generalizable">F</a> <a id="14588" href="#14571" class="Bound">A</a><a id="14589" class="Symbol">)</a> <a id="14591" href="#14571" class="Bound">A</a><a id="14592" class="Symbol">)</a>
          <a id="14604" class="Symbol">→</a> <a id="14606" href="#10969" class="Datatype">Fin𝔹</a> <a id="14611" href="#874" class="Generalizable">P</a> <a id="14613" href="#6437" class="Generalizable">ds</a>
          <a id="14626" class="Symbol">→</a> <a id="14628" href="../code/binary/Lenses.html#203" class="Record">Lens</a> <a id="14633" class="Symbol">(</a><a id="14634" href="#7823" class="Datatype">Array</a> <a id="14640" class="Symbol">(</a><a id="14641" href="#9268" class="Function">Nest</a> <a id="14646" href="#9450" class="Generalizable">F</a> <a id="14648" href="../code/binary/Prelude.html#470" class="Generalizable">A</a><a id="14649" class="Symbol">)</a> <a id="14651" href="#6437" class="Generalizable">ds</a><a id="14653" class="Symbol">)</a> <a id="14655" href="../code/binary/Prelude.html#470" class="Generalizable">A</a>
<a id="14657" href="#14555" class="Function">nest-lens</a> <a id="14667" href="#14667" class="Bound">ln</a> <a id="14670" href="#11007" class="InductiveConstructor">here₁</a>        <a id="14683" class="Symbol">=</a> <a id="14685" href="#14111" class="Function">head</a>
<a id="14690" href="#14555" class="Function">nest-lens</a> <a id="14700" href="#14700" class="Bound">ln</a> <a id="14703" class="Symbol">(</a><a id="14704" href="#11056" class="InductiveConstructor">here₂</a> <a id="14710" href="#14710" class="Bound">i</a><a id="14711" class="Symbol">)</a>    <a id="14716" class="Symbol">=</a> <a id="14718" href="#14111" class="Function">head</a> <a id="14723" href="../code/binary/Lenses.html#631" class="Function Operator">⋯</a> <a id="14725" href="#14700" class="Bound">ln</a> <a id="14728" href="#14710" class="Bound">i</a>
<a id="14730" href="#14555" class="Function">nest-lens</a> <a id="14740" href="#14740" class="Bound">ln</a> <a id="14743" class="Symbol">(</a><a id="14744" href="#11105" class="InductiveConstructor">there</a> <a id="14750" href="#14750" class="Bound">i</a> <a id="14752" href="#14752" class="Bound">is</a><a id="14754" class="Symbol">)</a> <a id="14756" class="Symbol">=</a> <a id="14758" href="#14318" class="Function">tail</a> <a id="14763" href="../code/binary/Lenses.html#631" class="Function Operator">⋯</a> <a id="14765" href="#14555" class="Function">nest-lens</a> <a id="14775" href="#14740" class="Bound">ln</a> <a id="14778" href="#14752" class="Bound">is</a> <a id="14781" href="../code/binary/Lenses.html#631" class="Function Operator">⋯</a> <a id="14783" href="#14740" class="Bound">ln</a> <a id="14786" href="#14750" class="Bound">i</a>
</pre>
<details>
<p><summary>Top-down version</summary></p>
<pre class="Agda"><a id="ind-lens"></a><a id="14848" href="#14848" class="Function">ind-lens</a> <a id="14857" class="Symbol">:</a> <a id="14859" class="Symbol">(∀</a> <a id="14862" class="Symbol">{</a><a id="14863" href="#14863" class="Bound">n</a><a id="14864" class="Symbol">}</a> <a id="14866" class="Symbol">→</a> <a id="14868" href="#874" class="Generalizable">P</a> <a id="14870" class="Symbol">→</a> <a id="14872" href="../code/binary/Lenses.html#203" class="Record">Lens</a> <a id="14877" class="Symbol">(</a><a id="14878" href="#846" class="Generalizable">T</a> <a id="14880" class="Symbol">(</a><a id="14881" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="14885" href="#14863" class="Bound">n</a><a id="14886" class="Symbol">))</a> <a id="14889" class="Symbol">(</a><a id="14890" href="#846" class="Generalizable">T</a> <a id="14892" href="#14863" class="Bound">n</a><a id="14893" class="Symbol">))</a>
         <a id="14905" class="Symbol">→</a> <a id="14907" href="#10969" class="Datatype">Fin𝔹</a> <a id="14912" href="#874" class="Generalizable">P</a> <a id="14914" href="#6437" class="Generalizable">ds</a>
         <a id="14926" class="Symbol">→</a> <a id="14928" href="../code/binary/Lenses.html#203" class="Record">Lens</a> <a id="14933" class="Symbol">(</a><a id="14934" href="#7823" class="Datatype">Array</a> <a id="14940" href="#846" class="Generalizable">T</a> <a id="14942" href="#6437" class="Generalizable">ds</a><a id="14944" class="Symbol">)</a> <a id="14946" class="Symbol">(</a><a id="14947" href="#846" class="Generalizable">T</a> <a id="14949" class="Number">0</a><a id="14950" class="Symbol">)</a>
<a id="14952" href="#14848" class="Function">ind-lens</a> <a id="14961" href="#14961" class="Bound">ln</a> <a id="14964" href="#11007" class="InductiveConstructor">here₁</a>        <a id="14977" class="Symbol">=</a> <a id="14979" href="#14111" class="Function">head</a>
<a id="14984" href="#14848" class="Function">ind-lens</a> <a id="14993" href="#14993" class="Bound">ln</a> <a id="14996" class="Symbol">(</a><a id="14997" href="#11056" class="InductiveConstructor">here₂</a> <a id="15003" href="#15003" class="Bound">i</a><a id="15004" class="Symbol">)</a>    <a id="15009" class="Symbol">=</a> <a id="15011" href="#14111" class="Function">head</a> <a id="15016" href="../code/binary/Lenses.html#631" class="Function Operator">⋯</a> <a id="15018" href="#14993" class="Bound">ln</a> <a id="15021" href="#15003" class="Bound">i</a>
<a id="15023" href="#14848" class="Function">ind-lens</a> <a id="15032" href="#15032" class="Bound">ln</a> <a id="15035" class="Symbol">(</a><a id="15036" href="#11105" class="InductiveConstructor">there</a> <a id="15042" href="#15042" class="Bound">i</a> <a id="15044" href="#15044" class="Bound">is</a><a id="15046" class="Symbol">)</a> <a id="15048" class="Symbol">=</a> <a id="15050" href="#14318" class="Function">tail</a> <a id="15055" href="../code/binary/Lenses.html#631" class="Function Operator">⋯</a> <a id="15057" href="#14848" class="Function">ind-lens</a> <a id="15066" href="#15032" class="Bound">ln</a> <a id="15069" href="#15044" class="Bound">is</a> <a id="15072" href="../code/binary/Lenses.html#631" class="Function Operator">⋯</a> <a id="15074" href="#15032" class="Bound">ln</a> <a id="15077" href="#15042" class="Bound">i</a>
</pre>
</details>
<h1 id="fenwick-trees">Fenwick Trees</h1>
<p>Finally, to demonstrate some of the versatility of this data structure, we’re going to implement a tree based on a <em>Fenwick</em> tree. This is a data structure for prefix sums: we can query the running total at any point, and <em>update</em> the value at a given point, in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math> time. We’re going to make it generic over a monoid:</p>
<pre class="Agda"><a id="15458" class="Keyword">module</a> <a id="15465" href="#15465" class="Module">_</a> <a id="15467" class="Symbol">{</a><a id="15468" href="#15468" class="Bound">ℓ</a><a id="15469" class="Symbol">}</a> <a id="15471" class="Symbol">(</a><a id="15472" href="#15472" class="Bound">mon</a> <a id="15476" class="Symbol">:</a> <a id="15478" href="../code/binary/Prelude.html#1125" class="Record">Monoid</a> <a id="15485" href="#15468" class="Bound">ℓ</a><a id="15486" class="Symbol">)</a> <a id="15488" class="Keyword">where</a>
  <a id="15496" class="Keyword">open</a> <a id="15501" href="../code/binary/Prelude.html#1125" class="Module">Monoid</a> <a id="15508" href="#15472" class="Bound">mon</a>

  <a id="15515" class="Keyword">record</a> <a id="15522" href="#15522" class="Record">Leaf</a> <a id="15527" class="Symbol">:</a> <a id="15529" class="PrimitiveType">Set</a> <a id="15533" href="#15468" class="Bound">ℓ</a> <a id="15535" class="Keyword">where</a>
    <a id="15545" class="Keyword">constructor</a> <a id="15557" href="#15557" class="InductiveConstructor">leaf</a>
    <a id="15566" class="Keyword">field</a> <a id="15572" href="#15572" class="Field">val</a> <a id="15576" class="Symbol">:</a> <a id="15578" href="../code/binary/Prelude.html#1182" class="Field">𝑆</a>
  <a id="15582" class="Keyword">open</a> <a id="15587" href="#15522" class="Module">Leaf</a>

  <a id="15595" class="Keyword">mutual</a>
    <a id="15606" href="#15606" class="Function">SumNode</a> <a id="15614" class="Symbol">:</a> <a id="15616" href="../code/binary/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="15618" class="Symbol">→</a> <a id="15620" class="PrimitiveType">Set</a> <a id="15624" href="#15468" class="Bound">ℓ</a>
    <a id="15630" href="#15606" class="Function">SumNode</a> <a id="15638" href="../code/binary/Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a> <a id="15643" class="Symbol">=</a> <a id="15645" href="#15522" class="Record">Leaf</a>
    <a id="15654" href="#15606" class="Function">SumNode</a> <a id="15662" class="Symbol">(</a><a id="15663" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="15667" href="#15667" class="Bound">n</a><a id="15668" class="Symbol">)</a> <a id="15670" class="Symbol">=</a> <a id="15672" href="#15699" class="Function">Summary</a> <a id="15680" href="#15667" class="Bound">n</a> <a id="15682" href="../code/binary/Prelude.html#621" class="Function Operator">×</a> <a id="15684" href="#15699" class="Function">Summary</a> <a id="15692" href="#15667" class="Bound">n</a>

    <a id="15699" href="#15699" class="Function">Summary</a> <a id="15707" class="Symbol">:</a> <a id="15709" href="../code/binary/Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="15711" class="Symbol">→</a> <a id="15713" class="PrimitiveType">Set</a> <a id="15717" href="#15468" class="Bound">ℓ</a>
    <a id="15723" href="#15699" class="Function">Summary</a> <a id="15731" href="#15731" class="Bound">n</a> <a id="15733" class="Symbol">=</a> <a id="15735" href="../code/binary/Agda.Builtin.Sigma.html#139" class="Record">Σ</a> <a id="15737" href="../code/binary/Prelude.html#1182" class="Field">𝑆</a> <a id="15739" class="Symbol">(</a><a id="15740" href="../code/binary/Cubical.Foundations.Equiv.html#801" class="Function">fiber</a> <a id="15746" class="Symbol">(</a><a id="15747" href="#15760" class="Function">cmb</a> <a id="15751" href="#15731" class="Bound">n</a><a id="15752" class="Symbol">))</a>

    <a id="15760" href="#15760" class="Function">cmb</a> <a id="15764" class="Symbol">:</a> <a id="15766" class="Symbol">∀</a> <a id="15768" href="#15768" class="Bound">n</a> <a id="15770" class="Symbol">→</a> <a id="15772" href="#15606" class="Function">SumNode</a> <a id="15780" href="#15768" class="Bound">n</a> <a id="15782" class="Symbol">→</a> <a id="15784" href="../code/binary/Prelude.html#1182" class="Field">𝑆</a>
    <a id="15790" href="#15760" class="Function">cmb</a> <a id="15794" href="../code/binary/Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a> <a id="15799" class="Symbol">=</a> <a id="15801" href="#15572" class="Field">val</a>
    <a id="15809" href="#15760" class="Function">cmb</a> <a id="15813" class="Symbol">(</a><a id="15814" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="15818" class="Symbol">_)</a> <a id="15821" class="Symbol">(</a><a id="15822" href="#15822" class="Bound">x</a> <a id="15824" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="15826" href="#15826" class="Bound">y</a><a id="15827" class="Symbol">)</a> <a id="15829" class="Symbol">=</a> <a id="15831" href="../code/binary/Agda.Builtin.Sigma.html#225" class="Field">fst</a> <a id="15835" href="#15822" class="Bound">x</a> <a id="15837" href="../code/binary/Prelude.html#1196" class="Field Operator">∙</a> <a id="15839" href="../code/binary/Agda.Builtin.Sigma.html#225" class="Field">fst</a> <a id="15843" href="#15826" class="Bound">y</a>

  <a id="15848" href="#15848" class="Function">Fenwick</a> <a id="15856" class="Symbol">:</a> <a id="15858" href="#6377" class="Function">𝔹</a> <a id="15860" class="Symbol">→</a>  <a id="15863" class="PrimitiveType">Set</a> <a id="15867" href="#15468" class="Bound">ℓ</a>
  <a id="15871" href="#15848" class="Function">Fenwick</a> <a id="15879" class="Symbol">=</a> <a id="15881" href="#7823" class="Datatype">Array</a> <a id="15887" href="#15699" class="Function">Summary</a>
</pre>
<p>So it’s an array of perfect trees, with each branch in the tree containing a summary of its children. Constructing a tree is straightforward:</p>
<pre class="Agda">  <a id="16052" href="#16052" class="Function">comb</a> <a id="16057" class="Symbol">:</a> <a id="16059" class="Symbol">∀</a> <a id="16061" href="#16061" class="Bound">n</a> <a id="16063" class="Symbol">→</a> <a id="16065" href="#15699" class="Function">Summary</a> <a id="16073" href="#16061" class="Bound">n</a> <a id="16075" class="Symbol">→</a> <a id="16077" href="#15699" class="Function">Summary</a> <a id="16085" href="#16061" class="Bound">n</a> <a id="16087" class="Symbol">→</a> <a id="16089" href="#15699" class="Function">Summary</a> <a id="16097" class="Symbol">(</a><a id="16098" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="16102" href="#16061" class="Bound">n</a><a id="16103" class="Symbol">)</a>
  <a id="16107" href="#16052" class="Function">comb</a> <a id="16112" href="#16112" class="Bound">n</a> <a id="16114" href="#16114" class="Bound">xs</a> <a id="16117" href="#16117" class="Bound">ys</a> <a id="16120" class="Symbol">=</a> <a id="16122" class="Symbol">_</a> <a id="16124" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="16126" class="Symbol">(</a><a id="16127" href="#16114" class="Bound">xs</a> <a id="16130" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="16132" href="#16117" class="Bound">ys</a><a id="16134" class="Symbol">)</a> <a id="16136" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="16138" href="../code/binary/Cubical.Foundations.Prelude.html#856" class="Function">refl</a>

  <a id="16146" href="#16146" class="Function">sing</a> <a id="16151" class="Symbol">:</a> <a id="16153" href="../code/binary/Prelude.html#1182" class="Field">𝑆</a> <a id="16155" class="Symbol">→</a> <a id="16157" href="#15699" class="Function">Summary</a> <a id="16165" class="Number">0</a>
  <a id="16169" href="#16146" class="Function">sing</a> <a id="16174" href="#16174" class="Bound">x</a> <a id="16176" class="Symbol">=</a> <a id="16178" class="Symbol">_</a> <a id="16180" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="16182" href="#15557" class="InductiveConstructor">leaf</a> <a id="16187" href="#16174" class="Bound">x</a> <a id="16189" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="16191" href="../code/binary/Cubical.Foundations.Prelude.html#856" class="Function">refl</a>

  <a id="16199" href="#16199" class="Function">fFromVec</a> <a id="16208" class="Symbol">:</a> <a id="16210" href="#1557" class="Datatype">Vec</a> <a id="16214" href="../code/binary/Prelude.html#1182" class="Field">𝑆</a> <a id="16216" href="../code/binary/Prelude.html#506" class="Generalizable">n</a> <a id="16218" class="Symbol">→</a> <a id="16220" href="#15848" class="Function">Fenwick</a> <a id="16228" href="#7079" class="Function Operator">⟦</a> <a id="16230" href="../code/binary/Prelude.html#506" class="Generalizable">n</a> <a id="16232" href="#7079" class="Function Operator">⇑⟧</a>
  <a id="16237" href="#16199" class="Function">fFromVec</a> <a id="16246" class="Symbol">=</a> <a id="16248" href="#2378" class="Function">vec-foldr</a> <a id="16258" class="Symbol">(</a><a id="16259" href="#15848" class="Function">Fenwick</a> <a id="16267" href="../code/binary/Prelude.html#942" class="Function Operator">∘</a> <a id="16269" href="#7079" class="Function Operator">⟦_⇑⟧</a><a id="16273" class="Symbol">)</a> <a id="16275" class="Symbol">(</a><a id="16276" href="#9698" class="Function">cons</a> <a id="16281" href="#16052" class="Function">comb</a> <a id="16286" href="../code/binary/Prelude.html#942" class="Function Operator">∘</a> <a id="16288" href="#16146" class="Function">sing</a><a id="16292" class="Symbol">)</a> <a id="16294" href="#7867" class="InductiveConstructor">[]</a>
</pre>
<p>Updating a particular point involves a good bit of boilerplate, but isn’t too complex.</p>
<details>
<p><summary>Lenses into a single level of the tree</summary></p>
<pre class="Agda">  <a id="16469" href="#16469" class="Function">upd-lens</a> <a id="16478" class="Symbol">:</a> <a id="16480" href="../code/binary/Prelude.html#1369" class="Datatype">Bool</a> <a id="16485" class="Symbol">→</a> <a id="16487" href="../code/binary/Lenses.html#203" class="Record">Lens</a> <a id="16492" class="Symbol">(</a><a id="16493" href="#15699" class="Function">Summary</a> <a id="16501" class="Symbol">(</a><a id="16502" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="16506" href="../code/binary/Prelude.html#506" class="Generalizable">n</a><a id="16507" class="Symbol">))</a> <a id="16510" class="Symbol">(</a><a id="16511" href="#15699" class="Function">Summary</a> <a id="16519" href="../code/binary/Prelude.html#506" class="Generalizable">n</a><a id="16520" class="Symbol">)</a>
  <a id="16524" href="#16469" class="Function">upd-lens</a> <a id="16533" href="#16533" class="Bound">b</a> <a id="16535" class="Symbol">.</a><a id="16536" href="../code/binary/Lenses.html#265" class="Field">into</a> <a id="16541" class="Symbol">(_</a> <a id="16544" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="16546" href="#16546" class="Bound">xs</a> <a id="16549" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="16551" class="Symbol">_)</a> <a id="16554" class="Symbol">.</a><a id="16555" href="../code/binary/Lenses.html#150" class="Field">get</a> <a id="16559" class="Symbol">=</a> <a id="16561" href="../code/binary/Lenses.html#1464" class="Function">⦅pair⦆</a> <a id="16568" href="#16533" class="Bound">b</a> <a id="16570" class="Symbol">.</a><a id="16571" href="../code/binary/Lenses.html#265" class="Field">into</a> <a id="16576" href="#16546" class="Bound">xs</a> <a id="16579" class="Symbol">.</a><a id="16580" href="../code/binary/Lenses.html#150" class="Field">get</a>
  <a id="16586" href="#16469" class="Function">upd-lens</a> <a id="16595" href="#16595" class="Bound">b</a> <a id="16597" class="Symbol">.</a><a id="16598" href="../code/binary/Lenses.html#265" class="Field">into</a> <a id="16603" class="Symbol">(_</a> <a id="16606" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="16608" href="#16608" class="Bound">xs</a> <a id="16611" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="16613" class="Symbol">_)</a> <a id="16616" class="Symbol">.</a><a id="16617" href="../code/binary/Lenses.html#162" class="Field">set</a> <a id="16621" href="#16621" class="Bound">x</a> <a id="16623" class="Symbol">=</a> <a id="16625" class="Symbol">_</a> <a id="16627" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="16629" href="../code/binary/Lenses.html#1464" class="Function">⦅pair⦆</a> <a id="16636" href="#16595" class="Bound">b</a> <a id="16638" class="Symbol">.</a><a id="16639" href="../code/binary/Lenses.html#265" class="Field">into</a> <a id="16644" href="#16608" class="Bound">xs</a> <a id="16647" class="Symbol">.</a><a id="16648" href="../code/binary/Lenses.html#162" class="Field">set</a> <a id="16652" href="#16621" class="Bound">x</a> <a id="16654" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="16656" href="../code/binary/Cubical.Foundations.Prelude.html#856" class="Function">refl</a>
  <a id="16663" href="#16469" class="Function">upd-lens</a> <a id="16672" href="#16672" class="Bound">b</a> <a id="16674" class="Symbol">.</a><a id="16675" href="../code/binary/Lenses.html#293" class="Field">get-set</a> <a id="16683" class="Symbol">_</a> <a id="16685" class="Symbol">=</a> <a id="16687" href="../code/binary/Lenses.html#1464" class="Function">⦅pair⦆</a> <a id="16694" href="#16672" class="Bound">b</a> <a id="16696" class="Symbol">.</a><a id="16697" href="../code/binary/Lenses.html#293" class="Field">get-set</a> <a id="16705" class="Symbol">_</a>
  <a id="16709" href="#16469" class="Function">upd-lens</a> <a id="16718" href="../code/binary/Prelude.html#1388" class="InductiveConstructor">false</a> <a id="16724" class="Symbol">.</a><a id="16725" href="../code/binary/Lenses.html#345" class="Field">set-get</a> <a id="16733" class="Symbol">(</a><a id="16734" href="#16734" class="Bound">t</a> <a id="16736" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="16738" href="#16738" class="Bound">xs</a> <a id="16741" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="16743" href="#16743" class="Bound">p</a><a id="16744" class="Symbol">)</a> <a id="16746" href="#16746" class="Bound">i</a> <a id="16748" class="Symbol">.</a><a id="16749" href="../code/binary/Agda.Builtin.Sigma.html#225" class="Field">fst</a> <a id="16753" class="Symbol">=</a> <a id="16755" href="#16743" class="Bound">p</a> <a id="16757" href="#16746" class="Bound">i</a>
  <a id="16761" href="#16469" class="Function">upd-lens</a> <a id="16770" href="../code/binary/Prelude.html#1388" class="InductiveConstructor">false</a> <a id="16776" class="Symbol">.</a><a id="16777" href="../code/binary/Lenses.html#345" class="Field">set-get</a> <a id="16785" class="Symbol">(</a><a id="16786" href="#16786" class="Bound">t</a> <a id="16788" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="16790" href="#16790" class="Bound">xs</a> <a id="16793" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="16795" href="#16795" class="Bound">p</a><a id="16796" class="Symbol">)</a> <a id="16798" href="#16798" class="Bound">i</a> <a id="16800" class="Symbol">.</a><a id="16801" href="../code/binary/Agda.Builtin.Sigma.html#237" class="Field">snd</a> <a id="16805" class="Symbol">.</a><a id="16806" href="../code/binary/Agda.Builtin.Sigma.html#225" class="Field">fst</a> <a id="16810" class="Symbol">=</a> <a id="16812" href="#16790" class="Bound">xs</a>
  <a id="16817" href="#16469" class="Function">upd-lens</a> <a id="16826" href="../code/binary/Prelude.html#1388" class="InductiveConstructor">false</a> <a id="16832" class="Symbol">.</a><a id="16833" href="../code/binary/Lenses.html#345" class="Field">set-get</a> <a id="16841" class="Symbol">(</a><a id="16842" href="#16842" class="Bound">t</a> <a id="16844" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="16846" href="#16846" class="Bound">xs</a> <a id="16849" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="16851" href="#16851" class="Bound">p</a><a id="16852" class="Symbol">)</a> <a id="16854" href="#16854" class="Bound">i</a> <a id="16856" class="Symbol">.</a><a id="16857" href="../code/binary/Agda.Builtin.Sigma.html#237" class="Field">snd</a> <a id="16861" class="Symbol">.</a><a id="16862" href="../code/binary/Agda.Builtin.Sigma.html#237" class="Field">snd</a> <a id="16866" href="#16866" class="Bound">j</a> <a id="16868" class="Symbol">=</a> <a id="16870" href="#16851" class="Bound">p</a> <a id="16872" class="Symbol">(</a><a id="16873" href="#16854" class="Bound">i</a> <a id="16875" href="../code/binary/Agda.Primitive.Cubical.html#226" class="Primitive Operator">∧</a> <a id="16877" href="#16866" class="Bound">j</a><a id="16878" class="Symbol">)</a>
  <a id="16882" href="#16469" class="Function">upd-lens</a> <a id="16891" href="../code/binary/Prelude.html#1403" class="InductiveConstructor">true</a>  <a id="16897" class="Symbol">.</a><a id="16898" href="../code/binary/Lenses.html#345" class="Field">set-get</a> <a id="16906" class="Symbol">(</a><a id="16907" href="#16907" class="Bound">t</a> <a id="16909" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="16911" href="#16911" class="Bound">xs</a> <a id="16914" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="16916" href="#16916" class="Bound">p</a><a id="16917" class="Symbol">)</a> <a id="16919" href="#16919" class="Bound">i</a> <a id="16921" class="Symbol">.</a><a id="16922" href="../code/binary/Agda.Builtin.Sigma.html#225" class="Field">fst</a> <a id="16926" class="Symbol">=</a> <a id="16928" href="#16916" class="Bound">p</a> <a id="16930" href="#16919" class="Bound">i</a>
  <a id="16934" href="#16469" class="Function">upd-lens</a> <a id="16943" href="../code/binary/Prelude.html#1403" class="InductiveConstructor">true</a>  <a id="16949" class="Symbol">.</a><a id="16950" href="../code/binary/Lenses.html#345" class="Field">set-get</a> <a id="16958" class="Symbol">(</a><a id="16959" href="#16959" class="Bound">t</a> <a id="16961" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="16963" href="#16963" class="Bound">xs</a> <a id="16966" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="16968" href="#16968" class="Bound">p</a><a id="16969" class="Symbol">)</a> <a id="16971" href="#16971" class="Bound">i</a> <a id="16973" class="Symbol">.</a><a id="16974" href="../code/binary/Agda.Builtin.Sigma.html#237" class="Field">snd</a> <a id="16978" class="Symbol">.</a><a id="16979" href="../code/binary/Agda.Builtin.Sigma.html#225" class="Field">fst</a> <a id="16983" class="Symbol">=</a> <a id="16985" href="#16963" class="Bound">xs</a>
  <a id="16990" href="#16469" class="Function">upd-lens</a> <a id="16999" href="../code/binary/Prelude.html#1403" class="InductiveConstructor">true</a>  <a id="17005" class="Symbol">.</a><a id="17006" href="../code/binary/Lenses.html#345" class="Field">set-get</a> <a id="17014" class="Symbol">(</a><a id="17015" href="#17015" class="Bound">t</a> <a id="17017" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="17019" href="#17019" class="Bound">xs</a> <a id="17022" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="17024" href="#17024" class="Bound">p</a><a id="17025" class="Symbol">)</a> <a id="17027" href="#17027" class="Bound">i</a> <a id="17029" class="Symbol">.</a><a id="17030" href="../code/binary/Agda.Builtin.Sigma.html#237" class="Field">snd</a> <a id="17034" class="Symbol">.</a><a id="17035" href="../code/binary/Agda.Builtin.Sigma.html#237" class="Field">snd</a> <a id="17039" href="#17039" class="Bound">j</a> <a id="17041" class="Symbol">=</a> <a id="17043" href="#17024" class="Bound">p</a> <a id="17045" class="Symbol">(</a><a id="17046" href="#17027" class="Bound">i</a> <a id="17048" href="../code/binary/Agda.Primitive.Cubical.html#226" class="Primitive Operator">∧</a> <a id="17050" href="#17039" class="Bound">j</a><a id="17051" class="Symbol">)</a>
  <a id="17055" href="#16469" class="Function">upd-lens</a> <a id="17064" href="../code/binary/Prelude.html#1388" class="InductiveConstructor">false</a> <a id="17070" class="Symbol">.</a><a id="17071" href="../code/binary/Lenses.html#395" class="Field">set-set</a> <a id="17079" class="Symbol">_</a> <a id="17081" class="Symbol">_</a> <a id="17083" class="Symbol">_</a> <a id="17085" class="Symbol">=</a> <a id="17087" href="../code/binary/Cubical.Foundations.Prelude.html#856" class="Function">refl</a>
  <a id="17094" href="#16469" class="Function">upd-lens</a> <a id="17103" href="../code/binary/Prelude.html#1403" class="InductiveConstructor">true</a>  <a id="17109" class="Symbol">.</a><a id="17110" href="../code/binary/Lenses.html#395" class="Field">set-set</a> <a id="17118" class="Symbol">_</a> <a id="17120" class="Symbol">_</a> <a id="17122" class="Symbol">_</a> <a id="17124" class="Symbol">=</a> <a id="17126" href="../code/binary/Cubical.Foundations.Prelude.html#856" class="Function">refl</a>

  <a id="17134" href="#17134" class="Function">top</a> <a id="17138" class="Symbol">:</a> <a id="17140" href="../code/binary/Lenses.html#203" class="Record">Lens</a> <a id="17145" class="Symbol">(</a><a id="17146" href="#15699" class="Function">Summary</a> <a id="17154" class="Number">0</a><a id="17155" class="Symbol">)</a> <a id="17157" href="../code/binary/Prelude.html#1182" class="Field">𝑆</a>
  <a id="17161" href="#17134" class="Function">top</a> <a id="17165" class="Symbol">.</a><a id="17166" href="../code/binary/Lenses.html#265" class="Field">into</a> <a id="17171" href="#17171" class="Bound">x</a> <a id="17173" class="Symbol">.</a><a id="17174" href="../code/binary/Lenses.html#150" class="Field">get</a> <a id="17178" class="Symbol">=</a> <a id="17180" href="#17171" class="Bound">x</a> <a id="17182" class="Symbol">.</a><a id="17183" href="../code/binary/Agda.Builtin.Sigma.html#237" class="Field">snd</a> <a id="17187" class="Symbol">.</a><a id="17188" href="../code/binary/Agda.Builtin.Sigma.html#225" class="Field">fst</a> <a id="17192" class="Symbol">.</a><a id="17193" href="#15572" class="Field">val</a>
  <a id="17199" href="#17134" class="Function">top</a> <a id="17203" class="Symbol">.</a><a id="17204" href="../code/binary/Lenses.html#265" class="Field">into</a> <a id="17209" href="#17209" class="Bound">x</a> <a id="17211" class="Symbol">.</a><a id="17212" href="../code/binary/Lenses.html#162" class="Field">set</a> <a id="17216" href="#17216" class="Bound">y</a> <a id="17218" class="Symbol">.</a><a id="17219" href="../code/binary/Agda.Builtin.Sigma.html#225" class="Field">fst</a> <a id="17223" class="Symbol">=</a> <a id="17225" href="#17216" class="Bound">y</a>
  <a id="17229" href="#17134" class="Function">top</a> <a id="17233" class="Symbol">.</a><a id="17234" href="../code/binary/Lenses.html#265" class="Field">into</a> <a id="17239" href="#17239" class="Bound">x</a> <a id="17241" class="Symbol">.</a><a id="17242" href="../code/binary/Lenses.html#162" class="Field">set</a> <a id="17246" href="#17246" class="Bound">y</a> <a id="17248" class="Symbol">.</a><a id="17249" href="../code/binary/Agda.Builtin.Sigma.html#237" class="Field">snd</a> <a id="17253" class="Symbol">.</a><a id="17254" href="../code/binary/Agda.Builtin.Sigma.html#225" class="Field">fst</a> <a id="17258" class="Symbol">.</a><a id="17259" href="#15572" class="Field">val</a> <a id="17263" class="Symbol">=</a> <a id="17265" href="#17246" class="Bound">y</a>
  <a id="17269" href="#17134" class="Function">top</a> <a id="17273" class="Symbol">.</a><a id="17274" href="../code/binary/Lenses.html#265" class="Field">into</a> <a id="17279" href="#17279" class="Bound">x</a> <a id="17281" class="Symbol">.</a><a id="17282" href="../code/binary/Lenses.html#162" class="Field">set</a> <a id="17286" href="#17286" class="Bound">y</a> <a id="17288" class="Symbol">.</a><a id="17289" href="../code/binary/Agda.Builtin.Sigma.html#237" class="Field">snd</a> <a id="17293" class="Symbol">.</a><a id="17294" href="../code/binary/Agda.Builtin.Sigma.html#237" class="Field">snd</a> <a id="17298" class="Symbol">=</a> <a id="17300" href="../code/binary/Cubical.Foundations.Prelude.html#856" class="Function">refl</a>
  <a id="17307" href="#17134" class="Function">top</a> <a id="17311" class="Symbol">.</a><a id="17312" href="../code/binary/Lenses.html#293" class="Field">get-set</a> <a id="17320" class="Symbol">_</a> <a id="17322" class="Symbol">_</a> <a id="17324" class="Symbol">=</a> <a id="17326" href="../code/binary/Cubical.Foundations.Prelude.html#856" class="Function">refl</a>
  <a id="17333" href="#17134" class="Function">top</a> <a id="17337" class="Symbol">.</a><a id="17338" href="../code/binary/Lenses.html#345" class="Field">set-get</a> <a id="17346" class="Symbol">(</a><a id="17347" href="#17347" class="Bound">x</a> <a id="17349" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="17351" href="#17351" class="Bound">y</a> <a id="17353" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="17355" href="#17355" class="Bound">p</a><a id="17356" class="Symbol">)</a> <a id="17358" href="#17358" class="Bound">i</a> <a id="17360" class="Symbol">.</a><a id="17361" href="../code/binary/Agda.Builtin.Sigma.html#225" class="Field">fst</a> <a id="17365" class="Symbol">=</a> <a id="17367" href="#17355" class="Bound">p</a> <a id="17369" href="#17358" class="Bound">i</a>
  <a id="17373" href="#17134" class="Function">top</a> <a id="17377" class="Symbol">.</a><a id="17378" href="../code/binary/Lenses.html#345" class="Field">set-get</a> <a id="17386" class="Symbol">(</a><a id="17387" href="#17387" class="Bound">x</a> <a id="17389" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="17391" href="#17391" class="Bound">y</a> <a id="17393" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="17395" href="#17395" class="Bound">p</a><a id="17396" class="Symbol">)</a> <a id="17398" href="#17398" class="Bound">i</a> <a id="17400" class="Symbol">.</a><a id="17401" href="../code/binary/Agda.Builtin.Sigma.html#237" class="Field">snd</a> <a id="17405" class="Symbol">.</a><a id="17406" href="../code/binary/Agda.Builtin.Sigma.html#225" class="Field">fst</a> <a id="17410" class="Symbol">=</a> <a id="17412" href="#17391" class="Bound">y</a>
  <a id="17416" href="#17134" class="Function">top</a> <a id="17420" class="Symbol">.</a><a id="17421" href="../code/binary/Lenses.html#345" class="Field">set-get</a> <a id="17429" class="Symbol">(</a><a id="17430" href="#17430" class="Bound">x</a> <a id="17432" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="17434" href="#17434" class="Bound">y</a> <a id="17436" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="17438" href="#17438" class="Bound">p</a><a id="17439" class="Symbol">)</a> <a id="17441" href="#17441" class="Bound">i</a> <a id="17443" class="Symbol">.</a><a id="17444" href="../code/binary/Agda.Builtin.Sigma.html#237" class="Field">snd</a> <a id="17448" class="Symbol">.</a><a id="17449" href="../code/binary/Agda.Builtin.Sigma.html#237" class="Field">snd</a> <a id="17453" href="#17453" class="Bound">j</a> <a id="17455" class="Symbol">=</a> <a id="17457" href="#17438" class="Bound">p</a> <a id="17459" class="Symbol">(</a><a id="17460" href="#17441" class="Bound">i</a> <a id="17462" href="../code/binary/Agda.Primitive.Cubical.html#226" class="Primitive Operator">∧</a> <a id="17464" href="#17453" class="Bound">j</a><a id="17465" class="Symbol">)</a>
  <a id="17469" href="#17134" class="Function">top</a> <a id="17473" class="Symbol">.</a><a id="17474" href="../code/binary/Lenses.html#395" class="Field">set-set</a> <a id="17482" class="Symbol">_</a> <a id="17484" class="Symbol">_</a> <a id="17486" class="Symbol">_</a> <a id="17488" class="Symbol">=</a> <a id="17490" href="../code/binary/Cubical.Foundations.Prelude.html#856" class="Function">refl</a>
</pre>
</details>
<pre class="Agda">  <a id="17522" href="#17522" class="Function">update</a> <a id="17529" class="Symbol">:</a> <a id="17531" href="#10969" class="Datatype">Fin𝔹</a> <a id="17536" href="../code/binary/Prelude.html#1369" class="Datatype">Bool</a> <a id="17541" href="#6437" class="Generalizable">ds</a> <a id="17544" class="Symbol">→</a> <a id="17546" href="../code/binary/Lenses.html#203" class="Record">Lens</a> <a id="17551" class="Symbol">(</a><a id="17552" href="#15848" class="Function">Fenwick</a> <a id="17560" href="#6437" class="Generalizable">ds</a><a id="17562" class="Symbol">)</a> <a id="17564" href="../code/binary/Prelude.html#1182" class="Field">𝑆</a>
  <a id="17568" href="#17522" class="Function">update</a> <a id="17575" href="#17575" class="Bound">is</a> <a id="17578" class="Symbol">=</a> <a id="17580" href="#14848" class="Function">ind-lens</a> <a id="17589" href="#16469" class="Function">upd-lens</a> <a id="17598" href="#17575" class="Bound">is</a> <a id="17601" href="../code/binary/Lenses.html#631" class="Function Operator">⋯</a> <a id="17603" href="#17134" class="Function">top</a>
</pre>
<p>Finally, here’s how we get the summary up to a particular point in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math> time:</p>
<pre class="Agda">  <a id="17718" href="#17718" class="Function">running</a> <a id="17726" class="Symbol">:</a> <a id="17728" class="Symbol">(∀</a> <a id="17731" href="#17731" class="Bound">n</a> <a id="17733" class="Symbol">→</a> <a id="17735" href="../code/binary/Prelude.html#1369" class="Datatype">Bool</a> <a id="17740" class="Symbol">→</a> <a id="17742" href="#846" class="Generalizable">T</a> <a id="17744" class="Symbol">(</a><a id="17745" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="17749" href="#17731" class="Bound">n</a><a id="17750" class="Symbol">)</a> <a id="17752" class="Symbol">→</a> <a id="17754" href="../code/binary/Prelude.html#1182" class="Field">𝑆</a> <a id="17756" href="../code/binary/Prelude.html#621" class="Function Operator">×</a> <a id="17758" href="#846" class="Generalizable">T</a> <a id="17760" href="#17731" class="Bound">n</a><a id="17761" class="Symbol">)</a>
          <a id="17773" class="Symbol">→</a> <a id="17775" class="Symbol">(∀</a> <a id="17778" href="#17778" class="Bound">n</a> <a id="17780" class="Symbol">→</a> <a id="17782" href="#846" class="Generalizable">T</a> <a id="17784" href="#17778" class="Bound">n</a> <a id="17786" class="Symbol">→</a> <a id="17788" href="../code/binary/Prelude.html#1182" class="Field">𝑆</a><a id="17789" class="Symbol">)</a>
          <a id="17801" class="Symbol">→</a> <a id="17803" href="#7823" class="Datatype">Array</a> <a id="17809" href="#846" class="Generalizable">T</a> <a id="17811" href="#6437" class="Generalizable">ds</a>
          <a id="17824" class="Symbol">→</a> <a id="17826" href="#10969" class="Datatype">Fin𝔹</a> <a id="17831" href="../code/binary/Prelude.html#1369" class="Datatype">Bool</a> <a id="17836" href="#6437" class="Generalizable">ds</a>
          <a id="17849" class="Symbol">→</a> <a id="17851" href="../code/binary/Prelude.html#1182" class="Field">𝑆</a> <a id="17853" href="../code/binary/Prelude.html#621" class="Function Operator">×</a> <a id="17855" href="#846" class="Generalizable">T</a> <a id="17857" class="Number">0</a>
  <a id="17861" href="#17718" class="Function">running</a> <a id="17869" href="#17869" class="Bound">l</a> <a id="17871" href="#17871" class="Bound">s</a> <a id="17873" class="Symbol">(</a><a id="17874" href="#17874" class="Bound">x</a> <a id="17876" href="#7886" class="InductiveConstructor Operator">∷</a> <a id="17878" href="#17878" class="Bound">xs</a><a id="17880" class="Symbol">)</a> <a id="17882" class="Symbol">(</a><a id="17883" href="#11105" class="InductiveConstructor">there</a> <a id="17889" href="#17889" class="Bound">i</a> <a id="17891" href="#17891" class="Bound">is</a><a id="17893" class="Symbol">)</a> <a id="17895" class="Symbol">=</a>
    <a id="17901" class="Keyword">let</a> <a id="17905" href="#17905" class="Bound">y</a> <a id="17907" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="17909" href="#17909" class="Bound">ys</a> <a id="17912" class="Symbol">=</a> <a id="17914" href="#17718" class="Function">running</a> <a id="17922" class="Symbol">(</a><a id="17923" href="#17869" class="Bound">l</a> <a id="17925" href="../code/binary/Prelude.html#942" class="Function Operator">∘</a> <a id="17927" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a><a id="17930" class="Symbol">)</a> <a id="17932" class="Symbol">(</a><a id="17933" href="#17871" class="Bound">s</a> <a id="17935" href="../code/binary/Prelude.html#942" class="Function Operator">∘</a> <a id="17937" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a><a id="17940" class="Symbol">)</a> <a id="17942" href="#17878" class="Bound">xs</a> <a id="17945" href="#17891" class="Bound">is</a>
        <a id="17956" href="#17956" class="Bound">z</a> <a id="17958" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="17960" href="#17960" class="Bound">zs</a> <a id="17963" class="Symbol">=</a> <a id="17965" href="#17869" class="Bound">l</a> <a id="17967" class="Symbol">_</a> <a id="17969" href="#17889" class="Bound">i</a> <a id="17971" href="#17909" class="Bound">ys</a>
    <a id="17978" class="Keyword">in</a> <a id="17981" href="#17871" class="Bound">s</a> <a id="17983" class="Symbol">_</a> <a id="17985" href="#17874" class="Bound">x</a> <a id="17987" href="../code/binary/Prelude.html#1196" class="Field Operator">∙</a> <a id="17989" href="#17905" class="Bound">y</a> <a id="17991" href="../code/binary/Prelude.html#1196" class="Field Operator">∙</a> <a id="17993" href="#17956" class="Bound">z</a> <a id="17995" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="17997" href="#17960" class="Bound">zs</a>
  <a id="18002" href="#17718" class="Function">running</a> <a id="18010" href="#18010" class="Bound">l</a> <a id="18012" href="#18012" class="Bound">s</a> <a id="18014" class="Symbol">(</a><a id="18015" href="#18015" class="Bound">x</a> <a id="18017" href="#7956" class="InductiveConstructor Operator">1∷</a> <a id="18020" href="#18020" class="Bound">xs</a><a id="18022" class="Symbol">)</a> <a id="18024" href="#11007" class="InductiveConstructor">here₁</a> <a id="18030" class="Symbol">=</a> <a id="18032" href="../code/binary/Prelude.html#1216" class="Field">ε</a> <a id="18034" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="18036" href="#18015" class="Bound">x</a>
  <a id="18040" href="#17718" class="Function">running</a> <a id="18048" href="#18048" class="Bound">l</a> <a id="18050" href="#18050" class="Bound">s</a> <a id="18052" class="Symbol">(</a><a id="18053" href="#18053" class="Bound">x</a> <a id="18055" href="#7994" class="InductiveConstructor Operator">2∷</a> <a id="18058" href="#18058" class="Bound">xs</a><a id="18060" class="Symbol">)</a> <a id="18062" class="Symbol">(</a><a id="18063" href="#11056" class="InductiveConstructor">here₂</a> <a id="18069" href="#18069" class="Bound">i</a><a id="18070" class="Symbol">)</a> <a id="18072" class="Symbol">=</a> <a id="18074" href="#18048" class="Bound">l</a> <a id="18076" class="Symbol">_</a> <a id="18078" href="#18069" class="Bound">i</a> <a id="18080" href="#18053" class="Bound">x</a>

  <a id="18085" href="#18085" class="Function">prefix</a> <a id="18092" class="Symbol">:</a> <a id="18094" href="#15848" class="Function">Fenwick</a> <a id="18102" href="#6437" class="Generalizable">ds</a> <a id="18105" class="Symbol">→</a> <a id="18107" href="#10969" class="Datatype">Fin𝔹</a> <a id="18112" href="../code/binary/Prelude.html#1369" class="Datatype">Bool</a> <a id="18117" href="#6437" class="Generalizable">ds</a> <a id="18120" class="Symbol">→</a> <a id="18122" href="../code/binary/Prelude.html#1182" class="Field">𝑆</a>
  <a id="18126" href="#18085" class="Function">prefix</a> <a id="18133" href="#18133" class="Bound">xs</a> <a id="18136" href="#18136" class="Bound">is</a> <a id="18139" class="Symbol">=</a> <a id="18141" class="Keyword">let</a> <a id="18145" href="#18145" class="Bound">ys</a> <a id="18148" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="18150" href="#18150" class="Bound">zs</a> <a id="18153" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="18155" class="Symbol">_</a> <a id="18157" class="Symbol">=</a> <a id="18159" href="#17718" class="Function">running</a> <a id="18167" href="#18214" class="Function">ind</a> <a id="18171" class="Symbol">(λ</a> <a id="18174" href="#18174" class="Bound">_</a> <a id="18176" class="Symbol">→</a> <a id="18178" href="../code/binary/Agda.Builtin.Sigma.html#225" class="Field">fst</a><a id="18181" class="Symbol">)</a> <a id="18183" href="#18133" class="Bound">xs</a> <a id="18186" href="#18136" class="Bound">is</a> <a id="18189" class="Keyword">in</a> <a id="18192" href="#18145" class="Bound">ys</a> <a id="18195" href="../code/binary/Prelude.html#1196" class="Field Operator">∙</a> <a id="18197" href="#18150" class="Bound">zs</a>
    <a id="18204" class="Keyword">where</a>
    <a id="18214" href="#18214" class="Function">ind</a> <a id="18218" class="Symbol">:</a> <a id="18220" class="Symbol">∀</a> <a id="18222" href="#18222" class="Bound">n</a> <a id="18224" class="Symbol">→</a> <a id="18226" href="../code/binary/Prelude.html#1369" class="Datatype">Bool</a> <a id="18231" class="Symbol">→</a> <a id="18233" href="#15699" class="Function">Summary</a> <a id="18241" class="Symbol">(</a><a id="18242" href="../code/binary/Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="18246" href="#18222" class="Bound">n</a><a id="18247" class="Symbol">)</a> <a id="18249" class="Symbol">→</a> <a id="18251" href="../code/binary/Prelude.html#1182" class="Field">𝑆</a> <a id="18253" href="../code/binary/Prelude.html#621" class="Function Operator">×</a> <a id="18255" href="#15699" class="Function">Summary</a> <a id="18263" href="#18222" class="Bound">n</a>
    <a id="18269" href="#18214" class="Function">ind</a> <a id="18273" href="#18273" class="Bound">n</a> <a id="18275" href="../code/binary/Prelude.html#1388" class="InductiveConstructor">false</a> <a id="18281" class="Symbol">(_</a> <a id="18284" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="18286" class="Symbol">(</a><a id="18287" href="#18287" class="Bound">xs</a> <a id="18290" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="18292" class="Symbol">_)</a> <a id="18295" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="18297" class="Symbol">_)</a> <a id="18300" class="Symbol">=</a> <a id="18302" href="../code/binary/Prelude.html#1216" class="Field">ε</a> <a id="18304" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="18306" href="#18287" class="Bound">xs</a>
    <a id="18313" href="#18214" class="Function">ind</a> <a id="18317" href="#18317" class="Bound">n</a> <a id="18319" href="../code/binary/Prelude.html#1403" class="InductiveConstructor">true</a>  <a id="18325" class="Symbol">(_</a> <a id="18328" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="18330" class="Symbol">((</a><a id="18332" href="#18332" class="Bound">x</a> <a id="18334" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="18336" class="Symbol">_)</a> <a id="18339" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="18341" class="Symbol">(</a><a id="18342" href="#18342" class="Bound">y</a> <a id="18344" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="18346" href="#18346" class="Bound">ys</a><a id="18348" class="Symbol">))</a> <a id="18351" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="18353" class="Symbol">_)</a> <a id="18356" class="Symbol">=</a> <a id="18358" href="#18332" class="Bound">x</a> <a id="18360" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="18362" class="Symbol">(</a><a id="18363" href="#18342" class="Bound">y</a> <a id="18365" href="../code/binary/Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="18367" href="#18346" class="Bound">ys</a><a id="18369" class="Symbol">)</a>
</pre>
<h1 id="references" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-danvyThereBackAgain2005">
<p>Danvy, Olivier, and Mayer Goldberg. 2005. “There and Back Again.” <em>BRICS Report Series</em> 12 (3). doi:<a href="https://doi.org/10.7146/brics.v12i3.21869">10.7146/brics.v12i3.21869</a>.</p>
</div>
<div id="ref-fonerThereBackAgain2016">
<p>Foner, Kenneth. 2016. “’There and Back Again’ and What Happened After.” New York.</p>
</div>
<div id="ref-okasakiPurelyFunctionalRandomaccess1995">
<p>Okasaki, Chris. 1995. “Purely Functional Random-access Lists.” In <em>Proceedings of the Seventh International Conference on Functional Programming Languages and Computer Architecture</em>, 86–95. FPCA ’95. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/224164.224187">10.1145/224164.224187</a>.</p>
</div>
<div id="ref-swierstraHeterogeneousRandomaccessLists2019">
<p>Swierstra, Wouter. 2019. “Heterogeneous random-access lists.”</p>
</div>
</div>
]]></description>
    <pubDate>Sat, 02 Nov 2019 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2019-11-02-how-to-binary-random-access-list.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>What is Good About Haskell?</title>
    <link>https://doisinkidney.com/posts/2019-10-02-what-is-good-about-haskell.html</link>
    <description><![CDATA[<div class="info">
    Posted on October  2, 2019
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<p>Update 5/10/2019: check the bottom of this post for some links to comments and discussion.</p>
<p>Beginners to Haskell are often confused as to what’s so great about the language. Much of the proselytizing online focuses on pretty abstract (and often poorly defined) concepts like “purity”, “strong types”, and (god forbid) “monads”. These things are difficult to understand, somewhat controversial, and not obviously beneficial (especially when you’ve only been using the language for a short amount of time).</p>
<p>The real tragedy is that Haskell (and other ML-family languages) are <em>packed</em> with simple, decades-old features like pattern matching and algebraic data types which have massive, clear benefits and few (if any) downsides. Some of these ideas are finally filtering in to mainstream languages (like Swift and Rust) where they’re used to great effect, but the vast majority of programmers out there haven’t yet been exposed to them.</p>
<p>This post aims to demonstrate some of these features in a simple (but hopefully not too simple) example. I’m going to write and package up a simple sorting algorithm in both Haskell and Python, and compare the code in each. I’m choosing Python because I like it and beginners like it, but also because it’s missing most of the features I’ll be demonstrating. It’s important to note I’m not comparing Haskell and Python as languages: the Python code is just there as a reference for people less familiar with Haskell. What’s more, the comparison is unfair, as the example deliberately plays to Haskell’s strengths (so I can show off the features I’m interested in): it wouldn’t be difficult to pick an example that makes Python look good and Haskell look poor.</p>
<p>This post is not meant to say “Haskell is great, and your language sucks”! It’s not even really about Haskell: much of what I’m talking about here applies equally well to Ocaml, Rust, etc. I’m really writing this as a response to the notion that functional features are somehow experimental, overly complex, or ultimately compromised. As a result of that idea, I feel like these features are left out of a lot of modern languages which would benefit from them. There exists a small set of simple, battle-tested PL ideas, which have been used for nearly forty years now: this post aims to demonstrate them, and argue for their inclusion in every general-purpose programming language that’s being designed today.</p>
<h1 id="the-algorithm">The Algorithm</h1>
<p>We’ll be using a <a href="https://en.wikipedia.org/wiki/Skew_heap">skew heap</a> to sort lists in both languages. The basic idea is to repeatedly insert stuff into the heap, and then repeatedly “pop” the smallest element from the heap until it’s empty. It’s not in-place, but it is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n \log n)</annotation></semantics></math>, and actually performs pretty well in practice.</p>
<h1 id="a-tree">A Tree</h1>
<p>A Skew Heap is represented by a <em>binary tree</em>:</p>
<style>
.column {
    float: left;
    width: 50%;
}
.row:after {
    content: "";
    display: table;
    clear: both;
}
</style>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">Leaf</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  <span class="fu">|</span> <span class="dt">Node</span> a (<span class="dt">Tree</span> a) (<span class="dt">Tree</span> a)</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">class</span> Tree:</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, is_node, data, lchild, rchild):</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">    <span class="va">self</span>._is_node <span class="op">=</span> is_node</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">    <span class="va">self</span>._data <span class="op">=</span> data</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">    <span class="va">self</span>._lchild <span class="op">=</span> lchild</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">    <span class="va">self</span>._rchild <span class="op">=</span> rchild</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">    </a>
<a class="sourceLine" id="cb2-8" data-line-number="8"><span class="kw">def</span> leaf():</a>
<a class="sourceLine" id="cb2-9" data-line-number="9">  <span class="cf">return</span> Tree(<span class="va">False</span>, <span class="va">None</span>, <span class="va">None</span>, <span class="va">None</span>)</a>
<a class="sourceLine" id="cb2-10" data-line-number="10"></a>
<a class="sourceLine" id="cb2-11" data-line-number="11"><span class="kw">def</span> node(data, lchild, rchild):</a>
<a class="sourceLine" id="cb2-12" data-line-number="12">  <span class="cf">return</span> Tree(<span class="va">True</span>, data, lchild, rchild)</a></code></pre></div>
</div>
</div>
<p>I want to point out the precision of the Haskell definition: a tree is either a leaf (an empty tree), or a node, with a payload and two children. There are no special cases, and it took us one line to write (spread to 3 here for legibility on smaller screens).</p>
<p>In Python, we have to write a few more lines<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>. This representation uses the <code>_is_node</code> field is <code>False</code> for an empty tree (a leaf). If it’s <code>True</code>, the other fields are filled. We write some helper functions to give us constructors like the leaf and node ones for the Haskell example.</p>
<p>This isn’t the standard definition of a binary tree in Python, in fact it might looks a little weird to most Python people. Let’s run through some alternatives and their issues.</p>
<ol>
<li><p>The standard definition:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">class</span> Tree:</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, data, lchild, rchild):</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">    <span class="va">self</span>._data <span class="op">=</span> data</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">    <span class="va">self</span>._lchild <span class="op">=</span> lchild</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">    <span class="va">self</span>._rchild <span class="op">=</span> rchild</a></code></pre></div>
<p>Instead of having a separate field for “is this a leaf or a node”, the empty tree is simply <code>None</code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">def</span> leaf():</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">    <span class="cf">return</span> <span class="va">None</span></a></code></pre></div>
<p>With this approach, if we define any <em>methods</em> on a tree, they won’t work on the empty tree!</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="op">&gt;&gt;&gt;</span> leaf().size()</a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="pp">AttributeError</span>: <span class="st">&#39;NoneType&#39;</span> <span class="bu">object</span> has no attribute <span class="st">&#39;size&#39;</span></a></code></pre></div></li>
<li><p>We’ll do inheritance! Python even has a handy <code>abc</code> library to help us with some of this:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="im">from</span> abc <span class="im">import</span> ABC, abstractmethod</a>
<a class="sourceLine" id="cb6-2" data-line-number="2"></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="kw">class</span> Tree(ABC):</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">    <span class="at">@abstractmethod</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">    <span class="kw">def</span> size(<span class="va">self</span>):</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">        <span class="cf">raise</span> <span class="va">NotImplemented</span></a>
<a class="sourceLine" id="cb6-7" data-line-number="7"></a>
<a class="sourceLine" id="cb6-8" data-line-number="8"><span class="kw">class</span> Leaf(Tree):</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</a>
<a class="sourceLine" id="cb6-10" data-line-number="10">        <span class="cf">pass</span></a>
<a class="sourceLine" id="cb6-11" data-line-number="11"></a>
<a class="sourceLine" id="cb6-12" data-line-number="12">    <span class="kw">def</span> size(<span class="va">self</span>):</a>
<a class="sourceLine" id="cb6-13" data-line-number="13">        <span class="cf">return</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb6-14" data-line-number="14"></a>
<a class="sourceLine" id="cb6-15" data-line-number="15"><span class="kw">class</span> Node(Tree):</a>
<a class="sourceLine" id="cb6-16" data-line-number="16">    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, data, lchild, rchild):</a>
<a class="sourceLine" id="cb6-17" data-line-number="17">        <span class="va">self</span>._data <span class="op">=</span> data</a>
<a class="sourceLine" id="cb6-18" data-line-number="18">        <span class="va">self</span>._lchild <span class="op">=</span> lchild</a>
<a class="sourceLine" id="cb6-19" data-line-number="19">        <span class="va">self</span>._rchild <span class="op">=</span> rchild</a>
<a class="sourceLine" id="cb6-20" data-line-number="20"></a>
<a class="sourceLine" id="cb6-21" data-line-number="21">    <span class="kw">def</span> size(<span class="va">self</span>):</a>
<a class="sourceLine" id="cb6-22" data-line-number="22">        <span class="cf">return</span> <span class="dv">1</span> <span class="op">+</span> <span class="va">self</span>._lchild.size() <span class="op">+</span> <span class="va">self</span>._rchild.size()</a></code></pre></div>
<p>Methods will now work on an empty tree, but we’re faced with 2 problems: first, this is very verbose, and pretty complex. Secondly, we can’t write a mutating method which changes a tree from a leaf to a node. In other words, we can’t write an <code>insert</code> method!</p></li>
<li><p>We won’t represent a leaf as the whole <em>tree</em> being <code>None</code>, just the data!</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">def</span> leaf():</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">    <span class="cf">return</span> Tree(<span class="va">None</span>, <span class="va">None</span>, <span class="va">None</span>)</a></code></pre></div>
<p>This (surprisingly) pops up in a few places. While it solves the problem of methods, and the mutation problem, it has a serious bug. We can’t have <code>None</code> as an element in the tree! In other words, if we ask our eventual algorithm to sort a list which contains <code>None</code>, it will silently discard some of the list, returning the wrong answer.</p></li>
</ol>
<p>There are yet more options (using a wrapper class), none of them ideal. Another thing to point out is that, even with our definition with a tag, we can only represent types with 2 possible states. If there was another type of node in the tree, we couldn’t simply use a boolean tag: we’d have to switch to integers (and remember the meaning of each integer), or strings! Yuck!</p>
<p>What Python is fundamentally missing here is <em>algebraic data types</em>. This is a way of building up all of your types out of products (“my type has this <em>and</em> this”) and sums (“my type is this <em>or</em> this”). Python can do products perfectly well: that’s what classes are. The tree class itself is the product of <code>Bool</code>, <code>data</code>, <code>Tree</code>, and <code>Tree</code>. However it’s missing an <em>entire half of the equation</em>! This is why you just can’t express binary trees as cleanly as you can in Swift, Haskell, OCaml, etc. Python, as well as a host of other languages like Go, Java, etc, will let you express <em>one</em> kind of “sum” type: “or nothing” (the null pointer). However, it’s clunky and poorly handled in all of those languages (the method problems above demonstrate the issues in Python), and doesn’t work for anything other than that one special case.</p>
<p>Again, there’s nothing about algebraic data types that makes them ill-suited to mainstream or imperative languages. Swift uses them, and <a href="https://www.caseyliss.com/2016/2/27/swift-enums">people love them</a>!</p>
<h1 id="a-function">A Function</h1>
<p>The core operation on skew heaps is the <em>skew merge</em>.</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">merge ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">merge <span class="dt">Leaf</span> ys <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">merge xs <span class="dt">Leaf</span> <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">merge xs<span class="fu">@</span>(<span class="dt">Node</span> x xl xr) ys<span class="fu">@</span>(<span class="dt">Node</span> y yl yr)</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">   <span class="fu">|</span> x <span class="fu">&lt;=</span> y    <span class="fu">=</span> <span class="dt">Node</span> x (merge ys xr) xl</a>
<a class="sourceLine" id="cb8-6" data-line-number="6">   <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Node</span> y (merge xs yr) yl</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">def</span> merge(lhs, rhs):</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">  <span class="cf">if</span> <span class="kw">not</span> lhs._is_node:</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">    <span class="cf">return</span> rhs</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">  <span class="cf">if</span> <span class="kw">not</span> rhs._is_node:</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">    <span class="cf">return</span> lhs</a>
<a class="sourceLine" id="cb9-6" data-line-number="6">  <span class="cf">if</span> lhs._data <span class="op">&lt;=</span> rhs._data:</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">    <span class="cf">return</span> Tree(lhs._data,</a>
<a class="sourceLine" id="cb9-8" data-line-number="8">                merge(rhs, lhs._rchild),</a>
<a class="sourceLine" id="cb9-9" data-line-number="9">                lhs._lchild)</a>
<a class="sourceLine" id="cb9-10" data-line-number="10">  <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb9-11" data-line-number="11">    <span class="cf">return</span> Tree(rhs._data,</a>
<a class="sourceLine" id="cb9-12" data-line-number="12">                merge(lhs, rhs._rchild),</a>
<a class="sourceLine" id="cb9-13" data-line-number="13">                rhs._lchild)</a></code></pre></div>
</div>
</div>
<p>The standout feature here is pattern matching. In Haskell, we’re able to write the function as we might describe it: “in this case, I’ll do this, in this other case, I’ll do this, etc.”. In Python, we are forced to think of the truth tables and sequential testing. What do I mean by truth tables? Consider the following version of the Python function above:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">def</span> merge(lhs, rhs):</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">  <span class="cf">if</span> lhs._is_node:</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">    <span class="cf">if</span> rhs._is_node:</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">      <span class="cf">if</span> lhs._data <span class="op">&lt;=</span> rhs._data:</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">        <span class="cf">return</span> Tree(lhs._data,</a>
<a class="sourceLine" id="cb10-6" data-line-number="6">                    merge(rhs, lhs._rchild),</a>
<a class="sourceLine" id="cb10-7" data-line-number="7">                    lhs._lchild)</a>
<a class="sourceLine" id="cb10-8" data-line-number="8">      <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb10-9" data-line-number="9">        <span class="cf">return</span> Tree(rhs._data,</a>
<a class="sourceLine" id="cb10-10" data-line-number="10">                    merge(lhs, rhs._rchild),</a>
<a class="sourceLine" id="cb10-11" data-line-number="11">                    rhs._lchild)</a>
<a class="sourceLine" id="cb10-12" data-line-number="12">    <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb10-13" data-line-number="13">      <span class="cf">return</span> lhs</a>
<a class="sourceLine" id="cb10-14" data-line-number="14">  <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb10-15" data-line-number="15">    <span class="cf">return</span> rhs</a></code></pre></div>
<p>You may even write this version first: it initially seems more natural (because <code>_is_node</code> is used in the positive). Here’s the question, though: does it do the same thing as the previous version? Are you <em>sure</em>? Which else is connected to which if? Does every if have an else? (some linters will suggest you <em>remove</em> some of the elses above, since the if-clause has a <code>return</code> statement in it!)</p>
<p>The fact of the matter is that we are forced to do truth tables of every condition in our minds, rather than <em>saying what we mean</em> (as we do in the Haskell version).</p>
<p>The other thing we’re saved from in the Haskell version is accessing undefined fields. In the Python function, we know accessing <code>lhs._data</code> is correct since we verified that <code>lhs</code> is a node. But the logic to do this verification is complex: we checked if it <em>wasn’t</em> a node, and returned if that was true… so if it <em>is true</em> that <code>lhs</code> <em>isn’t</em> a node, we would have returned, but we didn’t, so…</p>
<p>Bear in mind all of these logic checks happened four lines before the actual access: this can get much uglier in practice! Compare this to the Haskell version: <em>we only get to bind variables if we’re sure they exist</em>. The syntax itself prevents us from accessing fields which aren’t defined, in a simple way.</p>
<p>Pattern matching has existed for years in many different forms: even C has switch statements. The added feature of destructuring is available in languages like Swift, Rust, and the whole ML family. Ask for it in your language today!</p>
<p>Now that we have that function, we get to define others in terms of it:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">insert ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">insert x <span class="fu">=</span> merge (<span class="dt">Node</span> x <span class="dt">Leaf</span> <span class="dt">Leaf</span>)</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb12"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">def</span> insert(element, tree):</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">    tree.__dict__ <span class="op">=</span> merge(node(element, leaf(), leaf()),</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">                          tree).__dict__.copy()</a></code></pre></div>
</div>
</div>
<h1 id="a-word-on-types">A Word on Types</h1>
<p>I haven’t mentioned Haskell’s type system so far, as it’s been quite unobtrusive in the examples. And that’s kind of the point: despite more complex examples you’ll see online demonstrating the power of type classes and higher-kinded types, Haskell’s type system <em>excels</em> in these simpler cases.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="ot">merge ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a</a></code></pre></div>
<p>Without much ceremony, this signature tells us:</p>
<ol>
<li>The function takes two trees, and returns a third.</li>
<li>Both trees have to be filled with the same types of elements.</li>
<li>Those elements must have an order defined on them.</li>
</ol>
<h1 id="type-inference">Type Inference</h1>
<p>I feel a lot of people miss the point of this particular feature. Technically speaking, this feature allows us to write fewer type signatures, as Haskell will be able to guess most of them. Coming from something like Java, you might think that that’s an opportunity to shorten up some verbose code. It’s not! You’ll rarely find a Haskell program these days missing top-level type signatures: it’s easier to read a program with explicit type signatures, so people are advised to put them as much as possible.</p>
<p>(Amusingly, I often find older Haskell code snippets which are entirely devoid of type signatures. It seems that programmers were so excited about Hindley-Milner type inference that they would put it to the test as often as they could.)</p>
<p>Type inference in Haskell is actually useful in a different way. First, if I write the <em>implementation</em> of the <code>merge</code> function, the compiler will tell <em>me</em> the signature, which is extremely helpful for more complex examples. Take the following, for instance:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1">f x <span class="fu">=</span> ((x <span class="fu">*</span> <span class="dv">2</span>) <span class="fu">^</span> <span class="dv">3</span>) <span class="fu">/</span> <span class="dv">4</span></a></code></pre></div>
<p>Remembering precisely which numeric type <code>x</code> needs to be is a little difficult (<code>Floating</code>? <code>Real</code>? <code>Fractional</code>?), but if I just ask the compiler it will tell me without difficulty.</p>
<p>The second use is kind of the opposite: if I have a hole in my program where I need to fill in some code, Haskell can help me along by telling me the <em>type</em> of that hole automatically. This is often enough information to figure out the entire implementation! In fact, there are some programs which will use this capability of the type checker to fill in the hole with valid programs, synthesising your code for you.</p>
<p>So often strong type systems can make you feel like you’re fighting more and more against the compiler. I hope these couple examples show that it doesn’t have to be that way.</p>
<h1 id="when-things-go-wrong">When Things Go Wrong</h1>
<p>The next function is “pop-min”:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="ot">popMin ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, <span class="dt">Tree</span> a)</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">popMin <span class="dt">Leaf</span> <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb15-3" data-line-number="3">popMin (<span class="dt">Node</span> x xl xr) <span class="fu">=</span> <span class="dt">Just</span> (x, merge xl xr)</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb16"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="kw">def</span> popMin(tree):</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">  <span class="cf">if</span> tree._is_node:</a>
<a class="sourceLine" id="cb16-3" data-line-number="3">    res <span class="op">=</span> tree._data</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">    tree.__dict__ <span class="op">=</span> merge(tree._lchild, tree._rchild).__dict__.copy()</a>
<a class="sourceLine" id="cb16-5" data-line-number="5">    <span class="cf">return</span> res</a>
<a class="sourceLine" id="cb16-6" data-line-number="6">  <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb16-7" data-line-number="7">    <span class="cf">raise</span> <span class="pp">IndexError</span></a></code></pre></div>
</div>
</div>
<p>At first glance, this function should be right at home in Python. It <em>mutates</em> its input, and it has an error case. The code we’ve written here for Python is pretty idiomatic, also: other than the ugly deep copy, we’re basically just mutating the object, and using an exception for the exceptional state (when the tree is empty). Even the exception we use is the same exception as when you try and <code>pop()</code> from an empty list.</p>
<p>The Haskell code here mainly demonstrates a difference in API style you’ll see between the two languages. If something isn’t found, we just use <code>Maybe</code>. And instead of mutating the original variable, we return the new state in the second part of a tuple. What’s nice about this is that we’re only using simple core features like algebraic data types to emulate pretty complex features like exceptions in Python.</p>
<p>You may have heard that “Haskell uses monads to do mutation and exceptions”. This is not true. Yes, state and exceptions have patterns which technically speaking are “monadic”. But make no mistake: when we want to model “exceptions” in Haskell, we really just return a maybe (or an either). And when we want to do “mutation”, we return a tuple, where the second element is the updated state. You don’t have to understand monads to use them, and you certainly don’t “need” monads to do them. To drive the point home, the above code could actually equivalently have a type which mentions “the state monad” and “the maybe monad”:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="ot">popMin ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">StateT</span> (<span class="dt">Tree</span> a) <span class="dt">Maybe</span> a</a></code></pre></div>
<p>But there’s no need to!</p>
<h1 id="gluing-it-all-together">Gluing It All Together</h1>
<p>The main part of our task is now done: all that is left is to glue the various bits and pieces together. Remember, the overall algorithm builds up the heap from a list, and then tears it down using <code>popMin</code>. First, then, to build up the heap.</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="ot">listToHeap ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">listToHeap <span class="fu">=</span> foldr insert <span class="dt">Leaf</span></a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb19"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="kw">def</span> listToHeap(elements):</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">  res <span class="op">=</span> leaf()</a>
<a class="sourceLine" id="cb19-3" data-line-number="3">  <span class="cf">for</span> el <span class="kw">in</span> elements:</a>
<a class="sourceLine" id="cb19-4" data-line-number="4">    insert(el, res)</a>
<a class="sourceLine" id="cb19-5" data-line-number="5">  <span class="cf">return</span> res</a></code></pre></div>
</div>
</div>
<p>To my eye, the Haskell code here is significantly more “readable” than the Python. I know that’s a very subjective judgement, but <code>foldr</code> is a function so often used that it’s immediately clear what’s happening in this example.</p>
<p>Why didn’t we use a similar function in Python, then? We actually could have: python does have an equivalent to <code>foldr</code>, called <code>reduce</code> (it’s <a href="https://docs.python.org/3/library/functools.html#functools.reduce">been relegated to functools</a> since Python 3 (also technically it’s equivalent to <code>foldl</code>, not <code>foldr</code>)). We’re encouraged <em>not</em> to use it, though: the more pythonic code uses a for loop. Also, it wouldn’t work for our use case: the <code>insert</code> function we wrote is <em>mutating</em>, which doesn’t gel well with <code>reduce</code>.</p>
<p>I think this demonstrates another benefit of simple, functional APIs. If you keep things simple, and build things out of functions, they’ll tend to glue together <em>well</em>, without having to write any glue code yourself. The for loop, in my opinion, is “glue code”. The next function, <code>heapToList</code>, illustrates this even more so:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="ot">heapToList ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb20-2" data-line-number="2">heapToList <span class="fu">=</span> unfoldr popMin</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb21"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="kw">def</span> heapToList(tree):</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">  res <span class="op">=</span> []</a>
<a class="sourceLine" id="cb21-3" data-line-number="3">  <span class="cf">try</span>:</a>
<a class="sourceLine" id="cb21-4" data-line-number="4">    <span class="cf">while</span> <span class="va">True</span>:</a>
<a class="sourceLine" id="cb21-5" data-line-number="5">      res.append(popMin(tree))</a>
<a class="sourceLine" id="cb21-6" data-line-number="6">  <span class="cf">except</span> <span class="pp">IndexError</span>:</a>
<a class="sourceLine" id="cb21-7" data-line-number="7">    <span class="cf">return</span> res</a></code></pre></div>
</div>
</div>
<p>Again, things are kept simple in the Haskell example. We’ve stuck to data types and functions, and these data types and functions mesh well with each other. You might be aware that there’s some deep and interesting mathematics behind the <code>foldr</code> and <code>unfoldr</code> functions going on, and <a href="https://kseo.github.io/posts/2016-12-12-unfold-and-fold.html">how they relate</a>. We don’t need to know any of that here, though: they just work together well.</p>
<p>Again, Python does have a function which is equivalent to <code>unfoldr</code>: <a href="https://docs.python.org/3/library/functions.html#iter"><code>iter</code></a> has an overload which will repeatedly call a function until it hits a sentinel value. But this doesn’t fit with the rest of the iterator model! Most iterators are terminated with the <code>StopIteration</code> exception; ours (like the <code>pop</code> function on lists) is terminated by the <code>IndexError</code> exception; and this function excepts a third version, terminated by a sentinel!</p>
<p>Finally, let’s write <code>sort</code>:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1">sort<span class="ot"> ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb22-2" data-line-number="2">sort <span class="fu">=</span> heapToList <span class="fu">.</span> listToHeap</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb23"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="kw">def</span> sort(elements):</a>
<a class="sourceLine" id="cb23-2" data-line-number="2">  <span class="cf">return</span> heapToList(listToHeap(elements))</a></code></pre></div>
</div>
</div>
<p>This is just driving home the point: programs work <em>well</em> when they’re built out of functions, and you <em>want</em> your language to encourage you to build things out of functions. In this case, the <code>sort</code> function is built out of two smaller ones: it’s the <em>essence</em> of function composition.</p>
<h1 id="laziness">Laziness</h1>
<p>So I fully admit that laziness is one of the features of Haskell that does have downsides. I don’t think every language should be lazy, but I did want to say a little about it in regards to the sorting example here.</p>
<p>I tend to think that people overstate how hard it makes reasoning about space: it actually follows pretty straightforward rules, which you can generally step through in yourself (compared to, for instance, rewrite rules, which are often black magic!)</p>
<p>In modern programming, people will tend to use laziness it anyway. Python is a great example: the <a href="https://docs.python.org/3/library/itertools.html">itertools</a> library is almost entirely lazy. Actually making use of the laziness, though, is difficult and error-prone. Above, for instance, the <code>heapToList</code> function is lazy in Haskell, but strict in Python. Converting it to a lazy version is not the most difficult thing in the world:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="kw">def</span> heapToList(tree):</a>
<a class="sourceLine" id="cb24-2" data-line-number="2">  <span class="cf">try</span>:</a>
<a class="sourceLine" id="cb24-3" data-line-number="3">    <span class="cf">while</span> <span class="va">True</span>:</a>
<a class="sourceLine" id="cb24-4" data-line-number="4">      <span class="cf">yield</span> popMin(tree)</a>
<a class="sourceLine" id="cb24-5" data-line-number="5">  <span class="cf">except</span> <span class="pp">IndexError</span>:</a>
<a class="sourceLine" id="cb24-6" data-line-number="6">    <span class="cf">pass</span></a></code></pre></div>
<p>But now, suddenly, the entire list API won’t work. What’s more, if we try and access the <em>first</em> element of the returned value, we mutate the whole thing: anyone else looking at the output of the generator will have it mutated out from under them!</p>
<p>Laziness fundamentally makes this more reusable. Take our <code>popMin</code> function: if we just want to view the smallest element, without reconstructing the rest of the tree, we can actually use <code>popMin</code> as-is. If we don’t use the second element of the tuple we don’t pay for it. In Python, we need to write a second function.</p>
<h1 id="testing">Testing</h1>
<p>Testing the <code>sort</code> function in Haskell is ridiculously easy. Say we have an example sorting function that we trust, maybe a slow but obvious insertion sort, and we want to make sure that our fast heap sort here does the same thing. This is the test:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1">quickCheck (\xs <span class="ot">-&gt;</span> sort (<span class="ot">xs ::</span> [<span class="dt">Int</span>]) <span class="fu">===</span> insertionSort xs)</a></code></pre></div>
<p>In that single line, the <a href="https://hackage.haskell.org/package/QuickCheck">QuickCheck</a> library will automatically generate random input, run each sort function on it, and compare the two outputs, giving a rich diff if they don’t match.</p>
<h1 id="conclusion">Conclusion</h1>
<p>This post was meant to show a few features like pattern-matching, algebraic data types, and function-based APIs in a good light. These ideas aren’t revolutionary any more, and plenty of languages have them, but unfortunately several languages don’t. Hopefully the example here illustrates a little why these features are good, and pushes back against the idea that algebraic data types are too complex for mainstream languages.</p>
<h1 id="update-5102019">Update 5/10/2019</h1>
<p>This got posted to <a href="https://reddit.com/r/haskell/comments/dclflr/what_is_good_about_haskell/">/r/haskell</a> and <a href="https://news.ycombinator.com/item?id=21145014">hackernews</a>. You can find me arguing in the comments there a little bit: I’m <a href="https://news.ycombinator.com/user?id=oisdk"><code>oisdk</code> on hackernews</a> and <a href="https://reddit.com/user/foBrowsing">u/foBrowsing on reddit</a>.</p>
<p>There are two topics that came up a bunch that I’d like to add to this post. First I’ll just quote <a href="https://news.ycombinator.com/item?id=21145374">one of the comments</a> from <a href="https://news.ycombinator.com/user?id=Beltiras">Beltiras</a>:</p>
<blockquote>
<p>Friend of mine is always trying to convert me. Asked me to read this yesterday evening. This is my take on the article:</p>
</blockquote>
<blockquote>
<p>Most of my daily job goes into gluing services (API endpoints to databases or other services, some business logic in the middle). I don’t need to see yet another exposition of how to do algorithmic tasks. Haven’t seen one of those since doing my BSc. Show me the tools available to write a daemon, an http server, API endpoints, ORM-type things and you will have provided me with tools to tackle what I do. I’ll never write a binary tree or search or a linked list at work.</p>
</blockquote>
<blockquote>
<p>If you want to convince me, show me what I need to know to do what I do.</p>
</blockquote>
<p>and <a href="https://news.ycombinator.com/item?id=21151580">my response</a>:</p>
<blockquote>
<p>I wasn’t really trying to convince anyone to use Haskell at their day job: I am just a college student, after all, so I would have no idea what I was talking about!</p>
</blockquote>
<blockquote>
<p>I wrote the article a while ago after being frustrated using a bunch of Go and Python at an internship. Often I really wanted simple algebraic data types and pattern-matching, but when I looked up why Go didn’t have them I saw a lot of justifications that amounted to “functional features are too complex and we’re making a simple language. Haskell is notoriously complex”. In my opinion, the <code>res, err := fun(); if err != nil</code> (for example) pattern was much more complex than the alternative with pattern-matching. So I wanted to write an article demonstrating that, while Haskell has a lot of out-there stuff in it, there’s a bunch of simple ideas which really shouldn’t be missing from any modern general-purpose language.</p>
</blockquote>
<blockquote>
<p>As to why I used a binary tree as the example, I thought it was pretty self-contained, and I find skew heaps quite interesting.</p>
</blockquote>
<p>The second topic was basically people having a go at my ugly Python; to which I say: fair enough! It is not my best. I wasn’t trying necessarily to write the best Python I could here, though, rather I was trying to write the “normal” implementation of a binary tree. If I was to implement a binary tree of some sort myself, though, I would certainly write it in an immutable style rather than the style here. Bear in mind as well that much of what I’m arguing for is stylistic: I think (for instance) that it would be better to use <code>reduce</code> in Python more, and I think the move away from it is a bad thing. So of course I’m not going to use reduce when I’m showing the Python version: I’m doing a compare and contrast!</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Yes, I know about the new dataclasses feature. However, it’s wrapped up with the (also new) type hints module, and as such is much more complicated to use. As the purpose of the Python code here is to provide something of a lingua franca for non-Haskellers, I decided against using it. That said, the problems outlined are <em>not</em> solved by dataclasses.<a href="#fnref1" class="footnote-back">↩</a></p></li>
</ol>
</section>
]]></description>
    <pubDate>Wed, 02 Oct 2019 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2019-10-02-what-is-good-about-haskell.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Bachelor's Thesis</title>
    <link>https://doisinkidney.com/posts/2019-07-14-bsc-thesis.html</link>
    <description><![CDATA[<div class="info">
    Posted on July 14, 2019
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Agda.html">Agda</a>
    
</div>

<p>I recently finished my undergrad degree in <a href="https://www.ucc.ie/">UCC</a>. I’m putting my final-year project up here for reference purposes.</p>
<p><a href="/pdfs/bsc-thesis.pdf">Here</a> is the pdf.</p>
<p>And here’s a bibtext entry:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bib"><code class="sourceCode bibtex"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="va">@thesis</span>{<span class="ot">kidney_automatically_2019</span>,</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">	<span class="dt">address</span> = {Cork, Ireland},</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">	<span class="dt">type</span> = {Bachelor thesis},</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">	<span class="dt">title</span> = {Automatically and {Efficiently} {Illustrating} {Polynomial} {Equalities} in {Agda}},</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">	<span class="dt">url</span> = {https://doisinkidney.com/pdfs/bsc-thesis.pdf},</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">	<span class="dt">abstract</span> = {We present a new library which automates the construction of equivalence proofs between polynomials over commutative rings and semirings in the programming language Agda [20]. It is signi cantly faster than Agda’s existing solver. We use re ection to provide a sim- ple interface to the solver, and demonstrate how to use the constructed proofs to provide step-by-step solutions.},</a>
<a class="sourceLine" id="cb1-7" data-line-number="7">	<span class="dt">language</span> = {en},</a>
<a class="sourceLine" id="cb1-8" data-line-number="8">	<span class="dt">school</span> = {University College Cork},</a>
<a class="sourceLine" id="cb1-9" data-line-number="9">	<span class="dt">author</span> = {Kidney, Donnacha Oisín},</a>
<a class="sourceLine" id="cb1-10" data-line-number="10">	<span class="dt">month</span> = <span class="st">apr</span>,</a>
<a class="sourceLine" id="cb1-11" data-line-number="11">	<span class="dt">year</span> = {2019}</a>
<a class="sourceLine" id="cb1-12" data-line-number="12">}</a></code></pre></div>
]]></description>
    <pubDate>Sun, 14 Jul 2019 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2019-07-14-bsc-thesis.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Solving Programming Puzzles without using your Brain</title>
    <link>https://doisinkidney.com/posts/2019-06-04-solving-puzzles-without-your-brain.html</link>
    <description><![CDATA[<div class="info">
    Posted on June  4, 2019
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Python.html">Python</a>
    
</div>

<p>This post is a write-up of a solution to part of a programming puzzle I did yesterday. It’s a little different than the usual “solution + theory” approach, though: I’m going to talk about the actual steps you’d need to take to get to the solution (i.e. what to google, what intermediate code looks like, etc.). Often write ups like this are presented as finished artefacts, with little info on the tricks or techniques the author used to jog their intuition into figuring out the puzzle (or where some intermediate step requires a leap of insight). In actual fact, this particular puzzle requires almost no insight <em>at all</em>: I’m going to show how to get to a working solution without understanding any of the theory behind it!</p>
<p>Spoilers ahead for the google foobar problem “Distract the Guards”.</p>
<h1 id="the-problem">The Problem</h1>
<p>We’re interested in a particular type of sequences of pairs of numbers. These sequences are generated from a starting pair <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math> like so:</p>
<blockquote>
<p>If <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math> are equal, the sequence stops.</p>
<p>Otherwise, the smaller number is subtracted from the larger, and then the smaller is doubled, and the sequence continues with these two numbers.</p>
</blockquote>
<p>Here’s an example starting with 3 and 5:</p>
<pre><code>     3, 5
     6, 2
     4, 4
---- done ----</code></pre>
<p>Once it hits <code>4, 4</code>, the first condition is met, and the sequence stops. Not all of these sequences stop, however:</p>
<pre><code>     1, 4
     2, 3
     1, 4
---- done ---- </code></pre>
<p>As you can see, in this case we loop back around to <code>1, 4</code>: our task is to figure out, given a pair of numbers, whether the sequence generated by them loops forever, or stops at some point.</p>
<h1 id="step-1-write-a-dumb-solution">Step 1: Write a Dumb Solution</h1>
<p>This step is crucial: before trying to figure out any of the deep mathematics behind the problem, write the dumbest thing that could work. You’re going to need it, anyway, to test your faster versions against, and besides, it might be good enough as-is!</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">def</span> sequence(n,m):</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">    <span class="cf">while</span> n <span class="op">!=</span> m:</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">        <span class="cf">yield</span> (n,m)</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">        <span class="cf">if</span> n <span class="op">&lt;</span> m:</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">            m <span class="op">-=</span> n</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">            n <span class="op">*=</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7">        <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb3-8" data-line-number="8">            n <span class="op">-=</span> m</a>
<a class="sourceLine" id="cb3-9" data-line-number="9">            m <span class="op">*=</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb3-10" data-line-number="10"></a>
<a class="sourceLine" id="cb3-11" data-line-number="11"><span class="kw">def</span> loops(xs):</a>
<a class="sourceLine" id="cb3-12" data-line-number="12">    seen <span class="op">=</span> <span class="bu">set</span>()</a>
<a class="sourceLine" id="cb3-13" data-line-number="13">    <span class="cf">for</span> x <span class="kw">in</span> xs:</a>
<a class="sourceLine" id="cb3-14" data-line-number="14">        <span class="cf">if</span> x <span class="kw">in</span> seen:</a>
<a class="sourceLine" id="cb3-15" data-line-number="15">            <span class="cf">return</span> <span class="va">True</span></a>
<a class="sourceLine" id="cb3-16" data-line-number="16">        <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb3-17" data-line-number="17">            seen.add(x)</a>
<a class="sourceLine" id="cb3-18" data-line-number="18">    <span class="cf">return</span> <span class="va">False</span></a>
<a class="sourceLine" id="cb3-19" data-line-number="19"></a>
<a class="sourceLine" id="cb3-20" data-line-number="20"><span class="kw">def</span> solution(n,m):</a>
<a class="sourceLine" id="cb3-21" data-line-number="21">    <span class="cf">return</span> loops(sequence(n,m))</a></code></pre></div>
<p>The first function actually generates the sequence we’re interested in: it uses python’s generators to do so. The second function is just a generic function that checks a sequence for duplicates. Finally, the last function answers the question we’re interested in.</p>
<h1 id="step-2-graph-it">Step 2: Graph it</h1>
<p>Next, we want to try and spot some patterns in the answers the function generates. Remember, we’re not really interested in figuring out the theory at this point: if we find out that a loop only happens when both numbers are even (for instance), that’s good enough for us and we can stop there!</p>
<p>We humans are pattern-matching machines: to leverage our abilities, though, we will need to visualise the data somehow. In this case, I’m going to plot a simple scatter graph to the terminal, using the following code (I apologise for my terrible indentation style):</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="bu">print</span>(</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">    <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>.join(</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">        <span class="st">&#39;&#39;</span>.join(</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">            <span class="st">&#39;*&#39;</span> <span class="cf">if</span> solution(x,y) <span class="cf">else</span> <span class="st">&#39; &#39;</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5">            <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,<span class="dv">81</span>)</a>
<a class="sourceLine" id="cb4-6" data-line-number="6">        )</a>
<a class="sourceLine" id="cb4-7" data-line-number="7">        <span class="cf">for</span> y <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">100</span>,<span class="dv">0</span>,<span class="op">-</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb4-8" data-line-number="8">    )</a>
<a class="sourceLine" id="cb4-9" data-line-number="9">)</a></code></pre></div>
<p>And we get the following output:</p>
<details>
<p><summary> Output </summary></p>
<pre><code>*************************** ******************************* ********************
**************************** *** *********** ******************************* ***
************* *************** **************************************************
****************************** *************************************************
******************************* ************************************************
******************************** *********************** ******* ***************
********************************* **********************************************
** *************************** *** *********************************************
*********************************** ********************************************
************ ******* *************** *******************************************
***** *********************** ******* *************** *************** **********
************************************** *****************************************
*************************************** ****************************************
******** ******************* *********** ***************************************
***************************************** **************************************
****************************************** ******* *********************** *****
*********** *************** *************** ************************************
******************************************** ***********************************
********************************************* **********************************
************** *********** ******************* *************** *****************
*********************************************** ******************************* 
************************************************ ***************************** *
***************** ******* *********************** *************************** **
********** *********************** *************** ************************* ***
*************************************************** *********************** ****
**** *************** *** ******************* ******* ********************* *****
***************************************************** ******************* ******
****************************************************** ***************** *******
*********************** ******************************* *************** ********
******************************************************** ************* *********
********* ******************************* *************** *********** **********
********************** *** ******************************* ********* ***********
*********************************************************** ******* ************
************************************************************ ***** *************
********************* ******* ******************************* *** **************
************** *********************** *********************** * ***************
*************************************************************** ****************
 ******* *********** *********** *************** ************* * ***************
* *********************************************************** *** **************
** ********************************************************* ***** *************
*** *************** *************** *********************** ******* ************
**** ***************************************************** ********* ***********
***** *************************************************** *********** **********
****** *********** ******************* ***************** ************* *********
******* *********************************************** *************** ********
******** *************** ******* ********************* ***************** *******
********* ******* *********************** *********** ******************* ******
********** ***************************************** ********************* *****
*********** *************************************** *********************** ****
************ *** *************************** ***** ************************* ***
************* *************** ******************* *************************** **
****** ******* ********************************* ************* *************** *
*************** ******************************* ******************************* 
**************** ***************************** *********************************
***************** *************************** **********************************
** *********** *** ******* ******* ********* ***** *********************** *****
******************* *********************** ************************************
******************** ********************* *************************************
***** ******* ******* ******************* *********** *************** **********
********************** ***************** ***************************************
*********************** *************** ****************************************
******** *** *********** ************* ***************** ******* ***************
************************* *********** ******************************************
************************** ********* *******************************************
*********** *************** ******* *********************** ********************
**** *************** ******* ***** ********* ******************************* ***
***************************** *** **********************************************
********** *** *************** * ********************* ******* *****************
******************************* ************************************************
 ***************************** * ***********************************************
* ******* ******* *********** *** *************** *************** **************
** ************************* ***** *********************************************
*** *********************** ******* ********************************************
**** *** *********** ***** ********* ******* *********************** ***********
***** ******************* *********** *************************************** **
****** ******* ********* ************* *************** ******************* *****
******* *************** *************** ******************************* ********
******** ************* ***************** *************************** ***********
********* *********** ******************* *********************** **************
** *** *** ********* ***** ******* ******* ******************* *********** *****
*********** ******* *********************** *************** ********************
************ ***** ************************* *********** ***********************
***** ******* *** *********** *************** ******* *********************** **
************** * ***************************** *** *****************************
*************** ******************************* ********************************
 *** *** ***** * ******* ******* *********** *** *************** ***************
* *********** *** *********************** ******* ******************************
** ********* ***** ******************* *********** *****************************
*** ******* ******* *************** *************** ****************************
**** ***** ********* *********** ******************* *********************** ***
***** *** *********** ******* *********************** *************** **********
** *** * ***** ******* *** *********** *************** ******* *****************
******* *************** ******************************* ************************
 ***** * *********** *** *********************** ******* ***********************
* *** *** ******* ******* *************** *************** **********************
** * ***** *** *********** ******* *********************** *************** *****
*** ******* *************** ******************************* ********************
 * * *** *** ******* ******* *************** *************** *******************
* *** ******* *************** ******************************* ******************
 * *** ******* *************** ******************************* *****************</code></pre>
</details>
<p>There’s a clear pattern there, but it might be easier to see if we inverted it, plotting those things which <em>don’t</em> loop:</p>
<details>
<p><summary> Output </summary></p>
<pre><code>                           *                               *                    
                            *   *           *                               *   
             *               *                                                  
                              *                                                 
                               *                                                
                                *                       *       *               
                                 *                                              
  *                           *   *                                             
                                   *                                            
            *       *               *                                           
     *                       *       *               *               *          
                                      *                                         
                                       *                                        
        *                   *           *                                       
                                         *                                      
                                          *       *                       *     
           *               *               *                                    
                                            *                                   
                                             *                                  
              *           *                   *               *                 
                                               *                               *
                                                *                             * 
                 *       *                       *                           *  
          *                       *               *                         *   
                                                   *                       *    
    *               *   *                   *       *                     *     
                                                     *                   *      
                                                      *                 *       
                       *                               *               *        
                                                        *             *         
         *                               *               *           *          
                      *   *                               *         *           
                                                           *       *            
                                                            *     *             
                     *       *                               *   *              
              *                       *                       * *               
                                                               *                
*       *           *           *               *             * *               
 *                                                           *   *              
  *                                                         *     *             
   *               *               *                       *       *            
    *                                                     *         *           
     *                                                   *           *          
      *           *                   *                 *             *         
       *                                               *               *        
        *               *       *                     *                 *       
         *       *                       *           *                   *      
          *                                         *                     *     
           *                                       *                       *    
            *   *                           *     *                         *   
             *               *                   *                           *  
      *       *                                 *             *               * 
               *                               *                               *
                *                             *                                 
                 *                           *                                  
  *           *   *       *       *         *     *                       *     
                   *                       *                                    
                    *                     *                                     
     *       *       *                   *           *               *          
                      *                 *                                       
                       *               *                                        
        *   *           *             *                 *       *               
                         *           *                                          
                          *         *                                           
           *               *       *                       *                    
    *               *       *     *         *                               *   
                             *   *                                              
          *   *               * *                     *       *                 
                               *                                                
*                             * *                                               
 *       *       *           *   *               *               *              
  *                         *     *                                             
   *                       *       *                                            
    *   *           *     *         *       *                       *           
     *                   *           *                                       *  
      *       *         *             *               *                   *     
       *               *               *                               *        
        *             *                 *                           *           
         *           *                   *                       *              
  *   *   *         *     *       *       *                   *           *     
           *       *                       *               *                    
            *     *                         *           *                       
     *       *   *           *               *       *                       *  
              * *                             *   *                             
               *                               *                                
*   *   *     * *       *       *           *   *               *               
 *           *   *                       *       *                              
  *         *     *                   *           *                             
   *       *       *               *               *                            
    *     *         *           *                   *                       *   
     *   *           *       *                       *               *          
  *   * *     *       *   *           *               *       *                 
       *               *                               *                        
*     * *           *   *                       *       *                       
 *   *   *       *       *               *               *                      
  * *     *   *           *       *                       *               *     
   *       *               *                               *                    
* * *   *   *       *       *               *               *                   
 *   *       *               *                               *                  
* *   *       *               *                               *                 </code></pre>
</details>
<p>For this kind of thing it’s also worth getting familiar with <a href="http://www.gnuplot.info/">gnuplot</a>.</p>
<h1 id="step-3-reduce-the-space">Step 3: Reduce The Space</h1>
<p>The clearest pattern in the graph above is the straight lines coming from the origin. This tells me, straight away, that we have an opportunity for optimisation if we wanted to memoize. We can’t yet be sure, but it <em>looks</em> like every point belongs to one of these straight lines. That means that once we find a non-looping pair like <code>3, 5</code>, we can extend that line out to <code>6, 10</code> and <code>9, 15</code>, etc.</p>
<p>We can also see that the graph has a symmetry through the line <code>x = y</code>. This means that if <code>3, 5</code> doesn’t loop, neither does <code>5, 3</code>.</p>
<p>Both of these techniques allow us to reduce the arguments to a canonical form, making the memoization table smaller, also. In code:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="im">from</span> fractions <span class="im">import</span> Fraction</a>
<a class="sourceLine" id="cb7-2" data-line-number="2"></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="kw">def</span> canonical(n,m):</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">    f <span class="op">=</span> Fraction(n,m) <span class="cf">if</span> n <span class="op">&lt;=</span> m <span class="cf">else</span> Fraction(m,n)</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">    <span class="cf">return</span> (f.numerator, f.denominator)</a>
<a class="sourceLine" id="cb7-6" data-line-number="6"></a>
<a class="sourceLine" id="cb7-7" data-line-number="7">memo_dict <span class="op">=</span> {}</a>
<a class="sourceLine" id="cb7-8" data-line-number="8"></a>
<a class="sourceLine" id="cb7-9" data-line-number="9"><span class="kw">def</span> solution(n,m):</a>
<a class="sourceLine" id="cb7-10" data-line-number="10">    c <span class="op">=</span> canonical(n, m)</a>
<a class="sourceLine" id="cb7-11" data-line-number="11">    <span class="cf">try</span>:</a>
<a class="sourceLine" id="cb7-12" data-line-number="12">        <span class="cf">return</span> memo_dict[c]</a>
<a class="sourceLine" id="cb7-13" data-line-number="13">    <span class="cf">except</span> <span class="pp">KeyError</span>:</a>
<a class="sourceLine" id="cb7-14" data-line-number="14">      r <span class="op">=</span> loops(sequence(<span class="op">*</span>c))</a>
<a class="sourceLine" id="cb7-15" data-line-number="15">      memo_dict[c] <span class="op">=</span> r</a>
<a class="sourceLine" id="cb7-16" data-line-number="16">      <span class="cf">return</span> r</a></code></pre></div>
<h1 id="step-4-test">Step 4: Test</h1>
<p>Now that we have our faster version, we want to be able to quickly check that it’s equivalent to the slow. While Python is usually great for programming puzzles, this step in particular is crying out for something like QuickCheck: without it, we’ll have to roll our own.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="im">from</span> random <span class="im">import</span> randrange</a>
<a class="sourceLine" id="cb8-2" data-line-number="2"></a>
<a class="sourceLine" id="cb8-3" data-line-number="3"><span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1000</span>):</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">    x, y <span class="op">=</span> randrange(<span class="dv">1</span>,<span class="dv">10000</span>), randrange(<span class="dv">1</span>,<span class="dv">10000</span>)</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">    <span class="cf">if</span> solution_new(x,y) <span class="op">!=</span> solution_old(x,y):</a>
<a class="sourceLine" id="cb8-6" data-line-number="6">        <span class="bu">print</span>(x,y)</a></code></pre></div>
<p>We’re not looking for certainty here, just something that will quickly spot an error if one exists.</p>
<h1 id="step-5-more-sophisticated-patterns">Step 5: More Sophisticated Patterns</h1>
<p>Now that we’ve made some of the more obvious optimisations, it’s time to move on to finding another pattern in the output. To do this, we’ll use <a href="https://oeis.org/">oeis.org</a>. We want to find if the pairs which pass our test follow some sequence which has a simple generating function which we can adapt into a test.</p>
<p>Since the things we’re testing are pairs, rather than individual numbers, we’ll have to fix one of them and see if there’s a pattern in the other.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="bu">print</span>([x <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,<span class="dv">101</span>) <span class="cf">if</span> <span class="kw">not</span> solution(<span class="dv">1</span>, x)])</a></code></pre></div>
<p>This prints the following sequence:</p>
<pre><code>[1, 3, 7, 15, 31, 63]</code></pre>
<p>And when we search for it on oeis, we get <a href="https://oeis.org/A000225">this</a> as the top result:</p>
<pre><code>0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767,
65535, 131071, 262143, 524287, 1048575, 2097151, 4194303, 8388607, 16777215,
33554431, 67108863...</code></pre>
<p>And looking at the comments under the sequence, we see the following:</p>
<blockquote>
<p>Numbers n for which the expression 2^n/(n+1) is an integer. - <a href="https://oeis.org/wiki/User:Paolo_P._Lava">Paolo P. Lava</a>, May 12 2006</p>
</blockquote>
<p>A test for members of the sequence, all packaged up for us!</p>
<p>But how do we generalise to pairs other than 1? Well, as a total guess, we can see that 1 appears in one place in the formula: why not replace that with the other member of the pair?</p>
<p>After that, we get the following function to test:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">def</span> solution(n,m):</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">    nc, mc <span class="op">=</span> canonical(n,m)</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">    <span class="cf">return</span> <span class="bu">bool</span>((<span class="dv">2</span> <span class="op">**</span> mc) <span class="op">%</span> (nc <span class="op">+</span> mc))</a></code></pre></div>
<p>And it works!</p>
<h1 id="step-6-look-for-algorithms">Step 6: Look For Algorithms</h1>
<p>This last step is pretty straightforward: see if there’s an algorithm already out there that solves your problem. In our case, taking the modulus is still pretty slow, but it turns out that modular exponentiation (i.e. computing expressions of the form <code>x^y mod z</code>) can be done <a href="https://en.wikipedia.org/wiki/Modular_exponentiation">faster</a> than the naive way. In fact, python provides this algorithm as a function in the standard library, making our last version of the function the following:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">def</span> solution(n,m):</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">    nc, mc <span class="op">=</span> canonical(n,m)</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">    <span class="cf">return</span> <span class="bu">bool</span>(<span class="bu">pow</span>(<span class="dv">2</span>, mc, nc <span class="op">+</span> mc))</a></code></pre></div>
<p>I’m not sure if this function is fully correct, but it was accepted as a solution to the puzzle.</p>
<p>Anyway, in conclusion: you can get quite far through a programming puzzle by applying some educated guesses and googling!</p>
]]></description>
    <pubDate>Tue, 04 Jun 2019 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2019-06-04-solving-puzzles-without-your-brain.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Deriving a Linear-Time Applicative Traversal of a Rose Tree</title>
    <link>https://doisinkidney.com/posts/2019-05-28-linear-phases.html</link>
    <description><![CDATA[<div class="info">
    Posted on May 28, 2019
</div>
<div class="info">
    
        Part 7 of a <a href="/series/Breadth-First%20Traversals.html">7-part series on Breadth-First Traversals</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<h1 id="the-story-so-far">The Story so Far</h1>
<p>Currently, we have several different ways to enumerate a tree in breadth-first order. The typical solution (which is the usual recommended approach in imperative programming as well) uses a <em>queue</em>, as described by <span class="citation" data-cites="okasaki_breadth-first_2000">Okasaki (<a href="#ref-okasaki_breadth-first_2000">2000</a>)</span>. If we take the simplest possible queue (a list), we get a quadratic-time algorithm, with an albeit simple implementation. The next simplest version is to use a banker’s queue (which is just a pair of lists). From this version, if we inline and apply identities like the following:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1">foldr f b <span class="fu">.</span> reverse <span class="fu">=</span> foldl (flip f) b</a></code></pre></div>
<p>We’ll get to the following definition:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">bfe ::</span> <span class="dt">Forest</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">bfe ts <span class="fu">=</span> foldr f b ts []</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">    f (<span class="dt">Node</span> x xs) fw bw <span class="fu">=</span> x <span class="fu">:</span> fw (xs <span class="fu">:</span> bw)</a>
<a class="sourceLine" id="cb2-5" data-line-number="5"></a>
<a class="sourceLine" id="cb2-6" data-line-number="6">    b [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">    b qs <span class="fu">=</span> foldl (foldr f) b qs []</a></code></pre></div>
<p>We can get from this function to others (like one which uses a corecursive queue, and so on) through a similar derivation. I might some day write a post on each derivation, starting from the simple version and demonstrating how to get to the more efficient at each step.</p>
<p>For today, though, I’m interested in the <em>traversal</em> of a rose tree. Traversal, here, of course, is in the applicative sense.</p>
<p>Thus far, I’ve managed to write linear-time traversals, but they’ve been unsatisfying. They work by enumerating the tree, traversing the effectful function over the list, and then rebuilding the tree. Since each of those steps only takes linear time, the whole thing is indeed a linear-time traversal, but I hadn’t been able to fuse away the intermediate step.</p>
<h1 id="phases">Phases</h1>
<p>The template for the algorithm I want comes from the <code>Phases</code> applicative <span class="citation" data-cites="easterly_functions_2019">(Easterly <a href="#ref-easterly_functions_2019">2019</a>)</span>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Phases</span> f a <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  <span class="dt">Lift</span><span class="ot">   ::</span> f a <span class="ot">-&gt;</span> <span class="dt">Phases</span> f a</a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="ot">  (:&lt;*&gt;) ::</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Phases</span> f a <span class="ot">-&gt;</span> <span class="dt">Phases</span> f b</a></code></pre></div>
<p>We can use it to write a breadth-first traversal like so:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">bft ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> f (<span class="dt">Tree</span> b)</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">bft f <span class="fu">=</span> runPhases <span class="fu">.</span> go</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">    go (<span class="dt">Node</span> x xs) <span class="fu">=</span> liftA2 <span class="dt">Node</span> (<span class="dt">Lift</span> (f x)) (later (traverse go xs))</a></code></pre></div>
<p>The key component that makes this work is that it combines applicative effects in parallel:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Functor</span> (<span class="dt">Phases</span> f) <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">    fmap f (<span class="dt">Lift</span> x) <span class="fu">=</span> <span class="dt">Lift</span> (fmap f x)</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">    fmap f (fs <span class="fu">:&lt;*&gt;</span> xs) <span class="fu">=</span> fmap (f<span class="fu">.</span>) fs <span class="fu">:&lt;*&gt;</span> xs</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">    </a>
<a class="sourceLine" id="cb5-5" data-line-number="5"><span class="kw">instance</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="dt">Phases</span> f) <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6">    pure <span class="fu">=</span> <span class="dt">Lift</span> <span class="fu">.</span> pure</a>
<a class="sourceLine" id="cb5-7" data-line-number="7">    <span class="dt">Lift</span> fs      <span class="fu">&lt;*&gt;</span> <span class="dt">Lift</span> xs      <span class="fu">=</span> <span class="dt">Lift</span> (fs <span class="fu">&lt;*&gt;</span> xs)</a>
<a class="sourceLine" id="cb5-8" data-line-number="8">    (fs <span class="fu">:&lt;*&gt;</span> gs) <span class="fu">&lt;*&gt;</span> <span class="dt">Lift</span> xs      <span class="fu">=</span> liftA2 flip fs xs <span class="fu">:&lt;*&gt;</span> gs</a>
<a class="sourceLine" id="cb5-9" data-line-number="9">    <span class="dt">Lift</span> fs      <span class="fu">&lt;*&gt;</span> (xs <span class="fu">:&lt;*&gt;</span> ys) <span class="fu">=</span> liftA2 (<span class="fu">.</span>)  fs xs <span class="fu">:&lt;*&gt;</span> ys</a>
<a class="sourceLine" id="cb5-10" data-line-number="10">    (fs <span class="fu">:&lt;*&gt;</span> gs) <span class="fu">&lt;*&gt;</span> (xs <span class="fu">:&lt;*&gt;</span> ys) <span class="fu">=</span> liftA2 c    fs xs <span class="fu">:&lt;*&gt;</span> liftA2 (,) gs ys</a>
<a class="sourceLine" id="cb5-11" data-line-number="11">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-12" data-line-number="12">        c f g <span class="fu">~</span>(x,y) <span class="fu">=</span> f x (g y)</a></code></pre></div>
<p>We’re also using the following helper functions:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">runPhases ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">Phases</span> f a <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">runPhases (<span class="dt">Lift</span> x) <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">runPhases (fs <span class="fu">:&lt;*&gt;</span> xs) <span class="fu">=</span> fs <span class="fu">&lt;*&gt;</span> runPhases xs</a>
<a class="sourceLine" id="cb6-4" data-line-number="4"></a>
<a class="sourceLine" id="cb6-5" data-line-number="5"><span class="ot">later ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">Phases</span> f a <span class="ot">-&gt;</span> <span class="dt">Phases</span> f a</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">later <span class="fu">=</span> (<span class="fu">:&lt;*&gt;</span>) (pure id)</a></code></pre></div>
<p>The problem is that it’s quadratic: the <code>traverse</code> in:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1">go (<span class="dt">Node</span> x xs) <span class="fu">=</span> liftA2 <span class="dt">Node</span> (<span class="dt">Lift</span> (f x)) (later (traverse go xs))</a></code></pre></div>
<p>Hides some expensive calls to <code>&lt;*&gt;</code>.</p>
<h1 id="a-roadmap-for-optimisation">A Roadmap for Optimisation</h1>
<p>The problem with the <code>Phases</code> traversal is actually analogous to another function for enumeration: <code>levels</code> from <span class="citation" data-cites="gibbons_breadth-first_2015">Gibbons (<a href="#ref-gibbons_breadth-first_2015">2015</a>)</span>.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">levels ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">levels (<span class="dt">Node</span> x xs) <span class="fu">=</span> [x] <span class="fu">:</span> foldr lzw [] (map levels xs)</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">    lzw [] ys <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">    lzw xs [] <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb8-6" data-line-number="6">    lzw (x<span class="fu">:</span>xs) (y<span class="fu">:</span>ys) <span class="fu">=</span> (x <span class="fu">++</span> y) <span class="fu">:</span> lzw xs ys</a></code></pre></div>
<p><code>lzw</code> takes the place of <code>&lt;*&gt;</code> here, but the overall issue is the same: we’re zipping at every point, making the whole thing quadratic.</p>
<p>However, from the above function we <em>can</em> derive a linear time enumeration. It looks like this:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">levels ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">levels ts <span class="fu">=</span> f ts []</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4">    f (<span class="dt">Node</span> x xs) (q<span class="fu">:</span>qs) <span class="fu">=</span> (x<span class="fu">:</span>q) <span class="fu">:</span> foldr f qs xs</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">    f (<span class="dt">Node</span> x xs) []     <span class="fu">=</span> [x]   <span class="fu">:</span> foldr f [] xs</a></code></pre></div>
<p>Our objective is clear, then: try to derive the linear-time implementation of <code>bft</code> from the quadratic, in a way analogous to the above two functions. This is actually relatively straightforward once the target is clear: the rest of this post is devoted to the derivation.</p>
<h1 id="derivation">Derivation</h1>
<p>First, we start off with the original <code>bft</code>.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">bft ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> f (<span class="dt">Tree</span> b)</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">bft f <span class="fu">=</span> runPhases <span class="fu">.</span> go</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4">    go (<span class="dt">Node</span> x xs) <span class="fu">=</span> liftA2 <span class="dt">Node</span> (<span class="dt">Lift</span> (f x)) (later (traverse go xs))</a></code></pre></div>
<details>
<p><summary> Inline <code>traverse</code>. </summary></p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">bft ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> f (<span class="dt">Tree</span> b)</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">bft f <span class="fu">=</span> runPhases <span class="fu">.</span> go</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4">    go (<span class="dt">Node</span> x xs) <span class="fu">=</span> liftA2 <span class="dt">Node</span> (<span class="dt">Lift</span> (f x)) (later (go&#39; xs))</a>
<a class="sourceLine" id="cb11-5" data-line-number="5">    go&#39; <span class="fu">=</span> foldr (liftA2 (<span class="fu">:</span>) <span class="fu">.</span> go) (pure [])</a></code></pre></div>
</details>
<details>
<p><summary> Factor out <code>go''</code>. </summary></p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="ot">bft ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> f (<span class="dt">Tree</span> b)</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">bft f <span class="fu">=</span> runPhases <span class="fu">.</span> go</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">    go (<span class="dt">Node</span> x xs) <span class="fu">=</span> liftA2 <span class="dt">Node</span> (<span class="dt">Lift</span> (f x)) (later (go&#39; xs))</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">    go&#39; <span class="fu">=</span> foldr go&#39;&#39; (pure [])</a>
<a class="sourceLine" id="cb12-6" data-line-number="6">    go&#39;&#39; (<span class="dt">Node</span> x xs) ys <span class="fu">=</span> liftA2 (<span class="fu">:</span>) (liftA2 <span class="dt">Node</span> (<span class="dt">Lift</span> (f x)) (later (go&#39; xs))) ys</a></code></pre></div>
</details>
<details>
<p><summary> Inline <code>go'</code> (and rename <code>go''</code> to <code>go'</code>)</p>
<p></summary></p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="ot">bft ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> f (<span class="dt">Tree</span> b)</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">bft f <span class="fu">=</span> runPhases <span class="fu">.</span> go</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4">    go (<span class="dt">Node</span> x xs) <span class="fu">=</span> liftA2 <span class="dt">Node</span> (<span class="dt">Lift</span> (f x)) (later (foldr go&#39; (pure []) xs))</a>
<a class="sourceLine" id="cb13-5" data-line-number="5">    go&#39; (<span class="dt">Node</span> x xs) ys <span class="fu">=</span> liftA2 (<span class="fu">:</span>) (liftA2 <span class="dt">Node</span> (<span class="dt">Lift</span> (f x)) (later (foldr go&#39; (pure []) xs))) ys</a></code></pre></div>
</details>
<details>
<p><summary> Definition of <code>liftA2</code></p>
<p></summary></p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="ot">bft ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> f (<span class="dt">Tree</span> b)</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">bft f <span class="fu">=</span> runPhases <span class="fu">.</span> go</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-4" data-line-number="4">    go (<span class="dt">Node</span> x xs) <span class="fu">=</span> liftA2 <span class="dt">Node</span> (<span class="dt">Lift</span> (f x)) (later (foldr go&#39; (pure []) xs))</a>
<a class="sourceLine" id="cb14-5" data-line-number="5">    go&#39; (<span class="dt">Node</span> x xs) ys <span class="fu">=</span> liftA2 (<span class="fu">:</span>) (fmap <span class="dt">Node</span> (f x) <span class="fu">:&lt;*&gt;</span> (foldr go&#39; (pure []) xs)) ys</a></code></pre></div>
</details>
<details>
<p><summary> Definition of <code>liftA2</code> (pattern-matching on <code>ys</code>)</p>
<p></summary></p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="ot">bft ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> f (<span class="dt">Tree</span> b)</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">bft f <span class="fu">=</span> runPhases <span class="fu">.</span> go</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-4" data-line-number="4">    go (<span class="dt">Node</span> x xs) <span class="fu">=</span> liftA2 <span class="dt">Node</span> (<span class="dt">Lift</span> (f x)) (later (foldr go&#39; (pure []) xs))</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">    go&#39; (<span class="dt">Node</span> x xs) (<span class="dt">Lift</span> ys)    <span class="fu">=</span> fmap (((<span class="fu">:</span>)<span class="fu">.</span>) <span class="fu">.</span> <span class="dt">Node</span>) (f x) <span class="fu">:&lt;*&gt;</span> (foldr go&#39; (pure []) xs) <span class="fu">&lt;*&gt;</span> <span class="dt">Lift</span> ys</a>
<a class="sourceLine" id="cb15-6" data-line-number="6">    go&#39; (<span class="dt">Node</span> x xs) (ys <span class="fu">:&lt;*&gt;</span> zs) <span class="fu">=</span> fmap (((<span class="fu">:</span>)<span class="fu">.</span>) <span class="fu">.</span> <span class="dt">Node</span>) (f x) <span class="fu">:&lt;*&gt;</span> (foldr go&#39; (pure []) xs) <span class="fu">&lt;*&gt;</span> ys <span class="fu">:&lt;*&gt;</span> zs</a></code></pre></div>
</details>
<details>
<p><summary> Definition of <code>&lt;*&gt;</code>. </summary></p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="ot">bft ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> f (<span class="dt">Tree</span> b)</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">bft f <span class="fu">=</span> runPhases <span class="fu">.</span> go</a>
<a class="sourceLine" id="cb16-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-4" data-line-number="4">    go (<span class="dt">Node</span> x xs) <span class="fu">=</span> liftA2 <span class="dt">Node</span> (<span class="dt">Lift</span> (f x)) (later (foldr go&#39; (pure []) xs))</a>
<a class="sourceLine" id="cb16-5" data-line-number="5">    go&#39; (<span class="dt">Node</span> x xs) (<span class="dt">Lift</span> ys)    <span class="fu">=</span> liftA2 flip (fmap (((<span class="fu">:</span>)<span class="fu">.</span>) <span class="fu">.</span> <span class="dt">Node</span>) (f x)) ys <span class="fu">:&lt;*&gt;</span> foldr go&#39; (pure []) xs</a>
<a class="sourceLine" id="cb16-6" data-line-number="6">    go&#39; (<span class="dt">Node</span> x xs) (ys <span class="fu">:&lt;*&gt;</span> zs) <span class="fu">=</span> liftA2 c (fmap (((<span class="fu">:</span>)<span class="fu">.</span>) <span class="fu">.</span> <span class="dt">Node</span>) (f x)) ys <span class="fu">:&lt;*&gt;</span> liftA2 (,) (foldr go&#39; (pure []) xs) zs</a>
<a class="sourceLine" id="cb16-7" data-line-number="7">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-8" data-line-number="8">        c f g <span class="fu">~</span>(x,y) <span class="fu">=</span> f x (g y)</a></code></pre></div>
</details>
<details>
<p><summary> Fuse <code>liftA2</code> with <code>fmap</code></p>
<p></summary></p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="ot">bft ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> f (<span class="dt">Tree</span> b)</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">bft f <span class="fu">=</span> runPhases <span class="fu">.</span> go</a>
<a class="sourceLine" id="cb17-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb17-4" data-line-number="4">    go (<span class="dt">Node</span> x xs) <span class="fu">=</span> liftA2 <span class="dt">Node</span> (<span class="dt">Lift</span> (f x)) (later (foldr go&#39; (pure []) xs))</a>
<a class="sourceLine" id="cb17-5" data-line-number="5">    go&#39; (<span class="dt">Node</span> x xs) (<span class="dt">Lift</span> ys)    <span class="fu">=</span> liftA2 (flip <span class="fu">.</span> (((<span class="fu">:</span>)<span class="fu">.</span>) <span class="fu">.</span> <span class="dt">Node</span>)) (f x) ys <span class="fu">:&lt;*&gt;</span> foldr go&#39; (pure []) xs</a>
<a class="sourceLine" id="cb17-6" data-line-number="6">    go&#39; (<span class="dt">Node</span> x xs) (ys <span class="fu">:&lt;*&gt;</span> zs) <span class="fu">=</span> liftA2 (c <span class="fu">.</span> (((<span class="fu">:</span>)<span class="fu">.</span>) <span class="fu">.</span> <span class="dt">Node</span>)) (f x) ys <span class="fu">:&lt;*&gt;</span> liftA2 (,) (foldr go&#39; (pure []) xs) zs</a>
<a class="sourceLine" id="cb17-7" data-line-number="7">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb17-8" data-line-number="8">        c f g <span class="fu">~</span>(x,y) <span class="fu">=</span> f x (g y)</a></code></pre></div>
</details>
<details open>
<p><summary> Beta-reduction. </summary></p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="ot">bft ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> f (<span class="dt">Tree</span> b)</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">bft f <span class="fu">=</span> go</a>
<a class="sourceLine" id="cb18-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-4" data-line-number="4">    go (<span class="dt">Node</span> x xs) <span class="fu">=</span> liftA2 <span class="dt">Node</span> (f x) (runPhases (foldr go&#39; (pure []) xs))</a>
<a class="sourceLine" id="cb18-5" data-line-number="5">    </a>
<a class="sourceLine" id="cb18-6" data-line-number="6">    go&#39; (<span class="dt">Node</span> x xs) (<span class="dt">Lift</span> ys)    <span class="fu">=</span> liftA2 (\y zs ys <span class="ot">-&gt;</span> <span class="dt">Node</span> y ys <span class="fu">:</span> zs) (f x) ys <span class="fu">:&lt;*&gt;</span> foldr go&#39; (pure []) xs</a>
<a class="sourceLine" id="cb18-7" data-line-number="7">    go&#39; (<span class="dt">Node</span> x xs) (ys <span class="fu">:&lt;*&gt;</span> zs) <span class="fu">=</span> liftA2 c (f x) ys <span class="fu">:&lt;*&gt;</span> liftA2 (,) (foldr go&#39; (pure []) xs) zs</a>
<a class="sourceLine" id="cb18-8" data-line-number="8">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-9" data-line-number="9">        c y g <span class="fu">~</span>(ys,z) <span class="fu">=</span> <span class="dt">Node</span> y ys <span class="fu">:</span> g z</a></code></pre></div>
</details>
<p>At this point, we actually hit a wall: the expression</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1">liftA2 (,) (foldr go&#39; (pure []) xs) zs</a></code></pre></div>
<p>Is what makes the whole thing quadratic. We need to find a way to thread that <code>liftA2</code> along with the fold to get it to linear. This is the only real trick in the derivation: I’ll use polymorphic recursion to avoid the extra zip.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="ot">bft ::</span> forall f a b<span class="fu">.</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> f (<span class="dt">Tree</span> b)</a>
<a class="sourceLine" id="cb20-2" data-line-number="2">bft f <span class="fu">=</span> go</a>
<a class="sourceLine" id="cb20-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-4" data-line-number="4">    go (<span class="dt">Node</span> x xs) <span class="fu">=</span> liftA2 (\y (ys,_) <span class="ot">-&gt;</span> <span class="dt">Node</span> y ys) (f x) (runPhases (foldr go&#39; (pure ([],())) xs))</a>
<a class="sourceLine" id="cb20-5" data-line-number="5">    </a>
<a class="sourceLine" id="cb20-6" data-line-number="6"><span class="ot">    go&#39; ::</span> forall c<span class="fu">.</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Phases</span> f ([<span class="dt">Tree</span> b], c) <span class="ot">-&gt;</span> <span class="dt">Phases</span> f ([<span class="dt">Tree</span> b], c)</a>
<a class="sourceLine" id="cb20-7" data-line-number="7">    go&#39; (<span class="dt">Node</span> x xs) ys<span class="fu">@</span>(<span class="dt">Lift</span> _)  <span class="fu">=</span> fmap (\y <span class="ot">-&gt;</span> first (pure <span class="fu">.</span> <span class="dt">Node</span> y)) (f x) <span class="fu">:&lt;*&gt;</span> foldr go&#39; ys xs</a>
<a class="sourceLine" id="cb20-8" data-line-number="8">    go&#39; (<span class="dt">Node</span> x xs) (ys <span class="fu">:&lt;*&gt;</span> zs) <span class="fu">=</span> liftA2 c (f x) ys <span class="fu">:&lt;*&gt;</span> foldr go&#39; (fmap ((,) []) zs) xs</a>
<a class="sourceLine" id="cb20-9" data-line-number="9">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-10" data-line-number="10">        c y g <span class="fu">~</span>(ys,z) <span class="fu">=</span> first (<span class="dt">Node</span> y ys<span class="fu">:</span>) (g z)</a></code></pre></div>
<p>And that’s it!</p>
<h1 id="avoiding-maps">Avoiding Maps</h1>
<p>We can finally write a slightly different version that avoids some unnecessary <code>fmap</code>s by basing <code>Phases</code> on <code>liftA2</code> rather than <code>&lt;*&gt;</code>.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Levels</span> f a <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-2" data-line-number="2">  <span class="dt">Now</span><span class="ot">   ::</span> a <span class="ot">-&gt;</span> <span class="dt">Levels</span> f a</a>
<a class="sourceLine" id="cb21-3" data-line-number="3">  <span class="dt">Later</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Levels</span> f b <span class="ot">-&gt;</span> <span class="dt">Levels</span> f c</a>
<a class="sourceLine" id="cb21-4" data-line-number="4"></a>
<a class="sourceLine" id="cb21-5" data-line-number="5"><span class="kw">instance</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Functor</span> (<span class="dt">Levels</span> f) <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-6" data-line-number="6">    fmap f (<span class="dt">Now</span> x) <span class="fu">=</span> <span class="dt">Now</span> (f x)</a>
<a class="sourceLine" id="cb21-7" data-line-number="7">    fmap f (<span class="dt">Later</span> c xs ys) <span class="fu">=</span> <span class="dt">Later</span> ((f<span class="fu">.</span>) <span class="fu">.</span> c) xs ys</a>
<a class="sourceLine" id="cb21-8" data-line-number="8">            </a>
<a class="sourceLine" id="cb21-9" data-line-number="9"><span class="ot">runLevels ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">Levels</span> f a <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb21-10" data-line-number="10">runLevels (<span class="dt">Now</span> x) <span class="fu">=</span> pure x</a>
<a class="sourceLine" id="cb21-11" data-line-number="11">runLevels (<span class="dt">Later</span> f xs ys) <span class="fu">=</span> liftA2 f xs (runLevels ys)</a>
<a class="sourceLine" id="cb21-12" data-line-number="12"></a>
<a class="sourceLine" id="cb21-13" data-line-number="13"><span class="ot">bft ::</span> forall f a b<span class="fu">.</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> f (<span class="dt">Tree</span> b)</a>
<a class="sourceLine" id="cb21-14" data-line-number="14">bft f <span class="fu">=</span> go</a>
<a class="sourceLine" id="cb21-15" data-line-number="15">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-16" data-line-number="16">    go (<span class="dt">Node</span> x xs) <span class="fu">=</span> liftA2 (\y (ys,_) <span class="ot">-&gt;</span> <span class="dt">Node</span> y ys) (f x) (runLevels (foldr go&#39; (<span class="dt">Now</span> ([],())) xs))</a>
<a class="sourceLine" id="cb21-17" data-line-number="17">    </a>
<a class="sourceLine" id="cb21-18" data-line-number="18"><span class="ot">    go&#39; ::</span> forall c<span class="fu">.</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Levels</span> f ([<span class="dt">Tree</span> b], c) <span class="ot">-&gt;</span> <span class="dt">Levels</span> f ([<span class="dt">Tree</span> b], c)</a>
<a class="sourceLine" id="cb21-19" data-line-number="19">    go&#39; (<span class="dt">Node</span> x xs) ys<span class="fu">@</span>(<span class="dt">Now</span> _)      <span class="fu">=</span> <span class="dt">Later</span> (\y <span class="ot">-&gt;</span> first (pure <span class="fu">.</span> <span class="dt">Node</span> y)) (f x) (foldr go&#39; ys xs)</a>
<a class="sourceLine" id="cb21-20" data-line-number="20">    go&#39; (<span class="dt">Node</span> x xs) (<span class="dt">Later</span> k ys zs) <span class="fu">=</span> <span class="dt">Later</span> id (liftA2 c (f x) ys) (foldr go&#39; (fmap ((,) []) zs) xs)</a>
<a class="sourceLine" id="cb21-21" data-line-number="21">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-22" data-line-number="22">        c y g <span class="fu">~</span>(ys,z) <span class="fu">=</span> first (<span class="dt">Node</span> y ys<span class="fu">:</span>) (k g z)</a></code></pre></div>
<h1 id="references" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-easterly_functions_2019">
<p>Easterly, Noah. 2019. “Functions and newtype wrappers for traversing Trees: Rampion/tree-traversals.” <a href="https://github.com/rampion/tree-traversals" class="uri">https://github.com/rampion/tree-traversals</a>.</p>
</div>
<div id="ref-gibbons_breadth-first_2015">
<p>Gibbons, Jeremy. 2015. “Breadth-First Traversal.” <em>Patterns in Functional Programming</em>. <a href="https://patternsinfp.wordpress.com/2015/03/05/breadth-first-traversal/" class="uri">https://patternsinfp.wordpress.com/2015/03/05/breadth-first-traversal/</a>.</p>
</div>
<div id="ref-okasaki_breadth-first_2000">
<p>Okasaki, Chris. 2000. “Breadth-first Numbering: Lessons from a Small Exercise in Algorithm Design.” In <em>Proceedings of the Fifth ACM SIGPLAN International Conference on Functional Programming</em>, 131–136. ICFP ’00. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/351240.351253">10.1145/351240.351253</a>. <a href="https://www.cs.tufts.edu/~nr/cs257/archive/chris-okasaki/breadth-first.pdf" class="uri">https://www.cs.tufts.edu/~nr/cs257/archive/chris-okasaki/breadth-first.pdf</a>.</p>
</div>
</div>
]]></description>
    <pubDate>Tue, 28 May 2019 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2019-05-28-linear-phases.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Implicit Corecursive Queues</title>
    <link>https://doisinkidney.com/posts/2019-05-14-corecursive-implicit-queues.html</link>
    <description><![CDATA[<div class="info">
    Posted on May 14, 2019
</div>
<div class="info">
    
        Part 6 of a <a href="/series/Breadth-First%20Traversals.html">7-part series on Breadth-First Traversals</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<h1 id="fusion">Fusion</h1>
<p>I was looking again at one of my implementations of breadth-first traversals:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">bfe ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">bfe r <span class="fu">=</span> f r b []</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">    f (<span class="dt">Node</span> x xs) fw bw <span class="fu">=</span> x <span class="fu">:</span> fw (xs <span class="fu">:</span> bw)</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">  </a>
<a class="sourceLine" id="cb1-6" data-line-number="6">    b [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb1-7" data-line-number="7">    b qs <span class="fu">=</span> foldl (foldr f) b qs []</a></code></pre></div>
<p>And I was wondering if I could <em>fuse</em> away the intermediate list. On the following line:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1">f (<span class="dt">Node</span> x xs) fw bw <span class="fu">=</span> x <span class="fu">:</span> fw (xs <span class="fu">:</span> bw)</a></code></pre></div>
<p>The <code>xs : bw</code> is a little annoying, because we <em>know</em> it’s going to be consumed eventually by a fold. When that happens, it’s often a good idea to remove the list, and just inline the fold. In other words, if you see the following:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1">foldr f b (x <span class="fu">:</span> y <span class="fu">:</span> [])</a></code></pre></div>
<p>You should replace it with this:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">f x (f y b)</a></code></pre></div>
<p>If you try and do that with the above definition, you get something like the following:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">bfenum ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">bfenum t <span class="fu">=</span> f t b b</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">    f (<span class="dt">Node</span> x xs) fw bw <span class="fu">=</span> x <span class="fu">:</span> fw (bw <span class="fu">.</span> flip (foldr f) xs)</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">    b x <span class="fu">=</span> x b</a></code></pre></div>
<h1 id="infinite-types">Infinite Types</h1>
<p>The trouble is that the above comes with type errors:</p>
<pre><code>Cannot construct the infinite type: b ~ (b -&gt; c) -&gt; [a]</code></pre>
<p>This error shows up occasionally when you try and do heavy church-encoding in Haskell. You get a similar error when trying to encode the Y combinator:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1">y <span class="fu">=</span> \f <span class="ot">-&gt;</span> (\x <span class="ot">-&gt;</span> f (x x)) (\x <span class="ot">-&gt;</span> f (x x))</a></code></pre></div>
<pre><code>• Occurs check: cannot construct the infinite type: t0 ~ t0 -&gt; t</code></pre>
<p>The solution for the y combinator is to use a newtype, where we can catch the recursion at a certain point to help the typechecker.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Mu</span> a <span class="fu">=</span> <span class="dt">Mu</span> (<span class="dt">Mu</span> a <span class="ot">-&gt;</span> a)</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">y f <span class="fu">=</span> (\h <span class="ot">-&gt;</span> h <span class="fu">$</span> <span class="dt">Mu</span> h) (\x <span class="ot">-&gt;</span> f <span class="fu">.</span> (\(<span class="dt">Mu</span> g) <span class="ot">-&gt;</span> g) x <span class="fu">$</span> x)</a></code></pre></div>
<p>The trick for our queue is similar:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Q</span> a <span class="fu">=</span> <span class="dt">Q</span> {<span class="ot"> q ::</span> (<span class="dt">Q</span> a <span class="ot">-&gt;</span> [a]) <span class="ot">-&gt;</span> [a] }</a>
<a class="sourceLine" id="cb10-2" data-line-number="2"></a>
<a class="sourceLine" id="cb10-3" data-line-number="3"><span class="ot">bfenum ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">bfenum t <span class="fu">=</span> q (f t b) e</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-6" data-line-number="6">    f (<span class="dt">Node</span> x xs) fw <span class="fu">=</span> <span class="dt">Q</span> (\bw <span class="ot">-&gt;</span> x <span class="fu">:</span> q fw (bw <span class="fu">.</span> flip (foldr f) xs))</a>
<a class="sourceLine" id="cb10-7" data-line-number="7">    b <span class="fu">=</span> fix (<span class="dt">Q</span> <span class="fu">.</span> flip id)</a>
<a class="sourceLine" id="cb10-8" data-line-number="8">    e <span class="fu">=</span> fix (flip q)</a></code></pre></div>
<p>This is actually equivalent to the continuation monad:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Fix</span> f <span class="fu">=</span> <span class="dt">Fix</span> {<span class="ot"> unFix ::</span> f (<span class="dt">Fix</span> f) }</a>
<a class="sourceLine" id="cb11-2" data-line-number="2"></a>
<a class="sourceLine" id="cb11-3" data-line-number="3"><span class="kw">type</span> <span class="dt">Q</span> a <span class="fu">=</span> <span class="dt">Fix</span> (<span class="dt">ContT</span> a [])</a>
<a class="sourceLine" id="cb11-4" data-line-number="4"></a>
<a class="sourceLine" id="cb11-5" data-line-number="5">q <span class="fu">=</span> runContT <span class="fu">.</span> unFix</a>
<a class="sourceLine" id="cb11-6" data-line-number="6"></a>
<a class="sourceLine" id="cb11-7" data-line-number="7"><span class="ot">bfenum ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb11-8" data-line-number="8">bfenum t <span class="fu">=</span> q (f t b) e</a>
<a class="sourceLine" id="cb11-9" data-line-number="9">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-10" data-line-number="10">    f (<span class="dt">Node</span> x xs) fw <span class="fu">=</span> <span class="dt">Fix</span> (mapContT (x<span class="fu">:</span>) (flip (foldr f) xs <span class="fu">&lt;$&gt;</span> unFix fw))</a>
<a class="sourceLine" id="cb11-11" data-line-number="11">    b <span class="fu">=</span> fix (<span class="dt">Fix</span> <span class="fu">.</span> pure)</a>
<a class="sourceLine" id="cb11-12" data-line-number="12">    e <span class="fu">=</span> fix (flip q)</a></code></pre></div>
<h1 id="terminating">Terminating</h1>
<p>There’s a problem though: this algorithm never checks for an end. That’s ok if there isn’t one, mind you. For instance, with the following “unfold” function:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">9</span> <span class="fu">#.</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="ot">(#.) ::</span> <span class="dt">Coercible</span> b c <span class="ot">=&gt;</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> c</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">(<span class="fu">#.</span>) _ <span class="fu">=</span> coerce</a>
<a class="sourceLine" id="cb12-4" data-line-number="4"><span class="ot">{-# INLINE (#.) #-}</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5"></a>
<a class="sourceLine" id="cb12-6" data-line-number="6"><span class="ot">bfUnfold ::</span> (a <span class="ot">-&gt;</span> (b,[a])) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [b]</a>
<a class="sourceLine" id="cb12-7" data-line-number="7">bfUnfold f t <span class="fu">=</span> g t (fix (<span class="dt">Q</span> <span class="fu">#.</span> flip id)) (fix (flip q))</a>
<a class="sourceLine" id="cb12-8" data-line-number="8">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-9" data-line-number="9">    g b fw bw <span class="fu">=</span> x <span class="fu">:</span> q fw (bw <span class="fu">.</span> flip (foldr ((<span class="dt">Q</span> <span class="fu">.</span>) <span class="fu">#.</span> g)) xs)</a>
<a class="sourceLine" id="cb12-10" data-line-number="10">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-11" data-line-number="11">        (x,xs) <span class="fu">=</span> f b</a></code></pre></div>
<p>We can write a decent enumeration of the rationals.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="co">-- Stern-Brocot</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2"><span class="ot">rats1 ::</span> [<span class="dt">Rational</span>]</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">rats1 <span class="fu">=</span> bfUnfold step ((<span class="dv">0</span>,<span class="dv">1</span>),(<span class="dv">1</span>,<span class="dv">0</span>))</a>
<a class="sourceLine" id="cb13-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5">    step (lb,rb) <span class="fu">=</span> (n <span class="fu">%</span> d,[(lb , m),(m , rb)])</a>
<a class="sourceLine" id="cb13-6" data-line-number="6">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-7" data-line-number="7">        m<span class="fu">@</span>(n,d) <span class="fu">=</span> adj lb rb</a>
<a class="sourceLine" id="cb13-8" data-line-number="8">    adj (w,x) (y,z) <span class="fu">=</span> (w<span class="fu">+</span>y,x<span class="fu">+</span>z)</a>
<a class="sourceLine" id="cb13-9" data-line-number="9">    </a>
<a class="sourceLine" id="cb13-10" data-line-number="10"><span class="co">-- Calkin-Wilf</span></a>
<a class="sourceLine" id="cb13-11" data-line-number="11"><span class="ot">rats2 ::</span> [<span class="dt">Rational</span>]</a>
<a class="sourceLine" id="cb13-12" data-line-number="12">rats2 <span class="fu">=</span> bfUnfold step (<span class="dv">1</span>,<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb13-13" data-line-number="13">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-14" data-line-number="14">    step (m,n) <span class="fu">=</span> (m <span class="fu">%</span> n,[(m,m<span class="fu">+</span>n),(n<span class="fu">+</span>m,n)])</a></code></pre></div>
<p>However, if we <em>do</em> want to stop at some point, we need a slight change to the queue type.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Q</span> a <span class="fu">=</span> <span class="dt">Q</span> {<span class="ot"> q ::</span> <span class="dt">Maybe</span> (<span class="dt">Q</span> a <span class="ot">-&gt;</span> [a]) <span class="ot">-&gt;</span> [a] }</a>
<a class="sourceLine" id="cb14-2" data-line-number="2"></a>
<a class="sourceLine" id="cb14-3" data-line-number="3"><span class="ot">bfenum ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb14-4" data-line-number="4">bfenum t <span class="fu">=</span> q (f t b) e</a>
<a class="sourceLine" id="cb14-5" data-line-number="5">  <span class="kw">where</span> </a>
<a class="sourceLine" id="cb14-6" data-line-number="6">    f (<span class="dt">Node</span> x xs) fw <span class="fu">=</span> <span class="dt">Q</span> (\bw <span class="ot">-&gt;</span> x <span class="fu">:</span> q fw (<span class="dt">Just</span> (m bw <span class="fu">.</span> flip (foldr f) xs)))</a>
<a class="sourceLine" id="cb14-7" data-line-number="7">    b <span class="fu">=</span> fix (<span class="dt">Q</span> <span class="fu">.</span> maybe [] <span class="fu">.</span> flip (<span class="fu">$</span>))</a>
<a class="sourceLine" id="cb14-8" data-line-number="8">    e <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb14-9" data-line-number="9">    m <span class="fu">=</span> fromMaybe (flip q e)</a></code></pre></div>
<h1 id="monadic">Monadic</h1>
<p>We can actually add in a monad to the above unfold without much difficulty.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Q</span> m a <span class="fu">=</span> <span class="dt">Q</span> {<span class="ot"> q ::</span> <span class="dt">Maybe</span> (<span class="dt">Q</span> m a <span class="ot">-&gt;</span> m [a]) <span class="ot">-&gt;</span> m [a] }</a>
<a class="sourceLine" id="cb15-2" data-line-number="2"></a>
<a class="sourceLine" id="cb15-3" data-line-number="3"><span class="ot">bfUnfold ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m (b,[a])) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> m [b]</a>
<a class="sourceLine" id="cb15-4" data-line-number="4">bfUnfold f t <span class="fu">=</span> g t b e</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-6" data-line-number="6">    g s fw bw <span class="fu">=</span> f s <span class="fu">&gt;&gt;=</span> </a>
<a class="sourceLine" id="cb15-7" data-line-number="7">       \ <span class="fu">~</span>(x,xs) <span class="ot">-&gt;</span> (x <span class="fu">:</span>) <span class="fu">&lt;$&gt;</span>  q fw (<span class="dt">Just</span> (m bw <span class="fu">.</span> flip (foldr ((<span class="dt">Q</span> <span class="fu">.</span>) <span class="fu">#.</span> g)) xs))</a>
<a class="sourceLine" id="cb15-8" data-line-number="8">        </a>
<a class="sourceLine" id="cb15-9" data-line-number="9">    b <span class="fu">=</span> fix (<span class="dt">Q</span> <span class="fu">#.</span> maybe (pure []) <span class="fu">.</span> flip (<span class="fu">$</span>))</a>
<a class="sourceLine" id="cb15-10" data-line-number="10">    e <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb15-11" data-line-number="11">    m <span class="fu">=</span> fromMaybe (flip q e)</a></code></pre></div>
<p>And it passes the torture tests for a linear-time breadth-first unfold from <span class="citation" data-cites="feuer_is_2015">Feuer (<a href="#ref-feuer_is_2015">2015</a>)</span>. It breaks when you try and use it to build a tree, though.</p>
<h1 id="phases">Phases</h1>
<p>Finally, we can try and make the above code a little more modular, by actually packaging up the queue type as a queue.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Q</span> a <span class="fu">=</span> <span class="dt">Q</span> {<span class="ot"> q ::</span> <span class="dt">Maybe</span> (<span class="dt">Q</span> a <span class="ot">-&gt;</span> [a]) <span class="ot">-&gt;</span> [a] }</a>
<a class="sourceLine" id="cb16-2" data-line-number="2"><span class="kw">newtype</span> <span class="dt">Queue</span> a <span class="fu">=</span> <span class="dt">Queue</span> {<span class="ot"> runQueue ::</span> <span class="dt">Q</span> a <span class="ot">-&gt;</span> <span class="dt">Q</span> a }</a>
<a class="sourceLine" id="cb16-3" data-line-number="3"></a>
<a class="sourceLine" id="cb16-4" data-line-number="4"><span class="ot">now ::</span> a <span class="ot">-&gt;</span> <span class="dt">Queue</span> a</a>
<a class="sourceLine" id="cb16-5" data-line-number="5">now x <span class="fu">=</span> <span class="dt">Queue</span> (\fw <span class="ot">-&gt;</span> <span class="dt">Q</span> (\bw <span class="ot">-&gt;</span> x <span class="fu">:</span> q fw bw))</a>
<a class="sourceLine" id="cb16-6" data-line-number="6">    </a>
<a class="sourceLine" id="cb16-7" data-line-number="7"><span class="ot">delay ::</span> <span class="dt">Queue</span> a <span class="ot">-&gt;</span> <span class="dt">Queue</span> a</a>
<a class="sourceLine" id="cb16-8" data-line-number="8">delay xs <span class="fu">=</span> <span class="dt">Queue</span> (\fw <span class="ot">-&gt;</span> <span class="dt">Q</span> (\bw <span class="ot">-&gt;</span> q fw (<span class="dt">Just</span> (m bw <span class="fu">.</span> runQueue xs))))</a>
<a class="sourceLine" id="cb16-9" data-line-number="9">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-10" data-line-number="10">    m <span class="fu">=</span> fromMaybe (flip q <span class="dt">Nothing</span>)</a>
<a class="sourceLine" id="cb16-11" data-line-number="11">    </a>
<a class="sourceLine" id="cb16-12" data-line-number="12"><span class="kw">instance</span> <span class="dt">Monoid</span> (<span class="dt">Queue</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-13" data-line-number="13">    mempty <span class="fu">=</span> <span class="dt">Queue</span> id</a>
<a class="sourceLine" id="cb16-14" data-line-number="14">    mappend (<span class="dt">Queue</span> xs) (<span class="dt">Queue</span> ys) <span class="fu">=</span> <span class="dt">Queue</span> (xs <span class="fu">.</span> ys)</a>
<a class="sourceLine" id="cb16-15" data-line-number="15">    </a>
<a class="sourceLine" id="cb16-16" data-line-number="16"><span class="ot">run ::</span> <span class="dt">Queue</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb16-17" data-line-number="17">run (<span class="dt">Queue</span> xs) <span class="fu">=</span> q (xs b) <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb16-18" data-line-number="18">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-19" data-line-number="19">    b <span class="fu">=</span> fix (<span class="dt">Q</span> <span class="fu">.</span> maybe [] <span class="fu">.</span> flip (<span class="fu">$</span>))</a>
<a class="sourceLine" id="cb16-20" data-line-number="20"></a>
<a class="sourceLine" id="cb16-21" data-line-number="21"><span class="ot">bfenum ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb16-22" data-line-number="22">bfenum t <span class="fu">=</span> run (f t)</a>
<a class="sourceLine" id="cb16-23" data-line-number="23">  <span class="kw">where</span> </a>
<a class="sourceLine" id="cb16-24" data-line-number="24">    f (<span class="dt">Node</span> x xs) <span class="fu">=</span> now x <span class="fu">&lt;&gt;</span> delay (foldMap f xs)</a></code></pre></div>
<p>At this point, our type is starting to look a lot like the <a href="https://hackage.haskell.org/package/tree-traversals-0.1.0.0/docs/Control-Applicative-Phases.html#t:Phases"><code>Phases</code></a> type from Noah Easterly’s tree-traversals package. This is exciting: the <code>Phases</code> type has the ideal interface for level-wise traversals. Unfortunately, it has the wrong time complexity for <code>&lt;*&gt;</code> and so on: my suspicion is that the queue type above here is to <code>Phases</code> as the continuation monad is to the free monad. In other words, we’ll get efficient construction at the expense of no inspection. Unfortunately, I can’t figure out how to turn the above type into an applicative. Maybe in a future post!</p>
<p>Finally, a lot of this is working towards finally understanding <span class="citation" data-cites="smith_lloyd_2009">Smith (<a href="#ref-smith_lloyd_2009">2009</a>)</span> and <span class="citation" data-cites="allison_circular_2006">Allison (<a href="#ref-allison_circular_2006">2006</a>)</span>.</p>
<div id="refs" class="references">
<div id="ref-allison_circular_2006">
<p>Allison, Lloyd. 2006. “Circular Programs and Self-Referential Structures.” <em>Software: Practice and Experience</em> 19 (2) (October): 99–109. doi:<a href="https://doi.org/10.1002/spe.4380190202">10.1002/spe.4380190202</a>. <a href="http://users.monash.edu/~lloyd/tildeFP/1989SPE/" class="uri">http://users.monash.edu/~lloyd/tildeFP/1989SPE/</a>.</p>
</div>
<div id="ref-feuer_is_2015">
<p>Feuer, David. 2015. “Is a lazy, breadth-first monadic rose tree unfold possible?” Question. <em>Stack Overflow</em>. <a href="https://stackoverflow.com/q/27748526" class="uri">https://stackoverflow.com/q/27748526</a>.</p>
</div>
<div id="ref-smith_lloyd_2009">
<p>Smith, Leon P. 2009. “Lloyd Allison’s Corecursive Queues: Why Continuations Matter.” <em>The Monad.Reader</em> 14 (14) (July): 28. <a href="https://meldingmonads.files.wordpress.com/2009/06/corecqueues.pdf" class="uri">https://meldingmonads.files.wordpress.com/2009/06/corecqueues.pdf</a>.</p>
</div>
</div>
]]></description>
    <pubDate>Tue, 14 May 2019 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2019-05-14-corecursive-implicit-queues.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Concatenative Programming; The Free Monoid of Programming Languages</title>
    <link>https://doisinkidney.com/posts/2019-05-11-concatenative-free.html</link>
    <description><![CDATA[<div class="info">
    Posted on May 11, 2019
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Concatenative.html">Concatenative</a>, <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<p>This post demonstrates a simple encoding of a (typed) concatenative language in Haskell.</p>
<p>Point-free style is one of the distinctive markers of functional programming languages. Want to sum a list? That’s as easy as:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1">sum <span class="fu">=</span> foldr (<span class="fu">+</span>) <span class="dv">0</span></a></code></pre></div>
<p>Now I want to sum every number after adding one to it.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1">sumSuccs <span class="fu">=</span> foldr (<span class="fu">+</span>) <span class="dv">0</span> <span class="fu">.</span> map ((<span class="fu">+</span>) <span class="dv">1</span>)</a></code></pre></div>
<p>One more step to make this function truly abstract™ and general™: we’ll allow the user to supply their own number to add</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1">sumAdded <span class="fu">=</span> foldr (<span class="fu">+</span>) <span class="dv">0</span> <span class="fu">.</span> map <span class="fu">.</span> (<span class="fu">+</span>)</a></code></pre></div>
<p>And here the trouble begins. The above expression won’t actually type check. In fact, it’ll give a pretty terrible error message:</p>
<pre><code>• Non type-variable argument in the constraint: Num [a]
  (Use FlexibleContexts to permit this)
• When checking the inferred type
    sumThoseThat :: forall a.
                    (Num [a], Foldable ((-&gt;) [a])) =&gt;
                    a -&gt; [a]</code></pre>
<p>I remember as a beginner being confused by similar messages. What’s <code>FlexibleContexts</code>? I had thought that the “point-free style” just meant removing the last variable from an expression if it’s also the last argument:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1">sum xs <span class="fu">=</span> foldr (<span class="fu">+</span>) <span class="dv">0</span> xs</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">sum <span class="fu">=</span> foldr (<span class="fu">+</span>) <span class="dv">0</span></a></code></pre></div>
<p>Why doesn’t it work here?</p>
<p>Well, it doesn’t work because the types don’t line up, but I’m going to try and explain a slightly different perspective on the problem, which is <em>associativity</em>.</p>
<p>To make it a little clearer, let’s see what happens when we point-fill the expression:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1">sumAdded n xs <span class="fu">=</span> (foldr(<span class="fu">+</span>) <span class="dv">0</span> <span class="fu">.</span> (map <span class="fu">.</span> (<span class="fu">+</span>))) n xs</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">             <span class="ot">=&gt;</span> foldr(<span class="fu">+</span>) <span class="dv">0</span> ((map <span class="fu">.</span> (<span class="fu">+</span>)) n) xs</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">             <span class="ot">=&gt;</span> foldr(<span class="fu">+</span>) <span class="dv">0</span> (map ((<span class="fu">+</span>) n)) xs</a></code></pre></div>
<p>Indeed, the problem is the placement of the parentheses. What we want at the end is:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1">             <span class="ot">=&gt;</span> foldr(<span class="fu">+</span>) <span class="dv">0</span> (map ((<span class="fu">+</span>) n) xs)</a></code></pre></div>
<p>But, no matter. We have to jiggle the arguments around, or we could use something terrible like this:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">9</span> <span class="fu">.:</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">(<span class="fu">.:</span>) <span class="fu">=</span> (<span class="fu">.</span>)<span class="fu">.</span>(<span class="fu">.</span>)</a>
<a class="sourceLine" id="cb8-3" data-line-number="3"></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">sumAdded <span class="fu">=</span> foldr (<span class="fu">+</span>) <span class="dv">0</span> <span class="fu">.:</span> map <span class="fu">.</span> (<span class="fu">+</span>)</a></code></pre></div>
<p>Is there something, though, that could do this automatically?</p>
<h1 id="associativity">Associativity</h1>
<p>We run into a similar problem in Agda. We’re forever having to prove statements like:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">(</span>x + y<span class="ot">)</span> + z ≡ x + <span class="ot">(</span>y + z<span class="ot">)</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">x ≡ x + <span class="dv">0</span></a></code></pre></div>
<p>There are a couple of ways to get around the issue, and for monoids there’s a rich theory of techniques. I’ll just show one for now, which relies on the <em>endomorphism</em> monoid. This monoid is created by partially applying the monoid’s binary operator:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb10-1" data-line-number="1">Endo <span class="ot">:</span> <span class="dt">Set</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">Endo <span class="ot">=</span> ℕ <span class="ot">→</span> ℕ</a>
<a class="sourceLine" id="cb10-3" data-line-number="3"></a>
<a class="sourceLine" id="cb10-4" data-line-number="4">⟦<span class="ot">_</span>⇑⟧ <span class="ot">:</span> ℕ <span class="ot">→</span> Endo</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">⟦ n ⇑⟧ m <span class="ot">=</span> n + m</a></code></pre></div>
<p>And you can get back to the underlying monoid by applying it to the neutral element:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb11-1" data-line-number="1">⟦<span class="ot">_</span>⇓⟧ <span class="ot">:</span> Endo <span class="ot">→</span> ℕ</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">⟦ n ⇓⟧ <span class="ot">=</span> n <span class="dv">0</span></a></code></pre></div>
<p>Here’s the important parts: first, we can lift the underlying operation into the endomorphism:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="ot">_</span>⊕<span class="ot">_</span> <span class="ot">:</span> Endo <span class="ot">→</span> Endo <span class="ot">→</span> Endo</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">xs ⊕ ys <span class="ot">=</span> <span class="ot">λ</span> x <span class="ot">→</span> xs <span class="ot">(</span>ys x<span class="ot">)</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3"></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">⊕-homo <span class="ot">:</span> <span class="ot">∀</span> n m <span class="ot">→</span> ⟦ ⟦ n ⇑⟧ ⊕ ⟦ m ⇑⟧ ⇓⟧ ≡ n + m</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">⊕-homo n m <span class="ot">=</span> cong <span class="ot">(</span>n +<span class="ot">_)</span> <span class="ot">(</span>+-identityʳ m<span class="ot">)</span></a></code></pre></div>
<p>And second, it’s <em>definitionally</em> associative.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb13-1" data-line-number="1">⊕-assoc <span class="ot">:</span> <span class="ot">∀</span> x y z <span class="ot">→</span> <span class="ot">(</span>x ⊕ y<span class="ot">)</span> ⊕ z ≡ x ⊕ <span class="ot">(</span>y ⊕ z<span class="ot">)</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">⊕-assoc <span class="ot">_</span> <span class="ot">_</span> <span class="ot">_</span> <span class="ot">=</span> refl</a></code></pre></div>
<p>These are all clues as to how to solve the composition problem in the Haskell code above. We need definitional associativity, somehow. Maybe we can get it from the endomorphism monoid?</p>
<h1 id="state">State</h1>
<p>You’re probably familiar with Haskell’s state monad:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">State</span> s a <span class="fu">=</span> <span class="dt">State</span> {<span class="ot"> runState ::</span> s <span class="ot">-&gt;</span> (a, s) }</a></code></pre></div>
<p>It can help a lot when you’re threading around fiddly accumulators and so on.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="ot">nub ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">nub <span class="fu">=</span> go Set.empty</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-4" data-line-number="4">    go seen [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">    go seen (x<span class="fu">:</span>xs)</a>
<a class="sourceLine" id="cb15-6" data-line-number="6">      <span class="fu">|</span> x <span class="ot">`Set.member`</span> seen <span class="fu">=</span> go seen xs</a>
<a class="sourceLine" id="cb15-7" data-line-number="7">      <span class="fu">|</span> otherwise <span class="fu">=</span> x <span class="fu">:</span> go (Set.insert x seen) xs</a></code></pre></div>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="ot">nub ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">nub <span class="fu">=</span> flip evalState Set.empty <span class="fu">.</span> go</a>
<a class="sourceLine" id="cb16-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-4" data-line-number="4">    go [] <span class="fu">=</span> pure []</a>
<a class="sourceLine" id="cb16-5" data-line-number="5">    go (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb16-6" data-line-number="6">        seen <span class="ot">&lt;-</span> gets (Set.member x)</a>
<a class="sourceLine" id="cb16-7" data-line-number="7">        <span class="kw">if</span> seen</a>
<a class="sourceLine" id="cb16-8" data-line-number="8">          <span class="kw">then</span> go xs</a>
<a class="sourceLine" id="cb16-9" data-line-number="9">          <span class="kw">else</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb16-10" data-line-number="10">              modify (Set.insert x)</a>
<a class="sourceLine" id="cb16-11" data-line-number="11">              (x<span class="fu">:</span>) <span class="fu">&lt;$&gt;</span> go xs</a></code></pre></div>
<p>Of course, these days state is a transformer:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">StateT</span> s m a <span class="fu">=</span> <span class="dt">StateT</span> {<span class="ot"> runStateT ::</span> s <span class="ot">-&gt;</span> m (a, s) }</a></code></pre></div>
<p>This lets us stack multiple effects on top of each other: error handling, IO, randomness, even another state monad. In fact, if you <em>do</em> stack another state monad on top, you might be surprised by the efficiency of the code it generates:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="kw">type</span> <span class="dt">DoubleState</span> s1 s2 a <span class="fu">=</span> <span class="dt">StateT</span> s1 (<span class="dt">State</span> s2) a</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">                        <span class="ot">=&gt;</span> s1 <span class="ot">-&gt;</span> <span class="dt">State</span> s2 (a, s1)</a>
<a class="sourceLine" id="cb18-3" data-line-number="3">                        <span class="ot">=&gt;</span> s1 <span class="ot">-&gt;</span> s2 <span class="ot">-&gt;</span> ((a, s1), s2)</a></code></pre></div>
<p>It’s nothing earth shattering, but it inlines and optimises well. That output is effectively a left-nested list, also.</p>
<h1 id="multi-state">Multi-State</h1>
<p>If we can do one, and we can do two, why not more? Can we generalise the state pattern to an arbitrary number of variables? First we’ll need a generic tuple:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:-</span></a>
<a class="sourceLine" id="cb19-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Stack</span> (<span class="ot">xs ::</span> [<span class="dt">Type</span>])<span class="ot"> ::</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-3" data-line-number="3">    <span class="dt">Nil</span><span class="ot">  ::</span> <span class="dt">Stack</span> <span class="ch">&#39;[]</span></a>
<a class="sourceLine" id="cb19-4" data-line-number="4"><span class="ot">    (:-) ::</span> x <span class="ot">-&gt;</span> <span class="dt">Stack</span> xs <span class="ot">-&gt;</span> <span class="dt">Stack</span> (x <span class="fu">:</span> xs)</a></code></pre></div>
<p>Then, the state type.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">State</span> xs a <span class="fu">=</span> <span class="dt">State</span> {<span class="ot"> runState ::</span> <span class="dt">Stack</span> xs <span class="ot">-&gt;</span> (a, <span class="dt">Stack</span> xs) }</a></code></pre></div>
<p>We can actually clean the definition up a little: instead of a tuple at the other end, why not push it onto the stack.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">State</span> xs a <span class="fu">=</span> <span class="dt">State</span> {<span class="ot"> runState ::</span> <span class="dt">Stack</span> xs <span class="ot">-&gt;</span> <span class="dt">Stack</span> (a <span class="fu">:</span> xs) }</a></code></pre></div>
<p>In fact, let’s make this as polymorphic as possible. We should be able to change the state is we so desire.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">0</span> <span class="fu">:-&gt;</span></a>
<a class="sourceLine" id="cb22-2" data-line-number="2"><span class="kw">type</span> (<span class="fu">:-&gt;</span>) xs ys <span class="fu">=</span> <span class="dt">Stack</span> xs <span class="ot">-&gt;</span> <span class="dt">Stack</span> ys</a></code></pre></div>
<p>And suddenly, our endomorphism type from above shows up again.</p>
<p>We can, of course, get back our original types.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">State</span> xs a <span class="fu">=</span> <span class="dt">State</span> {<span class="ot"> runState ::</span> xs <span class="fu">:-&gt;</span> a <span class="fu">:</span> xs }</a></code></pre></div>
<p>And it comes with all of the instances you might expect:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">State</span> xs) <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-2" data-line-number="2">    fmap f xs <span class="fu">=</span> <span class="dt">State</span> (\s <span class="ot">-&gt;</span> <span class="kw">case</span> runState xs s <span class="kw">of</span></a>
<a class="sourceLine" id="cb24-3" data-line-number="3">        (x <span class="fu">:-</span> ys) <span class="ot">-&gt;</span> f x <span class="fu">:-</span> ys)</a>
<a class="sourceLine" id="cb24-4" data-line-number="4">        </a>
<a class="sourceLine" id="cb24-5" data-line-number="5"><span class="kw">instance</span> <span class="dt">Applicative</span> (<span class="dt">State</span> xs) <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-6" data-line-number="6">    pure x <span class="fu">=</span> <span class="dt">State</span> (x <span class="fu">:-</span>)</a>
<a class="sourceLine" id="cb24-7" data-line-number="7">    fs <span class="fu">&lt;*&gt;</span> xs <span class="fu">=</span> <span class="dt">State</span> (\s <span class="ot">-&gt;</span> <span class="kw">case</span> runState fs s <span class="kw">of</span></a>
<a class="sourceLine" id="cb24-8" data-line-number="8">        (f <span class="fu">:-</span> s&#39;) <span class="ot">-&gt;</span> <span class="kw">case</span> runState xs s&#39; <span class="kw">of</span></a>
<a class="sourceLine" id="cb24-9" data-line-number="9">            (x <span class="fu">:-</span> s&#39;&#39;) <span class="ot">-&gt;</span> f x <span class="fu">:-</span> s&#39;&#39;)</a>
<a class="sourceLine" id="cb24-10" data-line-number="10">            </a>
<a class="sourceLine" id="cb24-11" data-line-number="11"><span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">State</span> xs) <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-12" data-line-number="12">    xs <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">State</span> (\s <span class="ot">-&gt;</span> <span class="kw">case</span> runState xs s <span class="kw">of</span></a>
<a class="sourceLine" id="cb24-13" data-line-number="13">        y <span class="fu">:-</span> ys <span class="ot">-&gt;</span> runState (f y) ys)</a></code></pre></div>
<h1 id="polymorphism">Polymorphism</h1>
<p>But what’s the point? So far we’ve basically just encoded an unnecessarily complicated state transformer. Think back to the stacking of states. Written in the <a href="https://hackage.haskell.org/package/mtl">mtl</a> style, the main advantage of stacking monads like that is you can write code like the following:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="ot">pop ::</span> (<span class="dt">MonadState</span> [a] m, <span class="dt">MonadError</span> <span class="dt">String</span> m) <span class="ot">=&gt;</span> m a</a>
<a class="sourceLine" id="cb25-2" data-line-number="2">pop <span class="fu">=</span> get <span class="fu">&gt;&gt;=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb25-3" data-line-number="3">    [] <span class="ot">-&gt;</span> throwError <span class="st">&quot;pop: empty list&quot;</span></a>
<a class="sourceLine" id="cb25-4" data-line-number="4">    x<span class="fu">:</span>xs <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb25-5" data-line-number="5">        put xs </a>
<a class="sourceLine" id="cb25-6" data-line-number="6">        pure x</a></code></pre></div>
<p>In other words, we don’t care about the rest of <code>m</code>, we just care that it has, somewhere, state for an <code>[a]</code>.</p>
<p>This logic should apply to our stack transformer, as well. If it only cares about the top two variables, it shouldn’t care what the rest of the list is. In types:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">0</span> <span class="fu">:-&gt;</span></a>
<a class="sourceLine" id="cb26-2" data-line-number="2"><span class="kw">type</span> (<span class="fu">:-&gt;</span>) xs ys <span class="fu">=</span> forall zs<span class="fu">.</span> <span class="dt">Stack</span> (xs <span class="fu">++</span> zs) <span class="ot">-&gt;</span> <span class="dt">Stack</span> (ys <span class="fu">++</span> zs)</a></code></pre></div>
<p>And straight away we can write some of the standard combinators:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="ot">dup ::</span> <span class="ch">&#39;[a] :-&gt; &#39;</span>[a,a]</a>
<a class="sourceLine" id="cb27-2" data-line-number="2">dup (x <span class="fu">:-</span> xs) <span class="fu">=</span> (x <span class="fu">:-</span> x <span class="fu">:-</span> xs)</a>
<a class="sourceLine" id="cb27-3" data-line-number="3"></a>
<a class="sourceLine" id="cb27-4" data-line-number="4"><span class="ot">swap ::</span> <span class="ch">&#39;[x,y] :-&gt; &#39;</span>[y,x]</a>
<a class="sourceLine" id="cb27-5" data-line-number="5">swap (x <span class="fu">:-</span> y <span class="fu">:-</span> xs) <span class="fu">=</span> y <span class="fu">:-</span> x <span class="fu">:-</span> xs</a>
<a class="sourceLine" id="cb27-6" data-line-number="6"></a>
<a class="sourceLine" id="cb27-7" data-line-number="7">drop<span class="ot"> ::</span> <span class="ch">&#39;[x,y] :-&gt; &#39;</span>[y]</a>
<a class="sourceLine" id="cb27-8" data-line-number="8">drop (_ <span class="fu">:-</span> xs) <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb27-9" data-line-number="9"></a>
<a class="sourceLine" id="cb27-10" data-line-number="10"><span class="kw">infixl</span> <span class="dv">9</span> <span class="fu">!</span></a>
<a class="sourceLine" id="cb27-11" data-line-number="11">(f <span class="fu">!</span> g) x <span class="fu">=</span> g (f x)</a></code></pre></div>
<p>You’ll immediately run into trouble if you try to work with some of the more involved combinators, though. Quote should have the following type, for instance:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1"><span class="ot">quote ::</span> (xs <span class="fu">:-&gt;</span> ys) <span class="ot">-&gt;</span> <span class="ch">&#39;[] :-&gt; &#39;</span>[ xs <span class="fu">:-&gt;</span> ys ]</a></code></pre></div>
<p>But GHC complains again:</p>
<pre><code>• Illegal polymorphic type: xs :-&gt; ys
  GHC doesn&#39;t yet support impredicative polymorphism
• In the type signature:
    quote :: (xs :-&gt; ys) -&gt; &#39;[] :-&gt; &#39;[xs :-&gt; ys]</code></pre>
<p>I won’t go into the detail of this particular error: if you’ve been around the block with Haskell you know that it means “wrap it in a newtype”. If we do <em>that</em>, though, we get yet more errors:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="kw">newtype</span> (<span class="fu">:~&gt;</span>) xs ys <span class="fu">=</span> <span class="dt">Q</span> {<span class="ot"> d ::</span> xs <span class="fu">:-&gt;</span> ys }</a></code></pre></div>
<pre><code>• Couldn&#39;t match type ‘ys ++ zs0’ with ‘ys ++ zs’
  Expected type: Stack (xs ++ zs) -&gt; Stack (ys ++ zs)
    Actual type: Stack (xs ++ zs0) -&gt; Stack (ys ++ zs0)
  NB: ‘++’ is a type function, and may not be injective</code></pre>
<p>This injectivity error comes up often. It means that GHC needs to prove that the input to two functions is equal, but it only knows that their outputs are. This is a doubly serious problem for us, as we can’t do type family injectivity on two type variables (in current Haskell). To solve the problem, we need to rely on a weird mishmash of type families and functional dependencies:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" data-line-number="1"><span class="kw">type</span> family (<span class="fu">++</span>) xs ys <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-2" data-line-number="2">    <span class="ch">&#39;[] ++ ys = ys</span></a>
<a class="sourceLine" id="cb32-3" data-line-number="3">    (x <span class="fu">:</span> xs) <span class="fu">++</span> ys <span class="fu">=</span> x <span class="fu">:</span> (xs <span class="fu">++</span> ys)</a>
<a class="sourceLine" id="cb32-4" data-line-number="4">    </a>
<a class="sourceLine" id="cb32-5" data-line-number="5"><span class="kw">class</span> (xs <span class="fu">++</span> ys <span class="fu">~</span> zs) <span class="ot">=&gt;</span> <span class="dt">Conc</span> xs ys zs <span class="fu">|</span> xs zs <span class="ot">-&gt;</span> ys <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-6" data-line-number="6"><span class="ot">    conc ::</span> <span class="dt">Stack</span> xs <span class="ot">-&gt;</span> <span class="dt">Stack</span> ys <span class="ot">-&gt;</span> <span class="dt">Stack</span> zs</a>
<a class="sourceLine" id="cb32-7" data-line-number="7">    </a>
<a class="sourceLine" id="cb32-8" data-line-number="8"><span class="kw">instance</span> <span class="dt">Conc</span> <span class="ch">&#39;[] ys ys where</span></a>
<a class="sourceLine" id="cb32-9" data-line-number="9">    conc _ ys <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb32-10" data-line-number="10">    </a>
<a class="sourceLine" id="cb32-11" data-line-number="11"><span class="kw">instance</span> <span class="dt">Conc</span> xs ys zs <span class="ot">=&gt;</span> <span class="dt">Conc</span> (x <span class="fu">:</span> xs) ys (x <span class="fu">:</span> zs) <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-12" data-line-number="12">    conc (x <span class="fu">:-</span> xs) ys <span class="fu">=</span> x <span class="fu">:-</span> conc xs ys</a>
<a class="sourceLine" id="cb32-13" data-line-number="13"></a>
<a class="sourceLine" id="cb32-14" data-line-number="14"><span class="kw">infixr</span> <span class="dv">0</span> <span class="fu">:-&gt;</span></a>
<a class="sourceLine" id="cb32-15" data-line-number="15"><span class="kw">type</span> (<span class="fu">:-&gt;</span>) xs ys <span class="fu">=</span> forall zs yszs<span class="fu">.</span> <span class="dt">Conc</span> ys zs yszs <span class="ot">=&gt;</span> <span class="dt">Stack</span> (xs <span class="fu">++</span> zs) <span class="ot">-&gt;</span> <span class="dt">Stack</span> yszs</a></code></pre></div>
<p>And it does indeed work:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" data-line-number="1">pure<span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="ch">&#39;[] :-&gt; &#39;</span>[a]</a>
<a class="sourceLine" id="cb33-2" data-line-number="2">pure <span class="fu">=</span> (<span class="fu">:-</span>)</a>
<a class="sourceLine" id="cb33-3" data-line-number="3"></a>
<a class="sourceLine" id="cb33-4" data-line-number="4"><span class="kw">newtype</span> (<span class="fu">:~&gt;</span>) xs ys <span class="fu">=</span> <span class="dt">Q</span> {<span class="ot"> d ::</span> xs <span class="fu">:-&gt;</span> ys }</a>
<a class="sourceLine" id="cb33-5" data-line-number="5"></a>
<a class="sourceLine" id="cb33-6" data-line-number="6"><span class="ot">quote ::</span> (xs <span class="fu">:-&gt;</span> ys) <span class="ot">-&gt;</span> <span class="ch">&#39;[] :-&gt; &#39;</span>[ xs <span class="fu">:~&gt;</span> ys ]</a>
<a class="sourceLine" id="cb33-7" data-line-number="7">quote x <span class="fu">=</span> pure (<span class="dt">Q</span> x)</a>
<a class="sourceLine" id="cb33-8" data-line-number="8"></a>
<a class="sourceLine" id="cb33-9" data-line-number="9"><span class="ot">dot ::</span> forall xs ys<span class="fu">.</span> ((xs <span class="fu">:~&gt;</span> ys) <span class="fu">:</span> xs) <span class="fu">:-&gt;</span> ys</a>
<a class="sourceLine" id="cb33-10" data-line-number="10">dot (x <span class="fu">:-</span> xs) <span class="fu">=</span> d x xs</a>
<a class="sourceLine" id="cb33-11" data-line-number="11"></a>
<a class="sourceLine" id="cb33-12" data-line-number="12"><span class="ot">true ::</span> (xs <span class="fu">:~&gt;</span> ys) <span class="fu">:</span> (xs <span class="fu">:~&gt;</span> ys) <span class="fu">:</span> xs <span class="fu">:-&gt;</span> ys</a>
<a class="sourceLine" id="cb33-13" data-line-number="13">true <span class="fu">=</span> swap <span class="fu">!</span> drop <span class="fu">!</span> dot</a>
<a class="sourceLine" id="cb33-14" data-line-number="14"></a>
<a class="sourceLine" id="cb33-15" data-line-number="15"><span class="ot">false ::</span> (xs <span class="fu">:~&gt;</span> ys) <span class="fu">:</span> (xs <span class="fu">:~&gt;</span> ys) <span class="fu">:</span> xs <span class="fu">:-&gt;</span> ys</a>
<a class="sourceLine" id="cb33-16" data-line-number="16">false <span class="fu">=</span> drop <span class="fu">!</span> dot</a>
<a class="sourceLine" id="cb33-17" data-line-number="17"></a>
<a class="sourceLine" id="cb33-18" data-line-number="18"><span class="ot">test ::</span> <span class="ch">&#39;[] :-&gt; &#39;</span>[ <span class="ch">&#39;[a] :~&gt; &#39;</span>[a,a] ]</a>
<a class="sourceLine" id="cb33-19" data-line-number="19">test <span class="fu">=</span> quote dup</a></code></pre></div>
<p>Interestingly, these combinators represent the monadic operations on state (<code>dot</code> = <code>join</code>, <code>pure</code> = <code>pure</code>, etc.)</p>
<p>And can we get the nicer composition of the function from the intro? Kind of:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" data-line-number="1">sumAdded <span class="fu">=</span> quote add <span class="fu">!</span> curry <span class="fu">!</span> dot <span class="fu">!</span> map <span class="fu">!</span> sum</a></code></pre></div>
<p>Here are some references for concatenative languages: <span class="citation" data-cites="okasaki_techniques_2002">Okasaki (<a href="#ref-okasaki_techniques_2002">2002</a>)</span>, <span class="citation" data-cites="purdy_big_2012">Purdy (<a href="#ref-purdy_big_2012">2012</a>)</span>, <span class="citation" data-cites="kerby_theory_2007">Kerby (<a href="#ref-kerby_theory_2007">2007</a>)</span>, <span class="citation" data-cites="okasaki_theoretical_2003">Okasaki (<a href="#ref-okasaki_theoretical_2003">2003</a>)</span>.</p>
<div id="refs" class="references">
<div id="ref-kerby_theory_2007">
<p>Kerby, Brent. 2007. “The Theory of Concatenative Combinators.” <a href="http://tunes.org/\%7Eiepos/joy.html">http://tunes.org/\%7Eiepos/joy.html</a>.</p>
</div>
<div id="ref-okasaki_techniques_2002">
<p>Okasaki, Chris. 2002. “Techniques for embedding postfix languages in Haskell.” In <em>Proceedings of the ACM SIGPLAN workshop on Haskell - Haskell ’02</em>, 105–113. Pittsburgh, Pennsylvania: ACM Press. doi:<a href="https://doi.org/10.1145/581690.581699">10.1145/581690.581699</a>. <a href="http://portal.acm.org/citation.cfm?doid=581690.581699" class="uri">http://portal.acm.org/citation.cfm?doid=581690.581699</a>.</p>
</div>
<div id="ref-okasaki_theoretical_2003">
<p>———. 2003. “THEORETICAL PEARLS: Flattening combinators: Surviving without parentheses.” <em>Journal of Functional Programming</em> 13 (4) (July): 815–822. doi:<a href="https://doi.org/10.1017/S0956796802004483">10.1017/S0956796802004483</a>. <a href="https://www.cambridge.org/core/journals/journal-of-functional-programming/article/theoretical-pearls/3E99993FE5464986AD94D292FF5EA275" class="uri">https://www.cambridge.org/core/journals/journal-of-functional-programming/article/theoretical-pearls/3E99993FE5464986AD94D292FF5EA275</a>.</p>
</div>
<div id="ref-purdy_big_2012">
<p>Purdy, Jon. 2012. “The Big Mud Puddle: Why Concatenative Programming Matters.” <em>The Big Mud Puddle</em>. <a href="https://evincarofautumn.blogspot.com/2012/02/why-concatenative-programming-matters.html" class="uri">https://evincarofautumn.blogspot.com/2012/02/why-concatenative-programming-matters.html</a>.</p>
</div>
</div>
]]></description>
    <pubDate>Sat, 11 May 2019 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2019-05-11-concatenative-free.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Some Tricks for List Manipulation</title>
    <link>https://doisinkidney.com/posts/2019-05-08-list-manipulation-tricks.html</link>
    <description><![CDATA[<div class="info">
    Posted on May  8, 2019
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<p>This post is a collection of some of the tricks I’ve learned for manipulating lists in Haskell. Each one starts with a puzzle: you should try the puzzle yourself before seeing the solution!</p>
<h1 id="the-tortoise-and-the-hare">The Tortoise and the Hare</h1>
<blockquote>
<p>How can you split a list in half, in one pass, without taking its length?</p>
</blockquote>
<p>This first one is a relatively well-known trick, but it occasionally comes in handy, so I thought I’d mention it. The naive way is as follows:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1">splitHalf xs <span class="fu">=</span> splitAt (length xs <span class="ot">`div`</span> <span class="dv">2</span>) xs</a></code></pre></div>
<p>But it’s unsatisfying: we have to traverse the list twice, and we’re taking its length (which is almost always a bad idea). Instead, we use the following function:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">splitHalf ::</span> [a] <span class="ot">-&gt;</span> ([a],[a])</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">splitHalf xs <span class="fu">=</span> go xs xs</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">    go (y<span class="fu">:</span>ys) (_<span class="fu">:</span>_<span class="fu">:</span>zs) <span class="fu">=</span> first (y<span class="fu">:</span>) (go ys zs)</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">    go ys _ <span class="fu">=</span> ([],ys)</a></code></pre></div>
<p>The “tortoise and the hare” is the two arguments to <code>go</code>: it traverses the second one twice as fast, so when it hits the end, we know that the first list must be halfway done.</p>
<h1 id="there-and-back-again">There and Back Again</h1>
<blockquote>
<p>Given two lists, <code>xs</code> and <code>ys</code>, write a function which zips <code>xs</code> with the <em>reverse</em> of <code>ys</code> (in one pass).</p>
</blockquote>
<p>There’s a lovely paper <span class="citation" data-cites="danvy_there_2005">(Danvy and Goldberg <a href="#ref-danvy_there_2005">2005</a>)</span> which goes though a number of tricks for how to do certain list manipulations “in reverse”. Their technique is known as “there and back again”. However, I’d like to describe a different way to get to the same technique, using folds.</p>
<p>Whenever I need to do some list manipulation in reverse (i.e., I need the input list to be reversed), I first see if I can rewrite the function as a fold, and then just switch out <code>foldr</code> for <code>foldl</code>.</p>
<p>For our puzzle here, we need to first write <code>zip</code> as a fold:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1">zip<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a,b)]</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">zip <span class="fu">=</span> foldr f b</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">    f x k (y<span class="fu">:</span>ys) <span class="fu">=</span> (x,y) <span class="fu">:</span> k ys</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">    f x k [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">    b _ <span class="fu">=</span> []</a></code></pre></div>
<p>If that looks complex, or difficult to write, don’t worry! There’s a systematic way to get to the above definition from the normal version of <code>zip</code>. First, let’s start with a normal <code>zip</code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">zip<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a,b)]</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">zip [] ys <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">zip xs [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">zip (x<span class="fu">:</span>xs) (y<span class="fu">:</span>ys) <span class="fu">=</span> (x,y) <span class="fu">:</span> zip xs ys</a></code></pre></div>
<p>Then, we need to turn it into a case-tree, where the first branch is on the list we want to fold over. In other words, we want the function to look like this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1">zip xs <span class="fu">=</span> <span class="kw">case</span> xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">  <span class="fu">???</span></a></code></pre></div>
<p>To figure out the cases, we factor out the cases in the original function. Since the second clause (<code>zip xs [] = []</code>) is only reachable when <code>xs /= []</code>, it’s effectively a case for the <code>x:xs</code> branch.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1">zip<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a,b)]</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">zip xs <span class="fu">=</span> <span class="kw">case</span> xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">    [] <span class="ot">-&gt;</span> \_ <span class="ot">-&gt;</span> []</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">    x<span class="fu">:</span>xs <span class="ot">-&gt;</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">        [] <span class="ot">-&gt;</span> []</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">        y<span class="fu">:</span>ys <span class="ot">-&gt;</span> (x,y) <span class="fu">:</span> zip xs ys</a></code></pre></div>
<p>Now, we rewrite the different cases to be auxiliary functions:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1">zip<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a,b)]</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">zip xs <span class="fu">=</span> <span class="kw">case</span> xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">    [] <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">    x<span class="fu">:</span>xs <span class="ot">-&gt;</span> f x xs</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6">    b <span class="fu">=</span> \_ <span class="ot">-&gt;</span> []</a>
<a class="sourceLine" id="cb7-7" data-line-number="7">    f <span class="fu">=</span> \x xs <span class="ot">-&gt;</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb7-8" data-line-number="8">        [] <span class="ot">-&gt;</span> []</a>
<a class="sourceLine" id="cb7-9" data-line-number="9">        y<span class="fu">:</span>ys <span class="ot">-&gt;</span> (x,y) <span class="fu">:</span> zip xs ys</a></code></pre></div>
<p>And finally, we <em>refactor</em> the recursive call to the first case expression.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">zip<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a,b)]</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">zip xs <span class="fu">=</span> <span class="kw">case</span> xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">    [] <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">    x<span class="fu">:</span>xs <span class="ot">-&gt;</span> f x (zip xs)</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">    b <span class="fu">=</span> \_ <span class="ot">-&gt;</span> []</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">    f <span class="fu">=</span> \x xs <span class="ot">-&gt;</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8">        [] <span class="ot">-&gt;</span> []</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">        y<span class="fu">:</span>ys <span class="ot">-&gt;</span> (x,y) <span class="fu">:</span> xs ys</a></code></pre></div>
<p>Then those two auxiliary functions are what you pass to <code>foldr</code>!</p>
<p>So, to reverse it, we simply take wherever we wrote <code>foldr f b</code>, and replace it with <code>foldl (flip f) b</code>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">zipRev ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a,b)]</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">zipRev <span class="fu">=</span> foldl (flip f) b</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4">    f x k (y<span class="fu">:</span>ys) <span class="fu">=</span> (x,y) <span class="fu">:</span> k ys</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">    f x k [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb9-6" data-line-number="6">    b _ <span class="fu">=</span> []</a></code></pre></div>
<p>Of course, we’re reversing the wrong list here. Fixing that is simple:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">zipRev ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a,b)]</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">zipRev <span class="fu">=</span> flip (foldl (flip f) b)</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4">    f y k (x<span class="fu">:</span>xs) <span class="fu">=</span> (x,y) <span class="fu">:</span> k xs</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">    f y k [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb10-6" data-line-number="6">    b _ <span class="fu">=</span> []</a></code></pre></div>
<h1 id="maintaining-laziness">Maintaining Laziness</h1>
<blockquote>
<p>Rewrite the above function without using continuations.</p>
</blockquote>
<p><code>zipRev</code>, as written above, actually uses <em>continuation-passing style</em>. In most languages (including standard ML, which was the one used in <span class="citation" data-cites="danvy_there_2005">Danvy and Goldberg (<a href="#ref-danvy_there_2005">2005</a>)</span>), this is pretty much equivalent to a direct-style implementation (modulo some performance weirdness). In a lazy language like Haskell, though, continuation-passing style often makes things unnecessarily strict.</p>
<p>Consider the church-encoded pairs:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Pair</span> a b</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Pair</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">    {<span class="ot"> runPair ::</span> forall c<span class="fu">.</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> c</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">    }</a>
<a class="sourceLine" id="cb11-5" data-line-number="5">    </a>
<a class="sourceLine" id="cb11-6" data-line-number="6"><span class="ot">firstC ::</span> (a <span class="ot">-&gt;</span> a&#39;) <span class="ot">-&gt;</span> <span class="dt">Pair</span> a b <span class="ot">-&gt;</span> <span class="dt">Pair</span> a&#39; b</a>
<a class="sourceLine" id="cb11-7" data-line-number="7">firstC f p <span class="fu">=</span> <span class="dt">Pair</span> (\k <span class="ot">-&gt;</span> runPair p (k <span class="fu">.</span> f))</a>
<a class="sourceLine" id="cb11-8" data-line-number="8"></a>
<a class="sourceLine" id="cb11-9" data-line-number="9"><span class="ot">firstD ::</span> (a <span class="ot">-&gt;</span> a&#39;) <span class="ot">-&gt;</span> (a, b) <span class="ot">-&gt;</span> (a&#39;, b)</a>
<a class="sourceLine" id="cb11-10" data-line-number="10">firstD f <span class="fu">~</span>(x,y) <span class="fu">=</span> (f x, y)</a>
<a class="sourceLine" id="cb11-11" data-line-number="11"></a>
<a class="sourceLine" id="cb11-12" data-line-number="12"><span class="ot">fstD ::</span> (a, b) <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb11-13" data-line-number="13">fstD <span class="fu">~</span>(x,y) <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb11-14" data-line-number="14"></a>
<a class="sourceLine" id="cb11-15" data-line-number="15"><span class="ot">fstC ::</span> <span class="dt">Pair</span> a b <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb11-16" data-line-number="16">fstC p <span class="fu">=</span> runPair p const</a>
<a class="sourceLine" id="cb11-17" data-line-number="17"></a>
<a class="sourceLine" id="cb11-18" data-line-number="18"><span class="fu">&gt;&gt;&gt;</span> fstC (firstC (const ()) undefined)</a>
<a class="sourceLine" id="cb11-19" data-line-number="19">undefined</a>
<a class="sourceLine" id="cb11-20" data-line-number="20"></a>
<a class="sourceLine" id="cb11-21" data-line-number="21"><span class="fu">&gt;&gt;&gt;</span> fstD (firstD (const ()) undefined)</a>
<a class="sourceLine" id="cb11-22" data-line-number="22">()</a></code></pre></div>
<p>So it’s sometimes worth trying to avoid continuations if there is a fast direct-style solution. (alternatively, continuations can give you extra strictness when you <em>do</em> want it)</p>
<p>First, I’m going to write a different version of <code>zipRev</code>, which folds on the first list, not the second.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1">zipRev xs ys <span class="fu">=</span> foldl f (\_ r <span class="ot">-&gt;</span> r) xs ys []</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">    f k x (y<span class="fu">:</span>ys) r <span class="fu">=</span> k ys ((x,y)<span class="fu">:</span>r)</a></code></pre></div>
<p>Then, we inline the definition of <code>foldl</code>:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1">zipRev xs ys <span class="fu">=</span> foldr f id xs (\_ r <span class="ot">-&gt;</span> r) ys []</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">    f x k c <span class="fu">=</span> k (\(y<span class="fu">:</span>ys) r <span class="ot">-&gt;</span> c ys ((x,y)<span class="fu">:</span>r)) </a></code></pre></div>
<p>Then, as a hint, we tuple up the two accumulating parameters:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1">zipRev xs ys <span class="fu">=</span> foldr f id xs snd (ys,[])</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3">    f x k c <span class="fu">=</span> k (\((y<span class="fu">:</span>ys),r) <span class="ot">-&gt;</span> c (ys,(x,y)<span class="fu">:</span>r)) </a></code></pre></div>
<p>What we can see here is that we have two continuations stacked on top of each other. When this happens, they can often “cancel out”, like so:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1">zipRev xs ys <span class="fu">=</span> snd (foldr f (ys,[]) xs)</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-3" data-line-number="3">    f x (y<span class="fu">:</span>ys,r) <span class="fu">=</span> (ys,(x,y)<span class="fu">:</span>r)</a></code></pre></div>
<p>And we have our direct-style implementation!</p>
<p>Note 14/05/2019: the “cancel-out” explanation there is a little handwavy, as I’m sure you’ll notice. However, there are a number of <a href="https://stackoverflow.com/questions/56122022/how-can-two-continuations-cancel-each-other-out">excellent explanations on this stackoverflow thread</a> which explain it much better than I ever could. Thanks to Anders Kaseorg, Will Ness, user11228628, and to Joseph Sible <span class="citation" data-cites="sible_how_2019">(<a href="#ref-sible_how_2019">2019</a>)</span> for asking the question.</p>
<h1 id="manual-fusion">Manual Fusion</h1>
<blockquote>
<p>Detect that a list is a palindrome, in one pass.</p>
</blockquote>
<p>We now know a good way to split a list in two, and a good way to zip a list with its reverse. We can <em>combine</em> the two to get a program that checks if a list is a palindrome. Here’s a first attempt:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1">isPal xs <span class="fu">=</span> all (uncurry (<span class="fu">==</span>)) (uncurry zipRev (splitHalf xs))</a></code></pre></div>
<p>But this is doing <em>three</em> passes!</p>
<p>To get around it, we can manually do some fusion. Fusion is a technique where we can spot scenarios like the following:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1">foldr f b (x <span class="fu">:</span> y <span class="fu">:</span> [])</a></code></pre></div>
<p>And translate them into a version without a list:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1">x <span class="ot">`f`</span> (y <span class="ot">`f`</span> b)</a></code></pre></div>
<p>The trick is making sure that the consumer is written as a fold, and then we just put its <code>f</code> and <code>b</code> in place of the <code>:</code> and <code>[]</code> in the producer.</p>
<p>So, when we inline the definition of <code>splitHalf</code> into <code>zipRev</code>, we get the following:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="ot">zipRevHalf ::</span> [a] <span class="ot">-&gt;</span> [(a,a)]</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">zipRevHalf xs <span class="fu">=</span> snd (go xs xs)</a>
<a class="sourceLine" id="cb19-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-4" data-line-number="4">    go (y<span class="fu">:</span>ys) (_<span class="fu">:</span>_<span class="fu">:</span>zs) <span class="fu">=</span> f y (go ys zs)</a>
<a class="sourceLine" id="cb19-5" data-line-number="5">    go (_<span class="fu">:</span>ys) [_]      <span class="fu">=</span> (ys,[])</a>
<a class="sourceLine" id="cb19-6" data-line-number="6">    go ys []           <span class="fu">=</span> (ys,[])</a>
<a class="sourceLine" id="cb19-7" data-line-number="7"></a>
<a class="sourceLine" id="cb19-8" data-line-number="8">    f x (y<span class="fu">:</span>ys,r) <span class="fu">=</span> (ys,(x,y)<span class="fu">:</span>r)</a>
<a class="sourceLine" id="cb19-9" data-line-number="9"></a>
<a class="sourceLine" id="cb19-10" data-line-number="10">isPal xs <span class="fu">=</span> all (uncurry (<span class="fu">==</span>)) (zipRevHalf xs)</a></code></pre></div>
<p>(adding a special case for odd-length lists)</p>
<p>Finally, the <code>all (uncurry (==))</code> is implemented as a fold also. So we can fuse it with the rest of the definitions:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="ot">isPal ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2">isPal xs <span class="fu">=</span> snd (go xs xs)</a>
<a class="sourceLine" id="cb20-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-4" data-line-number="4">    go (y<span class="fu">:</span>ys) (_<span class="fu">:</span>_<span class="fu">:</span>zs) <span class="fu">=</span> f y (go ys zs)</a>
<a class="sourceLine" id="cb20-5" data-line-number="5">    go (_<span class="fu">:</span>ys) [_]      <span class="fu">=</span> (ys,<span class="dt">True</span>)</a>
<a class="sourceLine" id="cb20-6" data-line-number="6">    go ys     []       <span class="fu">=</span> (ys,<span class="dt">True</span>)</a>
<a class="sourceLine" id="cb20-7" data-line-number="7">    </a>
<a class="sourceLine" id="cb20-8" data-line-number="8">    f x (y<span class="fu">:</span>ys,r) <span class="fu">=</span> (ys,(x <span class="fu">==</span> y) <span class="fu">&amp;&amp;</span> r)</a></code></pre></div>
<p>You may have spotted the writer monad over <code>All</code> there. Indeed, we can rewrite it to use the monadic bind:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="ot">isPal ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb21-2" data-line-number="2">isPal xs <span class="fu">=</span> getAll (fst (go xs xs)) <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-3" data-line-number="3">  go (y<span class="fu">:</span>ys) (_<span class="fu">:</span>_<span class="fu">:</span>zs) <span class="fu">=</span> f y <span class="fu">=&lt;&lt;</span> go ys zs</a>
<a class="sourceLine" id="cb21-4" data-line-number="4">  go (_<span class="fu">:</span>ys) [_]      <span class="fu">=</span> pure ys</a>
<a class="sourceLine" id="cb21-5" data-line-number="5">  go ys     []       <span class="fu">=</span> pure ys</a>
<a class="sourceLine" id="cb21-6" data-line-number="6">  </a>
<a class="sourceLine" id="cb21-7" data-line-number="7">  f y (z<span class="fu">:</span>zs) <span class="fu">=</span> (<span class="dt">All</span> (y <span class="fu">==</span> z), zs)</a></code></pre></div>
<h1 id="eliminating-multiple-passes-with-laziness">Eliminating Multiple Passes with Laziness</h1>
<blockquote>
<p>Construct a Braun tree from a list in linear time.</p>
</blockquote>
<p>This is also a very well-known trick <span class="citation" data-cites="bird_using_1984">(Bird <a href="#ref-bird_using_1984">1984</a>)</span>, but today I’m going to use it to write a function for constructing Braun trees.</p>
<p>A Braun tree is a peculiar structure. It’s a binary tree, where adjacent branches can differ in size by only 1. When used as an array, it has <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math> lookup times. It’s enumerated like so:</p>
<pre><code>     ┌─7
   ┌3┤
   │ └11
 ┌1┤
 │ │ ┌─9
 │ └5┤
 │   └13
0┤
 │   ┌─8
 │ ┌4┤
 │ │ └12
 └2┤
   │ ┌10
   └6┤
     └14</code></pre>
<p>The objective is to construct a tree from a list in linear time, in the order defined above. <span class="citation" data-cites="okasaki_three_1997">Okasaki (<a href="#ref-okasaki_three_1997">1997</a>)</span> observed that, from the list:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1">[<span class="dv">0</span><span class="fu">..</span><span class="dv">14</span>]</a></code></pre></div>
<p>Each level in the tree is constructed from chucks of powers of two. In other words:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1">[[<span class="dv">0</span>],[<span class="dv">1</span>,<span class="dv">2</span>],[<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>],[<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>,<span class="dv">11</span>,<span class="dv">12</span>,<span class="dv">13</span>,<span class="dv">14</span>]]</a></code></pre></div>
<p>From this, we can write the following function:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1">rows k [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb25-2" data-line-number="2">rows k xs <span class="fu">=</span> (k , take k xs) <span class="fu">:</span> rows (<span class="dv">2</span><span class="fu">*</span>k) (drop k xs)</a>
<a class="sourceLine" id="cb25-3" data-line-number="3"></a>
<a class="sourceLine" id="cb25-4" data-line-number="4">build (k,xs) ts <span class="fu">=</span> zipWith3 <span class="dt">Node</span> xs ts1 ts2</a>
<a class="sourceLine" id="cb25-5" data-line-number="5">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-6" data-line-number="6">    (ts1,ts2) <span class="fu">=</span> splitAt k (ts <span class="fu">++</span> repeat <span class="dt">Leaf</span>)</a>
<a class="sourceLine" id="cb25-7" data-line-number="7">    </a>
<a class="sourceLine" id="cb25-8" data-line-number="8">fromList <span class="fu">=</span> head <span class="fu">.</span> foldr build [<span class="dt">Leaf</span>] <span class="fu">.</span> rows <span class="dv">1</span></a></code></pre></div>
<p>The first place we’ll look to eliminate a pass is the <code>build</code> function. It combines two rows by splitting the second in half, and zipping it with the first.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> build (<span class="dv">3</span>, [x1,x2,x3]) [y1,y2,y3,y4,y5,y6]</a>
<a class="sourceLine" id="cb26-2" data-line-number="2">[(x1,y1,y4),(x2,y2,y5),(x3,y3,y6)]</a></code></pre></div>
<p>We don’t need to store the length of the first list, though, as we are only using it to split the second, and we can do <em>that</em> at the same time as the zipping.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="ot">zipUntil ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> ([c],[b])</a>
<a class="sourceLine" id="cb27-2" data-line-number="2">zipUntil _ [] ys <span class="fu">=</span> ([],ys)</a>
<a class="sourceLine" id="cb27-3" data-line-number="3">zipUntil f (x<span class="fu">:</span>xs) (y<span class="fu">:</span>ys) <span class="fu">=</span> first (f x y<span class="fu">:</span>) (zipUntil f xs ys)</a>
<a class="sourceLine" id="cb27-4" data-line-number="4"></a>
<a class="sourceLine" id="cb27-5" data-line-number="5"><span class="fu">&gt;&gt;&gt;</span> zipUntil (,) [<span class="dv">1</span>,<span class="dv">2</span>] <span class="st">&quot;abc&quot;</span></a>
<a class="sourceLine" id="cb27-6" data-line-number="6">([(<span class="dv">1</span>,<span class="ch">&#39;a&#39;</span>),(<span class="dv">2</span>,<span class="ch">&#39;b&#39;</span>)],<span class="st">&quot;c&quot;</span>)</a></code></pre></div>
<p>Using this function in <code>build</code> looks like the following:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1">build (k,xs) ts <span class="fu">=</span> zipWith (<span class="fu">$</span>) ys ts2</a>
<a class="sourceLine" id="cb28-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb28-3" data-line-number="3">    (ys,ts2) <span class="fu">=</span> zipUntil <span class="dt">Node</span> xs (ts <span class="fu">++</span> repeat <span class="dt">Leaf</span>)</a></code></pre></div>
<p>That top-level <code>zipWith</code> is <em>also</em> unnecessary, though. If we make the program circular, we can produce <code>ts2</code> as we consume it, making the whole thing single-pass.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" data-line-number="1">build xs ts <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb29-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb29-3" data-line-number="3">    (ys,ts2) <span class="fu">=</span> zip3Node xs (ts <span class="fu">++</span> repeat <span class="dt">Leaf</span>) ts2</a>
<a class="sourceLine" id="cb29-4" data-line-number="4">    zip3Node (x<span class="fu">:</span>xs) (y<span class="fu">:</span>ys) <span class="fu">~</span>(z<span class="fu">:</span>zs) <span class="fu">=</span> first (<span class="dt">Node</span> x y z<span class="fu">:</span>) (zip3Node xs ys zs) </a>
<a class="sourceLine" id="cb29-5" data-line-number="5">    zip3Node [] ys _ <span class="fu">=</span> ([], ys)</a></code></pre></div>
<p>That <code>zip3Node</code> is a good candidate for rewriting as a fold, also, making the whole thing look like this:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" data-line-number="1">rows k [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb30-2" data-line-number="2">rows k xs <span class="fu">=</span> take k xs <span class="fu">:</span> rows (<span class="dv">2</span><span class="fu">*</span>k) (drop k xs)</a>
<a class="sourceLine" id="cb30-3" data-line-number="3"></a>
<a class="sourceLine" id="cb30-4" data-line-number="4">build xs ts <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb30-5" data-line-number="5">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-6" data-line-number="6">    (ys,zs) <span class="fu">=</span> foldr f b xs ts zs</a>
<a class="sourceLine" id="cb30-7" data-line-number="7">    f x xs (y<span class="fu">:</span>ys) <span class="fu">~</span>(z<span class="fu">:</span>zs) <span class="fu">=</span> first (<span class="dt">Node</span> x y z<span class="fu">:</span>) (xs ys zs) </a>
<a class="sourceLine" id="cb30-8" data-line-number="8">    b ys _ <span class="fu">=</span> ([],ys)</a>
<a class="sourceLine" id="cb30-9" data-line-number="9">    </a>
<a class="sourceLine" id="cb30-10" data-line-number="10">fromList <span class="fu">=</span> head <span class="fu">.</span> foldr build (repeat <span class="dt">Leaf</span>) <span class="fu">.</span> rows <span class="dv">1</span></a></code></pre></div>
<p>To fuse all of those definitions, we first will need to rewrite <code>rows</code> as a fold:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" data-line-number="1">rows xs <span class="fu">=</span> uncurry (<span class="fu">:</span>) (foldr f b xs <span class="dv">1</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb31-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb31-3" data-line-number="3">    b _ _ <span class="fu">=</span> ([],[])</a>
<a class="sourceLine" id="cb31-4" data-line-number="4">    f x k <span class="dv">0</span> j <span class="fu">=</span> ([], uncurry (<span class="fu">:</span>) (f x k j (j<span class="fu">*</span><span class="dv">2</span>)))</a>
<a class="sourceLine" id="cb31-5" data-line-number="5">    f x k i j <span class="fu">=</span> first (x<span class="fu">:</span>) (k (i<span class="fu">-</span><span class="dv">1</span>) j)</a></code></pre></div>
<p>Once we have everything as a fold, the rest of the transformation is pretty mechanical. At the end of it all, we get the following linear-time function for constructing a Braun tree from a list:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" data-line-number="1"><span class="ot">fromList ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb32-2" data-line-number="2">fromList xs <span class="fu">=</span> head (l (foldr f b xs <span class="dv">1</span> <span class="dv">2</span>))</a>
<a class="sourceLine" id="cb32-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-4" data-line-number="4">    b _ _ ys zs <span class="fu">=</span> (repeat <span class="dt">Leaf</span>, (repeat <span class="dt">Leaf</span>, ys))</a>
<a class="sourceLine" id="cb32-5" data-line-number="5">    </a>
<a class="sourceLine" id="cb32-6" data-line-number="6">    l k <span class="fu">=</span> <span class="kw">let</span> (xs, ys) <span class="fu">=</span> uncurry k ys <span class="kw">in</span> xs</a>
<a class="sourceLine" id="cb32-7" data-line-number="7">    </a>
<a class="sourceLine" id="cb32-8" data-line-number="8">    f x k <span class="dv">0</span> j ys zs           <span class="fu">=</span> ([], (l (f x k j (j<span class="fu">*</span><span class="dv">2</span>)), ys))</a>
<a class="sourceLine" id="cb32-9" data-line-number="9">    f x k i j <span class="fu">~</span>(y<span class="fu">:</span>ys) <span class="fu">~</span>(z<span class="fu">:</span>zs) <span class="fu">=</span> first (<span class="dt">Node</span> x y z<span class="fu">:</span>) (k (i<span class="fu">-</span><span class="dv">1</span>) j ys zs)</a></code></pre></div>
<h1 id="references" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-bird_using_1984">
<p>Bird, R. S. 1984. “Using Circular Programs to Eliminate Multiple Traversals of Data.” <em>Acta Inf.</em> 21 (3) (October): 239–250. doi:<a href="https://doi.org/10.1007/BF00264249">10.1007/BF00264249</a>. <a href="http://dx.doi.org/10.1007/BF00264249" class="uri">http://dx.doi.org/10.1007/BF00264249</a>.</p>
</div>
<div id="ref-danvy_there_2005">
<p>Danvy, Olivier, and Mayer Goldberg. 2005. “There and Back Again.” <em>BRICS Report Series</em> 12 (3). doi:<a href="https://doi.org/10.7146/brics.v12i3.21869">10.7146/brics.v12i3.21869</a>. <a href="https://tidsskrift.dk/brics/article/view/21869" class="uri">https://tidsskrift.dk/brics/article/view/21869</a>.</p>
</div>
<div id="ref-okasaki_three_1997">
<p>Okasaki, Chris. 1997. “Three Algorithms on Braun Trees.” <em>Journal of Functional Programming</em> 7 (6) (November): 661–666. doi:<a href="https://doi.org/10.1017/S0956796897002876">10.1017/S0956796897002876</a>. <a href="https://www.eecs.northwestern.edu/~robby/courses/395-495-2013-fall/three-algorithms-on-braun-trees.pdf" class="uri">https://www.eecs.northwestern.edu/~robby/courses/395-495-2013-fall/three-algorithms-on-braun-trees.pdf</a>.</p>
</div>
<div id="ref-sible_how_2019">
<p>Sible, Joseph. 2019. “How can two continuations cancel each other out?” <em>Stack Overflow</em>. <a href="https://stackoverflow.com/questions/56122022/how-can-two-continuations-cancel-each-other-out" class="uri">https://stackoverflow.com/questions/56122022/how-can-two-continuations-cancel-each-other-out</a>.</p>
</div>
</div>
]]></description>
    <pubDate>Wed, 08 May 2019 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2019-05-08-list-manipulation-tricks.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Probability Monads in Cubical Agda</title>
    <link>https://doisinkidney.com/posts/2019-04-17-cubical-probability.html</link>
    <description><![CDATA[<div class="info">
    Posted on April 17, 2019
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Agda.html">Agda</a>, <a href="/tags/Probability.html">Probability</a>
    
</div>

<p><a href="https://agda.readthedocs.io/en/latest/language/cubical.html">Cubical Agda</a> has just come out, and I’ve been playing around with it for a bit. There’s a bunch of info out there on the theory of cubical types, and Homotopy Type Theory more generally (cubical type theory is kind of like an “implementation” of Homotopy type theory), but I wanted to make a post demonstrating cubical Agda in practice, and one of its cool uses from a programming perspective.</p>
<h1 id="so-what-is-cubical-agda">So What is Cubical Agda?</h1>
<p>I don’t really know! Cubical type theory is quite complex (even for a type theory), and I’m not nearly qualified to properly explain it. In lieu of a proper first-principles explanation, then, I’ll try and give a few examples of how it differs from normal Agda, before moving on to the main example of this post.</p>
<details>
<summary>Imports</summary>
<pre class="Agda"><a id="920" class="Symbol">{-#</a> <a id="924" class="Keyword">OPTIONS</a> <a id="932" class="Pragma">--cubical</a> <a id="942" class="Symbol">#-}</a>

<a id="947" class="Keyword">open</a> <a id="952" class="Keyword">import</a> <a id="959" href="../code/probability/ProbabilityModule.Semirings.html" class="Module">ProbabilityModule.Semirings</a>

<a id="988" class="Keyword">module</a> <a id="995" href="" class="Module">ProbabilityModule.Monad</a> <a id="1019" class="Symbol">{</a><a id="1020" href="#1020" class="Bound">s</a><a id="1021" class="Symbol">}</a> <a id="1023" class="Symbol">(</a><a id="1024" href="#1024" class="Bound">rng</a> <a id="1028" class="Symbol">:</a> <a id="1030" href="../code/probability/ProbabilityModule.Semirings.html#125" class="Record">Semiring</a> <a id="1039" href="#1020" class="Bound">s</a><a id="1040" class="Symbol">)</a> <a id="1042" class="Keyword">where</a>

<a id="1049" class="Keyword">open</a> <a id="1054" class="Keyword">import</a> <a id="1061" href="../code/probability/Cubical.Core.Everything.html" class="Module">Cubical.Core.Everything</a>
<a id="1085" class="Keyword">open</a> <a id="1090" class="Keyword">import</a> <a id="1097" href="../code/probability/Cubical.Relation.Everything.html" class="Module">Cubical.Relation.Everything</a>
<a id="1125" class="Keyword">open</a> <a id="1130" class="Keyword">import</a> <a id="1137" href="../code/probability/Cubical.Foundations.Prelude.html" class="Module">Cubical.Foundations.Prelude</a> <a id="1165" class="Keyword">hiding</a> <a id="1172" class="Symbol">(</a><a id="1173" href="../code/probability/Cubical.Foundations.Prelude.html#2539" class="Function Operator">_≡⟨_⟩_</a><a id="1179" class="Symbol">)</a> <a id="1181" class="Keyword">renaming</a> <a id="1190" class="Symbol">(</a><a id="1191" href="../code/probability/Cubical.Foundations.Prelude.html#1674" class="Function Operator">_∙_</a> <a id="1195" class="Symbol">to</a> <a id="1198" href="../code/probability/Cubical.Foundations.Prelude.html#1674" class="Function Operator">_;_</a><a id="1201" class="Symbol">)</a>
<a id="1203" class="Keyword">open</a> <a id="1208" class="Keyword">import</a> <a id="1215" href="../code/probability/Cubical.HITs.SetTruncation.html" class="Module">Cubical.HITs.SetTruncation</a>
<a id="1242" class="Keyword">open</a> <a id="1247" class="Keyword">import</a> <a id="1254" href="../code/probability/ProbabilityModule.Utils.html" class="Module">ProbabilityModule.Utils</a>
</pre>
</details>
<dl>
<dt>Extensionality</dt>
<dd>One of the big annoyances in standard Agda is that we can’t prove the following:
<pre class="Agda"><a id="extensionality"></a><a id="1407" href="#1407" class="Function">extensionality</a> <a id="1422" class="Symbol">:</a> <a id="1424" class="Symbol">∀</a> <a id="1426" class="Symbol">{</a><a id="1427" href="#1427" class="Bound">f</a> <a id="1429" href="#1429" class="Bound">g</a> <a id="1431" class="Symbol">:</a> <a id="1433" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="1435" class="Symbol">→</a> <a id="1437" href="../code/probability/ProbabilityModule.Utils.html#206" class="Generalizable">B</a><a id="1438" class="Symbol">}</a>
           <a id="1455" class="Symbol">→</a> <a id="1457" class="Symbol">(∀</a> <a id="1460" href="#1460" class="Bound">x</a> <a id="1462" class="Symbol">→</a> <a id="1464" href="#1427" class="Bound">f</a> <a id="1466" href="#1460" class="Bound">x</a> <a id="1468" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">≡</a> <a id="1470" href="#1429" class="Bound">g</a> <a id="1472" href="#1460" class="Bound">x</a><a id="1473" class="Symbol">)</a>
           <a id="1490" class="Symbol">→</a> <a id="1492" href="#1427" class="Bound">f</a> <a id="1494" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">≡</a> <a id="1496" href="#1429" class="Bound">g</a>
</pre>
It’s emblematic of a wider problem in Agda: we can’t say “two things are equal if they always behave the same”. Infinite types, for instance (like streams) are often only equal via bisimulation: we can’t translate this into normal equality in standard Agda. Cubical type theory, though, has a different notion of “equality”, which allow a wide variety of things (including bisimulations and extensional proofs) to be translated into a proper equality
<pre class="Agda"><a id="1989" href="#1407" class="Function">extensionality</a> <a id="2004" class="Symbol">=</a> <a id="2006" href="../code/probability/Cubical.Foundations.Prelude.html#4401" class="Function">funExt</a>
</pre>
</dd>
<dt>Isomorphisms</dt>
<dd>One of these such things we can promote to a “proper equality” is an isomorphism. In the <a href="https://github.com/agda/cubical">cubical repo</a> this is used to <a href="https://github.com/agda/cubical/blob/8391a4835b3d2478e9394c6c3ec7e6fff42ede62/Cubical/Data/BinNat/BinNat.agda">prove things about binary numbers</a>: by proving that there’s an isomorphism between the Peano numbers and binary numbers, they can lift any properties on the Peano numbers to the binary numbers.
</dd>
</dl>
<p>So those are two useful examples, but the <em>most</em> interesting use I’ve seen so far is the following:</p>
<h1 id="higher-inductive-types">Higher Inductive Types</h1>
Higher Inductive Types are an extension of normal inductive types, like the list:
<pre class="Agda"><a id="2741" class="Keyword">module</a> <a id="NormalList"></a><a id="2748" href="#2748" class="Module">NormalList</a> <a id="2759" class="Keyword">where</a>
 <a id="2766" class="Keyword">data</a> <a id="NormalList.List"></a><a id="2771" href="#2771" class="Datatype">List</a> <a id="2776" class="Symbol">{</a><a id="2777" href="#2777" class="Bound">a</a><a id="2778" class="Symbol">}</a> <a id="2780" class="Symbol">(</a><a id="2781" href="#2781" class="Bound">A</a> <a id="2783" class="Symbol">:</a> <a id="2785" class="PrimitiveType">Set</a> <a id="2789" href="#2777" class="Bound">a</a><a id="2790" class="Symbol">)</a> <a id="2792" class="Symbol">:</a> <a id="2794" class="PrimitiveType">Set</a> <a id="2798" href="#2777" class="Bound">a</a> <a id="2800" class="Keyword">where</a>
   <a id="NormalList.List.[]"></a><a id="2809" href="#2809" class="InductiveConstructor">[]</a> <a id="2812" class="Symbol">:</a> <a id="2814" href="#2771" class="Datatype">List</a> <a id="2819" href="#2781" class="Bound">A</a>
   <a id="NormalList.List._∷_"></a><a id="2824" href="#2824" class="InductiveConstructor Operator">_∷_</a> <a id="2828" class="Symbol">:</a> <a id="2830" href="#2781" class="Bound">A</a> <a id="2832" class="Symbol">→</a> <a id="2834" href="#2771" class="Datatype">List</a> <a id="2839" href="#2781" class="Bound">A</a> <a id="2841" class="Symbol">→</a> <a id="2843" href="#2771" class="Datatype">List</a> <a id="2848" href="#2781" class="Bound">A</a>
</pre>
<p>They allow us to add new equations to a type, as well as constructors. To demonstrate what this means, as well as why you’d want it, I’m going to talk about free objects.</p>
<p>Very informally, a free object on some algebra is the <em>minimal</em> type which satisfies the laws of the algebra. Lists, for instance, are the free monoid. They satisfy all of the monoid laws (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>•</mo><annotation encoding="application/x-tex">\bullet</annotation></semantics></math> is <code>++</code> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ϵ</mi><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math> is <code>[]</code>):</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>•</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo><mo>•</mo><mi>z</mi><mo>=</mo><mi>x</mi><mo>•</mo><mo stretchy="false" form="prefix">(</mo><mi>y</mi><mo>•</mo><mi>z</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(x \bullet y) \bullet z = x \bullet (y \bullet z)</annotation></semantics></math> <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>•</mo><mi>ϵ</mi><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">x \bullet \epsilon = x</annotation></semantics></math> <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi><mo>•</mo><mi>x</mi><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">\epsilon \bullet x = x</annotation></semantics></math></p>
<p>But <em>nothing else</em>. That means they don’t satisfy any extra laws (like, for example, commutativity), and they don’t have any extra structure they don’t need.</p>
<p>How did we get to the definition of lists from the monoid laws, though? It doesn’t look anything like them. It would be nice if there was some systematic way to construct the corresponding free object given the laws of an algebra. Unfortunately, in normal Agda, this isn’t possible. Consider, for instance, if we added the commutativity law to the algebra: <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>•</mo><mi>y</mi><mo>=</mo><mi>y</mi><mo>•</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">x \bullet y = y \bullet x</annotation></semantics></math> Not only is it not obvious how we’d write the corresponding free object, it’s actually <em>not possible</em> in normal Agda!</p>
<p>This kind of problem comes up a lot: we have a type, and we want it to obey just <em>one more</em> equation, but there is no inductive type which does so. Higher Inductive Types solve the problem in quite a straightforward way. So we want lists to satisfy another equation? Well, just add it to the definition!</p>
<pre class="Agda"><a id="4347" class="Keyword">module</a> <a id="OddList"></a><a id="4354" href="#4354" class="Module">OddList</a> <a id="4362" class="Keyword">where</a>
 <a id="4369" class="Keyword">mutual</a>
  <a id="4378" class="Keyword">data</a> <a id="OddList.List"></a><a id="4383" href="#4383" class="Datatype">List</a> <a id="4388" class="Symbol">{</a><a id="4389" href="#4389" class="Bound">a</a><a id="4390" class="Symbol">}</a> <a id="4392" class="Symbol">(</a><a id="4393" href="#4393" class="Bound">A</a> <a id="4395" class="Symbol">:</a> <a id="4397" class="PrimitiveType">Set</a> <a id="4401" href="#4389" class="Bound">a</a><a id="4402" class="Symbol">)</a> <a id="4404" class="Symbol">:</a> <a id="4406" class="PrimitiveType">Set</a> <a id="4410" href="#4389" class="Bound">a</a> <a id="4412" class="Keyword">where</a>
    <a id="OddList.List.[]"></a><a id="4422" href="#4422" class="InductiveConstructor">[]</a> <a id="4425" class="Symbol">:</a> <a id="4427" href="#4383" class="Datatype">List</a> <a id="4432" href="#4393" class="Bound">A</a>
    <a id="OddList.List._∷_"></a><a id="4438" href="#4438" class="InductiveConstructor Operator">_∷_</a> <a id="4442" class="Symbol">:</a> <a id="4444" href="#4393" class="Bound">A</a> <a id="4446" class="Symbol">→</a> <a id="4448" href="#4383" class="Datatype">List</a> <a id="4453" href="#4393" class="Bound">A</a> <a id="4455" class="Symbol">→</a> <a id="4457" href="#4383" class="Datatype">List</a> <a id="4462" href="#4393" class="Bound">A</a>
    <a id="OddList.List.comm"></a><a id="4468" href="#4468" class="InductiveConstructor">comm</a> <a id="4473" class="Symbol">:</a> <a id="4475" class="Symbol">∀</a> <a id="4477" href="#4477" class="Bound">xs</a> <a id="4480" href="#4480" class="Bound">ys</a> <a id="4483" class="Symbol">→</a> <a id="4485" href="#4477" class="Bound">xs</a> <a id="4488" href="#4518" class="Postulate Operator">++</a> <a id="4491" href="#4480" class="Bound">ys</a> <a id="4494" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">≡</a> <a id="4496" href="#4480" class="Bound">ys</a> <a id="4499" href="#4518" class="Postulate Operator">++</a> <a id="4502" href="#4477" class="Bound">xs</a>

  <a id="4508" class="Keyword">postulate</a> <a id="OddList._++_"></a><a id="4518" href="#4518" class="Postulate Operator">_++_</a> <a id="4523" class="Symbol">:</a> <a id="4525" href="#4383" class="Datatype">List</a> <a id="4530" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="4532" class="Symbol">→</a> <a id="4534" href="#4383" class="Datatype">List</a> <a id="4539" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="4541" class="Symbol">→</a> <a id="4543" href="#4383" class="Datatype">List</a> <a id="4548" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a>
</pre>
Now, when we write a function that processes lists, Agda will check that the function behaves the same on <code>xs ++ ys</code> and <code>ys ++ xs</code>. As an example, here’s how you might define the free monoid as a HIT:
<pre class="Agda"><a id="4765" class="Keyword">data</a> <a id="FreeMonoid"></a><a id="4770" href="#4770" class="Datatype">FreeMonoid</a> <a id="4781" class="Symbol">{</a><a id="4782" href="#4782" class="Bound">a</a><a id="4783" class="Symbol">}</a> <a id="4785" class="Symbol">(</a><a id="4786" href="#4786" class="Bound">A</a> <a id="4788" class="Symbol">:</a> <a id="4790" class="PrimitiveType">Set</a> <a id="4794" href="#4782" class="Bound">a</a><a id="4795" class="Symbol">)</a> <a id="4797" class="Symbol">:</a> <a id="4799" class="PrimitiveType">Set</a> <a id="4803" href="#4782" class="Bound">a</a> <a id="4805" class="Keyword">where</a>
  <a id="FreeMonoid.[_]"></a><a id="4813" href="#4813" class="InductiveConstructor Operator">[_]</a> <a id="4817" class="Symbol">:</a> <a id="4819" href="#4786" class="Bound">A</a> <a id="4821" class="Symbol">→</a> <a id="4823" href="#4770" class="Datatype">FreeMonoid</a> <a id="4834" href="#4786" class="Bound">A</a>
  <a id="FreeMonoid._∙_"></a><a id="4838" href="#4838" class="InductiveConstructor Operator">_∙_</a> <a id="4842" class="Symbol">:</a> <a id="4844" href="#4770" class="Datatype">FreeMonoid</a> <a id="4855" href="#4786" class="Bound">A</a> <a id="4857" class="Symbol">→</a> <a id="4859" href="#4770" class="Datatype">FreeMonoid</a> <a id="4870" href="#4786" class="Bound">A</a> <a id="4872" class="Symbol">→</a> <a id="4874" href="#4770" class="Datatype">FreeMonoid</a> <a id="4885" href="#4786" class="Bound">A</a>
  <a id="FreeMonoid.ε"></a><a id="4889" href="#4889" class="InductiveConstructor">ε</a> <a id="4891" class="Symbol">:</a> <a id="4893" href="#4770" class="Datatype">FreeMonoid</a> <a id="4904" href="#4786" class="Bound">A</a>
  <a id="FreeMonoid.∙ε"></a><a id="4908" href="#4908" class="InductiveConstructor">∙ε</a> <a id="4911" class="Symbol">:</a> <a id="4913" class="Symbol">∀</a> <a id="4915" href="#4915" class="Bound">x</a> <a id="4917" class="Symbol">→</a> <a id="4919" href="#4915" class="Bound">x</a> <a id="4921" href="#4838" class="InductiveConstructor Operator">∙</a> <a id="4923" href="#4889" class="InductiveConstructor">ε</a> <a id="4925" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">≡</a> <a id="4927" href="#4915" class="Bound">x</a>
  <a id="FreeMonoid.ε∙"></a><a id="4931" href="#4931" class="InductiveConstructor">ε∙</a> <a id="4934" class="Symbol">:</a> <a id="4936" class="Symbol">∀</a> <a id="4938" href="#4938" class="Bound">x</a> <a id="4940" class="Symbol">→</a> <a id="4942" href="#4889" class="InductiveConstructor">ε</a> <a id="4944" href="#4838" class="InductiveConstructor Operator">∙</a> <a id="4946" href="#4938" class="Bound">x</a> <a id="4948" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">≡</a> <a id="4950" href="#4938" class="Bound">x</a>
  <a id="FreeMonoid.assoc"></a><a id="4954" href="#4954" class="InductiveConstructor">assoc</a> <a id="4960" class="Symbol">:</a> <a id="4962" class="Symbol">∀</a> <a id="4964" href="#4964" class="Bound">x</a> <a id="4966" href="#4966" class="Bound">y</a> <a id="4968" href="#4968" class="Bound">z</a> <a id="4970" class="Symbol">→</a> <a id="4972" class="Symbol">(</a><a id="4973" href="#4964" class="Bound">x</a> <a id="4975" href="#4838" class="InductiveConstructor Operator">∙</a> <a id="4977" href="#4966" class="Bound">y</a><a id="4978" class="Symbol">)</a> <a id="4980" href="#4838" class="InductiveConstructor Operator">∙</a> <a id="4982" href="#4968" class="Bound">z</a> <a id="4984" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">≡</a> <a id="4986" href="#4964" class="Bound">x</a> <a id="4988" href="#4838" class="InductiveConstructor Operator">∙</a> <a id="4990" class="Symbol">(</a><a id="4991" href="#4966" class="Bound">y</a> <a id="4993" href="#4838" class="InductiveConstructor Operator">∙</a> <a id="4995" href="#4968" class="Bound">z</a><a id="4996" class="Symbol">)</a>
</pre>
<p>It’s quite a satisfying definition, and very easy to see how we got to it from the monoid laws.</p>
Now, when we write functions, we have to prove that those functions themselves also obey the monoid laws. For instance, here’s how we would take the length:
<pre class="Agda"><a id="5265" class="Keyword">module</a> <a id="Length"></a><a id="5272" href="#5272" class="Module">Length</a> <a id="5279" class="Keyword">where</a>
  <a id="5287" class="Keyword">open</a> <a id="5292" class="Keyword">import</a> <a id="5299" href="../code/probability/ProbabilityModule.Semirings.Nat.html" class="Module">ProbabilityModule.Semirings.Nat</a>
  <a id="5333" class="Keyword">open</a> <a id="5338" href="../code/probability/ProbabilityModule.Semirings.html#125" class="Module">Semiring</a> <a id="5347" href="../code/probability/ProbabilityModule.Semirings.Nat.html#1820" class="Function">+-*-𝕊</a>

  <a id="Length.length"></a><a id="5356" href="#5356" class="Function">length</a> <a id="5363" class="Symbol">:</a> <a id="5365" href="#4770" class="Datatype">FreeMonoid</a> <a id="5376" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="5378" class="Symbol">→</a> <a id="5380" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a>
  <a id="5384" href="#5356" class="Function">length</a> <a id="5391" href="#4813" class="InductiveConstructor Operator">[</a> <a id="5393" href="#5393" class="Bound">x</a> <a id="5395" href="#4813" class="InductiveConstructor Operator">]</a> <a id="5397" class="Symbol">=</a> <a id="5399" class="Number">1</a>
  <a id="5403" href="#5356" class="Function">length</a> <a id="5410" class="Symbol">(</a><a id="5411" href="#5411" class="Bound">xs</a> <a id="5414" href="#4838" class="InductiveConstructor Operator">∙</a> <a id="5416" href="#5416" class="Bound">ys</a><a id="5418" class="Symbol">)</a> <a id="5420" class="Symbol">=</a> <a id="5422" href="#5356" class="Function">length</a> <a id="5429" href="#5411" class="Bound">xs</a> <a id="5432" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Function Operator">+</a> <a id="5434" href="#5356" class="Function">length</a> <a id="5441" href="#5416" class="Bound">ys</a>
  <a id="5446" href="#5356" class="Function">length</a> <a id="5453" href="#4889" class="InductiveConstructor">ε</a> <a id="5455" class="Symbol">=</a> <a id="5457" class="Number">0</a>
  <a id="5461" href="#5356" class="Function">length</a> <a id="5468" class="Symbol">(</a><a id="5469" href="#4908" class="InductiveConstructor">∙ε</a> <a id="5472" href="#5472" class="Bound">xs</a> <a id="5475" href="#5475" class="Bound">i</a><a id="5476" class="Symbol">)</a> <a id="5478" class="Symbol">=</a> <a id="5480" href="../code/probability/ProbabilityModule.Semirings.html#660" class="Function">+0</a> <a id="5483" class="Symbol">(</a><a id="5484" href="#5356" class="Function">length</a> <a id="5491" href="#5472" class="Bound">xs</a><a id="5493" class="Symbol">)</a> <a id="5495" href="#5475" class="Bound">i</a>
  <a id="5499" href="#5356" class="Function">length</a> <a id="5506" class="Symbol">(</a><a id="5507" href="#4931" class="InductiveConstructor">ε∙</a> <a id="5510" href="#5510" class="Bound">xs</a> <a id="5513" href="#5513" class="Bound">i</a><a id="5514" class="Symbol">)</a> <a id="5516" class="Symbol">=</a> <a id="5518" href="../code/probability/ProbabilityModule.Semirings.html#430" class="Function">0+</a> <a id="5521" class="Symbol">(</a><a id="5522" href="#5356" class="Function">length</a> <a id="5529" href="#5510" class="Bound">xs</a><a id="5531" class="Symbol">)</a> <a id="5533" href="#5513" class="Bound">i</a>
  <a id="5537" href="#5356" class="Function">length</a> <a id="5544" class="Symbol">(</a><a id="5545" href="#4954" class="InductiveConstructor">assoc</a> <a id="5551" href="#5551" class="Bound">xs</a> <a id="5554" href="#5554" class="Bound">ys</a> <a id="5557" href="#5557" class="Bound">zs</a> <a id="5560" href="#5560" class="Bound">i</a><a id="5561" class="Symbol">)</a> <a id="5563" class="Symbol">=</a> <a id="5565" href="../code/probability/ProbabilityModule.Semirings.html#276" class="Function">+-assoc</a> <a id="5573" class="Symbol">(</a><a id="5574" href="#5356" class="Function">length</a> <a id="5581" href="#5551" class="Bound">xs</a><a id="5583" class="Symbol">)</a> <a id="5585" class="Symbol">(</a><a id="5586" href="#5356" class="Function">length</a> <a id="5593" href="#5554" class="Bound">ys</a><a id="5595" class="Symbol">)</a> <a id="5597" class="Symbol">(</a><a id="5598" href="#5356" class="Function">length</a> <a id="5605" href="#5557" class="Bound">zs</a><a id="5607" class="Symbol">)</a> <a id="5609" href="#5560" class="Bound">i</a>
</pre>
<p>The first three clauses are the actual function: they deal with the three normal constructors of the type. The next three clauses prove that those previous clauses obey the equalities defined on the type.</p>
<p>With the preliminary stuff out of the way, let’s get on to the type I wanted to talk about:</p>
<h1 id="probability">Probability</h1>
<p>First things first, let’s remember the classic definition of the probability monad:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Prob</span> a <span class="fu">=</span> <span class="dt">Prob</span> {<span class="ot"> runProb ::</span> [(a, <span class="dt">Rational</span>)] }</a></code></pre></div>
<p>Definitionally speaking, this doesn’t really represent what we’re talking about. For instance, the following two things express the same distribution, but have different representations:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="dt">Prob</span> [(<span class="dt">True</span>, <span class="dv">1</span> <span class="fu">/</span> <span class="dv">4</span>), (<span class="dt">True</span>, <span class="dv">1</span> <span class="fu">/</span> <span class="dv">4</span>), (<span class="dt">False</span>, <span class="dv">1</span> <span class="fu">/</span> <span class="dv">2</span>)]</a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="dt">Prob</span> [(<span class="dt">True</span> , <span class="dv">1</span> <span class="fu">/</span> <span class="dv">2</span>), (<span class="dt">False</span>, <span class="dv">1</span> <span class="fu">/</span> <span class="dv">2</span>)]</a></code></pre></div>
<p>So it’s the perfect candidate for an extra equality clause like we had above.</p>
<p>Second, in an effort to generalise, we won’t deal specifically with <code>Rational</code>, and instead we’ll use any semiring. After all of that, we get the following definition:</p>
<pre class="Agda"><a id="6634" class="Keyword">open</a> <a id="6639" href="../code/probability/ProbabilityModule.Semirings.html#125" class="Module">Semiring</a> <a id="6648" href="#1024" class="Bound">rng</a>

<a id="6653" class="Keyword">module</a> <a id="Initial"></a><a id="6660" href="#6660" class="Module">Initial</a> <a id="6668" class="Keyword">where</a>
 <a id="6675" class="Keyword">infixr</a> <a id="6682" class="Number">5</a> <a id="6684" href="#6746" class="InductiveConstructor Operator">_&amp;_∷_</a>
 <a id="6691" class="Keyword">data</a> <a id="Initial.𝒫"></a><a id="6696" href="#6696" class="Datatype">𝒫</a> <a id="6698" class="Symbol">(</a><a id="6699" href="#6699" class="Bound">A</a> <a id="6701" class="Symbol">:</a> <a id="6703" class="PrimitiveType">Set</a> <a id="6707" href="../code/probability/ProbabilityModule.Utils.html#178" class="Generalizable">a</a><a id="6708" class="Symbol">)</a> <a id="6710" class="Symbol">:</a> <a id="6712" class="PrimitiveType">Set</a> <a id="6716" class="Symbol">(</a><a id="6717" href="#6707" class="Bound">a</a> <a id="6719" href="../code/probability/ProbabilityModule.Utils.html#242" class="Function Operator">⊔</a> <a id="6721" href="#1020" class="Bound">s</a><a id="6722" class="Symbol">)</a> <a id="6724" class="Keyword">where</a>
   <a id="Initial.𝒫.[]"></a><a id="6733" href="#6733" class="InductiveConstructor">[]</a>  <a id="6737" class="Symbol">:</a> <a id="6739" href="#6696" class="Datatype">𝒫</a> <a id="6741" href="#6699" class="Bound">A</a>
   <a id="Initial.𝒫._&amp;_∷_"></a><a id="6746" href="#6746" class="InductiveConstructor Operator">_&amp;_∷_</a> <a id="6752" class="Symbol">:</a> <a id="6754" class="Symbol">(</a><a id="6755" href="#6755" class="Bound">p</a> <a id="6757" class="Symbol">:</a> <a id="6759" href="../code/probability/ProbabilityModule.Semirings.html#200" class="Field">R</a><a id="6760" class="Symbol">)</a> <a id="6762" class="Symbol">→</a> <a id="6764" class="Symbol">(</a><a id="6765" href="#6765" class="Bound">x</a> <a id="6767" class="Symbol">:</a> <a id="6769" href="#6699" class="Bound">A</a><a id="6770" class="Symbol">)</a> <a id="6772" class="Symbol">→</a> <a id="6774" href="#6696" class="Datatype">𝒫</a> <a id="6776" href="#6699" class="Bound">A</a> <a id="6778" class="Symbol">→</a> <a id="6780" href="#6696" class="Datatype">𝒫</a> <a id="6782" href="#6699" class="Bound">A</a>
   <a id="Initial.𝒫.dup"></a><a id="6787" href="#6787" class="InductiveConstructor">dup</a> <a id="6791" class="Symbol">:</a> <a id="6793" class="Symbol">∀</a> <a id="6795" href="#6795" class="Bound">p</a> <a id="6797" href="#6797" class="Bound">q</a> <a id="6799" href="#6799" class="Bound">x</a> <a id="6801" href="#6801" class="Bound">xs</a> <a id="6804" class="Symbol">→</a> <a id="6806" href="#6795" class="Bound">p</a> <a id="6808" href="#6746" class="InductiveConstructor Operator">&amp;</a> <a id="6810" href="#6799" class="Bound">x</a> <a id="6812" href="#6746" class="InductiveConstructor Operator">∷</a> <a id="6814" href="#6797" class="Bound">q</a> <a id="6816" href="#6746" class="InductiveConstructor Operator">&amp;</a> <a id="6818" href="#6799" class="Bound">x</a> <a id="6820" href="#6746" class="InductiveConstructor Operator">∷</a> <a id="6822" href="#6801" class="Bound">xs</a> <a id="6825" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">≡</a> <a id="6827" href="#6795" class="Bound">p</a> <a id="6829" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="6831" href="#6797" class="Bound">q</a> <a id="6833" href="#6746" class="InductiveConstructor Operator">&amp;</a> <a id="6835" href="#6799" class="Bound">x</a> <a id="6837" href="#6746" class="InductiveConstructor Operator">∷</a> <a id="6839" href="#6801" class="Bound">xs</a>
   <a id="Initial.𝒫.com"></a><a id="6845" href="#6845" class="InductiveConstructor">com</a> <a id="6849" class="Symbol">:</a> <a id="6851" class="Symbol">∀</a> <a id="6853" href="#6853" class="Bound">p</a> <a id="6855" href="#6855" class="Bound">x</a> <a id="6857" href="#6857" class="Bound">q</a> <a id="6859" href="#6859" class="Bound">y</a> <a id="6861" href="#6861" class="Bound">xs</a> <a id="6864" class="Symbol">→</a> <a id="6866" href="#6853" class="Bound">p</a> <a id="6868" href="#6746" class="InductiveConstructor Operator">&amp;</a> <a id="6870" href="#6855" class="Bound">x</a> <a id="6872" href="#6746" class="InductiveConstructor Operator">∷</a> <a id="6874" href="#6857" class="Bound">q</a> <a id="6876" href="#6746" class="InductiveConstructor Operator">&amp;</a> <a id="6878" href="#6859" class="Bound">y</a> <a id="6880" href="#6746" class="InductiveConstructor Operator">∷</a> <a id="6882" href="#6861" class="Bound">xs</a> <a id="6885" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">≡</a> <a id="6887" href="#6857" class="Bound">q</a> <a id="6889" href="#6746" class="InductiveConstructor Operator">&amp;</a> <a id="6891" href="#6859" class="Bound">y</a> <a id="6893" href="#6746" class="InductiveConstructor Operator">∷</a> <a id="6895" href="#6853" class="Bound">p</a> <a id="6897" href="#6746" class="InductiveConstructor Operator">&amp;</a> <a id="6899" href="#6855" class="Bound">x</a> <a id="6901" href="#6746" class="InductiveConstructor Operator">∷</a> <a id="6903" href="#6861" class="Bound">xs</a>
   <a id="Initial.𝒫.del"></a><a id="6909" href="#6909" class="InductiveConstructor">del</a> <a id="6913" class="Symbol">:</a> <a id="6915" class="Symbol">∀</a> <a id="6917" href="#6917" class="Bound">x</a> <a id="6919" href="#6919" class="Bound">xs</a> <a id="6922" class="Symbol">→</a> <a id="6924" href="../code/probability/ProbabilityModule.Semirings.html#254" class="Field">0#</a> <a id="6927" href="#6746" class="InductiveConstructor Operator">&amp;</a> <a id="6929" href="#6917" class="Bound">x</a> <a id="6931" href="#6746" class="InductiveConstructor Operator">∷</a> <a id="6933" href="#6919" class="Bound">xs</a> <a id="6936" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">≡</a> <a id="6938" href="#6919" class="Bound">xs</a>
</pre>
<p>The three extra conditions are pretty sensible: the first removes duplicates, the second makes things commutative, and the third removes impossible events.</p>
<p>Let’s get to writing some functions, then:</p>
<pre class="Agda"> <a id="Initial.∫"></a><a id="7156" href="#7156" class="Function">∫</a> <a id="7158" class="Symbol">:</a> <a id="7160" class="Symbol">(</a><a id="7161" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="7163" class="Symbol">→</a> <a id="7165" href="../code/probability/ProbabilityModule.Semirings.html#200" class="Field">R</a><a id="7166" class="Symbol">)</a> <a id="7168" class="Symbol">→</a> <a id="7170" href="#6696" class="Datatype">𝒫</a> <a id="7172" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="7174" class="Symbol">→</a> <a id="7176" href="../code/probability/ProbabilityModule.Semirings.html#200" class="Field">R</a>
 <a id="7179" href="#7156" class="Function">∫</a> <a id="7181" href="#7181" class="Bound">f</a> <a id="7183" href="#6733" class="InductiveConstructor">[]</a> <a id="7186" class="Symbol">=</a> <a id="7188" href="../code/probability/ProbabilityModule.Semirings.html#254" class="Field">0#</a>
 <a id="7192" href="#7156" class="Function">∫</a> <a id="7194" href="#7194" class="Bound">f</a> <a id="7196" class="Symbol">(</a><a id="7197" href="#7197" class="Bound">p</a> <a id="7199" href="#6746" class="InductiveConstructor Operator">&amp;</a> <a id="7201" href="#7201" class="Bound">x</a> <a id="7203" href="#6746" class="InductiveConstructor Operator">∷</a> <a id="7205" href="#7205" class="Bound">xs</a><a id="7207" class="Symbol">)</a> <a id="7209" class="Symbol">=</a> <a id="7211" href="#7197" class="Bound">p</a> <a id="7213" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="7215" href="#7194" class="Bound">f</a> <a id="7217" href="#7201" class="Bound">x</a> <a id="7219" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="7221" href="#7156" class="Function">∫</a> <a id="7223" href="#7194" class="Bound">f</a> <a id="7225" href="#7205" class="Bound">xs</a>
 <a id="7229" href="#7156" class="Function">∫</a> <a id="7231" href="#7231" class="Bound">f</a> <a id="7233" class="Symbol">(</a><a id="7234" href="#6787" class="InductiveConstructor">dup</a> <a id="7238" href="#7238" class="Bound">p</a> <a id="7240" href="#7240" class="Bound">q</a> <a id="7242" href="#7242" class="Bound">x</a> <a id="7244" href="#7244" class="Bound">xs</a> <a id="7247" href="#7247" class="Bound">i</a><a id="7248" class="Symbol">)</a> <a id="7250" class="Symbol">=</a> <a id="7252" href="../code/probability/ProbabilityModule.Utils.html#645" class="Function Operator">begin[</a> <a id="7259" href="#7247" class="Bound">i</a> <a id="7261" href="../code/probability/ProbabilityModule.Utils.html#645" class="Function Operator">]</a>
   <a id="7266" href="#7238" class="Bound">p</a> <a id="7268" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="7270" href="#7231" class="Bound">f</a> <a id="7272" href="#7242" class="Bound">x</a> <a id="7274" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="7276" class="Symbol">(</a><a id="7277" href="#7240" class="Bound">q</a> <a id="7279" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="7281" href="#7231" class="Bound">f</a> <a id="7283" href="#7242" class="Bound">x</a> <a id="7285" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="7287" href="#7156" class="Function">∫</a> <a id="7289" href="#7231" class="Bound">f</a> <a id="7291" href="#7244" class="Bound">xs</a><a id="7293" class="Symbol">)</a> <a id="7295" href="../code/probability/ProbabilityModule.Utils.html#295" class="Function">≡˘⟨</a> <a id="7299" href="../code/probability/ProbabilityModule.Semirings.html#276" class="Field">+-assoc</a> <a id="7307" class="Symbol">(</a><a id="7308" href="#7238" class="Bound">p</a> <a id="7310" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="7312" href="#7231" class="Bound">f</a> <a id="7314" href="#7242" class="Bound">x</a><a id="7315" class="Symbol">)</a> <a id="7317" class="Symbol">(</a><a id="7318" href="#7240" class="Bound">q</a> <a id="7320" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="7322" href="#7231" class="Bound">f</a> <a id="7324" href="#7242" class="Bound">x</a><a id="7325" class="Symbol">)</a> <a id="7327" class="Symbol">(</a><a id="7328" href="#7156" class="Function">∫</a> <a id="7330" href="#7231" class="Bound">f</a> <a id="7332" href="#7244" class="Bound">xs</a><a id="7334" class="Symbol">)</a> <a id="7336" href="../code/probability/ProbabilityModule.Utils.html#295" class="Function">⟩</a>
   <a id="7341" class="Symbol">(</a><a id="7342" href="#7238" class="Bound">p</a> <a id="7344" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="7346" href="#7231" class="Bound">f</a> <a id="7348" href="#7242" class="Bound">x</a> <a id="7350" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="7352" href="#7240" class="Bound">q</a> <a id="7354" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="7356" href="#7231" class="Bound">f</a> <a id="7358" href="#7242" class="Bound">x</a><a id="7359" class="Symbol">)</a> <a id="7361" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="7363" href="#7156" class="Function">∫</a> <a id="7365" href="#7231" class="Bound">f</a> <a id="7367" href="#7244" class="Bound">xs</a> <a id="7370" href="../code/probability/ProbabilityModule.Utils.html#295" class="Function">≡˘⟨</a> <a id="7374" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="7379" class="Symbol">(</a><a id="7380" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">_+</a> <a id="7383" href="#7156" class="Function">∫</a> <a id="7385" href="#7231" class="Bound">f</a> <a id="7387" href="#7244" class="Bound">xs</a><a id="7389" class="Symbol">)</a> <a id="7391" class="Symbol">(</a><a id="7392" href="../code/probability/ProbabilityModule.Semirings.html#592" class="Field">⟨+⟩*</a> <a id="7397" href="#7238" class="Bound">p</a> <a id="7399" href="#7240" class="Bound">q</a> <a id="7401" class="Symbol">(</a><a id="7402" href="#7231" class="Bound">f</a> <a id="7404" href="#7242" class="Bound">x</a><a id="7405" class="Symbol">))</a>  <a id="7409" href="../code/probability/ProbabilityModule.Utils.html#295" class="Function">⟩</a>
   <a id="7414" class="Symbol">(</a><a id="7415" href="#7238" class="Bound">p</a> <a id="7417" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="7419" href="#7240" class="Bound">q</a><a id="7420" class="Symbol">)</a> <a id="7422" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="7424" href="#7231" class="Bound">f</a> <a id="7426" href="#7242" class="Bound">x</a> <a id="7428" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="7430" href="#7156" class="Function">∫</a> <a id="7432" href="#7231" class="Bound">f</a> <a id="7434" href="#7244" class="Bound">xs</a> <a id="7437" href="../code/probability/Cubical.Foundations.Prelude.html#2745" class="Function Operator">∎</a>
 <a id="7440" href="#7156" class="Function">∫</a> <a id="7442" href="#7442" class="Bound">f</a> <a id="7444" class="Symbol">(</a><a id="7445" href="#6845" class="InductiveConstructor">com</a> <a id="7449" href="#7449" class="Bound">p</a> <a id="7451" href="#7451" class="Bound">x</a> <a id="7453" href="#7453" class="Bound">q</a> <a id="7455" href="#7455" class="Bound">y</a> <a id="7457" href="#7457" class="Bound">xs</a> <a id="7460" href="#7460" class="Bound">i</a><a id="7461" class="Symbol">)</a> <a id="7463" class="Symbol">=</a> <a id="7465" href="../code/probability/ProbabilityModule.Utils.html#645" class="Function Operator">begin[</a> <a id="7472" href="#7460" class="Bound">i</a> <a id="7474" href="../code/probability/ProbabilityModule.Utils.html#645" class="Function Operator">]</a>
   <a id="7479" href="#7449" class="Bound">p</a> <a id="7481" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="7483" href="#7442" class="Bound">f</a> <a id="7485" href="#7451" class="Bound">x</a> <a id="7487" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="7489" class="Symbol">(</a><a id="7490" href="#7453" class="Bound">q</a> <a id="7492" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="7494" href="#7442" class="Bound">f</a> <a id="7496" href="#7455" class="Bound">y</a> <a id="7498" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="7500" href="#7156" class="Function">∫</a> <a id="7502" href="#7442" class="Bound">f</a> <a id="7504" href="#7457" class="Bound">xs</a><a id="7506" class="Symbol">)</a> <a id="7508" href="../code/probability/ProbabilityModule.Utils.html#295" class="Function">≡˘⟨</a> <a id="7512" href="../code/probability/ProbabilityModule.Semirings.html#276" class="Field">+-assoc</a> <a id="7520" class="Symbol">(</a><a id="7521" href="#7449" class="Bound">p</a> <a id="7523" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="7525" href="#7442" class="Bound">f</a> <a id="7527" href="#7451" class="Bound">x</a><a id="7528" class="Symbol">)</a> <a id="7530" class="Symbol">(</a><a id="7531" href="#7453" class="Bound">q</a> <a id="7533" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="7535" href="#7442" class="Bound">f</a> <a id="7537" href="#7455" class="Bound">y</a><a id="7538" class="Symbol">)</a> <a id="7540" class="Symbol">(</a><a id="7541" href="#7156" class="Function">∫</a> <a id="7543" href="#7442" class="Bound">f</a> <a id="7545" href="#7457" class="Bound">xs</a><a id="7547" class="Symbol">)</a> <a id="7549" href="../code/probability/ProbabilityModule.Utils.html#295" class="Function">⟩</a>
   <a id="7554" href="#7449" class="Bound">p</a> <a id="7556" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="7558" href="#7442" class="Bound">f</a> <a id="7560" href="#7451" class="Bound">x</a> <a id="7562" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="7564" href="#7453" class="Bound">q</a> <a id="7566" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="7568" href="#7442" class="Bound">f</a> <a id="7570" href="#7455" class="Bound">y</a> <a id="7572" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="7574" href="#7156" class="Function">∫</a> <a id="7576" href="#7442" class="Bound">f</a> <a id="7578" href="#7457" class="Bound">xs</a>   <a id="7583" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">≡⟨</a> <a id="7586" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="7591" class="Symbol">(</a><a id="7592" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">_+</a> <a id="7595" href="#7156" class="Function">∫</a> <a id="7597" href="#7442" class="Bound">f</a> <a id="7599" href="#7457" class="Bound">xs</a><a id="7601" class="Symbol">)</a> <a id="7603" class="Symbol">(</a><a id="7604" href="../code/probability/ProbabilityModule.Semirings.html#508" class="Field">+-comm</a> <a id="7611" class="Symbol">(</a><a id="7612" href="#7449" class="Bound">p</a> <a id="7614" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="7616" href="#7442" class="Bound">f</a> <a id="7618" href="#7451" class="Bound">x</a><a id="7619" class="Symbol">)</a> <a id="7621" class="Symbol">(</a><a id="7622" href="#7453" class="Bound">q</a> <a id="7624" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="7626" href="#7442" class="Bound">f</a> <a id="7628" href="#7455" class="Bound">y</a><a id="7629" class="Symbol">))</a> <a id="7632" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">⟩</a>
   <a id="7637" href="#7453" class="Bound">q</a> <a id="7639" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="7641" href="#7442" class="Bound">f</a> <a id="7643" href="#7455" class="Bound">y</a> <a id="7645" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="7647" href="#7449" class="Bound">p</a> <a id="7649" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="7651" href="#7442" class="Bound">f</a> <a id="7653" href="#7451" class="Bound">x</a> <a id="7655" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="7657" href="#7156" class="Function">∫</a> <a id="7659" href="#7442" class="Bound">f</a> <a id="7661" href="#7457" class="Bound">xs</a>   <a id="7666" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">≡⟨</a> <a id="7669" href="../code/probability/ProbabilityModule.Semirings.html#276" class="Field">+-assoc</a> <a id="7677" class="Symbol">(</a><a id="7678" href="#7453" class="Bound">q</a> <a id="7680" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="7682" href="#7442" class="Bound">f</a> <a id="7684" href="#7455" class="Bound">y</a><a id="7685" class="Symbol">)</a> <a id="7687" class="Symbol">(</a><a id="7688" href="#7449" class="Bound">p</a> <a id="7690" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="7692" href="#7442" class="Bound">f</a> <a id="7694" href="#7451" class="Bound">x</a><a id="7695" class="Symbol">)</a> <a id="7697" class="Symbol">(</a><a id="7698" href="#7156" class="Function">∫</a> <a id="7700" href="#7442" class="Bound">f</a> <a id="7702" href="#7457" class="Bound">xs</a><a id="7704" class="Symbol">)</a> <a id="7706" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">⟩</a>
   <a id="7711" href="#7453" class="Bound">q</a> <a id="7713" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="7715" href="#7442" class="Bound">f</a> <a id="7717" href="#7455" class="Bound">y</a> <a id="7719" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="7721" class="Symbol">(</a><a id="7722" href="#7449" class="Bound">p</a> <a id="7724" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="7726" href="#7442" class="Bound">f</a> <a id="7728" href="#7451" class="Bound">x</a> <a id="7730" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="7732" href="#7156" class="Function">∫</a> <a id="7734" href="#7442" class="Bound">f</a> <a id="7736" href="#7457" class="Bound">xs</a><a id="7738" class="Symbol">)</a> <a id="7740" href="../code/probability/Cubical.Foundations.Prelude.html#2745" class="Function Operator">∎</a>
 <a id="7743" href="#7156" class="Function">∫</a> <a id="7745" href="#7745" class="Bound">f</a> <a id="7747" class="Symbol">(</a><a id="7748" href="#6909" class="InductiveConstructor">del</a> <a id="7752" href="#7752" class="Bound">x</a> <a id="7754" href="#7754" class="Bound">xs</a> <a id="7757" href="#7757" class="Bound">i</a><a id="7758" class="Symbol">)</a> <a id="7760" class="Symbol">=</a> <a id="7762" href="../code/probability/ProbabilityModule.Utils.html#645" class="Function Operator">begin[</a> <a id="7769" href="#7757" class="Bound">i</a> <a id="7771" href="../code/probability/ProbabilityModule.Utils.html#645" class="Function Operator">]</a>
   <a id="7776" href="../code/probability/ProbabilityModule.Semirings.html#254" class="Field">0#</a> <a id="7779" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="7781" href="#7745" class="Bound">f</a> <a id="7783" href="#7752" class="Bound">x</a> <a id="7785" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="7787" href="#7156" class="Function">∫</a> <a id="7789" href="#7745" class="Bound">f</a> <a id="7791" href="#7754" class="Bound">xs</a> <a id="7794" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">≡⟨</a> <a id="7797" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="7802" class="Symbol">(</a><a id="7803" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">_+</a> <a id="7806" href="#7156" class="Function">∫</a> <a id="7808" href="#7745" class="Bound">f</a> <a id="7810" href="#7754" class="Bound">xs</a><a id="7812" class="Symbol">)</a> <a id="7814" class="Symbol">(</a><a id="7815" href="../code/probability/ProbabilityModule.Semirings.html#403" class="Field">0*</a> <a id="7818" class="Symbol">(</a><a id="7819" href="#7745" class="Bound">f</a> <a id="7821" href="#7752" class="Bound">x</a><a id="7822" class="Symbol">))</a> <a id="7825" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">⟩</a>
   <a id="7830" href="../code/probability/ProbabilityModule.Semirings.html#254" class="Field">0#</a> <a id="7833" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="7835" href="#7156" class="Function">∫</a> <a id="7837" href="#7745" class="Bound">f</a> <a id="7839" href="#7754" class="Bound">xs</a>       <a id="7848" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">≡⟨</a> <a id="7851" href="../code/probability/ProbabilityModule.Semirings.html#430" class="Field">0+</a> <a id="7854" class="Symbol">(</a><a id="7855" href="#7156" class="Function">∫</a> <a id="7857" href="#7745" class="Bound">f</a> <a id="7859" href="#7754" class="Bound">xs</a><a id="7861" class="Symbol">)</a> <a id="7863" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">⟩</a>
   <a id="7868" href="#7156" class="Function">∫</a> <a id="7870" href="#7745" class="Bound">f</a> <a id="7872" href="#7754" class="Bound">xs</a> <a id="7875" href="../code/probability/Cubical.Foundations.Prelude.html#2745" class="Function Operator">∎</a>
</pre>
<p>This is much more involved than the free monoid function, but the principle is the same: we first write the actual function (on the first three lines), and then we show that the function doesn’t care about the “rewrite rules” we have in the next three clauses.</p>
<p>Before going any further, we will have to amend the definition a little. The problem is that if we tried to prove something about any function on our <code>𝒫</code> type, we’d have to prove equalities <em>between equalities</em> as well. I’m sure that this is possible, but it’s very annoying, so I’m going to use a technique I saw in <a href="https://github.com/L-TChen/FiniteSets">this repository</a>. We add another rule to our type, stating that all equalities on the type are themselves equal. The new definition looks like this:</p>
<pre class="Agda"><a id="8659" class="Keyword">infixr</a> <a id="8666" class="Number">5</a> <a id="8668" href="#8727" class="InductiveConstructor Operator">_&amp;_∷_</a>
<a id="8674" class="Keyword">data</a> <a id="𝒫"></a><a id="8679" href="#8679" class="Datatype">𝒫</a> <a id="8681" class="Symbol">(</a><a id="8682" href="#8682" class="Bound">A</a> <a id="8684" class="Symbol">:</a> <a id="8686" class="PrimitiveType">Set</a> <a id="8690" href="../code/probability/ProbabilityModule.Utils.html#178" class="Generalizable">a</a><a id="8691" class="Symbol">)</a> <a id="8693" class="Symbol">:</a> <a id="8695" class="PrimitiveType">Set</a> <a id="8699" class="Symbol">(</a><a id="8700" href="#8690" class="Bound">a</a> <a id="8702" href="../code/probability/ProbabilityModule.Utils.html#242" class="Function Operator">⊔</a> <a id="8704" href="#1020" class="Bound">s</a><a id="8705" class="Symbol">)</a> <a id="8707" class="Keyword">where</a>
  <a id="𝒫.[]"></a><a id="8715" href="#8715" class="InductiveConstructor">[]</a>  <a id="8719" class="Symbol">:</a> <a id="8721" href="#8679" class="Datatype">𝒫</a> <a id="8723" href="#8682" class="Bound">A</a>
  <a id="𝒫._&amp;_∷_"></a><a id="8727" href="#8727" class="InductiveConstructor Operator">_&amp;_∷_</a> <a id="8733" class="Symbol">:</a> <a id="8735" class="Symbol">(</a><a id="8736" href="#8736" class="Bound">p</a> <a id="8738" class="Symbol">:</a> <a id="8740" href="../code/probability/ProbabilityModule.Semirings.html#200" class="Field">R</a><a id="8741" class="Symbol">)</a> <a id="8743" class="Symbol">→</a> <a id="8745" class="Symbol">(</a><a id="8746" href="#8746" class="Bound">x</a> <a id="8748" class="Symbol">:</a> <a id="8750" href="#8682" class="Bound">A</a><a id="8751" class="Symbol">)</a> <a id="8753" class="Symbol">→</a> <a id="8755" href="#8679" class="Datatype">𝒫</a> <a id="8757" href="#8682" class="Bound">A</a> <a id="8759" class="Symbol">→</a> <a id="8761" href="#8679" class="Datatype">𝒫</a> <a id="8763" href="#8682" class="Bound">A</a>
  <a id="𝒫.dup"></a><a id="8767" href="#8767" class="InductiveConstructor">dup</a> <a id="8771" class="Symbol">:</a> <a id="8773" class="Symbol">∀</a> <a id="8775" href="#8775" class="Bound">p</a> <a id="8777" href="#8777" class="Bound">q</a> <a id="8779" href="#8779" class="Bound">x</a> <a id="8781" href="#8781" class="Bound">xs</a> <a id="8784" class="Symbol">→</a> <a id="8786" href="#8775" class="Bound">p</a> <a id="8788" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="8790" href="#8779" class="Bound">x</a> <a id="8792" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="8794" href="#8777" class="Bound">q</a> <a id="8796" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="8798" href="#8779" class="Bound">x</a> <a id="8800" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="8802" href="#8781" class="Bound">xs</a> <a id="8805" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">≡</a> <a id="8807" href="#8775" class="Bound">p</a> <a id="8809" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="8811" href="#8777" class="Bound">q</a> <a id="8813" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="8815" href="#8779" class="Bound">x</a> <a id="8817" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="8819" href="#8781" class="Bound">xs</a>
  <a id="𝒫.com"></a><a id="8824" href="#8824" class="InductiveConstructor">com</a> <a id="8828" class="Symbol">:</a> <a id="8830" class="Symbol">∀</a> <a id="8832" href="#8832" class="Bound">p</a> <a id="8834" href="#8834" class="Bound">x</a> <a id="8836" href="#8836" class="Bound">q</a> <a id="8838" href="#8838" class="Bound">y</a> <a id="8840" href="#8840" class="Bound">xs</a> <a id="8843" class="Symbol">→</a> <a id="8845" href="#8832" class="Bound">p</a> <a id="8847" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="8849" href="#8834" class="Bound">x</a> <a id="8851" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="8853" href="#8836" class="Bound">q</a> <a id="8855" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="8857" href="#8838" class="Bound">y</a> <a id="8859" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="8861" href="#8840" class="Bound">xs</a> <a id="8864" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">≡</a> <a id="8866" href="#8836" class="Bound">q</a> <a id="8868" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="8870" href="#8838" class="Bound">y</a> <a id="8872" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="8874" href="#8832" class="Bound">p</a> <a id="8876" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="8878" href="#8834" class="Bound">x</a> <a id="8880" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="8882" href="#8840" class="Bound">xs</a>
  <a id="𝒫.del"></a><a id="8887" href="#8887" class="InductiveConstructor">del</a> <a id="8891" class="Symbol">:</a> <a id="8893" class="Symbol">∀</a> <a id="8895" href="#8895" class="Bound">x</a> <a id="8897" href="#8897" class="Bound">xs</a> <a id="8900" class="Symbol">→</a> <a id="8902" href="../code/probability/ProbabilityModule.Semirings.html#254" class="Field">0#</a> <a id="8905" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="8907" href="#8895" class="Bound">x</a> <a id="8909" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="8911" href="#8897" class="Bound">xs</a> <a id="8914" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">≡</a> <a id="8916" href="#8897" class="Bound">xs</a>
  <a id="𝒫.trunc"></a><a id="8921" href="#8921" class="InductiveConstructor">trunc</a> <a id="8927" class="Symbol">:</a> <a id="8929" href="../code/probability/Cubical.Foundations.Prelude.html#5455" class="Function">isSet</a> <a id="8935" class="Symbol">(</a><a id="8936" href="#8679" class="Datatype">𝒫</a> <a id="8938" href="#8682" class="Bound">A</a><a id="8939" class="Symbol">)</a>
</pre>
<h1 id="eliminators">Eliminators</h1>
<p>Unfortunately, after adding that case we have to deal with it explicitly in every pattern-match on <code>𝒫</code>. We can get around it by writing an eliminator for the type which deals with it itself. Eliminators are often irritating to work with, though: we give up the nice pattern-matching syntax we get when we program directly. It’s a bit like having to rely on church encoding everywhere.</p>
<p>However, we can get back some pattern-like syntax if we use <em>copatterns</em>. Here’s an example of what I mean, for folds on lists:</p>
<pre class="Agda"><a id="9484" class="Keyword">module</a> <a id="ListElim"></a><a id="9491" href="#9491" class="Module">ListElim</a> <a id="9500" class="Keyword">where</a>
 <a id="9507" class="Keyword">open</a> <a id="9512" href="#2748" class="Module">NormalList</a>
 <a id="9524" class="Keyword">open</a> <a id="9529" class="Keyword">import</a> <a id="9536" href="../code/probability/ProbabilityModule.Semirings.Nat.html" class="Module">ProbabilityModule.Semirings.Nat</a>
 <a id="9569" class="Keyword">open</a> <a id="9574" href="../code/probability/ProbabilityModule.Semirings.html#125" class="Module">Semiring</a> <a id="9583" href="../code/probability/ProbabilityModule.Semirings.Nat.html#1820" class="Function">+-*-𝕊</a> <a id="9589" class="Keyword">renaming</a> <a id="9598" class="Symbol">(</a>_+_ <a id="9603" class="Symbol">to</a> _ℕ+_<a id="9610" class="Symbol">)</a>

 <a id="9614" class="Keyword">record</a> <a id="ListElim.[_↦_]"></a><a id="9621" href="#9621" class="Record Operator">[_↦_]</a> <a id="9627" class="Symbol">(</a><a id="9628" href="#9628" class="Bound">A</a> <a id="9630" class="Symbol">:</a> <a id="9632" class="PrimitiveType">Set</a> <a id="9636" href="../code/probability/ProbabilityModule.Utils.html#178" class="Generalizable">a</a><a id="9637" class="Symbol">)</a> <a id="9639" class="Symbol">(</a><a id="9640" href="#9640" class="Bound">B</a> <a id="9642" class="Symbol">:</a> <a id="9644" class="PrimitiveType">Set</a> <a id="9648" href="../code/probability/ProbabilityModule.Utils.html#180" class="Generalizable">b</a><a id="9649" class="Symbol">)</a> <a id="9651" class="Symbol">:</a> <a id="9653" class="PrimitiveType">Set</a> <a id="9657" class="Symbol">(</a><a id="9658" href="#9636" class="Bound">a</a> <a id="9660" href="../code/probability/ProbabilityModule.Utils.html#242" class="Function Operator">⊔</a> <a id="9662" href="#9648" class="Bound">b</a><a id="9663" class="Symbol">)</a> <a id="9665" class="Keyword">where</a>
   <a id="9674" class="Keyword">field</a>
     <a id="ListElim.[_↦_].[_][]"></a><a id="9685" href="#9685" class="Field Operator">[_][]</a> <a id="9691" class="Symbol">:</a> <a id="9693" href="#9640" class="Bound">B</a>
     <a id="ListElim.[_↦_].[_]_∷_"></a><a id="9700" href="#9700" class="Field Operator">[_]_∷_</a> <a id="9707" class="Symbol">:</a> <a id="9709" href="#9628" class="Bound">A</a> <a id="9711" class="Symbol">→</a> <a id="9713" href="#9640" class="Bound">B</a> <a id="9715" class="Symbol">→</a> <a id="9717" href="#9640" class="Bound">B</a>
   <a id="ListElim.[_↦_].[_]↓"></a><a id="9722" href="#9722" class="Function Operator">[_]↓</a> <a id="9727" class="Symbol">:</a> <a id="9729" href="#2771" class="Datatype">List</a> <a id="9734" href="#9628" class="Bound">A</a> <a id="9736" class="Symbol">→</a> <a id="9738" href="#9640" class="Bound">B</a>
   <a id="9743" href="#9722" class="Function Operator">[</a> <a id="9745" href="#2809" class="InductiveConstructor">[]</a> <a id="9748" href="#9722" class="Function Operator">]↓</a> <a id="9751" class="Symbol">=</a> <a id="9753" href="#9685" class="Field Operator">[_][]</a>
   <a id="9762" href="#9722" class="Function Operator">[</a> <a id="9764" href="#9764" class="Bound">x</a> <a id="9766" href="#2824" class="InductiveConstructor Operator">∷</a> <a id="9768" href="#9768" class="Bound">xs</a> <a id="9771" href="#9722" class="Function Operator">]↓</a> <a id="9774" class="Symbol">=</a> <a id="9776" href="#9700" class="Field Operator">[_]_∷_</a> <a id="9783" href="#9764" class="Bound">x</a> <a id="9785" href="#9722" class="Function Operator">[</a> <a id="9787" href="#9768" class="Bound">xs</a> <a id="9790" href="#9722" class="Function Operator">]↓</a>
 <a id="9794" class="Keyword">open</a> <a id="9799" href="#9621" class="Module Operator">[_↦_]</a>
 
 <a id="ListElim.sum-alg"></a><a id="9808" href="#9808" class="Function">sum-alg</a> <a id="9816" class="Symbol">:</a> <a id="9818" href="#9621" class="Record Operator">[</a> <a id="9820" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="9822" href="#9621" class="Record Operator">↦</a> <a id="9824" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="9826" href="#9621" class="Record Operator">]</a>
 <a id="9829" href="#9685" class="Field Operator">[</a> <a id="9831" href="#9808" class="Function">sum-alg</a> <a id="9839" href="#9685" class="Field Operator">][]</a> <a id="9843" class="Symbol">=</a> <a id="9845" class="Number">0</a>
 <a id="9848" href="#9700" class="Field Operator">[</a> <a id="9850" href="#9808" class="Function">sum-alg</a> <a id="9858" href="#9700" class="Field Operator">]</a> <a id="9860" href="#9860" class="Bound">x</a> <a id="9862" href="#9700" class="Field Operator">∷</a> <a id="9864" href="#9864" class="Bound">xs</a> <a id="9867" class="Symbol">=</a> <a id="9869" href="#9860" class="Bound">x</a> <a id="9871" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Function Operator">ℕ+</a> <a id="9874" href="#9864" class="Bound">xs</a>
 
 <a id="ListElim.sum"></a><a id="9880" href="#9880" class="Function">sum</a> <a id="9884" class="Symbol">:</a> <a id="9886" href="#2771" class="Datatype">List</a> <a id="9891" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="9893" class="Symbol">→</a> <a id="9895" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a>
 <a id="9898" href="#9880" class="Function">sum</a> <a id="9902" class="Symbol">=</a> <a id="9904" href="#9722" class="Function Operator">[</a> <a id="9906" href="#9808" class="Function">sum-alg</a> <a id="9914" href="#9722" class="Function Operator">]↓</a>
</pre>
<p>For the probability monad, there’s an eliminator for the whole thing, and eliminator for propositional proofs, and a normal eliminator for folding. Their definitions are quite long, but mechanical.</p>
<details>
<summary>Eliminator Definitions</summary>
<pre class="Agda"><a id="10181" class="Keyword">record</a> <a id="⟅_↝_⟆"></a><a id="10188" href="#10188" class="Record Operator">⟅_↝_⟆</a> <a id="10194" class="Symbol">{</a><a id="10195" href="#10195" class="Bound">a</a> <a id="10197" href="#10197" class="Bound">ℓ</a><a id="10198" class="Symbol">}</a> <a id="10200" class="Symbol">(</a><a id="10201" href="#10201" class="Bound">A</a> <a id="10203" class="Symbol">:</a> <a id="10205" class="PrimitiveType">Set</a> <a id="10209" href="#10195" class="Bound">a</a><a id="10210" class="Symbol">)</a> <a id="10212" class="Symbol">(</a><a id="10213" href="#10213" class="Bound">P</a> <a id="10215" class="Symbol">:</a> <a id="10217" href="#8679" class="Datatype">𝒫</a> <a id="10219" href="#10201" class="Bound">A</a> <a id="10221" class="Symbol">→</a> <a id="10223" class="PrimitiveType">Set</a> <a id="10227" href="#10197" class="Bound">ℓ</a><a id="10228" class="Symbol">)</a> <a id="10230" class="Symbol">:</a> <a id="10232" class="PrimitiveType">Set</a> <a id="10236" class="Symbol">(</a><a id="10237" href="#10195" class="Bound">a</a> <a id="10239" href="../code/probability/ProbabilityModule.Utils.html#242" class="Function Operator">⊔</a> <a id="10241" href="#10197" class="Bound">ℓ</a> <a id="10243" href="../code/probability/ProbabilityModule.Utils.html#242" class="Function Operator">⊔</a> <a id="10245" href="#1020" class="Bound">s</a><a id="10246" class="Symbol">)</a> <a id="10248" class="Keyword">where</a>
  <a id="10256" class="Keyword">constructor</a> <a id="⟅_↝_⟆.elim"></a><a id="10268" href="#10268" class="InductiveConstructor">elim</a>
  <a id="10275" class="Keyword">field</a>
    <a id="⟅_↝_⟆.⟅_⟆-set"></a><a id="10285" href="#10285" class="Field Operator">⟅_⟆-set</a> <a id="10293" class="Symbol">:</a> <a id="10295" class="Symbol">∀</a> <a id="10297" class="Symbol">{</a><a id="10298" href="#10298" class="Bound">xs</a><a id="10300" class="Symbol">}</a> <a id="10302" class="Symbol">→</a> <a id="10304" href="../code/probability/Cubical.Foundations.Prelude.html#5455" class="Function">isSet</a> <a id="10310" class="Symbol">(</a><a id="10311" href="#10213" class="Bound">P</a> <a id="10313" href="#10298" class="Bound">xs</a><a id="10315" class="Symbol">)</a>
    <a id="⟅_↝_⟆.⟅_⟆[]"></a><a id="10321" href="#10321" class="Field Operator">⟅_⟆[]</a> <a id="10327" class="Symbol">:</a> <a id="10329" href="#10213" class="Bound">P</a> <a id="10331" href="#8715" class="InductiveConstructor">[]</a>
    <a id="⟅_↝_⟆.⟅_⟆_&amp;_∷_"></a><a id="10338" href="#10338" class="Field Operator">⟅_⟆_&amp;_∷_</a> <a id="10347" class="Symbol">:</a> <a id="10349" class="Symbol">∀</a> <a id="10351" href="#10351" class="Bound">p</a> <a id="10353" href="#10353" class="Bound">x</a> <a id="10355" href="#10355" class="Bound">xs</a> <a id="10358" class="Symbol">→</a> <a id="10360" href="#10213" class="Bound">P</a> <a id="10362" href="#10355" class="Bound">xs</a> <a id="10365" class="Symbol">→</a> <a id="10367" href="#10213" class="Bound">P</a> <a id="10369" class="Symbol">(</a><a id="10370" href="#10351" class="Bound">p</a> <a id="10372" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="10374" href="#10353" class="Bound">x</a> <a id="10376" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="10378" href="#10355" class="Bound">xs</a><a id="10380" class="Symbol">)</a>
  <a id="10384" class="Keyword">private</a> <a id="⟅_↝_⟆.z"></a><a id="10392" href="#10392" class="Function">z</a> <a id="10394" class="Symbol">=</a> <a id="10396" href="#10321" class="Field Operator">⟅_⟆[]</a><a id="10401" class="Symbol">;</a> <a id="⟅_↝_⟆.f"></a><a id="10403" href="#10403" class="Function">f</a> <a id="10405" class="Symbol">=</a> <a id="10407" href="#10338" class="Field Operator">⟅_⟆_&amp;_∷_</a>
  <a id="10418" class="Keyword">field</a>
    <a id="⟅_↝_⟆.⟅_⟆-dup"></a><a id="10428" href="#10428" class="Field Operator">⟅_⟆-dup</a> <a id="10436" class="Symbol">:</a> <a id="10438" class="Symbol">(∀</a> <a id="10441" href="#10441" class="Bound">p</a> <a id="10443" href="#10443" class="Bound">q</a> <a id="10445" href="#10445" class="Bound">x</a> <a id="10447" href="#10447" class="Bound">xs</a> <a id="10450" href="#10450" class="Bound">pxs</a> <a id="10454" class="Symbol">→</a> <a id="10456" href="Agda.Builtin.Cubical.Path.html#162" class="Postulate">PathP</a> <a id="10462" class="Symbol">(λ</a> <a id="10465" href="#10465" class="Bound">i</a> <a id="10467" class="Symbol">→</a> <a id="10469" href="#10213" class="Bound">P</a> <a id="10471" class="Symbol">(</a><a id="10472" href="#8767" class="InductiveConstructor">dup</a> <a id="10476" href="#10441" class="Bound">p</a> <a id="10478" href="#10443" class="Bound">q</a> <a id="10480" href="#10445" class="Bound">x</a> <a id="10482" href="#10447" class="Bound">xs</a> <a id="10485" href="#10465" class="Bound">i</a><a id="10486" class="Symbol">))</a>
              <a id="10503" class="Symbol">(</a><a id="10504" href="#10403" class="Function">f</a> <a id="10506" href="#10441" class="Bound">p</a> <a id="10508" href="#10445" class="Bound">x</a> <a id="10510" class="Symbol">(</a><a id="10511" href="#10443" class="Bound">q</a> <a id="10513" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="10515" href="#10445" class="Bound">x</a> <a id="10517" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="10519" href="#10447" class="Bound">xs</a><a id="10521" class="Symbol">)</a> <a id="10523" class="Symbol">(</a><a id="10524" href="#10403" class="Function">f</a> <a id="10526" href="#10443" class="Bound">q</a> <a id="10528" href="#10445" class="Bound">x</a> <a id="10530" href="#10447" class="Bound">xs</a> <a id="10533" href="#10450" class="Bound">pxs</a><a id="10536" class="Symbol">))</a> <a id="10539" class="Symbol">(</a><a id="10540" href="#10403" class="Function">f</a> <a id="10542" class="Symbol">(</a><a id="10543" href="#10441" class="Bound">p</a> <a id="10545" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="10547" href="#10443" class="Bound">q</a><a id="10548" class="Symbol">)</a> <a id="10550" href="#10445" class="Bound">x</a> <a id="10552" href="#10447" class="Bound">xs</a> <a id="10555" href="#10450" class="Bound">pxs</a><a id="10558" class="Symbol">))</a>
    <a id="⟅_↝_⟆.⟅_⟆-com"></a><a id="10565" href="#10565" class="Field Operator">⟅_⟆-com</a> <a id="10573" class="Symbol">:</a> <a id="10575" class="Symbol">(∀</a> <a id="10578" href="#10578" class="Bound">p</a> <a id="10580" href="#10580" class="Bound">x</a> <a id="10582" href="#10582" class="Bound">q</a> <a id="10584" href="#10584" class="Bound">y</a> <a id="10586" href="#10586" class="Bound">xs</a> <a id="10589" href="#10589" class="Bound">pxs</a> <a id="10593" class="Symbol">→</a> <a id="10595" href="Agda.Builtin.Cubical.Path.html#162" class="Postulate">PathP</a> <a id="10601" class="Symbol">(λ</a> <a id="10604" href="#10604" class="Bound">i</a> <a id="10606" class="Symbol">→</a> <a id="10608" href="#10213" class="Bound">P</a> <a id="10610" class="Symbol">(</a><a id="10611" href="#8824" class="InductiveConstructor">com</a> <a id="10615" href="#10578" class="Bound">p</a> <a id="10617" href="#10580" class="Bound">x</a> <a id="10619" href="#10582" class="Bound">q</a> <a id="10621" href="#10584" class="Bound">y</a> <a id="10623" href="#10586" class="Bound">xs</a> <a id="10626" href="#10604" class="Bound">i</a><a id="10627" class="Symbol">))</a>
              <a id="10644" class="Symbol">(</a><a id="10645" href="#10403" class="Function">f</a> <a id="10647" href="#10578" class="Bound">p</a> <a id="10649" href="#10580" class="Bound">x</a> <a id="10651" class="Symbol">(</a><a id="10652" href="#10582" class="Bound">q</a> <a id="10654" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="10656" href="#10584" class="Bound">y</a> <a id="10658" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="10660" href="#10586" class="Bound">xs</a><a id="10662" class="Symbol">)</a> <a id="10664" class="Symbol">(</a><a id="10665" href="#10403" class="Function">f</a> <a id="10667" href="#10582" class="Bound">q</a> <a id="10669" href="#10584" class="Bound">y</a> <a id="10671" href="#10586" class="Bound">xs</a> <a id="10674" href="#10589" class="Bound">pxs</a><a id="10677" class="Symbol">))</a> <a id="10680" class="Symbol">(</a><a id="10681" href="#10403" class="Function">f</a> <a id="10683" href="#10582" class="Bound">q</a> <a id="10685" href="#10584" class="Bound">y</a> <a id="10687" class="Symbol">(</a><a id="10688" href="#10578" class="Bound">p</a> <a id="10690" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="10692" href="#10580" class="Bound">x</a> <a id="10694" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="10696" href="#10586" class="Bound">xs</a><a id="10698" class="Symbol">)</a> <a id="10700" class="Symbol">(</a><a id="10701" href="#10403" class="Function">f</a> <a id="10703" href="#10578" class="Bound">p</a> <a id="10705" href="#10580" class="Bound">x</a> <a id="10707" href="#10586" class="Bound">xs</a> <a id="10710" href="#10589" class="Bound">pxs</a><a id="10713" class="Symbol">)))</a>
    <a id="⟅_↝_⟆.⟅_⟆-del"></a><a id="10721" href="#10721" class="Field Operator">⟅_⟆-del</a> <a id="10729" class="Symbol">:</a> <a id="10731" class="Symbol">(∀</a> <a id="10734" href="#10734" class="Bound">x</a> <a id="10736" href="#10736" class="Bound">xs</a> <a id="10739" href="#10739" class="Bound">pxs</a> <a id="10743" class="Symbol">→</a> <a id="10745" href="Agda.Builtin.Cubical.Path.html#162" class="Postulate">PathP</a> <a id="10751" class="Symbol">(λ</a> <a id="10754" href="#10754" class="Bound">i</a> <a id="10756" class="Symbol">→</a> <a id="10758" href="#10213" class="Bound">P</a> <a id="10760" class="Symbol">(</a><a id="10761" href="#8887" class="InductiveConstructor">del</a> <a id="10765" href="#10734" class="Bound">x</a> <a id="10767" href="#10736" class="Bound">xs</a> <a id="10770" href="#10754" class="Bound">i</a><a id="10771" class="Symbol">))</a>
              <a id="10788" class="Symbol">(</a><a id="10789" href="#10403" class="Function">f</a> <a id="10791" href="../code/probability/ProbabilityModule.Semirings.html#254" class="Field">0#</a> <a id="10794" href="#10734" class="Bound">x</a> <a id="10796" href="#10736" class="Bound">xs</a> <a id="10799" href="#10739" class="Bound">pxs</a><a id="10802" class="Symbol">)</a> <a id="10804" href="#10739" class="Bound">pxs</a><a id="10807" class="Symbol">)</a>
  <a id="⟅_↝_⟆.⟅_⟆⇓"></a><a id="10811" href="#10811" class="Function Operator">⟅_⟆⇓</a> <a id="10816" class="Symbol">:</a> <a id="10818" class="Symbol">(</a><a id="10819" href="#10819" class="Bound">xs</a> <a id="10822" class="Symbol">:</a> <a id="10824" href="#8679" class="Datatype">𝒫</a> <a id="10826" href="#10201" class="Bound">A</a><a id="10827" class="Symbol">)</a> <a id="10829" class="Symbol">→</a> <a id="10831" href="#10213" class="Bound">P</a> <a id="10833" href="#10819" class="Bound">xs</a>
  <a id="10838" href="#10811" class="Function Operator">⟅</a> <a id="10840" href="#8715" class="InductiveConstructor">[]</a> <a id="10843" href="#10811" class="Function Operator">⟆⇓</a> <a id="10846" class="Symbol">=</a> <a id="10848" href="#10392" class="Function">z</a>
  <a id="10852" href="#10811" class="Function Operator">⟅</a> <a id="10854" href="#10854" class="Bound">p</a> <a id="10856" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="10858" href="#10858" class="Bound">x</a> <a id="10860" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="10862" href="#10862" class="Bound">xs</a> <a id="10865" href="#10811" class="Function Operator">⟆⇓</a> <a id="10868" class="Symbol">=</a> <a id="10870" href="#10403" class="Function">f</a> <a id="10872" href="#10854" class="Bound">p</a> <a id="10874" href="#10858" class="Bound">x</a> <a id="10876" href="#10862" class="Bound">xs</a> <a id="10879" href="#10811" class="Function Operator">⟅</a> <a id="10881" href="#10862" class="Bound">xs</a> <a id="10884" href="#10811" class="Function Operator">⟆⇓</a>
  <a id="10889" href="#10811" class="Function Operator">⟅</a> <a id="10891" href="#8767" class="InductiveConstructor">dup</a> <a id="10895" href="#10895" class="Bound">p</a> <a id="10897" href="#10897" class="Bound">q</a> <a id="10899" href="#10899" class="Bound">x</a> <a id="10901" href="#10901" class="Bound">xs</a> <a id="10904" href="#10904" class="Bound">i</a> <a id="10906" href="#10811" class="Function Operator">⟆⇓</a> <a id="10909" class="Symbol">=</a> <a id="10911" href="#10428" class="Field Operator">⟅_⟆-dup</a> <a id="10919" href="#10895" class="Bound">p</a> <a id="10921" href="#10897" class="Bound">q</a> <a id="10923" href="#10899" class="Bound">x</a> <a id="10925" href="#10901" class="Bound">xs</a> <a id="10928" href="#10811" class="Function Operator">⟅</a> <a id="10930" href="#10901" class="Bound">xs</a> <a id="10933" href="#10811" class="Function Operator">⟆⇓</a> <a id="10936" href="#10904" class="Bound">i</a>
  <a id="10940" href="#10811" class="Function Operator">⟅</a> <a id="10942" href="#8824" class="InductiveConstructor">com</a> <a id="10946" href="#10946" class="Bound">p</a> <a id="10948" href="#10948" class="Bound">x</a> <a id="10950" href="#10950" class="Bound">q</a> <a id="10952" href="#10952" class="Bound">y</a> <a id="10954" href="#10954" class="Bound">xs</a> <a id="10957" href="#10957" class="Bound">i</a> <a id="10959" href="#10811" class="Function Operator">⟆⇓</a> <a id="10962" class="Symbol">=</a> <a id="10964" href="#10565" class="Field Operator">⟅_⟆-com</a> <a id="10972" href="#10946" class="Bound">p</a> <a id="10974" href="#10948" class="Bound">x</a> <a id="10976" href="#10950" class="Bound">q</a> <a id="10978" href="#10952" class="Bound">y</a> <a id="10980" href="#10954" class="Bound">xs</a> <a id="10983" href="#10811" class="Function Operator">⟅</a> <a id="10985" href="#10954" class="Bound">xs</a> <a id="10988" href="#10811" class="Function Operator">⟆⇓</a> <a id="10991" href="#10957" class="Bound">i</a>
  <a id="10995" href="#10811" class="Function Operator">⟅</a> <a id="10997" href="#8887" class="InductiveConstructor">del</a> <a id="11001" href="#11001" class="Bound">x</a> <a id="11003" href="#11003" class="Bound">xs</a> <a id="11006" href="#11006" class="Bound">i</a> <a id="11008" href="#10811" class="Function Operator">⟆⇓</a> <a id="11011" class="Symbol">=</a> <a id="11013" href="#10721" class="Field Operator">⟅_⟆-del</a> <a id="11021" href="#11001" class="Bound">x</a> <a id="11023" href="#11003" class="Bound">xs</a> <a id="11026" href="#10811" class="Function Operator">⟅</a> <a id="11028" href="#11003" class="Bound">xs</a> <a id="11031" href="#10811" class="Function Operator">⟆⇓</a> <a id="11034" href="#11006" class="Bound">i</a>
  <a id="11038" href="#10811" class="Function Operator">⟅</a> <a id="11040" href="#8921" class="InductiveConstructor">trunc</a> <a id="11046" href="#11046" class="Bound">xs</a> <a id="11049" href="#11049" class="Bound">ys</a> <a id="11052" href="#11052" class="Bound">p</a> <a id="11054" href="#11054" class="Bound">q</a> <a id="11056" href="#11056" class="Bound">i</a> <a id="11058" href="#11058" class="Bound">j</a> <a id="11060" href="#10811" class="Function Operator">⟆⇓</a> <a id="11063" class="Symbol">=</a>
    <a id="11069" href="../code/probability/Cubical.HITs.SetTruncation.Properties.html#434" class="Function">elimSquash₀</a> <a id="11081" class="Symbol">(λ</a> <a id="11084" href="#11084" class="Bound">xs</a> <a id="11087" class="Symbol">→</a> <a id="11089" href="#10285" class="Field Operator">⟅_⟆-set</a> <a id="11097" class="Symbol">{</a><a id="11098" href="#11084" class="Bound">xs</a><a id="11100" class="Symbol">})</a> <a id="11103" class="Symbol">(</a><a id="11104" href="#8921" class="InductiveConstructor">trunc</a> <a id="11110" href="#11046" class="Bound">xs</a> <a id="11113" href="#11049" class="Bound">ys</a> <a id="11116" href="#11052" class="Bound">p</a> <a id="11118" href="#11054" class="Bound">q</a><a id="11119" class="Symbol">)</a> <a id="11121" href="#10811" class="Function Operator">⟅</a> <a id="11123" href="#11046" class="Bound">xs</a> <a id="11126" href="#10811" class="Function Operator">⟆⇓</a> <a id="11129" href="#10811" class="Function Operator">⟅</a> <a id="11131" href="#11049" class="Bound">ys</a> <a id="11134" href="#10811" class="Function Operator">⟆⇓</a> <a id="11137" class="Symbol">(</a><a id="11138" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="11143" href="#10811" class="Function Operator">⟅_⟆⇓</a> <a id="11148" href="#11052" class="Bound">p</a><a id="11149" class="Symbol">)</a> <a id="11151" class="Symbol">(</a><a id="11152" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="11157" href="#10811" class="Function Operator">⟅_⟆⇓</a> <a id="11162" href="#11054" class="Bound">q</a><a id="11163" class="Symbol">)</a> <a id="11165" href="#11056" class="Bound">i</a> <a id="11167" href="#11058" class="Bound">j</a>

<a id="11170" class="Keyword">open</a> <a id="11175" href="#10188" class="Module Operator">⟅_↝_⟆</a> <a id="11181" class="Keyword">public</a>
<a id="elim-syntax"></a><a id="11188" href="#11188" class="Function">elim-syntax</a> <a id="11200" class="Symbol">:</a> <a id="11202" class="Symbol">∀</a> <a id="11204" class="Symbol">{</a><a id="11205" href="#11205" class="Bound">a</a> <a id="11207" href="#11207" class="Bound">ℓ</a><a id="11208" class="Symbol">}</a> <a id="11210" class="Symbol">→</a> <a id="11212" class="Symbol">(</a><a id="11213" href="#11213" class="Bound">A</a> <a id="11215" class="Symbol">:</a> <a id="11217" class="PrimitiveType">Set</a> <a id="11221" href="#11205" class="Bound">a</a><a id="11222" class="Symbol">)</a> <a id="11224" class="Symbol">→</a> <a id="11226" class="Symbol">(</a><a id="11227" href="#8679" class="Datatype">𝒫</a> <a id="11229" href="#11213" class="Bound">A</a> <a id="11231" class="Symbol">→</a> <a id="11233" class="PrimitiveType">Set</a> <a id="11237" href="#11207" class="Bound">ℓ</a><a id="11238" class="Symbol">)</a> <a id="11240" class="Symbol">→</a> <a id="11242" class="PrimitiveType">Set</a> <a id="11246" class="Symbol">(</a><a id="11247" href="#11205" class="Bound">a</a> <a id="11249" href="../code/probability/ProbabilityModule.Utils.html#242" class="Function Operator">⊔</a> <a id="11251" href="#11207" class="Bound">ℓ</a> <a id="11253" href="../code/probability/ProbabilityModule.Utils.html#242" class="Function Operator">⊔</a> <a id="11255" href="#1020" class="Bound">s</a><a id="11256" class="Symbol">)</a>
<a id="11258" href="#11188" class="Function">elim-syntax</a> <a id="11270" class="Symbol">=</a> <a id="11272" href="#10188" class="Record Operator">⟅_↝_⟆</a>

<a id="11279" class="Keyword">syntax</a> <a id="11286" href="#11188" class="Function">elim-syntax</a> <a id="11298" class="Bound">A</a> <a id="11300" class="Symbol">(λ</a> <a id="11303" class="Bound">xs</a> <a id="11306" class="Symbol">→</a> <a id="11308" class="Bound">Pxs</a><a id="11311" class="Symbol">)</a> <a id="11313" class="Symbol">=</a> <a id="11315" class="Function">[</a> <a id="11317" class="Bound">xs</a> <a id="11320" class="Function">∈𝒫</a> <a id="11323" class="Bound">A</a> <a id="11325" class="Function">↝</a> <a id="11327" class="Bound">Pxs</a> <a id="11331" class="Function">]</a>

<a id="11334" class="Keyword">record</a> <a id="⟦_⇒_⟧"></a><a id="11341" href="#11341" class="Record Operator">⟦_⇒_⟧</a> <a id="11347" class="Symbol">{</a><a id="11348" href="#11348" class="Bound">a</a> <a id="11350" href="#11350" class="Bound">ℓ</a><a id="11351" class="Symbol">}</a> <a id="11353" class="Symbol">(</a><a id="11354" href="#11354" class="Bound">A</a> <a id="11356" class="Symbol">:</a> <a id="11358" class="PrimitiveType">Set</a> <a id="11362" href="#11348" class="Bound">a</a><a id="11363" class="Symbol">)</a> <a id="11365" class="Symbol">(</a><a id="11366" href="#11366" class="Bound">P</a> <a id="11368" class="Symbol">:</a> <a id="11370" href="#8679" class="Datatype">𝒫</a> <a id="11372" href="#11354" class="Bound">A</a> <a id="11374" class="Symbol">→</a> <a id="11376" class="PrimitiveType">Set</a> <a id="11380" href="#11350" class="Bound">ℓ</a><a id="11381" class="Symbol">)</a> <a id="11383" class="Symbol">:</a> <a id="11385" class="PrimitiveType">Set</a> <a id="11389" class="Symbol">(</a><a id="11390" href="#11348" class="Bound">a</a> <a id="11392" href="../code/probability/ProbabilityModule.Utils.html#242" class="Function Operator">⊔</a> <a id="11394" href="#11350" class="Bound">ℓ</a> <a id="11396" href="../code/probability/ProbabilityModule.Utils.html#242" class="Function Operator">⊔</a> <a id="11398" href="#1020" class="Bound">s</a><a id="11399" class="Symbol">)</a> <a id="11401" class="Keyword">where</a>
  <a id="11409" class="Keyword">constructor</a> <a id="⟦_⇒_⟧.elim-prop"></a><a id="11421" href="#11421" class="InductiveConstructor">elim-prop</a>
  <a id="11433" class="Keyword">field</a>
    <a id="⟦_⇒_⟧.⟦_⟧-prop"></a><a id="11443" href="#11443" class="Field Operator">⟦_⟧-prop</a> <a id="11452" class="Symbol">:</a> <a id="11454" class="Symbol">∀</a> <a id="11456" class="Symbol">{</a><a id="11457" href="#11457" class="Bound">xs</a><a id="11459" class="Symbol">}</a> <a id="11461" class="Symbol">→</a> <a id="11463" href="../code/probability/Cubical.Foundations.Prelude.html#5402" class="Function">isProp</a> <a id="11470" class="Symbol">(</a><a id="11471" href="#11366" class="Bound">P</a> <a id="11473" href="#11457" class="Bound">xs</a><a id="11475" class="Symbol">)</a>
    <a id="⟦_⇒_⟧.⟦_⟧[]"></a><a id="11481" href="#11481" class="Field Operator">⟦_⟧[]</a> <a id="11487" class="Symbol">:</a> <a id="11489" href="#11366" class="Bound">P</a> <a id="11491" href="#8715" class="InductiveConstructor">[]</a>
    <a id="⟦_⇒_⟧.⟦_⟧_&amp;_∷_⟨_⟩"></a><a id="11498" href="#11498" class="Field Operator">⟦_⟧_&amp;_∷_⟨_⟩</a> <a id="11510" class="Symbol">:</a> <a id="11512" class="Symbol">∀</a> <a id="11514" href="#11514" class="Bound">p</a> <a id="11516" href="#11516" class="Bound">x</a> <a id="11518" href="#11518" class="Bound">xs</a> <a id="11521" class="Symbol">→</a> <a id="11523" href="#11366" class="Bound">P</a> <a id="11525" href="#11518" class="Bound">xs</a> <a id="11528" class="Symbol">→</a> <a id="11530" href="#11366" class="Bound">P</a> <a id="11532" class="Symbol">(</a><a id="11533" href="#11514" class="Bound">p</a> <a id="11535" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="11537" href="#11516" class="Bound">x</a> <a id="11539" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="11541" href="#11518" class="Bound">xs</a><a id="11543" class="Symbol">)</a>
  <a id="11547" class="Keyword">private</a> <a id="⟦_⇒_⟧.z"></a><a id="11555" href="#11555" class="Function">z</a> <a id="11557" class="Symbol">=</a> <a id="11559" href="#11481" class="Field Operator">⟦_⟧[]</a><a id="11564" class="Symbol">;</a> <a id="⟦_⇒_⟧.f"></a><a id="11566" href="#11566" class="Function">f</a> <a id="11568" class="Symbol">=</a> <a id="11570" href="#11498" class="Field Operator">⟦_⟧_&amp;_∷_⟨_⟩</a>
  <a id="⟦_⇒_⟧.⟦_⟧⇑"></a><a id="11584" href="#11584" class="Function Operator">⟦_⟧⇑</a> <a id="11589" class="Symbol">=</a> <a id="11591" href="#10268" class="InductiveConstructor">elim</a>
          <a id="11606" class="Symbol">(</a><a id="11607" href="../code/probability/Cubical.Foundations.Prelude.html#6576" class="Function">isProp→isSet</a> <a id="11620" href="#11443" class="Field Operator">⟦_⟧-prop</a><a id="11628" class="Symbol">)</a>
          <a id="11640" href="#11555" class="Function">z</a> <a id="11642" href="#11566" class="Function">f</a>
          <a id="11654" class="Symbol">(λ</a> <a id="11657" href="#11657" class="Bound">p</a> <a id="11659" href="#11659" class="Bound">q</a> <a id="11661" href="#11661" class="Bound">x</a> <a id="11663" href="#11663" class="Bound">xs</a> <a id="11666" href="#11666" class="Bound">pxs</a> <a id="11670" class="Symbol">→</a>
            <a id="11684" href="../code/probability/Cubical.Foundations.Prelude.html#5003" class="Function">toPathP</a> <a id="11692" class="Symbol">(</a><a id="11693" href="#11443" class="Field Operator">⟦_⟧-prop</a> <a id="11702" class="Symbol">(</a><a id="11703" href="Agda.Primitive.Cubical.html#1279" class="Primitive">transp</a> <a id="11710" class="Symbol">(λ</a> <a id="11713" href="#11713" class="Bound">i</a> <a id="11715" class="Symbol">→</a> <a id="11717" href="#11366" class="Bound">P</a> <a id="11719" class="Symbol">(</a><a id="11720" href="#8767" class="InductiveConstructor">dup</a> <a id="11724" href="#11657" class="Bound">p</a> <a id="11726" href="#11659" class="Bound">q</a> <a id="11728" href="#11661" class="Bound">x</a> <a id="11730" href="#11663" class="Bound">xs</a> <a id="11733" href="#11713" class="Bound">i</a><a id="11734" class="Symbol">))</a>
            <a id="11749" href="Agda.Primitive.Cubical.html#128" class="InductiveConstructor">i0</a>
            <a id="11764" class="Symbol">(</a><a id="11765" href="#11566" class="Function">f</a> <a id="11767" href="#11657" class="Bound">p</a> <a id="11769" href="#11661" class="Bound">x</a> <a id="11771" class="Symbol">(</a><a id="11772" href="#11659" class="Bound">q</a> <a id="11774" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="11776" href="#11661" class="Bound">x</a> <a id="11778" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="11780" href="#11663" class="Bound">xs</a><a id="11782" class="Symbol">)</a> <a id="11784" class="Symbol">(</a><a id="11785" href="#11566" class="Function">f</a> <a id="11787" href="#11659" class="Bound">q</a> <a id="11789" href="#11661" class="Bound">x</a> <a id="11791" href="#11663" class="Bound">xs</a> <a id="11794" href="#11666" class="Bound">pxs</a><a id="11797" class="Symbol">)))</a> <a id="11801" class="Symbol">(</a><a id="11802" href="#11566" class="Function">f</a> <a id="11804" class="Symbol">(</a><a id="11805" href="#11657" class="Bound">p</a> <a id="11807" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="11809" href="#11659" class="Bound">q</a><a id="11810" class="Symbol">)</a> <a id="11812" href="#11661" class="Bound">x</a> <a id="11814" href="#11663" class="Bound">xs</a> <a id="11817" href="#11666" class="Bound">pxs</a><a id="11820" class="Symbol">)</a> <a id="11822" class="Symbol">))</a>
          <a id="11835" class="Symbol">(λ</a> <a id="11838" href="#11838" class="Bound">p</a> <a id="11840" href="#11840" class="Bound">x</a> <a id="11842" href="#11842" class="Bound">q</a> <a id="11844" href="#11844" class="Bound">y</a> <a id="11846" href="#11846" class="Bound">xs</a> <a id="11849" href="#11849" class="Bound">pxs</a> <a id="11853" class="Symbol">→</a> <a id="11855" href="../code/probability/Cubical.Foundations.Prelude.html#5003" class="Function">toPathP</a> <a id="11863" class="Symbol">(</a><a id="11864" href="#11443" class="Field Operator">⟦_⟧-prop</a> <a id="11873" class="Symbol">(</a><a id="11874" href="Agda.Primitive.Cubical.html#1279" class="Primitive">transp</a> <a id="11881" class="Symbol">(λ</a> <a id="11884" href="#11884" class="Bound">i</a> <a id="11886" class="Symbol">→</a> <a id="11888" href="#11366" class="Bound">P</a> <a id="11890" class="Symbol">(</a><a id="11891" href="#8824" class="InductiveConstructor">com</a> <a id="11895" href="#11838" class="Bound">p</a> <a id="11897" href="#11840" class="Bound">x</a> <a id="11899" href="#11842" class="Bound">q</a> <a id="11901" href="#11844" class="Bound">y</a> <a id="11903" href="#11846" class="Bound">xs</a> <a id="11906" href="#11884" class="Bound">i</a><a id="11907" class="Symbol">))</a> <a id="11910" href="Agda.Primitive.Cubical.html#128" class="InductiveConstructor">i0</a>
            <a id="11925" class="Symbol">(</a><a id="11926" href="#11566" class="Function">f</a> <a id="11928" href="#11838" class="Bound">p</a> <a id="11930" href="#11840" class="Bound">x</a> <a id="11932" class="Symbol">(</a><a id="11933" href="#11842" class="Bound">q</a> <a id="11935" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="11937" href="#11844" class="Bound">y</a> <a id="11939" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="11941" href="#11846" class="Bound">xs</a><a id="11943" class="Symbol">)</a> <a id="11945" class="Symbol">(</a><a id="11946" href="#11566" class="Function">f</a> <a id="11948" href="#11842" class="Bound">q</a> <a id="11950" href="#11844" class="Bound">y</a> <a id="11952" href="#11846" class="Bound">xs</a> <a id="11955" href="#11849" class="Bound">pxs</a><a id="11958" class="Symbol">)))</a> <a id="11962" class="Symbol">(</a><a id="11963" href="#11566" class="Function">f</a> <a id="11965" href="#11842" class="Bound">q</a> <a id="11967" href="#11844" class="Bound">y</a> <a id="11969" class="Symbol">(</a><a id="11970" href="#11838" class="Bound">p</a> <a id="11972" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="11974" href="#11840" class="Bound">x</a> <a id="11976" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="11978" href="#11846" class="Bound">xs</a><a id="11980" class="Symbol">)</a> <a id="11982" class="Symbol">(</a><a id="11983" href="#11566" class="Function">f</a> <a id="11985" href="#11838" class="Bound">p</a> <a id="11987" href="#11840" class="Bound">x</a> <a id="11989" href="#11846" class="Bound">xs</a> <a id="11992" href="#11849" class="Bound">pxs</a><a id="11995" class="Symbol">))))</a>
            <a id="12012" class="Symbol">λ</a> <a id="12014" href="#12014" class="Bound">x</a> <a id="12016" href="#12016" class="Bound">xs</a> <a id="12019" href="#12019" class="Bound">pxs</a> <a id="12023" class="Symbol">→</a> <a id="12025" href="../code/probability/Cubical.Foundations.Prelude.html#5003" class="Function">toPathP</a> <a id="12033" class="Symbol">(</a><a id="12034" href="#11443" class="Field Operator">⟦_⟧-prop</a> <a id="12043" class="Symbol">(</a><a id="12044" href="Agda.Primitive.Cubical.html#1279" class="Primitive">transp</a> <a id="12051" class="Symbol">(λ</a> <a id="12054" href="#12054" class="Bound">i</a> <a id="12056" class="Symbol">→</a> <a id="12058" href="#11366" class="Bound">P</a> <a id="12060" class="Symbol">(</a><a id="12061" href="#8887" class="InductiveConstructor">del</a> <a id="12065" href="#12014" class="Bound">x</a> <a id="12067" href="#12016" class="Bound">xs</a> <a id="12070" href="#12054" class="Bound">i</a><a id="12071" class="Symbol">))</a> <a id="12074" href="Agda.Primitive.Cubical.html#128" class="InductiveConstructor">i0</a> <a id="12077" class="Symbol">((</a><a id="12079" href="#11566" class="Function">f</a> <a id="12081" href="../code/probability/ProbabilityModule.Semirings.html#254" class="Field">0#</a> <a id="12084" href="#12014" class="Bound">x</a> <a id="12086" href="#12016" class="Bound">xs</a> <a id="12089" href="#12019" class="Bound">pxs</a><a id="12092" class="Symbol">)))</a> <a id="12096" href="#12019" class="Bound">pxs</a><a id="12099" class="Symbol">)</a>
  <a id="⟦_⇒_⟧.⟦_⟧⇓"></a><a id="12103" href="#12103" class="Function Operator">⟦_⟧⇓</a> <a id="12108" class="Symbol">=</a> <a id="12110" href="#10811" class="Function Operator">⟅</a> <a id="12112" href="#11584" class="Function Operator">⟦_⟧⇑</a> <a id="12117" href="#10811" class="Function Operator">⟆⇓</a>

<a id="12121" class="Keyword">open</a> <a id="12126" href="#11341" class="Module Operator">⟦_⇒_⟧</a> <a id="12132" class="Keyword">public</a>
<a id="elim-prop-syntax"></a><a id="12139" href="#12139" class="Function">elim-prop-syntax</a> <a id="12156" class="Symbol">:</a> <a id="12158" class="Symbol">∀</a> <a id="12160" class="Symbol">{</a><a id="12161" href="#12161" class="Bound">a</a> <a id="12163" href="#12163" class="Bound">ℓ</a><a id="12164" class="Symbol">}</a> <a id="12166" class="Symbol">→</a> <a id="12168" class="Symbol">(</a><a id="12169" href="#12169" class="Bound">A</a> <a id="12171" class="Symbol">:</a> <a id="12173" class="PrimitiveType">Set</a> <a id="12177" href="#12161" class="Bound">a</a><a id="12178" class="Symbol">)</a> <a id="12180" class="Symbol">→</a> <a id="12182" class="Symbol">(</a><a id="12183" href="#8679" class="Datatype">𝒫</a> <a id="12185" href="#12169" class="Bound">A</a> <a id="12187" class="Symbol">→</a> <a id="12189" class="PrimitiveType">Set</a> <a id="12193" href="#12163" class="Bound">ℓ</a><a id="12194" class="Symbol">)</a> <a id="12196" class="Symbol">→</a> <a id="12198" class="PrimitiveType">Set</a> <a id="12202" class="Symbol">(</a><a id="12203" href="#12161" class="Bound">a</a> <a id="12205" href="../code/probability/ProbabilityModule.Utils.html#242" class="Function Operator">⊔</a> <a id="12207" href="#12163" class="Bound">ℓ</a> <a id="12209" href="../code/probability/ProbabilityModule.Utils.html#242" class="Function Operator">⊔</a> <a id="12211" href="#1020" class="Bound">s</a><a id="12212" class="Symbol">)</a>
<a id="12214" href="#12139" class="Function">elim-prop-syntax</a> <a id="12231" class="Symbol">=</a> <a id="12233" href="#11341" class="Record Operator">⟦_⇒_⟧</a>

<a id="12240" class="Keyword">syntax</a> <a id="12247" href="#12139" class="Function">elim-prop-syntax</a> <a id="12264" class="Bound">A</a> <a id="12266" class="Symbol">(λ</a> <a id="12269" class="Bound">xs</a> <a id="12272" class="Symbol">→</a> <a id="12274" class="Bound">Pxs</a><a id="12277" class="Symbol">)</a> <a id="12279" class="Symbol">=</a> <a id="12281" class="Function">⟦</a> <a id="12283" class="Bound">xs</a> <a id="12286" class="Function">∈𝒫</a> <a id="12289" class="Bound">A</a> <a id="12291" class="Function">⇒</a> <a id="12293" class="Bound">Pxs</a> <a id="12297" class="Function">⟧</a>

<a id="12300" class="Keyword">record</a> <a id="[_↦_]"></a><a id="12307" href="#12307" class="Record Operator">[_↦_]</a> <a id="12313" class="Symbol">{</a><a id="12314" href="#12314" class="Bound">a</a> <a id="12316" href="#12316" class="Bound">b</a><a id="12317" class="Symbol">}</a> <a id="12319" class="Symbol">(</a><a id="12320" href="#12320" class="Bound">A</a> <a id="12322" class="Symbol">:</a> <a id="12324" class="PrimitiveType">Set</a> <a id="12328" href="#12314" class="Bound">a</a><a id="12329" class="Symbol">)</a> <a id="12331" class="Symbol">(</a><a id="12332" href="#12332" class="Bound">B</a> <a id="12334" class="Symbol">:</a> <a id="12336" class="PrimitiveType">Set</a> <a id="12340" href="#12316" class="Bound">b</a><a id="12341" class="Symbol">)</a> <a id="12343" class="Symbol">:</a> <a id="12345" class="PrimitiveType">Set</a> <a id="12349" class="Symbol">(</a><a id="12350" href="#12314" class="Bound">a</a> <a id="12352" href="../code/probability/ProbabilityModule.Utils.html#242" class="Function Operator">⊔</a> <a id="12354" href="#12316" class="Bound">b</a> <a id="12356" href="../code/probability/ProbabilityModule.Utils.html#242" class="Function Operator">⊔</a> <a id="12358" href="#1020" class="Bound">s</a><a id="12359" class="Symbol">)</a> <a id="12361" class="Keyword">where</a>
  <a id="12369" class="Keyword">constructor</a> <a id="[_↦_].rec"></a><a id="12381" href="#12381" class="InductiveConstructor">rec</a>
  <a id="12387" class="Keyword">field</a>
    <a id="[_↦_].[_]-set"></a><a id="12397" href="#12397" class="Field Operator">[_]-set</a>  <a id="12406" class="Symbol">:</a> <a id="12408" href="../code/probability/Cubical.Foundations.Prelude.html#5455" class="Function">isSet</a> <a id="12414" href="#12332" class="Bound">B</a>
    <a id="[_↦_].[_]_&amp;_∷_"></a><a id="12420" href="#12420" class="Field Operator">[_]_&amp;_∷_</a> <a id="12429" class="Symbol">:</a> <a id="12431" href="../code/probability/ProbabilityModule.Semirings.html#200" class="Field">R</a> <a id="12433" class="Symbol">→</a> <a id="12435" href="#12320" class="Bound">A</a> <a id="12437" class="Symbol">→</a> <a id="12439" href="#12332" class="Bound">B</a> <a id="12441" class="Symbol">→</a> <a id="12443" href="#12332" class="Bound">B</a>
    <a id="[_↦_].[_][]"></a><a id="12449" href="#12449" class="Field Operator">[_][]</a>    <a id="12458" class="Symbol">:</a> <a id="12460" href="#12332" class="Bound">B</a>
  <a id="12464" class="Keyword">private</a> <a id="[_↦_].f"></a><a id="12472" href="#12472" class="Function">f</a> <a id="12474" class="Symbol">=</a> <a id="12476" href="#12420" class="Field Operator">[_]_&amp;_∷_</a><a id="12484" class="Symbol">;</a> <a id="[_↦_].z"></a><a id="12486" href="#12486" class="Function">z</a> <a id="12488" class="Symbol">=</a> <a id="12490" href="#12449" class="Field Operator">[_][]</a>
  <a id="12498" class="Keyword">field</a>
    <a id="[_↦_].[_]-dup"></a><a id="12508" href="#12508" class="Field Operator">[_]-dup</a>  <a id="12517" class="Symbol">:</a> <a id="12519" class="Symbol">∀</a> <a id="12521" href="#12521" class="Bound">p</a> <a id="12523" href="#12523" class="Bound">q</a> <a id="12525" href="#12525" class="Bound">x</a> <a id="12527" href="#12527" class="Bound">xs</a> <a id="12530" class="Symbol">→</a> <a id="12532" href="#12472" class="Function">f</a> <a id="12534" href="#12521" class="Bound">p</a> <a id="12536" href="#12525" class="Bound">x</a> <a id="12538" class="Symbol">(</a><a id="12539" href="#12472" class="Function">f</a> <a id="12541" href="#12523" class="Bound">q</a> <a id="12543" href="#12525" class="Bound">x</a> <a id="12545" href="#12527" class="Bound">xs</a><a id="12547" class="Symbol">)</a> <a id="12549" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">≡</a> <a id="12551" href="#12472" class="Function">f</a> <a id="12553" class="Symbol">(</a><a id="12554" href="#12521" class="Bound">p</a> <a id="12556" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="12558" href="#12523" class="Bound">q</a><a id="12559" class="Symbol">)</a> <a id="12561" href="#12525" class="Bound">x</a> <a id="12563" href="#12527" class="Bound">xs</a>
    <a id="[_↦_].[_]-com"></a><a id="12570" href="#12570" class="Field Operator">[_]-com</a> <a id="12578" class="Symbol">:</a> <a id="12580" class="Symbol">∀</a> <a id="12582" href="#12582" class="Bound">p</a> <a id="12584" href="#12584" class="Bound">x</a> <a id="12586" href="#12586" class="Bound">q</a> <a id="12588" href="#12588" class="Bound">y</a> <a id="12590" href="#12590" class="Bound">xs</a> <a id="12593" class="Symbol">→</a> <a id="12595" href="#12472" class="Function">f</a> <a id="12597" href="#12582" class="Bound">p</a> <a id="12599" href="#12584" class="Bound">x</a> <a id="12601" class="Symbol">(</a><a id="12602" href="#12472" class="Function">f</a> <a id="12604" href="#12586" class="Bound">q</a> <a id="12606" href="#12588" class="Bound">y</a> <a id="12608" href="#12590" class="Bound">xs</a><a id="12610" class="Symbol">)</a> <a id="12612" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">≡</a> <a id="12614" href="#12472" class="Function">f</a> <a id="12616" href="#12586" class="Bound">q</a> <a id="12618" href="#12588" class="Bound">y</a> <a id="12620" class="Symbol">(</a><a id="12621" href="#12472" class="Function">f</a> <a id="12623" href="#12582" class="Bound">p</a> <a id="12625" href="#12584" class="Bound">x</a> <a id="12627" href="#12590" class="Bound">xs</a><a id="12629" class="Symbol">)</a>
    <a id="[_↦_].[_]-del"></a><a id="12635" href="#12635" class="Field Operator">[_]-del</a> <a id="12643" class="Symbol">:</a> <a id="12645" class="Symbol">∀</a> <a id="12647" href="#12647" class="Bound">x</a> <a id="12649" href="#12649" class="Bound">xs</a> <a id="12652" class="Symbol">→</a> <a id="12654" href="#12472" class="Function">f</a> <a id="12656" href="../code/probability/ProbabilityModule.Semirings.html#254" class="Field">0#</a> <a id="12659" href="#12647" class="Bound">x</a> <a id="12661" href="#12649" class="Bound">xs</a> <a id="12664" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">≡</a> <a id="12666" href="#12649" class="Bound">xs</a>
  <a id="[_↦_].[_]⇑"></a><a id="12671" href="#12671" class="Function Operator">[_]⇑</a> <a id="12676" class="Symbol">=</a> <a id="12678" href="#10268" class="InductiveConstructor">elim</a>
            <a id="12695" href="#12397" class="Field Operator">[_]-set</a>
            <a id="12715" href="#12486" class="Function">z</a>
            <a id="12729" class="Symbol">(λ</a> <a id="12732" href="#12732" class="Bound">p</a> <a id="12734" href="#12734" class="Bound">x</a> <a id="12736" href="#12736" class="Bound">_</a> <a id="12738" href="#12738" class="Bound">xs</a> <a id="12741" class="Symbol">→</a> <a id="12743" href="#12472" class="Function">f</a> <a id="12745" href="#12732" class="Bound">p</a> <a id="12747" href="#12734" class="Bound">x</a> <a id="12749" href="#12738" class="Bound">xs</a><a id="12751" class="Symbol">)</a>
            <a id="12765" class="Symbol">(λ</a> <a id="12768" href="#12768" class="Bound">p</a> <a id="12770" href="#12770" class="Bound">q</a> <a id="12772" href="#12772" class="Bound">x</a> <a id="12774" href="#12774" class="Bound">xs</a> <a id="12777" class="Symbol">→</a> <a id="12779" href="#12508" class="Field Operator">[_]-dup</a> <a id="12787" href="#12768" class="Bound">p</a> <a id="12789" href="#12770" class="Bound">q</a> <a id="12791" href="#12772" class="Bound">x</a><a id="12792" class="Symbol">)</a>
            <a id="12806" class="Symbol">(λ</a> <a id="12809" href="#12809" class="Bound">p</a> <a id="12811" href="#12811" class="Bound">x</a> <a id="12813" href="#12813" class="Bound">q</a> <a id="12815" href="#12815" class="Bound">y</a> <a id="12817" href="#12817" class="Bound">xs</a> <a id="12820" class="Symbol">→</a> <a id="12822" href="#12570" class="Field Operator">[_]-com</a> <a id="12830" href="#12809" class="Bound">p</a> <a id="12832" href="#12811" class="Bound">x</a> <a id="12834" href="#12813" class="Bound">q</a> <a id="12836" href="#12815" class="Bound">y</a><a id="12837" class="Symbol">)</a>
            <a id="12851" class="Symbol">(λ</a> <a id="12854" href="#12854" class="Bound">x</a> <a id="12856" href="#12856" class="Bound">xs</a> <a id="12859" class="Symbol">→</a> <a id="12861" href="#12635" class="Field Operator">[_]-del</a> <a id="12869" href="#12854" class="Bound">x</a><a id="12870" class="Symbol">)</a>
  <a id="[_↦_].[_]↓"></a><a id="12874" href="#12874" class="Function Operator">[_]↓</a> <a id="12879" class="Symbol">=</a> <a id="12881" href="#10811" class="Function Operator">⟅</a> <a id="12883" href="#12671" class="Function Operator">[_]⇑</a> <a id="12888" href="#10811" class="Function Operator">⟆⇓</a>
<a id="12891" class="Keyword">open</a> <a id="12896" href="#12307" class="Module Operator">[_↦_]</a> <a id="12902" class="Keyword">public</a>
</pre>
</details>
<p>Here’s one in action, to define <code>map</code>:</p>
<pre class="Agda"><a id="map"></a><a id="12972" href="#12972" class="Function">map</a> <a id="12976" class="Symbol">:</a> <a id="12978" class="Symbol">(</a><a id="12979" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="12981" class="Symbol">→</a> <a id="12983" href="../code/probability/ProbabilityModule.Utils.html#206" class="Generalizable">B</a><a id="12984" class="Symbol">)</a> <a id="12986" class="Symbol">→</a> <a id="12988" href="#8679" class="Datatype">𝒫</a> <a id="12990" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="12992" class="Symbol">→</a> <a id="12994" href="#8679" class="Datatype">𝒫</a> <a id="12996" href="../code/probability/ProbabilityModule.Utils.html#206" class="Generalizable">B</a>
<a id="12998" href="#12972" class="Function">map</a> <a id="13002" class="Symbol">=</a> <a id="13004" class="Symbol">λ</a> <a id="13006" href="#13006" class="Bound">f</a> <a id="13008" class="Symbol">→</a> <a id="13010" href="#12874" class="Function Operator">[</a> <a id="13012" href="#13043" class="Function">map′</a> <a id="13017" href="#13006" class="Bound">f</a> <a id="13019" href="#12874" class="Function Operator">]↓</a>
  <a id="13024" class="Keyword">module</a> <a id="Map"></a><a id="13031" href="#13031" class="Module">Map</a> <a id="13035" class="Keyword">where</a>
  <a id="Map.map′"></a><a id="13043" href="#13043" class="Function">map′</a> <a id="13048" class="Symbol">:</a> <a id="13050" class="Symbol">(</a><a id="13051" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="13053" class="Symbol">→</a> <a id="13055" href="../code/probability/ProbabilityModule.Utils.html#206" class="Generalizable">B</a><a id="13056" class="Symbol">)</a> <a id="13058" class="Symbol">→</a> <a id="13060" href="#12307" class="Record Operator">[</a> <a id="13062" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="13064" href="#12307" class="Record Operator">↦</a> <a id="13066" href="#8679" class="Datatype">𝒫</a> <a id="13068" href="../code/probability/ProbabilityModule.Utils.html#206" class="Generalizable">B</a> <a id="13070" href="#12307" class="Record Operator">]</a>
  <a id="13074" href="#12420" class="Field Operator">[</a> <a id="13076" href="#13043" class="Function">map′</a> <a id="13081" href="#13081" class="Bound">f</a> <a id="13083" href="#12420" class="Field Operator">]</a> <a id="13085" href="#13085" class="Bound">p</a> <a id="13087" href="#12420" class="Field Operator">&amp;</a> <a id="13089" href="#13089" class="Bound">x</a> <a id="13091" href="#12420" class="Field Operator">∷</a> <a id="13093" href="#13093" class="Bound">xs</a> <a id="13096" class="Symbol">=</a> <a id="13098" href="#13085" class="Bound">p</a> <a id="13100" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="13102" href="#13081" class="Bound">f</a> <a id="13104" href="#13089" class="Bound">x</a> <a id="13106" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="13108" href="#13093" class="Bound">xs</a>
  <a id="13113" href="#12449" class="Field Operator">[</a> <a id="13115" href="#13043" class="Function">map′</a> <a id="13120" href="#13120" class="Bound">f</a> <a id="13122" href="#12449" class="Field Operator">][]</a> <a id="13126" class="Symbol">=</a> <a id="13128" href="#8715" class="InductiveConstructor">[]</a>
  <a id="13133" href="#12397" class="Field Operator">[</a> <a id="13135" href="#13043" class="Function">map′</a> <a id="13140" href="#13140" class="Bound">f</a> <a id="13142" href="#12397" class="Field Operator">]-set</a> <a id="13148" class="Symbol">=</a> <a id="13150" href="#8921" class="InductiveConstructor">trunc</a>
  <a id="13158" href="#12508" class="Field Operator">[</a> <a id="13160" href="#13043" class="Function">map′</a> <a id="13165" href="#13165" class="Bound">f</a> <a id="13167" href="#12508" class="Field Operator">]-dup</a> <a id="13173" href="#13173" class="Bound">p</a> <a id="13175" href="#13175" class="Bound">q</a> <a id="13177" href="#13177" class="Bound">x</a> <a id="13179" href="#13179" class="Bound">xs</a> <a id="13182" class="Symbol">=</a> <a id="13184" href="#8767" class="InductiveConstructor">dup</a> <a id="13188" href="#13173" class="Bound">p</a> <a id="13190" href="#13175" class="Bound">q</a> <a id="13192" class="Symbol">(</a><a id="13193" href="#13165" class="Bound">f</a> <a id="13195" href="#13177" class="Bound">x</a><a id="13196" class="Symbol">)</a> <a id="13198" href="#13179" class="Bound">xs</a>
  <a id="13203" href="#12570" class="Field Operator">[</a> <a id="13205" href="#13043" class="Function">map′</a> <a id="13210" href="#13210" class="Bound">f</a> <a id="13212" href="#12570" class="Field Operator">]-com</a> <a id="13218" href="#13218" class="Bound">p</a> <a id="13220" href="#13220" class="Bound">x</a> <a id="13222" href="#13222" class="Bound">q</a> <a id="13224" href="#13224" class="Bound">y</a> <a id="13226" href="#13226" class="Bound">xs</a> <a id="13229" class="Symbol">=</a> <a id="13231" href="#8824" class="InductiveConstructor">com</a> <a id="13235" href="#13218" class="Bound">p</a> <a id="13237" class="Symbol">(</a><a id="13238" href="#13210" class="Bound">f</a> <a id="13240" href="#13220" class="Bound">x</a><a id="13241" class="Symbol">)</a> <a id="13243" href="#13222" class="Bound">q</a> <a id="13245" class="Symbol">(</a><a id="13246" href="#13210" class="Bound">f</a> <a id="13248" href="#13224" class="Bound">y</a><a id="13249" class="Symbol">)</a> <a id="13251" href="#13226" class="Bound">xs</a>
  <a id="13256" href="#12635" class="Field Operator">[</a> <a id="13258" href="#13043" class="Function">map′</a> <a id="13263" href="#13263" class="Bound">f</a> <a id="13265" href="#12635" class="Field Operator">]-del</a> <a id="13271" href="#13271" class="Bound">x</a> <a id="13273" href="#13273" class="Bound">xs</a> <a id="13276" class="Symbol">=</a> <a id="13278" href="#8887" class="InductiveConstructor">del</a> <a id="13282" class="Symbol">(</a><a id="13283" href="#13263" class="Bound">f</a> <a id="13285" href="#13271" class="Bound">x</a><a id="13286" class="Symbol">)</a> <a id="13288" href="#13273" class="Bound">xs</a>
</pre>
<p>And here’s how we’d define union, and then prove that it’s associative:</p>
<pre class="Agda"><a id="13377" class="Keyword">infixr</a> <a id="13384" class="Number">5</a> <a id="13386" href="#13390" class="Function Operator">_∪_</a>
<a id="_∪_"></a><a id="13390" href="#13390" class="Function Operator">_∪_</a> <a id="13394" class="Symbol">:</a> <a id="13396" href="#8679" class="Datatype">𝒫</a> <a id="13398" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="13400" class="Symbol">→</a> <a id="13402" href="#8679" class="Datatype">𝒫</a> <a id="13404" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="13406" class="Symbol">→</a> <a id="13408" href="#8679" class="Datatype">𝒫</a> <a id="13410" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a>
<a id="13412" href="#13390" class="Function Operator">_∪_</a> <a id="13416" class="Symbol">=</a> <a id="13418" class="Symbol">λ</a> <a id="13420" href="#13420" class="Bound">xs</a> <a id="13423" href="#13423" class="Bound">ys</a> <a id="13426" class="Symbol">→</a> <a id="13428" href="#12874" class="Function Operator">[</a> <a id="13430" href="#13468" class="Function">union</a> <a id="13436" href="#13423" class="Bound">ys</a> <a id="13439" href="#12874" class="Function Operator">]↓</a> <a id="13442" href="#13420" class="Bound">xs</a>
  <a id="13447" class="Keyword">module</a> <a id="Union"></a><a id="13454" href="#13454" class="Module">Union</a> <a id="13460" class="Keyword">where</a>
  <a id="Union.union"></a><a id="13468" href="#13468" class="Function">union</a> <a id="13474" class="Symbol">:</a> <a id="13476" href="#8679" class="Datatype">𝒫</a> <a id="13478" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="13480" class="Symbol">→</a> <a id="13482" href="#12307" class="Record Operator">[</a> <a id="13484" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="13486" href="#12307" class="Record Operator">↦</a> <a id="13488" href="#8679" class="Datatype">𝒫</a> <a id="13490" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="13492" href="#12307" class="Record Operator">]</a>
  <a id="13496" href="#12397" class="Field Operator">[</a> <a id="13498" href="#13468" class="Function">union</a> <a id="13504" href="#13504" class="Bound">ys</a> <a id="13507" href="#12397" class="Field Operator">]-set</a> <a id="13513" class="Symbol">=</a> <a id="13515" href="#8921" class="InductiveConstructor">trunc</a>
  <a id="13523" href="#12420" class="Field Operator">[</a> <a id="13525" href="#13468" class="Function">union</a> <a id="13531" href="#13531" class="Bound">ys</a> <a id="13534" href="#12420" class="Field Operator">]</a> <a id="13536" href="#13536" class="Bound">p</a> <a id="13538" href="#12420" class="Field Operator">&amp;</a> <a id="13540" href="#13540" class="Bound">x</a> <a id="13542" href="#12420" class="Field Operator">∷</a> <a id="13544" href="#13544" class="Bound">xs</a> <a id="13547" class="Symbol">=</a> <a id="13549" href="#13536" class="Bound">p</a> <a id="13551" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="13553" href="#13540" class="Bound">x</a> <a id="13555" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="13557" href="#13544" class="Bound">xs</a>
  <a id="13562" href="#12449" class="Field Operator">[</a> <a id="13564" href="#13468" class="Function">union</a> <a id="13570" href="#13570" class="Bound">ys</a> <a id="13573" href="#12449" class="Field Operator">][]</a> <a id="13577" class="Symbol">=</a> <a id="13579" href="#13570" class="Bound">ys</a>
  <a id="13584" href="#12508" class="Field Operator">[</a> <a id="13586" href="#13468" class="Function">union</a> <a id="13592" href="#13592" class="Bound">ys</a> <a id="13595" href="#12508" class="Field Operator">]-dup</a> <a id="13601" class="Symbol">=</a> <a id="13603" href="#8767" class="InductiveConstructor">dup</a>
  <a id="13609" href="#12570" class="Field Operator">[</a> <a id="13611" href="#13468" class="Function">union</a> <a id="13617" href="#13617" class="Bound">ys</a> <a id="13620" href="#12570" class="Field Operator">]-com</a> <a id="13626" class="Symbol">=</a> <a id="13628" href="#8824" class="InductiveConstructor">com</a>
  <a id="13634" href="#12635" class="Field Operator">[</a> <a id="13636" href="#13468" class="Function">union</a> <a id="13642" href="#13642" class="Bound">ys</a> <a id="13645" href="#12635" class="Field Operator">]-del</a> <a id="13651" class="Symbol">=</a> <a id="13653" href="#8887" class="InductiveConstructor">del</a>

<a id="∪-assoc"></a><a id="13658" href="#13658" class="Function">∪-assoc</a> <a id="13666" class="Symbol">:</a> <a id="13668" class="Symbol">(</a><a id="13669" href="#13669" class="Bound">xs</a> <a id="13672" href="#13672" class="Bound">ys</a> <a id="13675" href="#13675" class="Bound">zs</a> <a id="13678" class="Symbol">:</a> <a id="13680" href="#8679" class="Datatype">𝒫</a> <a id="13682" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a><a id="13683" class="Symbol">)</a> <a id="13685" class="Symbol">→</a> <a id="13687" href="#13669" class="Bound">xs</a> <a id="13690" href="#13390" class="Function Operator">∪</a> <a id="13692" class="Symbol">(</a><a id="13693" href="#13672" class="Bound">ys</a> <a id="13696" href="#13390" class="Function Operator">∪</a> <a id="13698" href="#13675" class="Bound">zs</a><a id="13700" class="Symbol">)</a> <a id="13702" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">≡</a> <a id="13704" class="Symbol">(</a><a id="13705" href="#13669" class="Bound">xs</a> <a id="13708" href="#13390" class="Function Operator">∪</a> <a id="13710" href="#13672" class="Bound">ys</a><a id="13712" class="Symbol">)</a> <a id="13714" href="#13390" class="Function Operator">∪</a> <a id="13716" href="#13675" class="Bound">zs</a>
<a id="13719" href="#13658" class="Function">∪-assoc</a> <a id="13727" class="Symbol">=</a> <a id="13729" class="Symbol">λ</a> <a id="13731" href="#13731" class="Bound">xs</a> <a id="13734" href="#13734" class="Bound">ys</a> <a id="13737" href="#13737" class="Bound">zs</a> <a id="13740" class="Symbol">→</a> <a id="13742" href="#12103" class="Function Operator">⟦</a> <a id="13744" href="#13789" class="Function">∪-assoc′</a> <a id="13753" href="#13734" class="Bound">ys</a> <a id="13756" href="#13737" class="Bound">zs</a> <a id="13759" href="#12103" class="Function Operator">⟧⇓</a> <a id="13762" href="#13731" class="Bound">xs</a>
  <a id="13767" class="Keyword">module</a> <a id="UAssoc"></a><a id="13774" href="#13774" class="Module">UAssoc</a> <a id="13781" class="Keyword">where</a>
  <a id="UAssoc.∪-assoc′"></a><a id="13789" href="#13789" class="Function">∪-assoc′</a> <a id="13798" class="Symbol">:</a> <a id="13800" class="Symbol">∀</a> <a id="13802" href="#13802" class="Bound">ys</a> <a id="13805" href="#13805" class="Bound">zs</a> <a id="13808" class="Symbol">→</a> <a id="13810" href="#12139" class="Function">⟦</a> <a id="13812" href="#13812" class="Bound">xs</a> <a id="13815" href="#12139" class="Function">∈𝒫</a> <a id="13818" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="13820" href="#12139" class="Function">⇒</a> <a id="13822" href="#13812" class="Bound">xs</a> <a id="13825" href="#13390" class="Function Operator">∪</a> <a id="13827" class="Symbol">(</a><a id="13828" href="#13802" class="Bound">ys</a> <a id="13831" href="#13390" class="Function Operator">∪</a> <a id="13833" href="#13805" class="Bound">zs</a><a id="13835" class="Symbol">)</a> <a id="13837" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">≡</a> <a id="13839" class="Symbol">(</a><a id="13840" href="#13812" class="Bound">xs</a> <a id="13843" href="#13390" class="Function Operator">∪</a> <a id="13845" href="#13802" class="Bound">ys</a><a id="13847" class="Symbol">)</a> <a id="13849" href="#13390" class="Function Operator">∪</a> <a id="13851" href="#13805" class="Bound">zs</a> <a id="13854" href="#12139" class="Function">⟧</a>
  <a id="13858" href="#11443" class="Field Operator">⟦</a> <a id="13860" href="#13789" class="Function">∪-assoc′</a> <a id="13869" href="#13869" class="Bound">ys</a> <a id="13872" href="#13872" class="Bound">zs</a> <a id="13875" href="#11443" class="Field Operator">⟧-prop</a> <a id="13882" class="Symbol">=</a> <a id="13884" href="#8921" class="InductiveConstructor">trunc</a> <a id="13890" class="Symbol">_</a> <a id="13892" class="Symbol">_</a>
  <a id="13896" href="#11481" class="Field Operator">⟦</a> <a id="13898" href="#13789" class="Function">∪-assoc′</a> <a id="13907" href="#13907" class="Bound">ys</a> <a id="13910" href="#13910" class="Bound">zs</a> <a id="13913" href="#11481" class="Field Operator">⟧[]</a> <a id="13917" class="Symbol">=</a> <a id="13919" href="../code/probability/Cubical.Foundations.Prelude.html#827" class="Function">refl</a>
  <a id="13926" href="#11498" class="Field Operator">⟦</a> <a id="13928" href="#13789" class="Function">∪-assoc′</a> <a id="13937" href="#13937" class="Bound">ys</a> <a id="13940" href="#13940" class="Bound">zs</a> <a id="13943" href="#11498" class="Field Operator">⟧</a> <a id="13945" href="#13945" class="Bound">p</a> <a id="13947" href="#11498" class="Field Operator">&amp;</a> <a id="13949" href="#13949" class="Bound">x</a> <a id="13951" href="#11498" class="Field Operator">∷</a> <a id="13953" href="#13953" class="Bound">xs</a> <a id="13956" href="#11498" class="Field Operator">⟨</a> <a id="13958" href="#13958" class="Bound">P</a> <a id="13960" href="#11498" class="Field Operator">⟩</a> <a id="13962" class="Symbol">=</a> <a id="13964" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="13969" class="Symbol">(</a><a id="13970" href="#13945" class="Bound">p</a> <a id="13972" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="13974" href="#13949" class="Bound">x</a> <a id="13976" href="#8727" class="InductiveConstructor Operator">∷_</a><a id="13978" class="Symbol">)</a> <a id="13980" href="#13958" class="Bound">P</a>
</pre>
<p>There’s a lot more stuff here that I won’t bore you with.</p>
<details>
<summary>Boring Stuff</summary>
<pre class="Agda"><a id="14096" class="Keyword">infixl</a> <a id="14103" class="Number">7</a> <a id="14105" href="#14109" class="Function Operator">_⋊_</a>
<a id="_⋊_"></a><a id="14109" href="#14109" class="Function Operator">_⋊_</a> <a id="14113" class="Symbol">:</a> <a id="14115" href="../code/probability/ProbabilityModule.Semirings.html#200" class="Field">R</a> <a id="14117" class="Symbol">→</a> <a id="14119" href="#8679" class="Datatype">𝒫</a> <a id="14121" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="14123" class="Symbol">→</a> <a id="14125" href="#8679" class="Datatype">𝒫</a> <a id="14127" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a>
<a id="14129" href="#14109" class="Function Operator">_⋊_</a> <a id="14133" class="Symbol">=</a> <a id="14135" class="Symbol">λ</a> <a id="14137" href="#14137" class="Bound">p</a> <a id="14139" class="Symbol">→</a> <a id="14141" href="#12874" class="Function Operator">[</a> <a id="14143" href="#14137" class="Bound">p</a> <a id="14145" href="#14173" class="Function Operator">⋊′</a> <a id="14148" href="#12874" class="Function Operator">]↓</a>
  <a id="14153" class="Keyword">module</a> <a id="Cond"></a><a id="14160" href="#14160" class="Module">Cond</a> <a id="14165" class="Keyword">where</a>
  <a id="Cond._⋊′"></a><a id="14173" href="#14173" class="Function Operator">_⋊′</a> <a id="14177" class="Symbol">:</a> <a id="14179" href="../code/probability/ProbabilityModule.Semirings.html#200" class="Field">R</a> <a id="14181" class="Symbol">→</a> <a id="14183" href="#12307" class="Record Operator">[</a> <a id="14185" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="14187" href="#12307" class="Record Operator">↦</a> <a id="14189" href="#8679" class="Datatype">𝒫</a> <a id="14191" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="14193" href="#12307" class="Record Operator">]</a>
  <a id="14197" href="#12397" class="Field Operator">[</a> <a id="14199" href="#14199" class="Bound">p</a> <a id="14201" href="#14173" class="Function Operator">⋊′</a> <a id="14204" href="#12397" class="Field Operator">]-set</a> <a id="14210" class="Symbol">=</a> <a id="14212" href="#8921" class="InductiveConstructor">trunc</a>
  <a id="14220" href="#12449" class="Field Operator">[</a> <a id="14222" href="#14222" class="Bound">p</a> <a id="14224" href="#14173" class="Function Operator">⋊′</a> <a id="14227" href="#12449" class="Field Operator">][]</a> <a id="14231" class="Symbol">=</a> <a id="14233" href="#8715" class="InductiveConstructor">[]</a>
  <a id="14238" href="#12420" class="Field Operator">[</a> <a id="14240" href="#14240" class="Bound">p</a> <a id="14242" href="#14173" class="Function Operator">⋊′</a> <a id="14245" href="#12420" class="Field Operator">]</a> <a id="14247" href="#14247" class="Bound">q</a> <a id="14249" href="#12420" class="Field Operator">&amp;</a> <a id="14251" href="#14251" class="Bound">x</a> <a id="14253" href="#12420" class="Field Operator">∷</a> <a id="14255" href="#14255" class="Bound">xs</a> <a id="14258" class="Symbol">=</a> <a id="14260" href="#14240" class="Bound">p</a> <a id="14262" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="14264" href="#14247" class="Bound">q</a> <a id="14266" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="14268" href="#14251" class="Bound">x</a> <a id="14270" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="14272" href="#14255" class="Bound">xs</a>
  <a id="14277" href="#12570" class="Field Operator">[</a> <a id="14279" href="#14279" class="Bound">p</a> <a id="14281" href="#14173" class="Function Operator">⋊′</a> <a id="14284" href="#12570" class="Field Operator">]-com</a> <a id="14290" href="#14290" class="Bound">q</a> <a id="14292" href="#14292" class="Bound">x</a> <a id="14294" href="#14294" class="Bound">r</a> <a id="14296" href="#14296" class="Bound">y</a> <a id="14298" href="#14298" class="Bound">xs</a> <a id="14301" class="Symbol">=</a> <a id="14303" href="#8824" class="InductiveConstructor">com</a> <a id="14307" class="Symbol">(</a><a id="14308" href="#14279" class="Bound">p</a> <a id="14310" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="14312" href="#14290" class="Bound">q</a><a id="14313" class="Symbol">)</a> <a id="14315" href="#14292" class="Bound">x</a> <a id="14317" class="Symbol">(</a><a id="14318" href="#14279" class="Bound">p</a> <a id="14320" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="14322" href="#14294" class="Bound">r</a><a id="14323" class="Symbol">)</a> <a id="14325" href="#14296" class="Bound">y</a> <a id="14327" href="#14298" class="Bound">xs</a>
  <a id="14332" href="#12508" class="Field Operator">[</a> <a id="14334" href="#14334" class="Bound">p</a> <a id="14336" href="#14173" class="Function Operator">⋊′</a> <a id="14339" href="#12508" class="Field Operator">]-dup</a> <a id="14345" href="#14345" class="Bound">q</a> <a id="14347" href="#14347" class="Bound">r</a> <a id="14349" href="#14349" class="Bound">x</a> <a id="14351" href="#14351" class="Bound">xs</a> <a id="14354" class="Symbol">=</a>
    <a id="14360" href="#14334" class="Bound">p</a> <a id="14362" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="14364" href="#14345" class="Bound">q</a> <a id="14366" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="14368" href="#14349" class="Bound">x</a> <a id="14370" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="14372" href="#14334" class="Bound">p</a> <a id="14374" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="14376" href="#14347" class="Bound">r</a> <a id="14378" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="14380" href="#14349" class="Bound">x</a> <a id="14382" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="14384" href="#14351" class="Bound">xs</a> <a id="14387" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">≡⟨</a> <a id="14390" href="#8767" class="InductiveConstructor">dup</a> <a id="14394" class="Symbol">(</a><a id="14395" href="#14334" class="Bound">p</a> <a id="14397" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="14399" href="#14345" class="Bound">q</a><a id="14400" class="Symbol">)</a> <a id="14402" class="Symbol">(</a><a id="14403" href="#14334" class="Bound">p</a> <a id="14405" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="14407" href="#14347" class="Bound">r</a><a id="14408" class="Symbol">)</a> <a id="14410" href="#14349" class="Bound">x</a> <a id="14412" href="#14351" class="Bound">xs</a> <a id="14415" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">⟩</a>
    <a id="14421" href="#14334" class="Bound">p</a> <a id="14423" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="14425" href="#14345" class="Bound">q</a> <a id="14427" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="14429" href="#14334" class="Bound">p</a> <a id="14431" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="14433" href="#14347" class="Bound">r</a> <a id="14435" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="14437" href="#14349" class="Bound">x</a> <a id="14439" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="14441" href="#14351" class="Bound">xs</a>     <a id="14448" href="../code/probability/ProbabilityModule.Utils.html#295" class="Function">≡˘⟨</a> <a id="14452" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="14457" class="Symbol">(</a><a id="14458" href="#8727" class="InductiveConstructor Operator">_&amp;</a> <a id="14461" href="#14349" class="Bound">x</a> <a id="14463" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="14465" href="#14351" class="Bound">xs</a><a id="14467" class="Symbol">)</a> <a id="14469" class="Symbol">(</a><a id="14470" href="../code/probability/ProbabilityModule.Semirings.html#543" class="Field">*⟨+⟩</a> <a id="14475" href="#14334" class="Bound">p</a> <a id="14477" href="#14345" class="Bound">q</a> <a id="14479" href="#14347" class="Bound">r</a><a id="14480" class="Symbol">)</a> <a id="14482" href="../code/probability/ProbabilityModule.Utils.html#295" class="Function">⟩</a>
    <a id="14488" href="#14334" class="Bound">p</a> <a id="14490" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="14492" class="Symbol">(</a><a id="14493" href="#14345" class="Bound">q</a> <a id="14495" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="14497" href="#14347" class="Bound">r</a><a id="14498" class="Symbol">)</a> <a id="14500" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="14502" href="#14349" class="Bound">x</a> <a id="14504" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="14506" href="#14351" class="Bound">xs</a>       <a id="14515" href="../code/probability/Cubical.Foundations.Prelude.html#2745" class="Function Operator">∎</a>
  <a id="14519" href="#12635" class="Field Operator">[</a> <a id="14521" href="#14521" class="Bound">p</a> <a id="14523" href="#14173" class="Function Operator">⋊′</a> <a id="14526" href="#12635" class="Field Operator">]-del</a> <a id="14532" href="#14532" class="Bound">x</a> <a id="14534" href="#14534" class="Bound">xs</a> <a id="14537" class="Symbol">=</a>
    <a id="14543" href="#14521" class="Bound">p</a> <a id="14545" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="14547" href="../code/probability/ProbabilityModule.Semirings.html#254" class="Field">0#</a> <a id="14550" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="14552" href="#14532" class="Bound">x</a> <a id="14554" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="14556" href="#14534" class="Bound">xs</a> <a id="14559" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">≡⟨</a> <a id="14562" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="14567" class="Symbol">(</a><a id="14568" href="#8727" class="InductiveConstructor Operator">_&amp;</a> <a id="14571" href="#14532" class="Bound">x</a> <a id="14573" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="14575" href="#14534" class="Bound">xs</a><a id="14577" class="Symbol">)</a> <a id="14579" class="Symbol">(</a><a id="14580" href="../code/probability/ProbabilityModule.Semirings.html#376" class="Field">*0</a> <a id="14583" href="#14521" class="Bound">p</a><a id="14584" class="Symbol">)</a> <a id="14586" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">⟩</a>
    <a id="14592" href="../code/probability/ProbabilityModule.Semirings.html#254" class="Field">0#</a> <a id="14595" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="14597" href="#14532" class="Bound">x</a> <a id="14599" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="14601" href="#14534" class="Bound">xs</a>     <a id="14608" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">≡⟨</a> <a id="14611" href="#8887" class="InductiveConstructor">del</a> <a id="14615" href="#14532" class="Bound">x</a> <a id="14617" href="#14534" class="Bound">xs</a> <a id="14620" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">⟩</a>
    <a id="14626" href="#14534" class="Bound">xs</a>              <a id="14642" href="../code/probability/Cubical.Foundations.Prelude.html#2745" class="Function Operator">∎</a>

<a id="∫"></a><a id="14645" href="#14645" class="Function">∫</a> <a id="14647" class="Symbol">:</a> <a id="14649" class="Symbol">(</a><a id="14650" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="14652" class="Symbol">→</a> <a id="14654" href="../code/probability/ProbabilityModule.Semirings.html#200" class="Field">R</a><a id="14655" class="Symbol">)</a> <a id="14657" class="Symbol">→</a> <a id="14659" href="#8679" class="Datatype">𝒫</a> <a id="14661" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="14663" class="Symbol">→</a> <a id="14665" href="../code/probability/ProbabilityModule.Semirings.html#200" class="Field">R</a>
<a id="14667" href="#14645" class="Function">∫</a> <a id="14669" class="Symbol">=</a> <a id="14671" class="Symbol">λ</a> <a id="14673" href="#14673" class="Bound">f</a> <a id="14675" class="Symbol">→</a> <a id="14677" href="#12874" class="Function Operator">[</a> <a id="14679" href="#14711" class="Function">∫′</a> <a id="14682" href="#14673" class="Bound">f</a> <a id="14684" href="#12874" class="Function Operator">]↓</a>
  <a id="14689" class="Keyword">module</a> <a id="Expect"></a><a id="14696" href="#14696" class="Module">Expect</a> <a id="14703" class="Keyword">where</a>
  <a id="Expect.∫′"></a><a id="14711" href="#14711" class="Function">∫′</a> <a id="14714" class="Symbol">:</a> <a id="14716" class="Symbol">(</a><a id="14717" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="14719" class="Symbol">→</a> <a id="14721" href="../code/probability/ProbabilityModule.Semirings.html#200" class="Field">R</a><a id="14722" class="Symbol">)</a> <a id="14724" class="Symbol">→</a> <a id="14726" href="#12307" class="Record Operator">[</a> <a id="14728" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="14730" href="#12307" class="Record Operator">↦</a> <a id="14732" href="../code/probability/ProbabilityModule.Semirings.html#200" class="Field">R</a> <a id="14734" href="#12307" class="Record Operator">]</a>
  <a id="14738" href="#12397" class="Field Operator">[</a> <a id="14740" href="#14711" class="Function">∫′</a> <a id="14743" href="#14743" class="Bound">f</a> <a id="14745" href="#12397" class="Field Operator">]-set</a> <a id="14751" class="Symbol">=</a> <a id="14753" href="../code/probability/ProbabilityModule.Semirings.html#641" class="Field">sIsSet</a>
  <a id="14762" href="#12420" class="Field Operator">[</a> <a id="14764" href="#14711" class="Function">∫′</a> <a id="14767" href="#14767" class="Bound">f</a> <a id="14769" href="#12420" class="Field Operator">]</a> <a id="14771" href="#14771" class="Bound">p</a> <a id="14773" href="#12420" class="Field Operator">&amp;</a> <a id="14775" href="#14775" class="Bound">x</a> <a id="14777" href="#12420" class="Field Operator">∷</a> <a id="14779" href="#14779" class="Bound">xs</a> <a id="14782" class="Symbol">=</a> <a id="14784" href="#14771" class="Bound">p</a> <a id="14786" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="14788" href="#14767" class="Bound">f</a> <a id="14790" href="#14775" class="Bound">x</a> <a id="14792" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="14794" href="#14779" class="Bound">xs</a>
  <a id="14799" href="#12449" class="Field Operator">[</a> <a id="14801" href="#14711" class="Function">∫′</a> <a id="14804" href="#14804" class="Bound">f</a> <a id="14806" href="#12449" class="Field Operator">][]</a> <a id="14810" class="Symbol">=</a> <a id="14812" href="../code/probability/ProbabilityModule.Semirings.html#254" class="Field">0#</a>
  <a id="14817" href="#12508" class="Field Operator">[</a> <a id="14819" href="#14711" class="Function">∫′</a> <a id="14822" href="#14822" class="Bound">f</a> <a id="14824" href="#12508" class="Field Operator">]-dup</a> <a id="14830" href="#14830" class="Bound">p</a> <a id="14832" href="#14832" class="Bound">q</a> <a id="14834" href="#14834" class="Bound">x</a> <a id="14836" href="#14836" class="Bound">xs</a> <a id="14839" class="Symbol">=</a>
    <a id="14845" href="#14830" class="Bound">p</a> <a id="14847" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="14849" href="#14822" class="Bound">f</a> <a id="14851" href="#14834" class="Bound">x</a> <a id="14853" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="14855" class="Symbol">(</a><a id="14856" href="#14832" class="Bound">q</a> <a id="14858" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="14860" href="#14822" class="Bound">f</a> <a id="14862" href="#14834" class="Bound">x</a> <a id="14864" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="14866" href="#14836" class="Bound">xs</a><a id="14868" class="Symbol">)</a> <a id="14870" href="../code/probability/ProbabilityModule.Utils.html#295" class="Function">≡˘⟨</a> <a id="14874" href="../code/probability/ProbabilityModule.Semirings.html#276" class="Field">+-assoc</a> <a id="14882" class="Symbol">(</a><a id="14883" href="#14830" class="Bound">p</a> <a id="14885" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="14887" href="#14822" class="Bound">f</a> <a id="14889" href="#14834" class="Bound">x</a><a id="14890" class="Symbol">)</a> <a id="14892" class="Symbol">(</a><a id="14893" href="#14832" class="Bound">q</a> <a id="14895" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="14897" href="#14822" class="Bound">f</a> <a id="14899" href="#14834" class="Bound">x</a><a id="14900" class="Symbol">)</a> <a id="14902" href="#14836" class="Bound">xs</a> <a id="14905" href="../code/probability/ProbabilityModule.Utils.html#295" class="Function">⟩</a>
    <a id="14911" class="Symbol">(</a><a id="14912" href="#14830" class="Bound">p</a> <a id="14914" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="14916" href="#14822" class="Bound">f</a> <a id="14918" href="#14834" class="Bound">x</a> <a id="14920" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="14922" href="#14832" class="Bound">q</a> <a id="14924" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="14926" href="#14822" class="Bound">f</a> <a id="14928" href="#14834" class="Bound">x</a><a id="14929" class="Symbol">)</a> <a id="14931" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="14933" href="#14836" class="Bound">xs</a> <a id="14936" href="../code/probability/ProbabilityModule.Utils.html#295" class="Function">≡˘⟨</a> <a id="14940" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="14945" class="Symbol">(</a><a id="14946" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">_+</a> <a id="14949" href="#14836" class="Bound">xs</a><a id="14951" class="Symbol">)</a> <a id="14953" class="Symbol">(</a><a id="14954" href="../code/probability/ProbabilityModule.Semirings.html#592" class="Field">⟨+⟩*</a> <a id="14959" href="#14830" class="Bound">p</a> <a id="14961" href="#14832" class="Bound">q</a> <a id="14963" class="Symbol">(</a><a id="14964" href="#14822" class="Bound">f</a> <a id="14966" href="#14834" class="Bound">x</a><a id="14967" class="Symbol">))</a> <a id="14970" href="../code/probability/ProbabilityModule.Utils.html#295" class="Function">⟩</a>
    <a id="14976" class="Symbol">(</a><a id="14977" href="#14830" class="Bound">p</a> <a id="14979" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="14981" href="#14832" class="Bound">q</a><a id="14982" class="Symbol">)</a> <a id="14984" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="14986" href="#14822" class="Bound">f</a> <a id="14988" href="#14834" class="Bound">x</a> <a id="14990" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="14992" href="#14836" class="Bound">xs</a> <a id="14995" href="../code/probability/Cubical.Foundations.Prelude.html#2745" class="Function Operator">∎</a>
  <a id="14999" href="#12570" class="Field Operator">[</a> <a id="15001" href="#14711" class="Function">∫′</a> <a id="15004" href="#15004" class="Bound">f</a> <a id="15006" href="#12570" class="Field Operator">]-com</a> <a id="15012" href="#15012" class="Bound">p</a> <a id="15014" href="#15014" class="Bound">x</a> <a id="15016" href="#15016" class="Bound">q</a> <a id="15018" href="#15018" class="Bound">y</a> <a id="15020" href="#15020" class="Bound">xs</a> <a id="15023" class="Symbol">=</a>
    <a id="15029" href="#15012" class="Bound">p</a> <a id="15031" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="15033" href="#15004" class="Bound">f</a> <a id="15035" href="#15014" class="Bound">x</a> <a id="15037" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="15039" class="Symbol">(</a><a id="15040" href="#15016" class="Bound">q</a> <a id="15042" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="15044" href="#15004" class="Bound">f</a> <a id="15046" href="#15018" class="Bound">y</a> <a id="15048" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="15050" href="#15020" class="Bound">xs</a><a id="15052" class="Symbol">)</a> <a id="15054" href="../code/probability/ProbabilityModule.Utils.html#295" class="Function">≡˘⟨</a> <a id="15058" href="../code/probability/ProbabilityModule.Semirings.html#276" class="Field">+-assoc</a> <a id="15066" class="Symbol">(</a><a id="15067" href="#15012" class="Bound">p</a> <a id="15069" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="15071" href="#15004" class="Bound">f</a> <a id="15073" href="#15014" class="Bound">x</a><a id="15074" class="Symbol">)</a> <a id="15076" class="Symbol">(</a><a id="15077" href="#15016" class="Bound">q</a> <a id="15079" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="15081" href="#15004" class="Bound">f</a> <a id="15083" href="#15018" class="Bound">y</a><a id="15084" class="Symbol">)</a> <a id="15086" class="Symbol">(</a><a id="15087" href="#15020" class="Bound">xs</a><a id="15089" class="Symbol">)</a> <a id="15091" href="../code/probability/ProbabilityModule.Utils.html#295" class="Function">⟩</a>
    <a id="15097" href="#15012" class="Bound">p</a> <a id="15099" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="15101" href="#15004" class="Bound">f</a> <a id="15103" href="#15014" class="Bound">x</a> <a id="15105" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="15107" href="#15016" class="Bound">q</a> <a id="15109" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="15111" href="#15004" class="Bound">f</a> <a id="15113" href="#15018" class="Bound">y</a> <a id="15115" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="15117" href="#15020" class="Bound">xs</a>   <a id="15122" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">≡⟨</a> <a id="15125" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="15130" class="Symbol">(</a><a id="15131" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">_+</a> <a id="15134" href="#15020" class="Bound">xs</a><a id="15136" class="Symbol">)</a> <a id="15138" class="Symbol">(</a><a id="15139" href="../code/probability/ProbabilityModule.Semirings.html#508" class="Field">+-comm</a> <a id="15146" class="Symbol">(</a><a id="15147" href="#15012" class="Bound">p</a> <a id="15149" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="15151" href="#15004" class="Bound">f</a> <a id="15153" href="#15014" class="Bound">x</a><a id="15154" class="Symbol">)</a> <a id="15156" class="Symbol">(</a><a id="15157" href="#15016" class="Bound">q</a> <a id="15159" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="15161" href="#15004" class="Bound">f</a> <a id="15163" href="#15018" class="Bound">y</a><a id="15164" class="Symbol">))</a> <a id="15167" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">⟩</a>
    <a id="15173" href="#15016" class="Bound">q</a> <a id="15175" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="15177" href="#15004" class="Bound">f</a> <a id="15179" href="#15018" class="Bound">y</a> <a id="15181" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="15183" href="#15012" class="Bound">p</a> <a id="15185" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="15187" href="#15004" class="Bound">f</a> <a id="15189" href="#15014" class="Bound">x</a> <a id="15191" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="15193" href="#15020" class="Bound">xs</a>   <a id="15198" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">≡⟨</a> <a id="15201" href="../code/probability/ProbabilityModule.Semirings.html#276" class="Field">+-assoc</a> <a id="15209" class="Symbol">(</a><a id="15210" href="#15016" class="Bound">q</a> <a id="15212" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="15214" href="#15004" class="Bound">f</a> <a id="15216" href="#15018" class="Bound">y</a><a id="15217" class="Symbol">)</a> <a id="15219" class="Symbol">(</a><a id="15220" href="#15012" class="Bound">p</a> <a id="15222" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="15224" href="#15004" class="Bound">f</a> <a id="15226" href="#15014" class="Bound">x</a><a id="15227" class="Symbol">)</a> <a id="15229" class="Symbol">(</a><a id="15230" href="#15020" class="Bound">xs</a><a id="15232" class="Symbol">)</a> <a id="15234" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">⟩</a>
    <a id="15240" href="#15016" class="Bound">q</a> <a id="15242" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="15244" href="#15004" class="Bound">f</a> <a id="15246" href="#15018" class="Bound">y</a> <a id="15248" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="15250" class="Symbol">(</a><a id="15251" href="#15012" class="Bound">p</a> <a id="15253" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="15255" href="#15004" class="Bound">f</a> <a id="15257" href="#15014" class="Bound">x</a> <a id="15259" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="15261" href="#15020" class="Bound">xs</a><a id="15263" class="Symbol">)</a> <a id="15265" href="../code/probability/Cubical.Foundations.Prelude.html#2745" class="Function Operator">∎</a>
  <a id="15269" href="#12635" class="Field Operator">[</a> <a id="15271" href="#14711" class="Function">∫′</a> <a id="15274" href="#15274" class="Bound">f</a> <a id="15276" href="#12635" class="Field Operator">]-del</a> <a id="15282" href="#15282" class="Bound">x</a> <a id="15284" href="#15284" class="Bound">xs</a> <a id="15287" class="Symbol">=</a>
    <a id="15293" href="../code/probability/ProbabilityModule.Semirings.html#254" class="Field">0#</a> <a id="15296" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="15298" href="#15274" class="Bound">f</a> <a id="15300" href="#15282" class="Bound">x</a> <a id="15302" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="15304" href="#15284" class="Bound">xs</a> <a id="15307" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">≡⟨</a> <a id="15310" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="15315" class="Symbol">(</a><a id="15316" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">_+</a> <a id="15319" href="#15284" class="Bound">xs</a><a id="15321" class="Symbol">)</a> <a id="15323" class="Symbol">(</a><a id="15324" href="../code/probability/ProbabilityModule.Semirings.html#403" class="Field">0*</a> <a id="15327" class="Symbol">(</a><a id="15328" href="#15274" class="Bound">f</a> <a id="15330" href="#15282" class="Bound">x</a><a id="15331" class="Symbol">))</a> <a id="15334" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">⟩</a>
    <a id="15340" href="../code/probability/ProbabilityModule.Semirings.html#254" class="Field">0#</a> <a id="15343" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="15345" href="#15284" class="Bound">xs</a>       <a id="15354" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">≡⟨</a> <a id="15357" href="../code/probability/ProbabilityModule.Semirings.html#430" class="Field">0+</a> <a id="15360" class="Symbol">(</a><a id="15361" href="#15284" class="Bound">xs</a><a id="15363" class="Symbol">)</a> <a id="15365" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">⟩</a>
    <a id="15371" href="#15284" class="Bound">xs</a>            <a id="15385" href="../code/probability/Cubical.Foundations.Prelude.html#2745" class="Function Operator">∎</a>

<a id="15388" class="Keyword">syntax</a> <a id="15395" href="#14645" class="Function">∫</a> <a id="15397" class="Symbol">(λ</a> <a id="15400" class="Bound">x</a> <a id="15402" class="Symbol">→</a> <a id="15404" class="Bound">e</a><a id="15405" class="Symbol">)</a> <a id="15407" class="Symbol">=</a> <a id="15409" class="Function">∫</a> <a id="15411" class="Bound">e</a> <a id="15413" class="Function">𝑑</a> <a id="15415" class="Bound">x</a>

<a id="pure"></a><a id="15418" href="#15418" class="Function">pure</a> <a id="15423" class="Symbol">:</a> <a id="15425" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="15427" class="Symbol">→</a> <a id="15429" href="#8679" class="Datatype">𝒫</a> <a id="15431" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a>
<a id="15433" href="#15418" class="Function">pure</a> <a id="15438" href="#15438" class="Bound">x</a> <a id="15440" class="Symbol">=</a> <a id="15442" href="../code/probability/ProbabilityModule.Semirings.html#265" class="Field">1#</a> <a id="15445" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="15447" href="#15438" class="Bound">x</a> <a id="15449" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="15451" href="#8715" class="InductiveConstructor">[]</a>

<a id="∪-cons"></a><a id="15455" href="#15455" class="Function">∪-cons</a> <a id="15462" class="Symbol">:</a> <a id="15464" class="Symbol">∀</a> <a id="15466" href="#15466" class="Bound">p</a> <a id="15468" class="Symbol">(</a><a id="15469" href="#15469" class="Bound">x</a> <a id="15471" class="Symbol">:</a> <a id="15473" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a><a id="15474" class="Symbol">)</a> <a id="15476" href="#15476" class="Bound">xs</a> <a id="15479" href="#15479" class="Bound">ys</a> <a id="15482" class="Symbol">→</a> <a id="15484" href="#15476" class="Bound">xs</a> <a id="15487" href="#13390" class="Function Operator">∪</a> <a id="15489" href="#15466" class="Bound">p</a> <a id="15491" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="15493" href="#15469" class="Bound">x</a> <a id="15495" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="15497" href="#15479" class="Bound">ys</a> <a id="15500" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">≡</a> <a id="15502" href="#15466" class="Bound">p</a> <a id="15504" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="15506" href="#15469" class="Bound">x</a> <a id="15508" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="15510" href="#15476" class="Bound">xs</a> <a id="15513" href="#13390" class="Function Operator">∪</a> <a id="15515" href="#15479" class="Bound">ys</a>
<a id="15518" href="#15455" class="Function">∪-cons</a> <a id="15525" class="Symbol">=</a> <a id="15527" class="Symbol">λ</a> <a id="15529" href="#15529" class="Bound">p</a> <a id="15531" href="#15531" class="Bound">x</a> <a id="15533" href="#15533" class="Bound">xs</a> <a id="15536" href="#15536" class="Bound">ys</a> <a id="15539" class="Symbol">→</a> <a id="15541" href="#12103" class="Function Operator">⟦</a> <a id="15543" href="#15587" class="Function">∪-cons′</a> <a id="15551" href="#15529" class="Bound">p</a> <a id="15553" href="#15531" class="Bound">x</a> <a id="15555" href="#15536" class="Bound">ys</a> <a id="15558" href="#12103" class="Function Operator">⟧⇓</a> <a id="15561" href="#15533" class="Bound">xs</a>
  <a id="15566" class="Keyword">module</a> <a id="UCons"></a><a id="15573" href="#15573" class="Module">UCons</a> <a id="15579" class="Keyword">where</a>
  <a id="UCons.∪-cons′"></a><a id="15587" href="#15587" class="Function">∪-cons′</a> <a id="15595" class="Symbol">:</a> <a id="15597" class="Symbol">∀</a> <a id="15599" href="#15599" class="Bound">p</a> <a id="15601" href="#15601" class="Bound">x</a> <a id="15603" href="#15603" class="Bound">ys</a> <a id="15606" class="Symbol">→</a> <a id="15608" href="#12139" class="Function">⟦</a> <a id="15610" href="#15610" class="Bound">xs</a> <a id="15613" href="#12139" class="Function">∈𝒫</a> <a id="15616" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="15618" href="#12139" class="Function">⇒</a> <a id="15620" href="#15610" class="Bound">xs</a> <a id="15623" href="#13390" class="Function Operator">∪</a> <a id="15625" href="#15599" class="Bound">p</a> <a id="15627" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="15629" href="#15601" class="Bound">x</a> <a id="15631" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="15633" href="#15603" class="Bound">ys</a> <a id="15636" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">≡</a> <a id="15638" href="#15599" class="Bound">p</a> <a id="15640" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="15642" href="#15601" class="Bound">x</a> <a id="15644" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="15646" href="#15610" class="Bound">xs</a> <a id="15649" href="#13390" class="Function Operator">∪</a> <a id="15651" href="#15603" class="Bound">ys</a> <a id="15654" href="#12139" class="Function">⟧</a>
  <a id="15658" href="#11443" class="Field Operator">⟦</a> <a id="15660" href="#15587" class="Function">∪-cons′</a> <a id="15668" href="#15668" class="Bound">p</a> <a id="15670" href="#15670" class="Bound">x</a> <a id="15672" href="#15672" class="Bound">ys</a> <a id="15675" href="#11443" class="Field Operator">⟧-prop</a> <a id="15682" class="Symbol">=</a> <a id="15684" href="#8921" class="InductiveConstructor">trunc</a> <a id="15690" class="Symbol">_</a> <a id="15692" class="Symbol">_</a>
  <a id="15696" href="#11481" class="Field Operator">⟦</a> <a id="15698" href="#15587" class="Function">∪-cons′</a> <a id="15706" href="#15706" class="Bound">p</a> <a id="15708" href="#15708" class="Bound">x</a> <a id="15710" href="#15710" class="Bound">ys</a> <a id="15713" href="#11481" class="Field Operator">⟧[]</a> <a id="15717" class="Symbol">=</a> <a id="15719" href="../code/probability/Cubical.Foundations.Prelude.html#827" class="Function">refl</a>
  <a id="15726" href="#11498" class="Field Operator">⟦</a> <a id="15728" href="#15587" class="Function">∪-cons′</a> <a id="15736" href="#15736" class="Bound">p</a> <a id="15738" href="#15738" class="Bound">x</a> <a id="15740" href="#15740" class="Bound">ys</a> <a id="15743" href="#11498" class="Field Operator">⟧</a> <a id="15745" href="#15745" class="Bound">r</a> <a id="15747" href="#11498" class="Field Operator">&amp;</a> <a id="15749" href="#15749" class="Bound">y</a> <a id="15751" href="#11498" class="Field Operator">∷</a> <a id="15753" href="#15753" class="Bound">xs</a> <a id="15756" href="#11498" class="Field Operator">⟨</a> <a id="15758" href="#15758" class="Bound">P</a> <a id="15760" href="#11498" class="Field Operator">⟩</a> <a id="15762" class="Symbol">=</a> <a id="15764" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="15769" class="Symbol">(</a><a id="15770" href="#15745" class="Bound">r</a> <a id="15772" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="15774" href="#15749" class="Bound">y</a> <a id="15776" href="#8727" class="InductiveConstructor Operator">∷_</a><a id="15778" class="Symbol">)</a> <a id="15780" href="#15758" class="Bound">P</a> <a id="15782" href="../code/probability/Cubical.Foundations.Prelude.html#1674" class="Function Operator">;</a> <a id="15784" href="#8824" class="InductiveConstructor">com</a> <a id="15788" href="#15745" class="Bound">r</a> <a id="15790" href="#15749" class="Bound">y</a> <a id="15792" href="#15736" class="Bound">p</a> <a id="15794" href="#15738" class="Bound">x</a> <a id="15796" class="Symbol">(</a><a id="15797" href="#15753" class="Bound">xs</a> <a id="15800" href="#13390" class="Function Operator">∪</a> <a id="15802" href="#15740" class="Bound">ys</a><a id="15804" class="Symbol">)</a>

<a id="⋊-distribʳ"></a><a id="15807" href="#15807" class="Function">⋊-distribʳ</a> <a id="15818" class="Symbol">:</a> <a id="15820" class="Symbol">∀</a> <a id="15822" href="#15822" class="Bound">p</a> <a id="15824" href="#15824" class="Bound">q</a> <a id="15826" class="Symbol">→</a> <a id="15828" class="Symbol">(</a><a id="15829" href="#15829" class="Bound">xs</a> <a id="15832" class="Symbol">:</a> <a id="15834" href="#8679" class="Datatype">𝒫</a> <a id="15836" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a><a id="15837" class="Symbol">)</a> <a id="15839" class="Symbol">→</a> <a id="15841" href="#15822" class="Bound">p</a> <a id="15843" href="#14109" class="Function Operator">⋊</a> <a id="15845" href="#15829" class="Bound">xs</a> <a id="15848" href="#13390" class="Function Operator">∪</a> <a id="15850" href="#15824" class="Bound">q</a> <a id="15852" href="#14109" class="Function Operator">⋊</a> <a id="15854" href="#15829" class="Bound">xs</a> <a id="15857" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">≡</a> <a id="15859" class="Symbol">(</a><a id="15860" href="#15822" class="Bound">p</a> <a id="15862" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="15864" href="#15824" class="Bound">q</a><a id="15865" class="Symbol">)</a> <a id="15867" href="#14109" class="Function Operator">⋊</a> <a id="15869" href="#15829" class="Bound">xs</a>
<a id="15872" href="#15807" class="Function">⋊-distribʳ</a> <a id="15883" class="Symbol">=</a> <a id="15885" class="Symbol">λ</a> <a id="15887" href="#15887" class="Bound">p</a> <a id="15889" href="#15889" class="Bound">q</a> <a id="15891" class="Symbol">→</a> <a id="15893" href="#12103" class="Function Operator">⟦</a> <a id="15895" href="#15940" class="Function">⋊-distribʳ′</a> <a id="15907" href="#15887" class="Bound">p</a> <a id="15909" href="#15889" class="Bound">q</a> <a id="15911" href="#12103" class="Function Operator">⟧⇓</a>
  <a id="15916" class="Keyword">module</a> <a id="JDistrib"></a><a id="15923" href="#15923" class="Module">JDistrib</a> <a id="15932" class="Keyword">where</a>
  <a id="JDistrib.⋊-distribʳ′"></a><a id="15940" href="#15940" class="Function">⋊-distribʳ′</a> <a id="15952" class="Symbol">:</a> <a id="15954" class="Symbol">∀</a> <a id="15956" href="#15956" class="Bound">p</a> <a id="15958" href="#15958" class="Bound">q</a> <a id="15960" class="Symbol">→</a> <a id="15962" href="#12139" class="Function">⟦</a> <a id="15964" href="#15964" class="Bound">xs</a> <a id="15967" href="#12139" class="Function">∈𝒫</a> <a id="15970" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="15972" href="#12139" class="Function">⇒</a> <a id="15974" href="#15956" class="Bound">p</a> <a id="15976" href="#14109" class="Function Operator">⋊</a> <a id="15978" href="#15964" class="Bound">xs</a> <a id="15981" href="#13390" class="Function Operator">∪</a> <a id="15983" href="#15958" class="Bound">q</a> <a id="15985" href="#14109" class="Function Operator">⋊</a> <a id="15987" href="#15964" class="Bound">xs</a> <a id="15990" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">≡</a> <a id="15992" class="Symbol">(</a><a id="15993" href="#15956" class="Bound">p</a> <a id="15995" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="15997" href="#15958" class="Bound">q</a><a id="15998" class="Symbol">)</a> <a id="16000" href="#14109" class="Function Operator">⋊</a> <a id="16002" href="#15964" class="Bound">xs</a> <a id="16005" href="#12139" class="Function">⟧</a>
  <a id="16009" href="#11443" class="Field Operator">⟦</a> <a id="16011" href="#15940" class="Function">⋊-distribʳ′</a> <a id="16023" href="#16023" class="Bound">p</a> <a id="16025" href="#16025" class="Bound">q</a> <a id="16027" href="#11443" class="Field Operator">⟧-prop</a> <a id="16034" class="Symbol">=</a> <a id="16036" href="#8921" class="InductiveConstructor">trunc</a> <a id="16042" class="Symbol">_</a> <a id="16044" class="Symbol">_</a>
  <a id="16048" href="#11481" class="Field Operator">⟦</a> <a id="16050" href="#15940" class="Function">⋊-distribʳ′</a> <a id="16062" href="#16062" class="Bound">p</a> <a id="16064" href="#16064" class="Bound">q</a> <a id="16066" href="#11481" class="Field Operator">⟧[]</a> <a id="16070" class="Symbol">=</a> <a id="16072" href="../code/probability/Cubical.Foundations.Prelude.html#827" class="Function">refl</a>
  <a id="16079" href="#11498" class="Field Operator">⟦</a> <a id="16081" href="#15940" class="Function">⋊-distribʳ′</a> <a id="16093" href="#16093" class="Bound">p</a> <a id="16095" href="#16095" class="Bound">q</a> <a id="16097" href="#11498" class="Field Operator">⟧</a> <a id="16099" href="#16099" class="Bound">r</a> <a id="16101" href="#11498" class="Field Operator">&amp;</a> <a id="16103" href="#16103" class="Bound">x</a> <a id="16105" href="#11498" class="Field Operator">∷</a> <a id="16107" href="#16107" class="Bound">xs</a> <a id="16110" href="#11498" class="Field Operator">⟨</a> <a id="16112" href="#16112" class="Bound">P</a> <a id="16114" href="#11498" class="Field Operator">⟩</a> <a id="16116" class="Symbol">=</a>
    <a id="16122" href="#16093" class="Bound">p</a> <a id="16124" href="#14109" class="Function Operator">⋊</a> <a id="16126" class="Symbol">(</a><a id="16127" href="#16099" class="Bound">r</a> <a id="16129" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="16131" href="#16103" class="Bound">x</a> <a id="16133" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="16135" href="#16107" class="Bound">xs</a><a id="16137" class="Symbol">)</a> <a id="16139" href="#13390" class="Function Operator">∪</a> <a id="16141" href="#16095" class="Bound">q</a> <a id="16143" href="#14109" class="Function Operator">⋊</a> <a id="16145" class="Symbol">(</a><a id="16146" href="#16099" class="Bound">r</a> <a id="16148" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="16150" href="#16103" class="Bound">x</a> <a id="16152" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="16154" href="#16107" class="Bound">xs</a><a id="16156" class="Symbol">)</a>   <a id="16160" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">≡⟨</a> <a id="16163" href="#15455" class="Function">∪-cons</a> <a id="16170" class="Symbol">(</a><a id="16171" href="#16095" class="Bound">q</a> <a id="16173" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="16175" href="#16099" class="Bound">r</a><a id="16176" class="Symbol">)</a> <a id="16178" href="#16103" class="Bound">x</a> <a id="16180" class="Symbol">(</a><a id="16181" href="#16093" class="Bound">p</a> <a id="16183" href="#14109" class="Function Operator">⋊</a> <a id="16185" class="Symbol">(</a><a id="16186" href="#16099" class="Bound">r</a> <a id="16188" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="16190" href="#16103" class="Bound">x</a> <a id="16192" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="16194" href="#16107" class="Bound">xs</a><a id="16196" class="Symbol">))</a> <a id="16199" class="Symbol">(</a><a id="16200" href="#16095" class="Bound">q</a> <a id="16202" href="#14109" class="Function Operator">⋊</a> <a id="16204" href="#16107" class="Bound">xs</a><a id="16206" class="Symbol">)</a>  <a id="16209" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">⟩</a>
    <a id="16215" href="#16095" class="Bound">q</a> <a id="16217" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="16219" href="#16099" class="Bound">r</a> <a id="16221" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="16223" href="#16103" class="Bound">x</a> <a id="16225" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="16227" href="#16093" class="Bound">p</a> <a id="16229" href="#14109" class="Function Operator">⋊</a> <a id="16231" class="Symbol">(</a><a id="16232" href="#16099" class="Bound">r</a> <a id="16234" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="16236" href="#16103" class="Bound">x</a> <a id="16238" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="16240" href="#16107" class="Bound">xs</a><a id="16242" class="Symbol">)</a> <a id="16244" href="#13390" class="Function Operator">∪</a> <a id="16246" href="#16095" class="Bound">q</a> <a id="16248" href="#14109" class="Function Operator">⋊</a> <a id="16250" href="#16107" class="Bound">xs</a> <a id="16253" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">≡⟨</a> <a id="16256" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="16261" class="Symbol">(</a><a id="16262" href="#13390" class="Function Operator">_∪</a> <a id="16265" href="#16095" class="Bound">q</a> <a id="16267" href="#14109" class="Function Operator">⋊</a> <a id="16269" href="#16107" class="Bound">xs</a><a id="16271" class="Symbol">)</a> <a id="16273" class="Symbol">(</a><a id="16274" href="#8767" class="InductiveConstructor">dup</a> <a id="16278" class="Symbol">(</a><a id="16279" href="#16095" class="Bound">q</a> <a id="16281" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="16283" href="#16099" class="Bound">r</a><a id="16284" class="Symbol">)</a> <a id="16286" class="Symbol">(</a><a id="16287" href="#16093" class="Bound">p</a> <a id="16289" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="16291" href="#16099" class="Bound">r</a><a id="16292" class="Symbol">)</a> <a id="16294" href="#16103" class="Bound">x</a> <a id="16296" class="Symbol">(</a><a id="16297" href="#16093" class="Bound">p</a> <a id="16299" href="#14109" class="Function Operator">⋊</a> <a id="16301" href="#16107" class="Bound">xs</a><a id="16303" class="Symbol">))</a> <a id="16306" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">⟩</a>
    <a id="16312" href="#16095" class="Bound">q</a> <a id="16314" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="16316" href="#16099" class="Bound">r</a> <a id="16318" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="16320" href="#16093" class="Bound">p</a> <a id="16322" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="16324" href="#16099" class="Bound">r</a> <a id="16326" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="16328" href="#16103" class="Bound">x</a> <a id="16330" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="16332" href="#16093" class="Bound">p</a> <a id="16334" href="#14109" class="Function Operator">⋊</a> <a id="16336" href="#16107" class="Bound">xs</a> <a id="16339" href="#13390" class="Function Operator">∪</a> <a id="16341" href="#16095" class="Bound">q</a> <a id="16343" href="#14109" class="Function Operator">⋊</a> <a id="16345" href="#16107" class="Bound">xs</a>   <a id="16350" href="../code/probability/ProbabilityModule.Utils.html#295" class="Function">≡˘⟨</a> <a id="16354" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="16359" class="Symbol">(</a><a id="16360" href="#8727" class="InductiveConstructor Operator">_&amp;</a> <a id="16363" href="#16103" class="Bound">x</a> <a id="16365" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="16367" class="Symbol">(</a><a id="16368" href="#16093" class="Bound">p</a> <a id="16370" href="#14109" class="Function Operator">⋊</a> <a id="16372" href="#16107" class="Bound">xs</a> <a id="16375" href="#13390" class="Function Operator">∪</a> <a id="16377" href="#16095" class="Bound">q</a> <a id="16379" href="#14109" class="Function Operator">⋊</a> <a id="16381" href="#16107" class="Bound">xs</a><a id="16383" class="Symbol">))</a> <a id="16386" class="Symbol">(</a><a id="16387" href="../code/probability/ProbabilityModule.Semirings.html#592" class="Field">⟨+⟩*</a> <a id="16392" href="#16095" class="Bound">q</a> <a id="16394" href="#16093" class="Bound">p</a> <a id="16396" href="#16099" class="Bound">r</a><a id="16397" class="Symbol">)</a> <a id="16399" href="../code/probability/ProbabilityModule.Utils.html#295" class="Function">⟩</a>
    <a id="16405" class="Symbol">(</a><a id="16406" href="#16095" class="Bound">q</a> <a id="16408" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="16410" href="#16093" class="Bound">p</a><a id="16411" class="Symbol">)</a> <a id="16413" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="16415" href="#16099" class="Bound">r</a> <a id="16417" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="16419" href="#16103" class="Bound">x</a> <a id="16421" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="16423" href="#16093" class="Bound">p</a> <a id="16425" href="#14109" class="Function Operator">⋊</a> <a id="16427" href="#16107" class="Bound">xs</a> <a id="16430" href="#13390" class="Function Operator">∪</a> <a id="16432" href="#16095" class="Bound">q</a> <a id="16434" href="#14109" class="Function Operator">⋊</a> <a id="16436" href="#16107" class="Bound">xs</a>     <a id="16443" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">≡⟨</a> <a id="16446" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="16451" class="Symbol">((</a><a id="16453" href="#16095" class="Bound">q</a> <a id="16455" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="16457" href="#16093" class="Bound">p</a><a id="16458" class="Symbol">)</a> <a id="16460" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="16462" href="#16099" class="Bound">r</a> <a id="16464" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="16466" href="#16103" class="Bound">x</a> <a id="16468" href="#8727" class="InductiveConstructor Operator">∷_</a><a id="16470" class="Symbol">)</a> <a id="16472" href="#16112" class="Bound">P</a> <a id="16474" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">⟩</a>
    <a id="16480" class="Symbol">(</a><a id="16481" href="#16095" class="Bound">q</a> <a id="16483" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="16485" href="#16093" class="Bound">p</a><a id="16486" class="Symbol">)</a> <a id="16488" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="16490" href="#16099" class="Bound">r</a> <a id="16492" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="16494" href="#16103" class="Bound">x</a> <a id="16496" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="16498" class="Symbol">(</a><a id="16499" href="#16093" class="Bound">p</a> <a id="16501" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="16503" href="#16095" class="Bound">q</a><a id="16504" class="Symbol">)</a> <a id="16506" href="#14109" class="Function Operator">⋊</a> <a id="16508" href="#16107" class="Bound">xs</a>        <a id="16518" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">≡⟨</a> <a id="16521" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="16526" class="Symbol">(λ</a> <a id="16529" href="#16529" class="Bound">pq</a> <a id="16532" class="Symbol">→</a> <a id="16534" href="#16529" class="Bound">pq</a> <a id="16537" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="16539" href="#16099" class="Bound">r</a> <a id="16541" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="16543" href="#16103" class="Bound">x</a> <a id="16545" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="16547" class="Symbol">(</a><a id="16548" href="#16093" class="Bound">p</a> <a id="16550" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="16552" href="#16095" class="Bound">q</a><a id="16553" class="Symbol">)</a> <a id="16555" href="#14109" class="Function Operator">⋊</a> <a id="16557" href="#16107" class="Bound">xs</a><a id="16559" class="Symbol">)</a> <a id="16561" class="Symbol">(</a><a id="16562" href="../code/probability/ProbabilityModule.Semirings.html#508" class="Field">+-comm</a> <a id="16569" href="#16095" class="Bound">q</a> <a id="16571" href="#16093" class="Bound">p</a><a id="16572" class="Symbol">)</a> <a id="16574" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">⟩</a>
    <a id="16580" class="Symbol">(</a><a id="16581" href="#16093" class="Bound">p</a> <a id="16583" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="16585" href="#16095" class="Bound">q</a><a id="16586" class="Symbol">)</a> <a id="16588" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="16590" href="#16099" class="Bound">r</a> <a id="16592" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="16594" href="#16103" class="Bound">x</a> <a id="16596" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="16598" class="Symbol">(</a><a id="16599" href="#16093" class="Bound">p</a> <a id="16601" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="16603" href="#16095" class="Bound">q</a><a id="16604" class="Symbol">)</a> <a id="16606" href="#14109" class="Function Operator">⋊</a> <a id="16608" href="#16107" class="Bound">xs</a>        <a id="16618" href="../code/probability/ProbabilityModule.Utils.html#572" class="Function Operator">≡⟨⟩</a>
    <a id="16626" href="#14109" class="Function Operator">_⋊_</a> <a id="16630" class="Symbol">(</a><a id="16631" href="#16093" class="Bound">p</a> <a id="16633" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="16635" href="#16095" class="Bound">q</a><a id="16636" class="Symbol">)</a> <a id="16638" class="Symbol">(</a><a id="16639" href="#16099" class="Bound">r</a> <a id="16641" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="16643" href="#16103" class="Bound">x</a> <a id="16645" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="16647" href="#16107" class="Bound">xs</a><a id="16649" class="Symbol">)</a> <a id="16651" href="../code/probability/Cubical.Foundations.Prelude.html#2745" class="Function Operator">∎</a>

<a id="⋊-distribˡ"></a><a id="16654" href="#16654" class="Function">⋊-distribˡ</a> <a id="16665" class="Symbol">:</a> <a id="16667" class="Symbol">∀</a> <a id="16669" href="#16669" class="Bound">p</a> <a id="16671" class="Symbol">→</a> <a id="16673" class="Symbol">(</a><a id="16674" href="#16674" class="Bound">xs</a> <a id="16677" href="#16677" class="Bound">ys</a> <a id="16680" class="Symbol">:</a> <a id="16682" href="#8679" class="Datatype">𝒫</a> <a id="16684" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a><a id="16685" class="Symbol">)</a> <a id="16687" class="Symbol">→</a> <a id="16689" href="#16669" class="Bound">p</a> <a id="16691" href="#14109" class="Function Operator">⋊</a> <a id="16693" href="#16674" class="Bound">xs</a> <a id="16696" href="#13390" class="Function Operator">∪</a> <a id="16698" href="#16669" class="Bound">p</a> <a id="16700" href="#14109" class="Function Operator">⋊</a> <a id="16702" href="#16677" class="Bound">ys</a> <a id="16705" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">≡</a> <a id="16707" href="#16669" class="Bound">p</a> <a id="16709" href="#14109" class="Function Operator">⋊</a> <a id="16711" class="Symbol">(</a><a id="16712" href="#16674" class="Bound">xs</a> <a id="16715" href="#13390" class="Function Operator">∪</a> <a id="16717" href="#16677" class="Bound">ys</a><a id="16719" class="Symbol">)</a>
<a id="16721" href="#16654" class="Function">⋊-distribˡ</a> <a id="16732" class="Symbol">=</a> <a id="16734" class="Symbol">λ</a> <a id="16736" href="#16736" class="Bound">p</a> <a id="16738" href="#16738" class="Bound">xs</a> <a id="16741" href="#16741" class="Bound">ys</a> <a id="16744" class="Symbol">→</a> <a id="16746" href="#12103" class="Function Operator">⟦</a> <a id="16748" href="#16798" class="Function">⋊-distribˡ′</a> <a id="16760" href="#16736" class="Bound">p</a> <a id="16762" href="#16741" class="Bound">ys</a> <a id="16765" href="#12103" class="Function Operator">⟧⇓</a> <a id="16768" href="#16738" class="Bound">xs</a>
  <a id="16773" class="Keyword">module</a> <a id="JDistribL"></a><a id="16780" href="#16780" class="Module">JDistribL</a> <a id="16790" class="Keyword">where</a>
  <a id="JDistribL.⋊-distribˡ′"></a><a id="16798" href="#16798" class="Function">⋊-distribˡ′</a> <a id="16810" class="Symbol">:</a> <a id="16812" class="Symbol">∀</a> <a id="16814" href="#16814" class="Bound">p</a> <a id="16816" href="#16816" class="Bound">ys</a> <a id="16819" class="Symbol">→</a> <a id="16821" href="#12139" class="Function">⟦</a> <a id="16823" href="#16823" class="Bound">xs</a> <a id="16826" href="#12139" class="Function">∈𝒫</a> <a id="16829" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="16831" href="#12139" class="Function">⇒</a> <a id="16833" href="#16814" class="Bound">p</a> <a id="16835" href="#14109" class="Function Operator">⋊</a> <a id="16837" href="#16823" class="Bound">xs</a> <a id="16840" href="#13390" class="Function Operator">∪</a> <a id="16842" href="#16814" class="Bound">p</a> <a id="16844" href="#14109" class="Function Operator">⋊</a> <a id="16846" href="#16816" class="Bound">ys</a> <a id="16849" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">≡</a> <a id="16851" href="#16814" class="Bound">p</a> <a id="16853" href="#14109" class="Function Operator">⋊</a> <a id="16855" class="Symbol">(</a><a id="16856" href="#16823" class="Bound">xs</a> <a id="16859" href="#13390" class="Function Operator">∪</a> <a id="16861" href="#16816" class="Bound">ys</a><a id="16863" class="Symbol">)</a> <a id="16865" href="#12139" class="Function">⟧</a>
  <a id="16869" href="#11443" class="Field Operator">⟦</a> <a id="16871" href="#16798" class="Function">⋊-distribˡ′</a> <a id="16883" href="#16883" class="Bound">p</a> <a id="16885" href="#16885" class="Bound">ys</a> <a id="16888" href="#11443" class="Field Operator">⟧-prop</a> <a id="16895" class="Symbol">=</a> <a id="16897" href="#8921" class="InductiveConstructor">trunc</a> <a id="16903" class="Symbol">_</a> <a id="16905" class="Symbol">_</a>
  <a id="16909" href="#11481" class="Field Operator">⟦</a> <a id="16911" href="#16798" class="Function">⋊-distribˡ′</a> <a id="16923" href="#16923" class="Bound">p</a> <a id="16925" href="#16925" class="Bound">ys</a> <a id="16928" href="#11481" class="Field Operator">⟧[]</a> <a id="16932" class="Symbol">=</a> <a id="16934" href="../code/probability/Cubical.Foundations.Prelude.html#827" class="Function">refl</a>
  <a id="16941" href="#11498" class="Field Operator">⟦</a> <a id="16943" href="#16798" class="Function">⋊-distribˡ′</a> <a id="16955" href="#16955" class="Bound">p</a> <a id="16957" href="#16957" class="Bound">ys</a> <a id="16960" href="#11498" class="Field Operator">⟧</a> <a id="16962" href="#16962" class="Bound">q</a> <a id="16964" href="#11498" class="Field Operator">&amp;</a> <a id="16966" href="#16966" class="Bound">x</a> <a id="16968" href="#11498" class="Field Operator">∷</a> <a id="16970" href="#16970" class="Bound">xs</a> <a id="16973" href="#11498" class="Field Operator">⟨</a> <a id="16975" href="#16975" class="Bound">P</a> <a id="16977" href="#11498" class="Field Operator">⟩</a> <a id="16979" class="Symbol">=</a>
    <a id="16985" href="#16955" class="Bound">p</a> <a id="16987" href="#14109" class="Function Operator">⋊</a> <a id="16989" class="Symbol">(</a><a id="16990" href="#16962" class="Bound">q</a> <a id="16992" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="16994" href="#16966" class="Bound">x</a> <a id="16996" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="16998" href="#16970" class="Bound">xs</a><a id="17000" class="Symbol">)</a> <a id="17002" href="#13390" class="Function Operator">∪</a> <a id="17004" href="#16955" class="Bound">p</a> <a id="17006" href="#14109" class="Function Operator">⋊</a> <a id="17008" href="#16957" class="Bound">ys</a> <a id="17011" href="../code/probability/ProbabilityModule.Utils.html#572" class="Function Operator">≡⟨⟩</a>
    <a id="17019" href="#16955" class="Bound">p</a> <a id="17021" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="17023" href="#16962" class="Bound">q</a> <a id="17025" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="17027" href="#16966" class="Bound">x</a> <a id="17029" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="17031" href="#16955" class="Bound">p</a> <a id="17033" href="#14109" class="Function Operator">⋊</a> <a id="17035" href="#16970" class="Bound">xs</a> <a id="17038" href="#13390" class="Function Operator">∪</a> <a id="17040" href="#16955" class="Bound">p</a> <a id="17042" href="#14109" class="Function Operator">⋊</a> <a id="17044" href="#16957" class="Bound">ys</a> <a id="17047" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">≡⟨</a> <a id="17050" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="17055" class="Symbol">(</a><a id="17056" href="#16955" class="Bound">p</a> <a id="17058" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="17060" href="#16962" class="Bound">q</a> <a id="17062" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="17064" href="#16966" class="Bound">x</a> <a id="17066" href="#8727" class="InductiveConstructor Operator">∷_</a><a id="17068" class="Symbol">)</a> <a id="17070" href="#16975" class="Bound">P</a> <a id="17072" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">⟩</a>
    <a id="17078" href="#16955" class="Bound">p</a> <a id="17080" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="17082" href="#16962" class="Bound">q</a> <a id="17084" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="17086" href="#16966" class="Bound">x</a> <a id="17088" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="17090" href="#16955" class="Bound">p</a> <a id="17092" href="#14109" class="Function Operator">⋊</a> <a id="17094" class="Symbol">(</a><a id="17095" href="#16970" class="Bound">xs</a> <a id="17098" href="#13390" class="Function Operator">∪</a> <a id="17100" href="#16957" class="Bound">ys</a><a id="17102" class="Symbol">)</a> <a id="17104" href="../code/probability/ProbabilityModule.Utils.html#572" class="Function Operator">≡⟨⟩</a>
    <a id="17112" href="#16955" class="Bound">p</a> <a id="17114" href="#14109" class="Function Operator">⋊</a> <a id="17116" class="Symbol">((</a><a id="17118" href="#16962" class="Bound">q</a> <a id="17120" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="17122" href="#16966" class="Bound">x</a> <a id="17124" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="17126" href="#16970" class="Bound">xs</a><a id="17128" class="Symbol">)</a> <a id="17130" href="#13390" class="Function Operator">∪</a> <a id="17132" href="#16957" class="Bound">ys</a><a id="17134" class="Symbol">)</a> <a id="17136" href="../code/probability/Cubical.Foundations.Prelude.html#2745" class="Function Operator">∎</a>


<a id="∪-idʳ"></a><a id="17140" href="#17140" class="Function">∪-idʳ</a> <a id="17146" class="Symbol">:</a> <a id="17148" class="Symbol">(</a><a id="17149" href="#17149" class="Bound">xs</a> <a id="17152" class="Symbol">:</a> <a id="17154" href="#8679" class="Datatype">𝒫</a> <a id="17156" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a><a id="17157" class="Symbol">)</a> <a id="17159" class="Symbol">→</a> <a id="17161" href="#17149" class="Bound">xs</a> <a id="17164" href="#13390" class="Function Operator">∪</a> <a id="17166" href="#8715" class="InductiveConstructor">[]</a> <a id="17169" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">≡</a> <a id="17171" href="#17149" class="Bound">xs</a>
<a id="17174" href="#17140" class="Function">∪-idʳ</a> <a id="17180" class="Symbol">=</a> <a id="17182" href="#12103" class="Function Operator">⟦</a> <a id="17184" href="#17216" class="Function">∪-idʳ′</a> <a id="17191" href="#12103" class="Function Operator">⟧⇓</a>
  <a id="17196" class="Keyword">module</a> <a id="UIdR"></a><a id="17203" href="#17203" class="Module">UIdR</a> <a id="17208" class="Keyword">where</a>
  <a id="UIdR.∪-idʳ′"></a><a id="17216" href="#17216" class="Function">∪-idʳ′</a> <a id="17223" class="Symbol">:</a> <a id="17225" href="#12139" class="Function">⟦</a> <a id="17227" href="#17227" class="Bound">xs</a> <a id="17230" href="#12139" class="Function">∈𝒫</a> <a id="17233" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="17235" href="#12139" class="Function">⇒</a> <a id="17237" href="#17227" class="Bound">xs</a> <a id="17240" href="#13390" class="Function Operator">∪</a> <a id="17242" href="#8715" class="InductiveConstructor">[]</a> <a id="17245" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">≡</a> <a id="17247" href="#17227" class="Bound">xs</a> <a id="17250" href="#12139" class="Function">⟧</a>
  <a id="17254" href="#11443" class="Field Operator">⟦</a> <a id="17256" href="#17216" class="Function">∪-idʳ′</a> <a id="17263" href="#11443" class="Field Operator">⟧-prop</a> <a id="17270" class="Symbol">=</a> <a id="17272" href="#8921" class="InductiveConstructor">trunc</a> <a id="17278" class="Symbol">_</a> <a id="17280" class="Symbol">_</a>
  <a id="17284" href="#11481" class="Field Operator">⟦</a> <a id="17286" href="#17216" class="Function">∪-idʳ′</a> <a id="17293" href="#11481" class="Field Operator">⟧[]</a> <a id="17297" class="Symbol">=</a> <a id="17299" href="../code/probability/Cubical.Foundations.Prelude.html#827" class="Function">refl</a>
  <a id="17306" href="#11498" class="Field Operator">⟦</a> <a id="17308" href="#17216" class="Function">∪-idʳ′</a> <a id="17315" href="#11498" class="Field Operator">⟧</a> <a id="17317" href="#17317" class="Bound">p</a> <a id="17319" href="#11498" class="Field Operator">&amp;</a> <a id="17321" href="#17321" class="Bound">x</a> <a id="17323" href="#11498" class="Field Operator">∷</a> <a id="17325" href="#17325" class="Bound">xs</a> <a id="17328" href="#11498" class="Field Operator">⟨</a> <a id="17330" href="#17330" class="Bound">P</a> <a id="17332" href="#11498" class="Field Operator">⟩</a> <a id="17334" class="Symbol">=</a> <a id="17336" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="17341" class="Symbol">(</a><a id="17342" href="#17317" class="Bound">p</a> <a id="17344" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="17346" href="#17321" class="Bound">x</a> <a id="17348" href="#8727" class="InductiveConstructor Operator">∷_</a><a id="17350" class="Symbol">)</a> <a id="17352" href="#17330" class="Bound">P</a>

<a id="∪-comm"></a><a id="17355" href="#17355" class="Function">∪-comm</a> <a id="17362" class="Symbol">:</a> <a id="17364" class="Symbol">(</a><a id="17365" href="#17365" class="Bound">xs</a> <a id="17368" href="#17368" class="Bound">ys</a> <a id="17371" class="Symbol">:</a> <a id="17373" href="#8679" class="Datatype">𝒫</a> <a id="17375" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a><a id="17376" class="Symbol">)</a> <a id="17378" class="Symbol">→</a> <a id="17380" href="#17365" class="Bound">xs</a> <a id="17383" href="#13390" class="Function Operator">∪</a> <a id="17385" href="#17368" class="Bound">ys</a> <a id="17388" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">≡</a> <a id="17390" href="#17368" class="Bound">ys</a> <a id="17393" href="#13390" class="Function Operator">∪</a> <a id="17395" href="#17365" class="Bound">xs</a>
<a id="17398" href="#17355" class="Function">∪-comm</a> <a id="17405" class="Symbol">=</a> <a id="17407" class="Symbol">λ</a> <a id="17409" href="#17409" class="Bound">xs</a> <a id="17412" href="#17412" class="Bound">ys</a> <a id="17415" class="Symbol">→</a> <a id="17417" href="#12103" class="Function Operator">⟦</a> <a id="17419" href="#17459" class="Function">∪-comm′</a> <a id="17427" href="#17412" class="Bound">ys</a> <a id="17430" href="#12103" class="Function Operator">⟧⇓</a> <a id="17433" href="#17409" class="Bound">xs</a>
  <a id="17438" class="Keyword">module</a> <a id="UComm"></a><a id="17445" href="#17445" class="Module">UComm</a> <a id="17451" class="Keyword">where</a>
  <a id="UComm.∪-comm′"></a><a id="17459" href="#17459" class="Function">∪-comm′</a> <a id="17467" class="Symbol">:</a> <a id="17469" class="Symbol">∀</a> <a id="17471" href="#17471" class="Bound">ys</a> <a id="17474" class="Symbol">→</a> <a id="17476" href="#12139" class="Function">⟦</a> <a id="17478" href="#17478" class="Bound">xs</a> <a id="17481" href="#12139" class="Function">∈𝒫</a> <a id="17484" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="17486" href="#12139" class="Function">⇒</a> <a id="17488" href="#17478" class="Bound">xs</a> <a id="17491" href="#13390" class="Function Operator">∪</a> <a id="17493" href="#17471" class="Bound">ys</a> <a id="17496" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">≡</a> <a id="17498" href="#17471" class="Bound">ys</a> <a id="17501" href="#13390" class="Function Operator">∪</a> <a id="17503" href="#17478" class="Bound">xs</a> <a id="17506" href="#12139" class="Function">⟧</a>
  <a id="17510" href="#11443" class="Field Operator">⟦</a> <a id="17512" href="#17459" class="Function">∪-comm′</a> <a id="17520" href="#17520" class="Bound">ys</a> <a id="17523" href="#11443" class="Field Operator">⟧-prop</a> <a id="17530" class="Symbol">=</a> <a id="17532" href="#8921" class="InductiveConstructor">trunc</a> <a id="17538" class="Symbol">_</a> <a id="17540" class="Symbol">_</a>
  <a id="17544" href="#11481" class="Field Operator">⟦</a> <a id="17546" href="#17459" class="Function">∪-comm′</a> <a id="17554" href="#17554" class="Bound">ys</a> <a id="17557" href="#11481" class="Field Operator">⟧[]</a> <a id="17561" class="Symbol">=</a> <a id="17563" href="../code/probability/Cubical.Foundations.Prelude.html#864" class="Function">sym</a> <a id="17567" class="Symbol">(</a><a id="17568" href="#17140" class="Function">∪-idʳ</a> <a id="17574" href="#17554" class="Bound">ys</a><a id="17576" class="Symbol">)</a>
  <a id="17580" href="#11498" class="Field Operator">⟦</a> <a id="17582" href="#17459" class="Function">∪-comm′</a> <a id="17590" href="#17590" class="Bound">ys</a> <a id="17593" href="#11498" class="Field Operator">⟧</a> <a id="17595" href="#17595" class="Bound">p</a> <a id="17597" href="#11498" class="Field Operator">&amp;</a> <a id="17599" href="#17599" class="Bound">x</a> <a id="17601" href="#11498" class="Field Operator">∷</a> <a id="17603" href="#17603" class="Bound">xs</a> <a id="17606" href="#11498" class="Field Operator">⟨</a> <a id="17608" href="#17608" class="Bound">P</a> <a id="17610" href="#11498" class="Field Operator">⟩</a> <a id="17612" class="Symbol">=</a> <a id="17614" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="17619" class="Symbol">(</a><a id="17620" href="#17595" class="Bound">p</a> <a id="17622" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="17624" href="#17599" class="Bound">x</a> <a id="17626" href="#8727" class="InductiveConstructor Operator">∷_</a><a id="17628" class="Symbol">)</a> <a id="17630" href="#17608" class="Bound">P</a> <a id="17632" href="../code/probability/Cubical.Foundations.Prelude.html#1674" class="Function Operator">;</a> <a id="17634" href="../code/probability/Cubical.Foundations.Prelude.html#864" class="Function">sym</a> <a id="17638" class="Symbol">(</a><a id="17639" href="#15455" class="Function">∪-cons</a> <a id="17646" href="#17595" class="Bound">p</a> <a id="17648" href="#17599" class="Bound">x</a> <a id="17650" href="#17590" class="Bound">ys</a> <a id="17653" href="#17603" class="Bound">xs</a><a id="17655" class="Symbol">)</a>

<a id="0⋊"></a><a id="17658" href="#17658" class="Function">0⋊</a> <a id="17661" class="Symbol">:</a> <a id="17663" class="Symbol">(</a><a id="17664" href="#17664" class="Bound">xs</a> <a id="17667" class="Symbol">:</a> <a id="17669" href="#8679" class="Datatype">𝒫</a> <a id="17671" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a><a id="17672" class="Symbol">)</a> <a id="17674" class="Symbol">→</a> <a id="17676" href="../code/probability/ProbabilityModule.Semirings.html#254" class="Field">0#</a> <a id="17679" href="#14109" class="Function Operator">⋊</a> <a id="17681" href="#17664" class="Bound">xs</a> <a id="17684" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">≡</a> <a id="17686" href="#8715" class="InductiveConstructor">[]</a>
<a id="17689" href="#17658" class="Function">0⋊</a> <a id="17692" class="Symbol">=</a> <a id="17694" href="#12103" class="Function Operator">⟦</a> <a id="17696" href="#17726" class="Function">0⋊′</a> <a id="17700" href="#12103" class="Function Operator">⟧⇓</a>
  <a id="17705" class="Keyword">module</a> <a id="ZeroJ"></a><a id="17712" href="#17712" class="Module">ZeroJ</a> <a id="17718" class="Keyword">where</a>
  <a id="ZeroJ.0⋊′"></a><a id="17726" href="#17726" class="Function">0⋊′</a> <a id="17730" class="Symbol">:</a> <a id="17732" href="#12139" class="Function">⟦</a> <a id="17734" href="#17734" class="Bound">xs</a> <a id="17737" href="#12139" class="Function">∈𝒫</a> <a id="17740" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="17742" href="#12139" class="Function">⇒</a> <a id="17744" href="../code/probability/ProbabilityModule.Semirings.html#254" class="Field">0#</a> <a id="17747" href="#14109" class="Function Operator">⋊</a> <a id="17749" href="#17734" class="Bound">xs</a> <a id="17752" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">≡</a> <a id="17754" href="#8715" class="InductiveConstructor">[]</a> <a id="17757" href="#12139" class="Function">⟧</a>
  <a id="17761" href="#11443" class="Field Operator">⟦</a> <a id="17763" href="#17726" class="Function">0⋊′</a> <a id="17767" href="#11443" class="Field Operator">⟧-prop</a> <a id="17774" class="Symbol">=</a> <a id="17776" href="#8921" class="InductiveConstructor">trunc</a> <a id="17782" class="Symbol">_</a> <a id="17784" class="Symbol">_</a>
  <a id="17788" href="#11481" class="Field Operator">⟦</a> <a id="17790" href="#17726" class="Function">0⋊′</a> <a id="17794" href="#11481" class="Field Operator">⟧[]</a> <a id="17798" class="Symbol">=</a> <a id="17800" href="../code/probability/Cubical.Foundations.Prelude.html#827" class="Function">refl</a>
  <a id="17807" href="#11498" class="Field Operator">⟦</a> <a id="17809" href="#17726" class="Function">0⋊′</a> <a id="17813" href="#11498" class="Field Operator">⟧</a> <a id="17815" href="#17815" class="Bound">p</a> <a id="17817" href="#11498" class="Field Operator">&amp;</a> <a id="17819" href="#17819" class="Bound">x</a> <a id="17821" href="#11498" class="Field Operator">∷</a> <a id="17823" href="#17823" class="Bound">xs</a> <a id="17826" href="#11498" class="Field Operator">⟨</a> <a id="17828" href="#17828" class="Bound">P</a> <a id="17830" href="#11498" class="Field Operator">⟩</a> <a id="17832" class="Symbol">=</a>
    <a id="17838" href="../code/probability/ProbabilityModule.Semirings.html#254" class="Field">0#</a> <a id="17841" href="#14109" class="Function Operator">⋊</a> <a id="17843" class="Symbol">(</a><a id="17844" href="#17815" class="Bound">p</a> <a id="17846" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="17848" href="#17819" class="Bound">x</a> <a id="17850" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="17852" href="#17823" class="Bound">xs</a><a id="17854" class="Symbol">)</a>    <a id="17859" href="../code/probability/ProbabilityModule.Utils.html#572" class="Function Operator">≡⟨⟩</a>
    <a id="17867" href="../code/probability/ProbabilityModule.Semirings.html#254" class="Field">0#</a> <a id="17870" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="17872" href="#17815" class="Bound">p</a> <a id="17874" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="17876" href="#17819" class="Bound">x</a> <a id="17878" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="17880" href="../code/probability/ProbabilityModule.Semirings.html#254" class="Field">0#</a> <a id="17883" href="#14109" class="Function Operator">⋊</a> <a id="17885" href="#17823" class="Bound">xs</a> <a id="17888" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">≡⟨</a> <a id="17891" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="17896" class="Symbol">(</a><a id="17897" href="#8727" class="InductiveConstructor Operator">_&amp;</a> <a id="17900" href="#17819" class="Bound">x</a> <a id="17902" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="17904" href="../code/probability/ProbabilityModule.Semirings.html#254" class="Field">0#</a> <a id="17907" href="#14109" class="Function Operator">⋊</a> <a id="17909" href="#17823" class="Bound">xs</a><a id="17911" class="Symbol">)</a> <a id="17913" class="Symbol">(</a><a id="17914" href="../code/probability/ProbabilityModule.Semirings.html#403" class="Field">0*</a> <a id="17917" href="#17815" class="Bound">p</a><a id="17918" class="Symbol">)</a> <a id="17920" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">⟩</a>
    <a id="17926" href="../code/probability/ProbabilityModule.Semirings.html#254" class="Field">0#</a> <a id="17929" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="17931" href="#17819" class="Bound">x</a> <a id="17933" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="17935" href="../code/probability/ProbabilityModule.Semirings.html#254" class="Field">0#</a> <a id="17938" href="#14109" class="Function Operator">⋊</a> <a id="17940" href="#17823" class="Bound">xs</a>     <a id="17947" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">≡⟨</a> <a id="17950" href="#8887" class="InductiveConstructor">del</a> <a id="17954" href="#17819" class="Bound">x</a> <a id="17956" class="Symbol">(</a><a id="17957" href="../code/probability/ProbabilityModule.Semirings.html#254" class="Field">0#</a> <a id="17960" href="#14109" class="Function Operator">⋊</a> <a id="17962" href="#17823" class="Bound">xs</a><a id="17964" class="Symbol">)</a> <a id="17966" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">⟩</a>
    <a id="17972" href="../code/probability/ProbabilityModule.Semirings.html#254" class="Field">0#</a> <a id="17975" href="#14109" class="Function Operator">⋊</a> <a id="17977" href="#17823" class="Bound">xs</a>              <a id="17993" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">≡⟨</a> <a id="17996" href="#17828" class="Bound">P</a> <a id="17998" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">⟩</a>
    <a id="18004" href="#8715" class="InductiveConstructor">[]</a> <a id="18007" href="../code/probability/Cubical.Foundations.Prelude.html#2745" class="Function Operator">∎</a>
</pre>
</details>
<p>However, I <em>can</em> demonstrate the monadic bind:</p>
<pre class="Agda"><a id="_&gt;&gt;=_"></a><a id="18081" href="#18081" class="Function Operator">_&gt;&gt;=_</a> <a id="18087" class="Symbol">:</a> <a id="18089" href="#8679" class="Datatype">𝒫</a> <a id="18091" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="18093" class="Symbol">→</a> <a id="18095" class="Symbol">(</a><a id="18096" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="18098" class="Symbol">→</a> <a id="18100" href="#8679" class="Datatype">𝒫</a> <a id="18102" href="../code/probability/ProbabilityModule.Utils.html#206" class="Generalizable">B</a><a id="18103" class="Symbol">)</a> <a id="18105" class="Symbol">→</a> <a id="18107" href="#8679" class="Datatype">𝒫</a> <a id="18109" href="../code/probability/ProbabilityModule.Utils.html#206" class="Generalizable">B</a>
<a id="18111" href="#18111" class="Bound">xs</a> <a id="18114" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="18118" href="#18118" class="Bound">f</a> <a id="18120" class="Symbol">=</a> <a id="18122" href="#12874" class="Function Operator">[</a> <a id="18124" href="#18118" class="Bound">f</a> <a id="18126" href="#18158" class="Function Operator">=&lt;&lt;</a> <a id="18130" href="#12874" class="Function Operator">]↓</a> <a id="18133" href="#18111" class="Bound">xs</a>
  <a id="18138" class="Keyword">module</a> <a id="Bind"></a><a id="18145" href="#18145" class="Module">Bind</a> <a id="18150" class="Keyword">where</a>
  <a id="Bind._=&lt;&lt;"></a><a id="18158" href="#18158" class="Function Operator">_=&lt;&lt;</a> <a id="18163" class="Symbol">:</a> <a id="18165" class="Symbol">(</a><a id="18166" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="18168" class="Symbol">→</a> <a id="18170" href="#8679" class="Datatype">𝒫</a> <a id="18172" href="../code/probability/ProbabilityModule.Utils.html#206" class="Generalizable">B</a><a id="18173" class="Symbol">)</a> <a id="18175" class="Symbol">→</a> <a id="18177" href="#12307" class="Record Operator">[</a> <a id="18179" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="18181" href="#12307" class="Record Operator">↦</a> <a id="18183" href="#8679" class="Datatype">𝒫</a> <a id="18185" href="../code/probability/ProbabilityModule.Utils.html#206" class="Generalizable">B</a> <a id="18187" href="#12307" class="Record Operator">]</a>
  <a id="18191" href="#12420" class="Field Operator">[</a> <a id="18193" href="#18193" class="Bound">f</a> <a id="18195" href="#18158" class="Function Operator">=&lt;&lt;</a> <a id="18199" href="#12420" class="Field Operator">]</a> <a id="18201" href="#18201" class="Bound">p</a> <a id="18203" href="#12420" class="Field Operator">&amp;</a> <a id="18205" href="#18205" class="Bound">x</a> <a id="18207" href="#12420" class="Field Operator">∷</a> <a id="18209" href="#18209" class="Bound">xs</a> <a id="18212" class="Symbol">=</a> <a id="18214" href="#18201" class="Bound">p</a> <a id="18216" href="#14109" class="Function Operator">⋊</a> <a id="18218" class="Symbol">(</a><a id="18219" href="#18193" class="Bound">f</a> <a id="18221" href="#18205" class="Bound">x</a><a id="18222" class="Symbol">)</a> <a id="18224" href="#13390" class="Function Operator">∪</a> <a id="18226" href="#18209" class="Bound">xs</a>
  <a id="18231" href="#12449" class="Field Operator">[</a> <a id="18233" href="#18233" class="Bound">f</a> <a id="18235" href="#18158" class="Function Operator">=&lt;&lt;</a> <a id="18239" href="#12449" class="Field Operator">][]</a> <a id="18243" class="Symbol">=</a> <a id="18245" href="#8715" class="InductiveConstructor">[]</a>
  <a id="18250" href="#12397" class="Field Operator">[</a> <a id="18252" href="#18252" class="Bound">f</a> <a id="18254" href="#18158" class="Function Operator">=&lt;&lt;</a> <a id="18258" href="#12397" class="Field Operator">]-set</a> <a id="18264" class="Symbol">=</a> <a id="18266" href="#8921" class="InductiveConstructor">trunc</a>
  <a id="18274" href="#12635" class="Field Operator">[</a> <a id="18276" href="#18276" class="Bound">f</a> <a id="18278" href="#18158" class="Function Operator">=&lt;&lt;</a> <a id="18282" href="#12635" class="Field Operator">]-del</a> <a id="18288" href="#18288" class="Bound">x</a> <a id="18290" href="#18290" class="Bound">xs</a> <a id="18293" class="Symbol">=</a> <a id="18295" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="18300" class="Symbol">(</a><a id="18301" href="#13390" class="Function Operator">_∪</a> <a id="18304" href="#18290" class="Bound">xs</a><a id="18306" class="Symbol">)</a> <a id="18308" class="Symbol">(</a><a id="18309" href="#17658" class="Function">0⋊</a> <a id="18312" class="Symbol">(</a><a id="18313" href="#18276" class="Bound">f</a> <a id="18315" href="#18288" class="Bound">x</a><a id="18316" class="Symbol">))</a>
  <a id="18321" href="#12508" class="Field Operator">[</a> <a id="18323" href="#18323" class="Bound">f</a> <a id="18325" href="#18158" class="Function Operator">=&lt;&lt;</a> <a id="18329" href="#12508" class="Field Operator">]-dup</a> <a id="18335" href="#18335" class="Bound">p</a> <a id="18337" href="#18337" class="Bound">q</a> <a id="18339" href="#18339" class="Bound">x</a> <a id="18341" href="#18341" class="Bound">xs</a> <a id="18344" class="Symbol">=</a>
    <a id="18350" href="#18335" class="Bound">p</a> <a id="18352" href="#14109" class="Function Operator">⋊</a> <a id="18354" class="Symbol">(</a><a id="18355" href="#18323" class="Bound">f</a> <a id="18357" href="#18339" class="Bound">x</a><a id="18358" class="Symbol">)</a> <a id="18360" href="#13390" class="Function Operator">∪</a> <a id="18362" href="#18337" class="Bound">q</a> <a id="18364" href="#14109" class="Function Operator">⋊</a> <a id="18366" class="Symbol">(</a><a id="18367" href="#18323" class="Bound">f</a> <a id="18369" href="#18339" class="Bound">x</a><a id="18370" class="Symbol">)</a> <a id="18372" href="#13390" class="Function Operator">∪</a> <a id="18374" href="#18341" class="Bound">xs</a>   <a id="18379" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">≡⟨</a> <a id="18382" href="#13658" class="Function">∪-assoc</a> <a id="18390" class="Symbol">(</a><a id="18391" href="#18335" class="Bound">p</a> <a id="18393" href="#14109" class="Function Operator">⋊</a> <a id="18395" href="#18323" class="Bound">f</a> <a id="18397" href="#18339" class="Bound">x</a><a id="18398" class="Symbol">)</a> <a id="18400" class="Symbol">(</a><a id="18401" href="#18337" class="Bound">q</a> <a id="18403" href="#14109" class="Function Operator">⋊</a> <a id="18405" href="#18323" class="Bound">f</a> <a id="18407" href="#18339" class="Bound">x</a><a id="18408" class="Symbol">)</a> <a id="18410" href="#18341" class="Bound">xs</a> <a id="18413" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">⟩</a>
    <a id="18419" class="Symbol">(</a><a id="18420" href="#18335" class="Bound">p</a> <a id="18422" href="#14109" class="Function Operator">⋊</a> <a id="18424" class="Symbol">(</a><a id="18425" href="#18323" class="Bound">f</a> <a id="18427" href="#18339" class="Bound">x</a><a id="18428" class="Symbol">)</a> <a id="18430" href="#13390" class="Function Operator">∪</a> <a id="18432" href="#18337" class="Bound">q</a> <a id="18434" href="#14109" class="Function Operator">⋊</a> <a id="18436" class="Symbol">(</a><a id="18437" href="#18323" class="Bound">f</a> <a id="18439" href="#18339" class="Bound">x</a><a id="18440" class="Symbol">))</a> <a id="18443" href="#13390" class="Function Operator">∪</a> <a id="18445" href="#18341" class="Bound">xs</a> <a id="18448" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">≡⟨</a> <a id="18451" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="18456" class="Symbol">(</a><a id="18457" href="#13390" class="Function Operator">_∪</a> <a id="18460" href="#18341" class="Bound">xs</a><a id="18462" class="Symbol">)</a> <a id="18464" class="Symbol">(</a><a id="18465" href="#15807" class="Function">⋊-distribʳ</a> <a id="18476" href="#18335" class="Bound">p</a> <a id="18478" href="#18337" class="Bound">q</a> <a id="18480" class="Symbol">(</a><a id="18481" href="#18323" class="Bound">f</a> <a id="18483" href="#18339" class="Bound">x</a><a id="18484" class="Symbol">)</a> <a id="18486" class="Symbol">)</a> <a id="18488" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">⟩</a>
    <a id="18494" href="#14109" class="Function Operator">_⋊_</a> <a id="18498" class="Symbol">(</a><a id="18499" href="#18335" class="Bound">p</a> <a id="18501" href="../code/probability/ProbabilityModule.Semirings.html#214" class="Field Operator">+</a> <a id="18503" href="#18337" class="Bound">q</a><a id="18504" class="Symbol">)</a> <a id="18506" class="Symbol">(</a><a id="18507" href="#18323" class="Bound">f</a> <a id="18509" href="#18339" class="Bound">x</a><a id="18510" class="Symbol">)</a> <a id="18512" href="#13390" class="Function Operator">∪</a> <a id="18514" href="#18341" class="Bound">xs</a> <a id="18517" href="../code/probability/Cubical.Foundations.Prelude.html#2745" class="Function Operator">∎</a>
  <a id="18521" href="#12570" class="Field Operator">[</a> <a id="18523" href="#18523" class="Bound">f</a> <a id="18525" href="#18158" class="Function Operator">=&lt;&lt;</a> <a id="18529" href="#12570" class="Field Operator">]-com</a> <a id="18535" href="#18535" class="Bound">p</a> <a id="18537" href="#18537" class="Bound">x</a> <a id="18539" href="#18539" class="Bound">q</a> <a id="18541" href="#18541" class="Bound">y</a> <a id="18543" href="#18543" class="Bound">xs</a> <a id="18546" class="Symbol">=</a>
    <a id="18552" href="#18535" class="Bound">p</a> <a id="18554" href="#14109" class="Function Operator">⋊</a> <a id="18556" class="Symbol">(</a><a id="18557" href="#18523" class="Bound">f</a> <a id="18559" href="#18537" class="Bound">x</a><a id="18560" class="Symbol">)</a> <a id="18562" href="#13390" class="Function Operator">∪</a> <a id="18564" href="#18539" class="Bound">q</a> <a id="18566" href="#14109" class="Function Operator">⋊</a> <a id="18568" class="Symbol">(</a><a id="18569" href="#18523" class="Bound">f</a> <a id="18571" href="#18541" class="Bound">y</a><a id="18572" class="Symbol">)</a> <a id="18574" href="#13390" class="Function Operator">∪</a> <a id="18576" href="#18543" class="Bound">xs</a>   <a id="18581" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">≡⟨</a> <a id="18584" href="#13658" class="Function">∪-assoc</a> <a id="18592" class="Symbol">(</a><a id="18593" href="#18535" class="Bound">p</a> <a id="18595" href="#14109" class="Function Operator">⋊</a> <a id="18597" href="#18523" class="Bound">f</a> <a id="18599" href="#18537" class="Bound">x</a><a id="18600" class="Symbol">)</a> <a id="18602" class="Symbol">(</a><a id="18603" href="#18539" class="Bound">q</a> <a id="18605" href="#14109" class="Function Operator">⋊</a> <a id="18607" href="#18523" class="Bound">f</a> <a id="18609" href="#18541" class="Bound">y</a><a id="18610" class="Symbol">)</a> <a id="18612" href="#18543" class="Bound">xs</a> <a id="18615" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">⟩</a>
    <a id="18621" class="Symbol">(</a><a id="18622" href="#18535" class="Bound">p</a> <a id="18624" href="#14109" class="Function Operator">⋊</a> <a id="18626" class="Symbol">(</a><a id="18627" href="#18523" class="Bound">f</a> <a id="18629" href="#18537" class="Bound">x</a><a id="18630" class="Symbol">)</a> <a id="18632" href="#13390" class="Function Operator">∪</a> <a id="18634" href="#18539" class="Bound">q</a> <a id="18636" href="#14109" class="Function Operator">⋊</a> <a id="18638" class="Symbol">(</a><a id="18639" href="#18523" class="Bound">f</a> <a id="18641" href="#18541" class="Bound">y</a><a id="18642" class="Symbol">))</a> <a id="18645" href="#13390" class="Function Operator">∪</a> <a id="18647" href="#18543" class="Bound">xs</a> <a id="18650" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">≡⟨</a> <a id="18653" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="18658" class="Symbol">(</a><a id="18659" href="#13390" class="Function Operator">_∪</a> <a id="18662" href="#18543" class="Bound">xs</a><a id="18664" class="Symbol">)</a> <a id="18666" class="Symbol">(</a><a id="18667" href="#17355" class="Function">∪-comm</a> <a id="18674" class="Symbol">(</a><a id="18675" href="#18535" class="Bound">p</a> <a id="18677" href="#14109" class="Function Operator">⋊</a> <a id="18679" href="#18523" class="Bound">f</a> <a id="18681" href="#18537" class="Bound">x</a><a id="18682" class="Symbol">)</a> <a id="18684" class="Symbol">(</a><a id="18685" href="#18539" class="Bound">q</a> <a id="18687" href="#14109" class="Function Operator">⋊</a> <a id="18689" href="#18523" class="Bound">f</a> <a id="18691" href="#18541" class="Bound">y</a><a id="18692" class="Symbol">))</a> <a id="18695" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">⟩</a>
    <a id="18701" class="Symbol">(</a><a id="18702" href="#18539" class="Bound">q</a> <a id="18704" href="#14109" class="Function Operator">⋊</a> <a id="18706" class="Symbol">(</a><a id="18707" href="#18523" class="Bound">f</a> <a id="18709" href="#18541" class="Bound">y</a><a id="18710" class="Symbol">)</a> <a id="18712" href="#13390" class="Function Operator">∪</a> <a id="18714" href="#18535" class="Bound">p</a> <a id="18716" href="#14109" class="Function Operator">⋊</a> <a id="18718" class="Symbol">(</a><a id="18719" href="#18523" class="Bound">f</a> <a id="18721" href="#18537" class="Bound">x</a><a id="18722" class="Symbol">))</a> <a id="18725" href="#13390" class="Function Operator">∪</a> <a id="18727" href="#18543" class="Bound">xs</a> <a id="18730" href="../code/probability/ProbabilityModule.Utils.html#295" class="Function">≡˘⟨</a> <a id="18734" href="#13658" class="Function">∪-assoc</a> <a id="18742" class="Symbol">(</a><a id="18743" href="#18539" class="Bound">q</a> <a id="18745" href="#14109" class="Function Operator">⋊</a> <a id="18747" href="#18523" class="Bound">f</a> <a id="18749" href="#18541" class="Bound">y</a><a id="18750" class="Symbol">)</a> <a id="18752" class="Symbol">(</a><a id="18753" href="#18535" class="Bound">p</a> <a id="18755" href="#14109" class="Function Operator">⋊</a> <a id="18757" href="#18523" class="Bound">f</a> <a id="18759" href="#18537" class="Bound">x</a><a id="18760" class="Symbol">)</a> <a id="18762" href="#18543" class="Bound">xs</a> <a id="18765" href="../code/probability/ProbabilityModule.Utils.html#295" class="Function">⟩</a>
    <a id="18771" href="#18539" class="Bound">q</a> <a id="18773" href="#14109" class="Function Operator">⋊</a> <a id="18775" class="Symbol">(</a><a id="18776" href="#18523" class="Bound">f</a> <a id="18778" href="#18541" class="Bound">y</a><a id="18779" class="Symbol">)</a> <a id="18781" href="#13390" class="Function Operator">∪</a> <a id="18783" href="#18535" class="Bound">p</a> <a id="18785" href="#14109" class="Function Operator">⋊</a> <a id="18787" class="Symbol">(</a><a id="18788" href="#18523" class="Bound">f</a> <a id="18790" href="#18537" class="Bound">x</a><a id="18791" class="Symbol">)</a> <a id="18793" href="#13390" class="Function Operator">∪</a> <a id="18795" href="#18543" class="Bound">xs</a> <a id="18798" href="../code/probability/Cubical.Foundations.Prelude.html#2745" class="Function Operator">∎</a>
</pre>
<p>And we can prove the monad laws, also:</p>
<details>
<p><summary>Proofs of Monad Laws</summary></p>
<pre class="Agda"><a id="1⋊"></a><a id="18904" href="#18904" class="Function">1⋊</a> <a id="18907" class="Symbol">:</a> <a id="18909" class="Symbol">(</a><a id="18910" href="#18910" class="Bound">xs</a> <a id="18913" class="Symbol">:</a> <a id="18915" href="#8679" class="Datatype">𝒫</a> <a id="18917" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a><a id="18918" class="Symbol">)</a> <a id="18920" class="Symbol">→</a> <a id="18922" href="../code/probability/ProbabilityModule.Semirings.html#265" class="Field">1#</a> <a id="18925" href="#14109" class="Function Operator">⋊</a> <a id="18927" href="#18910" class="Bound">xs</a> <a id="18930" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">≡</a> <a id="18932" href="#18910" class="Bound">xs</a>
<a id="18935" href="#18904" class="Function">1⋊</a> <a id="18938" class="Symbol">=</a> <a id="18940" href="#12103" class="Function Operator">⟦</a> <a id="18942" href="#18974" class="Function">1⋊′</a> <a id="18946" href="#12103" class="Function Operator">⟧⇓</a>
  <a id="18951" class="Keyword">module</a> <a id="OneJoin"></a><a id="18958" href="#18958" class="Module">OneJoin</a> <a id="18966" class="Keyword">where</a>
  <a id="OneJoin.1⋊′"></a><a id="18974" href="#18974" class="Function">1⋊′</a> <a id="18978" class="Symbol">:</a> <a id="18980" href="#12139" class="Function">⟦</a> <a id="18982" href="#18982" class="Bound">xs</a> <a id="18985" href="#12139" class="Function">∈𝒫</a> <a id="18988" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="18990" href="#12139" class="Function">⇒</a> <a id="18992" href="../code/probability/ProbabilityModule.Semirings.html#265" class="Field">1#</a> <a id="18995" href="#14109" class="Function Operator">⋊</a> <a id="18997" href="#18982" class="Bound">xs</a> <a id="19000" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">≡</a> <a id="19002" href="#18982" class="Bound">xs</a> <a id="19005" href="#12139" class="Function">⟧</a>
  <a id="19009" href="#11443" class="Field Operator">⟦</a> <a id="19011" href="#18974" class="Function">1⋊′</a> <a id="19015" href="#11443" class="Field Operator">⟧-prop</a> <a id="19022" class="Symbol">=</a> <a id="19024" href="#8921" class="InductiveConstructor">trunc</a> <a id="19030" class="Symbol">_</a> <a id="19032" class="Symbol">_</a>
  <a id="19036" href="#11481" class="Field Operator">⟦</a> <a id="19038" href="#18974" class="Function">1⋊′</a> <a id="19042" href="#11481" class="Field Operator">⟧[]</a> <a id="19046" class="Symbol">=</a> <a id="19048" href="../code/probability/Cubical.Foundations.Prelude.html#827" class="Function">refl</a>
  <a id="19055" href="#11498" class="Field Operator">⟦</a> <a id="19057" href="#18974" class="Function">1⋊′</a> <a id="19061" href="#11498" class="Field Operator">⟧</a> <a id="19063" href="#19063" class="Bound">p</a> <a id="19065" href="#11498" class="Field Operator">&amp;</a> <a id="19067" href="#19067" class="Bound">x</a> <a id="19069" href="#11498" class="Field Operator">∷</a> <a id="19071" href="#19071" class="Bound">xs</a> <a id="19074" href="#11498" class="Field Operator">⟨</a> <a id="19076" href="#19076" class="Bound">P</a> <a id="19078" href="#11498" class="Field Operator">⟩</a> <a id="19080" class="Symbol">=</a>
    <a id="19086" href="../code/probability/ProbabilityModule.Semirings.html#265" class="Field">1#</a> <a id="19089" href="#14109" class="Function Operator">⋊</a> <a id="19091" class="Symbol">(</a><a id="19092" href="#19063" class="Bound">p</a> <a id="19094" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="19096" href="#19067" class="Bound">x</a> <a id="19098" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="19100" href="#19071" class="Bound">xs</a><a id="19102" class="Symbol">)</a> <a id="19104" href="../code/probability/ProbabilityModule.Utils.html#572" class="Function Operator">≡⟨⟩</a>
    <a id="19112" href="../code/probability/ProbabilityModule.Semirings.html#265" class="Field">1#</a> <a id="19115" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="19117" href="#19063" class="Bound">p</a> <a id="19119" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="19121" href="#19067" class="Bound">x</a> <a id="19123" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="19125" href="../code/probability/ProbabilityModule.Semirings.html#265" class="Field">1#</a> <a id="19128" href="#14109" class="Function Operator">⋊</a> <a id="19130" href="#19071" class="Bound">xs</a> <a id="19133" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">≡⟨</a> <a id="19136" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="19141" class="Symbol">(</a><a id="19142" href="#8727" class="InductiveConstructor Operator">_&amp;</a> <a id="19145" href="#19067" class="Bound">x</a> <a id="19147" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="19149" href="../code/probability/ProbabilityModule.Semirings.html#265" class="Field">1#</a> <a id="19152" href="#14109" class="Function Operator">⋊</a> <a id="19154" href="#19071" class="Bound">xs</a><a id="19156" class="Symbol">)</a> <a id="19158" class="Symbol">(</a><a id="19159" href="../code/probability/ProbabilityModule.Semirings.html#482" class="Field">1*</a> <a id="19162" href="#19063" class="Bound">p</a><a id="19163" class="Symbol">)</a> <a id="19165" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">⟩</a>
    <a id="19171" href="#19063" class="Bound">p</a> <a id="19173" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="19175" href="#19067" class="Bound">x</a> <a id="19177" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="19179" href="../code/probability/ProbabilityModule.Semirings.html#265" class="Field">1#</a> <a id="19182" href="#14109" class="Function Operator">⋊</a> <a id="19184" href="#19071" class="Bound">xs</a> <a id="19187" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">≡⟨</a> <a id="19190" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="19195" class="Symbol">(</a><a id="19196" href="#19063" class="Bound">p</a> <a id="19198" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="19200" href="#19067" class="Bound">x</a> <a id="19202" href="#8727" class="InductiveConstructor Operator">∷_</a><a id="19204" class="Symbol">)</a> <a id="19206" href="#19076" class="Bound">P</a> <a id="19208" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">⟩</a>
    <a id="19214" href="#19063" class="Bound">p</a> <a id="19216" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="19218" href="#19067" class="Bound">x</a> <a id="19220" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="19222" href="#19071" class="Bound">xs</a> <a id="19225" href="../code/probability/Cubical.Foundations.Prelude.html#2745" class="Function Operator">∎</a>

<a id="&gt;&gt;=-distrib"></a><a id="19228" href="#19228" class="Function">&gt;&gt;=-distrib</a> <a id="19240" class="Symbol">:</a> <a id="19242" class="Symbol">(</a><a id="19243" href="#19243" class="Bound">xs</a> <a id="19246" href="#19246" class="Bound">ys</a> <a id="19249" class="Symbol">:</a> <a id="19251" href="#8679" class="Datatype">𝒫</a> <a id="19253" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a><a id="19254" class="Symbol">)</a> <a id="19256" class="Symbol">(</a><a id="19257" href="#19257" class="Bound">g</a> <a id="19259" class="Symbol">:</a> <a id="19261" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="19263" class="Symbol">→</a> <a id="19265" href="#8679" class="Datatype">𝒫</a> <a id="19267" href="../code/probability/ProbabilityModule.Utils.html#206" class="Generalizable">B</a><a id="19268" class="Symbol">)</a> <a id="19270" class="Symbol">→</a> <a id="19272" class="Symbol">(</a><a id="19273" href="#19243" class="Bound">xs</a> <a id="19276" href="#13390" class="Function Operator">∪</a> <a id="19278" href="#19246" class="Bound">ys</a><a id="19280" class="Symbol">)</a> <a id="19282" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="19286" href="#19257" class="Bound">g</a> <a id="19288" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">≡</a> <a id="19290" class="Symbol">(</a><a id="19291" href="#19243" class="Bound">xs</a> <a id="19294" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="19298" href="#19257" class="Bound">g</a><a id="19299" class="Symbol">)</a> <a id="19301" href="#13390" class="Function Operator">∪</a> <a id="19303" class="Symbol">(</a><a id="19304" href="#19246" class="Bound">ys</a> <a id="19307" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="19311" href="#19257" class="Bound">g</a><a id="19312" class="Symbol">)</a>
<a id="19314" href="#19228" class="Function">&gt;&gt;=-distrib</a> <a id="19326" class="Symbol">=</a> <a id="19328" class="Symbol">λ</a> <a id="19330" href="#19330" class="Bound">xs</a> <a id="19333" href="#19333" class="Bound">ys</a> <a id="19336" href="#19336" class="Bound">g</a> <a id="19338" class="Symbol">→</a> <a id="19340" href="#12103" class="Function Operator">⟦</a> <a id="19342" href="#19395" class="Function">&gt;&gt;=-distrib′</a> <a id="19355" href="#19333" class="Bound">ys</a> <a id="19358" href="#19336" class="Bound">g</a> <a id="19360" href="#12103" class="Function Operator">⟧⇓</a> <a id="19363" href="#19330" class="Bound">xs</a>
  <a id="19368" class="Keyword">module</a> <a id="BindDistrib"></a><a id="19375" href="#19375" class="Module">BindDistrib</a> <a id="19387" class="Keyword">where</a>
  <a id="BindDistrib.&gt;&gt;=-distrib′"></a><a id="19395" href="#19395" class="Function">&gt;&gt;=-distrib′</a> <a id="19408" class="Symbol">:</a> <a id="19410" class="Symbol">(</a><a id="19411" href="#19411" class="Bound">ys</a> <a id="19414" class="Symbol">:</a> <a id="19416" href="#8679" class="Datatype">𝒫</a> <a id="19418" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a><a id="19419" class="Symbol">)</a> <a id="19421" class="Symbol">(</a><a id="19422" href="#19422" class="Bound">g</a> <a id="19424" class="Symbol">:</a> <a id="19426" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="19428" class="Symbol">→</a> <a id="19430" href="#8679" class="Datatype">𝒫</a> <a id="19432" href="../code/probability/ProbabilityModule.Utils.html#206" class="Generalizable">B</a><a id="19433" class="Symbol">)</a> <a id="19435" class="Symbol">→</a> <a id="19437" href="#12139" class="Function">⟦</a> <a id="19439" href="#19439" class="Bound">xs</a> <a id="19442" href="#12139" class="Function">∈𝒫</a> <a id="19445" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="19447" href="#12139" class="Function">⇒</a> <a id="19449" class="Symbol">((</a><a id="19451" href="#19439" class="Bound">xs</a> <a id="19454" href="#13390" class="Function Operator">∪</a> <a id="19456" href="#19411" class="Bound">ys</a><a id="19458" class="Symbol">)</a> <a id="19460" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="19464" href="#19422" class="Bound">g</a><a id="19465" class="Symbol">)</a> <a id="19467" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">≡</a> <a id="19469" class="Symbol">(</a><a id="19470" href="#19439" class="Bound">xs</a> <a id="19473" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="19477" href="#19422" class="Bound">g</a><a id="19478" class="Symbol">)</a> <a id="19480" href="#13390" class="Function Operator">∪</a> <a id="19482" class="Symbol">(</a><a id="19483" href="#19411" class="Bound">ys</a> <a id="19486" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="19490" href="#19422" class="Bound">g</a><a id="19491" class="Symbol">)</a> <a id="19493" href="#12139" class="Function">⟧</a>
  <a id="19497" href="#11443" class="Field Operator">⟦</a> <a id="19499" href="#19395" class="Function">&gt;&gt;=-distrib′</a> <a id="19512" href="#19512" class="Bound">ys</a> <a id="19515" href="#19515" class="Bound">g</a> <a id="19517" href="#11443" class="Field Operator">⟧-prop</a> <a id="19524" class="Symbol">=</a> <a id="19526" href="#8921" class="InductiveConstructor">trunc</a> <a id="19532" class="Symbol">_</a> <a id="19534" class="Symbol">_</a>
  <a id="19538" href="#11481" class="Field Operator">⟦</a> <a id="19540" href="#19395" class="Function">&gt;&gt;=-distrib′</a> <a id="19553" href="#19553" class="Bound">ys</a> <a id="19556" href="#19556" class="Bound">g</a> <a id="19558" href="#11481" class="Field Operator">⟧[]</a> <a id="19562" class="Symbol">=</a> <a id="19564" href="../code/probability/Cubical.Foundations.Prelude.html#827" class="Function">refl</a>
  <a id="19571" href="#11498" class="Field Operator">⟦</a> <a id="19573" href="#19395" class="Function">&gt;&gt;=-distrib′</a> <a id="19586" href="#19586" class="Bound">ys</a> <a id="19589" href="#19589" class="Bound">g</a> <a id="19591" href="#11498" class="Field Operator">⟧</a> <a id="19593" href="#19593" class="Bound">p</a> <a id="19595" href="#11498" class="Field Operator">&amp;</a> <a id="19597" href="#19597" class="Bound">x</a> <a id="19599" href="#11498" class="Field Operator">∷</a> <a id="19601" href="#19601" class="Bound">xs</a> <a id="19604" href="#11498" class="Field Operator">⟨</a> <a id="19606" href="#19606" class="Bound">P</a> <a id="19608" href="#11498" class="Field Operator">⟩</a> <a id="19610" class="Symbol">=</a>
    <a id="19616" class="Symbol">(((</a><a id="19619" href="#19593" class="Bound">p</a> <a id="19621" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="19623" href="#19597" class="Bound">x</a> <a id="19625" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="19627" href="#19601" class="Bound">xs</a><a id="19629" class="Symbol">)</a> <a id="19631" href="#13390" class="Function Operator">∪</a> <a id="19633" href="#19586" class="Bound">ys</a><a id="19635" class="Symbol">)</a> <a id="19637" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="19641" href="#19589" class="Bound">g</a><a id="19642" class="Symbol">)</a> <a id="19644" href="../code/probability/ProbabilityModule.Utils.html#572" class="Function Operator">≡⟨⟩</a>
    <a id="19652" class="Symbol">(</a><a id="19653" href="#19593" class="Bound">p</a> <a id="19655" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="19657" href="#19597" class="Bound">x</a> <a id="19659" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="19661" href="#19601" class="Bound">xs</a> <a id="19664" href="#13390" class="Function Operator">∪</a> <a id="19666" href="#19586" class="Bound">ys</a><a id="19668" class="Symbol">)</a> <a id="19670" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="19674" href="#19589" class="Bound">g</a> <a id="19676" href="../code/probability/ProbabilityModule.Utils.html#572" class="Function Operator">≡⟨⟩</a>
    <a id="19684" href="#19593" class="Bound">p</a> <a id="19686" href="#14109" class="Function Operator">⋊</a> <a id="19688" href="#19589" class="Bound">g</a> <a id="19690" href="#19597" class="Bound">x</a> <a id="19692" href="#13390" class="Function Operator">∪</a> <a id="19694" class="Symbol">((</a><a id="19696" href="#19601" class="Bound">xs</a> <a id="19699" href="#13390" class="Function Operator">∪</a> <a id="19701" href="#19586" class="Bound">ys</a><a id="19703" class="Symbol">)</a> <a id="19705" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="19709" href="#19589" class="Bound">g</a><a id="19710" class="Symbol">)</a> <a id="19712" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">≡⟨</a> <a id="19715" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="19720" class="Symbol">(</a><a id="19721" href="#19593" class="Bound">p</a> <a id="19723" href="#14109" class="Function Operator">⋊</a> <a id="19725" href="#19589" class="Bound">g</a> <a id="19727" href="#19597" class="Bound">x</a> <a id="19729" href="#13390" class="Function Operator">∪_</a><a id="19731" class="Symbol">)</a> <a id="19733" href="#19606" class="Bound">P</a> <a id="19735" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">⟩</a>
    <a id="19741" href="#19593" class="Bound">p</a> <a id="19743" href="#14109" class="Function Operator">⋊</a> <a id="19745" href="#19589" class="Bound">g</a> <a id="19747" href="#19597" class="Bound">x</a> <a id="19749" href="#13390" class="Function Operator">∪</a> <a id="19751" class="Symbol">((</a><a id="19753" href="#19601" class="Bound">xs</a> <a id="19756" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="19760" href="#19589" class="Bound">g</a><a id="19761" class="Symbol">)</a> <a id="19763" href="#13390" class="Function Operator">∪</a> <a id="19765" class="Symbol">(</a><a id="19766" href="#19586" class="Bound">ys</a> <a id="19769" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="19773" href="#19589" class="Bound">g</a><a id="19774" class="Symbol">))</a> <a id="19777" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">≡⟨</a> <a id="19780" href="#13658" class="Function">∪-assoc</a> <a id="19788" class="Symbol">(</a><a id="19789" href="#19593" class="Bound">p</a> <a id="19791" href="#14109" class="Function Operator">⋊</a> <a id="19793" href="#19589" class="Bound">g</a> <a id="19795" href="#19597" class="Bound">x</a><a id="19796" class="Symbol">)</a> <a id="19798" class="Symbol">(</a><a id="19799" href="#19601" class="Bound">xs</a> <a id="19802" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="19806" href="#19589" class="Bound">g</a><a id="19807" class="Symbol">)</a> <a id="19809" class="Symbol">(</a><a id="19810" href="#19586" class="Bound">ys</a> <a id="19813" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="19817" href="#19589" class="Bound">g</a><a id="19818" class="Symbol">)</a> <a id="19820" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">⟩</a>
    <a id="19826" class="Symbol">(</a><a id="19827" href="#19593" class="Bound">p</a> <a id="19829" href="#14109" class="Function Operator">⋊</a> <a id="19831" href="#19589" class="Bound">g</a> <a id="19833" href="#19597" class="Bound">x</a> <a id="19835" href="#13390" class="Function Operator">∪</a> <a id="19837" class="Symbol">(</a><a id="19838" href="#19601" class="Bound">xs</a> <a id="19841" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="19845" href="#19589" class="Bound">g</a><a id="19846" class="Symbol">))</a> <a id="19849" href="#13390" class="Function Operator">∪</a> <a id="19851" class="Symbol">(</a><a id="19852" href="#19586" class="Bound">ys</a> <a id="19855" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="19859" href="#19589" class="Bound">g</a><a id="19860" class="Symbol">)</a> <a id="19862" href="../code/probability/ProbabilityModule.Utils.html#572" class="Function Operator">≡⟨⟩</a>
    <a id="19870" class="Symbol">((</a><a id="19872" href="#19593" class="Bound">p</a> <a id="19874" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="19876" href="#19597" class="Bound">x</a> <a id="19878" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="19880" href="#19601" class="Bound">xs</a><a id="19882" class="Symbol">)</a> <a id="19884" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="19888" href="#19589" class="Bound">g</a><a id="19889" class="Symbol">)</a> <a id="19891" href="#13390" class="Function Operator">∪</a> <a id="19893" class="Symbol">(</a><a id="19894" href="#19586" class="Bound">ys</a> <a id="19897" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="19901" href="#19589" class="Bound">g</a><a id="19902" class="Symbol">)</a> <a id="19904" href="../code/probability/Cubical.Foundations.Prelude.html#2745" class="Function Operator">∎</a>

<a id="*-assoc-⋊"></a><a id="19907" href="#19907" class="Function">*-assoc-⋊</a> <a id="19917" class="Symbol">:</a> <a id="19919" class="Symbol">∀</a> <a id="19921" href="#19921" class="Bound">p</a> <a id="19923" href="#19923" class="Bound">q</a> <a id="19925" class="Symbol">(</a><a id="19926" href="#19926" class="Bound">xs</a> <a id="19929" class="Symbol">:</a> <a id="19931" href="#8679" class="Datatype">𝒫</a> <a id="19933" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a><a id="19934" class="Symbol">)</a> <a id="19936" class="Symbol">→</a> <a id="19938" class="Symbol">(</a><a id="19939" href="#19921" class="Bound">p</a> <a id="19941" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="19943" href="#19923" class="Bound">q</a><a id="19944" class="Symbol">)</a> <a id="19946" href="#14109" class="Function Operator">⋊</a> <a id="19948" href="#19926" class="Bound">xs</a> <a id="19951" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">≡</a> <a id="19953" href="#19921" class="Bound">p</a> <a id="19955" href="#14109" class="Function Operator">⋊</a> <a id="19957" class="Symbol">(</a><a id="19958" href="#19923" class="Bound">q</a> <a id="19960" href="#14109" class="Function Operator">⋊</a> <a id="19962" href="#19926" class="Bound">xs</a><a id="19964" class="Symbol">)</a>
<a id="19966" href="#19907" class="Function">*-assoc-⋊</a> <a id="19976" class="Symbol">=</a> <a id="19978" class="Symbol">λ</a> <a id="19980" href="#19980" class="Bound">p</a> <a id="19982" href="#19982" class="Bound">q</a> <a id="19984" class="Symbol">→</a> <a id="19986" href="#12103" class="Function Operator">⟦</a> <a id="19988" href="#20031" class="Function">*-assoc-⋊′</a> <a id="19999" href="#19980" class="Bound">p</a> <a id="20001" href="#19982" class="Bound">q</a> <a id="20003" href="#12103" class="Function Operator">⟧⇓</a>
  <a id="20008" class="Keyword">module</a> <a id="MAssocJ"></a><a id="20015" href="#20015" class="Module">MAssocJ</a> <a id="20023" class="Keyword">where</a>
  <a id="MAssocJ.*-assoc-⋊′"></a><a id="20031" href="#20031" class="Function">*-assoc-⋊′</a> <a id="20042" class="Symbol">:</a> <a id="20044" class="Symbol">∀</a> <a id="20046" href="#20046" class="Bound">p</a> <a id="20048" href="#20048" class="Bound">q</a> <a id="20050" class="Symbol">→</a> <a id="20052" href="#12139" class="Function">⟦</a> <a id="20054" href="#20054" class="Bound">xs</a> <a id="20057" href="#12139" class="Function">∈𝒫</a> <a id="20060" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="20062" href="#12139" class="Function">⇒</a> <a id="20064" class="Symbol">(</a><a id="20065" href="#20046" class="Bound">p</a> <a id="20067" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="20069" href="#20048" class="Bound">q</a><a id="20070" class="Symbol">)</a> <a id="20072" href="#14109" class="Function Operator">⋊</a> <a id="20074" href="#20054" class="Bound">xs</a> <a id="20077" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">≡</a> <a id="20079" href="#20046" class="Bound">p</a> <a id="20081" href="#14109" class="Function Operator">⋊</a> <a id="20083" class="Symbol">(</a><a id="20084" href="#20048" class="Bound">q</a> <a id="20086" href="#14109" class="Function Operator">⋊</a> <a id="20088" href="#20054" class="Bound">xs</a><a id="20090" class="Symbol">)</a> <a id="20092" href="#12139" class="Function">⟧</a>
  <a id="20096" href="#11443" class="Field Operator">⟦</a> <a id="20098" href="#20031" class="Function">*-assoc-⋊′</a> <a id="20109" href="#20109" class="Bound">p</a> <a id="20111" href="#20111" class="Bound">q</a> <a id="20113" href="#11443" class="Field Operator">⟧-prop</a> <a id="20120" class="Symbol">=</a> <a id="20122" href="#8921" class="InductiveConstructor">trunc</a> <a id="20128" class="Symbol">_</a> <a id="20130" class="Symbol">_</a>
  <a id="20134" href="#11481" class="Field Operator">⟦</a> <a id="20136" href="#20031" class="Function">*-assoc-⋊′</a> <a id="20147" href="#20147" class="Bound">p</a> <a id="20149" href="#20149" class="Bound">q</a> <a id="20151" href="#11481" class="Field Operator">⟧[]</a> <a id="20155" class="Symbol">=</a> <a id="20157" href="../code/probability/Cubical.Foundations.Prelude.html#827" class="Function">refl</a>
  <a id="20164" href="#11498" class="Field Operator">⟦</a> <a id="20166" href="#20031" class="Function">*-assoc-⋊′</a> <a id="20177" href="#20177" class="Bound">p</a> <a id="20179" href="#20179" class="Bound">q</a> <a id="20181" href="#11498" class="Field Operator">⟧</a> <a id="20183" href="#20183" class="Bound">r</a> <a id="20185" href="#11498" class="Field Operator">&amp;</a> <a id="20187" href="#20187" class="Bound">x</a> <a id="20189" href="#11498" class="Field Operator">∷</a> <a id="20191" href="#20191" class="Bound">xs</a> <a id="20194" href="#11498" class="Field Operator">⟨</a> <a id="20196" href="#20196" class="Bound">P</a> <a id="20198" href="#11498" class="Field Operator">⟩</a> <a id="20200" class="Symbol">=</a>
    <a id="20206" href="#20177" class="Bound">p</a> <a id="20208" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="20210" href="#20179" class="Bound">q</a> <a id="20212" href="#14109" class="Function Operator">⋊</a> <a id="20214" class="Symbol">(</a><a id="20215" href="#20183" class="Bound">r</a> <a id="20217" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="20219" href="#20187" class="Bound">x</a> <a id="20221" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="20223" href="#20191" class="Bound">xs</a><a id="20225" class="Symbol">)</a> <a id="20227" href="../code/probability/ProbabilityModule.Utils.html#572" class="Function Operator">≡⟨⟩</a>
    <a id="20235" href="#20177" class="Bound">p</a> <a id="20237" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="20239" href="#20179" class="Bound">q</a> <a id="20241" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="20243" href="#20183" class="Bound">r</a> <a id="20245" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="20247" href="#20187" class="Bound">x</a> <a id="20249" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="20251" class="Symbol">(</a><a id="20252" href="#20177" class="Bound">p</a> <a id="20254" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="20256" href="#20179" class="Bound">q</a> <a id="20258" href="#14109" class="Function Operator">⋊</a> <a id="20260" href="#20191" class="Bound">xs</a><a id="20262" class="Symbol">)</a> <a id="20264" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">≡⟨</a> <a id="20267" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="20272" class="Symbol">(</a><a id="20273" href="#8727" class="InductiveConstructor Operator">_&amp;</a> <a id="20276" href="#20187" class="Bound">x</a> <a id="20278" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="20280" class="Symbol">(</a><a id="20281" href="#20177" class="Bound">p</a> <a id="20283" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="20285" href="#20179" class="Bound">q</a> <a id="20287" href="#14109" class="Function Operator">⋊</a> <a id="20289" href="#20191" class="Bound">xs</a><a id="20291" class="Symbol">))</a> <a id="20294" class="Symbol">(</a><a id="20295" href="../code/probability/ProbabilityModule.Semirings.html#326" class="Field">*-assoc</a> <a id="20303" href="#20177" class="Bound">p</a> <a id="20305" href="#20179" class="Bound">q</a> <a id="20307" href="#20183" class="Bound">r</a><a id="20308" class="Symbol">)</a> <a id="20310" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">⟩</a>
    <a id="20316" href="#20177" class="Bound">p</a> <a id="20318" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="20320" class="Symbol">(</a><a id="20321" href="#20179" class="Bound">q</a> <a id="20323" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="20325" href="#20183" class="Bound">r</a><a id="20326" class="Symbol">)</a> <a id="20328" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="20330" href="#20187" class="Bound">x</a> <a id="20332" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="20334" class="Symbol">(</a><a id="20335" href="#20177" class="Bound">p</a> <a id="20337" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="20339" href="#20179" class="Bound">q</a> <a id="20341" href="#14109" class="Function Operator">⋊</a> <a id="20343" href="#20191" class="Bound">xs</a><a id="20345" class="Symbol">)</a> <a id="20347" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">≡⟨</a> <a id="20350" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="20355" class="Symbol">(</a><a id="20356" href="#20177" class="Bound">p</a> <a id="20358" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="20360" class="Symbol">(</a><a id="20361" href="#20179" class="Bound">q</a> <a id="20363" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="20365" href="#20183" class="Bound">r</a><a id="20366" class="Symbol">)</a> <a id="20368" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="20370" href="#20187" class="Bound">x</a> <a id="20372" href="#8727" class="InductiveConstructor Operator">∷_</a><a id="20374" class="Symbol">)</a> <a id="20376" href="#20196" class="Bound">P</a> <a id="20378" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">⟩</a>
    <a id="20384" href="#20177" class="Bound">p</a> <a id="20386" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="20388" class="Symbol">(</a><a id="20389" href="#20179" class="Bound">q</a> <a id="20391" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="20393" href="#20183" class="Bound">r</a><a id="20394" class="Symbol">)</a> <a id="20396" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="20398" href="#20187" class="Bound">x</a> <a id="20400" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="20402" class="Symbol">(</a><a id="20403" href="#20177" class="Bound">p</a> <a id="20405" href="#14109" class="Function Operator">⋊</a> <a id="20407" class="Symbol">(</a><a id="20408" href="#20179" class="Bound">q</a> <a id="20410" href="#14109" class="Function Operator">⋊</a> <a id="20412" href="#20191" class="Bound">xs</a><a id="20414" class="Symbol">))</a> <a id="20417" href="../code/probability/ProbabilityModule.Utils.html#572" class="Function Operator">≡⟨⟩</a>
    <a id="20425" href="#20177" class="Bound">p</a> <a id="20427" href="#14109" class="Function Operator">⋊</a> <a id="20429" class="Symbol">(</a><a id="20430" href="#20179" class="Bound">q</a> <a id="20432" href="#14109" class="Function Operator">⋊</a> <a id="20434" class="Symbol">(</a><a id="20435" href="#20183" class="Bound">r</a> <a id="20437" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="20439" href="#20187" class="Bound">x</a> <a id="20441" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="20443" href="#20191" class="Bound">xs</a><a id="20445" class="Symbol">))</a> <a id="20448" href="../code/probability/Cubical.Foundations.Prelude.html#2745" class="Function Operator">∎</a>

<a id="⋊-assoc-&gt;&gt;="></a><a id="20451" href="#20451" class="Function">⋊-assoc-&gt;&gt;=</a> <a id="20463" class="Symbol">:</a> <a id="20465" class="Symbol">∀</a> <a id="20467" href="#20467" class="Bound">p</a> <a id="20469" class="Symbol">(</a><a id="20470" href="#20470" class="Bound">xs</a> <a id="20473" class="Symbol">:</a> <a id="20475" href="#8679" class="Datatype">𝒫</a> <a id="20477" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a><a id="20478" class="Symbol">)</a> <a id="20480" class="Symbol">(</a><a id="20481" href="#20481" class="Bound">f</a> <a id="20483" class="Symbol">:</a> <a id="20485" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="20487" class="Symbol">→</a> <a id="20489" href="#8679" class="Datatype">𝒫</a> <a id="20491" href="../code/probability/ProbabilityModule.Utils.html#206" class="Generalizable">B</a><a id="20492" class="Symbol">)</a> <a id="20494" class="Symbol">→</a> <a id="20496" class="Symbol">(</a><a id="20497" href="#20467" class="Bound">p</a> <a id="20499" href="#14109" class="Function Operator">⋊</a> <a id="20501" href="#20470" class="Bound">xs</a><a id="20503" class="Symbol">)</a> <a id="20505" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="20509" href="#20481" class="Bound">f</a> <a id="20511" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">≡</a> <a id="20513" href="#20467" class="Bound">p</a> <a id="20515" href="#14109" class="Function Operator">⋊</a> <a id="20517" class="Symbol">(</a><a id="20518" href="#20470" class="Bound">xs</a> <a id="20521" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="20525" href="#20481" class="Bound">f</a><a id="20526" class="Symbol">)</a>
<a id="20528" href="#20451" class="Function">⋊-assoc-&gt;&gt;=</a> <a id="20540" class="Symbol">=</a> <a id="20542" class="Symbol">λ</a> <a id="20544" href="#20544" class="Bound">p</a> <a id="20546" href="#20546" class="Bound">xs</a> <a id="20549" href="#20549" class="Bound">f</a> <a id="20551" class="Symbol">→</a> <a id="20553" href="#12103" class="Function Operator">⟦</a> <a id="20555" href="#20605" class="Function">⋊-assoc-&gt;&gt;=′</a> <a id="20568" href="#20544" class="Bound">p</a> <a id="20570" href="#20549" class="Bound">f</a> <a id="20572" href="#12103" class="Function Operator">⟧⇓</a> <a id="20575" href="#20546" class="Bound">xs</a>
  <a id="20580" class="Keyword">module</a> <a id="JDistribB"></a><a id="20587" href="#20587" class="Module">JDistribB</a> <a id="20597" class="Keyword">where</a>
  <a id="JDistribB.⋊-assoc-&gt;&gt;=′"></a><a id="20605" href="#20605" class="Function">⋊-assoc-&gt;&gt;=′</a> <a id="20618" class="Symbol">:</a> <a id="20620" class="Symbol">∀</a> <a id="20622" href="#20622" class="Bound">p</a> <a id="20624" class="Symbol">(</a><a id="20625" href="#20625" class="Bound">f</a> <a id="20627" class="Symbol">:</a> <a id="20629" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="20631" class="Symbol">→</a> <a id="20633" href="#8679" class="Datatype">𝒫</a> <a id="20635" href="../code/probability/ProbabilityModule.Utils.html#206" class="Generalizable">B</a><a id="20636" class="Symbol">)</a> <a id="20638" class="Symbol">→</a> <a id="20640" href="#12139" class="Function">⟦</a> <a id="20642" href="#20642" class="Bound">xs</a> <a id="20645" href="#12139" class="Function">∈𝒫</a> <a id="20648" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="20650" href="#12139" class="Function">⇒</a> <a id="20652" class="Symbol">(</a><a id="20653" href="#20622" class="Bound">p</a> <a id="20655" href="#14109" class="Function Operator">⋊</a> <a id="20657" href="#20642" class="Bound">xs</a><a id="20659" class="Symbol">)</a> <a id="20661" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="20665" href="#20625" class="Bound">f</a> <a id="20667" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">≡</a> <a id="20669" href="#20622" class="Bound">p</a> <a id="20671" href="#14109" class="Function Operator">⋊</a> <a id="20673" class="Symbol">(</a><a id="20674" href="#20642" class="Bound">xs</a> <a id="20677" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="20681" href="#20625" class="Bound">f</a><a id="20682" class="Symbol">)</a> <a id="20684" href="#12139" class="Function">⟧</a>
  <a id="20688" href="#11443" class="Field Operator">⟦</a> <a id="20690" href="#20605" class="Function">⋊-assoc-&gt;&gt;=′</a> <a id="20703" href="#20703" class="Bound">p</a> <a id="20705" href="#20705" class="Bound">f</a> <a id="20707" href="#11443" class="Field Operator">⟧-prop</a> <a id="20714" class="Symbol">=</a> <a id="20716" href="#8921" class="InductiveConstructor">trunc</a> <a id="20722" class="Symbol">_</a> <a id="20724" class="Symbol">_</a>
  <a id="20728" href="#11481" class="Field Operator">⟦</a> <a id="20730" href="#20605" class="Function">⋊-assoc-&gt;&gt;=′</a> <a id="20743" href="#20743" class="Bound">p</a> <a id="20745" href="#20745" class="Bound">f</a> <a id="20747" href="#11481" class="Field Operator">⟧[]</a> <a id="20751" class="Symbol">=</a> <a id="20753" href="../code/probability/Cubical.Foundations.Prelude.html#827" class="Function">refl</a>
  <a id="20760" href="#11498" class="Field Operator">⟦</a> <a id="20762" href="#20605" class="Function">⋊-assoc-&gt;&gt;=′</a> <a id="20775" href="#20775" class="Bound">p</a> <a id="20777" href="#20777" class="Bound">f</a> <a id="20779" href="#11498" class="Field Operator">⟧</a> <a id="20781" href="#20781" class="Bound">q</a> <a id="20783" href="#11498" class="Field Operator">&amp;</a> <a id="20785" href="#20785" class="Bound">x</a> <a id="20787" href="#11498" class="Field Operator">∷</a> <a id="20789" href="#20789" class="Bound">xs</a> <a id="20792" href="#11498" class="Field Operator">⟨</a> <a id="20794" href="#20794" class="Bound">P</a> <a id="20796" href="#11498" class="Field Operator">⟩</a> <a id="20798" class="Symbol">=</a>
    <a id="20804" class="Symbol">(</a><a id="20805" href="#20775" class="Bound">p</a> <a id="20807" href="#14109" class="Function Operator">⋊</a> <a id="20809" class="Symbol">(</a><a id="20810" href="#20781" class="Bound">q</a> <a id="20812" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="20814" href="#20785" class="Bound">x</a> <a id="20816" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="20818" href="#20789" class="Bound">xs</a><a id="20820" class="Symbol">))</a> <a id="20823" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="20827" href="#20777" class="Bound">f</a> <a id="20829" href="../code/probability/ProbabilityModule.Utils.html#572" class="Function Operator">≡⟨⟩</a>
    <a id="20837" class="Symbol">(</a><a id="20838" href="#20775" class="Bound">p</a> <a id="20840" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="20842" href="#20781" class="Bound">q</a> <a id="20844" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="20846" href="#20785" class="Bound">x</a> <a id="20848" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="20850" href="#20775" class="Bound">p</a> <a id="20852" href="#14109" class="Function Operator">⋊</a> <a id="20854" href="#20789" class="Bound">xs</a><a id="20856" class="Symbol">)</a> <a id="20858" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="20862" href="#20777" class="Bound">f</a> <a id="20864" href="../code/probability/ProbabilityModule.Utils.html#572" class="Function Operator">≡⟨⟩</a>
    <a id="20872" class="Symbol">((</a><a id="20874" href="#20775" class="Bound">p</a> <a id="20876" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="20878" href="#20781" class="Bound">q</a><a id="20879" class="Symbol">)</a> <a id="20881" href="#14109" class="Function Operator">⋊</a> <a id="20883" href="#20777" class="Bound">f</a> <a id="20885" href="#20785" class="Bound">x</a><a id="20886" class="Symbol">)</a> <a id="20888" href="#13390" class="Function Operator">∪</a> <a id="20890" class="Symbol">((</a><a id="20892" href="#20775" class="Bound">p</a> <a id="20894" href="#14109" class="Function Operator">⋊</a> <a id="20896" href="#20789" class="Bound">xs</a><a id="20898" class="Symbol">)</a> <a id="20900" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="20904" href="#20777" class="Bound">f</a><a id="20905" class="Symbol">)</a> <a id="20907" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">≡⟨</a> <a id="20910" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="20915" class="Symbol">(((</a><a id="20918" href="#20775" class="Bound">p</a> <a id="20920" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="20922" href="#20781" class="Bound">q</a><a id="20923" class="Symbol">)</a> <a id="20925" href="#14109" class="Function Operator">⋊</a> <a id="20927" href="#20777" class="Bound">f</a> <a id="20929" href="#20785" class="Bound">x</a><a id="20930" class="Symbol">)</a> <a id="20932" href="#13390" class="Function Operator">∪_</a><a id="20934" class="Symbol">)</a> <a id="20936" href="#20794" class="Bound">P</a> <a id="20938" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">⟩</a>
    <a id="20944" class="Symbol">((</a><a id="20946" href="#20775" class="Bound">p</a> <a id="20948" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="20950" href="#20781" class="Bound">q</a><a id="20951" class="Symbol">)</a> <a id="20953" href="#14109" class="Function Operator">⋊</a> <a id="20955" href="#20777" class="Bound">f</a> <a id="20957" href="#20785" class="Bound">x</a><a id="20958" class="Symbol">)</a> <a id="20960" href="#13390" class="Function Operator">∪</a> <a id="20962" class="Symbol">(</a><a id="20963" href="#20775" class="Bound">p</a> <a id="20965" href="#14109" class="Function Operator">⋊</a> <a id="20967" class="Symbol">(</a><a id="20968" href="#20789" class="Bound">xs</a> <a id="20971" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="20975" href="#20777" class="Bound">f</a><a id="20976" class="Symbol">))</a> <a id="20979" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">≡⟨</a> <a id="20982" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="20987" class="Symbol">(</a><a id="20988" href="#13390" class="Function Operator">_∪</a> <a id="20991" class="Symbol">(</a><a id="20992" href="#20775" class="Bound">p</a> <a id="20994" href="#14109" class="Function Operator">⋊</a> <a id="20996" class="Symbol">(</a><a id="20997" href="#20789" class="Bound">xs</a> <a id="21000" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="21004" href="#20777" class="Bound">f</a><a id="21005" class="Symbol">)))</a> <a id="21009" class="Symbol">(</a><a id="21010" href="#19907" class="Function">*-assoc-⋊</a> <a id="21020" href="#20775" class="Bound">p</a> <a id="21022" href="#20781" class="Bound">q</a> <a id="21024" class="Symbol">(</a><a id="21025" href="#20777" class="Bound">f</a> <a id="21027" href="#20785" class="Bound">x</a><a id="21028" class="Symbol">))</a> <a id="21031" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">⟩</a>
    <a id="21037" class="Symbol">(</a><a id="21038" href="#20775" class="Bound">p</a> <a id="21040" href="#14109" class="Function Operator">⋊</a> <a id="21042" class="Symbol">(</a><a id="21043" href="#20781" class="Bound">q</a> <a id="21045" href="#14109" class="Function Operator">⋊</a> <a id="21047" href="#20777" class="Bound">f</a> <a id="21049" href="#20785" class="Bound">x</a><a id="21050" class="Symbol">))</a> <a id="21053" href="#13390" class="Function Operator">∪</a> <a id="21055" class="Symbol">(</a><a id="21056" href="#20775" class="Bound">p</a> <a id="21058" href="#14109" class="Function Operator">⋊</a> <a id="21060" class="Symbol">(</a><a id="21061" href="#20789" class="Bound">xs</a> <a id="21064" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="21068" href="#20777" class="Bound">f</a><a id="21069" class="Symbol">))</a> <a id="21072" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">≡⟨</a> <a id="21075" href="#16654" class="Function">⋊-distribˡ</a> <a id="21086" href="#20775" class="Bound">p</a> <a id="21088" class="Symbol">(</a><a id="21089" href="#20781" class="Bound">q</a> <a id="21091" href="#14109" class="Function Operator">⋊</a> <a id="21093" href="#20777" class="Bound">f</a> <a id="21095" href="#20785" class="Bound">x</a><a id="21096" class="Symbol">)</a> <a id="21098" class="Symbol">(</a><a id="21099" href="#20789" class="Bound">xs</a> <a id="21102" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="21106" href="#20777" class="Bound">f</a><a id="21107" class="Symbol">)</a> <a id="21109" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">⟩</a>
    <a id="21115" href="#20775" class="Bound">p</a> <a id="21117" href="#14109" class="Function Operator">⋊</a> <a id="21119" class="Symbol">((</a><a id="21121" href="#20781" class="Bound">q</a> <a id="21123" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="21125" href="#20785" class="Bound">x</a> <a id="21127" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="21129" href="#20789" class="Bound">xs</a><a id="21131" class="Symbol">)</a> <a id="21133" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="21137" href="#20777" class="Bound">f</a><a id="21138" class="Symbol">)</a> <a id="21140" href="../code/probability/Cubical.Foundations.Prelude.html#2745" class="Function Operator">∎</a>

<a id="&gt;&gt;=-idˡ"></a><a id="21143" href="#21143" class="Function">&gt;&gt;=-idˡ</a> <a id="21151" class="Symbol">:</a> <a id="21153" class="Symbol">(</a><a id="21154" href="#21154" class="Bound">x</a> <a id="21156" class="Symbol">:</a> <a id="21158" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a><a id="21159" class="Symbol">)</a> <a id="21161" class="Symbol">→</a> <a id="21163" class="Symbol">(</a><a id="21164" href="#21164" class="Bound">f</a> <a id="21166" class="Symbol">:</a> <a id="21168" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="21170" class="Symbol">→</a> <a id="21172" href="#8679" class="Datatype">𝒫</a> <a id="21174" href="../code/probability/ProbabilityModule.Utils.html#206" class="Generalizable">B</a><a id="21175" class="Symbol">)</a>
      <a id="21183" class="Symbol">→</a> <a id="21185" class="Symbol">(</a><a id="21186" href="#15418" class="Function">pure</a> <a id="21191" href="#21154" class="Bound">x</a> <a id="21193" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="21197" href="#21164" class="Bound">f</a><a id="21198" class="Symbol">)</a> <a id="21200" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">≡</a> <a id="21202" href="#21164" class="Bound">f</a> <a id="21204" href="#21154" class="Bound">x</a>
<a id="21206" href="#21143" class="Function">&gt;&gt;=-idˡ</a> <a id="21214" href="#21214" class="Bound">x</a> <a id="21216" href="#21216" class="Bound">f</a> <a id="21218" class="Symbol">=</a>
  <a id="21222" href="#15418" class="Function">pure</a> <a id="21227" href="#21214" class="Bound">x</a> <a id="21229" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="21233" href="#21216" class="Bound">f</a> <a id="21235" href="../code/probability/ProbabilityModule.Utils.html#572" class="Function Operator">≡⟨⟩</a>
  <a id="21241" class="Symbol">(</a><a id="21242" href="../code/probability/ProbabilityModule.Semirings.html#265" class="Field">1#</a> <a id="21245" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="21247" href="#21214" class="Bound">x</a> <a id="21249" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="21251" href="#8715" class="InductiveConstructor">[]</a><a id="21253" class="Symbol">)</a> <a id="21255" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="21259" href="#21216" class="Bound">f</a> <a id="21261" href="../code/probability/ProbabilityModule.Utils.html#572" class="Function Operator">≡⟨⟩</a>
  <a id="21267" href="../code/probability/ProbabilityModule.Semirings.html#265" class="Field">1#</a> <a id="21270" href="#14109" class="Function Operator">⋊</a> <a id="21272" href="#21216" class="Bound">f</a> <a id="21274" href="#21214" class="Bound">x</a> <a id="21276" href="#13390" class="Function Operator">∪</a> <a id="21278" href="#8715" class="InductiveConstructor">[]</a> <a id="21281" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="21285" href="#21216" class="Bound">f</a> <a id="21287" href="../code/probability/ProbabilityModule.Utils.html#572" class="Function Operator">≡⟨⟩</a>
  <a id="21293" href="../code/probability/ProbabilityModule.Semirings.html#265" class="Field">1#</a> <a id="21296" href="#14109" class="Function Operator">⋊</a> <a id="21298" href="#21216" class="Bound">f</a> <a id="21300" href="#21214" class="Bound">x</a> <a id="21302" href="#13390" class="Function Operator">∪</a> <a id="21304" href="#8715" class="InductiveConstructor">[]</a> <a id="21307" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">≡⟨</a> <a id="21310" href="#17140" class="Function">∪-idʳ</a> <a id="21316" class="Symbol">(</a><a id="21317" href="../code/probability/ProbabilityModule.Semirings.html#265" class="Field">1#</a> <a id="21320" href="#14109" class="Function Operator">⋊</a> <a id="21322" href="#21216" class="Bound">f</a> <a id="21324" href="#21214" class="Bound">x</a><a id="21325" class="Symbol">)</a> <a id="21327" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">⟩</a>
  <a id="21331" href="../code/probability/ProbabilityModule.Semirings.html#265" class="Field">1#</a> <a id="21334" href="#14109" class="Function Operator">⋊</a> <a id="21336" href="#21216" class="Bound">f</a> <a id="21338" href="#21214" class="Bound">x</a> <a id="21340" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">≡⟨</a> <a id="21343" href="#18904" class="Function">1⋊</a> <a id="21346" class="Symbol">(</a><a id="21347" href="#21216" class="Bound">f</a> <a id="21349" href="#21214" class="Bound">x</a><a id="21350" class="Symbol">)</a> <a id="21352" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">⟩</a>
  <a id="21356" href="#21216" class="Bound">f</a> <a id="21358" href="#21214" class="Bound">x</a> <a id="21360" href="../code/probability/Cubical.Foundations.Prelude.html#2745" class="Function Operator">∎</a>

<a id="&gt;&gt;=-idʳ"></a><a id="21363" href="#21363" class="Function">&gt;&gt;=-idʳ</a> <a id="21371" class="Symbol">:</a> <a id="21373" class="Symbol">(</a><a id="21374" href="#21374" class="Bound">xs</a> <a id="21377" class="Symbol">:</a> <a id="21379" href="#8679" class="Datatype">𝒫</a> <a id="21381" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a><a id="21382" class="Symbol">)</a> <a id="21384" class="Symbol">→</a> <a id="21386" href="#21374" class="Bound">xs</a> <a id="21389" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="21393" href="#15418" class="Function">pure</a> <a id="21398" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">≡</a> <a id="21400" href="#21374" class="Bound">xs</a>
<a id="21403" href="#21363" class="Function">&gt;&gt;=-idʳ</a> <a id="21411" class="Symbol">=</a> <a id="21413" href="#12103" class="Function Operator">⟦</a> <a id="21415" href="#21449" class="Function">&gt;&gt;=-idʳ′</a> <a id="21424" href="#12103" class="Function Operator">⟧⇓</a>
  <a id="21429" class="Keyword">module</a> <a id="Law1"></a><a id="21436" href="#21436" class="Module">Law1</a> <a id="21441" class="Keyword">where</a>
  <a id="Law1.&gt;&gt;=-idʳ′"></a><a id="21449" href="#21449" class="Function">&gt;&gt;=-idʳ′</a> <a id="21458" class="Symbol">:</a> <a id="21460" href="#12139" class="Function">⟦</a> <a id="21462" href="#21462" class="Bound">xs</a> <a id="21465" href="#12139" class="Function">∈𝒫</a> <a id="21468" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="21470" href="#12139" class="Function">⇒</a> <a id="21472" href="#21462" class="Bound">xs</a> <a id="21475" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="21479" href="#15418" class="Function">pure</a> <a id="21484" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">≡</a> <a id="21486" href="#21462" class="Bound">xs</a> <a id="21489" href="#12139" class="Function">⟧</a>
  <a id="21493" href="#11443" class="Field Operator">⟦</a> <a id="21495" href="#21449" class="Function">&gt;&gt;=-idʳ′</a> <a id="21504" href="#11443" class="Field Operator">⟧-prop</a> <a id="21511" class="Symbol">=</a> <a id="21513" href="#8921" class="InductiveConstructor">trunc</a> <a id="21519" class="Symbol">_</a> <a id="21521" class="Symbol">_</a>
  <a id="21525" href="#11481" class="Field Operator">⟦</a> <a id="21527" href="#21449" class="Function">&gt;&gt;=-idʳ′</a> <a id="21536" href="#11481" class="Field Operator">⟧[]</a> <a id="21540" class="Symbol">=</a> <a id="21542" href="../code/probability/Cubical.Foundations.Prelude.html#827" class="Function">refl</a>
  <a id="21549" href="#11498" class="Field Operator">⟦</a> <a id="21551" href="#21449" class="Function">&gt;&gt;=-idʳ′</a> <a id="21560" href="#11498" class="Field Operator">⟧</a> <a id="21562" href="#21562" class="Bound">p</a> <a id="21564" href="#11498" class="Field Operator">&amp;</a> <a id="21566" href="#21566" class="Bound">x</a> <a id="21568" href="#11498" class="Field Operator">∷</a> <a id="21570" href="#21570" class="Bound">xs</a> <a id="21573" href="#11498" class="Field Operator">⟨</a> <a id="21575" href="#21575" class="Bound">P</a> <a id="21577" href="#11498" class="Field Operator">⟩</a> <a id="21579" class="Symbol">=</a>
    <a id="21585" class="Symbol">((</a><a id="21587" href="#21562" class="Bound">p</a> <a id="21589" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="21591" href="#21566" class="Bound">x</a> <a id="21593" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="21595" href="#21570" class="Bound">xs</a><a id="21597" class="Symbol">)</a> <a id="21599" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="21603" href="#15418" class="Function">pure</a><a id="21607" class="Symbol">)</a> <a id="21609" href="../code/probability/ProbabilityModule.Utils.html#572" class="Function Operator">≡⟨⟩</a>
    <a id="21617" href="#21562" class="Bound">p</a> <a id="21619" href="#14109" class="Function Operator">⋊</a> <a id="21621" class="Symbol">(</a><a id="21622" href="#15418" class="Function">pure</a> <a id="21627" href="#21566" class="Bound">x</a><a id="21628" class="Symbol">)</a> <a id="21630" href="#13390" class="Function Operator">∪</a> <a id="21632" class="Symbol">(</a><a id="21633" href="#21570" class="Bound">xs</a> <a id="21636" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="21640" href="#15418" class="Function">pure</a><a id="21644" class="Symbol">)</a> <a id="21646" href="../code/probability/ProbabilityModule.Utils.html#572" class="Function Operator">≡⟨⟩</a>
    <a id="21654" href="#21562" class="Bound">p</a> <a id="21656" href="#14109" class="Function Operator">⋊</a> <a id="21658" class="Symbol">(</a><a id="21659" href="../code/probability/ProbabilityModule.Semirings.html#265" class="Field">1#</a> <a id="21662" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="21664" href="#21566" class="Bound">x</a> <a id="21666" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="21668" href="#8715" class="InductiveConstructor">[]</a><a id="21670" class="Symbol">)</a> <a id="21672" href="#13390" class="Function Operator">∪</a> <a id="21674" class="Symbol">(</a><a id="21675" href="#21570" class="Bound">xs</a> <a id="21678" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="21682" href="#15418" class="Function">pure</a><a id="21686" class="Symbol">)</a> <a id="21688" href="../code/probability/ProbabilityModule.Utils.html#572" class="Function Operator">≡⟨⟩</a>
    <a id="21696" href="#21562" class="Bound">p</a> <a id="21698" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="21700" href="../code/probability/ProbabilityModule.Semirings.html#265" class="Field">1#</a> <a id="21703" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="21705" href="#21566" class="Bound">x</a> <a id="21707" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="21709" href="#8715" class="InductiveConstructor">[]</a> <a id="21712" href="#13390" class="Function Operator">∪</a> <a id="21714" class="Symbol">(</a><a id="21715" href="#21570" class="Bound">xs</a> <a id="21718" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="21722" href="#15418" class="Function">pure</a><a id="21726" class="Symbol">)</a> <a id="21728" href="../code/probability/ProbabilityModule.Utils.html#572" class="Function Operator">≡⟨⟩</a>
    <a id="21736" href="#21562" class="Bound">p</a> <a id="21738" href="../code/probability/ProbabilityModule.Semirings.html#234" class="Field Operator">*</a> <a id="21740" href="../code/probability/ProbabilityModule.Semirings.html#265" class="Field">1#</a> <a id="21743" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="21745" href="#21566" class="Bound">x</a> <a id="21747" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="21749" class="Symbol">(</a><a id="21750" href="#21570" class="Bound">xs</a> <a id="21753" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="21757" href="#15418" class="Function">pure</a><a id="21761" class="Symbol">)</a> <a id="21763" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">≡⟨</a> <a id="21766" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="21771" class="Symbol">(</a><a id="21772" href="#8727" class="InductiveConstructor Operator">_&amp;</a> <a id="21775" href="#21566" class="Bound">x</a> <a id="21777" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="21779" class="Symbol">(</a><a id="21780" href="#21570" class="Bound">xs</a> <a id="21783" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="21787" href="#15418" class="Function">pure</a><a id="21791" class="Symbol">))</a> <a id="21794" class="Symbol">(</a><a id="21795" href="../code/probability/ProbabilityModule.Semirings.html#456" class="Field">*1</a> <a id="21798" href="#21562" class="Bound">p</a><a id="21799" class="Symbol">)</a> <a id="21801" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">⟩</a>
    <a id="21807" href="#21562" class="Bound">p</a> <a id="21809" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="21811" href="#21566" class="Bound">x</a> <a id="21813" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="21815" href="#21570" class="Bound">xs</a> <a id="21818" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="21822" href="#15418" class="Function">pure</a> <a id="21827" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">≡⟨</a> <a id="21830" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="21835" class="Symbol">(</a><a id="21836" href="#21562" class="Bound">p</a> <a id="21838" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="21840" href="#21566" class="Bound">x</a> <a id="21842" href="#8727" class="InductiveConstructor Operator">∷_</a><a id="21844" class="Symbol">)</a> <a id="21846" href="#21575" class="Bound">P</a> <a id="21848" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">⟩</a>
    <a id="21854" href="#21562" class="Bound">p</a> <a id="21856" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="21858" href="#21566" class="Bound">x</a> <a id="21860" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="21862" href="#21570" class="Bound">xs</a> <a id="21865" href="../code/probability/Cubical.Foundations.Prelude.html#2745" class="Function Operator">∎</a>

<a id="&gt;&gt;=-assoc"></a><a id="21868" href="#21868" class="Function">&gt;&gt;=-assoc</a> <a id="21878" class="Symbol">:</a> <a id="21880" class="Symbol">(</a><a id="21881" href="#21881" class="Bound">xs</a> <a id="21884" class="Symbol">:</a> <a id="21886" href="#8679" class="Datatype">𝒫</a> <a id="21888" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a><a id="21889" class="Symbol">)</a> <a id="21891" class="Symbol">→</a> <a id="21893" class="Symbol">(</a><a id="21894" href="#21894" class="Bound">f</a> <a id="21896" class="Symbol">:</a> <a id="21898" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="21900" class="Symbol">→</a> <a id="21902" href="#8679" class="Datatype">𝒫</a> <a id="21904" href="../code/probability/ProbabilityModule.Utils.html#206" class="Generalizable">B</a><a id="21905" class="Symbol">)</a> <a id="21907" class="Symbol">→</a> <a id="21909" class="Symbol">(</a><a id="21910" href="#21910" class="Bound">g</a> <a id="21912" class="Symbol">:</a> <a id="21914" href="../code/probability/ProbabilityModule.Utils.html#206" class="Generalizable">B</a> <a id="21916" class="Symbol">→</a> <a id="21918" href="#8679" class="Datatype">𝒫</a> <a id="21920" href="../code/probability/ProbabilityModule.Utils.html#218" class="Generalizable">C</a><a id="21921" class="Symbol">)</a>
      <a id="21929" class="Symbol">→</a> <a id="21931" class="Symbol">((</a><a id="21933" href="#21881" class="Bound">xs</a> <a id="21936" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="21940" href="#21894" class="Bound">f</a><a id="21941" class="Symbol">)</a> <a id="21943" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="21947" href="#21910" class="Bound">g</a><a id="21948" class="Symbol">)</a> <a id="21950" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">≡</a> <a id="21952" href="#21881" class="Bound">xs</a> <a id="21955" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="21959" class="Symbol">(λ</a> <a id="21962" href="#21962" class="Bound">x</a> <a id="21964" class="Symbol">→</a> <a id="21966" href="#21894" class="Bound">f</a> <a id="21968" href="#21962" class="Bound">x</a> <a id="21970" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="21974" href="#21910" class="Bound">g</a><a id="21975" class="Symbol">)</a>
<a id="21977" href="#21868" class="Function">&gt;&gt;=-assoc</a> <a id="21987" class="Symbol">=</a> <a id="21989" class="Symbol">λ</a> <a id="21991" href="#21991" class="Bound">xs</a> <a id="21994" href="#21994" class="Bound">f</a> <a id="21996" href="#21996" class="Bound">g</a> <a id="21998" class="Symbol">→</a> <a id="22000" href="#12103" class="Function Operator">⟦</a> <a id="22002" href="#22045" class="Function">&gt;&gt;=-assoc′</a> <a id="22013" href="#21994" class="Bound">f</a> <a id="22015" href="#21996" class="Bound">g</a> <a id="22017" href="#12103" class="Function Operator">⟧⇓</a> <a id="22020" href="#21991" class="Bound">xs</a>
  <a id="22025" class="Keyword">module</a> <a id="Law3"></a><a id="22032" href="#22032" class="Module">Law3</a> <a id="22037" class="Keyword">where</a>
  <a id="Law3.&gt;&gt;=-assoc′"></a><a id="22045" href="#22045" class="Function">&gt;&gt;=-assoc′</a> <a id="22056" class="Symbol">:</a> <a id="22058" class="Symbol">(</a><a id="22059" href="#22059" class="Bound">f</a> <a id="22061" class="Symbol">:</a> <a id="22063" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="22065" class="Symbol">→</a> <a id="22067" href="#8679" class="Datatype">𝒫</a> <a id="22069" href="../code/probability/ProbabilityModule.Utils.html#206" class="Generalizable">B</a><a id="22070" class="Symbol">)</a> <a id="22072" class="Symbol">→</a> <a id="22074" class="Symbol">(</a><a id="22075" href="#22075" class="Bound">g</a> <a id="22077" class="Symbol">:</a> <a id="22079" href="../code/probability/ProbabilityModule.Utils.html#206" class="Generalizable">B</a> <a id="22081" class="Symbol">→</a> <a id="22083" href="#8679" class="Datatype">𝒫</a> <a id="22085" href="../code/probability/ProbabilityModule.Utils.html#218" class="Generalizable">C</a><a id="22086" class="Symbol">)</a> <a id="22088" class="Symbol">→</a> <a id="22090" href="#12139" class="Function">⟦</a> <a id="22092" href="#22092" class="Bound">xs</a> <a id="22095" href="#12139" class="Function">∈𝒫</a> <a id="22098" href="../code/probability/ProbabilityModule.Utils.html#194" class="Generalizable">A</a> <a id="22100" href="#12139" class="Function">⇒</a> <a id="22102" class="Symbol">((</a><a id="22104" href="#22092" class="Bound">xs</a> <a id="22107" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="22111" href="#22059" class="Bound">f</a><a id="22112" class="Symbol">)</a> <a id="22114" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="22118" href="#22075" class="Bound">g</a><a id="22119" class="Symbol">)</a> <a id="22121" href="Agda.Builtin.Cubical.Path.html#353" class="Function Operator">≡</a> <a id="22123" href="#22092" class="Bound">xs</a> <a id="22126" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="22130" class="Symbol">(λ</a> <a id="22133" href="#22133" class="Bound">x</a> <a id="22135" class="Symbol">→</a> <a id="22137" href="#22059" class="Bound">f</a> <a id="22139" href="#22133" class="Bound">x</a> <a id="22141" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="22145" href="#22075" class="Bound">g</a><a id="22146" class="Symbol">)</a> <a id="22148" href="#12139" class="Function">⟧</a>
  <a id="22152" href="#11443" class="Field Operator">⟦</a> <a id="22154" href="#22045" class="Function">&gt;&gt;=-assoc′</a> <a id="22165" href="#22165" class="Bound">f</a> <a id="22167" href="#22167" class="Bound">g</a> <a id="22169" href="#11443" class="Field Operator">⟧-prop</a> <a id="22176" class="Symbol">=</a> <a id="22178" href="#8921" class="InductiveConstructor">trunc</a> <a id="22184" class="Symbol">_</a> <a id="22186" class="Symbol">_</a>
  <a id="22190" href="#11481" class="Field Operator">⟦</a> <a id="22192" href="#22045" class="Function">&gt;&gt;=-assoc′</a> <a id="22203" href="#22203" class="Bound">f</a> <a id="22205" href="#22205" class="Bound">g</a> <a id="22207" href="#11481" class="Field Operator">⟧[]</a> <a id="22211" class="Symbol">=</a> <a id="22213" href="../code/probability/Cubical.Foundations.Prelude.html#827" class="Function">refl</a>
  <a id="22220" href="#11498" class="Field Operator">⟦</a> <a id="22222" href="#22045" class="Function">&gt;&gt;=-assoc′</a> <a id="22233" href="#22233" class="Bound">f</a> <a id="22235" href="#22235" class="Bound">g</a> <a id="22237" href="#11498" class="Field Operator">⟧</a> <a id="22239" href="#22239" class="Bound">p</a> <a id="22241" href="#11498" class="Field Operator">&amp;</a> <a id="22243" href="#22243" class="Bound">x</a> <a id="22245" href="#11498" class="Field Operator">∷</a> <a id="22247" href="#22247" class="Bound">xs</a> <a id="22250" href="#11498" class="Field Operator">⟨</a> <a id="22252" href="#22252" class="Bound">P</a> <a id="22254" href="#11498" class="Field Operator">⟩</a> <a id="22256" class="Symbol">=</a>
    <a id="22262" class="Symbol">(((</a><a id="22265" href="#22239" class="Bound">p</a> <a id="22267" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="22269" href="#22243" class="Bound">x</a> <a id="22271" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="22273" href="#22247" class="Bound">xs</a><a id="22275" class="Symbol">)</a> <a id="22277" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="22281" href="#22233" class="Bound">f</a><a id="22282" class="Symbol">)</a> <a id="22284" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="22288" href="#22235" class="Bound">g</a><a id="22289" class="Symbol">)</a> <a id="22291" href="../code/probability/ProbabilityModule.Utils.html#572" class="Function Operator">≡⟨⟩</a>
    <a id="22299" class="Symbol">((</a><a id="22301" href="#22239" class="Bound">p</a> <a id="22303" href="#14109" class="Function Operator">⋊</a> <a id="22305" href="#22233" class="Bound">f</a> <a id="22307" href="#22243" class="Bound">x</a> <a id="22309" href="#13390" class="Function Operator">∪</a> <a id="22311" class="Symbol">(</a><a id="22312" href="#22247" class="Bound">xs</a> <a id="22315" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="22319" href="#22233" class="Bound">f</a><a id="22320" class="Symbol">))</a> <a id="22323" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="22327" href="#22235" class="Bound">g</a><a id="22328" class="Symbol">)</a> <a id="22330" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">≡⟨</a> <a id="22333" href="#19228" class="Function">&gt;&gt;=-distrib</a> <a id="22345" class="Symbol">(</a><a id="22346" href="#22239" class="Bound">p</a> <a id="22348" href="#14109" class="Function Operator">⋊</a> <a id="22350" href="#22233" class="Bound">f</a> <a id="22352" href="#22243" class="Bound">x</a><a id="22353" class="Symbol">)</a> <a id="22355" class="Symbol">(</a><a id="22356" href="#22247" class="Bound">xs</a> <a id="22359" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="22363" href="#22233" class="Bound">f</a><a id="22364" class="Symbol">)</a> <a id="22366" href="#22235" class="Bound">g</a> <a id="22368" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">⟩</a>
    <a id="22374" class="Symbol">((</a><a id="22376" href="#22239" class="Bound">p</a> <a id="22378" href="#14109" class="Function Operator">⋊</a> <a id="22380" href="#22233" class="Bound">f</a> <a id="22382" href="#22243" class="Bound">x</a><a id="22383" class="Symbol">)</a> <a id="22385" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="22389" href="#22235" class="Bound">g</a><a id="22390" class="Symbol">)</a> <a id="22392" href="#13390" class="Function Operator">∪</a> <a id="22394" class="Symbol">((</a><a id="22396" href="#22247" class="Bound">xs</a> <a id="22399" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="22403" href="#22233" class="Bound">f</a><a id="22404" class="Symbol">)</a> <a id="22406" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="22410" href="#22235" class="Bound">g</a><a id="22411" class="Symbol">)</a> <a id="22413" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">≡⟨</a> <a id="22416" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="22421" class="Symbol">((</a><a id="22423" href="#22239" class="Bound">p</a> <a id="22425" href="#14109" class="Function Operator">⋊</a> <a id="22427" href="#22233" class="Bound">f</a> <a id="22429" href="#22243" class="Bound">x</a><a id="22430" class="Symbol">)</a> <a id="22432" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="22436" href="#22235" class="Bound">g</a> <a id="22438" href="#13390" class="Function Operator">∪_</a><a id="22440" class="Symbol">)</a> <a id="22442" href="#22252" class="Bound">P</a> <a id="22444" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">⟩</a>
    <a id="22450" class="Symbol">((</a><a id="22452" href="#22239" class="Bound">p</a> <a id="22454" href="#14109" class="Function Operator">⋊</a> <a id="22456" href="#22233" class="Bound">f</a> <a id="22458" href="#22243" class="Bound">x</a><a id="22459" class="Symbol">)</a> <a id="22461" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="22465" href="#22235" class="Bound">g</a><a id="22466" class="Symbol">)</a> <a id="22468" href="#13390" class="Function Operator">∪</a> <a id="22470" class="Symbol">(</a><a id="22471" href="#22247" class="Bound">xs</a> <a id="22474" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="22478" class="Symbol">(λ</a> <a id="22481" href="#22481" class="Bound">y</a> <a id="22483" class="Symbol">→</a> <a id="22485" href="#22233" class="Bound">f</a> <a id="22487" href="#22481" class="Bound">y</a> <a id="22489" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="22493" href="#22235" class="Bound">g</a><a id="22494" class="Symbol">))</a> <a id="22497" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">≡⟨</a> <a id="22500" href="../code/probability/Cubical.Foundations.Prelude.html#1027" class="Function">cong</a> <a id="22505" class="Symbol">(</a><a id="22506" href="#13390" class="Function Operator">_∪</a> <a id="22509" class="Symbol">(</a><a id="22510" href="#22247" class="Bound">xs</a> <a id="22513" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="22517" class="Symbol">(λ</a> <a id="22520" href="#22520" class="Bound">y</a> <a id="22522" class="Symbol">→</a> <a id="22524" href="#22233" class="Bound">f</a> <a id="22526" href="#22520" class="Bound">y</a> <a id="22528" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="22532" href="#22235" class="Bound">g</a><a id="22533" class="Symbol">)))</a> <a id="22537" class="Symbol">(</a><a id="22538" href="#20451" class="Function">⋊-assoc-&gt;&gt;=</a> <a id="22550" href="#22239" class="Bound">p</a> <a id="22552" class="Symbol">(</a><a id="22553" href="#22233" class="Bound">f</a> <a id="22555" href="#22243" class="Bound">x</a><a id="22556" class="Symbol">)</a> <a id="22558" href="#22235" class="Bound">g</a><a id="22559" class="Symbol">)</a> <a id="22561" href="../code/probability/ProbabilityModule.Utils.html#436" class="Function">⟩</a>
    <a id="22567" href="#22239" class="Bound">p</a> <a id="22569" href="#14109" class="Function Operator">⋊</a> <a id="22571" class="Symbol">(</a><a id="22572" href="#22233" class="Bound">f</a> <a id="22574" href="#22243" class="Bound">x</a> <a id="22576" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="22580" href="#22235" class="Bound">g</a><a id="22581" class="Symbol">)</a> <a id="22583" href="#13390" class="Function Operator">∪</a> <a id="22585" class="Symbol">(</a><a id="22586" href="#22247" class="Bound">xs</a> <a id="22589" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="22593" class="Symbol">(λ</a> <a id="22596" href="#22596" class="Bound">y</a> <a id="22598" class="Symbol">→</a> <a id="22600" href="#22233" class="Bound">f</a> <a id="22602" href="#22596" class="Bound">y</a> <a id="22604" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="22608" href="#22235" class="Bound">g</a><a id="22609" class="Symbol">))</a> <a id="22612" href="../code/probability/ProbabilityModule.Utils.html#572" class="Function Operator">≡⟨⟩</a>
    <a id="22620" class="Symbol">((</a><a id="22622" href="#22239" class="Bound">p</a> <a id="22624" href="#8727" class="InductiveConstructor Operator">&amp;</a> <a id="22626" href="#22243" class="Bound">x</a> <a id="22628" href="#8727" class="InductiveConstructor Operator">∷</a> <a id="22630" href="#22247" class="Bound">xs</a><a id="22632" class="Symbol">)</a> <a id="22634" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="22638" class="Symbol">(λ</a> <a id="22641" href="#22641" class="Bound">y</a> <a id="22643" class="Symbol">→</a> <a id="22645" href="#22233" class="Bound">f</a> <a id="22647" href="#22641" class="Bound">y</a> <a id="22649" href="#18081" class="Function Operator">&gt;&gt;=</a> <a id="22653" href="#22235" class="Bound">g</a><a id="22654" class="Symbol">))</a> <a id="22657" href="../code/probability/Cubical.Foundations.Prelude.html#2745" class="Function Operator">∎</a>
</pre>
</details>
<h1 id="conclusion">Conclusion</h1>
<p>I’ve really enjoyed working with cubical Agda so far, and the proofs above were a pleasure to write. I think I can use the above definition to get a workable differential privacy monad, also.</p>
<p>Anyway, all the code is available <a href="https://oisdk.github.io/agda-cubical-probability/Probability.html">here</a>.</p>
]]></description>
    <pubDate>Wed, 17 Apr 2019 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2019-04-17-cubical-probability.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Permutations By Sorting</title>
    <link>https://doisinkidney.com/posts/2019-03-24-permutations-by-sorting.html</link>
    <description><![CDATA[<div class="info">
    Posted on March 24, 2019
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Agda.html">Agda</a>
    
</div>

<p>A naive—and wrong—way to shuffle a list is to assign each element in the list a random number, and then sort it. It might not be immediately obvious why: <span class="citation" data-cites="kiselyov_provably_2002">Kiselyov (<a href="#ref-kiselyov_provably_2002">2002</a>)</span> has a good explanation as to the problem. One way to think about it is like this: choosing <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> random numbers each in the range <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">[0,n)</annotation></semantics></math> has <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>n</mi><mi>n</mi></msup><annotation encoding="application/x-tex">n^n</annotation></semantics></math> possible outcomes, whereas there are <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>!</mi></mrow><annotation encoding="application/x-tex">n!</annotation></semantics></math> permutations. Since these don’t necessarily divide evenly into each other, you’re going to have some bias.</p>
<h1 id="factorial-numbers">Factorial Numbers</h1>
<p>The first part of the fix is to figure out a way to get some random data that has only <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>!</mi></mrow><annotation encoding="application/x-tex">n!</annotation></semantics></math> possible values. The trick here will be to mimic the structure of a factorial itself: taking <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">n = 5</annotation></semantics></math>, the previous technique would have yielded:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn><mo>×</mo><mn>5</mn><mo>×</mo><mn>5</mn><mo>×</mo><mn>5</mn><mo>×</mo><mn>5</mn><mo>=</mo><msup><mn>5</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">5 \times 5 \times 5 \times 5 \times 5 = 5^5</annotation></semantics></math></p>
<p>possible values. But we want:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn><mo>×</mo><mn>4</mn><mo>×</mo><mn>3</mn><mo>×</mo><mn>2</mn><mo>×</mo><mn>1</mn><mo>=</mo><mn>5</mn><mi>!</mi></mrow><annotation encoding="application/x-tex">5 \times 4 \times 3 \times 2 \times 1 = 5!</annotation></semantics></math></p>
<p>The solution is simple, then! Simply decrement the range by one for each position in the output list. In Haskell:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">nums ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> [<span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">nums <span class="dv">0</span> <span class="fu">=</span> pure []</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">nums n <span class="fu">=</span> (<span class="fu">:</span>) <span class="fu">&lt;$&gt;</span> randomR (<span class="dv">0</span>,n) <span class="fu">&lt;*&gt;</span> nums (n<span class="fu">-</span><span class="dv">1</span>)</a></code></pre></div>
<p>As an aside, what we’ve done here is constructed a list of digits in the <a href="https://en.wikipedia.org/wiki/Factorial_number_system">factorial number system</a>.</p>
<h1 id="sorts">Sorts</h1>
<p>Unfortunately, while we’ve figured out a way to get properly distributed random data, we can’t yet sort it to shuffle our list. If we look at the 6 factorial numbers generated for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">n = 5</annotation></semantics></math>, we can see the problem:</p>
<pre><code>000
010
100
110
200
210</code></pre>
<p>Different values in the list will produce the same sort: <code>100</code> and <code>200</code>, for instance.</p>
<h1 id="lehmer-codes">Lehmer Codes</h1>
<p>We need a way to map the numbers above to a particular permutations: that’s precisely the problem solved by <a href="https://en.wikipedia.org/wiki/Lehmer_code">Lehmer codes</a>. For the numbers <code>110</code>, we can think of each digit as the relative position to put that item from the string into. Some Haskell code might make it clear:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">insert ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">insert <span class="dv">0</span> x xs <span class="fu">=</span> x <span class="fu">:</span> xs</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">insert i x (y<span class="fu">:</span>ys) <span class="fu">=</span> y <span class="fu">:</span> insert (i<span class="fu">-</span><span class="dv">1</span>) x ys</a>
<a class="sourceLine" id="cb3-4" data-line-number="4"></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="ot">shuffle ::</span> [a] <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">shuffle xs ys <span class="fu">=</span> foldr (uncurry insert) [] (zip ys xs)</a></code></pre></div>
<p>And we can step through its execution:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">shuffle <span class="st">&quot;abc&quot;</span> [<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>]</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">foldr (uncurry insert) [] [(<span class="dv">1</span>,<span class="ch">&#39;a&#39;</span>),(<span class="dv">1</span>,<span class="ch">&#39;b&#39;</span>),(<span class="dv">0</span>,<span class="ch">&#39;c&#39;</span>)]</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">insert <span class="dv">1</span> <span class="ch">&#39;a&#39;</span> (insert <span class="dv">1</span> <span class="ch">&#39;b&#39;</span> (insert <span class="dv">0</span> <span class="ch">&#39;c&#39;</span> []))</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">insert <span class="dv">1</span> <span class="ch">&#39;a&#39;</span> (insert <span class="dv">1</span> <span class="ch">&#39;b&#39;</span> <span class="st">&quot;c&quot;</span>)</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">insert <span class="dv">1</span> <span class="ch">&#39;a&#39;</span> <span class="st">&quot;cb&quot;</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6"><span class="ch">&#39;c&#39;</span> <span class="fu">:</span> insert <span class="dv">0</span> <span class="ch">&#39;a&#39;</span> <span class="st">&quot;b&quot;</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7"><span class="st">&quot;cab&quot;</span></a></code></pre></div>
<h1 id="dualities-of-sorts">Dualities of Sorts</h1>
<p>Notice the similarity of the function above to a standard insertion sort:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">insert ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">insert x [] <span class="fu">=</span> x <span class="fu">:</span> []</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">insert x (y<span class="fu">:</span>ys)</a>
<a class="sourceLine" id="cb5-4" data-line-number="4"> <span class="fu">|</span> x <span class="fu">&lt;=</span> y <span class="fu">=</span> x <span class="fu">:</span> y <span class="fu">:</span> ys</a>
<a class="sourceLine" id="cb5-5" data-line-number="5"> <span class="fu">|</span> otherwise <span class="fu">=</span> y <span class="fu">:</span> insert x ys</a>
<a class="sourceLine" id="cb5-6" data-line-number="6"></a>
<a class="sourceLine" id="cb5-7" data-line-number="7"><span class="ot">insertSort ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb5-8" data-line-number="8">insertSort <span class="fu">=</span> foldr insert []</a></code></pre></div>
<p>The “comparison” is a little strange—we have to take into account relative position—but the shape is almost identical. Once I spot something like that, my first thought is to see if the relationship extends to a better <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n \log n)</annotation></semantics></math> sort, but there’s something else I’d like to look at first.</p>
<p>“A Duality of Sorts” <span class="citation" data-cites="hinze_duality_2013">(Hinze, Magalhães, and Wu <a href="#ref-hinze_duality_2013">2013</a>)</span> is a paper based on the interesting symmetry between insertion sort and selection sort <span class="citation" data-cites="haran_sorting_2016">(There’s also a video of Graham Hutton explaining the idea; Haran <a href="#ref-haran_sorting_2016">2016</a>)</span>.</p>
<p>With that paper in mind, can we rewrite <code>shuffle</code> as a selection-based algorithm? We can indeed!</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">pop ::</span> [(<span class="dt">Int</span>,a)] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, [(<span class="dt">Int</span>,a)])</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">pop [] <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">pop ((<span class="dv">0</span>,x)<span class="fu">:</span>xs) <span class="fu">=</span> <span class="dt">Just</span> (x, xs)</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">pop ((i,x)<span class="fu">:</span>xs) <span class="fu">=</span> (fmap<span class="fu">.</span>fmap) ((i<span class="fu">-</span><span class="dv">1</span>,x)<span class="fu">:</span>) (pop xs)</a>
<a class="sourceLine" id="cb6-5" data-line-number="5"></a>
<a class="sourceLine" id="cb6-6" data-line-number="6"><span class="ot">shuffle ::</span> [a] <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">shuffle xs ys <span class="fu">=</span> unfoldr pop (zip ys xs)</a></code></pre></div>
<p>While the symmetry is pleasing, the paper details how to make the relationship explicit, using the same function for both selection and insertion sort:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1">swop <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">swop (<span class="dt">Cons</span> a (x , <span class="dt">Nil</span>)) <span class="fu">=</span> <span class="dt">Cons</span> a (<span class="dt">Left</span> x)</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">swop (<span class="dt">Cons</span> a (x , <span class="dt">Cons</span> b x&#39;))</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">  <span class="fu">|</span> fst a <span class="fu">==</span> <span class="dv">0</span> <span class="fu">=</span> <span class="dt">Cons</span> a (<span class="dt">Left</span> x)</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">  <span class="fu">|</span> otherwise  <span class="fu">=</span> <span class="dt">Cons</span> b (<span class="dt">Right</span> (<span class="dt">Cons</span> (first pred a) x&#39;))</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">  </a>
<a class="sourceLine" id="cb7-7" data-line-number="7"><span class="ot">ishuffle ::</span> [(<span class="dt">Int</span>,a)] <span class="ot">-&gt;</span> [(<span class="dt">Int</span>,a)]</a>
<a class="sourceLine" id="cb7-8" data-line-number="8">ishuffle <span class="fu">=</span> cata (apo (swop <span class="fu">.</span> fmap (id <span class="fu">&amp;&amp;&amp;</span> project)))</a>
<a class="sourceLine" id="cb7-9" data-line-number="9"></a>
<a class="sourceLine" id="cb7-10" data-line-number="10"><span class="ot">sshuffle ::</span> [(<span class="dt">Int</span>,a)] <span class="ot">-&gt;</span> [(<span class="dt">Int</span>,a)]</a>
<a class="sourceLine" id="cb7-11" data-line-number="11">sshuffle <span class="fu">=</span> ana (para (fmap (id <span class="fu">|||</span> embed) <span class="fu">.</span> swop))</a></code></pre></div>
<h1 id="improved-efficiency">Improved Efficiency</h1>
<p>So now we have to upgrade our sorts: in the paper, merge sort is the more efficient sort chosen, similarly to what I chose <a href="2018-12-21-balancing-scans.html#random-shuffles">previously</a>.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">merge [] ys <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">merge xs [] <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">merge ((x,i)<span class="fu">:</span>xs) ((y,j)<span class="fu">:</span>ys)</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">  <span class="fu">|</span> i <span class="fu">&lt;=</span> j    <span class="fu">=</span> (x,i) <span class="fu">:</span> merge xs ((y,j<span class="fu">-</span>i)<span class="fu">:</span>ys)</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">  <span class="fu">|</span> otherwise <span class="fu">=</span> (y,j) <span class="fu">:</span> merge ((x,i<span class="fu">-</span>j<span class="fu">-</span><span class="dv">1</span>)<span class="fu">:</span>xs) ys</a>
<a class="sourceLine" id="cb8-6" data-line-number="6">  </a>
<a class="sourceLine" id="cb8-7" data-line-number="7"><span class="ot">treeFold ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb8-8" data-line-number="8">treeFold f <span class="fu">=</span> go</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-10" data-line-number="10">    go x [] <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb8-11" data-line-number="11">    go a (b<span class="fu">:</span>l) <span class="fu">=</span> go (f a b) (pairMap l)</a>
<a class="sourceLine" id="cb8-12" data-line-number="12">    pairMap (x<span class="fu">:</span>y<span class="fu">:</span>rest) <span class="fu">=</span> f x y <span class="fu">:</span> pairMap rest</a>
<a class="sourceLine" id="cb8-13" data-line-number="13">    pairMap xs <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb8-14" data-line-number="14">    </a>
<a class="sourceLine" id="cb8-15" data-line-number="15">shuffle xs inds <span class="fu">=</span> map fst <span class="fu">$</span> treeFold merge [] <span class="fu">$</span> map pure <span class="fu">$</span> zip xs inds</a></code></pre></div>
<p>However, I feel like merge sort is an upgrade of <em>insertion</em> sort, not selection sort. Indeed, if you do the “split” step of merge sort badly, i.e. by splitting very unevenly, merge sort in fact <em>becomes</em> insertion sort!</p>
<p>So there’s a missing bit of this table:</p>
<table>
<thead>
<tr class="header">
<th></th>
<th style="text-align: center;">Insertion</th>
<th style="text-align: center;">Selection</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n^2)</annotation></semantics></math></td>
<td style="text-align: center;">Insertion sort</td>
<td style="text-align: center;">Selection sort</td>
</tr>
<tr class="even">
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n \log n)</annotation></semantics></math></td>
<td style="text-align: center;">Merge sort</td>
<td style="text-align: center;">???</td>
</tr>
</tbody>
</table>
<p>I think it’s clear that quicksort is the algorithm that fits in there: again, done badly it degrades to selection sort (if you intentionally pick the pivot to be the worst element possible, i.e. the smallest element).</p>
<p>There are more symmetries: merge sort splits the lists using their structure, and merges them using the ordering of the elements. Quicksort is the opposite, merging by concatenation, but splitting using order. Finally, in merge sort adjacent elements are in the correct order after the recursive call, but the two sides of the split are not. Again, quicksort is precisely the opposite: adjacent elements have not been compared (<em>before</em> the recursive call), but the two sides of the split are correctly ordered.</p>
<p>Anyway, I haven’t yet formalised this duality (and I don’t know if I can), but we <em>can</em> use it to produce a quicksort-based shuffle algorithm:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1">partition <span class="fu">=</span> foldr f (const ([],[]))</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">    f (y,j) ys i</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">      <span class="fu">|</span> i <span class="fu">&lt;=</span> j    <span class="fu">=</span> fmap  ((y,j<span class="fu">-</span>i)<span class="fu">:</span>) (ys i)</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">      <span class="fu">|</span> otherwise <span class="fu">=</span> first ((y,j)<span class="fu">:</span>) (ys (i<span class="fu">-</span><span class="dv">1</span>))</a>
<a class="sourceLine" id="cb9-6" data-line-number="6">      </a>
<a class="sourceLine" id="cb9-7" data-line-number="7"><span class="ot">shuffle ::</span> [a] <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb9-8" data-line-number="8">shuffle xs ys <span class="fu">=</span> go (zip xs ys)</a>
<a class="sourceLine" id="cb9-9" data-line-number="9">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-10" data-line-number="10">    go [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb9-11" data-line-number="11">    go ((x,i)<span class="fu">:</span>xs) <span class="fu">=</span> <span class="kw">case</span> partition xs i <span class="kw">of</span></a>
<a class="sourceLine" id="cb9-12" data-line-number="12">        (ls,rs) <span class="ot">-&gt;</span> go ls <span class="fu">++</span> [x] <span class="fu">++</span> go rs</a></code></pre></div>
<p>That’s all for this post! The algorithms can all be translated into Agda or Idris: I’m currently working on a way to represent permutations that isn’t <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n^2)</annotation></semantics></math> using them. If I figure out a way to properly dualise quicksort and merge sort I’ll do a small write up as well <span class="citation" data-cites="hinze_sorting_2012">(I’m currently working my way through Hinze et al. <a href="#ref-hinze_sorting_2012">2012</a> for ideas)</span>. Finally, I’d like to explore some other sorting algorithms as permutation algorithms: sorting networks seem especially related to “permutations by swapping”.</p>
<h1 id="references" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-haran_sorting_2016">
<p>Haran, Brady. 2016. “Sorting Secret.” <a href="https://www.youtube.com/watch?v=pcJHkWwjNl4" class="uri">https://www.youtube.com/watch?v=pcJHkWwjNl4</a>.</p>
</div>
<div id="ref-hinze_sorting_2012">
<p>Hinze, Ralf, Daniel W.H. James, Thomas Harper, Nicolas Wu, and José Pedro Magalhães. 2012. “Sorting with bialgebras and distributive laws.” In <em>Proceedings of the 8th ACM SIGPLAN workshop on Generic programming - WGP ’12</em>, 69. Copenhagen, Denmark: ACM Press. doi:<a href="https://doi.org/10.1145/2364394.2364405">10.1145/2364394.2364405</a>.</p>
</div>
<div id="ref-hinze_duality_2013">
<p>Hinze, Ralf, José Pedro Magalhães, and Nicolas Wu. 2013. “A Duality of Sorts.” In <em>The Beauty of Functional Code: Essays Dedicated to Rinus Plasmeijer on the Occasion of His 61st Birthday</em>, ed by. Peter Achten and Pieter Koopman, 151–167. Lecture Notes in Computer Science. Berlin, Heidelberg: Springer Berlin Heidelberg. doi:<a href="https://doi.org/10.1007/978-3-642-40355-2_11">10.1007/978-3-642-40355-2_11</a>.</p>
</div>
<div id="ref-kiselyov_provably_2002">
<p>Kiselyov, Oleg. 2002. “Provably perfect random shuffling and its pure functional implementations.” <em>http://okmij.org</em>. <a href="http://okmij.org/ftp/Haskell/AlgorithmsH.html#perfect-shuffle" class="uri">http://okmij.org/ftp/Haskell/AlgorithmsH.html#perfect-shuffle</a>.</p>
</div>
</div>
]]></description>
    <pubDate>Sun, 24 Mar 2019 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2019-03-24-permutations-by-sorting.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Lazy Binary Numbers</title>
    <link>https://doisinkidney.com/posts/2019-03-21-binary-logic-search.html</link>
    <description><![CDATA[<div class="info">
    Posted on March 21, 2019
</div>
<div class="info">
    
        Part 1 of a <a href="/series/Binary%20Numbers.html">1-part series on Binary Numbers</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Agda.html">Agda</a>, <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<h1 id="number-representations">Number Representations</h1>
<p>When working with numbers in Agda, we usually use the following definition:</p>
<style>
.column {
    float: left;
    width: 50%;
}
.row:after {
    content: "";
    display: table;
    clear: both;
}
</style>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> <span class="dt">N</span> <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">|</span> <span class="dt">S</span> <span class="dt">N</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>)</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">instance</span> <span class="dt">Num</span> <span class="dt">N</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">    <span class="dt">Z</span> <span class="fu">+</span> n <span class="fu">=</span> n</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">    <span class="dt">S</span> n <span class="fu">+</span> m <span class="fu">=</span> <span class="dt">S</span> (n <span class="fu">+</span> m)</a>
<a class="sourceLine" id="cb1-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">    <span class="dt">Z</span> <span class="fu">*</span> m <span class="fu">=</span> <span class="dt">Z</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">    <span class="dt">S</span> n <span class="fu">*</span> m <span class="fu">=</span> m <span class="fu">+</span> n <span class="fu">*</span> m</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb2"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> ℕ <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  zero <span class="ot">:</span> ℕ</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  suc <span class="ot">:</span> ℕ <span class="ot">→</span> ℕ</a>
<a class="sourceLine" id="cb2-4" data-line-number="4"></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="ot">_</span>+<span class="ot">_</span> <span class="ot">:</span> ℕ <span class="ot">→</span> ℕ <span class="ot">→</span> ℕ</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">zero  + y <span class="ot">=</span> y</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">suc x + y <span class="ot">=</span> suc <span class="ot">(</span>x + y<span class="ot">)</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8"></a>
<a class="sourceLine" id="cb2-9" data-line-number="9"><span class="ot">_</span>*<span class="ot">_</span> <span class="ot">:</span> ℕ <span class="ot">→</span> ℕ <span class="ot">→</span> ℕ</a>
<a class="sourceLine" id="cb2-10" data-line-number="10">zero  * y <span class="ot">=</span> zero</a>
<a class="sourceLine" id="cb2-11" data-line-number="11">suc x * y <span class="ot">=</span> y + <span class="ot">(</span>x * y<span class="ot">)</span></a></code></pre></div>
</div>
</div>
<div class="row">
<div class="column">
<p>Haskell</p>
</div>
<div class="column">
<p>Agda</p>
</div>
</div>
<p>In Haskell it’s less common, for obvious reasons:</p>
<table>
<thead>
<tr class="header">
<th>Operation</th>
<th>Complexity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>+</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n + m</annotation></semantics></math></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n)</annotation></semantics></math></td>
</tr>
<tr class="even">
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>×</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n \times m</annotation></semantics></math></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mi>m</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(nm)</annotation></semantics></math></td>
</tr>
</tbody>
</table>
<p>Why use them at all, then? Well, in Agda, we need them so we can <em>prove</em> things about the natural numbers. Machine-level integers are fast, but they’re opaque: their implementation isn’t written in Agda, and therefore it’s not available for the compiler to reason about.</p>
<p>In Haskell, they occasionally find uses due to their <em>laziness</em>. This can help in Agda as well. By lazy here I mean that operations on them don’t have to inspect the full structure before giving some output.</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> <span class="dt">Z</span> <span class="fu">&lt;</span> <span class="dt">S</span> undefined</a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="dt">True</span></a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb4"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb4-1" data-line-number="1">*-zeroˡ <span class="ot">:</span> <span class="ot">∀</span> x <span class="ot">→</span> zero * x ≡ zero</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">*-zeroˡ x <span class="ot">=</span> refl</a></code></pre></div>
</div>
</div>
<p>In Haskell, as we can see, this lets us run computations without scrutinising some arguments. Agda benefits similarly: here it lets the compiler see more “obvious” facts that it may have missed otherwise.</p>
<p>It’s not <em>completely</em> lazy, though. In particular, it tends to be left-biased:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> undefined <span class="fu">*</span> <span class="dt">Z</span> <span class="fu">==</span> <span class="dt">Z</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="fu">**</span> <span class="dt">Exception</span><span class="fu">:</span> Prelude.undefined</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb6"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb6-1" data-line-number="1">*-zeroʳ <span class="ot">:</span> <span class="ot">∀</span> x <span class="ot">→</span> x * zero ≡ zero</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">*-zeroʳ x <span class="ot">=</span> refl</a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="co">-- x * zero != zero of type ℕ</span></a></code></pre></div>
</div>
</div>
<p>Like Boolean short-circuiting operators, operations on Peano numbers will usually have to scrutinise the left-hand-side argument quite a bit before giving an output.</p>
<p>So, Peano numbers are good because:</p>
<ol>
<li>We can prove things about them.</li>
<li>They’re lazy.</li>
</ol>
<p>In this post, I’m going to look at some other number representations that maintain these two desirable properties, while improving on the efficiency somewhat.</p>
<h2 id="list-of-bits-binary">List-of-Bits-Binary</h2>
<p>The first option for an improved representation is binary numbers. We can represent binary numbers as a list of bits:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Bit</span> <span class="fu">=</span> <span class="dt">O</span> <span class="fu">|</span> <span class="dt">I</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>, <span class="dt">Ord</span>)</a>
<a class="sourceLine" id="cb7-2" data-line-number="2"></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="kw">type</span> <span class="dt">B</span> <span class="fu">=</span> [<span class="dt">Bit</span>]</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb8"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">data</span> Bit <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span> O I <span class="ot">:</span> Bit</a>
<a class="sourceLine" id="cb8-2" data-line-number="2"></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">𝔹 <span class="ot">:</span> <span class="dt">Set</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">𝔹 <span class="ot">=</span> List Bit</a></code></pre></div>
</div>
</div>
<p>As we’re using these to represent natural numbers, we’ll need to define a way to convert between them:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">eval ::</span> <span class="dt">B</span> <span class="ot">-&gt;</span> <span class="dt">N</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">eval <span class="fu">=</span> foldr f <span class="dt">Z</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4">    f <span class="dt">O</span> xs <span class="fu">=</span> xs <span class="fu">+</span> xs</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">    f <span class="dt">I</span> xs <span class="fu">=</span> <span class="dt">S</span> (xs <span class="fu">+</span> xs)</a>
<a class="sourceLine" id="cb9-6" data-line-number="6"></a>
<a class="sourceLine" id="cb9-7" data-line-number="7"><span class="ot">inc ::</span> <span class="dt">B</span> <span class="ot">-&gt;</span> <span class="dt">B</span></a>
<a class="sourceLine" id="cb9-8" data-line-number="8">inc [] <span class="fu">=</span> [<span class="dt">I</span>]</a>
<a class="sourceLine" id="cb9-9" data-line-number="9">inc (<span class="dt">O</span><span class="fu">:</span>xs) <span class="fu">=</span> <span class="dt">I</span> <span class="fu">:</span> xs</a>
<a class="sourceLine" id="cb9-10" data-line-number="10">inc (<span class="dt">I</span><span class="fu">:</span>xs) <span class="fu">=</span> <span class="dt">O</span> <span class="fu">:</span> inc xs</a>
<a class="sourceLine" id="cb9-11" data-line-number="11"></a>
<a class="sourceLine" id="cb9-12" data-line-number="12"><span class="ot">fromN ::</span> <span class="dt">N</span> <span class="ot">-&gt;</span> <span class="dt">B</span></a>
<a class="sourceLine" id="cb9-13" data-line-number="13">fromN <span class="dt">Z</span> <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb9-14" data-line-number="14">fromN (<span class="dt">S</span> n) <span class="fu">=</span> inc (fromN n)</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb10"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb10-1" data-line-number="1">⟦<span class="ot">_</span>⇓⟧ <span class="ot">:</span> 𝔹 <span class="ot">→</span> ℕ</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">⟦<span class="ot">_</span>⇓⟧ <span class="ot">=</span> foldr <span class="ot">(λ</span> <span class="ot">{</span> O xs <span class="ot">→</span> xs + xs</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">                <span class="ot">;</span> I xs <span class="ot">→</span> suc <span class="ot">(</span>xs + xs<span class="ot">)</span> <span class="ot">})</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4">             zero</a>
<a class="sourceLine" id="cb10-5" data-line-number="5"></a>
<a class="sourceLine" id="cb10-6" data-line-number="6">inc <span class="ot">:</span> 𝔹 <span class="ot">→</span> 𝔹</a>
<a class="sourceLine" id="cb10-7" data-line-number="7">inc [] <span class="ot">=</span> I ∷ []</a>
<a class="sourceLine" id="cb10-8" data-line-number="8">inc <span class="ot">(</span>O ∷ xs<span class="ot">)</span> <span class="ot">=</span> I ∷ xs</a>
<a class="sourceLine" id="cb10-9" data-line-number="9">inc <span class="ot">(</span>I ∷ xs<span class="ot">)</span> <span class="ot">=</span> O ∷ inc xs</a>
<a class="sourceLine" id="cb10-10" data-line-number="10"></a>
<a class="sourceLine" id="cb10-11" data-line-number="11">⟦<span class="ot">_</span>⇑⟧ <span class="ot">:</span> ℕ <span class="ot">→</span> 𝔹</a>
<a class="sourceLine" id="cb10-12" data-line-number="12">⟦ zero  ⇑⟧ <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb10-13" data-line-number="13">⟦ suc n ⇑⟧ <span class="ot">=</span> inc ⟦ n ⇑⟧</a></code></pre></div>
</div>
</div>
<p>And here we run into our first problem: redundancy. There are multiple ways to represent the same number according to the semantics defined above. We can actually prove this in Agda:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb11-1" data-line-number="1">redundant <span class="ot">:</span> ∃₂ <span class="ot">λ</span> x y <span class="ot">→</span> x ≢ y × ⟦ x ⇓⟧ ≡ ⟦ y ⇓⟧</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">redundant <span class="ot">=</span> [] , O ∷ [] , <span class="ot">(λ</span> <span class="ot">())</span> , refl</a></code></pre></div>
<p>In English: “There are two binary numbers which are not the same, but which do evaluate to the same natural number”. (This proof was actually automatically filled in for me after writing the signature)</p>
<p>This represents a huge problem for proofs. It means that even simple things like <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>×</mo><mn>0</mn><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x \times 0 = 0</annotation></semantics></math> aren’t true, depending on how multiplication is implemented. On to our next option:</p>
<h2 id="list-of-gaps-binary">List-of-Gaps-Binary</h2>
<p>Instead of looking at the bits directly, let’s think about a binary number as a list of chunks of 0s, each followed by a 1. In this way, we simply <em>can’t</em> have trailing zeroes, because the definition implies that every number other than 0 ends in 1.</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Gap</span> <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">|</span> <span class="dt">S</span> <span class="dt">Gap</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="kw">type</span> <span class="dt">B</span> <span class="fu">=</span> [<span class="dt">Gap</span>]</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb13"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb13-1" data-line-number="1">𝔹 <span class="ot">:</span> <span class="dt">Set</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">𝔹 <span class="ot">=</span> List ℕ</a></code></pre></div>
</div>
</div>
<p>This guarantees a unique representation. As in the representation above, it has much improved time complexities for the familiar operations:</p>
<table>
<thead>
<tr class="header">
<th>Operation</th>
<th>Complexity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>+</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n + m</annotation></semantics></math></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><msub><mo>log</mo><mn>2</mn></msub><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log_2 n)</annotation></semantics></math></td>
</tr>
<tr class="even">
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>×</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n \times m</annotation></semantics></math></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><msub><mo>log</mo><mn>2</mn></msub><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log_2 (n + m))</annotation></semantics></math></td>
</tr>
</tbody>
</table>
<p>Encoding the zeroes as gaps also makes multiplication much faster in certain cases: multiplying by a high power of 2 is a constant-time operation, for instance.</p>
<p>It does have one disadvantage, and it’s to do with the increment function:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="ot">inc ::</span> <span class="dt">B</span> <span class="ot">-&gt;</span> <span class="dt">B</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2">inc <span class="fu">=</span> uncurry (flip (<span class="fu">:</span>)) <span class="fu">.</span> inc&#39;</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-4" data-line-number="4">    inc&#39; [] <span class="fu">=</span> ([], <span class="dt">Z</span>)</a>
<a class="sourceLine" id="cb14-5" data-line-number="5">    inc&#39; (x<span class="fu">:</span>xs) <span class="fu">=</span> inc&#39;&#39; x xs</a>
<a class="sourceLine" id="cb14-6" data-line-number="6">    </a>
<a class="sourceLine" id="cb14-7" data-line-number="7">    inc&#39;&#39; <span class="dt">Z</span> ns <span class="fu">=</span> fmap <span class="dt">S</span> (inc&#39; ns)</a>
<a class="sourceLine" id="cb14-8" data-line-number="8">    inc&#39;&#39; (<span class="dt">S</span> n) ns <span class="fu">=</span> (n<span class="fu">:</span>ns,<span class="dt">Z</span>)</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb15"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb15-1" data-line-number="1">𝔹⁺ <span class="ot">:</span> <span class="dt">Set</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2">𝔹⁺ <span class="ot">=</span> ℕ × 𝔹</a>
<a class="sourceLine" id="cb15-3" data-line-number="3"></a>
<a class="sourceLine" id="cb15-4" data-line-number="4">inc <span class="ot">:</span> 𝔹 <span class="ot">→</span> 𝔹</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">inc <span class="ot">=</span> uncurry <span class="ot">_</span>∷<span class="ot">_</span> ∘ inc′</a>
<a class="sourceLine" id="cb15-6" data-line-number="6">  <span class="kw">module</span> Inc <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-7" data-line-number="7">  <span class="kw">mutual</span></a>
<a class="sourceLine" id="cb15-8" data-line-number="8">    inc′ <span class="ot">:</span> 𝔹 <span class="ot">→</span> 𝔹⁺</a>
<a class="sourceLine" id="cb15-9" data-line-number="9">    inc′ [] <span class="ot">=</span> <span class="dv">0</span> , []</a>
<a class="sourceLine" id="cb15-10" data-line-number="10">    inc′ <span class="ot">(</span>x ∷ xs<span class="ot">)</span> <span class="ot">=</span> inc″ x xs</a>
<a class="sourceLine" id="cb15-11" data-line-number="11"></a>
<a class="sourceLine" id="cb15-12" data-line-number="12">    inc″ <span class="ot">:</span> ℕ <span class="ot">→</span> 𝔹 <span class="ot">→</span> 𝔹⁺</a>
<a class="sourceLine" id="cb15-13" data-line-number="13">    inc″ zero ns <span class="ot">=</span> map₁ suc <span class="ot">(</span>inc′ ns<span class="ot">)</span></a>
<a class="sourceLine" id="cb15-14" data-line-number="14">    inc″ <span class="ot">(</span>suc n<span class="ot">)</span> ns <span class="ot">=</span> <span class="dv">0</span> , n ∷ ns</a></code></pre></div>
</div>
</div>
<p>With all of their problems, Peano numbers performed this operation in constant time. The above implementation is only <em>amortised</em> constant-time, though, with a worst case of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><msub><mo>log</mo><mn>2</mn></msub><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log_2 n)</annotation></semantics></math> (same as the list-of-bits version). There are a number of ways to remedy this, the most famous being:</p>
<h2 id="skew-binary">Skew Binary</h2>
<p>This encoding has three digits: 0, 1, and 2. To guarantee a unique representation, we add the condition that there can be at most one 2 in the number, which must be the first non-zero digit if it’s present.</p>
<p>To represent this we’ll encode “gaps”, as before, with the condition that if the second gap is 0 it <em>actually</em> represents a 2 digit in the preceding position. That weirdness out of the way, we are rewarded with an <code>inc</code> implementation which is clearly <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math>.</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="ot">inc ::</span> <span class="dt">B</span> <span class="ot">-&gt;</span> <span class="dt">B</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2">inc [] <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">:</span> []</a>
<a class="sourceLine" id="cb16-3" data-line-number="3">inc (x<span class="fu">:</span>[]) <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">:</span> x <span class="fu">:</span> []</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">inc (x  <span class="fu">:</span> <span class="dt">Z</span> <span class="fu">:</span> xs) <span class="fu">=</span> <span class="dt">S</span> x <span class="fu">:</span> xs</a>
<a class="sourceLine" id="cb16-5" data-line-number="5">inc (x1 <span class="fu">:</span> <span class="dt">S</span> x2 <span class="fu">:</span> xs) <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">:</span> x1 <span class="fu">:</span> x2 <span class="fu">:</span> xs</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb17"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb17-1" data-line-number="1">inc <span class="ot">:</span> 𝔹 <span class="ot">→</span> 𝔹</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">inc [] <span class="ot">=</span> <span class="dv">0</span> ∷ []</a>
<a class="sourceLine" id="cb17-3" data-line-number="3">inc <span class="ot">(</span>x ∷ []<span class="ot">)</span> <span class="ot">=</span> <span class="dv">0</span> ∷ x ∷ []</a>
<a class="sourceLine" id="cb17-4" data-line-number="4">inc <span class="ot">(</span>x₁ ∷ zero ∷ xs<span class="ot">)</span> <span class="ot">=</span> suc x₁ ∷ xs</a>
<a class="sourceLine" id="cb17-5" data-line-number="5">inc <span class="ot">(</span>x₁ ∷ suc x₂ ∷ xs<span class="ot">)</span> <span class="ot">=</span> <span class="dv">0</span> ∷ x₁ ∷ x₂ ∷ xs</a></code></pre></div>
</div>
</div>
<p>Unfortunately, though, we’ve lost the other efficiencies! Addition and multiplication have no easy or direct encoding in this system, so we have to convert back and forth between this and regular binary to perform them.</p>
<h2 id="list-of-segments-binary">List-of-Segments-Binary</h2>
<p>The key problem with incrementing in the normal binary system is that it can cascade: when we hit a long string of 1s, all the 1s become 0 followed by a single 1. We can turn this problem to our advantage if we use a representation which encodes both 1s and 0s as strings of gaps. We’ll have to use a couple more tricks to ensure a unique representation, but all in all this is what we have (switching to just Agda now):</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="kw">data</span> 0≤<span class="ot">_</span> <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2">  0₂  <span class="ot">:</span> 0≤ A</a>
<a class="sourceLine" id="cb18-3" data-line-number="3">  0&lt;<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">→</span> 0≤ A</a>
<a class="sourceLine" id="cb18-4" data-line-number="4"></a>
<a class="sourceLine" id="cb18-5" data-line-number="5"><span class="kw">mutual</span></a>
<a class="sourceLine" id="cb18-6" data-line-number="6">  <span class="kw">record</span> 𝔹₀ <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-7" data-line-number="7">    <span class="kw">constructor</span> <span class="ot">_</span>0&amp;<span class="ot">_</span></a>
<a class="sourceLine" id="cb18-8" data-line-number="8">    <span class="kw">inductive</span></a>
<a class="sourceLine" id="cb18-9" data-line-number="9">    <span class="kw">field</span></a>
<a class="sourceLine" id="cb18-10" data-line-number="10">      H₀ <span class="ot">:</span> ℕ</a>
<a class="sourceLine" id="cb18-11" data-line-number="11">      T₀ <span class="ot">:</span> 𝔹₁</a>
<a class="sourceLine" id="cb18-12" data-line-number="12"></a>
<a class="sourceLine" id="cb18-13" data-line-number="13">  <span class="kw">record</span> 𝔹₁ <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-14" data-line-number="14">    <span class="kw">constructor</span> <span class="ot">_</span>1&amp;<span class="ot">_</span></a>
<a class="sourceLine" id="cb18-15" data-line-number="15">    <span class="kw">inductive</span></a>
<a class="sourceLine" id="cb18-16" data-line-number="16">    <span class="kw">field</span></a>
<a class="sourceLine" id="cb18-17" data-line-number="17">      H₁ <span class="ot">:</span> ℕ</a>
<a class="sourceLine" id="cb18-18" data-line-number="18">      T₁ <span class="ot">:</span> 0≤  𝔹₀</a>
<a class="sourceLine" id="cb18-19" data-line-number="19"><span class="kw">open</span> 𝔹₀ <span class="kw">public</span></a>
<a class="sourceLine" id="cb18-20" data-line-number="20"><span class="kw">open</span> 𝔹₁ <span class="kw">public</span></a>
<a class="sourceLine" id="cb18-21" data-line-number="21"></a>
<a class="sourceLine" id="cb18-22" data-line-number="22"><span class="kw">data</span> 𝔹⁺ <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-23" data-line-number="23">  B₀<span class="ot">_</span> <span class="ot">:</span> 𝔹₀ <span class="ot">→</span> 𝔹⁺</a>
<a class="sourceLine" id="cb18-24" data-line-number="24">  B₁<span class="ot">_</span> <span class="ot">:</span> 𝔹₁ <span class="ot">→</span> 𝔹⁺</a>
<a class="sourceLine" id="cb18-25" data-line-number="25"></a>
<a class="sourceLine" id="cb18-26" data-line-number="26">𝔹 <span class="ot">:</span> <span class="dt">Set</span></a>
<a class="sourceLine" id="cb18-27" data-line-number="27">𝔹 <span class="ot">=</span> 0≤ 𝔹⁺</a>
<a class="sourceLine" id="cb18-28" data-line-number="28"></a>
<a class="sourceLine" id="cb18-29" data-line-number="29">inc⁺ <span class="ot">:</span> 𝔹 <span class="ot">→</span> 𝔹⁺</a>
<a class="sourceLine" id="cb18-30" data-line-number="30">inc⁺ 0₂                               <span class="ot">=</span>      B₁ <span class="dv">0</span>     1&amp; 0₂</a>
<a class="sourceLine" id="cb18-31" data-line-number="31">inc⁺ <span class="ot">(</span>0&lt; B₀ zero  0&amp; y 1&amp; xs        <span class="ot">)</span> <span class="ot">=</span>      B₁ suc y 1&amp; xs</a>
<a class="sourceLine" id="cb18-32" data-line-number="32">inc⁺ <span class="ot">(</span>0&lt; B₀ suc x 0&amp; y 1&amp; xs        <span class="ot">)</span> <span class="ot">=</span>      B₁ <span class="dv">0</span>     1&amp; 0&lt; x 0&amp; y 1&amp; xs</a>
<a class="sourceLine" id="cb18-33" data-line-number="33">inc⁺ <span class="ot">(</span>0&lt; B₁ x 1&amp; 0₂                 <span class="ot">)</span> <span class="ot">=</span> B₀ x 0&amp; <span class="dv">0</span>     1&amp; 0₂</a>
<a class="sourceLine" id="cb18-34" data-line-number="34">inc⁺ <span class="ot">(</span>0&lt; B₁ x 1&amp; 0&lt; zero  0&amp; z 1&amp; xs<span class="ot">)</span> <span class="ot">=</span> B₀ x 0&amp; suc z 1&amp; xs</a>
<a class="sourceLine" id="cb18-35" data-line-number="35">inc⁺ <span class="ot">(</span>0&lt; B₁ x 1&amp; 0&lt; suc y 0&amp; z 1&amp; xs<span class="ot">)</span> <span class="ot">=</span> B₀ x 0&amp; <span class="dv">0</span>     1&amp; 0&lt; y 0&amp; z 1&amp; xs</a>
<a class="sourceLine" id="cb18-36" data-line-number="36"></a>
<a class="sourceLine" id="cb18-37" data-line-number="37">inc <span class="ot">:</span> 𝔹 <span class="ot">→</span> 𝔹</a>
<a class="sourceLine" id="cb18-38" data-line-number="38">inc x <span class="ot">=</span> 0&lt; inc⁺ x</a></code></pre></div>
<p>Perfect! Increments are obviously <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math>, and we’ve guaranteed a unique representation.</p>
<p>I’ve been working on this type for a couple of days, and you can see my code <a href="https://github.com/oisdk/agda-binary/">here</a>. So far, I’ve done the following:</p>
<dl>
<dt>Defined <code>inc</code>, addition, and multiplication</dt>
<dd><p>These were a little tricky to get right (<a href="https://github.com/oisdk/agda-binary/blob/master/Data/Binary/Operations/Addition.agda#L9">addition is particularly hairy</a>), but they’re all there, and maximally lazy.</p>
</dd>
<dt>Proved Homomorphism</dt>
<dd><p>For each one of the functions, you want them to correspond precisely to the equivalent functions on Peano numbers. Proving that fact amounts to filling in definitions for the following:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb19-1" data-line-number="1">inc-homo <span class="ot">:</span> <span class="ot">∀</span> x <span class="ot">→</span> ⟦ inc x ⇓⟧ ≡ suc ⟦ x ⇓⟧</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">+-homo <span class="ot">:</span> <span class="ot">∀</span> x y <span class="ot">→</span> ⟦ x + y ⇓⟧ ≡ ⟦ x ⇓⟧ + ⟦ y ⇓⟧</a>
<a class="sourceLine" id="cb19-3" data-line-number="3">*-homo <span class="ot">:</span> <span class="ot">∀</span> x y <span class="ot">→</span> ⟦ x * y ⇓⟧ ≡ ⟦ x ⇓⟧ * ⟦ y ⇓⟧</a></code></pre></div>
</dd>
<dt>Proved Bijection</dt>
<dd><p>As we went to so much trouble, it’s important to prove that these numbers form a one-to-one correspondence with the Peano numbers. As well as that, once done, we can use it to prove facts about the homomorphic functions above, by reusing any proofs about the same functions on Peano numbers. For instance, here is a proof of commutativity of addition:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb20-1" data-line-number="1">+-comm <span class="ot">:</span> <span class="ot">∀</span> x y <span class="ot">→</span> x + y ≡ y + x</a>
<a class="sourceLine" id="cb20-2" data-line-number="2">+-comm x y <span class="ot">=</span> injective <span class="ot">(</span>+-homo x y ⟨ trans ⟩</a>
<a class="sourceLine" id="cb20-3" data-line-number="3">                        ℕ<span class="ot">.</span>+-comm ⟦ x ⇓⟧ ⟦ y ⇓⟧ ⟨ trans ⟩</a>
<a class="sourceLine" id="cb20-4" data-line-number="4">                        sym <span class="ot">(</span>+-homo y x<span class="ot">))</span></a></code></pre></div>
</dd>
</dl>
<h1 id="applications">Applications</h1>
<p>So now that we have our nice number representation, what can we do with it? One use is as a general-purpose number type in Agda: it represents a good balance between speed and “proofiness”, and Coq uses a similar type in its standard library.</p>
<p>There are other, more unusual uses of such a type, though.</p>
<h2 id="data-structures">Data Structures</h2>
<p>It’s a well-known technique to build a data structure out of some number representation <span class="citation" data-cites="hinze_numerical_1998">(Hinze <a href="#ref-hinze_numerical_1998">1998</a>)</span>: in fact, all of the representations above are explored in Okasaki <span class="citation" data-cites="okasaki_purely_1999">(<a href="#ref-okasaki_purely_1999">1999</a>, chap. 9.2)</span>.</p>
<h2 id="logic-programming">Logic Programming</h2>
<p>Logic programming languages like Prolog let us write programs in a backwards kind of way. We say what the output looks like, and the unifier will figure out the set of inputs that generates it.</p>
<p>In Haskell, we have a very rough approximation of a similar system: the list monad.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="ot">pyth ::</span> [(<span class="dt">Int</span>,<span class="dt">Int</span>,<span class="dt">Int</span>)]</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">pyth <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb21-3" data-line-number="3">  x <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>]</a>
<a class="sourceLine" id="cb21-4" data-line-number="4">  y <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>]</a>
<a class="sourceLine" id="cb21-5" data-line-number="5">  z <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>]</a>
<a class="sourceLine" id="cb21-6" data-line-number="6">  guard (x<span class="fu">*</span>x <span class="fu">+</span> y<span class="fu">*</span>y <span class="fu">==</span> z<span class="fu">*</span>z)</a>
<a class="sourceLine" id="cb21-7" data-line-number="7">  return (x,y,z)</a></code></pre></div>
<p>There are tons of inefficiencies in the above code: for us, though, we can look at one: the number representation. In the equation:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup><mo>=</mo><msup><mi>z</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">x^2 + y^2 = z^2</annotation></semantics></math></p>
<p>If we know that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math> are both odd, then <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math> must be even. If the calculation of the equation is expensive, this is precisely the kind of shortcut we’d want to take advantage of. Luckily, our binary numbers do just that: it is enough to scrutinise just the first bits of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math> in order to determine the first bit of the output.</p>
<p>After seeing that example, you may be thinking that lazy evaluation is a perfect fit for logic programming. You’re not alone! Curry <span class="citation" data-cites="Hanus16Curry">(Hanus (ed.) <a href="#ref-Hanus16Curry">2016</a>)</span> is a lazy, functional logic programming language, with a similar syntax to Haskell. It also uses lazy binary numbers to optimise testing.</p>
<h2 id="lazy-predicates">Lazy Predicates</h2>
<p>In order for queries to be performed efficiently on binary numbers, we will also need a way to describe lazy <em>predicates</em> on them. A lot of these predicates are more easily expressible on the list-of-bits representation above, so we’ll be working with that representation for this bit. Not to worry, though: we can convert from the segmented representation into the list-of-bits, and <a href="https://github.com/oisdk/agda-binary/blob/fb89ba5ae3b2aa0cb95301da42c8dbf27048181b/Data/Binary/Bits.agda#L52">we can prove that the conversion is injective</a>:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb22-1" data-line-number="1">toBits-injective <span class="ot">:</span> <span class="ot">∀</span> xs ys <span class="ot">→</span> toBits xs ≡ toBits ys <span class="ot">→</span> xs ≡ ys</a></code></pre></div>
<p>Here’s the curious problem: since our binary numbers are expressed least-significant-bit-first, we have to go to the end before knowing which is bigger. Luckily, we can use one of my favourite Haskell tricks, involving the ordering monoid:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="kw">data</span> Ordering <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-2" data-line-number="2">  lt eq gt <span class="ot">:</span> Ordering</a>
<a class="sourceLine" id="cb23-3" data-line-number="3"></a>
<a class="sourceLine" id="cb23-4" data-line-number="4"><span class="ot">_</span>∙<span class="ot">_</span> <span class="ot">:</span> Ordering <span class="ot">→</span> Ordering <span class="ot">→</span> Ordering</a>
<a class="sourceLine" id="cb23-5" data-line-number="5">lt ∙ y <span class="ot">=</span> lt</a>
<a class="sourceLine" id="cb23-6" data-line-number="6">eq ∙ y <span class="ot">=</span> y</a>
<a class="sourceLine" id="cb23-7" data-line-number="7">gt ∙ y <span class="ot">=</span> gt</a>
<a class="sourceLine" id="cb23-8" data-line-number="8"></a>
<a class="sourceLine" id="cb23-9" data-line-number="9">cmpBit <span class="ot">:</span> Bit <span class="ot">→</span> Bit <span class="ot">→</span> Ordering</a>
<a class="sourceLine" id="cb23-10" data-line-number="10">cmpBit O O <span class="ot">=</span> eq</a>
<a class="sourceLine" id="cb23-11" data-line-number="11">cmpBit O I <span class="ot">=</span> lt</a>
<a class="sourceLine" id="cb23-12" data-line-number="12">cmpBit I O <span class="ot">=</span> gt</a>
<a class="sourceLine" id="cb23-13" data-line-number="13">cmpBit I I <span class="ot">=</span> eq</a>
<a class="sourceLine" id="cb23-14" data-line-number="14"></a>
<a class="sourceLine" id="cb23-15" data-line-number="15">compare <span class="ot">:</span> Bits <span class="ot">→</span> Bits <span class="ot">→</span> Ordering</a>
<a class="sourceLine" id="cb23-16" data-line-number="16">compare [] [] <span class="ot">=</span> eq</a>
<a class="sourceLine" id="cb23-17" data-line-number="17">compare [] <span class="ot">(_</span> ∷ <span class="ot">_)</span> <span class="ot">=</span> lt</a>
<a class="sourceLine" id="cb23-18" data-line-number="18">compare <span class="ot">(_</span> ∷ <span class="ot">_)</span> [] <span class="ot">=</span> gt</a>
<a class="sourceLine" id="cb23-19" data-line-number="19">compare <span class="ot">(</span>x ∷ xs<span class="ot">)</span> <span class="ot">(</span>y ∷ ys<span class="ot">)</span> <span class="ot">=</span> compare xs ys ∙ cmpBit x y</a></code></pre></div>
<p>Thanks to laziness, this function first compares the length of the lists, and then does a lexicographical comparison in reverse only if the lengths are the same. This is exactly what we want for our numbers.</p>
<h1 id="future-posts">Future Posts</h1>
<p>That’s all I have for now, but I’m interested to formalise the laziness of these numbers in Agda. Usually that’s done with coinduction: I would also like to see the relationship with exact real arithmetic.</p>
<p>I wonder if it can be combined with <span class="citation" data-cites="oconnor_applications_2016">O’Connor (<a href="#ref-oconnor_applications_2016">2016</a>)</span> to get some efficient proof search algorithms, or with <span class="citation" data-cites="escardo_seemingly_2014">Escardo (<a href="#ref-escardo_seemingly_2014">2014</a>)</span> to get more efficient exhaustive search.</p>
<h1 id="references" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-escardo_seemingly_2014">
<p>Escardo, Martin. 2014. “Seemingly impossible constructive proofs | Mathematics and Computation.” <em>Mathematics and Computation</em>. <a href="http://math.andrej.com/2014/05/08/seemingly-impossible-proofs/" class="uri">http://math.andrej.com/2014/05/08/seemingly-impossible-proofs/</a>.</p>
</div>
<div id="ref-Hanus16Curry">
<p>Hanus (ed.), M. 2016. <em>Curry: An Integrated Functional Logic Language (Vers. 0.9.0)</em>. Available at http://www.curry-language.org. <a href="https://www-ps.informatik.uni-kiel.de/currywiki/" class="uri">https://www-ps.informatik.uni-kiel.de/currywiki/</a>.</p>
</div>
<div id="ref-hinze_numerical_1998">
<p>Hinze, Ralf. 1998. <em>Numerical Representations as Higher-Order Nested Datatypes</em>. Institut für Informatik III, Universität Bonn. <a href="http://www.cs.ox.ac.uk/ralf.hinze/publications/\#R5" class="uri">http://www.cs.ox.ac.uk/ralf.hinze/publications/\#R5</a>.</p>
</div>
<div id="ref-oconnor_applications_2016">
<p>O’Connor, Liam. 2016. “Applications of Applicative Proof Search.” In <em>Proceedings of the 1st International Workshop on Type-Driven Development</em>, 43–55. TyDe 2016. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/2976022.2976030">10.1145/2976022.2976030</a>. <a href="http://doi.acm.org/10.1145/2976022.2976030" class="uri">http://doi.acm.org/10.1145/2976022.2976030</a>.</p>
</div>
<div id="ref-okasaki_purely_1999">
<p>Okasaki, Chris. 1999. <em>Purely Functional Data Structures</em>. Cambridge University Press.</p>
</div>
</div>
]]></description>
    <pubDate>Thu, 21 Mar 2019 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2019-03-21-binary-logic-search.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>More Agda Tips</title>
    <link>https://doisinkidney.com/posts/2019-03-14-more-agda-tips.html</link>
    <description><![CDATA[<div class="info">
    Posted on March 14, 2019
</div>
<div class="info">
    
        Part 2 of a <a href="/series/Agda%20Tips.html">2-part series on Agda Tips</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Agda.html">Agda</a>
    
</div>

<h1 id="literate-agda">Literate Agda</h1>
<p>For including Agda code in LaTeX files, Agda’s built-in literate programming support is a great tool. It typesets code well, and ensures that it typechecks which can help avoid typos.</p>
<h3 id="embedding-agda-code-in-latex">Embedding Agda Code in LaTeX</h3>
<p>I write the LaTeX document in one file, and the Agda code in another <code>.lagda</code> file. Using the <a href="https://ctan.org/pkg/catchfilebetweentags?lang=en">catchfilebetweentags</a> LaTeX package, I can then embed snippets of the Agda code into the LaTeX document. For instance, in a file named <code>Lists.lagda</code> I can have the following:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb1-1" data-line-number="1">%&lt;*head-type&gt;</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="ot">\</span>begin<span class="ot">{</span>code<span class="ot">}</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">head <span class="ot">:</span> List A <span class="ot">→</span> Maybe A</a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="ot">\</span>end<span class="ot">{</span>code<span class="ot">}</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5">%&lt;/head-type&gt;</a>
<a class="sourceLine" id="cb1-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="ot">\</span>begin<span class="ot">{</span>code<span class="ot">}</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">head [] <span class="ot">=</span> nothing</a>
<a class="sourceLine" id="cb1-9" data-line-number="9">head <span class="ot">(</span>x ∷ xs<span class="ot">)</span> <span class="ot">=</span> just x</a>
<a class="sourceLine" id="cb1-10" data-line-number="10"><span class="ot">\</span>end<span class="ot">{</span>code<span class="ot">}</span></a></code></pre></div>
<p>Then, after compiling the Agda file with <code>agda --latex --output-dir=. Lists.lagda</code>, I can embed the snippet <code>head : List A → Maybe A</code> into the TeX file like so:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode latex"><code class="sourceCode latex"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="fu">\ExecuteMetaData</span>[Lists.tex]{head-type}</a></code></pre></div>
<h3 id="dealing-with-unicode">Dealing with Unicode</h3>
<p>Most Agda source code will be Unicode-heavy, which doesn’t work well in LaTeX. There are a few different ways to deal with this: you could use XeTeX, which handles Unicode better, for instance. I found it easier to use the <a href="https://ctan.org/pkg/ucs?lang=en">ucs</a> package, and write a declaration for each Unicode character as I came across it. For the <code>∷</code> character above, for instance, you can write:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode latex"><code class="sourceCode latex"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="bu">\usepackage</span>{<span class="ex">ucs</span>}</a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="fu">\DeclareUnicodeCharacter</span>{8759}{<span class="ss">\ensuremath{</span><span class="sc">\squaredots</span><span class="ss">}</span>}</a></code></pre></div>
<h3 id="live-reloading">Live Reloading</h3>
<p>For plain LaTeX code, I use <a href="http://spacemacs.org/">Spacemacs</a> and <a href="https://skim-app.sourceforge.io/">Skim</a> to get live reloading. When I save the LaTeX source code, the Skim window refreshes and jumps to the point my editing cursor is at. I use elisp code from <a href="https://mssun.me/blog/spacemacs-and-latex.html">this</a> blog post.</p>
<p>For Agda code, live reloading gets a little trickier. If I edit an Agda source file, the LaTeX won’t automatically recompile it. However, based on <a href="https://tex.stackexchange.com/questions/142540/configuring-latexmk-to-use-a-preprocessor-lhs2tex">this</a> stack exchange answer, you can put the following <code>.latexmkrc</code> file in the same directory as your <code>.lagda</code> files and your <code>.tex</code> file:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode perl"><code class="sourceCode perl"><a class="sourceLine" id="cb4-1" data-line-number="1">add_cus_dep(<span class="kw">&#39;</span><span class="st">lagda</span><span class="kw">&#39;</span>,<span class="kw">&#39;</span><span class="st">tex</span><span class="kw">&#39;</span>,<span class="dv">0</span>,<span class="kw">&#39;</span><span class="st">lagda2tex</span><span class="kw">&#39;</span>);</a>
<a class="sourceLine" id="cb4-2" data-line-number="2"></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="kw">sub </span><span class="fu">lagda2tex</span> {</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">    <span class="kw">my</span> <span class="dt">$base</span> = <span class="fu">shift</span> <span class="dt">@_</span>;</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">    <span class="kw">return</span> <span class="fu">system</span>(<span class="kw">&#39;</span><span class="st">agda</span><span class="kw">&#39;</span>, <span class="kw">&#39;</span><span class="st">--latex</span><span class="kw">&#39;</span>, <span class="kw">&#39;</span><span class="st">--latex-dir=.</span><span class="kw">&#39;</span>, <span class="kw">&quot;</span><span class="dt">$base</span><span class="st">.lagda</span><span class="kw">&quot;</span>);</a>
<a class="sourceLine" id="cb4-6" data-line-number="6">}</a></code></pre></div>
<p>This will recompile the literate Agda files whenever they’re changed. Unfortunately, it doesn’t automate it the <em>first</em> time you do it: it needs to see the <code>.tex</code> files to see the dependency. You can fix this yourself, by running <code>agda --latex --output-dir=.</code> when you add a new <code>.lagda</code> file (just once, after that the automation will take over), or you can use a script like the following:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="co">#!/bin/bash</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="fu">find</span> . -type f -name <span class="st">&#39;*.lagda&#39;</span> <span class="kw">|</span> <span class="kw">while</span> <span class="bu">read</span> -r <span class="va">code</span> ; <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">    <span class="va">dir=$(</span><span class="fu">dirname</span> <span class="st">&quot;</span><span class="va">$code</span><span class="st">&quot;</span><span class="va">)</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">    <span class="va">file=$(</span><span class="fu">basename</span> <span class="st">&quot;</span><span class="va">$code</span><span class="st">&quot;</span> .lagda<span class="va">)</span>.tex</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">    <span class="kw">if</span><span class="bu"> [</span> <span class="ot">!</span> <span class="ot">-e</span> <span class="st">&quot;</span><span class="va">$dir</span><span class="st">/</span><span class="va">$file</span><span class="st">&quot;</span><span class="bu"> ]</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6">    <span class="kw">then</span></a>
<a class="sourceLine" id="cb5-7" data-line-number="7">        <span class="ex">agda</span> --latex --latex-dir=. <span class="st">&quot;</span><span class="va">$code</span><span class="st">&quot;</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8">    <span class="kw">fi</span></a>
<a class="sourceLine" id="cb5-9" data-line-number="9"><span class="kw">done</span></a></code></pre></div>
<p>This will compile any <code>.lagda</code> file it finds that <em>doesn’t</em> have a corresponding <code>.tex</code> file (so it won’t slow things down). Then call that script on the first line of your <code>.latexmkrc</code>, like so:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode perl"><code class="sourceCode perl"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="fu">system</span>(<span class="kw">&quot;</span><span class="st">bash ./init-missing-lagda.sh</span><span class="kw">&quot;</span>);</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">add_cus_dep(<span class="kw">&#39;</span><span class="st">lagda</span><span class="kw">&#39;</span>,<span class="kw">&#39;</span><span class="st">tex</span><span class="kw">&#39;</span>,<span class="dv">0</span>,<span class="kw">&#39;</span><span class="st">lagda2tex</span><span class="kw">&#39;</span>);</a>
<a class="sourceLine" id="cb6-3" data-line-number="3"></a>
<a class="sourceLine" id="cb6-4" data-line-number="4"><span class="kw">sub </span><span class="fu">lagda2tex</span> {</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">    <span class="kw">my</span> <span class="dt">$base</span> = <span class="fu">shift</span> <span class="dt">@_</span>;</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">    <span class="kw">return</span> <span class="fu">system</span>(<span class="kw">&#39;</span><span class="st">agda</span><span class="kw">&#39;</span>, <span class="kw">&#39;</span><span class="st">--latex</span><span class="kw">&#39;</span>, <span class="kw">&#39;</span><span class="st">--latex-dir=.</span><span class="kw">&#39;</span>, <span class="kw">&quot;</span><span class="dt">$base</span><span class="st">.lagda</span><span class="kw">&quot;</span>);</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">}</a></code></pre></div>
<h1 id="flags-for-debugging">Flags for Debugging</h1>
<p>There are a number of undocumented flags you can pass to Agda which are absolutely invaluable when it comes to debugging. One of them <a href="http://oleg.fi/gists/posts/2018-08-29-agda-termination-checker.html">can tell you more about termination checking</a>, another reports on type checking (<code>tc</code>), another for profiling (<code>profile</code>), and so on. Set the verbosity level (<code>agda -v 100</code>) to get more or less info.</p>
<h1 id="type-checking-order">Type Checking Order</h1>
<p>Agda does type checking from left to right. This isn’t always desired: as an example, if we want to annotate a value with its type, we can use the following function:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb7-1" data-line-number="1">the <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">)</span> <span class="ot">→</span> A <span class="ot">→</span> A</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">the <span class="ot">_</span> x <span class="ot">=</span> x</a>
<a class="sourceLine" id="cb7-3" data-line-number="3"></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">example <span class="ot">:</span> <span class="ot">_</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5">example <span class="ot">=</span> the ℕ <span class="dv">3</span></a></code></pre></div>
<p>Coming from Haskell, though, this is the wrong way around. We usually prefer to write something like <code>3 :: Int</code>. We can’t write that as a simple function in Agda, though, so we instead use a syntax declaration:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">syntax</span> the ty x <span class="ot">=</span> x ∷ ty</a>
<a class="sourceLine" id="cb8-2" data-line-number="2"></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">example <span class="ot">:</span> <span class="ot">_</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">example <span class="ot">=</span> <span class="dv">3</span> ∷ ℕ</a></code></pre></div>
<p>Changing the order of type checking can also <a href="https://github.com/agda/agda-stdlib/issues/622#issue-411010875">speed up typechecking in some cases</a>. There’s more information about syntax declarations in <a href="https://agda.readthedocs.io/en/latest/language/syntax-declarations.html">Agda’s documentation</a>.</p>
]]></description>
    <pubDate>Thu, 14 Mar 2019 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2019-03-14-more-agda-tips.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Finger Trees in Agda</title>
    <link>https://doisinkidney.com/posts/2019-02-25-agda-fingertrees.html</link>
    <description><![CDATA[<div class="info">
    Posted on February 25, 2019
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Agda.html">Agda</a>
    
</div>

<hr />
<h2 id="this-post-is-available-with-clickable-code-here"><a href="https://oisdk.github.io/agda-indexed-fingertree/Data.FingerTree.html">This Post is Available With Clickable Code Here</a></h2>
<p>This whole post is written with clickable identifiers and ascii art at the above link. I also provide the normal version below in case there are any problems rendering.</p>
<hr />
<p>As I have talked about <a href="/posts/2019-01-15-binomial-urn.html">previously</a>, a large class of divide-and conquer algorithms rely on “good” partitioning for the divide step. If you then want to make the algorithms incremental, you keep all of those partitions (with their summaries) in some “good” arrangement <span class="citation" data-cites="mu_queueing_2016">(Mu, Chiang, and Lyu <a href="#ref-mu_queueing_2016">2016</a>)</span>. Several common data structures are designed around this principle: binomial heaps, for instance, store partitions of size <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mi>n</mi></msup><annotation encoding="application/x-tex">2^n</annotation></semantics></math>. Different ways of storing partitions favours different use cases: switch from a binomial heap to a skew binomial, for instance, and you get constant-time <code>cons</code>.</p>
<p>The standout data structure in this area is Hinze and Paterson’s finger tree <span class="citation" data-cites="Hinze-Paterson:FingerTree">(Hinze and Paterson <a href="#ref-Hinze-Paterson:FingerTree">2006</a>)</span>. It caches summaries in a pretty amazing way, allowing for (amortised) <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math> <code>cons</code> and <code>snoc</code> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math> <code>split</code> and <code>append</code>. These features allow it to be used for a huge variety of things: <a href="http://hackage.haskell.org/package/containers-0.6.0.1/docs/Data-Sequence.html">Data.Sequence</a> uses it as a random-access sequence, but it can also work as a priority queue, a search tree, a priority search tree <span class="citation" data-cites="hinze_simple_2001">(Hinze <a href="#ref-hinze_simple_2001">2001</a>)</span>, an interval tree, an order statistic tree…</p>
<p>All of these applications solely rely on an underlying monoid. As a result, I thought it would be a great data structure to implement in Agda, so that you’d get all of the other data structures with minimal effort <span class="citation" data-cites="sozeau_program-ing_2007">(similar thinking motivated a Coq implementation; Sozeau <a href="#ref-sozeau_program-ing_2007">2007</a>)</span>.</p>
<h1 id="scope-of-the-verification">Scope of the Verification</h1>
<p>There would be no real point to implementing a finger tree in Agda if we didn’t also prove some things about it. The scope of the proofs I’ve done so far are intrinsic proofs of the summaries in the tree. In other words, the type of <code>cons</code> is as follows:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb1-1" data-line-number="1">cons <span class="ot">:</span> <span class="ot">∀</span> x <span class="ot">{</span>xs<span class="ot">}</span> <span class="ot">→</span> Tree xs <span class="ot">→</span> Tree <span class="ot">(</span>μ x ∙ xs<span class="ot">)</span></a></code></pre></div>
<p>This is enough to prove things about the derived data structures (like the correctness of sorting if it’s used as a priority queue), but it’s worth pointing out what I <em>haven’t</em> proved (yet):</p>
<ol>
<li>Invariants on the structure (“safe” and “unsafe” digits and so on).</li>
<li>The time complexity or performance of any operations.</li>
</ol>
<p>To be honest, I’m not even sure that my current implementation is correct in these regards! I’ll probably have a go at proving them in the future <span class="citation" data-cites="danielsson_lightweight_2008">(possibly using Danielsson <a href="#ref-danielsson_lightweight_2008">2008</a>)</span>.</p>
<h1 id="monoids-and-proofs">Monoids and Proofs</h1>
<p>The bad news is that finger trees are a relatively complex data structure, and we’re going to need a <em>lot</em> of proofs to write a verified version. The good news is that monoids (in contrast to rings) are extremely easy to prove automatically. In this project, I used reflection to do so, but I think it should be possible to do with instance resolution also.</p>
<h1 id="measures">Measures</h1>
<p>First things first, we need a way to talk about the summaries of elements we’re interested in. This is captured by the following record type:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">record</span> σ <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">(</span>Σ <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">(</span>a ⊔ r<span class="ot">)</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  <span class="kw">field</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">    μ <span class="ot">:</span> Σ <span class="ot">→</span> 𝓡</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">    </a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="kw">open</span> σ ⦃ <span class="ot">...</span> ⦄</a></code></pre></div>
<p><code>𝓡</code> is the type of the summaries, and <code>μ</code> means “summarise”. The silly symbols are used for brevity: we’re going to be using this thing everywhere, so it’s important to keep it short. Here’s an example instance for lists:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb3-1" data-line-number="1">instance</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  σ-List <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">{</span>Σ <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">→</span> ⦃ <span class="ot">_</span> <span class="ot">:</span> σ Σ ⦄ <span class="ot">→</span> σ <span class="ot">(</span>List Σ<span class="ot">)</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">  μ ⦃ σ-List ⦄ <span class="ot">=</span> List<span class="ot">.</span>foldr <span class="ot">(_</span>∙<span class="ot">_</span> ∘ μ<span class="ot">)</span> ε</a></code></pre></div>
<h1 id="working-with-setoids">Working With Setoids</h1>
<p>As I mentioned, the tree is going to be verified intrinsically. In other word its type will look something like this:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb4-1" data-line-number="1">Tree <span class="ot">:</span> 𝓡 <span class="ot">→</span> <span class="dt">Set</span></a></code></pre></div>
<p>But before running off to define that the obvious way, I should mention that I made the annoying decision to use a setoid (rather than propositional equality) based monoid. This means that we don’t get substitution, making the obvious definition untenable.</p>
<p>I figured out a solution to the problem, but I’m not sure if I’m happy with it. That’s actually the main motivation for writing this post: I’m curious if other people have better techniques for this kind of thing.</p>
<p>To clarify: “this kind of thing” is writing intrinsic (correct-by-construction) proofs when a setoid is involved. Intrinsic proofs usually lend themselves to elegance: to prove that <code>map</code> preserves a vector’s length, for instance, basically requires no proof at all:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb5-1" data-line-number="1">map <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>a b n<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">{</span>B <span class="ot">:</span> <span class="dt">Set</span> b<span class="ot">}</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">    <span class="ot">→</span> <span class="ot">(</span>A <span class="ot">→</span> B<span class="ot">)</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">    <span class="ot">→</span> Vec A n</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">    <span class="ot">→</span> Vec B n</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">map f [] <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">map f <span class="ot">(</span>x ∷ xs<span class="ot">)</span> <span class="ot">=</span> f x ∷ map f xs</a></code></pre></div>
<p>But that’s because pattern matching works well with propositional equality: in the first clause, <code>n</code> is set to <code>0</code> automatically. If we were working with setoid equality, we’d instead maybe get a proof that <code>n ≈ 0</code>, and we’d have to figure a way to work that into the types.</p>
<h1 id="fibres">Fibres</h1>
<p>The first part of the solution is to define a wrapper type which stores information about the size of the thing it contains:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">record</span> μ⟨<span class="ot">_</span>⟩≈<span class="ot">_</span> <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">(</span>Σ <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">)</span> ⦃ <span class="ot">_</span> <span class="ot">:</span> σ Σ ⦄ <span class="ot">(</span>𝓂 <span class="ot">:</span> 𝓡<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">(</span>a ⊔ r ⊔ m<span class="ot">)</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  <span class="kw">constructor</span> <span class="ot">_</span>⇑[<span class="ot">_</span>]</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  <span class="kw">field</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">    𝓢 <span class="ot">:</span> Σ</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">    𝒻 <span class="ot">:</span> μ 𝓢 ≈ 𝓂</a></code></pre></div>
<p>Technically speaking, I think this is known as a “fibre”. <code>μ⟨ Σ ⟩≈ 𝓂</code> means “There exists a <code>Σ</code> such that <code>μ Σ ≈ 𝓂</code>”. Next, we’ll need some combinators to work with:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">infixl</span> <span class="dv">2</span> <span class="ot">_</span>≈[<span class="ot">_</span>]</a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="ot">_</span>≈[<span class="ot">_</span>] <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">{</span>Σ <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> ⦃ <span class="ot">_</span> <span class="ot">:</span> σ Σ ⦄ <span class="ot">{</span>x <span class="ot">:</span> 𝓡<span class="ot">}</span> <span class="ot">→</span> μ⟨ Σ ⟩≈ x <span class="ot">→</span> <span class="ot">∀</span> <span class="ot">{</span>y<span class="ot">}</span> <span class="ot">→</span> x ≈ y <span class="ot">→</span> μ⟨ Σ ⟩≈ y</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">𝓢 <span class="ot">(</span>xs ≈[ y≈z ]<span class="ot">)</span> <span class="ot">=</span> 𝓢 xs</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">𝒻 <span class="ot">(</span>xs ≈[ y≈z ]<span class="ot">)</span> <span class="ot">=</span> trans <span class="ot">(</span>𝒻 xs<span class="ot">)</span> y≈z</a></code></pre></div>
<p>This makes it possible to “rewrite” the summary, given a proof of equivalence.</p>
<h1 id="do-notation">Do Notation</h1>
<p>The wrapper on its own isn’t enough to save us from hundreds of lines of proofs. Once you do computation on its contents, you still need to join it up with its original proof of equivalence. In other words, you’ll need to drill into the return type of a function, find the place you used the relevant type variable, and apply the relevant proof from the type above. This can really clutter proofs. Instead, we can use Agda’s new support for do notation to try and get a cleaner notation for everything. Here’s a big block of code:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">infixl</span> <span class="dv">2</span> arg-syntax</a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="kw">record</span> Arg <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">(</span>Σ <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">)</span> ⦃ <span class="ot">_</span> <span class="ot">:</span> σ Σ ⦄ <span class="ot">(</span>𝓂 <span class="ot">:</span> 𝓡<span class="ot">)</span> <span class="ot">(</span>f <span class="ot">:</span> 𝓡 <span class="ot">→</span> 𝓡<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">(</span>m ⊔ r ⊔ a<span class="ot">)</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  <span class="kw">constructor</span> arg-syntax</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">  <span class="kw">field</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5">    ⟨f⟩ <span class="ot">:</span> Congruent₁ f</a>
<a class="sourceLine" id="cb8-6" data-line-number="6">    arg <span class="ot">:</span> μ⟨ Σ ⟩≈ 𝓂</a>
<a class="sourceLine" id="cb8-7" data-line-number="7"><span class="kw">open</span> Arg</a>
<a class="sourceLine" id="cb8-8" data-line-number="8"></a>
<a class="sourceLine" id="cb8-9" data-line-number="9"><span class="kw">syntax</span> arg-syntax <span class="ot">(λ</span> sz <span class="ot">→</span> e₁<span class="ot">)</span> xs <span class="ot">=</span> xs [ e₁ ⟿ sz ]</a>
<a class="sourceLine" id="cb8-10" data-line-number="10"></a>
<a class="sourceLine" id="cb8-11" data-line-number="11"><span class="kw">infixl</span> <span class="dv">1</span> <span class="ot">_</span>&gt;&gt;=<span class="ot">_</span></a>
<a class="sourceLine" id="cb8-12" data-line-number="12"><span class="ot">_</span>&gt;&gt;=<span class="ot">_</span> <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>a b<span class="ot">}</span> <span class="ot">{</span>Σ₁ <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">{</span>Σ₂ <span class="ot">:</span> <span class="dt">Set</span> b<span class="ot">}</span> ⦃ <span class="ot">_</span> <span class="ot">:</span> σ Σ₁ ⦄ ⦃ <span class="ot">_</span> <span class="ot">:</span> σ Σ₂ ⦄ <span class="ot">{</span>𝓂 f<span class="ot">}</span></a>
<a class="sourceLine" id="cb8-13" data-line-number="13">      <span class="ot">→</span> Arg Σ₁ 𝓂 f</a>
<a class="sourceLine" id="cb8-14" data-line-number="14">      <span class="ot">→</span> <span class="ot">((</span>x <span class="ot">:</span> Σ₁<span class="ot">)</span> <span class="ot">→</span> ⦃ x≈ <span class="ot">:</span> μ x ≈ 𝓂 ⦄ <span class="ot">→</span> μ⟨ Σ₂ ⟩≈ f <span class="ot">(</span>μ x<span class="ot">))</span></a>
<a class="sourceLine" id="cb8-15" data-line-number="15">      <span class="ot">→</span> μ⟨ Σ₂ ⟩≈ f 𝓂</a>
<a class="sourceLine" id="cb8-16" data-line-number="16">arg-syntax cng xs &gt;&gt;= k <span class="ot">=</span> k <span class="ot">(</span>𝓢 xs<span class="ot">)</span> ⦃ 𝒻 xs ⦄ ≈[ cng <span class="ot">(</span>𝒻 xs<span class="ot">)</span> ]</a></code></pre></div>
<p>First, we define a wrapper for types parameterised by their summary, with a way to lift an underlying equality up into some expression <code>f</code>. The <code>&gt;&gt;=</code> operator just connects up all of the relevant bits. An example is what’s needed:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb9-1" data-line-number="1">listToTree <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">{</span>Σ <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> ⦃ <span class="ot">_</span> <span class="ot">:</span> σ Σ ⦄ <span class="ot">→</span> <span class="ot">(</span>xs <span class="ot">:</span> List Σ<span class="ot">)</span> <span class="ot">→</span> μ⟨ Tree Σ ⟩≈ μ xs</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">listToTree [] <span class="ot">=</span> empty ⇑</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">listToTree <span class="ot">(</span>x ∷ xs<span class="ot">)</span> <span class="ot">=</span> [ ℳ ↯ ]≈ do</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">  ys ← listToTree xs [ μ x ∙&gt; s ⟿ s ]</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  x ◂ ys</a></code></pre></div>
<p>The first line is the base case, nothing interesting going on there. The second line begins the do-notation, but first applies <code>[ ℳ ↯ ]≈</code>: this calls the automated solver. The second line makes the recursive call, and with the syntax:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb10-1" data-line-number="1">[ μ x ∙&gt; s ⟿ s ]</a></code></pre></div>
<p>It tells us where the size of the bound variable will end up in the outer expression.</p>
<div id="refs" class="references">
<div id="ref-danielsson_lightweight_2008">
<p>Danielsson, Nils Anders. 2008. “Lightweight Semiformal Time Complexity Analysis for Purely Functional Data Structures.” In <em>Proceedings of the 35th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</em>, 133–144. POPL ’08. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/1328438.1328457">10.1145/1328438.1328457</a>.</p>
</div>
<div id="ref-hinze_simple_2001">
<p>Hinze, Ralf. 2001. “A Simple Implementation Technique for Priority Search Queues.” In <em>Proceedings of the 2001 International Conference on Functional Programming</em>, 110–121. ACM Press. doi:<a href="https://doi.org/10.1145/507635.507650">10.1145/507635.507650</a>.</p>
</div>
<div id="ref-Hinze-Paterson:FingerTree">
<p>Hinze, Ralf, and Ross Paterson. 2006. “Finger Trees: A Simple General-purpose Data Structure.” <em>Journal of Functional Programming</em> 16 (2): 197–217.</p>
</div>
<div id="ref-mu_queueing_2016">
<p>Mu, Shin-Cheng, Yu-Hsi Chiang, and Yu-Han Lyu. 2016. “Queueing and Glueing for Optimal Partitioning (Functional Pearl).” In <em>Proceedings of the 21st ACM SIGPLAN International Conference on Functional Programming</em>, 158–167. ICFP 2016. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/2951913.2951923">10.1145/2951913.2951923</a>.</p>
</div>
<div id="ref-sozeau_program-ing_2007">
<p>Sozeau, Matthieu. 2007. “Program-ing Finger Trees in Coq.” In <em>Proceedings of the 12th ACM SIGPLAN International Conference on Functional Programming</em>, 13–24. ICFP ’07. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/1291151.1291156">10.1145/1291151.1291156</a>.</p>
</div>
</div>
]]></description>
    <pubDate>Mon, 25 Feb 2019 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2019-02-25-agda-fingertrees.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>A New Ring Solver for Agda</title>
    <link>https://doisinkidney.com/posts/2019-01-25-agda-ring-solver.html</link>
    <description><![CDATA[<div class="info">
    Posted on January 25, 2019
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Agda.html">Agda</a>
    
</div>

<p>I’m finally a the point where I feel like I can make the project I’ve been working on for the past few months public: <a href="https://oisdk.github.io/agda-ring-solver/README.html">A Ring Solver for Agda</a>. The focus of the project is ergonomics and ease-of-use: hopefully the interface to the solver is simpler and more friendly than the one that’s already there. It can do step-by-step solutions (like Wolfram Alpha). It’s also asymptotically faster than the old solver (and actually faster! The usual optimizations you might apply don’t actually work here, so this bit definitely took the most work).</p>
<p>Anyway, this work is all for my undergrad final year project, but I’m hoping to submit it to a conference or something in the next few weeks.</p>
]]></description>
    <pubDate>Fri, 25 Jan 2019 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2019-01-25-agda-ring-solver.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>A Binomial Urn</title>
    <link>https://doisinkidney.com/posts/2019-01-15-binomial-urn.html</link>
    <description><![CDATA[<div class="info">
    Posted on January 15, 2019
</div>
<div class="info">
    
        Part 3 of a <a href="/series/Balanced%20Folds.html">3-part series on Balanced Folds</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<p>When we started the series, we wanted to find a “better” fold: one that was more balanced than either <code>foldl</code> or <code>foldr</code> (in its placement of parentheses). Both of these are about as unbalanced as you can get:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> foldr (<span class="fu">+</span>) <span class="dv">0</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="dv">1</span> <span class="fu">+</span> (<span class="dv">2</span> <span class="fu">+</span> (<span class="dv">3</span> <span class="fu">+</span> <span class="dv">0</span>))</a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="fu">&gt;&gt;&gt;</span> foldl (<span class="fu">+</span>) <span class="dv">0</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">((<span class="dv">0</span> <span class="fu">+</span> <span class="dv">1</span>) <span class="fu">+</span> <span class="dv">2</span>) <span class="fu">+</span> <span class="dv">3</span></a></code></pre></div>
<p>The first better fold I found was Jon Fairbairn’s simple <code>treeFold</code>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">treeFold ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">treeFold f <span class="fu">=</span> go</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">    go x [] <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">    go a  (b<span class="fu">:</span>l) <span class="fu">=</span> go (f a b) (pairMap l)</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">    pairMap (x<span class="fu">:</span>y<span class="fu">:</span>rest) <span class="fu">=</span> f x y <span class="fu">:</span> pairMap rest</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">    pairMap xs <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">  </a>
<a class="sourceLine" id="cb2-9" data-line-number="9"><span class="fu">&gt;&gt;&gt;</span> treeFold (<span class="fu">+</span>) <span class="dv">0</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb2-10" data-line-number="10">(<span class="dv">0</span> <span class="fu">+</span> <span class="dv">1</span>) <span class="fu">+</span> (<span class="dv">2</span> <span class="fu">+</span> <span class="dv">3</span>)</a></code></pre></div>
<p>Already this function was kind of magical: if your binary operator merges two sorted lists, <code>foldr</code> will give you insertion sort, whereas <code>treeFold</code> will give you merge sort; for summing floats, <code>treeFold</code> has a lower error growth than <code>sum</code>. By dividing up the work better, we were able to improve the characteristics of many algorithms automatically. We also saw that it could easily be made parallel:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">parseq ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">parseq a b <span class="fu">=</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">    runST</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">        (bool (par a b) (seq a b) <span class="fu">&lt;$&gt;</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">         unsafeIOToST (liftA2 (<span class="fu">&gt;</span>) numSparks getNumCapabilities))</a>
<a class="sourceLine" id="cb3-6" data-line-number="6"></a>
<a class="sourceLine" id="cb3-7" data-line-number="7"><span class="ot">treeFoldParallel ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb3-8" data-line-number="8">treeFoldParallel f <span class="fu">=</span></a>
<a class="sourceLine" id="cb3-9" data-line-number="9">    treeFold</a>
<a class="sourceLine" id="cb3-10" data-line-number="10">        (\l r <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb3-11" data-line-number="11">              r <span class="ot">`parseq`</span> (l <span class="ot">`parseq`</span> f l r))</a></code></pre></div>
<p>In the next post, we saw how we could make the fold incremental, by using binary number representations for data structures. This let us do 2 things: it meant the fold was structurally terminating, so it would pass the termination checker (efficiently) in languages like Agda or Idris, and it meant we could write <code>scanl</code> using the fold. The <code>scanl</code> was also efficient: you could run the fold at any point in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math> time, and work would be shared between subsequent runs. Effectively, this let us use it to solve greedy optimization problems. We also saw how it was effectively constructing an implicit binomial priority queue under the hood, and how it exploited laziness to get sharing.</p>
<p>I’ve gotten huge mileage out of this fold and the general ideas about it, and today I’m going to show one more use of it. We’re going to improve some of the asymptotics of the data structure presented in <span class="citation" data-cites="lampropoulos_ode_2017">Lampropoulos, Spector-Zabusky, and Foner (<a href="#ref-lampropoulos_ode_2017">2017</a>)</span>.</p>
<h1 id="a-random-urn">A Random Urn</h1>
<p>The paper opens with the problem:</p>
<blockquote>
<p>Suppose you have an urn containing two red balls, four green balls, and three blue balls. If you take three balls out of the urn, what is the probability that two of them are green?</p>
</blockquote>
<p>If you were to take just <em>one</em> ball out of the earn, calculating the associated probabilities would be easy. Once you get to the second, though, you have to update the previous probability <em>based on what ball was removed</em>. In other words, we need to be able to dynamically update the distribution.</p>
<p>Using lists, this would obviously become an <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n)</annotation></semantics></math> operation. In the paper, an almost-perfect binary tree is used. This turns the operation into one that’s <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math>. The rest of the operations have the following complexities:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Operation</th>
<th>Complexity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>insert</code></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>remove</code></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>fromList</code></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n)</annotation></semantics></math></td>
</tr>
</tbody>
</table>
<p>As a quick spoiler, the improved version presented here has these complexities:</p>
<table>
<thead>
<tr class="header">
<th>Operation</th>
<th>Complexity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>insert</code></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math></td>
</tr>
<tr class="even">
<td><code>remove</code></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math></td>
</tr>
<tr class="odd">
<td><code>merge</code></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math></td>
</tr>
<tr class="even">
<td><code>fromList</code></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n)</annotation></semantics></math></td>
</tr>
</tbody>
</table>
<p>We add another operation (<code>merge</code>), which means that the new structure is viable as an instance of <code>Alternative</code>, <code>Monad</code>, and so on, making it an efficient monad for weighted backtracking search.</p>
<h1 id="priority-queues">Priority Queues</h1>
<p>The key thing to notice in the paper which will let us improve the structure is that what they’re designing is actually a <em>priority queue</em>. Well, a weird looking priority queue, but a priority queue nonetheless.</p>
<p>Think about it like a max-priority queue (pop returns the largest element first), with a degree of “randomization”. In other words, when you go to do a pop, all of the comparisons between the ordering keys (the weights in this case) sprinkles some randomness into the equation, meaning that instead of <code>1 &lt; 2</code> returning <code>True</code>, it returns <code>True</code> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mn>2</mn><mn>3</mn></mfrac><annotation encoding="application/x-tex">\frac{2}{3}</annotation></semantics></math> of the time, and <code>False</code> the other <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mn>1</mn><mn>3</mn></mfrac><annotation encoding="application/x-tex">\frac{1}{3}</annotation></semantics></math>.</p>
<p>This way of doing things means that not every priority queue is suitable: we want to run comparisons at <code>pop</code> time (not <code>insert</code>), so a binary heap (for instance) won’t do. At branches (non-leaves), the queue will only be allowed store <em>summaries</em> of the data, not the “max element”.</p>
<p>The one presented in the paper is something like a Braun priority queue: the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n)</annotation></semantics></math> <code>fromList</code> implementation is reminiscent of the one in <span class="citation" data-cites="okasaki_three_1997">Okasaki (<a href="#ref-okasaki_three_1997">1997</a>)</span>.</p>
<p>So what priority queue can we choose to get us the desired efficiency? Why, a binomial one of course!</p>
<h1 id="the-data-structure">The Data Structure</h1>
<p>The urn structure itself looks a lot like a binomial heap:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">Tree</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  {<span class="ot"> weight ::</span> <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">Word</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">  ,<span class="ot"> branch ::</span> <span class="dt">Node</span> a</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">  }</a>
<a class="sourceLine" id="cb4-6" data-line-number="6"></a>
<a class="sourceLine" id="cb4-7" data-line-number="7"><span class="kw">data</span> <span class="dt">Node</span> a</a>
<a class="sourceLine" id="cb4-8" data-line-number="8">  <span class="fu">=</span> <span class="dt">Leaf</span> a</a>
<a class="sourceLine" id="cb4-9" data-line-number="9">  <span class="fu">|</span> <span class="dt">Branch</span> (<span class="dt">Tree</span> a) (<span class="dt">Node</span> a)</a>
<a class="sourceLine" id="cb4-10" data-line-number="10"></a>
<a class="sourceLine" id="cb4-11" data-line-number="11"><span class="kw">data</span> <span class="dt">Heap</span> a</a>
<a class="sourceLine" id="cb4-12" data-line-number="12">  <span class="fu">=</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb4-13" data-line-number="13">  <span class="fu">|</span> <span class="dt">Cons</span> <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">Word</span> (<span class="dt">Tree</span> a) (<span class="dt">Heap</span> a)</a>
<a class="sourceLine" id="cb4-14" data-line-number="14">  </a>
<a class="sourceLine" id="cb4-15" data-line-number="15"><span class="kw">data</span> <span class="dt">Urn</span> a <span class="fu">=</span></a>
<a class="sourceLine" id="cb4-16" data-line-number="16">    <span class="dt">Urn</span> <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">Word</span></a>
<a class="sourceLine" id="cb4-17" data-line-number="17">        <span class="fu">!</span>(<span class="dt">Heap</span> a)</a></code></pre></div>
<p>By avoiding the usual <code>Skip</code> constructors you often see in a binomial heap we save a huge amount of space. Instead, we store the “number of zeroes before this bit”. Another thing to point out is that only left branches in the trees store their weight: the same optimization is made in the paper.</p>
<p>Insertion is not much different from insertion for a usual binomial priority queue, although we don’t need to do anything to merge the trees:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">insertHeap ::</span> <span class="dt">Word</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Heap</span> a <span class="ot">-&gt;</span> <span class="dt">Heap</span> a</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">insertHeap i&#39; x&#39; <span class="fu">=</span> go <span class="dv">0</span> (<span class="dt">Tree</span> i&#39; (<span class="dt">Leaf</span> x&#39;))</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">    go <span class="fu">!</span>i x <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Cons</span> i x <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">    go <span class="fu">!</span>i x (<span class="dt">Cons</span> <span class="dv">0</span> y ys) <span class="fu">=</span> go (i<span class="fu">+</span><span class="dv">1</span>) (mergeTree x y) ys</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">    go <span class="fu">!</span>i x (<span class="dt">Cons</span> j y ys) <span class="fu">=</span> <span class="dt">Cons</span> i x (<span class="dt">Cons</span> (j<span class="fu">-</span><span class="dv">1</span>) y ys)</a>
<a class="sourceLine" id="cb5-7" data-line-number="7"></a>
<a class="sourceLine" id="cb5-8" data-line-number="8"><span class="ot">mergeTree ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb5-9" data-line-number="9">mergeTree xs ys <span class="fu">=</span></a>
<a class="sourceLine" id="cb5-10" data-line-number="10">  <span class="dt">Tree</span></a>
<a class="sourceLine" id="cb5-11" data-line-number="11">    (weight xs <span class="fu">+</span> weight ys)</a>
<a class="sourceLine" id="cb5-12" data-line-number="12">    (<span class="dt">Branch</span> xs (branch ys))</a>
<a class="sourceLine" id="cb5-13" data-line-number="13"></a>
<a class="sourceLine" id="cb5-14" data-line-number="14"><span class="ot">insert ::</span> <span class="dt">Word</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Urn</span> a <span class="ot">-&gt;</span> <span class="dt">Urn</span> a</a>
<a class="sourceLine" id="cb5-15" data-line-number="15">insert i x (<span class="dt">Urn</span> w xs) <span class="fu">=</span> <span class="dt">Urn</span> (w<span class="fu">+</span>i) (insertHeap i x xs)</a></code></pre></div>
<p>We <em>could</em> potentially get insertion from amortized <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math> to worst-case <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math> by using skew binary instead of binary (in fact I am almost sure it’s possible), but then I think we’d lose the efficient merge. I’ll leave exploring that for another day.</p>
<p>To get randomness, we’ll write a very simple class that encapsulates only what we need:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Sample</span> m <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">    <span class="co">-- | Inclusive range</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="ot">    inRange ::</span> <span class="dt">Word</span> <span class="ot">-&gt;</span> <span class="dt">Word</span> <span class="ot">-&gt;</span> m <span class="dt">Word</span></a></code></pre></div>
<p>You can later instantiate this to whatever random monad you end up using. (The same approach was taken in the paper, although we only require <code>Functor</code> here, not <code>Monad</code>).</p>
<p>Sampling (with replacement) first randomly chooses a tree from the top-level list, and then we drill down into that tree with binary search.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">sample ::</span> (<span class="dt">Functor</span> m, <span class="dt">Sample</span> m) <span class="ot">=&gt;</span> <span class="dt">Urn</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (m a)</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">sample (<span class="dt">Urn</span> _ <span class="dt">Nil</span>) <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">sample (<span class="dt">Urn</span> w&#39; (<span class="dt">Cons</span> _ x&#39; xs&#39;)) <span class="fu">=</span> <span class="dt">Just</span> (fmap (go x&#39; xs&#39;) (inRange <span class="dv">0</span> (w&#39; <span class="fu">-</span> <span class="dv">1</span>)))</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5">    go x <span class="dt">Nil</span> <span class="fu">!</span>w <span class="fu">=</span> go&#39; w (branch x)</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">    go x (<span class="dt">Cons</span> _ y ys) <span class="fu">!</span>w</a>
<a class="sourceLine" id="cb7-7" data-line-number="7">      <span class="fu">|</span> w <span class="fu">&lt;</span> weight x <span class="fu">=</span> go&#39; w (branch x)</a>
<a class="sourceLine" id="cb7-8" data-line-number="8">      <span class="fu">|</span> otherwise    <span class="fu">=</span> go y ys (w <span class="fu">-</span> weight x)</a>
<a class="sourceLine" id="cb7-9" data-line-number="9">    go&#39; <span class="fu">!</span>_ (<span class="dt">Leaf</span> x) <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb7-10" data-line-number="10">    go&#39; <span class="fu">!</span>i (<span class="dt">Branch</span> xs ys)</a>
<a class="sourceLine" id="cb7-11" data-line-number="11">      <span class="fu">|</span> i <span class="fu">&lt;</span> weight xs <span class="fu">=</span> go&#39; i (branch xs)</a>
<a class="sourceLine" id="cb7-12" data-line-number="12">      <span class="fu">|</span> otherwise <span class="fu">=</span> go&#39; (i <span class="fu">-</span> weight xs) ys</a></code></pre></div>
<p>So we’re off to a good start, but <code>remove</code> is a complex operation. We take the same route taken in the paper: first, we perform an “uncons”-like operation, which pops out the last inserted element. Then, we randomly choose a point in the tree (using the same logic as in <code>sample</code>), and replace it with the popped element<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">remove ::</span> (<span class="dt">Functor</span> m, <span class="dt">Sample</span> m) <span class="ot">=&gt;</span> <span class="dt">Urn</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (m ((a, <span class="dt">Word</span>), <span class="dt">Urn</span> a))</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">remove (<span class="dt">Urn</span> w hp) <span class="fu">=</span> fmap go&#39; (Heap.uninsert hp)</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">    go&#39; (vw,v,hp&#39;) <span class="fu">=</span> fmap (<span class="ot">`go`</span> hp&#39;) (inRange <span class="dv">0</span> (w<span class="fu">-</span><span class="dv">1</span>))</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">        go <span class="fu">!</span>_  <span class="dt">Nil</span> <span class="fu">=</span> ((v, vw), <span class="dt">Urn</span> <span class="dv">0</span> <span class="dt">Nil</span>)</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">        go <span class="fu">!</span>rw vs<span class="fu">@</span>(<span class="dt">Cons</span> i&#39; x&#39; xs&#39;)</a>
<a class="sourceLine" id="cb8-8" data-line-number="8">          <span class="fu">|</span> rw <span class="fu">&lt;</span> vw <span class="fu">=</span> ((v, vw), <span class="dt">Urn</span> (w <span class="fu">-</span> vw) vs)</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">          <span class="fu">|</span> otherwise <span class="fu">=</span> replace (rw <span class="fu">-</span> vw) i&#39; x&#39; xs&#39;</a>
<a class="sourceLine" id="cb8-10" data-line-number="10">            (\ys yw y <span class="ot">-&gt;</span> ((y, yw), <span class="dt">Urn</span> (w <span class="fu">-</span> yw) ys))</a>
<a class="sourceLine" id="cb8-11" data-line-number="11"></a>
<a class="sourceLine" id="cb8-12" data-line-number="12">        replace <span class="fu">!</span>rw i x <span class="dt">Nil</span> k <span class="fu">=</span> replaceTree rw x (\t <span class="ot">-&gt;</span> k (<span class="dt">Cons</span> i t <span class="dt">Nil</span>))</a>
<a class="sourceLine" id="cb8-13" data-line-number="13">        replace <span class="fu">!</span>rw i x xs<span class="fu">@</span>(<span class="dt">Cons</span> j y ys) k</a>
<a class="sourceLine" id="cb8-14" data-line-number="14">          <span class="fu">|</span> rw <span class="fu">&lt;</span> weight x <span class="fu">=</span> replaceTree rw x (\t <span class="ot">-&gt;</span> k (<span class="dt">Cons</span> i t xs))</a>
<a class="sourceLine" id="cb8-15" data-line-number="15">          <span class="fu">|</span> otherwise <span class="fu">=</span> replace (rw <span class="fu">-</span> weight x) j y ys (k <span class="fu">.</span> <span class="dt">Cons</span> i x)</a>
<a class="sourceLine" id="cb8-16" data-line-number="16"></a>
<a class="sourceLine" id="cb8-17" data-line-number="17">        replaceTree <span class="fu">!</span>_  (<span class="dt">Tree</span> tw (<span class="dt">Leaf</span> x)) k <span class="fu">=</span> k (<span class="dt">Tree</span> vw (<span class="dt">Leaf</span> v)) tw x</a>
<a class="sourceLine" id="cb8-18" data-line-number="18">        replaceTree <span class="fu">!</span>rw (<span class="dt">Tree</span> tw (<span class="dt">Branch</span> xs ys)) k</a>
<a class="sourceLine" id="cb8-19" data-line-number="19">          <span class="fu">|</span> rw <span class="fu">&lt;</span> weight xs <span class="fu">=</span> replaceTree rw xs</a>
<a class="sourceLine" id="cb8-20" data-line-number="20">            (\t <span class="ot">-&gt;</span> k (<span class="dt">Tree</span> (tw <span class="fu">+</span> (weight t <span class="fu">-</span> weight xs)) (<span class="dt">Branch</span> t ys)))</a>
<a class="sourceLine" id="cb8-21" data-line-number="21">          <span class="fu">|</span> otherwise <span class="fu">=</span> replaceTree (rw <span class="fu">-</span> weight xs)</a>
<a class="sourceLine" id="cb8-22" data-line-number="22">            (<span class="dt">Tree</span> (tw <span class="fu">-</span> weight xs) ys)</a>
<a class="sourceLine" id="cb8-23" data-line-number="23">            (\t <span class="ot">-&gt;</span> k (<span class="dt">Tree</span> (weight xs <span class="fu">+</span> weight t) (<span class="dt">Branch</span> xs (branch t))))</a></code></pre></div>
<p>Merge is the same as on binomial heaps:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">mergeHeap ::</span> <span class="dt">Heap</span> a <span class="ot">-&gt;</span> <span class="dt">Heap</span> a <span class="ot">-&gt;</span> <span class="dt">Heap</span> a</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">mergeHeap <span class="dt">Nil</span> <span class="fu">=</span> id</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">mergeHeap (<span class="dt">Cons</span> i&#39; x&#39; xs&#39;) <span class="fu">=</span> merger i&#39; x&#39; xs&#39;</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">    merger <span class="fu">!</span>i x xs <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Cons</span> i x xs</a>
<a class="sourceLine" id="cb9-6" data-line-number="6">    merger <span class="fu">!</span>i x xs (<span class="dt">Cons</span> j y ys) <span class="fu">=</span> merge&#39; i x xs j y ys</a>
<a class="sourceLine" id="cb9-7" data-line-number="7"></a>
<a class="sourceLine" id="cb9-8" data-line-number="8">    merge&#39; <span class="fu">!</span>i x xs <span class="fu">!</span>j y ys <span class="fu">=</span> <span class="kw">case</span> compare i j <span class="kw">of</span></a>
<a class="sourceLine" id="cb9-9" data-line-number="9">        <span class="dt">LT</span> <span class="ot">-&gt;</span> <span class="dt">Cons</span> i x (merger (j<span class="fu">-</span>i<span class="fu">-</span><span class="dv">1</span>) y ys xs)</a>
<a class="sourceLine" id="cb9-10" data-line-number="10">        <span class="dt">GT</span> <span class="ot">-&gt;</span> <span class="dt">Cons</span> j y (merger (i<span class="fu">-</span>j<span class="fu">-</span><span class="dv">1</span>) x xs ys)</a>
<a class="sourceLine" id="cb9-11" data-line-number="11">        <span class="dt">EQ</span> <span class="ot">-&gt;</span> mergec (succ i) (mergeTree x y) xs ys</a>
<a class="sourceLine" id="cb9-12" data-line-number="12"></a>
<a class="sourceLine" id="cb9-13" data-line-number="13">    mergec <span class="fu">!</span>p <span class="fu">!</span>t <span class="dt">Nil</span> <span class="fu">=</span> carryLonger p t</a>
<a class="sourceLine" id="cb9-14" data-line-number="14">    mergec <span class="fu">!</span>p <span class="fu">!</span>t (<span class="dt">Cons</span> i x xs) <span class="fu">=</span> mergecr p t i x xs</a>
<a class="sourceLine" id="cb9-15" data-line-number="15"></a>
<a class="sourceLine" id="cb9-16" data-line-number="16">    mergecr <span class="fu">!</span>p <span class="fu">!</span>t <span class="fu">!</span>i x xs <span class="dt">Nil</span> <span class="fu">=</span> carryLonger&#39; p t i x xs</a>
<a class="sourceLine" id="cb9-17" data-line-number="17">    mergecr <span class="fu">!</span>p <span class="fu">!</span>t <span class="fu">!</span>i x xs (<span class="dt">Cons</span> j y ys) <span class="fu">=</span> mergec&#39; p t i x xs j y ys</a>
<a class="sourceLine" id="cb9-18" data-line-number="18"></a>
<a class="sourceLine" id="cb9-19" data-line-number="19">    mergec&#39; <span class="fu">!</span>p t <span class="fu">!</span>i x xs <span class="fu">!</span>j y ys <span class="fu">=</span> <span class="kw">case</span> compare i j <span class="kw">of</span></a>
<a class="sourceLine" id="cb9-20" data-line-number="20">      <span class="dt">LT</span> <span class="ot">-&gt;</span> mergecr&#39;&#39; p t i x xs (j<span class="fu">-</span>i<span class="fu">-</span><span class="dv">1</span>) y ys</a>
<a class="sourceLine" id="cb9-21" data-line-number="21">      <span class="dt">GT</span> <span class="ot">-&gt;</span> mergecr&#39;&#39; p t j y ys (i<span class="fu">-</span>j<span class="fu">-</span><span class="dv">1</span>) x xs</a>
<a class="sourceLine" id="cb9-22" data-line-number="22">      <span class="dt">EQ</span> <span class="ot">-&gt;</span> <span class="dt">Cons</span> p t (mergec i (mergeTree x y) xs ys)</a>
<a class="sourceLine" id="cb9-23" data-line-number="23"></a>
<a class="sourceLine" id="cb9-24" data-line-number="24">    mergecr&#39;&#39; <span class="fu">!</span>p <span class="fu">!</span>t  <span class="dv">0</span> x xs <span class="fu">!</span>j y ys <span class="fu">=</span> mergecr (p<span class="fu">+</span><span class="dv">1</span>) (mergeTree t x) j y ys xs</a>
<a class="sourceLine" id="cb9-25" data-line-number="25">    mergecr&#39;&#39; <span class="fu">!</span>p <span class="fu">!</span>t <span class="fu">!</span>i x xs <span class="fu">!</span>j y ys <span class="fu">=</span> <span class="dt">Cons</span> p t (<span class="dt">Cons</span> (i<span class="fu">-</span><span class="dv">1</span>) x (merger j y ys xs))</a>
<a class="sourceLine" id="cb9-26" data-line-number="26"></a>
<a class="sourceLine" id="cb9-27" data-line-number="27">    carryLonger <span class="fu">!</span>i <span class="fu">!</span>t <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Cons</span> i t <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb9-28" data-line-number="28">    carryLonger <span class="fu">!</span>i <span class="fu">!</span>t (<span class="dt">Cons</span> j y ys) <span class="fu">=</span> carryLonger&#39; i t j y ys</a>
<a class="sourceLine" id="cb9-29" data-line-number="29"></a>
<a class="sourceLine" id="cb9-30" data-line-number="30">    carryLonger&#39; <span class="fu">!</span>i <span class="fu">!</span>t  <span class="dv">0</span> y ys <span class="fu">=</span> carryLonger (succ i) (mergeTree t y) ys</a>
<a class="sourceLine" id="cb9-31" data-line-number="31">    carryLonger&#39; <span class="fu">!</span>i <span class="fu">!</span>t <span class="fu">!</span>j y ys <span class="fu">=</span> <span class="dt">Cons</span> i t (<span class="dt">Cons</span> (j<span class="fu">-</span><span class="dv">1</span>) y ys)</a>
<a class="sourceLine" id="cb9-32" data-line-number="32"></a>
<a class="sourceLine" id="cb9-33" data-line-number="33"><span class="ot">merge ::</span> <span class="dt">Urn</span> a <span class="ot">-&gt;</span> <span class="dt">Urn</span> a <span class="ot">-&gt;</span> <span class="dt">Urn</span> a</a>
<a class="sourceLine" id="cb9-34" data-line-number="34">merge (<span class="dt">Urn</span> i xs) (<span class="dt">Urn</span> j ys) <span class="fu">=</span> <span class="dt">Urn</span> (i<span class="fu">+</span>j) (mergeHeap xs ys)   </a></code></pre></div>
<h1 id="finger-trees">Finger Trees</h1>
<p>Again, the cleverness of all the tree folds is that they intelligently batch summarizing operations, allowing you to efficiently so prefix-scan-like operations that exploit sharing.</p>
<p>The bare-bones version just uses binary numbers: you can upgrade the <code>cons</code> operation to worst-case constant-time if you use <em>skew</em> binary. Are there other optimizations? Yes! What if we wanted to stick something on to the <em>other</em> end, for instance? What if we wanted to reverse?</p>
<p>If you figure out a way to do <em>all</em> these optimizations, and put them into one big data structure, you get the mother-of-all “batching” data structures: the finger tree. This is the basis for Haskell’s Data.Sequence, but it can also implement priority queues, urns (I’d imagine), fenwick-tree-like structures, and more.</p>
<h1 id="uses-and-further-work">Uses and Further Work</h1>
<p>First and foremost, I should test the above implementations! I’m pretty confident the asymptotics are correct, but I’m certain the implementations have bugs.</p>
<p>The efficient <code>merge</code> is intriguing: it means that <code>Urn</code> could conceivably be <code>Alternative</code>, <code>MonadPlus</code>, etc. I have yet to see a use for that, but it’s interesting nonetheless! I’m constantly looking for a way to express something like Dijkstra’s algorithm algebraicly, using the usual <code>Alternative</code> combinators; I don’t know if this is related.</p>
<p>The other interesting point is that, for this to be an instance of <code>Applicative</code>, it would need some analogue for multiplication for the weights. I’m not sure what that should be.</p>
<p>This is inherently <em>max</em>-priority. It’s not obvious how to translate what we have into a min-priority queue version.</p>
<p>Finally, it might be worth trying out different priority queues (a pairing heap is very similar in structure to this). Also, we could rearrange the weights so that larger ones are higher in each tree: this might give a performance boost.</p>
<div id="refs" class="references">
<div id="ref-lampropoulos_ode_2017">
<p>Lampropoulos, Leonidas, Antal Spector-Zabusky, and Kenneth Foner. 2017. “Ode on a random urn (functional pearl).” In, 26–37. ACM Press. doi:<a href="https://doi.org/10.1145/3122955.3122959">10.1145/3122955.3122959</a>.</p>
</div>
<div id="ref-okasaki_three_1997">
<p>Okasaki, Chris. 1997. “Three Algorithms on Braun Trees.” <em>Journal of Functional Programming</em> 7 (6) (November): 661–666. doi:<a href="https://doi.org/10.1017/S0956796897002876">10.1017/S0956796897002876</a>.</p>
</div>
</div>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>There’s one extra step I haven’t mentioned: we also must allow the first element (the last inserted) to be chosen, so we run the random-number generator once to check if that’s the element we want to choose.<a href="#fnref1" class="footnote-back">↩</a></p></li>
</ol>
</section>
]]></description>
    <pubDate>Tue, 15 Jan 2019 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2019-01-15-binomial-urn.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Balancing Scans</title>
    <link>https://doisinkidney.com/posts/2018-12-21-balancing-scans.html</link>
    <description><![CDATA[<div class="info">
    Posted on December 21, 2018
</div>
<div class="info">
    
        Part 2 of a <a href="/series/Balanced%20Folds.html">3-part series on Balanced Folds</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Agda.html">Agda</a>
    
</div>

<p><a href="2017-10-30-balancing-folds.html">Previously</a> I tried to figure out a way to fold lists in a more balanced way. Usually, when folding lists, you’ve got two choices for your folds, both of which are extremely unbalanced in one direction or another. Jon Fairbairn <a href="https://www.mail-archive.com/haskell@haskell.org/msg01788.html">wrote</a> a more balanced version, which looked something like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">treeFold ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">treeFold f <span class="fu">=</span> go</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">    go x [] <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">    go a (b<span class="fu">:</span>l) <span class="fu">=</span> go (f a b) (pairMap l)</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">    pairMap (x<span class="fu">:</span>y<span class="fu">:</span>rest) <span class="fu">=</span> f x y <span class="fu">:</span> pairMap rest</a>
<a class="sourceLine" id="cb1-7" data-line-number="7">    pairMap xs <span class="fu">=</span> xs</a></code></pre></div>
<h1 id="magical-speedups">Magical Speedups</h1>
<p>The fold above is kind of magical: for a huge class of algorithms, it kind of “automatically” improves some factor of theirs from <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n)</annotation></semantics></math> to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math>. For instance: to sum a list of floats, <code class="sourceCode haskell">foldl&#39; (<span class="fu">+</span>) <span class="dv">0</span></code> will have an error growth of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n)</annotation></semantics></math>; <code>treeFold (+) 0</code>, though, has an error rate of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math>. Similarly, using the following function to merge two sorted lists:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">merge ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">merge [] ys <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">merge (x<span class="fu">:</span>xs) ys <span class="fu">=</span> go x xs ys</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5">    go x xs [] <span class="fu">=</span> x <span class="fu">:</span> xs</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">    go x xs (y<span class="fu">:</span>ys)</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">      <span class="fu">|</span> x <span class="fu">&lt;=</span> y    <span class="fu">=</span> x <span class="fu">:</span> go y ys xs</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">      <span class="fu">|</span> otherwise <span class="fu">=</span> y <span class="fu">:</span> go x xs ys</a></code></pre></div>
<p>We get either insertion sort (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n^2)</annotation></semantics></math>) or merge sort (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n \log n)</annotation></semantics></math>) just depending on which fold you use.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1">foldr    merge [] <span class="fu">.</span> map pure <span class="co">-- n^2</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">treeFold merge [] <span class="fu">.</span> map pure <span class="co">-- n log(n)</span></a></code></pre></div>
<p>I’ll give some more examples later, but effectively it gives us a better “divide” step in many divide and conquer algorithms.</p>
<h1 id="termination">Termination</h1>
<p>As it was such a useful fold, and so integral to many tricky algorithms, I really wanted to have it available in Agda. Unfortunately, though, the functions (as defined above) aren’t structurally terminating, and there doesn’t <em>look</em> like there’s an obvious way to make it so. I tried to make well founded recursion work, but the proofs were ugly and slow.</p>
<p>However, we can use some structures from a <a href="2018-11-20-fast-verified-structures.html">previous post</a>: the nested binary sequence, for instance. It has some extra nice properties: instead of nesting the types, we can just apply the combining function.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">mutual</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  <span class="kw">data</span> Tree <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">    2^<span class="ot">_</span>×<span class="ot">_</span>+<span class="ot">_</span> <span class="ot">:</span> ℕ <span class="ot">→</span> A <span class="ot">→</span> Node A <span class="ot">→</span> Tree A</a>
<a class="sourceLine" id="cb4-4" data-line-number="4"></a>
<a class="sourceLine" id="cb4-5" data-line-number="5">  <span class="kw">data</span> Node <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">    ⟨⟩  <span class="ot">:</span> Node A</a>
<a class="sourceLine" id="cb4-7" data-line-number="7">    ⟨<span class="ot">_</span>⟩ <span class="ot">:</span> Tree A <span class="ot">→</span> Node A</a>
<a class="sourceLine" id="cb4-8" data-line-number="8"></a>
<a class="sourceLine" id="cb4-9" data-line-number="9"><span class="kw">module</span> TreeFold <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">(_</span>*<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">→</span> A <span class="ot">→</span> A<span class="ot">)</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-10" data-line-number="10">  <span class="kw">infixr</span> <span class="dv">5</span> <span class="ot">_</span>⊛<span class="ot">_</span> 2^<span class="ot">_</span>×<span class="ot">_</span>⊛<span class="ot">_</span></a>
<a class="sourceLine" id="cb4-11" data-line-number="11"></a>
<a class="sourceLine" id="cb4-12" data-line-number="12">  2^<span class="ot">_</span>×<span class="ot">_</span>⊛<span class="ot">_</span> <span class="ot">:</span> ℕ <span class="ot">→</span> A <span class="ot">→</span> Tree A <span class="ot">→</span> Tree A</a>
<a class="sourceLine" id="cb4-13" data-line-number="13">  2^ n × x ⊛ 2^ suc m × y + ys <span class="ot">=</span> 2^ n × x + ⟨ 2^ m × y + ys ⟩</a>
<a class="sourceLine" id="cb4-14" data-line-number="14">  2^ n × x ⊛ 2^ zero  × y + ⟨⟩ <span class="ot">=</span> 2^ suc n × <span class="ot">(</span>x * y<span class="ot">)</span> + ⟨⟩</a>
<a class="sourceLine" id="cb4-15" data-line-number="15">  2^ n × x ⊛ 2^ zero  × y + ⟨ ys ⟩ <span class="ot">=</span> 2^ suc n × <span class="ot">(</span>x * y<span class="ot">)</span> ⊛ ys</a>
<a class="sourceLine" id="cb4-16" data-line-number="16"></a>
<a class="sourceLine" id="cb4-17" data-line-number="17">  <span class="ot">_</span>⊛<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">→</span> Tree A <span class="ot">→</span> Tree A</a>
<a class="sourceLine" id="cb4-18" data-line-number="18">  <span class="ot">_</span>⊛<span class="ot">_</span> <span class="ot">=</span> 2^ <span class="dv">0</span> ×<span class="ot">_</span>⊛<span class="ot">_</span></a>
<a class="sourceLine" id="cb4-19" data-line-number="19"></a>
<a class="sourceLine" id="cb4-20" data-line-number="20">  ⟦<span class="ot">_</span>⟧↓ <span class="ot">:</span> Tree A <span class="ot">→</span> A</a>
<a class="sourceLine" id="cb4-21" data-line-number="21">  ⟦ 2^ <span class="ot">_</span> × x + ⟨⟩ ⟧↓ <span class="ot">=</span> x</a>
<a class="sourceLine" id="cb4-22" data-line-number="22">  ⟦ 2^ <span class="ot">_</span> × x + ⟨ xs ⟩ ⟧↓ <span class="ot">=</span> x * ⟦ xs ⟧↓</a>
<a class="sourceLine" id="cb4-23" data-line-number="23"></a>
<a class="sourceLine" id="cb4-24" data-line-number="24">  ⟦<span class="ot">_</span>⟧↑ <span class="ot">:</span> A <span class="ot">→</span> Tree A</a>
<a class="sourceLine" id="cb4-25" data-line-number="25">  ⟦ x ⟧↑ <span class="ot">=</span> 2^ <span class="dv">0</span> × x + ⟨⟩</a>
<a class="sourceLine" id="cb4-26" data-line-number="26"></a>
<a class="sourceLine" id="cb4-27" data-line-number="27">  ⦅<span class="ot">_</span>,<span class="ot">_</span>⦆ <span class="ot">:</span> A <span class="ot">→</span> List A <span class="ot">→</span> A</a>
<a class="sourceLine" id="cb4-28" data-line-number="28">  ⦅ x , xs ⦆ <span class="ot">=</span> ⟦ foldr <span class="ot">_</span>⊛<span class="ot">_</span> ⟦ x ⟧↑ xs ⟧↓</a></code></pre></div>
<p>Alternatively, we can get <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math> cons with the skew array:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">5</span> <span class="ot">_</span>⊛<span class="ot">_</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="ot">_</span>⊛<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">→</span> Tree A <span class="ot">→</span> Tree A</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">x ⊛ 2^ n × y  + ⟨⟩ <span class="ot">=</span> 2^ <span class="dv">0</span> × x + ⟨ 2^ n × y + ⟨⟩ ⟩</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">x ⊛ 2^ n × y₁ + ⟨ 2^ <span class="dv">0</span>     × y₂ + ys ⟩ <span class="ot">=</span> 2^ suc n × <span class="ot">(</span>x * <span class="ot">(</span>y₁ * y₂<span class="ot">))</span> + ys</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">x ⊛ 2^ n × y₁ + ⟨ 2^ suc m × y₂ + ys ⟩ <span class="ot">=</span> 2^ <span class="dv">0</span> × x + ⟨ 2^ n × y₁ + ⟨ 2^ m × y₂ + ys ⟩ ⟩</a></code></pre></div>
<p>Using this, a proper and efficient merge sort is very straightforward:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">data</span> Total <span class="ot">{</span>a r<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">(_</span>≤<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">→</span> A <span class="ot">→</span> <span class="dt">Set</span> r<span class="ot">)</span> <span class="ot">(</span>x y <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">(</span>a ⊔ r<span class="ot">)</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  x≤y <span class="ot">:</span> ⦃ <span class="ot">_</span> <span class="ot">:</span> x ≤ y ⦄ <span class="ot">→</span> Total <span class="ot">_</span>≤<span class="ot">_</span> x y</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  y≤x <span class="ot">:</span> ⦃ <span class="ot">_</span> <span class="ot">:</span> y ≤ x ⦄ <span class="ot">→</span> Total <span class="ot">_</span>≤<span class="ot">_</span> x y</a>
<a class="sourceLine" id="cb6-4" data-line-number="4"></a>
<a class="sourceLine" id="cb6-5" data-line-number="5"><span class="kw">module</span> Sorting <span class="ot">{</span>a r<span class="ot">}</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">               <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span></a>
<a class="sourceLine" id="cb6-7" data-line-number="7">               <span class="ot">{_</span>≤<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">→</span> A <span class="ot">→</span> <span class="dt">Set</span> r<span class="ot">}</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">               <span class="ot">(_</span>≤?<span class="ot">_</span> <span class="ot">:</span> <span class="ot">∀</span> x y <span class="ot">→</span> Total <span class="ot">_</span>≤<span class="ot">_</span> x y<span class="ot">)</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-9" data-line-number="9">  <span class="kw">data</span> [∙] <span class="ot">:</span> <span class="dt">Set</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-10" data-line-number="10">    ⊥   <span class="ot">:</span> [∙]</a>
<a class="sourceLine" id="cb6-11" data-line-number="11">    [<span class="ot">_</span>] <span class="ot">:</span> A <span class="ot">→</span> [∙]</a>
<a class="sourceLine" id="cb6-12" data-line-number="12"></a>
<a class="sourceLine" id="cb6-13" data-line-number="13">  <span class="kw">data</span> <span class="ot">_</span>≥<span class="ot">_</span> <span class="ot">(</span>x <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">:</span> [∙] <span class="ot">→</span> <span class="dt">Set</span> <span class="ot">(</span>a ⊔ r<span class="ot">)</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-14" data-line-number="14">    instance ⌈<span class="ot">_</span>⌉ <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>y<span class="ot">}</span> <span class="ot">→</span> y ≤ x <span class="ot">→</span> x ≥ [ y ]</a>
<a class="sourceLine" id="cb6-15" data-line-number="15">    instance ⌊⊥⌋ <span class="ot">:</span> x ≥ ⊥</a>
<a class="sourceLine" id="cb6-16" data-line-number="16"></a>
<a class="sourceLine" id="cb6-17" data-line-number="17">  <span class="kw">infixr</span> <span class="dv">5</span> <span class="ot">_</span>∷<span class="ot">_</span></a>
<a class="sourceLine" id="cb6-18" data-line-number="18">  <span class="kw">data</span> Ordered <span class="ot">(</span>b <span class="ot">:</span> [∙]<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">(</span>a ⊔ r<span class="ot">)</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-19" data-line-number="19">    []  <span class="ot">:</span> Ordered b</a>
<a class="sourceLine" id="cb6-20" data-line-number="20">    <span class="ot">_</span>∷<span class="ot">_</span> <span class="ot">:</span> <span class="ot">∀</span> x <span class="ot">→</span> ⦃ x≥b <span class="ot">:</span> x ≥ b ⦄ <span class="ot">→</span> <span class="ot">(</span>xs <span class="ot">:</span> Ordered [ x ]<span class="ot">)</span> <span class="ot">→</span> Ordered b</a>
<a class="sourceLine" id="cb6-21" data-line-number="21"></a>
<a class="sourceLine" id="cb6-22" data-line-number="22">  <span class="ot">_</span>∪<span class="ot">_</span> <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>b<span class="ot">}</span> <span class="ot">→</span> Ordered b <span class="ot">→</span> Ordered b <span class="ot">→</span> Ordered b</a>
<a class="sourceLine" id="cb6-23" data-line-number="23">  [] ∪ ys <span class="ot">=</span> ys</a>
<a class="sourceLine" id="cb6-24" data-line-number="24">  <span class="ot">(</span>x ∷ xs<span class="ot">)</span> ∪ ys <span class="ot">=</span> ⟅ x ∹ xs ∪ ys ⟆</a>
<a class="sourceLine" id="cb6-25" data-line-number="25">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-26" data-line-number="26">    ⟅<span class="ot">_</span>∹<span class="ot">_</span>∪<span class="ot">_</span>⟆ <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>b<span class="ot">}</span> <span class="ot">→</span> <span class="ot">∀</span> x ⦃ <span class="ot">_</span> <span class="ot">:</span> x ≥ b ⦄ <span class="ot">→</span> Ordered [ x ] <span class="ot">→</span> Ordered b <span class="ot">→</span> Ordered b</a>
<a class="sourceLine" id="cb6-27" data-line-number="27">    ⟅<span class="ot">_</span>∪<span class="ot">_</span>∹<span class="ot">_</span>⟆ <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>b<span class="ot">}</span> <span class="ot">→</span> Ordered b <span class="ot">→</span> <span class="ot">∀</span> y ⦃ <span class="ot">_</span> <span class="ot">:</span> y ≥ b ⦄ <span class="ot">→</span> Ordered [ y ] <span class="ot">→</span> Ordered b</a>
<a class="sourceLine" id="cb6-28" data-line-number="28">    merge <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>b<span class="ot">}</span> x y ⦃ <span class="ot">_</span> <span class="ot">:</span> x ≥ b ⦄ ⦃ <span class="ot">_</span> <span class="ot">:</span> y ≥ b ⦄</a>
<a class="sourceLine" id="cb6-29" data-line-number="29">          <span class="ot">→</span> Total <span class="ot">_</span>≤<span class="ot">_</span> x y</a>
<a class="sourceLine" id="cb6-30" data-line-number="30">          <span class="ot">→</span> Ordered [ x ]</a>
<a class="sourceLine" id="cb6-31" data-line-number="31">          <span class="ot">→</span> Ordered [ y ]</a>
<a class="sourceLine" id="cb6-32" data-line-number="32">          <span class="ot">→</span> Ordered b</a>
<a class="sourceLine" id="cb6-33" data-line-number="33"></a>
<a class="sourceLine" id="cb6-34" data-line-number="34">    ⟅ x ∹ xs ∪ [] ⟆ <span class="ot">=</span> x ∷ xs</a>
<a class="sourceLine" id="cb6-35" data-line-number="35">    ⟅ x ∹ xs ∪ y ∷ ys ⟆ <span class="ot">=</span> merge x y <span class="ot">(</span>x ≤? y<span class="ot">)</span> xs ys</a>
<a class="sourceLine" id="cb6-36" data-line-number="36">    ⟅ [] ∪ y ∹ ys ⟆ <span class="ot">=</span> y ∷ ys</a>
<a class="sourceLine" id="cb6-37" data-line-number="37">    ⟅ x ∷ xs ∪ y ∹ ys ⟆ <span class="ot">=</span> merge x y <span class="ot">(</span>x ≤? y<span class="ot">)</span> xs ys</a>
<a class="sourceLine" id="cb6-38" data-line-number="38"></a>
<a class="sourceLine" id="cb6-39" data-line-number="39">    merge x y x≤y xs ys <span class="ot">=</span> x ∷ ⟅ xs ∪ y ∹ ys ⟆</a>
<a class="sourceLine" id="cb6-40" data-line-number="40">    merge x y y≤x xs ys <span class="ot">=</span> y ∷ ⟅ x ∹ xs ∪ ys ⟆</a>
<a class="sourceLine" id="cb6-41" data-line-number="41"></a>
<a class="sourceLine" id="cb6-42" data-line-number="42"></a>
<a class="sourceLine" id="cb6-43" data-line-number="43">  <span class="kw">open</span> TreeFold</a>
<a class="sourceLine" id="cb6-44" data-line-number="44"></a>
<a class="sourceLine" id="cb6-45" data-line-number="45">  sort <span class="ot">:</span> List A <span class="ot">→</span> Ordered ⊥</a>
<a class="sourceLine" id="cb6-46" data-line-number="46">  sort <span class="ot">=</span> ⦅ <span class="ot">_</span>∪<span class="ot">_</span> , [] ⦆ ∘ map <span class="ot">(_</span>∷ []<span class="ot">)</span></a></code></pre></div>
<h1 id="validity">Validity</h1>
<p>It would be nice if we could verify these optimizated versions of folds. Luckily, by writing them using <code>foldr</code>, we’ve stumbled into well-trodden ground: the <em>foldr fusion law</em>. It states that if you have some transformation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>, and two binary operators <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>⊕</mo><annotation encoding="application/x-tex">\oplus</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>⊗</mo><annotation encoding="application/x-tex">\otimes</annotation></semantics></math>, then:</p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right"><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>⊕</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="left"></mtd><mtd columnalign="right"><mo>=</mo><mspace width="0.278em"></mspace></mtd><mtd columnalign="left"><mi>x</mi><mo>⊗</mo><mi>f</mi><mi>y</mi></mtd></mtr><mtr><mtd columnalign="right"><mo>⟹</mo><mi>f</mi><mo>∘</mo><mtext mathvariant="normal">foldr</mtext><mo>⊕</mo><mi>e</mi></mtd><mtd columnalign="left"></mtd><mtd columnalign="right"><mo>=</mo><mspace width="0.278em"></mspace></mtd><mtd columnalign="left"><mtext mathvariant="normal">foldr</mtext><mo>⊗</mo><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mi>e</mi><mo stretchy="false" form="postfix">)</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align}
   f (x \oplus y)                         &amp;&amp;=\;&amp; x \otimes f y \\
   \implies f \circ \text{foldr} \oplus e &amp;&amp;=\;&amp; \text{foldr} \otimes (f e)
\end{align}</annotation></semantics></math>
<p>This fits right in with the function we used above. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> is <code>⟦_⟧↓</code>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>⊕</mo><annotation encoding="application/x-tex">\oplus</annotation></semantics></math> is <code>_⊛_</code>, and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>⊗</mo><annotation encoding="application/x-tex">\otimes</annotation></semantics></math> is whatever combining function was passed in. Let’s prove the foldr fusion law, then, before we go any further.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">module</span> Proofs</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  <span class="ot">{</span>a r<span class="ot">}</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">  <span class="ot">{</span>R <span class="ot">:</span> Rel A r<span class="ot">}</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6"></a>
<a class="sourceLine" id="cb7-7" data-line-number="7">  <span class="kw">infix</span> <span class="dv">4</span> <span class="ot">_</span>≈<span class="ot">_</span></a>
<a class="sourceLine" id="cb7-8" data-line-number="8">  <span class="ot">_</span>≈<span class="ot">_</span> <span class="ot">=</span> R</a>
<a class="sourceLine" id="cb7-9" data-line-number="9"></a>
<a class="sourceLine" id="cb7-10" data-line-number="10">  <span class="kw">open</span> <span class="kw">import</span> Algebra<span class="ot">.</span>FunctionProperties <span class="ot">_</span>≈<span class="ot">_</span></a>
<a class="sourceLine" id="cb7-11" data-line-number="11"></a>
<a class="sourceLine" id="cb7-12" data-line-number="12">  foldr-universal <span class="ot">:</span> Transitive <span class="ot">_</span>≈<span class="ot">_</span></a>
<a class="sourceLine" id="cb7-13" data-line-number="13">                  <span class="ot">→</span> <span class="ot">∀</span> <span class="ot">{</span>b<span class="ot">}</span> <span class="ot">{</span>B <span class="ot">:</span> <span class="dt">Set</span> b<span class="ot">}</span> <span class="ot">(</span>h <span class="ot">:</span> List B <span class="ot">→</span> A<span class="ot">)</span> f e</a>
<a class="sourceLine" id="cb7-14" data-line-number="14">                  <span class="ot">→</span> ∀[ f ⊢ Congruent₁ ]</a>
<a class="sourceLine" id="cb7-15" data-line-number="15">                  <span class="ot">→</span> <span class="ot">(</span>h [] ≈ e<span class="ot">)</span></a>
<a class="sourceLine" id="cb7-16" data-line-number="16">                  <span class="ot">→</span> <span class="ot">(∀</span> x xs <span class="ot">→</span> h <span class="ot">(</span>x ∷ xs<span class="ot">)</span> ≈ f x <span class="ot">(</span>h xs<span class="ot">))</span></a>
<a class="sourceLine" id="cb7-17" data-line-number="17">                  <span class="ot">→</span> <span class="ot">∀</span> xs <span class="ot">→</span> h xs ≈ foldr f e xs</a>
<a class="sourceLine" id="cb7-18" data-line-number="18">  foldr-universal <span class="ot">_</span>○<span class="ot">_</span> h f e f⟨<span class="ot">_</span>⟩ ⇒[] ⇒<span class="ot">_</span>∷<span class="ot">_</span> [] <span class="ot">=</span> ⇒[]</a>
<a class="sourceLine" id="cb7-19" data-line-number="19">  foldr-universal <span class="ot">_</span>○<span class="ot">_</span> h f e f⟨<span class="ot">_</span>⟩ ⇒[] ⇒<span class="ot">_</span>∷<span class="ot">_</span> <span class="ot">(</span>x ∷ xs<span class="ot">)</span> <span class="ot">=</span></a>
<a class="sourceLine" id="cb7-20" data-line-number="20">    <span class="ot">(</span>⇒ x ∷ xs<span class="ot">)</span> ○ f⟨ foldr-universal <span class="ot">_</span>○<span class="ot">_</span> h f e f⟨<span class="ot">_</span>⟩ ⇒[] ⇒<span class="ot">_</span>∷<span class="ot">_</span> xs ⟩</a>
<a class="sourceLine" id="cb7-21" data-line-number="21"></a>
<a class="sourceLine" id="cb7-22" data-line-number="22">  foldr-fusion <span class="ot">:</span> Transitive <span class="ot">_</span>≈<span class="ot">_</span></a>
<a class="sourceLine" id="cb7-23" data-line-number="23">               <span class="ot">→</span> Reflexive <span class="ot">_</span>≈<span class="ot">_</span></a>
<a class="sourceLine" id="cb7-24" data-line-number="24">               <span class="ot">→</span> <span class="ot">∀</span> <span class="ot">{</span>b c<span class="ot">}</span> <span class="ot">{</span>B <span class="ot">:</span> <span class="dt">Set</span> b<span class="ot">}</span> <span class="ot">{</span>C <span class="ot">:</span> <span class="dt">Set</span> c<span class="ot">}</span> <span class="ot">(</span>f <span class="ot">:</span> C <span class="ot">→</span> A<span class="ot">)</span> <span class="ot">{_</span>⊕<span class="ot">_</span> <span class="ot">:</span> B <span class="ot">→</span> C <span class="ot">→</span> C<span class="ot">}</span> <span class="ot">{_</span>⊗<span class="ot">_</span> <span class="ot">:</span> B <span class="ot">→</span> A <span class="ot">→</span> A<span class="ot">}</span> e</a>
<a class="sourceLine" id="cb7-25" data-line-number="25">               <span class="ot">→</span> ∀[ <span class="ot">_</span>⊗<span class="ot">_</span> ⊢ Congruent₁ ]</a>
<a class="sourceLine" id="cb7-26" data-line-number="26">               <span class="ot">→</span> <span class="ot">(∀</span> x y <span class="ot">→</span> f <span class="ot">(</span>x ⊕ y<span class="ot">)</span> ≈ x ⊗ f y<span class="ot">)</span></a>
<a class="sourceLine" id="cb7-27" data-line-number="27">               <span class="ot">→</span> <span class="ot">∀</span> xs <span class="ot">→</span> f <span class="ot">(</span>foldr <span class="ot">_</span>⊕<span class="ot">_</span> e xs<span class="ot">)</span> ≈ foldr <span class="ot">_</span>⊗<span class="ot">_</span> <span class="ot">(</span>f e<span class="ot">)</span> xs</a>
<a class="sourceLine" id="cb7-28" data-line-number="28">  foldr-fusion <span class="ot">_</span>○<span class="ot">_</span> ∎ h <span class="ot">{</span>f<span class="ot">}</span> <span class="ot">{</span>g<span class="ot">}</span> e g⟨<span class="ot">_</span>⟩ fuse <span class="ot">=</span></a>
<a class="sourceLine" id="cb7-29" data-line-number="29">    foldr-universal <span class="ot">_</span>○<span class="ot">_</span> <span class="ot">(</span>h ∘ foldr f e<span class="ot">)</span> g <span class="ot">(</span>h e<span class="ot">)</span> g⟨<span class="ot">_</span>⟩ ∎ <span class="ot">(λ</span> x xs <span class="ot">→</span> fuse x <span class="ot">(</span>foldr f e xs<span class="ot">))</span></a></code></pre></div>
<p>We’re not using the proofs in Agda’s standard library because these are tied to propositional equality. In other words, instead of using an abstract binary relation, they prove things over <em>actual</em> equality. That’s all well and good, but as you can see above, we don’t need propositional equality: we don’t even need the relation to be an equivalence, we just need transitivity and reflexivity.</p>
<p>After that, we can state precisely what correspondence the tree fold has, and under what conditions it does the same things as a fold:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">module</span> <span class="ot">_</span> <span class="ot">{_</span>*<span class="ot">_</span> <span class="ot">:</span> A <span class="ot">→</span> A <span class="ot">→</span> A<span class="ot">}</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  <span class="kw">open</span> TreeFold <span class="ot">_</span>*<span class="ot">_</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3"></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">  treeFoldHom <span class="ot">:</span> Transitive <span class="ot">_</span>≈<span class="ot">_</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5">              <span class="ot">→</span> Reflexive <span class="ot">_</span>≈<span class="ot">_</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">              <span class="ot">→</span> Associative <span class="ot">_</span>*<span class="ot">_</span></a>
<a class="sourceLine" id="cb8-7" data-line-number="7">              <span class="ot">→</span> RightCongruent <span class="ot">_</span>*<span class="ot">_</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8">              <span class="ot">→</span> <span class="ot">∀</span> x xs</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">              <span class="ot">→</span> ⦅ x , xs ⦆ ≈ foldr <span class="ot">_</span>*<span class="ot">_</span> x xs</a>
<a class="sourceLine" id="cb8-10" data-line-number="10">  treeFoldHom <span class="ot">_</span>○<span class="ot">_</span> ∎ assoc *⟨<span class="ot">_</span>⟩ b <span class="ot">=</span> foldr-fusion <span class="ot">_</span>○<span class="ot">_</span> ∎ ⟦<span class="ot">_</span>⟧↓ ⟦ b ⟧↑ *⟨<span class="ot">_</span>⟩ <span class="ot">(</span>⊛-hom zero<span class="ot">)</span></a>
<a class="sourceLine" id="cb8-11" data-line-number="11">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-12" data-line-number="12">    ⊛-hom <span class="ot">:</span> <span class="ot">∀</span> n x xs <span class="ot">→</span> ⟦ 2^ n × x ⊛ xs ⟧↓ ≈ x * ⟦ xs ⟧↓</a>
<a class="sourceLine" id="cb8-13" data-line-number="13">    ⊛-hom n x <span class="ot">(</span>2^ suc m × y + ⟨⟩    <span class="ot">)</span> <span class="ot">=</span> ∎</a>
<a class="sourceLine" id="cb8-14" data-line-number="14">    ⊛-hom n x <span class="ot">(</span>2^ suc m × y + ⟨ ys ⟩<span class="ot">)</span> <span class="ot">=</span> ∎</a>
<a class="sourceLine" id="cb8-15" data-line-number="15">    ⊛-hom n x <span class="ot">(</span>2^ zero  × y + ⟨⟩    <span class="ot">)</span> <span class="ot">=</span> ∎</a>
<a class="sourceLine" id="cb8-16" data-line-number="16">    ⊛-hom n x <span class="ot">(</span>2^ zero  × y + ⟨ ys ⟩<span class="ot">)</span> <span class="ot">=</span> ⊛-hom <span class="ot">(</span>suc n<span class="ot">)</span> <span class="ot">(</span>x * y<span class="ot">)</span> ys ○ assoc x y ⟦ ys ⟧↓</a></code></pre></div>
<h1 id="implicit-data-structures">“Implicit” Data Structures</h1>
<p>Consider the following implementation of the tree above in Haskell:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Tree</span> a <span class="fu">=</span> [(<span class="dt">Int</span>,a)]</a>
<a class="sourceLine" id="cb9-2" data-line-number="2"></a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="ot">cons ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">cons (<span class="fu">*</span>) <span class="fu">=</span> cons&#39; <span class="dv">0</span> </a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6">    cons&#39; n x [] <span class="fu">=</span> [(n,x)]</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">    cons&#39; n x ((<span class="dv">0</span>,y)<span class="fu">:</span>ys) <span class="fu">=</span> cons&#39; (n<span class="fu">+</span><span class="dv">1</span>) (x <span class="fu">*</span> y) ys</a>
<a class="sourceLine" id="cb9-8" data-line-number="8">    cons&#39; n x ((m,y)<span class="fu">:</span>ys) <span class="fu">=</span> (n,x) <span class="fu">:</span> (m<span class="fu">-</span><span class="dv">1</span>,y) <span class="fu">:</span> ys</a></code></pre></div>
<p>The <code>cons</code> function “increments” that list as if it were the bits of a binary number. Now, consider using the <code>merge</code> function from above, in a pattern like this:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">f <span class="fu">=</span> foldr (cons merge <span class="fu">.</span> pure) []</a></code></pre></div>
<p>What does <code>f</code> build? A list of lists, right?</p>
<p>Kind of. That’s what’s built in terms of the observable, but what’s actually stored in memory us a bunch of thunks. The shape of <em>those</em> is what I’m interested in. We can try and see what they look like by using a data structure that doesn’t force on merge:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a <span class="fu">=</span> <span class="dt">Leaf</span> a <span class="fu">|</span> <span class="dt">Tree</span> a <span class="fu">:*:</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb11-2" data-line-number="2"></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">f <span class="fu">=</span> foldr (cons (<span class="fu">:*:</span>) <span class="fu">.</span> <span class="dt">Leaf</span>) []</a></code></pre></div>
<p>Using a handy tree-drawing function, we can see what <code>f [1..13]</code> looks like:</p>
<pre><code>[(0,*),(1,*),(0,*)]
    └1    │ ┌2  │  ┌6
          │┌┤   │ ┌┤
          ││└3  │ │└7
          └┤    │┌┤
           │┌4  │││┌8
           └┤   ││└┤
            └5  ││ └9
                └┤
                 │ ┌10
                 │┌┤
                 ││└11
                 └┤
                  │┌12
                  └┤
                   └13</code></pre>
<p>It’s a binomial heap! It’s a list of trees, each one contains <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mi>n</mi></msup><annotation encoding="application/x-tex">2^n</annotation></semantics></math> elements. But they’re not in heap order, you say? Well, as a matter of fact, they <em>are</em>. It just hasn’t been evaluated yet. Once we force—say—the first element, the rest will shuffle themselves into a tree of thunks.</p>
<p>This illustrates a pretty interesting similarity between binomial heaps and merge sort. Performance-wise, though, there’s another interesting property: the thunks <em>stay thunked</em>. In other words, if we do a merge sort via:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1">sort <span class="fu">=</span> foldr (merge <span class="fu">.</span> snd) [] <span class="fu">.</span> foldr (cons merge <span class="fu">.</span> pure) []</a></code></pre></div>
<p>We could instead freeze the fold, and look at it at every point:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1">sortPrefixes <span class="fu">=</span> map (foldr (merge <span class="fu">.</span> snd) []) <span class="fu">.</span> scanl (flip (cons merge <span class="fu">.</span> pure)) []</a>
<a class="sourceLine" id="cb14-2" data-line-number="2"><span class="fu">&gt;&gt;&gt;</span> [[],[<span class="dv">1</span>],[<span class="dv">1</span>,<span class="dv">4</span>],[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">4</span>],[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>],[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>]]</a></code></pre></div>
<p>And <code>sortPrefixes</code> is only <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n^2)</annotation></semantics></math> (rather than <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n^2 \log n)</annotation></semantics></math>). I confess I don’t know of a use for sorted prefixes, but it should illustrate the general idea: we get a pretty decent batching of operations, with the ability to freeze at any point in time. The other nice property (which I mentioned in the last post) is that any of the tree folds are extremely parallel.</p>
<h1 id="random-shuffles">Random Shuffles</h1>
<p><a href="http://okmij.org/ftp/Haskell/AlgorithmsH.html#perfect-shuffle">There’s a great article on shuffling in Haskell</a> which provides an <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n \log n)</annotation></semantics></math> implementation of a perfect random shuffle. Unfortunately, the <a href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle">Fisher-Yates shuffle</a> isn’t applicable in a pure functional setting, so you have to be a little cleverer.</p>
<p>The first implementation most people jump to (certainly the one I thought of) is to assign everything in the sequence a random number, and then sort according to that number. Perhaps surprisingly, this <em>isn’t</em> perfectly random! It’s a little weird, but the example in the article explains it well: basically, for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> elements, your random numbers will have <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>n</mi><mi>n</mi></msup><annotation encoding="application/x-tex">n^n</annotation></semantics></math> possible values, but the output of the sort will have <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>!</mi></mrow><annotation encoding="application/x-tex">n!</annotation></semantics></math> possible values. Since they don’t divide into each other evenly, you’re going to have some extra weight on some permutations, and less on others.</p>
<p>Instead, we can generate a random <a href="https://en.wikipedia.org/wiki/Factorial_number_system"><em>factoradic</em></a> number. A factoradic number is one where the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>th digit is in base <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>. Because of this, a factoradic number with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> digits has <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>!</mi></mrow><annotation encoding="application/x-tex">n!</annotation></semantics></math> possible values: exactly what we want.</p>
<p>In the article, the digits of the number are used to pop values from a binary tree. Because the last digit will have <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> possible values, and the second last <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math>, and so on, you can keep popping without hitting an empty tree.</p>
<p>This has the correct time complexity—<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n \log n)</annotation></semantics></math>—but there’s a lot of overhead. Building the tree, then indexing into it, the rebuilding after each pop, etc.</p>
<p>We’d <em>like</em> to just sort the list, according to the indices. The problem is that the indices are relative: if you want to <code>cons</code> something onto the list, you have to increment the rest of the indices, as they’ve all shifted right by one.</p>
<p>What we’ll do instead is use the indices as <em>gaps</em>. Our merge function looks like the following:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1">merge [] ys <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">merge xs [] <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">merge ((x,i)<span class="fu">:</span>xs) ((y,j)<span class="fu">:</span>ys)</a>
<a class="sourceLine" id="cb15-4" data-line-number="4">  <span class="fu">|</span> i <span class="fu">&lt;=</span> j    <span class="fu">=</span> (x,i) <span class="fu">:</span> merge xs ((y,j<span class="fu">-</span>i)<span class="fu">:</span>ys)</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">  <span class="fu">|</span> otherwise <span class="fu">=</span> (y,j) <span class="fu">:</span> merge ((x,i<span class="fu">-</span>j<span class="fu">-</span><span class="dv">1</span>)<span class="fu">:</span>xs) ys</a></code></pre></div>
<p>With that, and the same <code>cons</code> as above, we get a very simple random shuffle algorithm:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1">shuffle xs <span class="fu">=</span> map fst</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">           <span class="fu">.</span> foldr (merge <span class="fu">.</span> snd) []</a>
<a class="sourceLine" id="cb16-3" data-line-number="3">           <span class="fu">.</span> foldr f (const []) xs</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-5" data-line-number="5">    f x xs (i<span class="fu">:</span>is) <span class="fu">=</span> cons merge [(x,i)] (xs is)</a></code></pre></div>
<p>The other interesting thing about this algorithm is that it can use Peano numbers with taking too much of a performance hit:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1">merge <span class="fu">:</span> <span class="ot">∀</span> {a} {<span class="dt">A</span> <span class="fu">:</span> <span class="dt">Set</span> a} <span class="ot">→</span> <span class="dt">List</span> (<span class="dt">A</span> × ℕ) <span class="ot">→</span> <span class="dt">List</span> (<span class="dt">A</span> × ℕ) <span class="ot">→</span> <span class="dt">List</span> (<span class="dt">A</span> × ℕ)</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">merge xs [] <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb17-3" data-line-number="3">merge {<span class="dt">A</span> <span class="fu">=</span> <span class="dt">A</span>} xs ((y , j) <span class="ot">∷</span> ys) <span class="fu">=</span> go<span class="fu">-</span>r xs y j ys</a>
<a class="sourceLine" id="cb17-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb17-5" data-line-number="5">  go<span class="fu">-</span>l <span class="fu">:</span> <span class="dt">A</span> <span class="ot">→</span> ℕ <span class="ot">→</span> <span class="dt">List</span> (<span class="dt">A</span> × ℕ) <span class="ot">→</span> <span class="dt">List</span> (<span class="dt">A</span> × ℕ) <span class="ot">→</span> <span class="dt">List</span> (<span class="dt">A</span> × ℕ)</a>
<a class="sourceLine" id="cb17-6" data-line-number="6">  go<span class="fu">-</span>r <span class="fu">:</span> <span class="dt">List</span> (<span class="dt">A</span> × ℕ) <span class="ot">→</span> <span class="dt">A</span> <span class="ot">→</span> ℕ <span class="ot">→</span> <span class="dt">List</span> (<span class="dt">A</span> × ℕ) <span class="ot">→</span> <span class="dt">List</span> (<span class="dt">A</span> × ℕ)</a>
<a class="sourceLine" id="cb17-7" data-line-number="7">  go <span class="fu">:</span> ℕ <span class="ot">→</span> ℕ <span class="ot">→</span> <span class="dt">A</span> <span class="ot">→</span> ℕ <span class="ot">→</span> <span class="dt">List</span> (<span class="dt">A</span> × ℕ) <span class="ot">→</span> <span class="dt">A</span> <span class="ot">→</span> ℕ <span class="ot">→</span> <span class="dt">List</span> (<span class="dt">A</span> × ℕ) <span class="ot">→</span> <span class="dt">List</span> (<span class="dt">A</span> × ℕ)</a>
<a class="sourceLine" id="cb17-8" data-line-number="8"></a>
<a class="sourceLine" id="cb17-9" data-line-number="9">  go i     zero   x i′ xs y j′ ys <span class="fu">=</span> (y , j′) <span class="ot">∷</span> go<span class="fu">-</span>l x i xs ys</a>
<a class="sourceLine" id="cb17-10" data-line-number="10">  go zero (suc j) x i′ xs y j′ ys <span class="fu">=</span> (x , i′) <span class="ot">∷</span> go<span class="fu">-</span>r xs y j ys</a>
<a class="sourceLine" id="cb17-11" data-line-number="11">  go (suc i) (suc j) <span class="fu">=</span> go i j</a>
<a class="sourceLine" id="cb17-12" data-line-number="12"></a>
<a class="sourceLine" id="cb17-13" data-line-number="13">  go<span class="fu">-</span>l x i xs [] <span class="fu">=</span> (x , i) <span class="ot">∷</span> xs</a>
<a class="sourceLine" id="cb17-14" data-line-number="14">  go<span class="fu">-</span>l x i xs ((y , j) <span class="ot">∷</span> ys) <span class="fu">=</span> go i j x i xs y j ys</a>
<a class="sourceLine" id="cb17-15" data-line-number="15"></a>
<a class="sourceLine" id="cb17-16" data-line-number="16">  go<span class="fu">-</span>r [] y j ys <span class="fu">=</span> (y , j) <span class="ot">∷</span> ys</a>
<a class="sourceLine" id="cb17-17" data-line-number="17">  go<span class="fu">-</span>r ((x , i) <span class="ot">∷</span> xs) y j ys <span class="fu">=</span> go i j x i xs y j ys</a>
<a class="sourceLine" id="cb17-18" data-line-number="18"></a>
<a class="sourceLine" id="cb17-19" data-line-number="19">shuffle <span class="fu">:</span> <span class="ot">∀</span> {a} {<span class="dt">A</span> <span class="fu">:</span> <span class="dt">Set</span> a} <span class="ot">→</span> <span class="dt">List</span> <span class="dt">A</span> <span class="ot">→</span> <span class="dt">List</span> ℕ <span class="ot">→</span> <span class="dt">List</span> <span class="dt">A</span></a>
<a class="sourceLine" id="cb17-20" data-line-number="20">shuffle {a} {<span class="dt">A</span>} xs i <span class="fu">=</span> map proj₁ (⦅ [] , zip<span class="fu">-</span>inds xs i ⦆)</a>
<a class="sourceLine" id="cb17-21" data-line-number="21">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb17-22" data-line-number="22">  open <span class="dt">TreeFold</span> {a} {<span class="dt">List</span> (<span class="dt">A</span> × ℕ)} merge</a>
<a class="sourceLine" id="cb17-23" data-line-number="23"></a>
<a class="sourceLine" id="cb17-24" data-line-number="24">  zip<span class="fu">-</span>inds <span class="fu">:</span> <span class="dt">List</span> <span class="dt">A</span> <span class="ot">→</span> <span class="dt">List</span> ℕ <span class="ot">→</span> <span class="dt">List</span> (<span class="dt">List</span> (<span class="dt">A</span> × ℕ))</a>
<a class="sourceLine" id="cb17-25" data-line-number="25">  zip<span class="fu">-</span>inds [] inds <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb17-26" data-line-number="26">  zip<span class="fu">-</span>inds (x <span class="ot">∷</span> xs) [] <span class="fu">=</span> ((x , <span class="dv">0</span>) <span class="ot">∷</span> []) <span class="ot">∷</span> zip<span class="fu">-</span>inds xs []</a>
<a class="sourceLine" id="cb17-27" data-line-number="27">  zip<span class="fu">-</span>inds (x <span class="ot">∷</span> xs) (i <span class="ot">∷</span> inds) <span class="fu">=</span> ((x , i) <span class="ot">∷</span> []) <span class="ot">∷</span> zip<span class="fu">-</span>inds xs inds</a></code></pre></div>
<p>I don’t know exactly what the complexity of this is, but I <em>think</em> it should be better than the usual approach of popping from a vector.</p>
<h1 id="future-stuff">Future Stuff</h1>
<p>This is just a collection of random thoughts for now, but I intend to work on using these folds to see if there are any other algorithms they can be useful for. In particular, I think I can write a version of Data.List.permutations which benefits from sharing. And I’m interested in using the implicit binomial heap for some search problems.</p>
]]></description>
    <pubDate>Fri, 21 Dec 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-12-21-balancing-scans.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Pure and Lazy Breadth-First Traversals of Graphs in Haskell</title>
    <link>https://doisinkidney.com/posts/2018-12-18-traversing-graphs.html</link>
    <description><![CDATA[<div class="info">
    Posted on December 18, 2018
</div>
<div class="info">
    
        Part 5 of a <a href="/series/Breadth-First%20Traversals.html">7-part series on Breadth-First Traversals</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<p>Today, I’m going to look at extending the previous breadth-first traversal algorithms to arbitrary graphs (rather than just trees). Graphs with cycles are notoriously cumbersome in functional languages, so this actually proves to be a little trickier than I thought it would be. First, a quick recap.</p>
<h1 id="ways-to-breadth-first-search">3 Ways to Breadth-First Search</h1>
<p>So far, we have three major ways to traverse a tree in breadth-first order. The first is the simplest, and the fastest:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">bfe ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">bfe r <span class="fu">=</span> f r b []</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">    f (<span class="dt">Node</span> x xs) fw bw <span class="fu">=</span> x <span class="fu">:</span> fw (xs <span class="fu">:</span> bw)</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">  </a>
<a class="sourceLine" id="cb1-6" data-line-number="6">    b [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb1-7" data-line-number="7">    b qs <span class="fu">=</span> foldl (foldr f) b qs []</a></code></pre></div>
<p>Given a tree like the following:</p>
<pre><code>   ┌4
 ┌2┤
 │ │ ┌8
 │ └5┤
 │   └9
1┤
 │   ┌10
 │ ┌6┘
 └3┤
   └7</code></pre>
<p>We get:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> bfe tree</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>]</a></code></pre></div>
<p>It also demonstrates a theme that will run through this post: lists are the only <em>visible</em> data structure (other than the tree, of course). However, we are carefully batching the operations on those lists (the <code>foldl</code> is effectively a reverse) so that they have the same complexity as if we had used a queue. In actual fact, when lists are used this way, they <em>are</em> queues: “corecursive” ones <span class="citation" data-cites="allison_circular_2006 smith_lloyd_2009">(Allison <a href="#ref-allison_circular_2006">2006</a>; Smith <a href="#ref-smith_lloyd_2009">2009</a>)</span>.</p>
<p>The next two functions perform a breadth-first traversal “level-wise”: instead of just returning all the nodes of the tree, we get them delimited by how far they are from the root.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">lwe ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">lwe r <span class="fu">=</span> f b r [] []</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">    f k (<span class="dt">Node</span> x xs) ls qs <span class="fu">=</span> k (x <span class="fu">:</span> ls) (xs <span class="fu">:</span> qs)</a>
<a class="sourceLine" id="cb4-5" data-line-number="5"></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">    b _ [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb4-7" data-line-number="7">    b k qs <span class="fu">=</span> k <span class="fu">:</span> foldl (foldl f) b qs [] []</a>
<a class="sourceLine" id="cb4-8" data-line-number="8"></a>
<a class="sourceLine" id="cb4-9" data-line-number="9"><span class="fu">&gt;&gt;&gt;</span> lwe tree</a>
<a class="sourceLine" id="cb4-10" data-line-number="10">[[<span class="dv">1</span>],[<span class="dv">2</span>,<span class="dv">3</span>],[<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>],[<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>]]</a></code></pre></div>
<p>The above function is very clearly related to the <code>bfe</code> function: we just add another queue (representing the current level), and work from there.</p>
<p>The third of these functions also does level-wise enumeration, but in a direct style (without continuations).</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">lwe ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">lwe r <span class="fu">=</span> f r []</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">    f (<span class="dt">Node</span> x xs) (q<span class="fu">:</span>qs) <span class="fu">=</span> (x<span class="fu">:</span>q) <span class="fu">:</span> foldr f qs xs</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">    f (<span class="dt">Node</span> x xs) []     <span class="fu">=</span> [x]   <span class="fu">:</span> foldr f [] xs</a></code></pre></div>
<p>There are more techniques out there than just these three (including the one in <a href="http://hackage.haskell.org/package/containers-0.6.0.1/docs/Data-Tree.html#v:levels">Data.Tree</a>), but these are my favorite, and they’re what I’ll be looking at today.</p>
<h1 id="graphs-and-purity">Graphs and Purity</h1>
<p>Functional programming in general excels at working with trees and similar data structures. Graphs, though, are trickier. There’s been a lot of recent work in improving the situation <span class="citation" data-cites="mokhov_algebraic_2017">(Mokhov <a href="#ref-mokhov_algebraic_2017">2017</a>)</span>, but I’m going to keep it simple today: a graph is just a function.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Graph</span> a <span class="fu">=</span> a <span class="ot">-&gt;</span> [a]</a></code></pre></div>
<p>So the tree from above could be represented as:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1">graph <span class="dv">1</span> <span class="fu">=</span> [<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">graph <span class="dv">2</span> <span class="fu">=</span> [<span class="dv">4</span>,<span class="dv">5</span>]</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">graph <span class="dv">3</span> <span class="fu">=</span> [<span class="dv">6</span>,<span class="dv">7</span>]</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">graph <span class="dv">5</span> <span class="fu">=</span> [<span class="dv">8</span>,<span class="dv">9</span>]</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">graph <span class="dv">6</span> <span class="fu">=</span> [<span class="dv">10</span>]</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">graph _ <span class="fu">=</span> []</a></code></pre></div>
<p>As it happens, all of the algorithms that follow will work on graphs represented as rose trees (or represented any way, really).</p>
<p>So let’s fire up our first traversal!</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">bfs ::</span> <span class="dt">Graph</span> a <span class="ot">-&gt;</span> <span class="dt">Graph</span> a</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">bfs g r <span class="fu">=</span> f r b []</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">    f x fw bw <span class="fu">=</span> x <span class="fu">:</span> fw (g x <span class="fu">:</span> bw)</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">  </a>
<a class="sourceLine" id="cb8-6" data-line-number="6">    b [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">    b qs <span class="fu">=</span> foldl (foldr f) b qs []</a>
<a class="sourceLine" id="cb8-8" data-line-number="8">    </a>
<a class="sourceLine" id="cb8-9" data-line-number="9"><span class="fu">&gt;&gt;&gt;</span> bfs graph <span class="dv">1</span></a>
<a class="sourceLine" id="cb8-10" data-line-number="10">[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>]</a></code></pre></div>
<p>Unfortunately, this won’t handle cycles properly:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1">graph <span class="dv">1</span> <span class="fu">=</span> [<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">graph <span class="dv">2</span> <span class="fu">=</span> [<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">graph <span class="dv">3</span> <span class="fu">=</span> [<span class="dv">6</span>,<span class="dv">7</span>]</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">graph <span class="dv">5</span> <span class="fu">=</span> [<span class="dv">8</span>,<span class="dv">9</span>]</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">graph <span class="dv">6</span> <span class="fu">=</span> [<span class="dv">10</span>]</a>
<a class="sourceLine" id="cb9-6" data-line-number="6">graph _ <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb9-7" data-line-number="7"></a>
<a class="sourceLine" id="cb9-8" data-line-number="8"><span class="fu">&gt;&gt;&gt;</span> bfs graph <span class="dv">1</span></a>
<a class="sourceLine" id="cb9-9" data-line-number="9">[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">1</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">10</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">1</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">10</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">1</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">10</span>,<span class="dv">4</span>,<span class="dv">5</span><span class="fu">...</span></a></code></pre></div>
<p>We need a way to mark off what we’ve already seen. The following isn’t good enough, also:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> nub (bfs graph <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span><span class="fu">...</span></a></code></pre></div>
<p>It will hang without finishing the list. The solution is to mark off nodes as we find them, with some set structure:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">bfs ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Graph</span> a <span class="ot">-&gt;</span> <span class="dt">Graph</span> a</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">bfs g ts <span class="fu">=</span> f ts b [] Set.empty</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4">    f x fw bw s</a>
<a class="sourceLine" id="cb11-5" data-line-number="5">      <span class="fu">|</span> Set.member x s <span class="fu">=</span> fw bw s</a>
<a class="sourceLine" id="cb11-6" data-line-number="6">      <span class="fu">|</span> otherwise      <span class="fu">=</span> x <span class="fu">:</span> fw (g x <span class="fu">:</span> bw) (Set.insert x s)</a>
<a class="sourceLine" id="cb11-7" data-line-number="7"></a>
<a class="sourceLine" id="cb11-8" data-line-number="8">    b [] _ <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb11-9" data-line-number="9">    b qs s <span class="fu">=</span> foldl (foldr f) b qs [] s</a>
<a class="sourceLine" id="cb11-10" data-line-number="10"></a>
<a class="sourceLine" id="cb11-11" data-line-number="11"><span class="fu">&gt;&gt;&gt;</span> bfs graph <span class="dv">1</span></a>
<a class="sourceLine" id="cb11-12" data-line-number="12">[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>]</a></code></pre></div>
<p>The levelwise algorithm is similar:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="ot">lws ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Graph</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [[a]] </a>
<a class="sourceLine" id="cb12-2" data-line-number="2">lws g r <span class="fu">=</span> f b r [] [] Set.empty</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">    f k x ls qs s</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">      <span class="fu">|</span> Set.member x s <span class="fu">=</span> k ls qs s</a>
<a class="sourceLine" id="cb12-6" data-line-number="6">      <span class="fu">|</span> otherwise <span class="fu">=</span> k (x <span class="fu">:</span> ls) (g x <span class="fu">:</span> qs) (Set.insert x s)</a>
<a class="sourceLine" id="cb12-7" data-line-number="7"></a>
<a class="sourceLine" id="cb12-8" data-line-number="8">    b _ [] _ <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb12-9" data-line-number="9">    b k qs s <span class="fu">=</span> k <span class="fu">:</span> foldl (foldl f) b qs [] [] s</a></code></pre></div>
<h1 id="tying-the-knot">Tying the Knot</h1>
<p>The other levelwise algorithm <em>doesn’t</em> translate across so easily. To see why, let’s look at the version without cycle detection:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="ot">lws ::</span> <span class="dt">Graph</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">lws g r <span class="fu">=</span> f r []</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4">    f x (q<span class="fu">:</span>qs) <span class="fu">=</span> (x<span class="fu">:</span>q) <span class="fu">:</span> foldr f qs (g x)</a>
<a class="sourceLine" id="cb13-5" data-line-number="5">    f x []     <span class="fu">=</span> [x]   <span class="fu">:</span> foldr f [] (g x)</a></code></pre></div>
<p>The recursive call is being made <em>depth</em>-first, not breadth-first. The result, of course, is breadth-first, but that’s only because the recursive call zips as it goes.</p>
<p>Just looking at the fourth line for now:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1">f x (q<span class="fu">:</span>qs) <span class="fu">=</span> (x<span class="fu">:</span>q) <span class="fu">:</span> foldr f qs (g x)</a></code></pre></div>
<p>We want whatever process built up that <code>q</code> to be denied access to <code>x</code>. The following doesn’t work:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1">f x (q<span class="fu">:</span>qs) <span class="fu">=</span> (x<span class="fu">:</span>filter (x<span class="fu">/=</span>) q) <span class="fu">:</span> foldr f qs (g x)</a></code></pre></div>
<p>As well as being terribly slow, the later computation can diverge when it finds a cycle, and filtering won’t do anything to help that.</p>
<p>The solution is to “tie the knot”. We basically do two passes over the data: one to build up the “seen so far” list, and then another to do the actual search. The trick is to do both of these passes at once, and feed the result back into the demanding computation.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1">lws g r <span class="fu">=</span> takeWhile (not<span class="fu">.</span>null) (map fst (fix (f r <span class="fu">.</span> push)))</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3">    push xs <span class="fu">=</span> ([],Set.empty) <span class="fu">:</span> [ ([],seen) <span class="fu">|</span> (_,seen) <span class="ot">&lt;-</span> xs ]</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">    f x q<span class="fu">@</span>((l,s)<span class="fu">:</span>qs)</a>
<a class="sourceLine" id="cb16-5" data-line-number="5">      <span class="fu">|</span> Set.member x s <span class="fu">=</span> q</a>
<a class="sourceLine" id="cb16-6" data-line-number="6">      <span class="fu">|</span> otherwise <span class="fu">=</span> (x<span class="fu">:</span>l, Set.insert x s) <span class="fu">:</span> foldr f qs (g x)</a></code></pre></div>
<p>And it works!</p>
<p>I got the idea for this trick from the appendix of <span class="citation" data-cites="okasaki_breadth-first_2000">Okasaki (<a href="#ref-okasaki_breadth-first_2000">2000</a>)</span>. There’s something similar in <span class="citation" data-cites="kiselyov_pure-functional_2002">Kiselyov (<a href="#ref-kiselyov_pure-functional_2002">2002</a>)</span>.</p>
<hr />
<h1 id="references" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-allison_circular_2006">
<p>Allison, Lloyd. 2006. “Circular Programs and Self-Referential Structures.” <em>Software: Practice and Experience</em> 19 (2) (October): 99–109. doi:<a href="https://doi.org/10.1002/spe.4380190202">10.1002/spe.4380190202</a>.</p>
</div>
<div id="ref-kiselyov_pure-functional_2002">
<p>Kiselyov, Oleg. 2002. “Pure-functional transformations of cyclic graphs and the Credit Card Transform.” <a href="http://okmij.org/ftp/Haskell/AlgorithmsH.html#ccard-transform" class="uri">http://okmij.org/ftp/Haskell/AlgorithmsH.html#ccard-transform</a>.</p>
</div>
<div id="ref-mokhov_algebraic_2017">
<p>Mokhov, Andrey. 2017. “Algebraic Graphs with Class (Functional Pearl).” In <em>Proceedings of the 10th ACM SIGPLAN International Symposium on Haskell</em>, 2–13. Haskell 2017. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/3122955.3122956">10.1145/3122955.3122956</a>.</p>
</div>
<div id="ref-okasaki_breadth-first_2000">
<p>Okasaki, Chris. 2000. “Breadth-first Numbering: Lessons from a Small Exercise in Algorithm Design.” In <em>Proceedings of the Fifth ACM SIGPLAN International Conference on Functional Programming</em>, 131–136. ICFP ’00. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/351240.351253">10.1145/351240.351253</a>.</p>
</div>
<div id="ref-smith_lloyd_2009">
<p>Smith, Leon P. 2009. “Lloyd Allison’s Corecursive Queues: Why Continuations Matter.” <em>The Monad.Reader</em> 14 (14) (July): 28.</p>
</div>
</div>
]]></description>
    <pubDate>Tue, 18 Dec 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-12-18-traversing-graphs.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Prime Sieves in Agda</title>
    <link>https://doisinkidney.com/posts/2018-12-14-primes-in-agda.html</link>
    <description><![CDATA[<div class="info">
    Posted on December 14, 2018
</div>
<div class="info">
    
        Part 2 of a <a href="/series/Prime%20Sieves.html">2-part series on Prime Sieves</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Agda.html">Agda</a>
    
</div>

<p>Prime numbers in Agda are <em>slow</em>. First, they’re Peano-based, so a huge chunk of optimizations we might make in other languages are out of the window. Second, we really often want to <em>prove</em> that they’re prime, so the generation code has to carry verification logic with it (I won’t do that today, though). And third, as always in Agda, you have to convince the compiler of termination. With all of that in mind, let’s try and write a (very slow, very basic) prime sieve in Agda.</p>
<p>First, we can make an “array” of numbers that we cross off as we go.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb1-1" data-line-number="1">primes <span class="ot">:</span> <span class="ot">∀</span> n <span class="ot">→</span> List <span class="ot">(</span>Fin n<span class="ot">)</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">primes zero <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">primes <span class="ot">(</span>suc zero<span class="ot">)</span> <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">primes <span class="ot">(</span>suc <span class="ot">(</span>suc zero<span class="ot">))</span> <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">primes <span class="ot">(</span>suc <span class="ot">(</span>suc <span class="ot">(</span>suc m<span class="ot">)))</span> <span class="ot">=</span> sieve <span class="ot">(</span>tabulate <span class="ot">(</span>just ∘ Fin<span class="ot">.</span>suc<span class="ot">))</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">  cross-off <span class="ot">:</span> Fin <span class="ot">_</span> <span class="ot">→</span> List <span class="ot">(</span>Maybe <span class="ot">(</span>Fin <span class="ot">_))</span> <span class="ot">→</span> List <span class="ot">(</span>Maybe <span class="ot">(</span>Fin <span class="ot">_))</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"></a>
<a class="sourceLine" id="cb1-9" data-line-number="9">  sieve <span class="ot">:</span> List <span class="ot">(</span>Maybe <span class="ot">(</span>Fin <span class="ot">_))</span> <span class="ot">→</span> List <span class="ot">(</span>Fin <span class="ot">_)</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10">  sieve [] <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb1-11" data-line-number="11">  sieve <span class="ot">(</span>nothing ∷ xs<span class="ot">)</span> <span class="ot">=</span>         sieve xs</a>
<a class="sourceLine" id="cb1-12" data-line-number="12">  sieve <span class="ot">(</span>just x  ∷ xs<span class="ot">)</span> <span class="ot">=</span> suc x ∷ sieve <span class="ot">(</span>cross-off x xs<span class="ot">)</span></a>
<a class="sourceLine" id="cb1-13" data-line-number="13"></a>
<a class="sourceLine" id="cb1-14" data-line-number="14">  cross-off p fs <span class="ot">=</span> foldr f <span class="ot">(</span>const []<span class="ot">)</span> fs p</a>
<a class="sourceLine" id="cb1-15" data-line-number="15">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-16" data-line-number="16">    B <span class="ot">=</span> <span class="ot">∀</span> <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">→</span> Fin i <span class="ot">→</span> List <span class="ot">(</span>Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">2</span> + m<span class="ot">)))</span></a>
<a class="sourceLine" id="cb1-17" data-line-number="17"></a>
<a class="sourceLine" id="cb1-18" data-line-number="18">    f <span class="ot">:</span> Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">2</span> + m<span class="ot">))</span> <span class="ot">→</span> B <span class="ot">→</span> B</a>
<a class="sourceLine" id="cb1-19" data-line-number="19">    f <span class="ot">_</span> xs zero    <span class="ot">=</span> nothing ∷ xs p</a>
<a class="sourceLine" id="cb1-20" data-line-number="20">    f x xs <span class="ot">(</span>suc y<span class="ot">)</span> <span class="ot">=</span> x       ∷ xs y</a></code></pre></div>
<p>Very simple so far: we run through the list, filtering out the multiples of each prime as we see it. Unfortunately, this won’t pass the termination checker. This recursive call to <code>sieve</code> is the problem:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb2-1" data-line-number="1">sieve <span class="ot">(</span>just x ∷ xs<span class="ot">)</span> <span class="ot">=</span> suc x ∷ sieve <span class="ot">(</span>cross-off x xs<span class="ot">)</span></a></code></pre></div>
<p>Agda finds if a function is terminating by checking that at least one argument gets (structurally) smaller on every recursive call. <code>sieve</code> only takes one argument (the input list), so that’s the one that needs to get smaller. In the line above, if we replaced it with the following:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb3-1" data-line-number="1">sieve <span class="ot">(</span>just x ∷ xs<span class="ot">)</span> <span class="ot">=</span> suc x ∷ sieve xs</a></code></pre></div>
<p>We’d be good to go: <code>xs</code> is definitely smaller than <code>(just x ∷ xs)</code>. <code>cross-off x xs</code>, though? The thing is, <code>cross-off</code> returns a list of the same length that it’s given. But the function call is opaque: Agda can’t automatically see the fact that the length stays the same. Reaching for a proof here is the wrong move, though: you can get all of the same benefit by switching out the list for a length-indexed vector.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb4-1" data-line-number="1">primes <span class="ot">:</span> <span class="ot">∀</span> n <span class="ot">→</span> List <span class="ot">(</span>Fin n<span class="ot">)</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">primes zero <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">primes <span class="ot">(</span>suc zero<span class="ot">)</span> <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">primes <span class="ot">(</span>suc <span class="ot">(</span>suc zero<span class="ot">))</span> <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">primes <span class="ot">(</span>suc <span class="ot">(</span>suc <span class="ot">(</span>suc m<span class="ot">)))</span> <span class="ot">=</span> sieve <span class="ot">(</span>tabulate <span class="ot">(</span>just ∘ Fin<span class="ot">.</span>suc<span class="ot">))</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7">  cross-off <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">→</span> Fin <span class="ot">_</span> <span class="ot">→</span> Vec <span class="ot">(</span>Maybe <span class="ot">_)</span> n <span class="ot">→</span> Vec <span class="ot">(</span>Maybe <span class="ot">_)</span> n</a>
<a class="sourceLine" id="cb4-8" data-line-number="8"></a>
<a class="sourceLine" id="cb4-9" data-line-number="9">  sieve <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">→</span>  Vec <span class="ot">(</span>Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">2</span> + m<span class="ot">)))</span> n <span class="ot">→</span> List <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">3</span> + m<span class="ot">))</span></a>
<a class="sourceLine" id="cb4-10" data-line-number="10">  sieve [] <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb4-11" data-line-number="11">  sieve <span class="ot">(</span>nothing ∷ xs<span class="ot">)</span> <span class="ot">=</span>         sieve xs</a>
<a class="sourceLine" id="cb4-12" data-line-number="12">  sieve <span class="ot">(</span>just x  ∷ xs<span class="ot">)</span> <span class="ot">=</span> suc x ∷ sieve <span class="ot">(</span>cross-off x xs<span class="ot">)</span></a>
<a class="sourceLine" id="cb4-13" data-line-number="13"></a>
<a class="sourceLine" id="cb4-14" data-line-number="14">  cross-off p fs <span class="ot">=</span> foldr B f <span class="ot">(</span>const []<span class="ot">)</span> fs p</a>
<a class="sourceLine" id="cb4-15" data-line-number="15">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-16" data-line-number="16">    B <span class="ot">=</span> <span class="ot">λ</span> n <span class="ot">→</span> <span class="ot">∀</span> <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">→</span> Fin i <span class="ot">→</span> Vec <span class="ot">(</span>Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">2</span> + m<span class="ot">)))</span> n</a>
<a class="sourceLine" id="cb4-17" data-line-number="17"></a>
<a class="sourceLine" id="cb4-18" data-line-number="18">    f <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">→</span> Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">2</span> + m<span class="ot">))</span> <span class="ot">→</span> B n <span class="ot">→</span> B <span class="ot">(</span>suc n<span class="ot">)</span></a>
<a class="sourceLine" id="cb4-19" data-line-number="19">    f <span class="ot">_</span> xs zero    <span class="ot">=</span> nothing ∷ xs p</a>
<a class="sourceLine" id="cb4-20" data-line-number="20">    f x xs <span class="ot">(</span>suc y<span class="ot">)</span> <span class="ot">=</span> x       ∷ xs y</a></code></pre></div>
<p>Actually, my explanation above is a little bit of a lie. Often, the way I think about dependently-typed programs has a lot to do with my intuition for “proofs” and so on. But this leads you down the wrong path (and it’s why writing a proof that <code>cross-off</code> returns a list of the same length is the wrong move).</p>
<p>The actual termination checking algorithm is very simple, albeit strict: the argument passed recursively must be <em>structurally</em> smaller. That’s it. Basically, the recursive argument has to be contained in one of the arguments passed. It has nothing to do with Agda “seeing” inside the function <code>cross-off</code> or anything like that. What we’ve done above (to make it terminate) is add another argument to the function: the length of the vector. The argument is implicit, but if we were to make it explicit in the recursive call:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb5-1" data-line-number="1">sieve <span class="ot">{</span>suc n<span class="ot">}</span> <span class="ot">(</span>just x  ∷ xs<span class="ot">)</span> <span class="ot">=</span> suc x ∷ sieve <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">(</span>cross-off x xs<span class="ot">)</span></a></code></pre></div>
<p>We can see that it does indeed get structurally smaller.</p>
<h1 id="adding-the-squaring-optimization">Adding the Squaring Optimization</h1>
<p>A simple improvement we should be able to make is stopping once we hit the square root of the limit. Since we don’t want to be squaring as we go, we’ll use the following identity:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><msup><mo stretchy="false" form="postfix">)</mo><mn>2</mn></msup><mo>=</mo><msup><mi>n</mi><mn>2</mn></msup><mo>+</mo><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">(n + 1)^2 = n^2 + 2n + 1</annotation></semantics></math></p>
<p>to figure out the square of the next number from the previous. In fact, we’ll just pass in the limit, and reduce it by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2n + 1</annotation></semantics></math> each time, until it reaches zero:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb6-1" data-line-number="1">primes <span class="ot">:</span> <span class="ot">∀</span> n <span class="ot">→</span> List <span class="ot">(</span>Fin n<span class="ot">)</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">primes zero <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">primes <span class="ot">(</span>suc zero<span class="ot">)</span> <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">primes <span class="ot">(</span>suc <span class="ot">(</span>suc zero<span class="ot">))</span> <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">primes <span class="ot">(</span>suc <span class="ot">(</span>suc <span class="ot">(</span>suc m<span class="ot">)))</span> <span class="ot">=</span> sieve <span class="dv">1</span> m <span class="ot">(</span>Vec<span class="ot">.</span>tabulate <span class="ot">(</span>just ∘ Fin<span class="ot">.</span>suc ∘ Fin<span class="ot">.</span>suc<span class="ot">))</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-7" data-line-number="7">  cross-off <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">→</span> ℕ <span class="ot">→</span> Vec <span class="ot">(</span>Maybe <span class="ot">_)</span> n <span class="ot">→</span> Vec <span class="ot">(</span>Maybe <span class="ot">_)</span> n</a>
<a class="sourceLine" id="cb6-8" data-line-number="8"></a>
<a class="sourceLine" id="cb6-9" data-line-number="9">  sieve <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">→</span> ℕ <span class="ot">→</span> ℕ <span class="ot">→</span> Vec <span class="ot">(</span>Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">3</span> + m<span class="ot">)))</span> n <span class="ot">→</span> List <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">3</span> + m<span class="ot">))</span></a>
<a class="sourceLine" id="cb6-10" data-line-number="10">  sieve <span class="ot">_</span> zero <span class="ot">=</span> List<span class="ot">.</span>mapMaybe id ∘ Vec<span class="ot">.</span>toList</a>
<a class="sourceLine" id="cb6-11" data-line-number="11">  sieve <span class="ot">_</span> <span class="ot">(</span>suc <span class="ot">_)</span> [] <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb6-12" data-line-number="12">  sieve i <span class="ot">(</span>suc l<span class="ot">)</span> <span class="ot">(</span>nothing ∷ xs<span class="ot">)</span> <span class="ot">=</span>     sieve <span class="ot">(</span>suc i<span class="ot">)</span> <span class="ot">(</span>l ∸ i ∸ i<span class="ot">)</span> xs</a>
<a class="sourceLine" id="cb6-13" data-line-number="13">  sieve i <span class="ot">(</span>suc l<span class="ot">)</span> <span class="ot">(</span>just x  ∷ xs<span class="ot">)</span> <span class="ot">=</span> x ∷ sieve <span class="ot">(</span>suc i<span class="ot">)</span> <span class="ot">(</span>l ∸ i ∸ i<span class="ot">)</span> <span class="ot">(</span>cross-off i xs<span class="ot">)</span></a>
<a class="sourceLine" id="cb6-14" data-line-number="14"></a>
<a class="sourceLine" id="cb6-15" data-line-number="15">  cross-off p fs <span class="ot">=</span> Vec<span class="ot">.</span>foldr B f <span class="ot">(</span>const []<span class="ot">)</span> fs p</a>
<a class="sourceLine" id="cb6-16" data-line-number="16">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-17" data-line-number="17">      B <span class="ot">=</span> <span class="ot">λ</span> n <span class="ot">→</span> ℕ <span class="ot">→</span> Vec <span class="ot">(</span>Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">3</span> + m<span class="ot">)))</span> n</a>
<a class="sourceLine" id="cb6-18" data-line-number="18"></a>
<a class="sourceLine" id="cb6-19" data-line-number="19">      f <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">→</span> Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">3</span> + m<span class="ot">))</span> <span class="ot">→</span> B i <span class="ot">→</span> B <span class="ot">(</span>suc i<span class="ot">)</span></a>
<a class="sourceLine" id="cb6-20" data-line-number="20">      f <span class="ot">_</span> xs zero    <span class="ot">=</span> nothing ∷ xs p</a>
<a class="sourceLine" id="cb6-21" data-line-number="21">      f x xs <span class="ot">(</span>suc y<span class="ot">)</span> <span class="ot">=</span> x       ∷ xs y</a></code></pre></div>
<h1 id="finding-prime-factors">Finding Prime Factors</h1>
<p>A slight variation on the code above (the first version) will give us the prime factors of a number:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb7-1" data-line-number="1">primeFactors <span class="ot">:</span> <span class="ot">∀</span> n <span class="ot">→</span> List <span class="ot">(</span>Fin n<span class="ot">)</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">primeFactors zero <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">primeFactors <span class="ot">(</span>suc zero<span class="ot">)</span> <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">primeFactors <span class="ot">(</span>suc <span class="ot">(</span>suc zero<span class="ot">))</span> <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">primeFactors <span class="ot">(</span>suc <span class="ot">(</span>suc <span class="ot">(</span>suc m<span class="ot">)))</span> <span class="ot">=</span> sieve <span class="ot">(</span>Vec<span class="ot">.</span>tabulate <span class="ot">(</span>just ∘ Fin<span class="ot">.</span>suc<span class="ot">))</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-7" data-line-number="7">  sieve <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">→</span> Vec <span class="ot">(</span>Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">2</span> + m<span class="ot">)))</span> n <span class="ot">→</span> List <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">3</span> + m<span class="ot">))</span></a>
<a class="sourceLine" id="cb7-8" data-line-number="8">  sieve [] <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb7-9" data-line-number="9">  sieve <span class="ot">(</span>nothing ∷ xs<span class="ot">)</span> <span class="ot">=</span> sieve xs</a>
<a class="sourceLine" id="cb7-10" data-line-number="10">  sieve <span class="ot">(</span>just x  ∷ xs<span class="ot">)</span> <span class="ot">=</span> Vec<span class="ot">.</span>foldr B remove b xs sieve x</a>
<a class="sourceLine" id="cb7-11" data-line-number="11">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-12" data-line-number="12">    B <span class="ot">=</span> <span class="ot">λ</span> n <span class="ot">→</span> <span class="ot">∀</span> <span class="ot">{</span>i<span class="ot">}</span></a>
<a class="sourceLine" id="cb7-13" data-line-number="13">            <span class="ot">→</span> <span class="ot">(</span>Vec <span class="ot">(</span>Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">2</span> + m<span class="ot">)))</span> n</a>
<a class="sourceLine" id="cb7-14" data-line-number="14">            <span class="ot">→</span> List <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">3</span> + m<span class="ot">)))</span></a>
<a class="sourceLine" id="cb7-15" data-line-number="15">            <span class="ot">→</span> Fin i</a>
<a class="sourceLine" id="cb7-16" data-line-number="16">            <span class="ot">→</span> List <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">3</span> + m<span class="ot">))</span></a>
<a class="sourceLine" id="cb7-17" data-line-number="17"></a>
<a class="sourceLine" id="cb7-18" data-line-number="18">    b <span class="ot">:</span> B <span class="dv">0</span></a>
<a class="sourceLine" id="cb7-19" data-line-number="19">    b k zero    <span class="ot">=</span> suc x ∷ k []</a>
<a class="sourceLine" id="cb7-20" data-line-number="20">    b k <span class="ot">(</span>suc <span class="ot">_)</span> <span class="ot">=</span>         k []</a>
<a class="sourceLine" id="cb7-21" data-line-number="21"></a>
<a class="sourceLine" id="cb7-22" data-line-number="22">    remove <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">→</span> Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">2</span> + m<span class="ot">))</span> <span class="ot">→</span> B n <span class="ot">→</span> B <span class="ot">(</span>suc n<span class="ot">)</span></a>
<a class="sourceLine" id="cb7-23" data-line-number="23">    remove y ys k zero    <span class="ot">=</span> ys <span class="ot">(</span>k ∘ <span class="ot">(</span>nothing ∷<span class="ot">_))</span> x</a>
<a class="sourceLine" id="cb7-24" data-line-number="24">    remove y ys k <span class="ot">(</span>suc j<span class="ot">)</span> <span class="ot">=</span> ys <span class="ot">(</span>k ∘ <span class="ot">(</span>y ∷<span class="ot">_))</span> j</a></code></pre></div>
<p>Adding the squaring optimization complicates things significantly:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb8-1" data-line-number="1">primeFactors <span class="ot">:</span> <span class="ot">∀</span> n <span class="ot">→</span> List <span class="ot">(</span>Fin n<span class="ot">)</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">primeFactors zero <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">primeFactors <span class="ot">(</span>suc zero<span class="ot">)</span> <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">primeFactors <span class="ot">(</span>suc <span class="ot">(</span>suc zero<span class="ot">))</span> <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">primeFactors <span class="ot">(</span>suc <span class="ot">(</span>suc <span class="ot">(</span>suc m<span class="ot">)))</span> <span class="ot">=</span> sqr <span class="ot">(</span>suc m<span class="ot">)</span> m suc sieve</a>
<a class="sourceLine" id="cb8-6" data-line-number="6">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-7" data-line-number="7">  <span class="ot">_</span>2F-<span class="ot">_</span> <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">→</span> ℕ <span class="ot">→</span> Fin n <span class="ot">→</span> ℕ</a>
<a class="sourceLine" id="cb8-8" data-line-number="8">  x           2F- zero <span class="ot">=</span> x</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">  zero        2F- suc y <span class="ot">=</span> zero</a>
<a class="sourceLine" id="cb8-10" data-line-number="10">  suc zero    2F- suc y <span class="ot">=</span> zero</a>
<a class="sourceLine" id="cb8-11" data-line-number="11">  suc <span class="ot">(</span>suc x<span class="ot">)</span> 2F- suc y <span class="ot">=</span> x 2F- y</a>
<a class="sourceLine" id="cb8-12" data-line-number="12"></a>
<a class="sourceLine" id="cb8-13" data-line-number="13">  sqr <span class="ot">:</span> <span class="ot">∀</span> n</a>
<a class="sourceLine" id="cb8-14" data-line-number="14">      <span class="ot">→</span> ℕ</a>
<a class="sourceLine" id="cb8-15" data-line-number="15">      <span class="ot">→</span> <span class="ot">(</span>Fin n <span class="ot">→</span> Fin <span class="ot">(</span><span class="dv">2</span> + m<span class="ot">))</span></a>
<a class="sourceLine" id="cb8-16" data-line-number="16">      <span class="ot">→</span> <span class="ot">(∀</span> <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">→</span> Vec <span class="ot">(</span>Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">2</span> + m<span class="ot">)))</span> i <span class="ot">→</span> ℕ <span class="ot">→</span> List <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">3</span> + m<span class="ot">)))</span></a>
<a class="sourceLine" id="cb8-17" data-line-number="17">      <span class="ot">→</span> List <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">3</span> + m<span class="ot">))</span></a>
<a class="sourceLine" id="cb8-18" data-line-number="18">  sqr n       zero    f k <span class="ot">=</span> k [] n</a>
<a class="sourceLine" id="cb8-19" data-line-number="19">  sqr zero    <span class="ot">(</span>suc l<span class="ot">)</span> f k <span class="ot">=</span> k [] zero</a>
<a class="sourceLine" id="cb8-20" data-line-number="20">  sqr <span class="ot">(</span>suc n<span class="ot">)</span> <span class="ot">(</span>suc l<span class="ot">)</span> f k <span class="ot">=</span></a>
<a class="sourceLine" id="cb8-21" data-line-number="21">    <span class="kw">let</span> x <span class="ot">=</span> f zero</a>
<a class="sourceLine" id="cb8-22" data-line-number="22">    <span class="kw">in</span> sqr n <span class="ot">(</span>l 2F- x<span class="ot">)</span> <span class="ot">(</span>f ∘ suc<span class="ot">)</span> <span class="ot">(</span>k ∘ <span class="ot">(</span>just x ∷<span class="ot">_))</span></a>
<a class="sourceLine" id="cb8-23" data-line-number="23"></a>
<a class="sourceLine" id="cb8-24" data-line-number="24">  sieve <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">→</span> Vec <span class="ot">(</span>Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">2</span> + m<span class="ot">)))</span> n <span class="ot">→</span> ℕ <span class="ot">→</span> List <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">3</span> + m<span class="ot">))</span></a>
<a class="sourceLine" id="cb8-25" data-line-number="25">  sieve xs′ i <span class="ot">=</span> go xs′</a>
<a class="sourceLine" id="cb8-26" data-line-number="26">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-27" data-line-number="27">    go <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">→</span> Vec <span class="ot">(</span>Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">2</span> + m<span class="ot">)))</span> n <span class="ot">→</span> List <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">3</span> + m<span class="ot">))</span></a>
<a class="sourceLine" id="cb8-28" data-line-number="28">    go [] <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb8-29" data-line-number="29">    go <span class="ot">(</span>nothing ∷ xs<span class="ot">)</span> <span class="ot">=</span> go xs</a>
<a class="sourceLine" id="cb8-30" data-line-number="30">    go <span class="ot">(</span>just x  ∷ xs<span class="ot">)</span> <span class="ot">=</span> Vec<span class="ot">.</span>foldr B remove <span class="ot">(</span>b i<span class="ot">)</span> xs x go</a>
<a class="sourceLine" id="cb8-31" data-line-number="31">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-32" data-line-number="32">      B <span class="ot">=</span> <span class="ot">λ</span> n <span class="ot">→</span> <span class="ot">∀</span> <span class="ot">{</span>i<span class="ot">}</span></a>
<a class="sourceLine" id="cb8-33" data-line-number="33">              <span class="ot">→</span> Fin i</a>
<a class="sourceLine" id="cb8-34" data-line-number="34">              <span class="ot">→</span> <span class="ot">(</span>Vec <span class="ot">(</span>Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">2</span> + m<span class="ot">)))</span> n <span class="ot">→</span> List <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">3</span> + m<span class="ot">)))</span></a>
<a class="sourceLine" id="cb8-35" data-line-number="35">              <span class="ot">→</span> List <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">3</span> + m<span class="ot">))</span></a>
<a class="sourceLine" id="cb8-36" data-line-number="36"></a>
<a class="sourceLine" id="cb8-37" data-line-number="37">      b <span class="ot">:</span> ℕ <span class="ot">→</span> B <span class="dv">0</span></a>
<a class="sourceLine" id="cb8-38" data-line-number="38">      b zero    zero    k <span class="ot">=</span> suc x ∷ k []</a>
<a class="sourceLine" id="cb8-39" data-line-number="39">      b zero    <span class="ot">(</span>suc y<span class="ot">)</span> k <span class="ot">=</span> k []</a>
<a class="sourceLine" id="cb8-40" data-line-number="40">      b <span class="ot">(</span>suc n<span class="ot">)</span> zero    k <span class="ot">=</span> b n x k</a>
<a class="sourceLine" id="cb8-41" data-line-number="41">      b <span class="ot">(</span>suc n<span class="ot">)</span> <span class="ot">(</span>suc y<span class="ot">)</span> k <span class="ot">=</span> b n y k</a>
<a class="sourceLine" id="cb8-42" data-line-number="42"></a>
<a class="sourceLine" id="cb8-43" data-line-number="43">      remove <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">→</span> Maybe <span class="ot">(</span>Fin <span class="ot">(</span><span class="dv">2</span> + m<span class="ot">))</span> <span class="ot">→</span> B n <span class="ot">→</span> B <span class="ot">(</span>suc n<span class="ot">)</span></a>
<a class="sourceLine" id="cb8-44" data-line-number="44">      remove y ys zero    k <span class="ot">=</span> ys x <span class="ot">(</span>k ∘ <span class="ot">(</span>nothing ∷<span class="ot">_))</span></a>
<a class="sourceLine" id="cb8-45" data-line-number="45">      remove y ys <span class="ot">(</span>suc j<span class="ot">)</span> k <span class="ot">=</span> ys j <span class="ot">(</span>k ∘ <span class="ot">(</span>y ∷<span class="ot">_))</span></a></code></pre></div>
<h1 id="infinitude">Infinitude</h1>
<p>The above sieve aren’t “true” in that each <code>remove</code> is linear, so the performance is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n^2)</annotation></semantics></math> overall. This is the same problem we ran into with the naive infinite sieve in Haskell.</p>
<p>Since it bears such a similarity to the infinite sieve, we have to ask: can <em>this</em> sieve be infinite? Agda supports a notion of infinite data, so it would seem like it:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">5</span> <span class="ot">_</span>◂<span class="ot">_</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="kw">record</span> Stream <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  <span class="kw">constructor</span> <span class="ot">_</span>◂<span class="ot">_</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4">  <span class="kw">coinductive</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  <span class="kw">field</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6">    head <span class="ot">:</span> A</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">    tail <span class="ot">:</span> Stream A</a>
<a class="sourceLine" id="cb9-8" data-line-number="8"><span class="kw">open</span> Stream</a>
<a class="sourceLine" id="cb9-9" data-line-number="9"></a>
<a class="sourceLine" id="cb9-10" data-line-number="10">primes <span class="ot">:</span> Stream ℕ</a>
<a class="sourceLine" id="cb9-11" data-line-number="11">primes <span class="ot">=</span> sieve <span class="dv">1</span> nats</a>
<a class="sourceLine" id="cb9-12" data-line-number="12">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-13" data-line-number="13">  nats <span class="ot">:</span> Stream ℕ</a>
<a class="sourceLine" id="cb9-14" data-line-number="14">  head nats <span class="ot">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb9-15" data-line-number="15">  tail nats <span class="ot">=</span> nats</a>
<a class="sourceLine" id="cb9-16" data-line-number="16"></a>
<a class="sourceLine" id="cb9-17" data-line-number="17">  sieve <span class="ot">:</span> ℕ <span class="ot">→</span> Stream ℕ <span class="ot">→</span> Stream ℕ</a>
<a class="sourceLine" id="cb9-18" data-line-number="18">  head <span class="ot">(</span>sieve i xs<span class="ot">)</span> <span class="ot">=</span> suc i</a>
<a class="sourceLine" id="cb9-19" data-line-number="19">  tail <span class="ot">(</span>sieve i xs<span class="ot">)</span> <span class="ot">=</span> remove i <span class="ot">(</span>head xs<span class="ot">)</span> <span class="ot">(</span>tail xs<span class="ot">)</span> <span class="ot">(</span>sieve ∘ suc ∘ <span class="ot">(_</span>+ i<span class="ot">))</span></a>
<a class="sourceLine" id="cb9-20" data-line-number="20">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-21" data-line-number="21">    remove <span class="ot">:</span> ℕ <span class="ot">→</span> ℕ <span class="ot">→</span> Stream ℕ <span class="ot">→</span> <span class="ot">(</span>ℕ <span class="ot">→</span> Stream ℕ <span class="ot">→</span> Stream ℕ<span class="ot">)</span> <span class="ot">→</span> Stream ℕ</a>
<a class="sourceLine" id="cb9-22" data-line-number="22">    remove zero zero zs       k <span class="ot">=</span> remove i <span class="ot">(</span>head zs<span class="ot">)</span> <span class="ot">(</span>tail zs<span class="ot">)</span> <span class="ot">(</span>k ∘ suc<span class="ot">)</span></a>
<a class="sourceLine" id="cb9-23" data-line-number="23">    remove zero <span class="ot">(</span>suc z<span class="ot">)</span> zs    k <span class="ot">=</span> remove i z zs <span class="ot">(</span>k ∘ suc<span class="ot">)</span></a>
<a class="sourceLine" id="cb9-24" data-line-number="24">    remove <span class="ot">(</span>suc y<span class="ot">)</span> zero zs    k <span class="ot">=</span> k zero <span class="ot">(</span>remove y <span class="ot">(</span>head zs<span class="ot">)</span> <span class="ot">(</span>tail zs<span class="ot">)</span> <span class="ot">_</span>◂<span class="ot">_)</span></a>
<a class="sourceLine" id="cb9-25" data-line-number="25">    remove <span class="ot">(</span>suc y<span class="ot">)</span> <span class="ot">(</span>suc z<span class="ot">)</span> zs k <span class="ot">=</span> remove y z zs <span class="ot">(</span>k ∘ suc<span class="ot">)</span></a></code></pre></div>
<p>But this won’t pass the termination checker. What we actually need to prove to do so is that there are infinitely many primes: <a href="https://gist.github.com/copumpkin/1286093">a nontrivial task in Agda</a>.</p>
]]></description>
    <pubDate>Fri, 14 Dec 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-12-14-primes-in-agda.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Keeping Formal Verification in Bounds</title>
    <link>https://doisinkidney.com/posts/2018-11-20-fast-verified-structures.html</link>
    <description><![CDATA[<div class="info">
    Posted on November 20, 2018
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Agda.html">Agda</a>
    
</div>

<p>One of the favorite pastimes of both Haskell and Agda programmers alike is verifying data structures. Among my favorite examples are Red-Black trees <span class="citation" data-cites="might_missing_2015 weirich_depending_2014">(Might <a href="#ref-might_missing_2015">2015</a>; Weirich <a href="#ref-weirich_depending_2014">2014</a>, verified for balance)</span>, perfect binary trees <span class="citation" data-cites="hinze_perfect_1999">(Hinze <a href="#ref-hinze_perfect_1999">1999</a>)</span>, square matrices <span class="citation" data-cites="okasaki_fast_1999">(Okasaki <a href="#ref-okasaki_fast_1999">1999</a><a href="#ref-okasaki_fast_1999">a</a>)</span>, search trees <span class="citation" data-cites="mcbride_how_2014">(McBride <a href="#ref-mcbride_how_2014">2014</a>, verified for balance and order)</span>, and binomial heaps <span class="citation" data-cites="hinze_numerical_1998">(Hinze <a href="#ref-hinze_numerical_1998">1998</a>, verified for structure)</span>.</p>
<p>There are many ways to verify data structures. One technique which has had recent massive success is to convert Haskell code to Coq, and then verify the Coq translation: this was the route taken by <span class="citation" data-cites="breitner_ready_2018-1">Breitner et al. (<a href="#ref-breitner_ready_2018-1">2018</a>)</span> to verify <code>Set</code> and <code>IntSet</code> in containers (a mammoth achievement, in my opinion).</p>
<p>This approach has some obvious advantages: you separate implementation from testing (which is usually a good idea), and your verification language can be different from your implementation language, with each tailored towards its particular domain.</p>
<p>LiquidHaskell <span class="citation" data-cites="bakst_liquidhaskell_2018">(Bakst et al. <a href="#ref-bakst_liquidhaskell_2018">2018</a>)</span> (and other tools like it) adds an extra type system to Haskell tailor-made for verification. The added type system (refinement types) is more automated (the typechecker uses Z3), more suited for “invariant”-like things (it supports subtyping), and has a bunch of domain-specific built-ins (reasoning about sets, equations, etc.). I’d encourage anyone who hasn’t used it to give it a try: especially if you’re experienced writing any kind of proof in a language like Agda or Idris, LiquidHaskell proofs are <em>shockingly</em> simple and easy.</p>
<p>What I’m going to focus on today, though, is writing <em>correct-by-construction</em> data structures, using Haskell and Agda’s own type systems. In particular, I’m going to look at how to write <em>fast</em> verification. In the other two approaches, we don’t really care about the “speed” of the proofs: sure, it’s nice to speed up compilation and so on, but we don’t have to worry about our implementation suffering at runtime because of some complex proof. When writing correct-by-construction code, though, our task is doubly hard: we now have to worry about the time complexity of both the implementation <em>and the proofs</em>.</p>
<p>In this post, I’m going to demonstrate some techniques to write proofs that stay within the complexity bounds of the algorithms they’re verifying (without cheating!). Along the way I’m going to verify some data structures I haven’t seen verified before (a skew-binary random-access list).</p>
<h1 id="technique-1-start-with-an-unverified-implementation-then-index">Technique 1: Start With an Unverified Implementation, then Index</h1>
<p>To demonstrate the first two techniques, we’re going to write a type for modular arithmetic. For a more tactile metaphor, think of the flip clock:</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/c/c3/Split-flap_display.jpg" /></p>
<p>Each digit can be incremented <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> times, where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> is whatever base you’re using (12 for our flip-clock above). Once you hit the limit, it flips the next digit along. We’ll start with just one digit, and then just string them together to get our full type. That in mind, our “digit” type has two requirements:</p>
<ol>
<li>It should be incrementable.</li>
<li>Once it hits its limit, it should flip back to zero, and let us know that a flip was performed.</li>
</ol>
<p>Anyone who’s used a little Agda or Idris will be familiar with the <code>Fin</code> type:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> Fin <span class="ot">:</span> ℕ <span class="ot">→</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  zero <span class="ot">:</span> <span class="ot">{</span>n <span class="ot">:</span> ℕ<span class="ot">}</span> <span class="ot">→</span> Fin <span class="ot">(</span>suc n<span class="ot">)</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  suc  <span class="ot">:</span> <span class="ot">{</span>n <span class="ot">:</span> ℕ<span class="ot">}</span> <span class="ot">→</span> Fin n <span class="ot">→</span> Fin <span class="ot">(</span>suc n<span class="ot">)</span></a></code></pre></div>
<p><code>Fin n</code> is the standard way to encode “numbers smaller than <code>n</code>”. However, for digits they’re entirely unsuitable: since the limit parameter changes on successor, the kind of increment we want is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n)</annotation></semantics></math>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb2-1" data-line-number="1">try-suc <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">→</span> Fin n <span class="ot">→</span> Maybe <span class="ot">(</span>Fin n<span class="ot">)</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">try-suc <span class="ot">(</span>suc x<span class="ot">)</span> <span class="ot">=</span> Maybe<span class="ot">.</span>map suc <span class="ot">(</span>try-suc x<span class="ot">)</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">try-suc <span class="ot">{</span>suc n<span class="ot">}</span> zero <span class="kw">with</span> n</a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="ot">...</span> <span class="ot">|</span> zero <span class="ot">=</span> nothing</a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="ot">...</span> <span class="ot">|</span> suc <span class="ot">_</span> <span class="ot">=</span> just <span class="ot">(</span>suc zero<span class="ot">)</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6"></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">suc-flip <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">→</span> Fin n <span class="ot">→</span> Fin n × Bool</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">suc-flip <span class="ot">{</span>suc n<span class="ot">}</span> x <span class="ot">=</span> maybe <span class="ot">(_</span>, false<span class="ot">)</span> <span class="ot">(</span>zero , true<span class="ot">)</span> <span class="ot">(</span>try-suc x<span class="ot">)</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9">suc-flip <span class="ot">{</span>zero<span class="ot">}</span> <span class="ot">()</span></a></code></pre></div>
<p>If we keep going down this path with proofs in mind, we might next look at the various <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>≤</mo><annotation encoding="application/x-tex">\leq</annotation></semantics></math> proofs in the Agda standard library (<a href="https://github.com/agda/agda-stdlib/blob/18b45b151f44cee2114fa4b3c1ad9ea532baf919/src/Data/Nat/Base.agda#L28">here</a>, <a href="https://github.com/agda/agda-stdlib/blob/18b45b151f44cee2114fa4b3c1ad9ea532baf919/src/Data/Nat/Base.agda#L117">here</a>, and <a href="https://github.com/agda/agda-stdlib/blob/18b45b151f44cee2114fa4b3c1ad9ea532baf919/src/Data/Nat/Base.agda#L133">here</a>), and see if we can we can wrangle them into doing what we want.</p>
<p>For me, though, this wasn’t a fruitful approach. Instead, we’ll try and think of how we’d do this without proving anything, and then see if there’s any place in the resulting data structure we can hang some proof.</p>
<p>So, in an unproven way, let’s start with some numbers. Since we’re going to be incrementing, they’d better be unary:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">data</span> ℕ <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  zero <span class="ot">:</span> ℕ</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">  suc <span class="ot">:</span> ℕ <span class="ot">→</span> ℕ</a></code></pre></div>
<p>And then, for the “flippable” type, we’ll just store the limit alongside the value:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">record</span> Flipper <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  <span class="kw">constructor</span> <span class="ot">_</span>&amp;<span class="ot">_</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  <span class="kw">field</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">    val <span class="ot">:</span> ℕ</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">    lim <span class="ot">:</span> ℕ</a></code></pre></div>
<p>We’re not there yet: to check if we’ve gone over the limit, we’ll still have to compare <code>val</code> and <code>lim</code>. Hopefully you can guess the optimization we’ll make: instead of storing the limit, we’ll store the space left:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">record</span> Flipper <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">  <span class="kw">constructor</span> <span class="ot">_</span>&amp;<span class="ot">_</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  <span class="kw">field</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">    space <span class="ot">:</span> ℕ</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">    val   <span class="ot">:</span> ℕ</a></code></pre></div>
<p>And we get our flip function:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb6-1" data-line-number="1">suc-flip <span class="ot">:</span> Flipper <span class="ot">→</span> Flipper × Bool</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">suc-flip <span class="ot">(</span>zero  &amp; n<span class="ot">)</span> <span class="ot">=</span> <span class="ot">(</span>suc n &amp; zero <span class="ot">)</span>, true</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">suc-flip <span class="ot">(</span>suc m &amp; n<span class="ot">)</span> <span class="ot">=</span> <span class="ot">(</span>m     &amp; suc n<span class="ot">)</span>, false</a></code></pre></div>
<p>When there’s no space left, the digit must be maximal (9 in decimal, for instance), so it’ll be one less than the base. That lets us stick it in for the base, rather than recalculating. In the other case, we just take one from the space left, and add it to the value.</p>
<p>So, to “prove” this implementation, we might first reach for an equality proof that <code>val + space</code> is equal to your base. Don’t! Both <code>val</code> and <code>space</code> are inductive structures, which could be giving us information on every application of <code>suc</code>! Let’s set our sights on <code>val</code> and see how we can hang our proofs off of it.</p>
<p>We’re going to upgrade our Peano number with some information, which means that our resulting type is going to look an awful lot like a Peano number. In other words, two cases: <code>zero</code> and <code>suc</code>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">data</span> Val <span class="ot">_</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  zero-case <span class="ot">:</span> Val <span class="ot">_</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  suc-case  <span class="ot">:</span> Val <span class="ot">_</span> <span class="ot">→</span> Val <span class="ot">_</span></a></code></pre></div>
<p>For the <code>suc-case</code>, remember we only want to be allowed to increment it when the space left is more than zero. So let’s encode it:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">data</span> Val <span class="ot">_</span> <span class="ot">:</span> ℕ <span class="ot">→</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  zero-case <span class="ot">:</span> Val <span class="ot">_</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  suc-case  <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>space<span class="ot">}</span> <span class="ot">→</span> Val <span class="ot">_</span> <span class="ot">(</span>suc space<span class="ot">)</span> <span class="ot">→</span> Val <span class="ot">_</span> space</a></code></pre></div>
<p>And for the <code>zero-case</code>, the space left is just the base. So let’s stick the base into the type as well:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">data</span> Val <span class="ot">(</span>base <span class="ot">:</span> ℕ<span class="ot">)</span> <span class="ot">:</span> ℕ <span class="ot">→</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">  zero-case <span class="ot">:</span> Val base base</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  suc-case  <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>space<span class="ot">}</span> <span class="ot">→</span> Val base <span class="ot">(</span>suc space<span class="ot">)</span> <span class="ot">→</span> Val base space</a></code></pre></div>
<p>(We’ve changed around the way “base” works: it’s now one smaller. So to encode base-10 you’d have <code>Val 9 space</code>. You can get back to the other encoding with a simple wrapper, this way just makes things slightly easier from now on).</p>
<p>Finally, our flipper:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">record</span> Flipper <span class="ot">(</span>base <span class="ot">:</span> ℕ<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">  <span class="kw">constructor</span> <span class="ot">_</span>&amp;<span class="ot">_</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  <span class="kw">field</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4">    space <span class="ot">:</span> ℕ</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">    val <span class="ot">:</span> Val base space</a>
<a class="sourceLine" id="cb10-6" data-line-number="6"></a>
<a class="sourceLine" id="cb10-7" data-line-number="7">suc-flip <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">→</span> Flipper n <span class="ot">→</span> Flipper n × Bool</a>
<a class="sourceLine" id="cb10-8" data-line-number="8">suc-flip <span class="ot">(</span>zero  &amp; m<span class="ot">)</span> <span class="ot">=</span> <span class="ot">(_</span> &amp;  zero-case<span class="ot">)</span> , true</a>
<a class="sourceLine" id="cb10-9" data-line-number="9">suc-flip <span class="ot">(</span>suc n &amp; m<span class="ot">)</span> <span class="ot">=</span> <span class="ot">(</span>n &amp; suc-case m<span class="ot">)</span> , false</a></code></pre></div>
<p>Great! Everything works.</p>
<p>You may have noticed that the <code>Val</code> type is actually a proof for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>≥</mo><annotation encoding="application/x-tex">\geq</annotation></semantics></math> in disguise:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">data</span> <span class="ot">_</span>≥<span class="ot">_</span> <span class="ot">(</span>m <span class="ot">:</span> ℕ<span class="ot">)</span> <span class="ot">:</span> ℕ <span class="ot">→</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2">  m≥m <span class="ot">:</span> m ≥ m</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  m≥p <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">→</span> m ≥ suc n <span class="ot">→</span> m ≥ n</a></code></pre></div>
<p>And the flipper itself is just an existential in disguise:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb12-1" data-line-number="1">Flipper <span class="ot">:</span> ℕ <span class="ot">→</span> <span class="dt">Set</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">Flipper n <span class="ot">=</span> ∃ <span class="ot">(</span>n ≥<span class="ot">_)</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3"></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">suc-flip <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">→</span> Flipper n <span class="ot">→</span> Flipper n × Bool</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">suc-flip <span class="ot">(</span>zero  , m<span class="ot">)</span> <span class="ot">=</span> <span class="ot">(_</span> , m≥m  <span class="ot">)</span>, true</a>
<a class="sourceLine" id="cb12-6" data-line-number="6">suc-flip <span class="ot">(</span>suc n , m<span class="ot">)</span> <span class="ot">=</span> <span class="ot">(</span>n , m≥p m<span class="ot">)</span>, false</a></code></pre></div>
<p>Hopefully this explanation will help you understand how to get from the specification to those 8 lines. This technique is going to come in especially handy later when we base data structures off of number systems.</p>
<h1 id="technique-2-once-you-eliminate-the-impossible-whatever-remains-no-matter-how-improbable-must-be-the-truth.">Technique 2: Once you eliminate the impossible, whatever remains, no matter how improbable, must be the truth.</h1>
<p>For this next trick, we’ll add an extra operation to the flipper type above: conversion from a natural number. We want to be able to do it in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n)</annotation></semantics></math> time, and we won’t allow ourselves to change the original type definition. Here’s the type we’re aiming for:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb13-1" data-line-number="1">fromNat <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>m<span class="ot">}</span> <span class="ot">(</span>n <span class="ot">:</span> ℕ<span class="ot">)</span> <span class="ot">→</span> <span class="ot">(</span>m≥n <span class="ot">:</span> m ≥ n<span class="ot">)</span> <span class="ot">→</span> Flipper m</a></code></pre></div>
<p>We pass in a proof that the natural number we’re converting from is indeed in range (it’s marked irrelevant so we don’t pay for it). Here’s a non-answer:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb14-1" data-line-number="1">fromNat <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>m<span class="ot">}</span> <span class="ot">(</span>n <span class="ot">:</span> ℕ<span class="ot">)</span> <span class="ot">→</span> <span class="ot">{</span>m≥n <span class="ot">:</span> m ≥ n<span class="ot">}</span> <span class="ot">→</span> Flipper m</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">fromNat n <span class="ot">{</span>m≥n<span class="ot">}</span> <span class="ot">=</span> n , m≥n</a></code></pre></div>
<p>While this looks fine, it’s actually the <em>inverse</em> of what we want. We defined the inductive structure to be indicated by the inequality proof itself. Let’s make the desired output explicit:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb15-1" data-line-number="1">toNat <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n m<span class="ot">}</span> <span class="ot">→</span> n ≥ m <span class="ot">→</span> ℕ</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">toNat m≥m <span class="ot">=</span> zero</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">toNat <span class="ot">(</span>m≥p n≥m<span class="ot">)</span> <span class="ot">=</span> suc <span class="ot">(</span>toNat n≥m<span class="ot">)</span></a>
<a class="sourceLine" id="cb15-4" data-line-number="4"></a>
<a class="sourceLine" id="cb15-5" data-line-number="5">fromNat-≡ <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n<span class="ot">}</span> m</a>
<a class="sourceLine" id="cb15-6" data-line-number="6">          <span class="ot">→</span> <span class="ot">.(</span>n≥m <span class="ot">:</span> n ≥ m<span class="ot">)</span></a>
<a class="sourceLine" id="cb15-7" data-line-number="7">          <span class="ot">→</span>  Σ[ n-m ∈ Flipper n ] toNat <span class="ot">(</span>proj₂ n-m<span class="ot">)</span> ≡ m</a></code></pre></div>
<p>And finally we can try an implementation:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb16-1" data-line-number="1">fromNat-≡ zero    <span class="ot">_</span>   <span class="ot">=</span> <span class="ot">(_</span> , m≥m<span class="ot">)</span> , refl</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">fromNat-≡ <span class="ot">(</span>suc m<span class="ot">)</span> n≥m <span class="ot">=</span> ??? <span class="ot">(</span>fromNat-≡ m <span class="ot">(</span>m≥p n≥m<span class="ot">))</span></a></code></pre></div>
<p>In the <code>???</code> there, we want some kind of successor function. The problem is that we would also need to prove that we <em>can</em> do a successor call. Except we don’t want to do that: proving that there’s space left is an expensive operation, and one we can avoid with another trick: first, we <em>assume</em> that there’s space left.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb17-1" data-line-number="1">fromNat-≡ zero    n≥m <span class="ot">=</span> <span class="ot">(</span> <span class="ot">_</span> , m≥m<span class="ot">)</span> , refl</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">fromNat-≡ <span class="ot">(</span>suc n<span class="ot">)</span> n≥m <span class="kw">with</span> fromNat-≡ n <span class="ot">(</span>m≥p n≥m<span class="ot">)</span></a>
<a class="sourceLine" id="cb17-3" data-line-number="3"><span class="ot">...</span> <span class="ot">|</span> <span class="ot">(</span>suc space , n-1<span class="ot">)</span>, x≡m  <span class="ot">=</span> <span class="ot">(</span>space , m≥p n-1<span class="ot">)</span>, cong suc x≡m</a>
<a class="sourceLine" id="cb17-4" data-line-number="4"><span class="ot">...</span> <span class="ot">|</span> <span class="ot">(</span>zero      , n-1<span class="ot">)</span>, refl <span class="ot">=</span> ???</a></code></pre></div>
<p>But what about the second case? Well, we have to prove this impossible. What if it’s an extremely complex, expensive proof? It doesn’t matter! It will never be run! In contrast to proving the “happy path” correct, if we can confine all of the ugly complex cases to the unhappy paths, we can spend as long as we want proving them impossible without having to worry about runtime cost. Here’s the full function.</p>
<details>
<p><summary> <code>fromNat</code> implementation </summary></p>
<div class="sourceCode" id="cb18"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb18-1" data-line-number="1">fromNat-≡ <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n<span class="ot">}</span> m</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">          <span class="ot">→</span> <span class="ot">.(</span>n≥m <span class="ot">:</span> n ≥ m<span class="ot">)</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3">          <span class="ot">→</span>  Σ[ n-m ∈ Flipper n ] toNat <span class="ot">(</span>proj₂ n-m<span class="ot">)</span> ≡ m</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">fromNat-≡ zero    n≥m <span class="ot">=</span> <span class="ot">(</span> <span class="ot">_</span> , m≥m<span class="ot">)</span> , refl</a>
<a class="sourceLine" id="cb18-5" data-line-number="5">fromNat-≡ <span class="ot">(</span>suc n<span class="ot">)</span> n≥m <span class="kw">with</span> fromNat-≡ n <span class="ot">(</span>m≥p n≥m<span class="ot">)</span></a>
<a class="sourceLine" id="cb18-6" data-line-number="6"><span class="ot">...</span> <span class="ot">|</span> <span class="ot">(</span>suc space , n-1<span class="ot">)</span>, x≡m  <span class="ot">=</span> <span class="ot">(</span>space , m≥p n-1<span class="ot">)</span>, cong suc x≡m</a>
<a class="sourceLine" id="cb18-7" data-line-number="7"><span class="ot">...</span> <span class="ot">|</span> <span class="ot">(</span>zero      , n≥0<span class="ot">)</span>, refl <span class="ot">=</span> Irrel<span class="ot">.</span>⊥-elim <span class="ot">(</span>contra <span class="ot">_</span> zero n≥0 n≥m<span class="ot">)</span></a>
<a class="sourceLine" id="cb18-8" data-line-number="8">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-9" data-line-number="9">  <span class="kw">import</span> Data<span class="ot">.</span>Nat<span class="ot">.</span>Properties as <span class="dt">Prop</span></a>
<a class="sourceLine" id="cb18-10" data-line-number="10"></a>
<a class="sourceLine" id="cb18-11" data-line-number="11">  n≱sk+n <span class="ot">:</span> <span class="ot">∀</span> n k <span class="ot">{</span>sk+n<span class="ot">}</span> <span class="ot">→</span> sk+n ≡ suc k ℕ<span class="ot">.</span>+ n <span class="ot">→</span> n ≥ sk+n <span class="ot">→</span> ⊥</a>
<a class="sourceLine" id="cb18-12" data-line-number="12">  n≱sk+n n k wit <span class="ot">(</span>m≥p n≥sk+n<span class="ot">)</span> <span class="ot">=</span> n≱sk+n n <span class="ot">(</span>suc k<span class="ot">)</span> <span class="ot">(</span>cong suc wit<span class="ot">)</span> n≥sk+n</a>
<a class="sourceLine" id="cb18-13" data-line-number="13">  n≱sk+n n k wit m≥m <span class="kw">with</span> <span class="dt">Prop</span><span class="ot">.</span>+-cancelʳ-≡ <span class="dv">0</span> <span class="ot">(</span>suc k<span class="ot">)</span> wit</a>
<a class="sourceLine" id="cb18-14" data-line-number="14">  <span class="ot">...</span> <span class="ot">|</span> <span class="ot">()</span></a>
<a class="sourceLine" id="cb18-15" data-line-number="15"></a>
<a class="sourceLine" id="cb18-16" data-line-number="16">  contra <span class="ot">:</span> <span class="ot">∀</span> n m <span class="ot">→</span> <span class="ot">(</span>n≥m <span class="ot">:</span> n ≥ m<span class="ot">)</span> <span class="ot">→</span> n ≥ suc <span class="ot">(</span>m ℕ<span class="ot">.</span>+ toNat n≥m<span class="ot">)</span> <span class="ot">→</span> ⊥</a>
<a class="sourceLine" id="cb18-17" data-line-number="17">  contra n m m≥m n≥st <span class="ot">=</span> n≱sk+n n zero <span class="ot">(</span>cong suc <span class="ot">(</span><span class="dt">Prop</span><span class="ot">.</span>+-identityʳ n<span class="ot">))</span> n≥st</a>
<a class="sourceLine" id="cb18-18" data-line-number="18">  contra n m <span class="ot">(</span>m≥p n≥m<span class="ot">)</span> n≥st <span class="ot">=</span></a>
<a class="sourceLine" id="cb18-19" data-line-number="19">    contra</a>
<a class="sourceLine" id="cb18-20" data-line-number="20">      n</a>
<a class="sourceLine" id="cb18-21" data-line-number="21">      <span class="ot">(</span>suc m<span class="ot">)</span></a>
<a class="sourceLine" id="cb18-22" data-line-number="22">      n≥m</a>
<a class="sourceLine" id="cb18-23" data-line-number="23">      <span class="ot">(</span>subst <span class="ot">(λ</span> x <span class="ot">→</span> n ≥ suc x<span class="ot">)</span> <span class="ot">(</span><span class="dt">Prop</span><span class="ot">.</span>+-suc m <span class="ot">(</span>toNat n≥m<span class="ot">))</span> n≥st<span class="ot">)</span></a>
<a class="sourceLine" id="cb18-24" data-line-number="24"></a>
<a class="sourceLine" id="cb18-25" data-line-number="25">fromNat <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n<span class="ot">}</span> m <span class="ot">→</span> <span class="ot">.(</span>n≥m <span class="ot">:</span> n ≥ m<span class="ot">)</span> <span class="ot">→</span> Flipper n</a>
<a class="sourceLine" id="cb18-26" data-line-number="26">fromNat m n≥m <span class="ot">=</span> proj₁ <span class="ot">(</span>fromNat-≡ m n≥m<span class="ot">)</span></a></code></pre></div>
</details>
<h1 id="technique-3-make-indices-correct-by-construction">Technique 3: Make Indices Correct-By-Construction</h1>
<p>We’re going to switch into Haskell now, and in particular to functional arrays. These are data structures which aren’t real arrays, but they offer you the kind of interface you’d want from an array in a functional setting. You can’t get better than <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math> indexing, unfortunately <span class="citation" data-cites="ben-amram_pointers_1992">(Ben-Amram and Galil <a href="#ref-ben-amram_pointers_1992">1992</a>)</span>, but often it’s enough.</p>
<p>The first “functional array” we’re going to be looking at nested binary random-access lists. It has <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math> indexing, as you might expect, and amortized single-threaded <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math> <code>cons</code>.</p>
<p>It starts out like a binary random-access list (“random-access list” is another name for “functional array”). You can find a full explanation of the structure in your nearest copy of Purely Functional Data Structures <span class="citation" data-cites="okasaki_purely_1999">(Okasaki <a href="#ref-okasaki_purely_1999">1999</a><a href="#ref-okasaki_purely_1999">b</a>)</span>, but briefly: the structure mimics a binary number, in that it’s a list of “bits”. At each set bit, it stores a tree with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mi>i</mi></msup><annotation encoding="application/x-tex">2^i</annotation></semantics></math> elements, where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math> is the position in the list. In this way, every binary number <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> has an analogous list of “bits” which contains, in total, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> elements.</p>
<p>The “nested” part refers to how we’re going to implement the trees. It works a little like this:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a <span class="fu">=</span> <span class="dt">Leaf</span> a <span class="fu">|</span> <span class="dt">Node</span> (<span class="dt">Tree</span> (a,a))</a></code></pre></div>
<p>You might have to squint at that definition for a second to understand it: instead of storing two trees at the <code>Node</code> constructor (which is what you’d usually do), we store a tree with double the elements. This has two advantages: all of the children have the same number of elements (this tree, for instance, is always some power of 2), and it also cuts down on memory use.</p>
<p>For the binary random-access list, we’ll use the nested encoding of trees to encode the contents of each bit. There’s an implementation of this very thing on Hackage <span class="citation" data-cites="komuves_nested-sequence_2016">(Komuves and Divianszky <a href="#ref-komuves_nested-sequence_2016">2016</a>)</span>, and Okasaki himself wrote something very similar to it <span class="citation" data-cites="okasaki_fast_1999">(<a href="#ref-okasaki_fast_1999">1999</a><a href="#ref-okasaki_fast_1999">a</a>)</span>, but we’re going to go a little further than both of those by indexing the type by its size. Here it is:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Bit</span> <span class="fu">=</span> <span class="dt">O</span> <span class="fu">|</span> <span class="dt">I</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2"></a>
<a class="sourceLine" id="cb20-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Seq</span> ns a <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-4" data-line-number="4">    <span class="dt">Nil</span><span class="ot">  ::</span>                      <span class="dt">Seq</span> <span class="ch">&#39;[]      a</span></a>
<a class="sourceLine" id="cb20-5" data-line-number="5">    <span class="dt">Even</span><span class="ot"> ::</span>      <span class="dt">Seq</span> xs (a,a) <span class="ot">-&gt;</span> <span class="dt">Seq</span> (<span class="dt">O</span> <span class="fu">:</span> xs) a</a>
<a class="sourceLine" id="cb20-6" data-line-number="6">    <span class="dt">Odd</span><span class="ot">  ::</span> a <span class="ot">-&gt;</span> <span class="dt">Seq</span> xs (a,a) <span class="ot">-&gt;</span> <span class="dt">Seq</span> (<span class="dt">I</span> <span class="fu">:</span> xs) a</a></code></pre></div>
<p>The operations we’re interested will be <code>cons</code> and <code>uncons</code>: for the indices, they correspond to incrementing and decrementing the numbers, respectively. As such, we’ll need type-level functions for those:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">Inc</span> (<span class="ot">ns ::</span> [<span class="dt">Bit</span>])<span class="ot"> ::</span> [<span class="dt">Bit</span>] <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-2" data-line-number="2">    <span class="dt">Inc</span> <span class="ch">&#39;[] = &#39;</span>[<span class="dt">I</span>]</a>
<a class="sourceLine" id="cb21-3" data-line-number="3">    <span class="dt">Inc</span> (<span class="dt">O</span> <span class="fu">:</span> xs) <span class="fu">=</span> <span class="dt">I</span> <span class="fu">:</span> xs</a>
<a class="sourceLine" id="cb21-4" data-line-number="4">    <span class="dt">Inc</span> (<span class="dt">I</span> <span class="fu">:</span> xs) <span class="fu">=</span> <span class="dt">O</span> <span class="fu">:</span> <span class="dt">Inc</span> xs</a></code></pre></div>
<p>And now the <code>cons</code> function:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="ot">cons ::</span> a <span class="ot">-&gt;</span> <span class="dt">Seq</span> ns a <span class="ot">-&gt;</span> <span class="dt">Seq</span> (<span class="dt">Inc</span> ns) a</a>
<a class="sourceLine" id="cb22-2" data-line-number="2">cons x <span class="dt">Nil</span>        <span class="fu">=</span> <span class="dt">Odd</span> x <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb22-3" data-line-number="3">cons x (<span class="dt">Even</span>  xs) <span class="fu">=</span> <span class="dt">Odd</span> x xs</a>
<a class="sourceLine" id="cb22-4" data-line-number="4">cons x (<span class="dt">Odd</span> y ys) <span class="fu">=</span> <span class="dt">Even</span> (cons (x,y) ys)</a></code></pre></div>
<p>However, we’re going to run into trouble if we try to write <code>uncons</code>:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">Dec</span> (<span class="ot">ns ::</span> [<span class="dt">Bit</span>])<span class="ot"> ::</span> [<span class="dt">Bit</span>] <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-2" data-line-number="2">    <span class="dt">Dec</span> (<span class="dt">I</span> <span class="fu">:</span> xs) <span class="fu">=</span> <span class="dt">O</span> <span class="fu">:</span> xs</a>
<a class="sourceLine" id="cb23-3" data-line-number="3">    <span class="dt">Dec</span> (<span class="dt">O</span> <span class="fu">:</span> xs) <span class="fu">=</span> <span class="dt">I</span> <span class="fu">:</span> <span class="dt">Dec</span> xs</a>
<a class="sourceLine" id="cb23-4" data-line-number="4">    <span class="dt">Dec</span> <span class="ch">&#39;[] = ???</span></a>
<a class="sourceLine" id="cb23-5" data-line-number="5">    </a>
<a class="sourceLine" id="cb23-6" data-line-number="6"><span class="ot">uncons ::</span> <span class="dt">Seq</span> ns a <span class="ot">-&gt;</span> (a, <span class="dt">Seq</span> (<span class="dt">Dec</span> ns) a)</a>
<a class="sourceLine" id="cb23-7" data-line-number="7">uncons (<span class="dt">Odd</span> x xs) <span class="fu">=</span> (x, <span class="dt">Even</span> xs)</a>
<a class="sourceLine" id="cb23-8" data-line-number="8">uncons (<span class="dt">Even</span>  xs) <span class="fu">=</span> <span class="kw">case</span> uncons xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb23-9" data-line-number="9">    ((x,y),ys) <span class="ot">-&gt;</span> (x, <span class="dt">Odd</span> y ys)</a>
<a class="sourceLine" id="cb23-10" data-line-number="10">uncons <span class="dt">Nil</span> <span class="fu">=</span> <span class="fu">???</span></a></code></pre></div>
<p>We <em>should</em> be able to write this function without returning a <code>Maybe</code>. Because we statically know the size, we can encode “only nonempty sequences”. The problem is that <code>Seq [] a</code> isn’t the only non-empty sequence: there’s also <code>Seq [O] a</code> and <code>Seq [O,O] a</code>, and so on. Our binary number system is redundant, because it contains trailing zeroes.</p>
<p>We could add some kind of proof into the data structure, but that would (again) be expensive. Instead, we can make the index <em>itself</em> correct-by-construction, by choosing a non-redundant representation of binary numbers.</p>
<p>Here’s the trick: instead of having a list of bits, we’re going to have a list of “the distance to the next one”. This eliminates the redundancy, and translates into our data structure like so:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="kw">data</span> <span class="dt">N</span> <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">|</span> <span class="dt">S</span> <span class="dt">N</span></a>
<a class="sourceLine" id="cb24-2" data-line-number="2"></a>
<a class="sourceLine" id="cb24-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Nest</span> n ns a <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-4" data-line-number="4">    <span class="dt">Odd</span><span class="ot">  ::</span> a <span class="ot">-&gt;</span> (<span class="dt">Seq</span>    ns (a,a)) <span class="ot">-&gt;</span> <span class="dt">Nest</span> <span class="dt">Z</span>     ns a</a>
<a class="sourceLine" id="cb24-5" data-line-number="5">    <span class="dt">Even</span><span class="ot"> ::</span>      (<span class="dt">Nest</span> n ns (a,a)) <span class="ot">-&gt;</span> <span class="dt">Nest</span> (<span class="dt">S</span> n) ns a</a>
<a class="sourceLine" id="cb24-6" data-line-number="6"></a>
<a class="sourceLine" id="cb24-7" data-line-number="7"><span class="kw">data</span> <span class="dt">Seq</span> ns a <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-8" data-line-number="8">    <span class="dt">Nil</span><span class="ot">  ::</span> <span class="dt">Seq</span> <span class="ch">&#39;[] a</span></a>
<a class="sourceLine" id="cb24-9" data-line-number="9">    <span class="dt">Cons</span><span class="ot"> ::</span> <span class="dt">Nest</span> n ns a <span class="ot">-&gt;</span> <span class="dt">Seq</span> (n <span class="fu">:</span> ns) a</a></code></pre></div>
<p>Lovely! Crucially for our <code>uncons</code>, we now know that any non-empty list of bits is a non-zero list of bits, so we can type “nonempty sequence” easily:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">Dec</span> (<span class="ot">n ::</span> <span class="dt">N</span>) (<span class="ot">ns ::</span> [<span class="dt">N</span>]) <span class="fu">=</span> (<span class="ot">r ::</span> [<span class="dt">N</span>]) <span class="fu">|</span> r <span class="ot">-&gt;</span> n ns <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-2" data-line-number="2">    <span class="dt">Dec</span> (<span class="dt">S</span> n) ns       <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">:</span> <span class="dt">Dec</span> n ns</a>
<a class="sourceLine" id="cb25-3" data-line-number="3">    <span class="dt">Dec</span> <span class="dt">Z</span>     <span class="ch">&#39;[]      = &#39;</span>[]</a>
<a class="sourceLine" id="cb25-4" data-line-number="4">    <span class="dt">Dec</span> <span class="dt">Z</span>     (n <span class="fu">:</span> ns) <span class="fu">=</span> <span class="dt">S</span> n <span class="fu">:</span> ns</a>
<a class="sourceLine" id="cb25-5" data-line-number="5"></a>
<a class="sourceLine" id="cb25-6" data-line-number="6"><span class="ot">uncons ::</span> <span class="dt">Seq</span> (n <span class="fu">:</span> ns) a <span class="ot">-&gt;</span> (a, <span class="dt">Seq</span> (<span class="dt">Dec</span> n ns) a)</a>
<a class="sourceLine" id="cb25-7" data-line-number="7">uncons (<span class="dt">Cons</span> xs&#39;) <span class="fu">=</span> go xs&#39;</a>
<a class="sourceLine" id="cb25-8" data-line-number="8">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-9" data-line-number="9"><span class="ot">    go ::</span> <span class="dt">Nest</span> n ns a <span class="ot">-&gt;</span> (a, <span class="dt">Seq</span> (<span class="dt">Dec</span> n ns) a)</a>
<a class="sourceLine" id="cb25-10" data-line-number="10">    go (<span class="dt">Odd</span> x <span class="dt">Nil</span>) <span class="fu">=</span> (x, <span class="dt">Nil</span>)</a>
<a class="sourceLine" id="cb25-11" data-line-number="11">    go (<span class="dt">Odd</span> x (<span class="dt">Cons</span> xs)) <span class="fu">=</span> (x, <span class="dt">Cons</span> (<span class="dt">Even</span> xs))</a>
<a class="sourceLine" id="cb25-12" data-line-number="12">    go (<span class="dt">Even</span> xs) <span class="fu">=</span> <span class="kw">case</span> go xs <span class="kw">of</span> ((x,y),ys) <span class="ot">-&gt;</span> (x, <span class="dt">Cons</span> (<span class="dt">Odd</span> y ys))</a></code></pre></div>
<p>We’re still not done, though: here’s our new type family for incrementing things.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">Inc</span> (<span class="ot">ns ::</span> [<span class="dt">N</span>])<span class="ot"> ::</span> [<span class="dt">N</span>] <span class="kw">where</span></a>
<a class="sourceLine" id="cb26-2" data-line-number="2">    <span class="dt">Inc</span> <span class="ch">&#39;[] = &#39;</span>[<span class="dt">Z</span>]</a>
<a class="sourceLine" id="cb26-3" data-line-number="3">    <span class="dt">Inc</span> (<span class="dt">S</span> n <span class="fu">:</span> ns) <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">:</span> n <span class="fu">:</span> ns</a>
<a class="sourceLine" id="cb26-4" data-line-number="4">    <span class="dt">Inc</span> (<span class="dt">Z</span>   <span class="fu">:</span> ns) <span class="fu">=</span> <span class="dt">Carry</span> (<span class="dt">Inc</span> ns)</a>
<a class="sourceLine" id="cb26-5" data-line-number="5">    </a>
<a class="sourceLine" id="cb26-6" data-line-number="6"><span class="kw">type</span> family <span class="dt">Carry</span> (<span class="ot">ns ::</span> [<span class="dt">N</span>])<span class="ot"> ::</span> [<span class="dt">N</span>] <span class="kw">where</span></a>
<a class="sourceLine" id="cb26-7" data-line-number="7">    <span class="dt">Carry</span> <span class="ch">&#39;[] = &#39;</span>[]</a>
<a class="sourceLine" id="cb26-8" data-line-number="8">    <span class="dt">Carry</span> (n <span class="fu">:</span> ns) <span class="fu">=</span> <span class="dt">S</span> n <span class="fu">:</span> ns</a></code></pre></div>
<p>The <code>Carry</code> there is ugly, and that ugliness carries into the <code>cons</code> function:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="ot">cons ::</span> a <span class="ot">-&gt;</span> <span class="dt">Seq</span> ns a <span class="ot">-&gt;</span> <span class="dt">Seq</span> (<span class="dt">Inc</span> ns) a</a>
<a class="sourceLine" id="cb27-2" data-line-number="2">cons x <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Cons</span> (<span class="dt">Odd</span> x <span class="dt">Nil</span>)</a>
<a class="sourceLine" id="cb27-3" data-line-number="3">cons x&#39; (<span class="dt">Cons</span> xs&#39;) <span class="fu">=</span> go x&#39; xs&#39;</a>
<a class="sourceLine" id="cb27-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb27-5" data-line-number="5"><span class="ot">    go ::</span> a <span class="ot">-&gt;</span> <span class="dt">Nest</span> n ns a <span class="ot">-&gt;</span> <span class="dt">Seq</span> (<span class="dt">Inc</span> (n<span class="fu">:</span>ns)) a</a>
<a class="sourceLine" id="cb27-6" data-line-number="6">    go x (<span class="dt">Even</span>  xs) <span class="fu">=</span> <span class="dt">Cons</span> (<span class="dt">Odd</span> x (<span class="dt">Cons</span> xs))</a>
<a class="sourceLine" id="cb27-7" data-line-number="7">    go x (<span class="dt">Odd</span> y <span class="dt">Nil</span>) <span class="fu">=</span> <span class="dt">Cons</span> (<span class="dt">Even</span> (<span class="dt">Odd</span> (x,y) <span class="dt">Nil</span>))</a>
<a class="sourceLine" id="cb27-8" data-line-number="8">    go x (<span class="dt">Odd</span> y (<span class="dt">Cons</span> ys)) <span class="fu">=</span> carry (go (x,y) ys)</a>
<a class="sourceLine" id="cb27-9" data-line-number="9"></a>
<a class="sourceLine" id="cb27-10" data-line-number="10"><span class="ot">    carry ::</span> <span class="dt">Seq</span> ns (a,a) <span class="ot">-&gt;</span> <span class="dt">Seq</span> (<span class="dt">Carry</span> ns) a</a>
<a class="sourceLine" id="cb27-11" data-line-number="11">    carry <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb27-12" data-line-number="12">    carry (<span class="dt">Cons</span> xs) <span class="fu">=</span> <span class="dt">Cons</span> (<span class="dt">Even</span> xs)</a></code></pre></div>
<p>To clean it up, we’re going to use another technique.</p>
<h1 id="technique-4-provide-information-on-indices-as-early-as-possible">Technique 4: Provide Information on Indices as Early as Possible</h1>
<p>You occasionally see people wonder about the usual definition of addition on Peano numbers:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb28-1" data-line-number="1"><span class="ot">_</span>+<span class="ot">_</span> <span class="ot">:</span> ℕ <span class="ot">→</span> ℕ <span class="ot">→</span> ℕ</a>
<a class="sourceLine" id="cb28-2" data-line-number="2">zero  + m <span class="ot">=</span> m</a>
<a class="sourceLine" id="cb28-3" data-line-number="3">suc n + m <span class="ot">=</span> suc <span class="ot">(</span>n + m<span class="ot">)</span></a></code></pre></div>
<p>It’s very simple, with only two equations. When someone sees the following error, then:</p>
<blockquote>
<p><code>couldn't match type n with n + 0</code></p>
</blockquote>
<p>They might be tempted to add it as an equation to the function:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb29-1" data-line-number="1"><span class="ot">_</span>+<span class="ot">_</span> <span class="ot">:</span> ℕ <span class="ot">→</span> ℕ <span class="ot">→</span> ℕ</a>
<a class="sourceLine" id="cb29-2" data-line-number="2">zero  + m    <span class="ot">=</span> m</a>
<a class="sourceLine" id="cb29-3" data-line-number="3">n     + zero <span class="ot">=</span> n</a>
<a class="sourceLine" id="cb29-4" data-line-number="4">suc n + m    <span class="ot">=</span> suc <span class="ot">(</span>n + m<span class="ot">)</span></a></code></pre></div>
<p>Similarly, when someone sees the other error commonly found with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>+</mo><annotation encoding="application/x-tex">+</annotation></semantics></math>:</p>
<blockquote>
<p><code>couldn't match type S n + m with n + S m</code></p>
</blockquote>
<p>They’ll add that equation in too! In fact, that particular equation will provide a valid definition of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>+</mo><annotation encoding="application/x-tex">+</annotation></semantics></math>:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="ot">_</span>+<span class="ot">_</span> <span class="ot">:</span> ℕ <span class="ot">→</span> ℕ <span class="ot">→</span> ℕ</a>
<a class="sourceLine" id="cb30-2" data-line-number="2">zero  + m <span class="ot">=</span> m</a>
<a class="sourceLine" id="cb30-3" data-line-number="3">suc n + m <span class="ot">=</span> n + suc m</a></code></pre></div>
<p>So why is the first definition of + the one almost always used? Because it <em>maximizes output information from minimal input</em>. Take the second implementation above, the one with the zero on the right. In this function, we have to look at the second argument in the second clause: in other words, we don’t get to find out about the output until we’ve looked at both <code>n</code> and <code>m</code>. In the usual definition, if you know the first argument is <code>suc</code> something, you also know the <em>output</em> must be <code>suc</code> something.</p>
<p>Similarly with the third implementation: we have to examine the first argument in its <em>entirety</em> before we wrap the output in a constructor. Yes, we can of course prove that they’re all equivalent, but remember: proofs are expensive, and we’re looking for speed here. So the first definition of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>+</mo><annotation encoding="application/x-tex">+</annotation></semantics></math> is our best bet, since it tells us the most without having to prove anything.</p>
<p>Looking back at our definition of <code>Inc</code>, we can actually provide more information a little sooner:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">Inc</span> (<span class="ot">ns ::</span> [<span class="dt">N</span>])<span class="ot"> ::</span> [<span class="dt">N</span>] <span class="kw">where</span></a>
<a class="sourceLine" id="cb31-2" data-line-number="2">    <span class="dt">Inc</span> <span class="ch">&#39;[] = &#39;</span>[<span class="dt">Z</span>]</a>
<a class="sourceLine" id="cb31-3" data-line-number="3">    <span class="dt">Inc</span> (<span class="dt">S</span> n <span class="fu">:</span> ns) <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">:</span> n <span class="fu">:</span> ns</a>
<a class="sourceLine" id="cb31-4" data-line-number="4">    <span class="dt">Inc</span> (<span class="dt">Z</span>   <span class="fu">:</span> ns) <span class="fu">=</span> <span class="dt">Carry</span> (<span class="dt">Inc</span> ns)</a></code></pre></div>
<p>In all of the outputs, the list is non-empty. We can encode that, by having two different functions for the head and tail of the list:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">IncHead</span> (<span class="ot">ns ::</span> [<span class="dt">N</span>])<span class="ot"> ::</span> <span class="dt">N</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-2" data-line-number="2">    <span class="dt">IncHead</span> <span class="ch">&#39;[] = Z</span></a>
<a class="sourceLine" id="cb32-3" data-line-number="3">    <span class="dt">IncHead</span> (n <span class="fu">:</span> ns) <span class="fu">=</span> <span class="dt">IncHead&#39;</span> n ns</a>
<a class="sourceLine" id="cb32-4" data-line-number="4"></a>
<a class="sourceLine" id="cb32-5" data-line-number="5"><span class="kw">type</span> family <span class="dt">IncHead&#39;</span> (<span class="ot">n ::</span> <span class="dt">N</span>) (<span class="ot">ns ::</span> [<span class="dt">N</span>])<span class="ot"> ::</span> <span class="dt">N</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-6" data-line-number="6">    <span class="dt">IncHead&#39;</span> (<span class="dt">S</span> n) ns <span class="fu">=</span> <span class="dt">Z</span></a>
<a class="sourceLine" id="cb32-7" data-line-number="7">    <span class="dt">IncHead&#39;</span> <span class="dt">Z</span> ns <span class="fu">=</span> <span class="dt">S</span> (<span class="dt">IncHead</span> ns)</a>
<a class="sourceLine" id="cb32-8" data-line-number="8"></a>
<a class="sourceLine" id="cb32-9" data-line-number="9"><span class="kw">type</span> family <span class="dt">IncTail</span> (<span class="ot">ns ::</span> [<span class="dt">N</span>])<span class="ot"> ::</span> [<span class="dt">N</span>] <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-10" data-line-number="10">    <span class="dt">IncTail</span> <span class="ch">&#39;[] = &#39;</span>[]</a>
<a class="sourceLine" id="cb32-11" data-line-number="11">    <span class="dt">IncTail</span> (n <span class="fu">:</span> ns) <span class="fu">=</span> <span class="dt">IncTail&#39;</span> n ns</a>
<a class="sourceLine" id="cb32-12" data-line-number="12"></a>
<a class="sourceLine" id="cb32-13" data-line-number="13"><span class="kw">type</span> family <span class="dt">IncTail&#39;</span> (<span class="ot">n ::</span> <span class="dt">N</span>) (<span class="ot">ns ::</span> [<span class="dt">N</span>])<span class="ot"> ::</span> [<span class="dt">N</span>] <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-14" data-line-number="14">    <span class="dt">IncTail&#39;</span> (<span class="dt">S</span> n) ns <span class="fu">=</span> n <span class="fu">:</span> ns</a>
<a class="sourceLine" id="cb32-15" data-line-number="15">    <span class="dt">IncTail&#39;</span> <span class="dt">Z</span> ns <span class="fu">=</span> <span class="dt">IncTail</span> ns</a>
<a class="sourceLine" id="cb32-16" data-line-number="16"></a>
<a class="sourceLine" id="cb32-17" data-line-number="17"><span class="kw">type</span> <span class="dt">Inc</span> (<span class="ot">ns ::</span> [<span class="dt">N</span>]) <span class="fu">=</span> <span class="dt">IncHead</span> ns <span class="fu">:</span> <span class="dt">IncTail</span> ns</a></code></pre></div>
<p>This tells the typechecker that we’re not returning an empty sequence right away, so we don’t have to pattern-match to prove it later, giving us a more efficient function.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" data-line-number="1"><span class="ot">cons ::</span> a <span class="ot">-&gt;</span> <span class="dt">Seq</span> ns a <span class="ot">-&gt;</span> <span class="dt">Seq</span> (<span class="dt">Inc</span> ns) a</a>
<a class="sourceLine" id="cb33-2" data-line-number="2">cons x&#39; xs&#39; <span class="fu">=</span> <span class="dt">Cons</span> (go x&#39; xs&#39;)</a>
<a class="sourceLine" id="cb33-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb33-4" data-line-number="4"><span class="ot">    go ::</span> a <span class="ot">-&gt;</span> <span class="dt">Seq</span> ns a <span class="ot">-&gt;</span> <span class="dt">Nest</span> (<span class="dt">IncHead</span> ns) (<span class="dt">IncTail</span> ns) a</a>
<a class="sourceLine" id="cb33-5" data-line-number="5">    go x <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Odd</span> x <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb33-6" data-line-number="6">    go x (<span class="dt">Cons</span> (<span class="dt">Even</span>  xs)) <span class="fu">=</span> <span class="dt">Odd</span> x (<span class="dt">Cons</span> xs)</a>
<a class="sourceLine" id="cb33-7" data-line-number="7">    go x (<span class="dt">Cons</span> (<span class="dt">Odd</span> y ys)) <span class="fu">=</span> <span class="dt">Even</span> (go (x,y) ys)</a></code></pre></div>
<h1 id="technique-5-lazy-proofs">Technique 5: Lazy Proofs</h1>
<p>Briefly after introducing the binary random-access list, Okasaki describes the <em>skew-binary</em> random-access list. As well as having the same indexing cost as the type above, it supports <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math> <code>cons</code>. But wait—didn’t the previous structure have <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math> <code>cons</code>? Not really. Unfortunately, in a pure functional setting, imperative-style amortization measurements aren’t always valid. Say we perform a <code>cons</code> in the worst case, and it takes <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>log</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\log n</annotation></semantics></math> time. In an imperative setting, that’s no problem, because all of the rest of the operations are not going to be on the worst-case. In a pure setting, though, the old structure is still sitting around. You can still access it, and you can still get that awful worst-case time.</p>
<p>This is where the skew binary tree comes in. It’s based on the <a href="https://en.wikipedia.org/wiki/Skew_binary_number_system">skew binary numbers</a>: these work similarly to binary, but you’re allowed have (at most) a single 2 digit before any ones. This gives you <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math> incrementing and decrementing, which is what we need here. Let’s get started.</p>
<p>First, our type-level numbers. We’re going to use the sparse encoding as above, but we need some way to encode “you’re only allowed one 2”. The most lightweight way to do it I can think of is by implicitly assuming the second number in the list of gaps is one less than the others. In other words, we encode a 2 with <code>[n, 0, m]</code>. That <code>0</code> means that at position <code>n</code> there’s a 2, not a 1.</p>
<p>The corresponding type families for increment and decrement are clearly <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math>:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">Inc</span> (<span class="ot">ns ::</span> [<span class="dt">N</span>]) <span class="fu">=</span> (<span class="ot">ms ::</span> [<span class="dt">N</span>]) <span class="fu">|</span> ms <span class="ot">-&gt;</span> ns <span class="kw">where</span></a>
<a class="sourceLine" id="cb34-2" data-line-number="2">    <span class="dt">Inc</span> <span class="ch">&#39;[]              = Z   : &#39;</span>[]</a>
<a class="sourceLine" id="cb34-3" data-line-number="3">    <span class="dt">Inc</span> (x  <span class="fu">:</span> <span class="ch">&#39;[])       = Z   : x  : &#39;</span>[]</a>
<a class="sourceLine" id="cb34-4" data-line-number="4">    <span class="dt">Inc</span> (x  <span class="fu">:</span> <span class="dt">Z</span>    <span class="fu">:</span> xs) <span class="fu">=</span> <span class="dt">S</span> x <span class="fu">:</span> xs</a>
<a class="sourceLine" id="cb34-5" data-line-number="5">    <span class="dt">Inc</span> (x1 <span class="fu">:</span> <span class="dt">S</span> x2 <span class="fu">:</span> xs) <span class="fu">=</span> <span class="dt">Z</span>   <span class="fu">:</span> x1 <span class="fu">:</span> x2 <span class="fu">:</span> xs</a>
<a class="sourceLine" id="cb34-6" data-line-number="6"></a>
<a class="sourceLine" id="cb34-7" data-line-number="7"><span class="kw">type</span> family <span class="dt">Dec</span> (<span class="ot">n ::</span> <span class="dt">N</span>) (<span class="ot">ns ::</span> [<span class="dt">N</span>]) <span class="fu">=</span> (<span class="ot">ms ::</span> [<span class="dt">N</span>]) <span class="fu">|</span> ms <span class="ot">-&gt;</span> n ns <span class="kw">where</span></a>
<a class="sourceLine" id="cb34-8" data-line-number="8">    <span class="dt">Dec</span> (<span class="dt">S</span> x)  xs            <span class="fu">=</span> x  <span class="fu">:</span> <span class="dt">Z</span> <span class="fu">:</span> xs</a>
<a class="sourceLine" id="cb34-9" data-line-number="9">    <span class="dt">Dec</span> <span class="dt">Z</span>     <span class="ch">&#39;[]            = &#39;</span>[]</a>
<a class="sourceLine" id="cb34-10" data-line-number="10">    <span class="dt">Dec</span> <span class="dt">Z</span>     (x  <span class="fu">:</span> <span class="ch">&#39;[])     = x  : &#39;</span>[]</a>
<a class="sourceLine" id="cb34-11" data-line-number="11">    <span class="dt">Dec</span> <span class="dt">Z</span>     (x1 <span class="fu">:</span> x2 <span class="fu">:</span> xs) <span class="fu">=</span> x1 <span class="fu">:</span> <span class="dt">S</span> x2 <span class="fu">:</span> xs</a></code></pre></div>
<p>We don’t need to split this into head and tail families as we did before because there’s no recursive call: we know all we’re ever going to know about the output following <em>any</em> match on the input.</p>
<p>There’s another problem before we write the implementation: we can’t use the <code>Nest</code> construction that we had before, because then the head would be buried in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>log</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\log n</annotation></semantics></math> constructors (or thereabouts). Instead, we’re going to have to use GADTs to encode the “gap” type, alongside the relevant tree. This gap type is going to be very similar to the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>≥</mo><annotation encoding="application/x-tex">\geq</annotation></semantics></math> proof we had for the modular counters, but with an extra parameter:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb35-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Gap</span> (<span class="ot">n ::</span> <span class="dt">N</span>) (<span class="ot">g ::</span> <span class="dt">N</span>) (<span class="ot">m ::</span> <span class="dt">N</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb35-2" data-line-number="2">    <span class="dt">Zy</span><span class="ot"> ::</span> <span class="dt">Gap</span> n <span class="dt">Z</span> n</a>
<a class="sourceLine" id="cb35-3" data-line-number="3">    <span class="dt">Sy</span><span class="ot"> ::</span> <span class="dt">Gap</span> n g m <span class="ot">-&gt;</span> <span class="dt">Gap</span> n (<span class="dt">S</span> g) (<span class="dt">S</span> m)</a></code></pre></div>
<p><code>Gap n g m</code> means there is a gap of <code>g</code> between <code>n</code> and <code>m</code>. Or, stated another way, it means <code>n + g = m</code>. Its inductive structure mimics the <code>g</code> parameter (it’s basically the <code>g</code> parameter itself with some added information).</p>
<p>With all of that together, here’s the definition of the array itself:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">Tree</span> (<span class="ot">n ::</span> <span class="dt">N</span>) (<span class="ot">a ::</span> <span class="dt">Type</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb36-2" data-line-number="2">    <span class="dt">Tree</span> <span class="dt">Z</span> a <span class="fu">=</span> a</a>
<a class="sourceLine" id="cb36-3" data-line-number="3">    <span class="dt">Tree</span> (<span class="dt">S</span> n) a <span class="fu">=</span> <span class="dt">Node</span> n a</a>
<a class="sourceLine" id="cb36-4" data-line-number="4"></a>
<a class="sourceLine" id="cb36-5" data-line-number="5"><span class="kw">data</span> <span class="dt">Node</span> n a <span class="fu">=</span> <span class="dt">Node</span> a (<span class="dt">Tree</span> n a) (<span class="dt">Tree</span> n a)</a>
<a class="sourceLine" id="cb36-6" data-line-number="6"></a>
<a class="sourceLine" id="cb36-7" data-line-number="7"><span class="kw">data</span> <span class="dt">SeqTail</span> (<span class="ot">n ::</span> <span class="dt">N</span>) (<span class="ot">ns ::</span> [<span class="dt">N</span>]) (<span class="ot">a ::</span> <span class="dt">Type</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb36-8" data-line-number="8">    <span class="dt">NilT</span><span class="ot">  ::</span> <span class="dt">SeqTail</span> n <span class="ch">&#39;[] a</span></a>
<a class="sourceLine" id="cb36-9" data-line-number="9">    <span class="dt">ConsT</span><span class="ot"> ::</span> <span class="dt">Gap</span> n g m</a>
<a class="sourceLine" id="cb36-10" data-line-number="10">          <span class="ot">-&gt;</span> <span class="dt">Tree</span> m a</a>
<a class="sourceLine" id="cb36-11" data-line-number="11">          <span class="ot">-&gt;</span> <span class="dt">SeqTail</span> (<span class="dt">S</span> m) ms a</a>
<a class="sourceLine" id="cb36-12" data-line-number="12">          <span class="ot">-&gt;</span> <span class="dt">SeqTail</span> n (g <span class="fu">:</span> ms) a</a>
<a class="sourceLine" id="cb36-13" data-line-number="13"></a>
<a class="sourceLine" id="cb36-14" data-line-number="14"><span class="kw">data</span> <span class="dt">Seq</span> (<span class="ot">ns ::</span> [<span class="dt">N</span>]) (<span class="ot">a ::</span> <span class="dt">Type</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb36-15" data-line-number="15">    <span class="dt">Nil</span><span class="ot">  ::</span> <span class="dt">Seq</span> <span class="ch">&#39;[] a</span></a>
<a class="sourceLine" id="cb36-16" data-line-number="16">    <span class="dt">Cons</span><span class="ot"> ::</span> <span class="dt">Gap</span> <span class="dt">Z</span> g n</a>
<a class="sourceLine" id="cb36-17" data-line-number="17">         <span class="ot">-&gt;</span> <span class="dt">Tree</span> n a</a>
<a class="sourceLine" id="cb36-18" data-line-number="18">         <span class="ot">-&gt;</span> <span class="dt">SeqTail</span> n ns a</a>
<a class="sourceLine" id="cb36-19" data-line-number="19">         <span class="ot">-&gt;</span> <span class="dt">Seq</span> (g <span class="fu">:</span> ns) a</a></code></pre></div>
<p>The <code>cons</code> operation again mimics the increment function, but there’s one final snag before it’ll typecheck:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb37-1" data-line-number="1"><span class="ot">cons ::</span> a <span class="ot">-&gt;</span> <span class="dt">Seq</span> ns a <span class="ot">-&gt;</span> <span class="dt">Seq</span> (<span class="dt">Inc</span> ns) a</a>
<a class="sourceLine" id="cb37-2" data-line-number="2">cons x <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Cons</span> <span class="dt">Zy</span> x <span class="dt">NilT</span></a>
<a class="sourceLine" id="cb37-3" data-line-number="3">cons x (<span class="dt">Cons</span> zn y <span class="dt">NilT</span>) <span class="fu">=</span> <span class="dt">Cons</span> <span class="dt">Zy</span> x (<span class="dt">ConsT</span> zn y <span class="dt">NilT</span>)</a>
<a class="sourceLine" id="cb37-4" data-line-number="4">cons x (<span class="dt">Cons</span> zn y1 (<span class="dt">ConsT</span> <span class="dt">Zy</span> y2 ys)) <span class="fu">=</span> <span class="dt">Cons</span>(<span class="dt">Sy</span> zn) (<span class="dt">Node</span> x y1 y2) ys</a>
<a class="sourceLine" id="cb37-5" data-line-number="5">cons x (<span class="dt">Cons</span> zn y1 (<span class="dt">ConsT</span> (<span class="dt">Sy</span> nm) y2 ys)) <span class="fu">=</span></a>
<a class="sourceLine" id="cb37-6" data-line-number="6">    <span class="dt">Cons</span> <span class="dt">Zy</span> x (<span class="dt">ConsT</span> zn y1 (<span class="dt">ConsT</span> <span class="fu">???</span> y2 ys))</a></code></pre></div>
<p>On the final line, the <code>???</code> is missing. In the unverified version, <code>nm</code> would slot right in there. Here, though, if we try it we get an error, which basically amounts to:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb38-1" data-line-number="1"><span class="dt">Gap</span> n g m <span class="fu">/=</span> <span class="dt">Gap</span> (<span class="dt">S</span> n) g (<span class="dt">S</span> m)</a></code></pre></div>
<p>At this point, I’d usually throw out the inductive-style proof, and replace it with a proof of equality, which I’d aggressively erase in all of the functions. I said at the beginning I wouldn’t cheat, though, so here’s what I’ll do instead:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb39-1" data-line-number="1"><span class="ot">gapr ::</span> <span class="dt">Gap</span> n g m <span class="ot">-&gt;</span> <span class="dt">Gap</span> (<span class="dt">S</span> n) g (<span class="dt">S</span> m)</a>
<a class="sourceLine" id="cb39-2" data-line-number="2">gapr <span class="dt">Zy</span>       <span class="fu">=</span> <span class="dt">Zy</span></a>
<a class="sourceLine" id="cb39-3" data-line-number="3">gapr (<span class="dt">Sy</span> pnm) <span class="fu">=</span> <span class="dt">Sy</span> (gapr pnm)</a>
<a class="sourceLine" id="cb39-4" data-line-number="4"></a>
<a class="sourceLine" id="cb39-5" data-line-number="5"><span class="ot">cons ::</span> a <span class="ot">-&gt;</span> <span class="dt">Seq</span> ns a <span class="ot">-&gt;</span> <span class="dt">Seq</span> (<span class="dt">Inc</span> ns) a</a>
<a class="sourceLine" id="cb39-6" data-line-number="6">cons x <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Cons</span> <span class="dt">Zy</span> x <span class="dt">NilT</span></a>
<a class="sourceLine" id="cb39-7" data-line-number="7">cons x (<span class="dt">Cons</span> zn y <span class="dt">NilT</span>) <span class="fu">=</span> <span class="dt">Cons</span> <span class="dt">Zy</span> x (<span class="dt">ConsT</span> zn y <span class="dt">NilT</span>)</a>
<a class="sourceLine" id="cb39-8" data-line-number="8">cons x (<span class="dt">Cons</span> zn y1 (<span class="dt">ConsT</span> <span class="dt">Zy</span> y2 ys)) <span class="fu">=</span> <span class="dt">Cons</span> (<span class="dt">Sy</span> zn) (<span class="dt">Node</span> x y1 y2) ys</a>
<a class="sourceLine" id="cb39-9" data-line-number="9">cons x (<span class="dt">Cons</span> zn y1 (<span class="dt">ConsT</span> (<span class="dt">Sy</span> nm) y2 ys)) <span class="fu">=</span></a>
<a class="sourceLine" id="cb39-10" data-line-number="10">    <span class="dt">Cons</span> <span class="dt">Zy</span> x (<span class="dt">ConsT</span> zn y1 (<span class="dt">ConsT</span> (gapr nm) y2 ys))</a></code></pre></div>
<p>At first glance, we’ve lost the complexity bounds. That <code>gapr</code> operation is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>log</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\log n</annotation></semantics></math> (or something), and we’re performing it pretty frequently. We might keep the amortized bounds, but isn’t that not really worthy in a pure setting?</p>
<p>That would all be true, if it weren’t for laziness. Because we <em>delay</em> the evaluation of <code>gapr</code>, we won’t have to pay for it all in one big thunk. In fact, because it’s basically a unary number, we only have to pay for one part of it at a time. I haven’t yet fully worked out the proofs, but I’m pretty sure we’re guaranteed <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math> worst-case time here too.</p>
<h1 id="technique-6-when-all-else-fails-prove-it-later">Technique 6: When All Else Fails, Prove it Later</h1>
<p>About a year ago, I <a href="/posts/2017-04-23-verifying-data-structures-in-haskell-lhs.html">tried</a> to write a verified version of binomial heaps, which could then be used for sorting traversable containers. Unfortunately, I couldn’t figure out how to write delete-min, and gave up. I <em>did</em> recognize that the redundancy of the binary representation was a problem, but I couldn’t figure out much more than that.</p>
<p>Now, though, we have a new non-redundant representation of binary numbers, and some handy techniques to go along with it.</p>
<p>Unfortunately, I ran into a similar roadblock in the implementation. Here’s the point where I was stuck:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb40-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Zipper</span> a n xs <span class="fu">=</span> <span class="dt">Zipper</span> a (<span class="dt">Node</span> n a) (<span class="dt">Binomial</span> n xs a)</a>
<a class="sourceLine" id="cb40-2" data-line-number="2"></a>
<a class="sourceLine" id="cb40-3" data-line-number="3"><span class="ot">slideLeft ::</span> <span class="dt">Zipper</span> a (<span class="dt">S</span> n) xs <span class="ot">-&gt;</span> <span class="dt">Zipper</span> a n (<span class="dt">Z</span> <span class="fu">:</span> xs)</a>
<a class="sourceLine" id="cb40-4" data-line-number="4">slideLeft (<span class="dt">Zipper</span> m (t <span class="fu">:&lt;</span> ts) hs) <span class="fu">=</span> <span class="dt">Zipper</span> m ts (<span class="dt">Cons</span> (<span class="dt">Odd</span> t hs))</a>
<a class="sourceLine" id="cb40-5" data-line-number="5"></a>
<a class="sourceLine" id="cb40-6" data-line-number="6"><span class="ot">minView ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Binomial</span> n (x <span class="fu">:</span> xs) a <span class="ot">-&gt;</span> (a, <span class="dt">Binomial</span> n (<span class="dt">Decr</span> x xs) a)</a>
<a class="sourceLine" id="cb40-7" data-line-number="7">minView (<span class="dt">Cons</span> xs&#39;) <span class="fu">=</span> unZipper (go xs&#39;)</a>
<a class="sourceLine" id="cb40-8" data-line-number="8">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb40-9" data-line-number="9">    unZipper (<span class="dt">Zipper</span> x _ xs) <span class="fu">=</span> (x, xs)</a>
<a class="sourceLine" id="cb40-10" data-line-number="10"></a>
<a class="sourceLine" id="cb40-11" data-line-number="11"><span class="ot">    go ::</span> forall a n x xs<span class="fu">.</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Nest</span> n x xs a <span class="ot">-&gt;</span> <span class="dt">Zipper</span> a n (<span class="dt">Decr</span> x xs)</a>
<a class="sourceLine" id="cb40-12" data-line-number="12">    go (<span class="dt">Even</span> xs) <span class="fu">=</span> slideLeft (go xs)</a>
<a class="sourceLine" id="cb40-13" data-line-number="13">    go (<span class="dt">Odd</span> (<span class="dt">Root</span> x ts) <span class="dt">Empty</span>) <span class="fu">=</span> <span class="dt">Zipper</span> x ts <span class="dt">Empty</span></a>
<a class="sourceLine" id="cb40-14" data-line-number="14">    go (<span class="dt">Odd</span> c<span class="fu">@</span>(<span class="dt">Root</span> x ts) (<span class="dt">Cons</span> xs)) <span class="fu">=</span></a>
<a class="sourceLine" id="cb40-15" data-line-number="15">        <span class="kw">case</span> go xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb40-16" data-line-number="16">            (<span class="dt">Zipper</span> m (t&#39; <span class="fu">:&lt;</span> _) hs)</a>
<a class="sourceLine" id="cb40-17" data-line-number="17">              <span class="fu">|</span> m <span class="fu">&gt;=</span> x <span class="ot">-&gt;</span> <span class="dt">Zipper</span> x ts (<span class="dt">Cons</span> (<span class="dt">Even</span> xs))</a>
<a class="sourceLine" id="cb40-18" data-line-number="18">              <span class="fu">|</span> otherwise <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb40-19" data-line-number="19">                  <span class="dt">Zipper</span> m ts</a>
<a class="sourceLine" id="cb40-20" data-line-number="20">                      (<span class="kw">case</span> hs <span class="kw">of</span></a>
<a class="sourceLine" id="cb40-21" data-line-number="21">                           <span class="dt">Empty</span> <span class="ot">-&gt;</span> <span class="dt">Cons</span> (<span class="dt">Even</span> (<span class="dt">Odd</span> (mergeTree c t&#39;) <span class="dt">Empty</span>))</a>
<a class="sourceLine" id="cb40-22" data-line-number="22">                           <span class="dt">Cons</span> hs&#39; <span class="ot">-&gt;</span> <span class="dt">Cons</span> (<span class="dt">Even</span> (carryOneNest (mergeTree c t&#39;) hs&#39;)))</a></code></pre></div>
<p>The last two lines don’t typecheck! The errors were complex, but effectively they stated:</p>
<blockquote>
<p><code>Could not deduce</code></p>
<blockquote>
<p><code class="sourceCode haskell">x <span class="fu">:</span> xs <span class="fu">~</span> [<span class="dt">Z</span>]</code></p>
</blockquote>
<p><code>from the context</code></p>
<blockquote>
<p><code class="sourceCode haskell"><span class="dt">Decr</span> x xs <span class="fu">~</span> []</code></p>
</blockquote>
</blockquote>
<p>and:</p>
<blockquote>
<p><code>Could not deduce</code></p>
<blockquote>
<p><code class="sourceCode haskell">x <span class="fu">:</span> xs <span class="fu">~</span> <span class="dt">Inc</span> (y <span class="fu">:</span> ys)</code></p>
</blockquote>
<p><code>from the context</code></p>
<blockquote>
<p><code class="sourceCode haskell"><span class="dt">Decr</span> x xs <span class="fu">~</span> y <span class="fu">:</span> ys</code></p>
</blockquote>
</blockquote>
<p>The thing is, all of those look pretty provable. So, for this technique, we first figure out what proofs we need, and <em>assume</em> we have them. This means changing <code>minView</code> to the following:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb41-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Zipper</span> a n xs <span class="fu">=</span> <span class="dt">Zipper</span> a (<span class="dt">Node</span> n a) (<span class="dt">Binomial</span> n xs a)</a>
<a class="sourceLine" id="cb41-2" data-line-number="2"></a>
<a class="sourceLine" id="cb41-3" data-line-number="3"><span class="ot">slideLeft ::</span> <span class="dt">Zipper</span> a (<span class="dt">S</span> n) xs <span class="ot">-&gt;</span> <span class="dt">Zipper</span> a n (<span class="dt">Z</span> <span class="fu">:</span> xs)</a>
<a class="sourceLine" id="cb41-4" data-line-number="4">slideLeft (<span class="dt">Zipper</span> m (t <span class="fu">:&lt;</span> ts) hs) <span class="fu">=</span> <span class="dt">Zipper</span> m ts (<span class="dt">Cons</span> (<span class="dt">Odd</span> t hs))</a>
<a class="sourceLine" id="cb41-5" data-line-number="5"></a>
<a class="sourceLine" id="cb41-6" data-line-number="6"><span class="ot">minView ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Binomial</span> n (x <span class="fu">:</span> xs) a <span class="ot">-&gt;</span> (a, <span class="dt">Binomial</span> n (<span class="dt">Decr</span> x xs) a)</a>
<a class="sourceLine" id="cb41-7" data-line-number="7">minView (<span class="dt">Cons</span> xs&#39;) <span class="fu">=</span> unZipper (go xs&#39;)</a>
<a class="sourceLine" id="cb41-8" data-line-number="8">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb41-9" data-line-number="9">    unZipper (<span class="dt">Zipper</span> x _ xs) <span class="fu">=</span> (x, xs)</a>
<a class="sourceLine" id="cb41-10" data-line-number="10"></a>
<a class="sourceLine" id="cb41-11" data-line-number="11"><span class="ot">    go ::</span> forall a n x xs<span class="fu">.</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Nest</span> n x xs a <span class="ot">-&gt;</span> <span class="dt">Zipper</span> a n (<span class="dt">Decr</span> x xs)</a>
<a class="sourceLine" id="cb41-12" data-line-number="12">    go (<span class="dt">Even</span> xs) <span class="fu">=</span> slideLeft (go xs)</a>
<a class="sourceLine" id="cb41-13" data-line-number="13">    go (<span class="dt">Odd</span> (<span class="dt">Root</span> x ts) <span class="dt">Empty</span>) <span class="fu">=</span> <span class="dt">Zipper</span> x ts <span class="dt">Empty</span></a>
<a class="sourceLine" id="cb41-14" data-line-number="14">    go (<span class="dt">Odd</span> c<span class="fu">@</span>(<span class="dt">Root</span> x ts) (<span class="dt">Cons</span> xs)) <span class="fu">=</span></a>
<a class="sourceLine" id="cb41-15" data-line-number="15">        <span class="kw">case</span> go xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb41-16" data-line-number="16">            (<span class="dt">Zipper</span> m (t&#39; <span class="fu">:&lt;</span> _) (<span class="ot">hs ::</span> <span class="dt">Binomial</span> (<span class="dt">S</span> n) (<span class="dt">Decr</span> y ys) a))</a>
<a class="sourceLine" id="cb41-17" data-line-number="17">              <span class="fu">|</span> m <span class="fu">&gt;=</span> x <span class="ot">-&gt;</span> <span class="dt">Zipper</span> x ts (<span class="dt">Cons</span> (<span class="dt">Even</span> xs))</a>
<a class="sourceLine" id="cb41-18" data-line-number="18">              <span class="fu">|</span> otherwise <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb41-19" data-line-number="19">                  <span class="dt">Zipper</span> m ts</a>
<a class="sourceLine" id="cb41-20" data-line-number="20">                      (<span class="kw">case</span> hs <span class="kw">of</span></a>
<a class="sourceLine" id="cb41-21" data-line-number="21">                           <span class="dt">Empty</span> <span class="ot">-&gt;</span> gcastWith (lemma1 <span class="fu">@</span>y <span class="fu">@</span>ys <span class="dt">Refl</span>)</a>
<a class="sourceLine" id="cb41-22" data-line-number="22">                               <span class="dt">Cons</span> (<span class="dt">Even</span> (<span class="dt">Odd</span> (mergeTree c t&#39;) <span class="dt">Empty</span>))</a>
<a class="sourceLine" id="cb41-23" data-line-number="23">                           <span class="dt">Cons</span> hs&#39; <span class="ot">-&gt;</span> gcastWith (lemma2 <span class="fu">@</span>y <span class="fu">@</span>ys <span class="dt">Refl</span>)</a>
<a class="sourceLine" id="cb41-24" data-line-number="24">                               <span class="dt">Cons</span> (<span class="dt">Even</span> (carryOneNest (mergeTree c t&#39;) hs&#39;)))</a></code></pre></div>
<p>And writing in the templates for our lemmas:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb42-1" data-line-number="1"><span class="ot">lemma1 ::</span> forall x xs<span class="fu">.</span> <span class="dt">Decr</span> x xs <span class="fu">:~:</span> <span class="ch">&#39;[] -&gt; x : xs :~: Z : &#39;</span>[]</a>
<a class="sourceLine" id="cb42-2" data-line-number="2">lemma1 <span class="fu">=</span> _</a>
<a class="sourceLine" id="cb42-3" data-line-number="3"></a>
<a class="sourceLine" id="cb42-4" data-line-number="4"><span class="ot">lemma2 ::</span> forall x xs y ys<span class="fu">.</span> <span class="dt">Decr</span> x xs <span class="fu">:~:</span> y <span class="fu">:</span> ys <span class="ot">-&gt;</span> x <span class="fu">:</span> xs <span class="fu">:~:</span> <span class="dt">Inc</span> (y <span class="fu">:</span> ys)</a>
<a class="sourceLine" id="cb42-5" data-line-number="5">lemma2 <span class="fu">=</span> _</a></code></pre></div>
<p>We now need to provide the <em>implementations</em> for <code>lemma1</code> and <code>lemma2</code>. With this approach, even if we fail to do the next steps, we can cop out here and sub in <code>unsafeCoerce Refl</code> in place of the two proofs, maintaining the efficiency. We won’t need to, though!</p>
<p>Unlike in Agda, the types for those proofs won’t be around at runtime, so we won’t have anything to pattern match on. We’ll need to look for things in the surrounding area which could act like singletons for the lemmas.</p>
<p>It turns out that the <code>xs</code> and <code>hs'</code> floating around can do exactly that: they tell us about the type-level <code>y</code> and <code>x</code>. So we just pass them to the lemmas (where they’re needed). This changes the last 4 lines of <code>minView</code> to:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb43-1" data-line-number="1"><span class="dt">Empty</span> <span class="ot">-&gt;</span> gcastWith (lemma1 <span class="dt">Refl</span> xs)</a>
<a class="sourceLine" id="cb43-2" data-line-number="2">    <span class="dt">Cons</span> (<span class="dt">Even</span> (<span class="dt">Odd</span> (mergeTree c t&#39;) <span class="dt">Empty</span>))</a>
<a class="sourceLine" id="cb43-3" data-line-number="3"><span class="dt">Cons</span> hs&#39; <span class="ot">-&gt;</span> gcastWith (lemma2 <span class="dt">Refl</span> xs hs&#39;)</a>
<a class="sourceLine" id="cb43-4" data-line-number="4">    <span class="dt">Cons</span> (<span class="dt">Even</span> (carryOneNest (mergeTree c t&#39;) hs&#39;))</a></code></pre></div>
<p>Now, we just have to fill in the lemmas! If we were lucky, they’d actually be constant-time.</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb44-1" data-line-number="1"><span class="ot">lemma1 ::</span> forall x xs n a<span class="fu">.</span> <span class="dt">Decr</span> x xs <span class="fu">:~:</span> <span class="ch">&#39;[]</span></a>
<a class="sourceLine" id="cb44-2" data-line-number="2">       <span class="ot">-&gt;</span>  <span class="dt">Nest</span> n x xs a</a>
<a class="sourceLine" id="cb44-3" data-line-number="3">       <span class="ot">-&gt;</span> x <span class="fu">:</span> xs <span class="fu">:~:</span> <span class="dt">Z</span> <span class="fu">:</span> <span class="ch">&#39;[]</span></a>
<a class="sourceLine" id="cb44-4" data-line-number="4">lemma1 <span class="dt">Refl</span> (<span class="dt">Odd</span> _ <span class="dt">Empty</span>) <span class="fu">=</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb44-5" data-line-number="5"></a>
<a class="sourceLine" id="cb44-6" data-line-number="6"><span class="ot">lemma2 ::</span> forall x xs y ys n a<span class="fu">.</span></a>
<a class="sourceLine" id="cb44-7" data-line-number="7">          <span class="dt">Decr</span> x xs <span class="fu">:~:</span> y <span class="fu">:</span> ys</a>
<a class="sourceLine" id="cb44-8" data-line-number="8">       <span class="ot">-&gt;</span> <span class="dt">Nest</span> n x xs a</a>
<a class="sourceLine" id="cb44-9" data-line-number="9">       <span class="ot">-&gt;</span> <span class="dt">Nest</span> n y ys a</a>
<a class="sourceLine" id="cb44-10" data-line-number="10">       <span class="ot">-&gt;</span> x <span class="fu">:</span> xs <span class="fu">:~:</span> <span class="dt">Inc</span> (y <span class="fu">:</span> ys)</a>
<a class="sourceLine" id="cb44-11" data-line-number="11">lemma2 <span class="dt">Refl</span> (<span class="dt">Even</span> (<span class="dt">Odd</span> _ <span class="dt">Empty</span>)) (<span class="dt">Odd</span> _ <span class="dt">Empty</span>) <span class="fu">=</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb44-12" data-line-number="12">lemma2 <span class="dt">Refl</span> (<span class="dt">Odd</span> _ (<span class="dt">Cons</span> _)) (<span class="dt">Even</span> _) <span class="fu">=</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb44-13" data-line-number="13">lemma2 <span class="dt">Refl</span> (<span class="dt">Even</span> xs) (<span class="dt">Odd</span> _ (<span class="dt">Cons</span> ys)) <span class="fu">=</span></a>
<a class="sourceLine" id="cb44-14" data-line-number="14">  gcastWith (lemma2 <span class="dt">Refl</span> xs ys) <span class="dt">Refl</span></a></code></pre></div>
<p>If they <em>had</em> been constant-time, that would have let us throw them out: each proof would essentially show you what cases needed to be scrutinized to satisfy the typechecker. You then just scrutinize those cases in the actual function, and it should all typecheck.</p>
<p>As it is, <code>lemma2</code> is actually ok. It does cost <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log n)</annotation></semantics></math>, but so does <code>carryOneNest</code>: we’ve maintained the complexity! We <em>could</em> stop here, satisfied.</p>
<p>There’s another option, though, one that I picked up from Stephanie Weirich’s talk <span class="citation" data-cites="weirich_dependent_2017">(<a href="#ref-weirich_dependent_2017">2017</a>)</span>: you thread the requirement through the function as an equality constraint. It won’t always work, but when your function’s call graph matches that of the proof, the constraint will indeed be satisfied, with no runtime cost. In this case, we can whittle down the proof obligation to the following:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb45-1" data-line-number="1"><span class="dt">Inc</span> (<span class="dt">Decr</span> x xs) <span class="fu">~</span> (x <span class="fu">:</span> xs)</a></code></pre></div>
<p>Now we change the recursive <code>go</code> into continuation-passing style, and add that constraint to its signature, and everything works!</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb46-1" data-line-number="1"><span class="ot">minView ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Binomial</span> n (x <span class="fu">:</span> xs) a <span class="ot">-&gt;</span> (a, <span class="dt">Binomial</span> n (<span class="dt">Decr</span> x xs) a)</a>
<a class="sourceLine" id="cb46-2" data-line-number="2">minView (<span class="dt">Cons</span> xs&#39;) <span class="fu">=</span> go xs&#39; \(<span class="dt">Zipper</span> x _ xs) <span class="ot">-&gt;</span> (x,xs)</a>
<a class="sourceLine" id="cb46-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb46-4" data-line-number="4"><span class="ot">    go ::</span> <span class="dt">Ord</span> a</a>
<a class="sourceLine" id="cb46-5" data-line-number="5">       <span class="ot">=&gt;</span> <span class="dt">Nest</span> n x xs a</a>
<a class="sourceLine" id="cb46-6" data-line-number="6">       <span class="ot">-&gt;</span> (<span class="dt">Inc</span> (<span class="dt">Decr</span> x xs) <span class="fu">~</span> (x <span class="fu">:</span> xs) <span class="ot">=&gt;</span> <span class="dt">Zipper</span> a n (<span class="dt">Decr</span> x xs) <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb46-7" data-line-number="7">    go (<span class="dt">Even</span> xs) k <span class="fu">=</span> go xs \(<span class="dt">Zipper</span> m (t <span class="fu">:&lt;</span> ts) hs) <span class="ot">-&gt;</span> k (<span class="dt">Zipper</span> m ts (<span class="dt">Cons</span> (<span class="dt">Odd</span> t hs)))</a>
<a class="sourceLine" id="cb46-8" data-line-number="8">    go (<span class="dt">Odd</span> (<span class="dt">Root</span> x ts) <span class="dt">Empty</span>) k <span class="fu">=</span> k (<span class="dt">Zipper</span> x ts <span class="dt">Empty</span>)</a>
<a class="sourceLine" id="cb46-9" data-line-number="9">    go (<span class="dt">Odd</span> c<span class="fu">@</span>(<span class="dt">Root</span> x cs) (<span class="dt">Cons</span> xs)) k <span class="fu">=</span></a>
<a class="sourceLine" id="cb46-10" data-line-number="10">        go xs</a>
<a class="sourceLine" id="cb46-11" data-line-number="11">            \<span class="kw">case</span></a>
<a class="sourceLine" id="cb46-12" data-line-number="12">                <span class="dt">Zipper</span> m _ _ <span class="fu">|</span> m <span class="fu">&gt;=</span> x <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb46-13" data-line-number="13">                    k (<span class="dt">Zipper</span> x cs (<span class="dt">Cons</span> (<span class="dt">Even</span> xs)))</a>
<a class="sourceLine" id="cb46-14" data-line-number="14">                <span class="dt">Zipper</span> m (t <span class="fu">:&lt;</span> ts) <span class="dt">Empty</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb46-15" data-line-number="15">                    k (<span class="dt">Zipper</span> m ts (<span class="dt">Cons</span> (<span class="dt">Even</span> (<span class="dt">Odd</span> (mergeTree c t) <span class="dt">Empty</span>))))</a>
<a class="sourceLine" id="cb46-16" data-line-number="16">                <span class="dt">Zipper</span> m (t <span class="fu">:&lt;</span> ts) (<span class="dt">Cons</span> hs) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb46-17" data-line-number="17">                    k (<span class="dt">Zipper</span> m ts (<span class="dt">Cons</span> (<span class="dt">Even</span> (carryOneNest (mergeTree c t) hs))))</a></code></pre></div>
<h1 id="conclusion">Conclusion</h1>
<p>As I mentioned in the beginning, a huge amount of this stuff is <em>much</em> easier using other systems. On top of that, there’s currently a lot of work being done on dependent type erasure, so that proofs like the above don’t even exist at runtime. In other words, there’s a chance that all of these techniques will soon be useless!</p>
<p>Efficient proof-carrying code makes for an interesting puzzle, though, even if it is a bit of a hair shirt.</p>
<h1 id="code">Code</h1>
<p>Fuller implementations of the structures here are in <a href="https://github.com/oisdk/pure-arrays">this</a> git repository.</p>
<h1 id="references" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-bakst_liquidhaskell_2018">
<p>Bakst, Alexander, Ranjit Jhala, Ming Kawaguchi, Patrick Rondon, Eric Seidel, Michael Smith, Anish Tondwalkar, Chris Tetreault, and Niki Vazou. 2018. “LiquidHaskell: Liquid Types For Haskell.” ucsd-progsys. <a href="https://github.com/ucsd-progsys/liquidhaskell" class="uri">https://github.com/ucsd-progsys/liquidhaskell</a>.</p>
</div>
<div id="ref-ben-amram_pointers_1992">
<p>Ben-Amram, Amir M., and Zvi Galil. 1992. “On Pointers Versus Addresses.” <em>J. ACM</em> 39 (3) (July): 617–648. doi:<a href="https://doi.org/10.1145/146637.146666">10.1145/146637.146666</a>. <a href="http://doi.acm.org/10.1145/146637.146666" class="uri">http://doi.acm.org/10.1145/146637.146666</a>.</p>
</div>
<div id="ref-breitner_ready_2018-1">
<p>Breitner, Joachim, Antal Spector-Zabusky, Yao Li, Christine Rizkallah, John Wiegley, and Stephanie Weirich. 2018. “Ready, Set, Verify! Applying Hs-to-coq to Real-world Haskell Code (Experience Report).” <em>Proc. ACM Program. Lang.</em> 2 (ICFP) (July): 89:1–89:16. doi:<a href="https://doi.org/10.1145/3236784">10.1145/3236784</a>. <a href="http://doi.acm.org/10.1145/3236784" class="uri">http://doi.acm.org/10.1145/3236784</a>.</p>
</div>
<div id="ref-hinze_numerical_1998">
<p>Hinze, Ralf. 1998. <em>Numerical Representations as Higher-Order Nested Datatypes</em>. Institut für Informatik III, Universität Bonn. <a href="http://www.cs.ox.ac.uk/ralf.hinze/publications/\#R5" class="uri">http://www.cs.ox.ac.uk/ralf.hinze/publications/\#R5</a>.</p>
</div>
<div id="ref-hinze_perfect_1999">
<p>———. 1999. <em>Perfect Trees and Bit-reversal Permutations</em>.</p>
</div>
<div id="ref-komuves_nested-sequence_2016">
<p>Komuves, Balazs, and Peter Divianszky. 2016. “Nested-sequence: List-like data structures with O(Log(n)) random access.” <a href="http://hackage.haskell.org/package/nested-sequence" class="uri">http://hackage.haskell.org/package/nested-sequence</a>.</p>
</div>
<div id="ref-mcbride_how_2014">
<p>McBride, Conor Thomas. 2014. “How to Keep Your Neighbours in Order.” In <em>Proceedings of the 19th ACM SIGPLAN International Conference on Functional Programming</em>, 297–309. ICFP ’14. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/2628136.2628163">10.1145/2628136.2628163</a>. <a href="https://personal.cis.strath.ac.uk/conor.mcbride/pub/Pivotal.pdf" class="uri">https://personal.cis.strath.ac.uk/conor.mcbride/pub/Pivotal.pdf</a>.</p>
</div>
<div id="ref-might_missing_2015">
<p>Might, Matthew. 2015. “Missing method: How to delete from Okasaki’s red-black trees.” <em>matt.might.net</em>. <a href="http://matt.might.net/articles/red-black-delete/" class="uri">http://matt.might.net/articles/red-black-delete/</a>.</p>
</div>
<div id="ref-okasaki_fast_1999">
<p>Okasaki, Chris. 1999a. “From Fast Exponentiation to Square Matrices: An Adventure in Types.” In <em>Proceedings of the ACM SIGPLAN International Conference on Functional Programming (ICFP’99), Paris, France, September 27-29, 1999</em>, 34:28. ACM. <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.456.357\&amp;rep=rep1\&amp;type=pdf" class="uri">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.456.357\&amp;rep=rep1\&amp;type=pdf</a>.</p>
</div>
<div id="ref-okasaki_purely_1999">
<p>———. 1999b. <em>Purely Functional Data Structures</em>. Cambridge University Press.</p>
</div>
<div id="ref-weirich_depending_2014">
<p>Weirich, Stephanie. 2014. “Depending on Types.” In <em>Proceedings of the 19th ACM SIGPLAN International Conference on Functional Programming</em>, 241–241. ICFP ’14. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/2628136.2631168">10.1145/2628136.2631168</a>. <a href="https://www.cis.upenn.edu/~sweirich/talks/icfp14.pdf" class="uri">https://www.cis.upenn.edu/~sweirich/talks/icfp14.pdf</a>.</p>
</div>
<div id="ref-weirich_dependent_2017">
<p>———. 2017. “Dependent Types in Haskell.” St. Louis, MO, USA. <a href="https://www.youtube.com/watch?v=wNa3MMbhwS4" class="uri">https://www.youtube.com/watch?v=wNa3MMbhwS4</a>.</p>
</div>
</div>
]]></description>
    <pubDate>Tue, 20 Nov 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-11-20-fast-verified-structures.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>A Very Simple Prime Sieve in Haskell</title>
    <link>https://doisinkidney.com/posts/2018-11-10-a-very-simple-prime-sieve.html</link>
    <description><![CDATA[<div class="info">
    Posted on November 10, 2018
</div>
<div class="info">
    
        Part 1 of a <a href="/series/Prime%20Sieves.html">2-part series on Prime Sieves</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<p>A few days ago, the <a href="https://www.youtube.com/user/Computerphile">Computerphile YouTube channel</a> put up a video about infinite lists in Haskell <span class="citation" data-cites="haran_infinity_2018">(Haran <a href="#ref-haran_infinity_2018">2018</a>)</span>. It’s pretty basic, but finishes up with a definition of an infinite list of prime numbers. The definition was something like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1">primes <span class="fu">=</span> sieve [<span class="dv">2</span><span class="fu">..</span>]</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">sieve (p<span class="fu">:</span>ps) <span class="fu">=</span> p <span class="fu">:</span> sieve [ x <span class="fu">|</span> x <span class="ot">&lt;-</span> ps, mod x p <span class="fu">/=</span> <span class="dv">0</span> ]</a></code></pre></div>
<p>This really demonstrates the elegance of list comprehensions coupled with lazy evaluation. If we’re being totally pedantic, however, this <em>isn’t</em> a genuine <a href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes">sieve of Eratosthenes</a>. And this makes sense: the “true” sieve of Eratosthenes <span class="citation" data-cites="oneill_genuine_2009">(O’Neill <a href="#ref-oneill_genuine_2009">2009</a>)</span> is probably too complex to demonstrate in a video meant to be an introduction to Haskell. This isn’t because Haskell is bad at this particular problem, mind you: it’s because a lazy, infinite sieve is something very hard to implement indeed.</p>
<p>Anyway, I’m going to try today to show a very simple prime sieve that (hopefully) rivals the simplicity of the definition above.</p>
<h1 id="a-first-attempt">A First Attempt</h1>
<p>Visualizations of the sieve of Eratosthenes often rely on metaphors of “crossing out” on some large table. Once you hit a prime, you cross off all of its multiples in the rest of the table, and then you move to the next crossed-off number.</p>
<figure>
<img src="https://upload.wikimedia.org/wikipedia/commons/0/0b/Sieve_of_Eratosthenes_animation.svg" alt="Sieve of Eratosthenes Animation. By Ricordisamoa, CC BY-SA 3.0, from Wikimedia Commons" /><figcaption>Sieve of Eratosthenes Animation. By Ricordisamoa, CC BY-SA 3.0, from Wikimedia Commons</figcaption>
</figure>
<p>Working with a finite array, it should be easy to see that this is extremely efficient. You’re crossing off every non-prime exactly once, only using addition and squaring.</p>
<p>To extend it to infinite lists, we will use the following function:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1">[] \\ ys <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">xs \\ [] <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">(x<span class="fu">:</span>xs) \\ (y<span class="fu">:</span>ys) <span class="fu">=</span> <span class="kw">case</span> compare x y <span class="kw">of</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">    <span class="dt">LT</span> <span class="ot">-&gt;</span> x <span class="fu">:</span> xs \\ (y<span class="fu">:</span>ys)</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">    <span class="dt">EQ</span> <span class="ot">-&gt;</span> xs \\ ys</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">    <span class="dt">GT</span> <span class="ot">-&gt;</span> (x<span class="fu">:</span>xs) \\ ys</a></code></pre></div>
<p>We’re “subtracting” the right list from the left. Crucially, it works with infinite lists:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> take <span class="dv">10</span> ([<span class="dv">1</span><span class="fu">..</span>] \\ [<span class="dv">2</span>,<span class="dv">4</span><span class="fu">..</span>])</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">[<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">7</span>,<span class="dv">9</span>,<span class="dv">11</span>,<span class="dv">13</span>,<span class="dv">15</span>,<span class="dv">17</span>,<span class="dv">19</span>]</a></code></pre></div>
<p>Finally, it only works if both lists are ordered and don’t contain duplicates, but our sieve does indeed satisfy that requirement. Using this, we’ve already got a sieve:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">sieve (p<span class="fu">:</span>ps) <span class="fu">=</span> p <span class="fu">:</span> sieve (ps \\ [p<span class="fu">*</span>p, p<span class="fu">*</span>p<span class="fu">+</span>p<span class="fu">..</span>])</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">primes <span class="fu">=</span> <span class="dv">2</span> <span class="fu">:</span> sieve [<span class="dv">3</span>,<span class="dv">5</span><span class="fu">..</span>]</a></code></pre></div>
<p>No division, just addition and squaring, as promised. Unfortunately, though, this doesn’t have the time complexity we want. See, in the <code>(\\)</code> operation, we have to test every entry in the sieve against the prime factor: when we’re crossing off from an array, we just jump to the next composite number.</p>
<h1 id="using-a-queue">Using a Queue</h1>
<p>The way we speed up the “crossing-off” section of the algorithms is by using a priority queue: this was the optimization provided in <span class="citation" data-cites="oneill_genuine_2009">O’Neill (<a href="#ref-oneill_genuine_2009">2009</a>)</span>. Before we go any further, then, let’s put one together:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:-</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Queue</span> a b <span class="fu">=</span> <span class="dt">Queue</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">    {<span class="ot"> minKey ::</span> <span class="fu">!</span>a</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">    ,<span class="ot"> minVal ::</span> b</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">    ,<span class="ot"> rest   ::</span> <span class="dt">List</span> a b</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">    }</a>
<a class="sourceLine" id="cb5-7" data-line-number="7"></a>
<a class="sourceLine" id="cb5-8" data-line-number="8"><span class="kw">data</span> <span class="dt">List</span> a b</a>
<a class="sourceLine" id="cb5-9" data-line-number="9">    <span class="fu">=</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb5-10" data-line-number="10">    <span class="fu">|</span> (<span class="fu">:-</span>) <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span>(<span class="dt">Queue</span> a b)</a>
<a class="sourceLine" id="cb5-11" data-line-number="11">           (<span class="dt">List</span> a b)</a>
<a class="sourceLine" id="cb5-12" data-line-number="12"></a>
<a class="sourceLine" id="cb5-13" data-line-number="13"></a>
<a class="sourceLine" id="cb5-14" data-line-number="14"><span class="ot">(&lt;+&gt;) ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Queue</span> a b <span class="ot">-&gt;</span> <span class="dt">Queue</span> a b <span class="ot">-&gt;</span> <span class="dt">Queue</span> a b</a>
<a class="sourceLine" id="cb5-15" data-line-number="15">(<span class="fu">&lt;+&gt;</span>) q1<span class="fu">@</span>(<span class="dt">Queue</span> x1 y1 ts1) q2<span class="fu">@</span>(<span class="dt">Queue</span> x2 y2 ts2)</a>
<a class="sourceLine" id="cb5-16" data-line-number="16">  <span class="fu">|</span> x1 <span class="fu">&lt;=</span> x2 <span class="fu">=</span> <span class="dt">Queue</span> x1 y1 (q2 <span class="fu">:-</span> ts1)</a>
<a class="sourceLine" id="cb5-17" data-line-number="17">  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Queue</span> x2 y2 (q1 <span class="fu">:-</span> ts2)</a>
<a class="sourceLine" id="cb5-18" data-line-number="18"></a>
<a class="sourceLine" id="cb5-19" data-line-number="19"><span class="ot">mergeQs ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">List</span> a b <span class="ot">-&gt;</span> <span class="dt">Queue</span> a b</a>
<a class="sourceLine" id="cb5-20" data-line-number="20">mergeQs (t <span class="fu">:-</span> ts) <span class="fu">=</span> mergeQs1 t ts</a>
<a class="sourceLine" id="cb5-21" data-line-number="21">mergeQs <span class="dt">Nil</span>       <span class="fu">=</span> errorWithoutStackTrace <span class="st">&quot;tried to merge empty list&quot;</span></a>
<a class="sourceLine" id="cb5-22" data-line-number="22"></a>
<a class="sourceLine" id="cb5-23" data-line-number="23"><span class="ot">mergeQs1 ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Queue</span> a b <span class="ot">-&gt;</span> <span class="dt">List</span> a b <span class="ot">-&gt;</span> <span class="dt">Queue</span> a b</a>
<a class="sourceLine" id="cb5-24" data-line-number="24">mergeQs1 t1 <span class="dt">Nil</span>              <span class="fu">=</span> t1</a>
<a class="sourceLine" id="cb5-25" data-line-number="25">mergeQs1 t1 (t2 <span class="fu">:-</span> <span class="dt">Nil</span>)      <span class="fu">=</span> t1 <span class="fu">&lt;+&gt;</span> t2</a>
<a class="sourceLine" id="cb5-26" data-line-number="26">mergeQs1 t1 (t2 <span class="fu">:-</span> t3 <span class="fu">:-</span> ts) <span class="fu">=</span> (t1 <span class="fu">&lt;+&gt;</span> t2) <span class="fu">&lt;+&gt;</span> mergeQs1 t3 ts</a>
<a class="sourceLine" id="cb5-27" data-line-number="27"></a>
<a class="sourceLine" id="cb5-28" data-line-number="28"><span class="ot">insert ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Queue</span> a b <span class="ot">-&gt;</span> <span class="dt">Queue</span> a b</a>
<a class="sourceLine" id="cb5-29" data-line-number="29">insert <span class="fu">!</span>k <span class="fu">!</span>v <span class="fu">=</span> (<span class="fu">&lt;+&gt;</span>) (singleton k v)</a>
<a class="sourceLine" id="cb5-30" data-line-number="30"></a>
<a class="sourceLine" id="cb5-31" data-line-number="31"><span class="ot">singleton ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Queue</span> a b</a>
<a class="sourceLine" id="cb5-32" data-line-number="32">singleton <span class="fu">!</span>k <span class="fu">!</span>v <span class="fu">=</span> <span class="dt">Queue</span> k v <span class="dt">Nil</span></a></code></pre></div>
<p>These are pairing heaps: I’m using them here because they’re relatively simple and very fast. A lot of their speed comes from the fact that the top-level constructor (<code>Queue</code>) is <em>non-empty</em>. Since, in this algorithm, we’re only actually going to be working with non-empty queues, this saves us a pattern match on pretty much every function. They’re also what’s used in <a href="https://github.com/haskell/containers/blob/30ccbaa201043109bf1ee905c66ccd0dbe24422f/containers/src/Data/Sequence/Internal/sorting.md">Data.Sequence for sorting</a>.</p>
<p>With that, we can write our proper sieve:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1">insertPrime x xs <span class="fu">=</span> insert (x<span class="fu">*</span>x) (map (<span class="fu">*</span>x) xs)</a>
<a class="sourceLine" id="cb6-2" data-line-number="2"></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">adjust x q<span class="fu">@</span>(<span class="dt">Queue</span> y (z<span class="fu">:</span>zs) qs)</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">  <span class="fu">|</span> y <span class="fu">&lt;=</span> x <span class="fu">=</span> adjust x (insert z zs (mergeQs qs))</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">  <span class="fu">|</span> otherwise <span class="fu">=</span> q</a>
<a class="sourceLine" id="cb6-6" data-line-number="6"></a>
<a class="sourceLine" id="cb6-7" data-line-number="7">sieve (x<span class="fu">:</span>xs) <span class="fu">=</span> x <span class="fu">:</span> sieve&#39; xs (singleton (x<span class="fu">*</span>x) (map (<span class="fu">*</span>x) xs))</a>
<a class="sourceLine" id="cb6-8" data-line-number="8">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-9" data-line-number="9">    sieve&#39; (x<span class="fu">:</span>xs) table</a>
<a class="sourceLine" id="cb6-10" data-line-number="10">      <span class="fu">|</span> minKey table <span class="fu">&lt;=</span> x <span class="fu">=</span> sieve&#39; xs (adjust x table)</a>
<a class="sourceLine" id="cb6-11" data-line-number="11">      <span class="fu">|</span> otherwise <span class="fu">=</span> x <span class="fu">:</span> sieve&#39; xs (insertPrime x xs table)</a>
<a class="sourceLine" id="cb6-12" data-line-number="12">      </a>
<a class="sourceLine" id="cb6-13" data-line-number="13">primes <span class="fu">=</span> <span class="dv">2</span> <span class="fu">:</span> sieve [<span class="dv">3</span>,<span class="dv">5</span><span class="fu">..</span>]</a></code></pre></div>
<h1 id="simplifying">Simplifying</h1>
<p>The priority queue stores lists alongside their keys: what you might notice is that those lists are simply sequences of the type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mi>x</mi><mo>,</mo><mn>2</mn><mi>x</mi><mo>,</mo><mn>3</mn><mi>x</mi><mo>,</mo><mn>4</mn><mi>x</mi><mi>.</mi><mi>.</mi><mi>.</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[x, 2x, 3x, 4x...]</annotation></semantics></math> and so on. Rather than storing the whole list, we can instead store just the head and the step. This also simplifies (and greatly speeds up) the expensive <code>map (*x)</code> operation to just <em>two</em> multiplications. If you wanted, you could just sub in this representation of streams for all the lists above:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Stepper</span> a <span class="fu">=</span> <span class="dt">Stepper</span> {<span class="ot"> start ::</span> a,<span class="ot"> step ::</span> a }</a>
<a class="sourceLine" id="cb7-2" data-line-number="2"></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="ot">nextStep ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Stepper</span> a <span class="ot">-&gt;</span> (a, <span class="dt">Stepper</span> a)</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">nextStep (<span class="dt">Stepper</span> x y) <span class="fu">=</span> (x, <span class="dt">Stepper</span> (x<span class="fu">+</span>y) y)</a>
<a class="sourceLine" id="cb7-5" data-line-number="5"></a>
<a class="sourceLine" id="cb7-6" data-line-number="6">pattern x <span class="fu">:-</span> xs <span class="ot">&lt;-</span> (nextStep <span class="ot">-&gt;</span> (x,xs))</a>
<a class="sourceLine" id="cb7-7" data-line-number="7"></a>
<a class="sourceLine" id="cb7-8" data-line-number="8"><span class="ot">(^*) ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Stepper</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Stepper</span> a</a>
<a class="sourceLine" id="cb7-9" data-line-number="9"><span class="dt">Stepper</span> x y <span class="fu">^*</span> f <span class="fu">=</span> <span class="dt">Stepper</span> (x <span class="fu">*</span> f) (y <span class="fu">*</span> f)</a></code></pre></div>
<p>If you were so inclined, you could even make it conform to <code>Foldable</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Stepper</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">    <span class="dt">Stepper</span><span class="ot"> ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Stepper</span> a</a>
<a class="sourceLine" id="cb8-3" data-line-number="3"></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">nextStep (<span class="dt">Stepper</span> x y) <span class="fu">=</span> (x, <span class="dt">Stepper</span> (x<span class="fu">+</span>y) y)</a>
<a class="sourceLine" id="cb8-5" data-line-number="5"></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">pattern x <span class="fu">:-</span> xs <span class="ot">&lt;-</span> (nextStep <span class="ot">-&gt;</span> (x,xs))</a>
<a class="sourceLine" id="cb8-7" data-line-number="7"></a>
<a class="sourceLine" id="cb8-8" data-line-number="8"><span class="kw">instance</span> <span class="dt">Foldable</span> <span class="dt">Stepper</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-9" data-line-number="9">    foldr f b (x <span class="fu">:-</span> xs) <span class="fu">=</span> f x (foldr f b xs)</a></code></pre></div>
<p>But that’s overkill for what we need here.</p>
<p>Second observation is that if we remove the wheel (from 2), the “start” is simply the <em>key</em> in the priority queue, again cutting down on space.</p>
<p>Finally, we get the implementation:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1">primes <span class="fu">=</span> <span class="dv">2</span> <span class="fu">:</span> sieve <span class="dv">3</span> (singleton <span class="dv">4</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">    adjust <span class="fu">!</span>x q<span class="fu">@</span>(<span class="dt">Queue</span> y z qs)</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">        <span class="fu">|</span> x <span class="fu">&lt;</span> y <span class="fu">=</span> q</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">        <span class="fu">|</span> otherwise <span class="fu">=</span> adjust x (mergeQs1 (singleton (y <span class="fu">+</span> z) z) qs)</a>
<a class="sourceLine" id="cb9-6" data-line-number="6">    sieve <span class="fu">!</span>x q</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">        <span class="fu">|</span> x <span class="fu">&lt;</span> minKey q <span class="fu">=</span> x <span class="fu">:</span> sieve (x <span class="fu">+</span> <span class="dv">1</span>) (insert (x <span class="fu">*</span> x) x q)</a>
<a class="sourceLine" id="cb9-8" data-line-number="8">        <span class="fu">|</span> otherwise <span class="fu">=</span> sieve (x <span class="fu">+</span> <span class="dv">1</span>) (adjust x q)</a></code></pre></div>
<p>8 lines for a lazy prime sieve isn’t bad!</p>
<p>I haven’t tried a huge amount to optimize the function, but it might be worth looking in to how to add back the wheels. I noticed that for no wheels, the queue contains only two elements per key; for one (the 2 wheel), we needed 3. I wonder if this pattern continues: possibly we could represent wheels as finite lists at each key in the queue. Maybe in a later post.</p>
<div id="refs" class="references">
<div id="ref-haran_infinity_2018">
<p>Haran, Brady. 2018. “To Infinity &amp; Beyond - Computerphile.” <a href="https://www.youtube.com/watch?v=bnRNiE_OVWA&amp;feature=youtu.be" class="uri">https://www.youtube.com/watch?v=bnRNiE_OVWA&amp;feature=youtu.be</a>.</p>
</div>
<div id="ref-oneill_genuine_2009">
<p>O’Neill, Melissa E. 2009. “The Genuine Sieve of Eratosthenes.” <em>Journal of Functional Programming</em> 19 (01) (January): 95. doi:<a href="https://doi.org/10.1017/S0956796808007004">10.1017/S0956796808007004</a>.</p>
</div>
</div>
]]></description>
    <pubDate>Sat, 10 Nov 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-11-10-a-very-simple-prime-sieve.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Total Combinations</title>
    <link>https://doisinkidney.com/posts/2018-10-16-total-combinations.html</link>
    <description><![CDATA[<div class="info">
    Posted on October 16, 2018
</div>
<div class="info">
    
        Part 1 of a <a href="/series/Total%20Combinatorics.html">1-part series on Total Combinatorics</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Agda.html">Agda</a>, <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<p>Here’s a quick puzzle: from a finite alphabet, produce an infinite list of infinite strings, each of them unique.</p>
<p>It’s not a super hard problem, but here are some examples of what you might get. Given the alphabet of <code>0</code> and <code>1</code>, for instance, you could produce the following:</p>
<pre><code>0000000...
1000000...
0100000...
1100000...
0010000...
1010000...
0110000...
1110000...
0001000...</code></pre>
<p>In other words, the enumeration of the binary numbers (least-significant-digit first). We’ll just deal with bits first:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Bit</span> <span class="fu">=</span> <span class="dt">O</span> <span class="fu">|</span> <span class="dt">I</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Bit</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">    showsPrec _ <span class="dt">O</span> <span class="fu">=</span> (<span class="fu">:</span>) <span class="ch">&#39;0&#39;</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5">    showsPrec _ <span class="dt">I</span> <span class="fu">=</span> (<span class="fu">:</span>) <span class="ch">&#39;1&#39;</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6">    showList xs s <span class="fu">=</span> foldr f s xs</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8">        f <span class="dt">O</span> a <span class="fu">=</span> <span class="ch">&#39;0&#39;</span> <span class="fu">:</span> a</a>
<a class="sourceLine" id="cb2-9" data-line-number="9">        f <span class="dt">I</span> a <span class="fu">=</span> <span class="ch">&#39;1&#39;</span> <span class="fu">:</span> a</a></code></pre></div>
<p>Thinking recursively, we can see that the tail of each list is actually the original sequence, doubled-up:</p>
<p><code class="sourceCode"> 0<span class="er">000000</span>... <br/> 1<span class="er">000000</span>... <br/> 0<span class="er">100000</span>... <br/> 1<span class="er">100000</span>... <br/> 0<span class="er">010000</span>... <br/> 1<span class="er">010000</span>... <br/> 0<span class="er">110000</span>... <br/> 1<span class="er">110000</span>... <br/> 0<span class="er">001000</span>... <br/> </code></p>
<p>As it happens, we get something like this pattern with the monad instance for lists <em>anyway</em>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> (,) <span class="fu">&lt;$&gt;</span> [<span class="dt">O</span>,<span class="dt">I</span>] <span class="fu">&lt;*&gt;</span> <span class="st">&quot;abc&quot;</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">[(<span class="dv">0</span>,<span class="ch">&#39;a&#39;</span>),(<span class="dv">0</span>,<span class="ch">&#39;b&#39;</span>),(<span class="dv">0</span>,<span class="ch">&#39;c&#39;</span>),(<span class="dv">1</span>,<span class="ch">&#39;a&#39;</span>),(<span class="dv">1</span>,<span class="ch">&#39;b&#39;</span>),(<span class="dv">1</span>,<span class="ch">&#39;c&#39;</span>)]</a></code></pre></div>
<p>Well, actually it’s the wrong way around. We want to loop through the <em>first</em> list the quickest, incrementing the second slower. No worries, we can just use a flipped version of <code>&lt;*&gt;</code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">infixl</span> <span class="dv">4</span> <span class="fu">&lt;&lt;&gt;</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="ot">(&lt;&lt;&gt;) ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">fs <span class="fu">&lt;&lt;&gt;</span> xs <span class="fu">=</span> flip (<span class="fu">$</span>) <span class="fu">&lt;$&gt;</span> xs <span class="fu">&lt;*&gt;</span> fs</a>
<a class="sourceLine" id="cb4-4" data-line-number="4"></a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="fu">&gt;&gt;&gt;</span> (,) <span class="fu">&lt;$&gt;</span> [<span class="dt">O</span>,<span class="dt">I</span>] <span class="fu">&lt;&lt;&gt;</span> <span class="st">&quot;abc&quot;</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">[(<span class="dv">0</span>,<span class="ch">&#39;a&#39;</span>),(<span class="dv">1</span>,<span class="ch">&#39;a&#39;</span>),(<span class="dv">0</span>,<span class="ch">&#39;b&#39;</span>),(<span class="dv">1</span>,<span class="ch">&#39;b&#39;</span>),(<span class="dv">0</span>,<span class="ch">&#39;c&#39;</span>),(<span class="dv">1</span>,<span class="ch">&#39;c&#39;</span>)]</a></code></pre></div>
<p>Brilliant! So we can write our function now, yes?</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1">bins <span class="fu">=</span> (<span class="fu">:</span>) <span class="fu">&lt;$&gt;</span> [<span class="dt">O</span>,<span class="dt">I</span>] <span class="fu">&lt;&lt;&gt;</span> bins</a></code></pre></div>
<p>Nope! That won’t ever produce an answer, unfortunately.</p>
<h1 id="productivity">Productivity</h1>
<p>The issue with our definition above is that it’s not lazy enough: it demands information that it hasn’t produced yet, so it gets caught in an infinite loop before it can do anything!</p>
<p>We need to kick-start it a little, so it can produce output <em>before</em> it asks itself for more. Because we know what the first line is going to be, we can just tell it that:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1">bins <span class="fu">=</span> (<span class="fu">:</span>) <span class="fu">&lt;$&gt;</span> [<span class="dt">O</span>,<span class="dt">I</span>] <span class="fu">&lt;&lt;&gt;</span> (repeat <span class="dt">O</span> <span class="fu">:</span> tail bins)</a>
<a class="sourceLine" id="cb6-2" data-line-number="2"></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="fu">&gt;&gt;&gt;</span> mapM_ print (take <span class="dv">8</span> (map (take <span class="dv">3</span>) bins))</a>
<a class="sourceLine" id="cb6-4" data-line-number="4"><span class="dv">000</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5"><span class="dv">100</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6"><span class="dv">010</span></a>
<a class="sourceLine" id="cb6-7" data-line-number="7"><span class="dv">110</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8"><span class="dv">001</span></a>
<a class="sourceLine" id="cb6-9" data-line-number="9"><span class="dv">101</span></a>
<a class="sourceLine" id="cb6-10" data-line-number="10"><span class="dv">011</span></a>
<a class="sourceLine" id="cb6-11" data-line-number="11"><span class="dv">111</span></a></code></pre></div>
<p>The property that this function has that the previous didn’t is <em>productivity</em>: the dual of termination. See, we want to avoid a <em>kind</em> of infinite loops in <code>bins</code>, but we don’t want to avoid infinite things altogether: the list it produces is meant to be infinite, for goodness’ sake. Instead, what it needs to do is produce every new value in <em>finite</em> time.</p>
<h1 id="checking-productivity">Checking Productivity</h1>
<p>In total languages, like Agda, termination checking is a must. To express computation like that above, though, you often also want a <em>productivity</em> checker. Agda can do that, too.</p>
<p>Let’s get started then. First, a stream:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">5</span> <span class="ot">_</span>◂<span class="ot">_</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="kw">record</span> Stream <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  <span class="kw">coinductive</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">  <span class="kw">constructor</span> <span class="ot">_</span>◂<span class="ot">_</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5">  <span class="kw">field</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6">    head <span class="ot">:</span> A</a>
<a class="sourceLine" id="cb7-7" data-line-number="7">    tail <span class="ot">:</span> Stream A</a>
<a class="sourceLine" id="cb7-8" data-line-number="8"><span class="kw">open</span> Stream</a></code></pre></div>
<p>In Haskell, there was no need to define a separate stream type: the type of lists contains both finite and infinite lists.</p>
<p>Agda can get a little more specific: here, we’ve used the <code>coinductive</code> keyword, which means we’re free to create infinite <code>Stream</code>s. Rather than the usual termination checking (which would kick in when we consume a recursive, inductive type), we now get productivity checking: when creating a <code>Stream</code>, the <code>tail</code> must always be available in finite time. For a finite type, we’d have used the <code>inductive</code> keyword instead; this wouldn’t be much use, though, since there’s no way to create a finite <code>Stream</code> without a nil constructor!<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a></p>
<p>One of the interesting things about working with infinite data (when you’re forced to notice that it’s infinite, as you are in Agda) is that <em>everything</em> gets flipped. So you have to prove productivity, not totality; you use product types, rather than sums; and to define functions, you use <em>co</em>patterns, rather than patterns.</p>
<h1 id="copatterns">Copatterns</h1>
<p>Copatterns are a handy syntactic construct for writing functions about record types. Let’s start with an example, and then I’ll try explain a little:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb8-1" data-line-number="1">pure <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">→</span> A <span class="ot">→</span> Stream A</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">head <span class="ot">(</span>pure x<span class="ot">)</span> <span class="ot">=</span> x</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">tail <span class="ot">(</span>pure x<span class="ot">)</span> <span class="ot">=</span> pure x</a></code></pre></div>
<p>Here, we’re defining <code>pure</code> on streams: <code>pure x</code> produces an infinite stream of <code>x</code>. Its equivalent would be repeat in Haskell:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1">repeat<span class="ot"> ::</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">repeat x <span class="fu">=</span> x <span class="fu">:</span> repeat x</a></code></pre></div>
<p>Except instead of describing what it <em>is</em>, you describe how it <em>acts</em> (it’s kind of an intensional vs. extensional thing). In other words, if you want to make a stream <code>xs</code>, you have to answer the questions “what’s the head of <code>xs</code>?” and “what’s the tail of <code>xs</code>?”</p>
<p>Contrast this with pattern-matching: we’re producing (rather than consuming) a value, and in pattern matching, you have to answer a question for each <em>case</em>. If you want to consume a list <code>xs</code>, you have to answer the questions “what do you do when it’s nil?” and “what do you do when it’s cons?”</p>
<p>Anyway, I think the symmetry is kind of cool. Let’s get back to writing our functions.</p>
<h1 id="sized-types">Sized Types</h1>
<p>Unfortunately, we don’t have enough to prove productivity yet. As an explanation why, let’s first try produce the famous <code>fibs</code> list. Written here in Haskell:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">fibs <span class="fu">=</span> <span class="dv">0</span> <span class="fu">:</span> <span class="dv">1</span> <span class="fu">:</span> zipWith (<span class="fu">+</span>) fibs (tail fibs)</a></code></pre></div>
<p>Instead of <code>zipWith</code>, let’s define <code>&lt;*&gt;</code>. That will let us use <a href="https://agda.readthedocs.io/en/v2.5.4.1/language/syntactic-sugar.html#idiom-brackets">idiom brackets</a>.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">_</span>&lt;*&gt;<span class="ot">_</span> <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>a b<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">{</span>B <span class="ot">:</span> <span class="dt">Set</span> b<span class="ot">}</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2">      <span class="ot">→</span> Stream <span class="ot">(</span>A <span class="ot">→</span> B<span class="ot">)</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">      <span class="ot">→</span> Stream A</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">      <span class="ot">→</span> Stream B</a>
<a class="sourceLine" id="cb11-5" data-line-number="5">head <span class="ot">(</span>fs &lt;*&gt; xs<span class="ot">)</span> <span class="ot">=</span> head fs <span class="ot">(</span>head xs<span class="ot">)</span></a>
<a class="sourceLine" id="cb11-6" data-line-number="6">tail <span class="ot">(</span>fs &lt;*&gt; xs<span class="ot">)</span> <span class="ot">=</span> tail fs &lt;*&gt; tail xs</a></code></pre></div>
<p>And here’s <code>fibs</code>:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb12-1" data-line-number="1">fibs <span class="ot">:</span> Stream ℕ</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">head fibs <span class="ot">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">head <span class="ot">(</span>tail fibs<span class="ot">)</span> <span class="ot">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">tail <span class="ot">(</span>tail fibs<span class="ot">)</span> <span class="ot">=</span> ⦇ fibs + tail fibs ⦈</a></code></pre></div>
<p>But it doesn’t pass the productivity checker! Because we use a higher-order function (<code>&lt;*&gt;</code>), Agda won’t look at how much it dips into the infinite supply of values. This is a problem: we need it to know that <code>&lt;*&gt;</code> only needs the heads of its arguments to produce a head, and so on. The solution? Encode this information in the types.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">5</span> <span class="ot">_</span>◂<span class="ot">_</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2"><span class="kw">record</span> Stream <span class="ot">{</span>i <span class="ot">:</span> Size<span class="ot">}</span> <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">  <span class="kw">coinductive</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4">  <span class="kw">constructor</span> <span class="ot">_</span>◂<span class="ot">_</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5">  <span class="kw">field</span></a>
<a class="sourceLine" id="cb13-6" data-line-number="6">    head <span class="ot">:</span> A</a>
<a class="sourceLine" id="cb13-7" data-line-number="7">    tail <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>j <span class="ot">:</span> Size&lt; i<span class="ot">}</span> <span class="ot">→</span> Stream <span class="ot">{</span>j<span class="ot">}</span> A</a>
<a class="sourceLine" id="cb13-8" data-line-number="8"><span class="kw">open</span> Stream</a></code></pre></div>
<p>Now, <code>Stream</code> has an implicit <em>size</em> parameter. Basically, <code>Stream {i} A</code> can produce <code>i</code> more values. So <code>cons</code>, then, gives a stream one extra value to produce:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb14-1" data-line-number="1">cons <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>i a<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">→</span> A <span class="ot">→</span> Stream <span class="ot">{</span>i<span class="ot">}</span> A <span class="ot">→</span> Stream <span class="ot">{</span>↑ i<span class="ot">}</span> A</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">head <span class="ot">(</span>cons x xs<span class="ot">)</span> <span class="ot">=</span> x</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">tail <span class="ot">(</span>cons x xs<span class="ot">)</span> <span class="ot">=</span> xs</a></code></pre></div>
<p>Conversely, we can write a different definition of <code>tail</code> that consumes one value<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb15-1" data-line-number="1">tail′ <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>i a<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">→</span> Stream <span class="ot">{</span>↑ i<span class="ot">}</span> A <span class="ot">→</span> Stream <span class="ot">{</span>i<span class="ot">}</span> A</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">tail′ <span class="ot">{</span>i<span class="ot">}</span> xs <span class="ot">=</span> tail xs <span class="ot">{</span>i<span class="ot">}</span></a></code></pre></div>
<p>For <code>&lt;*&gt;</code>, we want to show that its result can produce just as much values as its inputs can:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="ot">_</span>&lt;*&gt;<span class="ot">_</span> <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>i a b<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">{</span>B <span class="ot">:</span> <span class="dt">Set</span> b<span class="ot">}</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2">      <span class="ot">→</span> Stream <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">(</span>A <span class="ot">→</span> B<span class="ot">)</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3">      <span class="ot">→</span> Stream <span class="ot">{</span>i<span class="ot">}</span> A</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">      <span class="ot">→</span> Stream <span class="ot">{</span>i<span class="ot">}</span> B</a>
<a class="sourceLine" id="cb16-5" data-line-number="5">head <span class="ot">(</span>fs &lt;*&gt; xs<span class="ot">)</span> <span class="ot">=</span> head fs <span class="ot">(</span>head xs<span class="ot">)</span></a>
<a class="sourceLine" id="cb16-6" data-line-number="6">tail <span class="ot">(</span>fs &lt;*&gt; xs<span class="ot">)</span> <span class="ot">=</span> tail fs &lt;*&gt; tail xs</a></code></pre></div>
<p>How does this help the termination/productivity checker? Well, for terminating functions, we have to keep giving the <code>tail</code> field smaller and smaller sizes, meaning that we’ll eventually hit zero (and terminate). For productivity, we now have a way to talk about “definedness” in types, so we can make sure that a recursive call doesn’t dip into a supply it hasn’t produced yet.</p>
<p>One more thing: <code>Size</code> types have strange typing rules, mainly for ergonomic purposes (this is why we’re not just using an <code>ℕ</code> parameter). One of them is that if you don’t specify the size, it’s defaulted to <code>∞</code>, so functions written without size annotations don’t have to be changed with this new definition:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb17-1" data-line-number="1">pure <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">→</span> A <span class="ot">→</span> Stream A</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">head <span class="ot">(</span>pure x<span class="ot">)</span> <span class="ot">=</span> x</a>
<a class="sourceLine" id="cb17-3" data-line-number="3">tail <span class="ot">(</span>pure x<span class="ot">)</span> <span class="ot">=</span> pure x</a></code></pre></div>
<p>Finally <code>fibs</code>:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb18-1" data-line-number="1">fibs <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">→</span> Stream <span class="ot">{</span>i<span class="ot">}</span> ℕ</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">head fibs <span class="ot">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3">head <span class="ot">(</span>tail fibs<span class="ot">)</span> <span class="ot">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb18-4" data-line-number="4">tail <span class="ot">(</span>tail fibs<span class="ot">)</span> <span class="ot">=</span> ⦇ fibs + tail fibs ⦈</a></code></pre></div>
<h1 id="bugs">Bugs!</h1>
<p>Before I show the Agda solution, I’d like to point out some bugs that were revealed in the Haskell version by trying to implement it totally. First of all, the function signature. “Takes an alphabet and produces unique strings” seems like this:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="ot">strings ::</span> [a] <span class="ot">-&gt;</span> [[a]]</a></code></pre></div>
<p>But what should you produce in this case:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1">strings []</a></code></pre></div>
<p>So it must be a non-empty list, giving us the following type and definition:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="ot">strings ::</span> <span class="dt">NonEmpty</span> a <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">strings (x <span class="fu">:|</span> xs) <span class="fu">=</span> (<span class="fu">:</span>) <span class="fu">&lt;$&gt;</span> (x<span class="fu">:</span>xs) <span class="fu">&lt;&lt;&gt;</span> (repeat x <span class="fu">:</span> tail (strings (x <span class="fu">:|</span> xs)))</a></code></pre></div>
<p>But this has a bug too! What happens if we pass in the following:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1">strings (x <span class="fu">:|</span> [])</a></code></pre></div>
<p>So this fails the specification: there is only one unique infinite string from that alphabet (<code>pure x</code>). Interestingly, though, our implementation above also won’t produce any output beyond the first element. I suppose, in a way, these things cancel each other out: our function does indeed produce all of the unique strings, it’s just a pity that it goes into an infinite loop to do so!</p>
<h1 id="bringing-it-all-together">Bringing it all Together</h1>
<p>Finally, we have our function:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb23-1" data-line-number="1">strings <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>i a<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">→</span> A × A × List A <span class="ot">→</span> Stream <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">(</span>Stream A<span class="ot">)</span></a>
<a class="sourceLine" id="cb23-2" data-line-number="2">head <span class="ot">(</span>strings <span class="ot">(</span>x , <span class="ot">_</span> , <span class="ot">_))</span> <span class="ot">=</span> pure x</a>
<a class="sourceLine" id="cb23-3" data-line-number="3">tail <span class="ot">(</span>strings <span class="ot">{</span>A <span class="ot">=</span> A<span class="ot">}</span> xs<span class="ot">@(</span>x₁ , x₂ , xt<span class="ot">))</span> <span class="ot">=</span> go x₂ xt <span class="ot">(</span>strings xs<span class="ot">)</span></a>
<a class="sourceLine" id="cb23-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-5" data-line-number="5">  go <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">→</span> A <span class="ot">→</span> List A <span class="ot">→</span> Stream <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">(</span>Stream A<span class="ot">)</span> <span class="ot">→</span> Stream <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">(</span>Stream A<span class="ot">)</span></a>
<a class="sourceLine" id="cb23-6" data-line-number="6">  head <span class="ot">(</span>head <span class="ot">(</span>go y ys zs<span class="ot">))</span> <span class="ot">=</span> y</a>
<a class="sourceLine" id="cb23-7" data-line-number="7">  tail <span class="ot">(</span>head <span class="ot">(</span>go y ys zs<span class="ot">))</span> <span class="ot">=</span> head zs</a>
<a class="sourceLine" id="cb23-8" data-line-number="8">  tail <span class="ot">(</span>go <span class="ot">_</span> [] zs<span class="ot">)</span> <span class="ot">=</span> go x₁ <span class="ot">(</span>x₂ ∷ xt<span class="ot">)</span> <span class="ot">(</span>tail zs<span class="ot">)</span></a>
<a class="sourceLine" id="cb23-9" data-line-number="9">  tail <span class="ot">(</span>go <span class="ot">_</span> <span class="ot">(</span>y ∷ ys<span class="ot">)</span> zs<span class="ot">)</span> <span class="ot">=</span> go y ys zs</a></code></pre></div>
<p>As you can see, we do need to kick-start it without a recursive call (the first line is <code>pure x</code>). Then, <code>go</code> takes as a third argument the “tails” argument, and does the kind of backwards Cartesian product we want. However, since we’re into the second element of the stream now, we want to avoid repeating what we already said, which is why we have to give <code>go</code> <code>x₂</code>, rather than <code>x₁</code>. This is what forces us to take at least two elements, rather than at least one, also: we can’t just take the tail of the call to <code>go</code> (this is what we did in the Haskell version of <code>strings</code> with the <code>NonEmpty</code> list), as the recursive call to strings then doesn’t decrease in size:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb24-1" data-line-number="1">strings <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>i a<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">→</span> A × List A <span class="ot">→</span> Stream <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">(</span>Stream A<span class="ot">)</span></a>
<a class="sourceLine" id="cb24-2" data-line-number="2">head <span class="ot">(</span>strings <span class="ot">(</span>x , <span class="ot">_))</span> <span class="ot">=</span> pure x</a>
<a class="sourceLine" id="cb24-3" data-line-number="3">tail <span class="ot">(</span>strings <span class="ot">{</span>A <span class="ot">=</span> A<span class="ot">}</span> xs<span class="ot">@(</span>x , xt<span class="ot">))</span> <span class="ot">=</span> tail <span class="ot">(</span>go x xt <span class="ot">(</span>strings xs<span class="ot">))</span></a>
<a class="sourceLine" id="cb24-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-5" data-line-number="5">  go <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">→</span> A <span class="ot">→</span> List A <span class="ot">→</span> Stream <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">(</span>Stream A<span class="ot">)</span> <span class="ot">→</span> Stream <span class="ot">{</span>i<span class="ot">}</span> <span class="ot">(</span>Stream A<span class="ot">)</span></a>
<a class="sourceLine" id="cb24-6" data-line-number="6">  head <span class="ot">(</span>head <span class="ot">(</span>go y ys zs<span class="ot">))</span> <span class="ot">=</span> y</a>
<a class="sourceLine" id="cb24-7" data-line-number="7">  tail <span class="ot">(</span>head <span class="ot">(</span>go y ys zs<span class="ot">))</span> <span class="ot">=</span> head zs</a>
<a class="sourceLine" id="cb24-8" data-line-number="8">  tail <span class="ot">(</span>go <span class="ot">_</span> [] zs<span class="ot">)</span> <span class="ot">=</span> go x xt <span class="ot">(</span>tail zs<span class="ot">)</span></a>
<a class="sourceLine" id="cb24-9" data-line-number="9">  tail <span class="ot">(</span>go <span class="ot">_</span> <span class="ot">(</span>y ∷ ys<span class="ot">)</span> zs<span class="ot">)</span> <span class="ot">=</span> go y ys zs</a></code></pre></div>
<p>Agda will warn about termination on this function. Now, if you slap a pragma on it, it <em>will</em> produce the correct results for enough arguments, but give it one and you’ll get an infinite loop, just as you were warned!</p>
<h1 id="further-work">Further Work</h1>
<p>I’m having a lot of fun with copatterns for various algorithms (especially combinatorics). I’m planning on working on two particular tasks with them for the next posts in this series:</p>
<dl>
<dt>Proving <code>strings</code></dt>
<dd><p>I’d like to prove that <code>strings</code> does indeed produce a stream of unique values. Following from that, it would be cool to do a Cantor diagonalisation on its output.</p>
</dd>
<dt>Permutations</dt>
<dd><p>Haskell’s <a href="http://hackage.haskell.org/package/base-4.12.0.0/docs/src/Data.OldList.html#permutations">permutations implementation in Data.List</a> does some interesting tricks to make it as lazy as possible. It would be great to write an implementation that is verified to be as lazy as possible: the pattern of “definedness” is complex, though, so I don’t know if it’s possible with Agda’s current sized types.</p>
</dd>
</dl>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Thanks to <a href="http://gelisam.blogspot.com/">gelisam</a> for pointing out the poor phrasing here. Updated on 2018/10/16<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>You might wonder why the definition of <code>tail</code> doesn’t have this signature to begin with. The reason is that our record type must be <em>parameterized</em> (not indexed) over its size (as it’s a record type), so we use a less-than proof instead.<a href="#fnref2" class="footnote-back">↩</a></p></li>
</ol>
</section>
]]></description>
    <pubDate>Tue, 16 Oct 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-10-16-total-combinations.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Agda Beginner(-ish) Tips, Tricks, and Pitfalls</title>
    <link>https://doisinkidney.com/posts/2018-09-20-agda-tips.html</link>
    <description><![CDATA[<div class="info">
    Posted on September 20, 2018
</div>
<div class="info">
    
        Part 1 of a <a href="/series/Agda%20Tips.html">2-part series on Agda Tips</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Agda.html">Agda</a>
    
</div>

<p>I’m in the middle of quite a large Agda project at the moment, and I’ve picked up a few tips and tricks in the past few weeks. I’d imagine a lot of these are quite obvious once you get to grips with Agda, so I’m writing them down before I forget that they were once confusing stumbling blocks. Hopefully this helps other people trying to learn the language!</p>
<h1 id="parameterized-modules-strangeness">Parameterized Modules Strangeness</h1>
<p>Agda lets you parameterize modules, just as you can datatypes, with types, values, etc. It’s extremely handy for those situations where you want to be generic over some type, but that type won’t change inside the generic code. The keys to dictionaries is a good example: you can start the module with:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">module</span> Map <span class="ot">(</span>Key <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">(</span>Ordering <span class="ot">:</span> Ord Key<span class="ot">)</span> <span class="kw">where</span></a></code></pre></div>
<p>And now, where in Haskell you’d have to write something like <code>Ord a =&gt; Map a</code>… in pretty much any function signature, you can just refer to <code>Key</code>, and you’re good to go. It’s kind of like a dynamic type synonym, in that way.</p>
<p>Here’s the strangeness, though: what if you don’t supply one of the arguments?</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">import</span> Map</a></code></pre></div>
<p>This won’t give you a type error, strange as it may seem. This will perform <em>lambda lifting</em>, meaning that now, every function exported by the module will have the type signature:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">(</span>Key <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">(</span>Ordering <span class="ot">:</span> Ord Key<span class="ot">)</span> <span class="ot">...</span></a></code></pre></div>
<p>Preceding its normal signature. In other words, it changes it into what you would have had to write in Haskell.</p>
<p>This is a powerful feature, but it can also give you some confusing errors if you don’t know about it (especially if the module has implicit arguments).</p>
<h1 id="auto">Auto</h1>
<p>If you’ve got a hole in your program, you can put the cursor in it and press <code>SPC-m-a</code> (in spacemacs), and Agda will try and find the automatic solution to the problem. For a while, I didn’t think much of this feature, as rare was the program which Agda could figure out. Turns out I was just using it wrong! Into the hole you should type the options for the proof search: enabling case-splitting (<code>-c</code>), enabling the use of available definitions (<code>-r</code>), and listing possible solutions (<code>-l</code>).</p>
<h1 id="well-founded-recursion">Well-Founded Recursion</h1>
<p>Often, a program will not be obviously terminating (according to Agda’s termination checker). The first piece of advice is this: <em>don’t</em> use well-founded recursion. It’s a huge hammer, and often you can get away with fiddling with the function (try inlining definitions, rewriting generic functions to monomorphic versions, or replacing with-blocks with helper functions), or using one of the <a href="https://gallais.github.io/blog/termination-tricks.html">more lightweight techniques</a> out there.</p>
<p>However, sometimes it really is the best option, so you have to grit your teeth and use it. What I expected (and what I used originally) was a recursion combinator, with a type something like:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb4-1" data-line-number="1">wf-rec <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>a b<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">{</span>B <span class="ot">:</span> <span class="dt">Set</span> b<span class="ot">}</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">       <span class="ot">→</span> <span class="ot">((</span>x <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">→</span> <span class="ot">((</span>y <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">→</span> y &lt; x <span class="ot">→</span> B<span class="ot">)</span> <span class="ot">→</span> B<span class="ot">)</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">       <span class="ot">→</span> A <span class="ot">→</span> B</a></code></pre></div>
<p>So we’re trying to generate a function of type <code>A → B</code>, but there’s a hairy recursive call in there somewhere. Instead we use this function, and pass it a version of our function that uses the supplied function rather than making a recursive call:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb5-1" data-line-number="1">terminating <span class="ot">:</span> A <span class="ot">→</span> B</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">terminating <span class="ot">=</span> wf-rec <span class="ot">(λ</span> x recursive-call <span class="ot">→</span> <span class="ot">...)</span></a></code></pre></div>
<p>In other words, instead of calling the function itself, you call <code>recursive-call</code> above. Along with the argument, you supply a proof that it’s smaller than the outer argument (<code>y &lt; x</code>; assume for now that the definition of <code>&lt;</code> is just some relation like <a href="https://github.com/agda/agda-stdlib/blob/442cd8a06b63f7e3550af55fb75c9d345c6ddb8f/src/Data/Nat/Base.agda#L31"><code>_&lt;_</code> in Data.Nat</a>).</p>
<p>But wait! You don’t have to use it! Instead of all that, you can just pass the <code>Acc _&lt;_ x</code> type as a parameter to your function. In other words, if you have a dangerous function:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb6-1" data-line-number="1">f <span class="ot">:</span> A <span class="ot">→</span> B</a></code></pre></div>
<p>Instead write:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb7-1" data-line-number="1">f-step <span class="ot">:</span> <span class="ot">(</span>x <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">→</span> Acc <span class="ot">_</span>&lt;<span class="ot">_</span> x <span class="ot">→</span> B</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">f-step <span class="ot">=</span> <span class="ot">...</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">f <span class="ot">:</span> A <span class="ot">→</span> B</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">f x <span class="ot">=</span> f-step x <span class="ot">...</span></a></code></pre></div>
<p>Once you pattern match on the accessibility relation, the termination checker is satisfied. This is much easier to understand (for me anyway), and made it <em>much</em> easier to write proofs about it.</p>
<p>Thanks to <a href="http://oleg.fi">Oleg Grenrus (phadej)</a> on irc for helping me out with this! Funnily enough, he actually recommended the <code>Acc</code> approach, and I instead originally went with the recursion combinator. Would have saved a couple hours if I’d just listened! Also worth mentioning is the approach recommended by <a href="https://gallais.github.io">Guillaume Allais (gallais)</a>, detailed <a href="https://gallais.github.io/agdarsec/Induction.Nat.Strong.html">here</a>. Haven’t had time to figure it out, so this article may be updated to recommend it instead in the future.</p>
<h1 id="dont-touch-the-green-slime">Don’t Touch The Green Slime!</h1>
<p>This one is really important. If I hadn’t read the exact explanation <a href="https://twitter.com/pigworker/status/1013535783234473984">here</a> I think I may have given up with Agda (or at the very least the project I’m working on) out of frustration.</p>
<p>Basically the problem arises like this. Say you’re writing a function to split a vector in two. You can specify the type pretty precisely:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb8-1" data-line-number="1">split <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>a n m<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span> <span class="ot">→</span> Vec A <span class="ot">(</span>n + m<span class="ot">)</span> <span class="ot">→</span> Vec A n × Vec A m</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">split xs <span class="ot">=</span> <span class="ot">{!!}</span></a></code></pre></div>
<p>Try to pattern-match on <code>xs</code>, though, and you’ll get the following error:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb9-1" data-line-number="1">I&#39;m not sure if there should be a case for the <span class="kw">constructor</span> [],</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">because I get stuck when trying <span class="kw">to</span> solve the following unification</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">problems <span class="ot">(</span>inferred index ≟ expected index<span class="ot">):</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4">  zero ≟ n + m</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">when checking that the expression ? has type Vec <span class="ot">.</span>A <span class="ot">.</span>n × Vec <span class="ot">.</span>A <span class="ot">.</span>m</a></code></pre></div>
<p>What?! That’s weird. Anyway, you fiddle around with the function, end up pattern matching on the <code>n</code> instead, and continue on with your life.</p>
<p>What about this, though: you want to write a type for proofs that one number is less than or equal to another. You go with something like this:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">infix</span> <span class="dv">4</span> <span class="ot">_</span>≤<span class="ot">_</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="kw">data</span> <span class="ot">_</span>≤<span class="ot">_</span> <span class="ot">(</span>n <span class="ot">:</span> ℕ<span class="ot">)</span> <span class="ot">:</span> ℕ <span class="ot">→</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  proof <span class="ot">:</span> <span class="ot">∀</span> k <span class="ot">→</span> n ≤ n + k</a></code></pre></div>
<p>And you want to use it in a proof. Here’s the example we’ll be using: if two numbers are less than some limit <code>u</code>, then their maximum is also less than that limit:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb11-1" data-line-number="1">max <span class="ot">:</span> ℕ <span class="ot">→</span> ℕ <span class="ot">→</span> ℕ</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">max zero m <span class="ot">=</span> m</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">max <span class="ot">(</span>suc n<span class="ot">)</span> zero <span class="ot">=</span> suc n</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">max <span class="ot">(</span>suc n<span class="ot">)</span> <span class="ot">(</span>suc m<span class="ot">)</span> <span class="ot">=</span> suc <span class="ot">(</span>max n m<span class="ot">)</span></a>
<a class="sourceLine" id="cb11-5" data-line-number="5"></a>
<a class="sourceLine" id="cb11-6" data-line-number="6">max-≤ <span class="ot">:</span> <span class="ot">∀</span> n m <span class="ot">{</span>u<span class="ot">}</span> <span class="ot">→</span> n ≤ u <span class="ot">→</span> m ≤ u <span class="ot">→</span> max n m ≤ u</a>
<a class="sourceLine" id="cb11-7" data-line-number="7">max-≤ n m <span class="ot">(</span>proof k<span class="ot">)</span> m≤u <span class="ot">=</span> <span class="ot">{!!}</span></a></code></pre></div>
<p>It won’t let you match on <code>m≤u</code>! Here’s the error:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb12-1" data-line-number="1">I&#39;m not sure if there should be a case for the <span class="kw">constructor</span> proof,</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">because I get stuck when trying <span class="kw">to</span> solve the following unification</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">problems <span class="ot">(</span>inferred index ≟ expected index<span class="ot">):</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">  m₁ + k₂ ≟ n₁ + k₁</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">when checking that the expression ? has type max n m ≤ n + k</a></code></pre></div>
<p>What do you <em>mean</em> you’re not sure if there’s a case for the constructor <code>proof</code>: it’s the <em>only</em> case!</p>
<p>The problem is that Agda is trying to <em>unify</em> two types who both have calls to user-defined functions in them, which is a hard problem. As phrased by Conor McBride:</p>
<blockquote>
<p>When combining prescriptive and descriptive indices, ensure both are in constructor form. Exclude defined functions which yield difficult unification problems.</p>
</blockquote>
<p>So if you ever get the “I’m not sure if…” error, try either to:</p>
<ol>
<li>Redefine the indices so they use constructors, not functions.</li>
<li>Remove the index, instead having a proof inside the type of equality. What does that mean? Basically, transform the definition of <code>≤</code> above into <a href="https://github.com/agda/agda-stdlib/blob/442cd8a06b63f7e3550af55fb75c9d345c6ddb8f/src/Data/Nat/Base.agda#L72-L76">the one in Data.Nat</a>.</li>
</ol>
<h1 id="inspect">Inspect</h1>
<p>The use-case I had for this is a little long, I’m afraid (too long to include here), but it <em>did</em> come in handy. Basically, if you’re trying to prove something about a function, you may well want to <em>run</em> that function and pattern match on the result.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb13-1" data-line-number="1">f-is-the-same-as-g <span class="ot">:</span> <span class="ot">∀</span> x <span class="ot">→</span> f x ≡ g x</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">f-is-the-same-as-g x <span class="kw">with</span> f x</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">f-is-the-same-as-g x <span class="ot">|</span> y <span class="ot">=</span> <span class="ot">{!!}</span></a></code></pre></div>
<p>This is a little different from the normal way of doing things, where you’d pattern match on the argument. It is a pattern you’ll sometimes need to write, though. And here’s the issue: that <code>y</code> has nothing to do with <code>f x</code>, as far as Agda is concerned. All you’ve done is introduced a new variable, and that’s that.</p>
<p>This is exactly the problem <a href="https://github.com/agda/agda-stdlib/blob/442cd8a06b63f7e3550af55fb75c9d345c6ddb8f/src/Relation/Binary/PropositionalEquality.agda#L111-L113"><code>inspect</code></a> solves: it runs your function, giving you a result, but <em>also</em> giving you a proof that the result is equal to running the function. You use it like this:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb14-1" data-line-number="1">f-is-the-same-as-g <span class="ot">:</span> <span class="ot">∀</span> x <span class="ot">→</span> f x ≡ g x</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">f-is-the-same-as-g x <span class="kw">with</span> f x <span class="ot">|</span> inspect f x</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">f-is-the-same-as-g x <span class="ot">|</span> y <span class="ot">|</span> [ fx≡y ] <span class="ot">=</span> <span class="ot">{!!}</span></a></code></pre></div>
<h1 id="spc-g-g">SPC-G-G</h1>
<p>Because the Agda standard library is a big fan of type synonyms (<code>Op₂ A</code> instead of <code>A → A → A</code> for example), it’s handy to know that pressing <code>SPC-G-G</code> (in spacemacs) over any identifier will bring you to the definition. Also, you can normalize a type with <code>SPC-m-n</code>.</p>
<h1 id="irrelevance">Irrelevance</h1>
<p>This one is a little confusing, because Agda’s notion of “irrelevance” is different from Idris’, or Haskell’s. In all three languages, irrelevance is used for performance: it means that a value doesn’t need to be around at runtime, so the compiler can elide it.</p>
<p>That’s where the similarities stop though. In Haskell, <em>all</em> types are irrelevant: they’re figments of the typechecker’s imagination. You can’t get a type at runtime full stop.</p>
<p>In dependently typed languages, this isn’t a distinction we can rely on. The line between runtime entities and compile-time entities is drawn elsewhere, so quite often types <em>need</em> to exist at runtime. As you might guess, though, they don’t always need to. The length of a length-indexed vector, for instance, is completely determined by the structure of the vector: why would you bother storing all of that information at runtime? This is what Idris recognizes, and what it tries to remedy: it analyses code for these kinds of opportunities for elision, and does so when it can. Kind of like Haskell’s fusion, though, it’s an invisible optimization, and there’s no way to make Idris throw a type error when it can’t elide something you want it to elide.</p>
<p>Agda is totally different. Something is irrelevant in Agda if it’s <em>unique</em>. Or, rather, it’s irrelevant if all you rely on is its existence. It’s used for proofs that you carry around with you: in a rational number type, you might use it to say that the numerator and denominator have no common factors. The only information you want from this proof is whether it holds or not, so it’s the perfect candidate for irrelevance.</p>
<p>Weirdly, this means it’s useless for the length-indexed vector kind of stuff mentioned above. In fact, it doe exactly the opposite of what you might expect: if the length parameter is marked as irrelevant, the the types <code>Vec A n</code> and <code>Vec A (suc n)</code> are the same!</p>
<p>The way you <em>can</em> use it is to pattern-match if it’s impossible. Again, it’s designed for eliding proofs that you may carry with you otherwise.</p>
<h1 id="future-tips">Future Tips</h1>
<p>Once I’m finished the project, I’ll try write up a guide on how to do literate Agda files. There were a couple of weird nuances that I had to pick up on the way, mainly to do with getting unicode to work.</p>
]]></description>
    <pubDate>Thu, 20 Sep 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-09-20-agda-tips.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Verified AVL Trees in Haskell and Agda</title>
    <link>https://doisinkidney.com/posts/2018-07-30-verified-avl.html</link>
    <description><![CDATA[<div class="info">
    Posted on July 30, 2018
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Agda.html">Agda</a>
    
</div>

<p>I’ve been writing a lot of Agda recently, and had the occasion to write a <a href="https://en.wikipedia.org/wiki/Fenwick_tree">Fenwick tree</a> that did some rebalancing. I went with <a href="https://en.wikipedia.org/wiki/AVL_tree">AVL</a>-style rebalancing (rather than <a href="https://en.wikipedia.org/wiki/Red–black_tree">red-black</a> or <a href="https://en.wikipedia.org/wiki/Weight-balanced_tree">trees of bounded balance</a>). I’d written pretty full implementations of the other two before, and the Agda standard library <span class="citation" data-cites="danielsson_agda_2018">(Danielsson <a href="#ref-danielsson_agda_2018">2018</a>)</span> has an implementation already that I was able to use as a starting point. Also, apparently, AVL trees seem to perform better than red-black trees in practice <span class="citation" data-cites="pfaff_performance_2004">(Pfaff <a href="#ref-pfaff_performance_2004">2004</a>)</span>.</p>
<p>This post will be similar in style to Stephanie Weirich’s talk <span class="citation" data-cites="weirich_depending_2014">(<a href="#ref-weirich_depending_2014">2014</a>)</span>, which compares an Agda implementation of verified red-black trees to a Haskell one. When there’s two columns of code side-by-side, the left-hand side is Haskell, the right Agda.</p>
<p>The method of constructing the ordering proof is taken from “How to Keep Your Neighbours in Order” <span class="citation" data-cites="mcbride_how_2014">(<a href="#ref-mcbride_how_2014">2014</a>)</span> by Conor McBride; the structural proofs are somewhat inspired by the implementation in the Agda standard library, but are mainly my own.</p>
<h1 id="height">Height</h1>
<p>AVL trees are more strictly balanced than red-black trees: the height of neighboring subtrees can differ by at most one. To store the height, we will start as every dependently-typed program does: with Peano numbers.</p>
<style>
.column {
    float: left;
    width: 50%;
}
.row:after {
    content: "";
    display: table;
    clear: both;
}
</style>
<div class="row">
<div class="column">
<p>Haskell</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> <span class="dt">N</span> <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">|</span> <span class="dt">S</span> <span class="dt">N</span></a></code></pre></div>
</div>
<div class="column">
<p>Agda</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> ℕ <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  zero <span class="ot">:</span> ℕ</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  suc  <span class="ot">:</span> ℕ <span class="ot">→</span> ℕ</a></code></pre></div>
</div>
</div>
<p>The trees will be balanced one of three possible ways: left-heavy, right-heavy, or even. We can represent these three cases in a GADT in the case of Haskell, or an indexed datatype in the case of Agda:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Balance</span><span class="ot"> ::</span> <span class="dt">N</span> <span class="ot">-&gt;</span> <span class="dt">N</span> <span class="ot">-&gt;</span> <span class="dt">N</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">      <span class="dt">L</span><span class="ot"> ::</span> <span class="dt">Balance</span> (<span class="dt">S</span> n) n    (<span class="dt">S</span> n)</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">      <span class="dt">O</span><span class="ot"> ::</span> <span class="dt">Balance</span>  n    n     n</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">      <span class="dt">R</span><span class="ot"> ::</span> <span class="dt">Balance</span>  n   (<span class="dt">S</span> n) (<span class="dt">S</span> n)</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb4"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">data</span> ⟨<span class="ot">_</span>⊔<span class="ot">_</span>⟩≡<span class="ot">_</span> <span class="ot">:</span> ℕ <span class="ot">→</span> ℕ <span class="ot">→</span> ℕ <span class="ot">→</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  ◿  <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">→</span> ⟨ suc  n ⊔      n ⟩≡ suc  n</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  ▽  <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">→</span> ⟨      n ⊔      n ⟩≡      n</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">  ◺  <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">→</span> ⟨      n ⊔ suc  n ⟩≡ suc  n</a></code></pre></div>
</div>
</div>
<p>Those unfamiliar with Agda might be a little intimidated by the mixfix operator in the balance definition: we’re using it here because the type can be seen of a proof that:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">max(x,y) = z</annotation></semantics></math></p>
<p>Or, using the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>⊔</mo><annotation encoding="application/x-tex">\sqcup</annotation></semantics></math> operator:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>⊔</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">(x \sqcup y) = z</annotation></semantics></math></p>
<p>We’ll use this proof in the tree itself, as we’ll need to know the maximum of the height of a node’s two subtrees to find the height of the node. Before we do that, we’ll need a couple helper functions for manipulating the balance:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">balr ::</span> <span class="dt">Balance</span> x y z <span class="ot">-&gt;</span> <span class="dt">Balance</span> z x z</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">balr <span class="dt">L</span> <span class="fu">=</span> <span class="dt">O</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">balr <span class="dt">O</span> <span class="fu">=</span> <span class="dt">O</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">balr <span class="dt">R</span> <span class="fu">=</span> <span class="dt">L</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5"></a>
<a class="sourceLine" id="cb5-6" data-line-number="6"><span class="ot">ball ::</span> <span class="dt">Balance</span> x y z <span class="ot">-&gt;</span> <span class="dt">Balance</span> y z z</a>
<a class="sourceLine" id="cb5-7" data-line-number="7">ball <span class="dt">L</span> <span class="fu">=</span> <span class="dt">R</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8">ball <span class="dt">O</span> <span class="fu">=</span> <span class="dt">O</span></a>
<a class="sourceLine" id="cb5-9" data-line-number="9">ball <span class="dt">R</span> <span class="fu">=</span> <span class="dt">O</span></a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb6"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb6-1" data-line-number="1">⃕ <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>x y z<span class="ot">}</span> <span class="ot">→</span> ⟨ x ⊔ y ⟩≡ z <span class="ot">→</span> ⟨ z ⊔ x ⟩≡ z</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">⃕  ◿  <span class="ot">=</span> ▽</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">⃕  ▽  <span class="ot">=</span> ▽</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">⃕  ◺  <span class="ot">=</span> ◿</a>
<a class="sourceLine" id="cb6-5" data-line-number="5"></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">⃔ <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>x y z<span class="ot">}</span> <span class="ot">→</span> ⟨ x ⊔ y ⟩≡ z <span class="ot">→</span> ⟨ y ⊔ z ⟩≡ z</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">⃔  ◿  <span class="ot">=</span> ◺</a>
<a class="sourceLine" id="cb6-8" data-line-number="8">⃔  ▽  <span class="ot">=</span> ▽</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">⃔  ◺  <span class="ot">=</span> ▽</a></code></pre></div>
</div>
</div>
<h1 id="ordering">Ordering</h1>
<p>Along with the verification of the structure of the tree, we will also want to verify that its contents are ordered correctly. Unfortunately, this property is a little out of reach for Haskell, but it’s 100% doable in Agda. First, we’ll need a way to describe orders on a data type. In Haskell, we might write:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Ord</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="ot">  (==) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="ot">  (&lt;)  ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a></code></pre></div>
</div>
<div class="column">
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>*</mo><mo>*</mo><mo>*</mo></mrow><annotation encoding="application/x-tex">***</annotation></semantics></math>
</div>
</div>
<p>That <code class="sourceCode haskell"><span class="dt">Bool</span></code> throws away any information gained in the comparison, though: we want to supply a proof with the result of the comparison. First, equality:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">infix <span class="dv">4</span> <span class="fu">==</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="kw">data</span><span class="ot"> (==) ::</span> <span class="dt">Type</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">          <span class="ot">-&gt;</span> <span class="dt">Type</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">          <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5">  <span class="dt">Refl</span><span class="ot"> ::</span> x <span class="fu">==</span> x</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb9"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">infix</span> <span class="dv">4</span> <span class="ot">_</span>≡<span class="ot">_</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="kw">data</span> <span class="ot">_</span>≡<span class="ot">_</span> <span class="ot">{</span>a<span class="ot">}</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span> a<span class="ot">}</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">         <span class="ot">(</span>x <span class="ot">:</span> A<span class="ot">)</span> </a>
<a class="sourceLine" id="cb9-4" data-line-number="4">         <span class="ot">:</span> A <span class="ot">→</span> <span class="dt">Set</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  refl <span class="ot">:</span> x ≡ x</a></code></pre></div>
</div>
</div>
<p>This is one of the many ways to describe equality in Agda. It’s a type with only one constructor, and it can only be constructed when its two arguments are the same. When we pattern match on the constructor, then, we’re given a proof that whatever things those arguments refer to must be the same.</p>
<p>Next, we need to describe an order. For this, we’ll need two types: the empty type, and the unit type.</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Void</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Unit</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="kw">where</span> <span class="dt">Unit</span><span class="ot"> ::</span> <span class="dt">Unit</span></a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb11"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">data</span> ⊥ <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2"><span class="kw">data</span> ⊤ <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span> ⟨⟩ <span class="ot">:</span> ⊤</a></code></pre></div>
</div>
</div>
<p>These are kind of like type-level Bools, with one extra, powerful addition: they keep their proof after construction. Because <code class="sourceCode agda">⊥</code> has no constructors, if someone tells you they’re going to give you one, you can be pretty sure they’re lying. How do we use this? Well, first, on the numbers:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">type</span> family (<span class="ot">n ::</span> <span class="dt">N</span>) <span class="fu">&lt;</span> (<span class="ot">m ::</span> <span class="dt">N</span>)</a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="ot">    ::</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">  x   <span class="fu">&lt;</span> <span class="dt">Z</span>   <span class="fu">=</span> <span class="dt">Void</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">  <span class="dt">Z</span>   <span class="fu">&lt;</span> <span class="dt">S</span> y <span class="fu">=</span> <span class="dt">Unit</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5">  <span class="dt">S</span> x <span class="fu">&lt;</span> <span class="dt">S</span> y <span class="fu">=</span> x <span class="fu">&lt;</span> y</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb13"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="ot">_</span>ℕ&lt;<span class="ot">_</span> <span class="ot">:</span> ℕ <span class="ot">→</span> ℕ <span class="ot">→</span> <span class="dt">Set</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">x     ℕ&lt; zero  <span class="ot">=</span> ⊥</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">zero  ℕ&lt; suc y <span class="ot">=</span> ⊤</a>
<a class="sourceLine" id="cb13-4" data-line-number="4">suc x ℕ&lt; suc y <span class="ot">=</span> x ℕ&lt; y</a></code></pre></div>
</div>
</div>
<p>Therefore, if we ask for something of type <code class="sourceCode agda">x ℕ&lt; y</code> (for some <code>x</code> and <code>y</code>), we know that it only exists when <code>x</code> really is less than <code>y</code> (according to the definition above).</p>
<p>For our actual code, we’ll parameterize the whole thing over some abstract key type. We’ll do this using a module (a feature recently added to Haskell, as it happens). That might look something like this:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1">signature <span class="dt">Key</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2">  <span class="kw">import</span> <span class="dt">Data.Kind</span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3">  <span class="kw">data</span> <span class="dt">Key</span></a>
<a class="sourceLine" id="cb14-4" data-line-number="4">  <span class="kw">type</span> family (<span class="ot">n ::</span> <span class="dt">Key</span>) <span class="fu">&lt;</span> (<span class="ot">m ::</span> <span class="dt">Key</span>)</a>
<a class="sourceLine" id="cb14-5" data-line-number="5"><span class="ot">    ::</span> <span class="dt">Type</span></a>
<a class="sourceLine" id="cb14-6" data-line-number="6"></a>
<a class="sourceLine" id="cb14-7" data-line-number="7"><span class="kw">module</span> <span class="dt">AVL</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-8" data-line-number="8">  <span class="kw">import</span> <span class="dt">Key</span></a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb15"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="kw">module</span> AVL</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">  <span class="ot">{</span>k r<span class="ot">}</span> <span class="ot">(</span>Key <span class="ot">:</span> <span class="dt">Set</span> k<span class="ot">)</span></a>
<a class="sourceLine" id="cb15-3" data-line-number="3">  <span class="ot">{_</span>&lt;<span class="ot">_</span> <span class="ot">:</span> Rel Key r<span class="ot">}</span></a>
<a class="sourceLine" id="cb15-4" data-line-number="4">  <span class="ot">(</span>isStrictTotalOrder</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">   <span class="ot">:</span> IsStrictTotalOrder <span class="ot">_</span>≡<span class="ot">_</span> <span class="ot">_</span>&lt;<span class="ot">_)</span></a>
<a class="sourceLine" id="cb15-6" data-line-number="6">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-7" data-line-number="7"></a>
<a class="sourceLine" id="cb15-8" data-line-number="8">  <span class="kw">open</span> IsStrictTotalOrder isStrictTotalOrder</a></code></pre></div>
</div>
</div>
<p>(the <code class="sourceCode agda">k</code> and <code class="sourceCode agda">r</code> here, as well as the <code class="sourceCode agda">Lift</code>ing noise below, are to do with Agda’s universe system, which I’ll try explain in a bit)</p>
<p>Now, the trick for the ordering is to keep a proof that two neighboring values are ordered correctly in the tree at each leaf (as there’s a leaf between every pair of nodes, this is exactly the place you <em>should</em> store such a proof). A problem arises with the extremal leaves in the tree (leftmost and rightmost): each leaf is missing one neighboring value, so how can it store a proof of order? The solution is to affix two elements to our key type which we define as the greatest and least elements of the set.</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"></a>
<a class="sourceLine" id="cb16-2" data-line-number="2"></a>
<a class="sourceLine" id="cb16-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Bound</span> <span class="fu">=</span> <span class="dt">LB</span> <span class="fu">|</span> <span class="dt">IB</span> <span class="dt">Key</span> <span class="fu">|</span> <span class="dt">UB</span></a>
<a class="sourceLine" id="cb16-4" data-line-number="4"></a>
<a class="sourceLine" id="cb16-5" data-line-number="5"></a>
<a class="sourceLine" id="cb16-6" data-line-number="6"></a>
<a class="sourceLine" id="cb16-7" data-line-number="7">infix <span class="dv">4</span> <span class="fu">&lt;:</span></a>
<a class="sourceLine" id="cb16-8" data-line-number="8"></a>
<a class="sourceLine" id="cb16-9" data-line-number="9"><span class="kw">type</span> family (<span class="ot">x ::</span> <span class="dt">Bound</span>) <span class="fu">&lt;:</span> (<span class="ot">y ::</span> <span class="dt">Bound</span>)</a>
<a class="sourceLine" id="cb16-10" data-line-number="10"><span class="ot">    ::</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-11" data-line-number="11">  <span class="dt">LB</span>   <span class="fu">&lt;:</span> <span class="dt">LB</span>   <span class="fu">=</span> <span class="dt">Void</span></a>
<a class="sourceLine" id="cb16-12" data-line-number="12">  <span class="dt">LB</span>   <span class="fu">&lt;:</span> <span class="dt">UB</span>   <span class="fu">=</span> <span class="dt">Unit</span></a>
<a class="sourceLine" id="cb16-13" data-line-number="13">  <span class="dt">LB</span>   <span class="fu">&lt;:</span> <span class="dt">IB</span> _ <span class="fu">=</span> <span class="dt">Unit</span></a>
<a class="sourceLine" id="cb16-14" data-line-number="14">  <span class="dt">UB</span>   <span class="fu">&lt;:</span> _    <span class="fu">=</span> <span class="dt">Void</span></a>
<a class="sourceLine" id="cb16-15" data-line-number="15">  <span class="dt">IB</span> _ <span class="fu">&lt;:</span> <span class="dt">LB</span>   <span class="fu">=</span> <span class="dt">Void</span></a>
<a class="sourceLine" id="cb16-16" data-line-number="16">  <span class="dt">IB</span> _ <span class="fu">&lt;:</span> <span class="dt">UB</span>   <span class="fu">=</span> <span class="dt">Unit</span></a>
<a class="sourceLine" id="cb16-17" data-line-number="17">  <span class="dt">IB</span> x <span class="fu">&lt;:</span> <span class="dt">IB</span> y <span class="fu">=</span> x <span class="fu">&lt;</span> y</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb17"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw">infix</span> <span class="dv">5</span> [<span class="ot">_</span>]</a>
<a class="sourceLine" id="cb17-2" data-line-number="2"></a>
<a class="sourceLine" id="cb17-3" data-line-number="3"><span class="kw">data</span> [∙] <span class="ot">:</span> <span class="dt">Set</span> k <span class="kw">where</span></a>
<a class="sourceLine" id="cb17-4" data-line-number="4">  ⌊⌋ ⌈⌉ <span class="ot">:</span> [∙]</a>
<a class="sourceLine" id="cb17-5" data-line-number="5">  [<span class="ot">_</span>]   <span class="ot">:</span> <span class="ot">(</span>k <span class="ot">:</span> Key<span class="ot">)</span> <span class="ot">→</span> [∙]</a>
<a class="sourceLine" id="cb17-6" data-line-number="6"></a>
<a class="sourceLine" id="cb17-7" data-line-number="7"><span class="kw">infix</span> <span class="dv">4</span> <span class="ot">_</span>[&lt;]<span class="ot">_</span></a>
<a class="sourceLine" id="cb17-8" data-line-number="8"></a>
<a class="sourceLine" id="cb17-9" data-line-number="9"><span class="ot">_</span>[&lt;]<span class="ot">_</span> <span class="ot">:</span> [∙] <span class="ot">→</span> [∙] <span class="ot">→</span> <span class="dt">Set</span> r</a>
<a class="sourceLine" id="cb17-10" data-line-number="10">⌊⌋     [&lt;] ⌊⌋    <span class="ot">=</span> Lift r ⊥</a>
<a class="sourceLine" id="cb17-11" data-line-number="11">⌊⌋     [&lt;] ⌈⌉    <span class="ot">=</span> Lift r ⊤</a>
<a class="sourceLine" id="cb17-12" data-line-number="12">⌊⌋     [&lt;] [ <span class="ot">_</span> ] <span class="ot">=</span> Lift r ⊤</a>
<a class="sourceLine" id="cb17-13" data-line-number="13">⌈⌉     [&lt;] <span class="ot">_</span>     <span class="ot">=</span> Lift r ⊥</a>
<a class="sourceLine" id="cb17-14" data-line-number="14">[ <span class="ot">_</span> ]  [&lt;] ⌊⌋    <span class="ot">=</span> Lift r ⊥</a>
<a class="sourceLine" id="cb17-15" data-line-number="15">[ <span class="ot">_</span> ]  [&lt;] ⌈⌉    <span class="ot">=</span> Lift r ⊤</a>
<a class="sourceLine" id="cb17-16" data-line-number="16">[ x ]  [&lt;] [ y ] <span class="ot">=</span> x &lt; y</a></code></pre></div>
</div>
</div>
<h1 id="the-tree-type">The Tree Type</h1>
<p>After all that, we can get bring back Haskell into the story, and define or tree types:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"></a>
<a class="sourceLine" id="cb18-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Tree</span><span class="ot"> ::</span> <span class="dt">N</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3">          <span class="ot">-&gt;</span> <span class="dt">Type</span></a>
<a class="sourceLine" id="cb18-4" data-line-number="4">          <span class="ot">-&gt;</span> <span class="dt">Type</span></a>
<a class="sourceLine" id="cb18-5" data-line-number="5">          <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-6" data-line-number="6">  <span class="dt">Leaf</span><span class="ot"> ::</span> <span class="dt">Tree</span> <span class="dt">Z</span> k v</a>
<a class="sourceLine" id="cb18-7" data-line-number="7">  <span class="dt">Node</span><span class="ot"> ::</span> k</a>
<a class="sourceLine" id="cb18-8" data-line-number="8">       <span class="ot">-&gt;</span> v</a>
<a class="sourceLine" id="cb18-9" data-line-number="9">       <span class="ot">-&gt;</span> <span class="dt">Balance</span> lh rh h</a>
<a class="sourceLine" id="cb18-10" data-line-number="10">       <span class="ot">-&gt;</span> <span class="dt">Tree</span> lh k v</a>
<a class="sourceLine" id="cb18-11" data-line-number="11">       <span class="ot">-&gt;</span> <span class="dt">Tree</span> rh k v</a>
<a class="sourceLine" id="cb18-12" data-line-number="12">       <span class="ot">-&gt;</span> <span class="dt">Tree</span> (<span class="dt">S</span> h) k v</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb19"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="kw">data</span> Tree <span class="ot">{</span>v<span class="ot">}</span> </a>
<a class="sourceLine" id="cb19-2" data-line-number="2">          <span class="ot">(</span>V <span class="ot">:</span> Key <span class="ot">→</span> <span class="dt">Set</span> v<span class="ot">)</span></a>
<a class="sourceLine" id="cb19-3" data-line-number="3">          <span class="ot">(</span>l u <span class="ot">:</span> [∙]<span class="ot">)</span> <span class="ot">:</span> ℕ <span class="ot">→</span></a>
<a class="sourceLine" id="cb19-4" data-line-number="4">          <span class="dt">Set</span> <span class="ot">(</span>k ⊔ v ⊔ r<span class="ot">)</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-5" data-line-number="5">  leaf  <span class="ot">:</span> <span class="ot">(</span>l&lt;u <span class="ot">:</span> l [&lt;] u<span class="ot">)</span> <span class="ot">→</span> Tree V l u <span class="dv">0</span></a>
<a class="sourceLine" id="cb19-6" data-line-number="6">  node  <span class="ot">:</span> <span class="ot">∀</span>  <span class="ot">{</span>h lh rh<span class="ot">}</span></a>
<a class="sourceLine" id="cb19-7" data-line-number="7">             <span class="ot">(</span>k <span class="ot">:</span> Key<span class="ot">)</span></a>
<a class="sourceLine" id="cb19-8" data-line-number="8">             <span class="ot">(</span>v <span class="ot">:</span> V k<span class="ot">)</span></a>
<a class="sourceLine" id="cb19-9" data-line-number="9">             <span class="ot">(</span>bl <span class="ot">:</span> ⟨ lh ⊔ rh ⟩≡ h<span class="ot">)</span></a>
<a class="sourceLine" id="cb19-10" data-line-number="10">             <span class="ot">(</span>lk <span class="ot">:</span> Tree V l [ k ] lh<span class="ot">)</span></a>
<a class="sourceLine" id="cb19-11" data-line-number="11">             <span class="ot">(</span>ku <span class="ot">:</span> Tree V [ k ] u rh<span class="ot">)</span> <span class="ot">→</span></a>
<a class="sourceLine" id="cb19-12" data-line-number="12">             Tree V l u <span class="ot">(</span>suc h<span class="ot">)</span></a></code></pre></div>
</div>
</div>
<p>The two definitions are similar, but have a few obvious differences. The Agda version stores the ordering proof at the leaves, as well as the bounds as indices. Its <a href="https://pigworker.wordpress.com/2015/01/09/universe-hierarchies/"><em>universe</em></a> is also different: briefly, universes are one of the ways to avoid Russell’s paradox when you’re dealing with dependent types.</p>
<p>In normal, standard Haskell, we think of types as things that describe values (how quaint!). When you’ve got a list, everything in the list has the same type, and that is good and right.</p>
<p>These days, though, we’re not so constrained:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:-</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2"><span class="kw">data</span> <span class="dt">List</span> xs <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-3" data-line-number="3">  <span class="dt">Nil</span><span class="ot">  ::</span> <span class="dt">List</span> <span class="ch">&#39;[]</span></a>
<a class="sourceLine" id="cb20-4" data-line-number="4"><span class="ot">  (:-) ::</span> x</a>
<a class="sourceLine" id="cb20-5" data-line-number="5">       <span class="ot">-&gt;</span> <span class="dt">List</span> xs</a>
<a class="sourceLine" id="cb20-6" data-line-number="6">       <span class="ot">-&gt;</span> <span class="dt">List</span> (x <span class="fu">:</span> xs)</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb21"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">5</span> <span class="ot">_</span>፦<span class="ot">_</span></a>
<a class="sourceLine" id="cb21-2" data-line-number="2"><span class="kw">data</span> List′ <span class="ot">:</span> List <span class="dt">Set</span> <span class="ot">→</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-3" data-line-number="3">  nil <span class="ot">:</span> List′ []</a>
<a class="sourceLine" id="cb21-4" data-line-number="4">  <span class="ot">_</span>፦<span class="ot">_</span> <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>x xs<span class="ot">}</span></a>
<a class="sourceLine" id="cb21-5" data-line-number="5">      <span class="ot">→</span> x </a>
<a class="sourceLine" id="cb21-6" data-line-number="6">      <span class="ot">→</span> List′ xs </a>
<a class="sourceLine" id="cb21-7" data-line-number="7">      <span class="ot">→</span> List′ <span class="ot">(</span>x ∷ xs<span class="ot">)</span></a></code></pre></div>
</div>
</div>
<p>This can quite happily store elements of different types:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="ot">example ::</span> <span class="dt">List</span> [<span class="dt">Bool</span>, <span class="dt">String</span>, <span class="dt">Integer</span>]</a>
<a class="sourceLine" id="cb22-2" data-line-number="2">example <span class="fu">=</span> <span class="dt">True</span> <span class="fu">:-</span> <span class="st">&quot;true&quot;</span> <span class="fu">:-</span> <span class="dv">1</span> <span class="fu">:-</span> <span class="dt">Nil</span></a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb23"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb23-1" data-line-number="1">example <span class="ot">:</span> List′ <span class="ot">(</span>Bool ∷ String ∷ ℕ ∷ []<span class="ot">)</span></a>
<a class="sourceLine" id="cb23-2" data-line-number="2">example <span class="ot">=</span> true ፦ <span class="st">&quot;true&quot;</span> ፦ <span class="dv">1</span> ፦ nil</a></code></pre></div>
</div>
</div>
<p>And look at that bizarre-looking list on the wrong side of “<code class="sourceCode haskell"><span class="ot">::</span></code>”! Types aren’t just describing values, they’re acting like values themselves. What type does <code class="sourceCode haskell">[<span class="dt">Bool</span>, <span class="dt">String</span>, <span class="dt">Integer</span>]</code> even have, anyway? Why, <code class="sourceCode haskell">[<span class="dt">Type</span>]</code> of course!</p>
<p>So we see that types can be put in lists, and types have types: the natural question then is:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="dt">Type</span><span class="ot"> ::</span> <span class="fu">???</span></a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb25"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="dt">Set</span> <span class="ot">:</span> ???</a></code></pre></div>
</div>
</div>
<p>And this is where Haskell and Agda diverge: in Haskell, we say <code class="sourceCode haskell"><span class="dt">Type</span><span class="ot"> ::</span> <span class="dt">Type</span></code> (as the old extension <code class="sourceCode haskell"><span class="dt">TypeInType</span></code> implied), and that’s that. From a certain point of view, we’ve opened the door to Russell’s paradox (we’ve allowed a set to be a member of itself). This isn’t an issue in Haskell, though, as the type-level language was already inconsistent.</p>
<p>Agda goes another way, saying that <code class="sourceCode agda"><span class="dt">Set</span></code> (Agda’s equivalent for <code class="sourceCode haskell"><span class="dt">Type</span></code>) has the type <code class="sourceCode agda"><span class="dt">Set₁</span></code>, and <code class="sourceCode agda"><span class="dt">Set₁</span></code> has the type <code class="sourceCode agda"><span class="dt">Set₂</span></code>, and so on<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>. These different sets are called “universes” and their numbers “levels”. When we write <code class="sourceCode agda">k ⊔ v ⊔ r</code>, we’re saying we want to take the greatest universe level from those three possible levels: the level of the key, the value, and the relation, respectively.</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="dt">Type</span><span class="ot"> ::</span> <span class="dt">Type</span></a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb27"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="dt">Set</span> <span class="ot">:</span> <span class="dt">Set₁</span></a></code></pre></div>
</div>
</div>
<h1 id="rotations">Rotations</h1>
<p>AVL trees maintain their invariants through relatively simple rotations. We’ll start with the right rotation, which fixes an imbalance of two on the left. Because the size of the tree returned might change, we’ll need to wrap it in a datatype:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1"><span class="kw">data</span><span class="ot"> (++?) ::</span> (<span class="dt">N</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>)</a>
<a class="sourceLine" id="cb28-2" data-line-number="2">           <span class="ot">-&gt;</span> (<span class="dt">N</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>)</a>
<a class="sourceLine" id="cb28-3" data-line-number="3">           <span class="kw">where</span></a>
<a class="sourceLine" id="cb28-4" data-line-number="4">  <span class="dt">Stay</span><span class="ot"> ::</span> t n     <span class="ot">-&gt;</span> t <span class="fu">++?</span> n</a>
<a class="sourceLine" id="cb28-5" data-line-number="5">  <span class="dt">Incr</span><span class="ot"> ::</span> t (<span class="dt">S</span> n) <span class="ot">-&gt;</span> t <span class="fu">++?</span> n</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb29"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb29-1" data-line-number="1"></a>
<a class="sourceLine" id="cb29-2" data-line-number="2"><span class="ot">_</span>1?+⟨<span class="ot">_</span>⟩ <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>𝓁<span class="ot">}</span> <span class="ot">(</span>T <span class="ot">:</span> ℕ <span class="ot">→</span> <span class="dt">Set</span> 𝓁<span class="ot">)</span> <span class="ot">→</span> ℕ <span class="ot">→</span> <span class="dt">Set</span> 𝓁</a>
<a class="sourceLine" id="cb29-3" data-line-number="3">T 1?+⟨ n ⟩ <span class="ot">=</span> ∃[ inc? ] T <span class="ot">(</span>if inc?</a>
<a class="sourceLine" id="cb29-4" data-line-number="4">                            then suc n</a>
<a class="sourceLine" id="cb29-5" data-line-number="5">                            else n<span class="ot">)</span></a>
<a class="sourceLine" id="cb29-6" data-line-number="6"></a>
<a class="sourceLine" id="cb29-7" data-line-number="7"><span class="kw">pattern</span> 0+<span class="ot">_</span> tr <span class="ot">=</span> false , tr</a>
<a class="sourceLine" id="cb29-8" data-line-number="8"><span class="kw">pattern</span> 1+<span class="ot">_</span> tr <span class="ot">=</span> true  , tr</a></code></pre></div>
</div>
</div>
<p>We could actually have the Agda definition be the same as Haskell’s, it doesn’t make much difference. I’m mainly using it here to demonstrate dependent pairs in Agda. The first member of the pair is just a boolean (increased in height/not increased in height). The second member is a tree whose height <em>depends</em> on the actual value of the boolean. The <code class="sourceCode agda">∃</code> business is just a fancy syntax; it also waggles its eyebrows at the way a (dependent) pair of type <code>(x , y)</code> means “There exists an x such that y”.</p>
<p>Using this, we can write the type for right-rotation:</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="ot">rotr ::</span> k</a>
<a class="sourceLine" id="cb30-2" data-line-number="2">     <span class="ot">-&gt;</span> v</a>
<a class="sourceLine" id="cb30-3" data-line-number="3">     <span class="ot">-&gt;</span> <span class="dt">Tree</span> (<span class="dt">S</span> (<span class="dt">S</span> rh)) k v</a>
<a class="sourceLine" id="cb30-4" data-line-number="4">     <span class="ot">-&gt;</span> <span class="dt">Tree</span> rh k v</a>
<a class="sourceLine" id="cb30-5" data-line-number="5">     <span class="ot">-&gt;</span> <span class="dt">Tree</span> k v <span class="fu">++?</span> <span class="dt">S</span> (<span class="dt">S</span> rh)</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb31"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb31-1" data-line-number="1">rotʳ <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>lb ub rh v<span class="ot">}</span> <span class="ot">{</span>V <span class="ot">:</span> Key <span class="ot">→</span> <span class="dt">Set</span> v<span class="ot">}</span></a>
<a class="sourceLine" id="cb31-2" data-line-number="2">     <span class="ot">→</span> <span class="ot">(</span>k <span class="ot">:</span> Key<span class="ot">)</span></a>
<a class="sourceLine" id="cb31-3" data-line-number="3">     <span class="ot">→</span> V k</a>
<a class="sourceLine" id="cb31-4" data-line-number="4">     <span class="ot">→</span> Tree V lb [ k ] <span class="ot">(</span>suc <span class="ot">(</span>suc rh<span class="ot">))</span></a>
<a class="sourceLine" id="cb31-5" data-line-number="5">     <span class="ot">→</span> Tree V [ k ] ub rh</a>
<a class="sourceLine" id="cb31-6" data-line-number="6">     <span class="ot">→</span> Tree V lb ub 1?+⟨ suc <span class="ot">(</span>suc rh<span class="ot">)</span> ⟩</a></code></pre></div>
</div>
</div>
<p>There are two possible cases, single rotation:</p>
<style>
.tree {
  margin: auto;
  width: 30%;
}
</style>
<div class="tree">
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" data-line-number="1">   ┌a       ┌a</a>
<a class="sourceLine" id="cb32-2" data-line-number="2"> ┌y┤       y┤</a>
<a class="sourceLine" id="cb32-3" data-line-number="3"> │ └b <span class="fu">---&gt;</span>  │ ┌b</a>
<a class="sourceLine" id="cb32-4" data-line-number="4">x┤          └x┤</a>
<a class="sourceLine" id="cb32-5" data-line-number="5"> └c           └c</a></code></pre></div>
</div>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" data-line-number="1">rotr x xv (<span class="dt">Node</span> y yv <span class="dt">L</span> a b) c <span class="fu">=</span></a>
<a class="sourceLine" id="cb33-2" data-line-number="2">  <span class="dt">Stay</span> (<span class="dt">Node</span> y yv <span class="dt">O</span> a (<span class="dt">Node</span> x xv <span class="dt">O</span> b c))</a>
<a class="sourceLine" id="cb33-3" data-line-number="3">rotr x xv (<span class="dt">Node</span> y yv <span class="dt">O</span> a b) c <span class="fu">=</span></a>
<a class="sourceLine" id="cb33-4" data-line-number="4">  <span class="dt">Incr</span> (<span class="dt">Node</span> y yv <span class="dt">R</span> a (<span class="dt">Node</span> x xv <span class="dt">L</span> b c))</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb34"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb34-1" data-line-number="1">rotʳ x xv <span class="ot">(</span>node y yv ◿ a b<span class="ot">)</span> c <span class="ot">=</span></a>
<a class="sourceLine" id="cb34-2" data-line-number="2">  0+ <span class="ot">(</span>node y yv ▽ a <span class="ot">(</span>node x xv ▽  b c<span class="ot">))</span></a>
<a class="sourceLine" id="cb34-3" data-line-number="3">rotʳ x xv <span class="ot">(</span>node y yv ▽ a b<span class="ot">)</span> c <span class="ot">=</span></a>
<a class="sourceLine" id="cb34-4" data-line-number="4">  1+ <span class="ot">(</span>node y yv ◺ a <span class="ot">(</span>node x xv ◿  b c<span class="ot">))</span></a></code></pre></div>
</div>
</div>
<p>And double:</p>
<div class="tree">
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb35-1" data-line-number="1">   ┌a           ┌a</a>
<a class="sourceLine" id="cb35-2" data-line-number="2"> ┌y┤          ┌y┤</a>
<a class="sourceLine" id="cb35-3" data-line-number="3"> │ │ ┌b       │ └b</a>
<a class="sourceLine" id="cb35-4" data-line-number="4"> │ └z┤  <span class="fu">---&gt;</span> z┤</a>
<a class="sourceLine" id="cb35-5" data-line-number="5"> │   └c       │ ┌c</a>
<a class="sourceLine" id="cb35-6" data-line-number="6">x┤            └x┤</a>
<a class="sourceLine" id="cb35-7" data-line-number="7"> └d             └d</a></code></pre></div>
</div>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" data-line-number="1">rotr x xv (<span class="dt">Node</span> y yv <span class="dt">R</span> a </a>
<a class="sourceLine" id="cb36-2" data-line-number="2">            (<span class="dt">Node</span> z zv bl b c)) d <span class="fu">=</span></a>
<a class="sourceLine" id="cb36-3" data-line-number="3">  <span class="dt">Stay</span> (<span class="dt">Node</span> z zv <span class="dt">O</span> </a>
<a class="sourceLine" id="cb36-4" data-line-number="4">         (<span class="dt">Node</span> y yv (balr bl) a b)</a>
<a class="sourceLine" id="cb36-5" data-line-number="5">         (<span class="dt">Node</span> x xv (ball bl) c d))</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb37"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb37-1" data-line-number="1">rotʳ x xv <span class="ot">(</span>node y yv ◺  a</a>
<a class="sourceLine" id="cb37-2" data-line-number="2">            <span class="ot">(</span>node z zv bl b c<span class="ot">))</span> d <span class="ot">=</span></a>
<a class="sourceLine" id="cb37-3" data-line-number="3">  0+ <span class="ot">(</span>node z zv ▽</a>
<a class="sourceLine" id="cb37-4" data-line-number="4">       <span class="ot">(</span>node y yv <span class="ot">(</span>⃕ bl<span class="ot">)</span> a b<span class="ot">)</span></a>
<a class="sourceLine" id="cb37-5" data-line-number="5">       <span class="ot">(</span>node x xv <span class="ot">(</span>⃔ bl<span class="ot">)</span> c d<span class="ot">))</span></a></code></pre></div>
</div>
</div>
<p>I won’t bore you with left-rotation: suffice to say, it’s the opposite of right-rotation.</p>
<h1 id="insertion">Insertion</h1>
<p>Finally, the main event: insertion. Once the above functions have all been defined, it’s not very difficult, as it happens: by and large, the types guide you to the right answer. Of course, this is only after we decided to use the pivotal pragmatism and balance approach.</p>
<div class="row">
<div class="column">
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb38-1" data-line-number="1">insertWith</a>
<a class="sourceLine" id="cb38-2" data-line-number="2"><span class="ot">    ::</span> <span class="dt">Ord</span> k</a>
<a class="sourceLine" id="cb38-3" data-line-number="3">    <span class="ot">=&gt;</span> (v <span class="ot">-&gt;</span> v <span class="ot">-&gt;</span> v)</a>
<a class="sourceLine" id="cb38-4" data-line-number="4">    <span class="ot">-&gt;</span> k</a>
<a class="sourceLine" id="cb38-5" data-line-number="5">    <span class="ot">-&gt;</span> v</a>
<a class="sourceLine" id="cb38-6" data-line-number="6">    <span class="ot">-&gt;</span> <span class="dt">Tree</span> h k v</a>
<a class="sourceLine" id="cb38-7" data-line-number="7">    <span class="ot">-&gt;</span> <span class="dt">Tree</span> k v <span class="fu">++?</span> h</a>
<a class="sourceLine" id="cb38-8" data-line-number="8">insertWith _ v vc <span class="dt">Leaf</span> <span class="fu">=</span></a>
<a class="sourceLine" id="cb38-9" data-line-number="9">  <span class="dt">Incr</span> (<span class="dt">Node</span> v vc <span class="dt">O</span> <span class="dt">Leaf</span> <span class="dt">Leaf</span>)</a>
<a class="sourceLine" id="cb38-10" data-line-number="10">insertWith f v vc (<span class="dt">Node</span> k kc bl tl tr) <span class="fu">=</span></a>
<a class="sourceLine" id="cb38-11" data-line-number="11">  <span class="kw">case</span> compare v k <span class="kw">of</span></a>
<a class="sourceLine" id="cb38-12" data-line-number="12">    <span class="dt">LT</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb38-13" data-line-number="13">      <span class="kw">case</span> insertWith f v vc tl <span class="kw">of</span></a>
<a class="sourceLine" id="cb38-14" data-line-number="14">        <span class="dt">Stay</span> tl&#39; <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb38-15" data-line-number="15">          <span class="dt">Stay</span> (<span class="dt">Node</span> k kc bl tl&#39; tr)</a>
<a class="sourceLine" id="cb38-16" data-line-number="16">        <span class="dt">Incr</span> tl&#39; <span class="ot">-&gt;</span> <span class="kw">case</span> bl <span class="kw">of</span></a>
<a class="sourceLine" id="cb38-17" data-line-number="17">          <span class="dt">L</span> <span class="ot">-&gt;</span> rotr k kc tl&#39; tr</a>
<a class="sourceLine" id="cb38-18" data-line-number="18">          <span class="dt">O</span> <span class="ot">-&gt;</span> <span class="dt">Incr</span> (<span class="dt">Node</span> k kc <span class="dt">L</span> tl&#39; tr)</a>
<a class="sourceLine" id="cb38-19" data-line-number="19">          <span class="dt">R</span> <span class="ot">-&gt;</span> <span class="dt">Stay</span> (<span class="dt">Node</span> k kc <span class="dt">O</span> tl&#39; tr)</a>
<a class="sourceLine" id="cb38-20" data-line-number="20">    <span class="dt">EQ</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb38-21" data-line-number="21">      <span class="dt">Stay</span> (<span class="dt">Node</span> v (f vc kc) bl tl tr)</a>
<a class="sourceLine" id="cb38-22" data-line-number="22">    <span class="dt">GT</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb38-23" data-line-number="23">      <span class="kw">case</span> insertWith f v vc tr <span class="kw">of</span></a>
<a class="sourceLine" id="cb38-24" data-line-number="24">        <span class="dt">Stay</span> tr&#39; <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb38-25" data-line-number="25">          <span class="dt">Stay</span> (<span class="dt">Node</span> k kc bl tl tr&#39;)</a>
<a class="sourceLine" id="cb38-26" data-line-number="26">        <span class="dt">Incr</span> tr&#39; <span class="ot">-&gt;</span> <span class="kw">case</span> bl <span class="kw">of</span></a>
<a class="sourceLine" id="cb38-27" data-line-number="27">          <span class="dt">L</span> <span class="ot">-&gt;</span> <span class="dt">Stay</span> (<span class="dt">Node</span> k kc <span class="dt">O</span> tl tr&#39;)</a>
<a class="sourceLine" id="cb38-28" data-line-number="28">          <span class="dt">O</span> <span class="ot">-&gt;</span> <span class="dt">Incr</span> (<span class="dt">Node</span> k kc <span class="dt">R</span> tl tr&#39;)</a>
<a class="sourceLine" id="cb38-29" data-line-number="29">          <span class="dt">R</span> <span class="ot">-&gt;</span> rotl k kc tl tr&#39;</a></code></pre></div>
</div>
<div class="column">
<div class="sourceCode" id="cb39"><pre class="sourceCode agda"><code class="sourceCode agda"><a class="sourceLine" id="cb39-1" data-line-number="1">insert <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>l u h v<span class="ot">}</span></a>
<a class="sourceLine" id="cb39-2" data-line-number="2">           <span class="ot">{</span>V <span class="ot">:</span> Key <span class="ot">→</span> <span class="dt">Set</span> v<span class="ot">}</span></a>
<a class="sourceLine" id="cb39-3" data-line-number="3">           <span class="ot">(</span>k <span class="ot">:</span> Key<span class="ot">)</span></a>
<a class="sourceLine" id="cb39-4" data-line-number="4">       <span class="ot">→</span> V k</a>
<a class="sourceLine" id="cb39-5" data-line-number="5">       <span class="ot">→</span> <span class="ot">(</span>V k <span class="ot">→</span> V k <span class="ot">→</span> V k<span class="ot">)</span></a>
<a class="sourceLine" id="cb39-6" data-line-number="6">       <span class="ot">→</span> Tree V l u h</a>
<a class="sourceLine" id="cb39-7" data-line-number="7">       <span class="ot">→</span> l &lt; k &lt; u</a>
<a class="sourceLine" id="cb39-8" data-line-number="8">       <span class="ot">→</span> Tree V l u 1?+⟨ h ⟩</a>
<a class="sourceLine" id="cb39-9" data-line-number="9">insert v vc f <span class="ot">(</span>leaf l&lt;u<span class="ot">)</span> <span class="ot">(</span>l , u<span class="ot">)</span> <span class="ot">=</span></a>
<a class="sourceLine" id="cb39-10" data-line-number="10">  1+ <span class="ot">(</span>node v vc ▽ <span class="ot">(</span>leaf l<span class="ot">)</span> <span class="ot">(</span>leaf u<span class="ot">))</span></a>
<a class="sourceLine" id="cb39-11" data-line-number="11">insert v vc f <span class="ot">(</span>node k kc bl tl tr<span class="ot">)</span> prf</a>
<a class="sourceLine" id="cb39-12" data-line-number="12">  <span class="kw">with</span> compare v k</a>
<a class="sourceLine" id="cb39-13" data-line-number="13">insert v vc f <span class="ot">(</span>node k kc bl tl tr<span class="ot">)</span> <span class="ot">(</span>l , <span class="ot">_)</span></a>
<a class="sourceLine" id="cb39-14" data-line-number="14">    <span class="ot">|</span> tri&lt; a <span class="ot">_</span> <span class="ot">_</span> <span class="kw">with</span> insert v vc f tl <span class="ot">(</span>l , a<span class="ot">)</span></a>
<a class="sourceLine" id="cb39-15" data-line-number="15"><span class="ot">...</span> <span class="ot">|</span> 0+ tl′ <span class="ot">=</span> 0+ <span class="ot">(</span>node k kc bl tl′ tr<span class="ot">)</span></a>
<a class="sourceLine" id="cb39-16" data-line-number="16"><span class="ot">...</span> <span class="ot">|</span> 1+ tl′ <span class="kw">with</span> bl</a>
<a class="sourceLine" id="cb39-17" data-line-number="17"><span class="ot">...</span> <span class="ot">|</span> ◿ <span class="ot">=</span> rotʳ k kc tl′ tr</a>
<a class="sourceLine" id="cb39-18" data-line-number="18"><span class="ot">...</span> <span class="ot">|</span> ▽ <span class="ot">=</span> 1+ <span class="ot">(</span>node k kc  ◿  tl′ tr<span class="ot">)</span></a>
<a class="sourceLine" id="cb39-19" data-line-number="19"><span class="ot">...</span> <span class="ot">|</span> ◺ <span class="ot">=</span> 0+ <span class="ot">(</span>node k kc  ▽  tl′ tr<span class="ot">)</span></a>
<a class="sourceLine" id="cb39-20" data-line-number="20">insert v vc f <span class="ot">(</span>node k kc bl tl tr<span class="ot">)</span> <span class="ot">_</span></a>
<a class="sourceLine" id="cb39-21" data-line-number="21">    <span class="ot">|</span> tri≈ <span class="ot">_</span> refl <span class="ot">_</span> <span class="ot">=</span></a>
<a class="sourceLine" id="cb39-22" data-line-number="22">        0+ <span class="ot">(</span>node k <span class="ot">(</span>f vc kc<span class="ot">)</span> bl tl tr<span class="ot">)</span></a>
<a class="sourceLine" id="cb39-23" data-line-number="23">insert v vc f <span class="ot">(</span>node k kc bl tl tr<span class="ot">)</span> <span class="ot">(_</span> , u<span class="ot">)</span></a>
<a class="sourceLine" id="cb39-24" data-line-number="24">    <span class="ot">|</span> tri&gt; <span class="ot">_</span> <span class="ot">_</span> c <span class="kw">with</span> insert v vc f tr <span class="ot">(</span>c , u<span class="ot">)</span></a>
<a class="sourceLine" id="cb39-25" data-line-number="25"><span class="ot">...</span> <span class="ot">|</span> 0+ tr′ <span class="ot">=</span> 0+ <span class="ot">(</span>node k kc bl tl tr′<span class="ot">)</span></a>
<a class="sourceLine" id="cb39-26" data-line-number="26"><span class="ot">...</span> <span class="ot">|</span> 1+ tr′ <span class="kw">with</span> bl</a>
<a class="sourceLine" id="cb39-27" data-line-number="27"><span class="ot">...</span> <span class="ot">|</span> ◿ <span class="ot">=</span> 0+ <span class="ot">(</span>node k kc ▽ tl tr′<span class="ot">)</span></a>
<a class="sourceLine" id="cb39-28" data-line-number="28"><span class="ot">...</span> <span class="ot">|</span> ▽ <span class="ot">=</span> 1+ <span class="ot">(</span>node k kc ◺ tl tr′<span class="ot">)</span></a>
<a class="sourceLine" id="cb39-29" data-line-number="29"><span class="ot">...</span> <span class="ot">|</span> ◺ <span class="ot">=</span> rotˡ k kc tl tr′</a></code></pre></div>
</div>
</div>
<h1 id="conclusion">Conclusion</h1>
<p>Overall, I’ve been enjoying programming in Agda. The things I liked and didn’t like surprised me:</p>
<dl>
<dt>Editor Support</dt>
<dd><p>Is excellent. I use <a href="http://spacemacs.org">spacemacs</a>, and the whole thing worked pretty seamlessly. Proof search and auto was maybe not as powerful as Idris’, although that might be down to lack of experience (note—as I write this, I see you can enable case-splitting in proof search, so it looks like I was right about my lack of experience). In many ways, it was much better than Haskell’s editor support: personally, I have never managed to get case-splitting to work in my Haskell setup, never mind some of the fancier features that you get in Agda.</p>
<p>It’s worth noting that my experience with Idris is similar: maybe it’s something about dependent types?</p>
<p>Of course, I missed lots of extra tools, like linters, code formatters, etc., but the tight integration with the compiler was so useful it more than made up for it.</p>
<p>Also, I’d implore anyone who’s had trouble with emacs before to give <a href="http://spacemacs.org">spacemacs</a> a go. It works well out-of-the-box, and has a system for keybinding discovery that <em>actually works</em>.</p>
</dd>
<dt>Documentation</dt>
<dd><p>Pretty good, considering. There are some missing parts (<a href="https://agda.readthedocs.io/en/v2.5.4.1/language/rewriting.html">rewriting</a> and <a href="https://agda.readthedocs.io/en/v2.5.4.1/language/telescopes.html">telescopes</a> are both stubs on the documentation site), but there seemed to be more fully worked-out examples available online for different concepts when I needed to figure them out.</p>
</dd>
</dl>
<p>Now, the thing about a lot of these complaints/commendations (<em>especially</em> with regards to tooling and personal setups) is that people tend to be pretty bad about evaluating how difficult finicky tasks like editor setups are. Once you’ve gotten the hang of some of this stuff, you forget that you ever didn’t. Agda is the second dependently-typed language I’ve really gone for a deepish dive on, and I’ve been using spacemacs for a while, so YMMV.</p>
<p>One area of the language itself that I would have liked to see more on was irrelevance. Looking back at the definition of the tree type, in the Haskell version there’s no singleton storing the height (the balance type stores all the information we need), which means that it definitely doesn’t exist at runtime. As I understand it, that implies that the type should be irrelevant in the equivalent Agda. However, when I actually mark it as irrelevant, everything works fine, except that missing cases warnings start showing up. I couldn’t figure out why: Haskell was able to infer full case coverage without the index, after all. Equality proof erasure, also: is it safe? Consistent?</p>
<p>All in all, I’d encourage more Haskellers to give Agda a try. It’s fun, interesting, and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="script"><mi>𝒰</mi><mi>𝓃</mi><mi>𝒾</mi><mi>𝒸</mi><mi>ℴ</mi><mi>𝒹</mi><mi>ℯ</mi></mstyle><annotation encoding="application/x-tex">\mathcal{Unicode}</annotation></semantics></math>!</p>
<h1 id="further-reading">Further Reading</h1>
<p>No “deletion is left as an exercise to the reader” here, no sir! Fuller implementations of both the Haskell and Agda versions of the code here are available: first, a pdf of the Agda code with lovely colours is <a href="/pdfs/AVL.pdf">here</a>. The accompanying repository is <a href="https://github.com/oisdk/agda-avl">here</a>, and the equivalent for the Haskell code is <a href="https://github.com/oisdk/verified-avl">here</a>. Of course, if you would rather read something by someone who knows what they’re talking about, please see the</p>
<h1 id="references" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-danielsson_agda_2018">
<p>Danielsson, Nils Anders. 2018. “The Agda standard library.”</p>
</div>
<div id="ref-mcbride_how_2014">
<p>McBride, Conor Thomas. 2014. “How to Keep Your Neighbours in Order.” In <em>Proceedings of the 19th ACM SIGPLAN International Conference on Functional Programming</em>, 297–309. ICFP ’14. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/2628136.2628163">10.1145/2628136.2628163</a>.</p>
</div>
<div id="ref-pfaff_performance_2004">
<p>Pfaff, Ben. 2004. “Performance Analysis of BSTs in System Software.” In <em>Proceedings of the Joint International Conference on Measurement and Modeling of Computer Systems</em>, 410–411. SIGMETRICS ’04/Performance ’04. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/1005686.1005742">10.1145/1005686.1005742</a>.</p>
</div>
<div id="ref-weirich_depending_2014">
<p>Weirich, Stephanie. 2014. “Depending on Types.” In <em>Proceedings of the 19th ACM SIGPLAN International Conference on Functional Programming</em>, 241–241. ICFP ’14. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/2628136.2631168">10.1145/2628136.2631168</a>.</p>
</div>
</div>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>My phrasing is maybe a little confusing here. When <code class="sourceCode haskell"><span class="dt">Set</span></code> “has the type” <code class="sourceCode agda"><span class="dt">Set₁</span></code> it means that <code class="sourceCode haskell"><span class="dt">Set</span></code> is <em>in</em> <code class="sourceCode agda"><span class="dt">Set₁</span></code>, not the other way around.<a href="#fnref1" class="footnote-back">↩</a></p></li>
</ol>
</section>
]]></description>
    <pubDate>Mon, 30 Jul 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-07-30-verified-avl.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Probabilistic Functional Programming</title>
    <link>https://doisinkidney.com/posts/2018-07-17-probability-presentation.html</link>
    <description><![CDATA[<div class="info">
    Posted on July 17, 2018
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Probability.html">Probability</a>
    
</div>

<p><a href="/pdfs/prob-presentation.pdf">Here</a> are the slides for a short talk I gave to a reading group I’m in at Harvard today. The speaker notes are included in the pdf, code and the tex is available in the <a href="https://github.com/oisdk/prob-presentation">repository</a>.</p>
]]></description>
    <pubDate>Tue, 17 Jul 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-07-17-probability-presentation.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Probability 5 Ways</title>
    <link>https://doisinkidney.com/posts/2018-06-30-probability-5-ways.html</link>
    <description><![CDATA[<div class="info">
    Posted on June 30, 2018
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Probability.html">Probability</a>, <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<p>Ever since the famous pearl by <span class="citation" data-cites="erwig_functional_2006">Erwig and Kollmansberger (<a href="#ref-erwig_functional_2006">2006</a>)</span>, probabilistic programming with monads has been an interesting and diverse area in functional programming, with many different approaches.</p>
<p>I’m going to present five here, some of which I have not seen before.</p>
<h1 id="the-classic">The Classic</h1>
<p>As presented in the paper, a simple and elegant formulation of probability distributions looks like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Prob</span> a</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Prob</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">    {<span class="ot"> runProb ::</span> [(a, <span class="dt">Rational</span>)]</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">    }</a></code></pre></div>
<p>It’s a list of possible events, each tagged with their probability of happening. Here’s the probability distribution representing a die roll, for instance:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">die ::</span> <span class="dt">Prob</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">die <span class="fu">=</span> [ (x, <span class="dv">1</span><span class="fu">/</span><span class="dv">6</span>) <span class="fu">|</span> x <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span><span class="dv">6</span>] ]</a></code></pre></div>
<p>The semantics can afford to be a little fuzzy: it doesn’t hugely matter if the probabilities don’t add up to 1 (you can still extract meaningful answers when they don’t). However, I can’t see a way in which either negative probabilities or an empty list would make sense. It would be nice if those states were unrepresentable.</p>
<p>Its monadic structure multiplies conditional events:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Prob</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">    fmap f xs <span class="fu">=</span> <span class="dt">Prob</span> [ (f x, p) <span class="fu">|</span> (x,p) <span class="ot">&lt;-</span> runProb xs ]</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">    </a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Prob</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">    pure x <span class="fu">=</span> <span class="dt">Prob</span> [(x,<span class="dv">1</span>)]</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">    fs <span class="fu">&lt;*&gt;</span> xs</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">        <span class="fu">=</span> <span class="dt">Prob</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8">        [ (f x,fp<span class="fu">*</span>xp)</a>
<a class="sourceLine" id="cb3-9" data-line-number="9">        <span class="fu">|</span> (f,fp) <span class="ot">&lt;-</span> runProb fs</a>
<a class="sourceLine" id="cb3-10" data-line-number="10">        , (x,xp) <span class="ot">&lt;-</span> runProb xs ]</a>
<a class="sourceLine" id="cb3-11" data-line-number="11">                     </a>
<a class="sourceLine" id="cb3-12" data-line-number="12"><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Prob</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-13" data-line-number="13">    xs <span class="fu">&gt;&gt;=</span> f</a>
<a class="sourceLine" id="cb3-14" data-line-number="14">        <span class="fu">=</span> <span class="dt">Prob</span></a>
<a class="sourceLine" id="cb3-15" data-line-number="15">        [ (y,xp<span class="fu">*</span>yp)</a>
<a class="sourceLine" id="cb3-16" data-line-number="16">        <span class="fu">|</span> (x,xp) <span class="ot">&lt;-</span> runProb xs</a>
<a class="sourceLine" id="cb3-17" data-line-number="17">        , (y,yp) <span class="ot">&lt;-</span> runProb (f x) ]</a></code></pre></div>
<p>In most of the examples, we’ll need a few extra functions in order for the types to be useful. First is support:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">support ::</span> <span class="dt">Prob</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">support <span class="fu">=</span> fmap fst <span class="fu">.</span> runProb</a></code></pre></div>
<p>And second is expectation:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">expect ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Rational</span>) <span class="ot">-&gt;</span> <span class="dt">Prob</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">expect p xs <span class="fu">=</span> sum [ p x <span class="fu">*</span> xp <span class="fu">|</span> (x,xp) <span class="ot">&lt;-</span> runProb xs ]</a>
<a class="sourceLine" id="cb5-3" data-line-number="3"></a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="ot">probOf ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Prob</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">probOf p <span class="fu">=</span> expect (bool <span class="dv">0</span> <span class="dv">1</span> <span class="fu">.</span> p)</a></code></pre></div>
<p>It’s useful to be able to construct uniform distributions:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1">uniform xs <span class="fu">=</span> <span class="dt">Prob</span> [ (x,n) <span class="fu">|</span> x <span class="ot">&lt;-</span> xs ]</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">    n <span class="fu">=</span> <span class="dv">1</span> <span class="fu">%</span> toEnum (length xs)</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">    </a>
<a class="sourceLine" id="cb6-5" data-line-number="5">die <span class="fu">=</span> uniform [<span class="dv">1</span><span class="fu">..</span><span class="dv">6</span>]</a>
<a class="sourceLine" id="cb6-6" data-line-number="6"></a>
<a class="sourceLine" id="cb6-7" data-line-number="7"><span class="fu">&gt;&gt;&gt;</span> probOf (<span class="dv">7</span><span class="fu">==</span>) <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">  x <span class="ot">&lt;-</span> die</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">  y <span class="ot">&lt;-</span> die</a>
<a class="sourceLine" id="cb6-10" data-line-number="10">  pure (x<span class="fu">+</span>y)</a>
<a class="sourceLine" id="cb6-11" data-line-number="11"><span class="dv">1</span> <span class="fu">%</span> <span class="dv">6</span></a></code></pre></div>
<h1 id="the-bells-and-whistles">The Bells and Whistles</h1>
<p>As elegant as the above approach is, it leaves something to be desired when it comes to efficiency. In particular, you’ll see a combinatorial explosion at every step. To demonstrate, let’s take the example above, using three-sided dice instead so it doesn’t take up too much space.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1">die <span class="fu">=</span> uniform [<span class="dv">1</span><span class="fu">..</span><span class="dv">3</span>]</a>
<a class="sourceLine" id="cb7-2" data-line-number="2"></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">example <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">  x <span class="ot">&lt;-</span> die</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">  y <span class="ot">&lt;-</span> die</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">  pure (x<span class="fu">+</span>y)</a></code></pre></div>
<p>The probability table looks like this:</p>
<pre class="center"><code>2 1/9
3 2/9
4 1/3
5 2/9
6 1/9</code></pre>
<p>But the internal representation looks like this:</p>
<pre><code>2 1/9
3 1/9
4 1/9
3 1/9
4 1/9
5 1/9
4 1/9
5 1/9
6 1/9</code></pre>
<p>States are duplicated, because the implementation has no way of knowing that two outcomes are the same. We could collapse equivalent outcomes if we used a <code class="sourceCode haskell"><span class="dt">Map</span></code>, but then we can’t implement <code class="sourceCode haskell"><span class="dt">Functor</span></code>, <code class="sourceCode haskell"><span class="dt">Applicative</span></code>, or <code class="sourceCode haskell"><span class="dt">Monad</span></code>. The types:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="ot">    fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</a>
<a class="sourceLine" id="cb10-3" data-line-number="3"></a>
<a class="sourceLine" id="cb10-4" data-line-number="4"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Applicative</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-5" data-line-number="5"><span class="ot">    pure ::</span> a <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb10-6" data-line-number="6"><span class="ot">    (&lt;*&gt;) ::</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</a>
<a class="sourceLine" id="cb10-7" data-line-number="7"></a>
<a class="sourceLine" id="cb10-8" data-line-number="8"><span class="kw">class</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">Monad</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-9" data-line-number="9"><span class="ot">    (&gt;&gt;=) ::</span> f a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> f b</a></code></pre></div>
<p>Don’t allow an <code class="sourceCode haskell"><span class="dt">Ord</span></code> constraint, which is what we’d need to remove duplicates. We can instead make our own classes which <em>do</em> allow constraints:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">{-# LANGUAGE RebindableSyntax #-}</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2"><span class="ot">{-# LANGUAGE TypeFamilies     #-}</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3"></a>
<a class="sourceLine" id="cb11-4" data-line-number="4"><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (<span class="dt">Functor</span>(..),<span class="dt">Applicative</span>(..),<span class="dt">Monad</span>(..))</a>
<a class="sourceLine" id="cb11-5" data-line-number="5"></a>
<a class="sourceLine" id="cb11-6" data-line-number="6"><span class="kw">import</span> <span class="dt">Data.Kind</span></a>
<a class="sourceLine" id="cb11-7" data-line-number="7"></a>
<a class="sourceLine" id="cb11-8" data-line-number="8"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-9" data-line-number="9">    <span class="kw">type</span> <span class="dt">Domain</span> f<span class="ot"> a ::</span> <span class="dt">Constraint</span></a>
<a class="sourceLine" id="cb11-10" data-line-number="10">    <span class="kw">type</span> <span class="dt">Domain</span> f a <span class="fu">=</span> ()</a>
<a class="sourceLine" id="cb11-11" data-line-number="11"><span class="ot">    fmap ::</span> <span class="dt">Domain</span> f b <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</a>
<a class="sourceLine" id="cb11-12" data-line-number="12"></a>
<a class="sourceLine" id="cb11-13" data-line-number="13"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Applicative</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-14" data-line-number="14">    <span class="ot">{-# MINIMAL pure, liftA2 #-}</span></a>
<a class="sourceLine" id="cb11-15" data-line-number="15"><span class="ot">    pure   ::</span> <span class="dt">Domain</span> f a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb11-16" data-line-number="16"><span class="ot">    liftA2 ::</span> <span class="dt">Domain</span> f c <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f c</a>
<a class="sourceLine" id="cb11-17" data-line-number="17">    </a>
<a class="sourceLine" id="cb11-18" data-line-number="18"><span class="ot">    (&lt;*&gt;) ::</span> <span class="dt">Domain</span> f b <span class="ot">=&gt;</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</a>
<a class="sourceLine" id="cb11-19" data-line-number="19">    (<span class="fu">&lt;*&gt;</span>) <span class="fu">=</span> liftA2 (<span class="fu">$</span>) </a>
<a class="sourceLine" id="cb11-20" data-line-number="20"></a>
<a class="sourceLine" id="cb11-21" data-line-number="21"><span class="kw">class</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">Monad</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-22" data-line-number="22"><span class="ot">    (&gt;&gt;=) ::</span> <span class="dt">Domain</span> f b <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> f b</a>
<a class="sourceLine" id="cb11-23" data-line-number="23"></a>
<a class="sourceLine" id="cb11-24" data-line-number="24">fail<span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb11-25" data-line-number="25">fail <span class="fu">=</span> error</a>
<a class="sourceLine" id="cb11-26" data-line-number="26"></a>
<a class="sourceLine" id="cb11-27" data-line-number="27">return<span class="ot"> ::</span> (<span class="dt">Applicative</span> f, <span class="dt">Domain</span> f a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb11-28" data-line-number="28">return <span class="fu">=</span> pure</a></code></pre></div>
<p>This setup gets over a couple common annoyances in Haskell, like making <a href="http://hackage.haskell.org/package/containers-0.6.0.1/docs/Data-Set.html"><code class="sourceCode haskell"><span class="dt">Data.Set</span></code></a> a Monad:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">    <span class="kw">type</span> <span class="dt">Domain</span> <span class="dt">Set</span> a <span class="fu">=</span> <span class="dt">Ord</span> a</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">    fmap <span class="fu">=</span> Set.map</a>
<a class="sourceLine" id="cb12-4" data-line-number="4"></a>
<a class="sourceLine" id="cb12-5" data-line-number="5"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-6" data-line-number="6">    pure <span class="fu">=</span> Set.singleton</a>
<a class="sourceLine" id="cb12-7" data-line-number="7">    liftA2 f xs ys <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb12-8" data-line-number="8">        x <span class="ot">&lt;-</span> xs</a>
<a class="sourceLine" id="cb12-9" data-line-number="9">        y <span class="ot">&lt;-</span> ys</a>
<a class="sourceLine" id="cb12-10" data-line-number="10">        pure (f x y)</a>
<a class="sourceLine" id="cb12-11" data-line-number="11"></a>
<a class="sourceLine" id="cb12-12" data-line-number="12"><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-13" data-line-number="13">    (<span class="fu">&gt;&gt;=</span>) <span class="fu">=</span> flip foldMap</a></code></pre></div>
<p>And, of course, the probability monad:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Prob</span> a <span class="fu">=</span> <span class="dt">Prob</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">    {<span class="ot"> runProb ::</span> <span class="dt">Map</span> a <span class="dt">Rational</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">    }</a>
<a class="sourceLine" id="cb13-4" data-line-number="4"></a>
<a class="sourceLine" id="cb13-5" data-line-number="5"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Prob</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-6" data-line-number="6">    <span class="kw">type</span> <span class="dt">Domain</span> <span class="dt">Prob</span> a <span class="fu">=</span> <span class="dt">Ord</span> a</a>
<a class="sourceLine" id="cb13-7" data-line-number="7">    fmap f <span class="fu">=</span> <span class="dt">Prob</span> <span class="fu">.</span> Map.mapKeysWith (<span class="fu">+</span>) f <span class="fu">.</span> runProb</a>
<a class="sourceLine" id="cb13-8" data-line-number="8"></a>
<a class="sourceLine" id="cb13-9" data-line-number="9"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Prob</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-10" data-line-number="10">    pure x <span class="fu">=</span> <span class="dt">Prob</span> (Map.singleton x <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb13-11" data-line-number="11">    liftA2 f xs ys <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb13-12" data-line-number="12">      x <span class="ot">&lt;-</span> xs</a>
<a class="sourceLine" id="cb13-13" data-line-number="13">      y <span class="ot">&lt;-</span> ys</a>
<a class="sourceLine" id="cb13-14" data-line-number="14">      pure (f x y)</a>
<a class="sourceLine" id="cb13-15" data-line-number="15">      </a>
<a class="sourceLine" id="cb13-16" data-line-number="16"><span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Prob</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-17" data-line-number="17">    mempty <span class="fu">=</span> <span class="dt">Prob</span> Map.empty</a>
<a class="sourceLine" id="cb13-18" data-line-number="18">    mappend (<span class="dt">Prob</span> xs) (<span class="dt">Prob</span> ys) <span class="fu">=</span> <span class="dt">Prob</span> (Map.unionWith (<span class="fu">+</span>) xs ys)</a>
<a class="sourceLine" id="cb13-19" data-line-number="19"></a>
<a class="sourceLine" id="cb13-20" data-line-number="20"><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Prob</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-21" data-line-number="21">    <span class="dt">Prob</span> xs <span class="fu">&gt;&gt;=</span> f</a>
<a class="sourceLine" id="cb13-22" data-line-number="22">        <span class="fu">=</span> Map.foldMapWithKey ((<span class="dt">Prob</span> <span class="fu">.</span>) <span class="fu">.</span> flip (Map.map <span class="fu">.</span> (<span class="fu">*</span>)) <span class="fu">.</span> runProb <span class="fu">.</span> f) xs</a>
<a class="sourceLine" id="cb13-23" data-line-number="23"></a>
<a class="sourceLine" id="cb13-24" data-line-number="24">support <span class="fu">=</span> Map.keys <span class="fu">.</span> runProb</a>
<a class="sourceLine" id="cb13-25" data-line-number="25"></a>
<a class="sourceLine" id="cb13-26" data-line-number="26">expect p <span class="fu">=</span> getSum <span class="fu">.</span> Map.foldMapWithKey (\k v <span class="ot">-&gt;</span> <span class="dt">Sum</span> (p k <span class="fu">*</span> v)) <span class="fu">.</span> runProb</a>
<a class="sourceLine" id="cb13-27" data-line-number="27"></a>
<a class="sourceLine" id="cb13-28" data-line-number="28">probOf p <span class="fu">=</span> expect (bool <span class="dv">0</span> <span class="dv">1</span> <span class="fu">.</span> p)</a>
<a class="sourceLine" id="cb13-29" data-line-number="29"></a>
<a class="sourceLine" id="cb13-30" data-line-number="30">uniform xs <span class="fu">=</span> <span class="dt">Prob</span> (Map.fromList [ (x,n) <span class="fu">|</span> x <span class="ot">&lt;-</span> xs ])</a>
<a class="sourceLine" id="cb13-31" data-line-number="31">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-32" data-line-number="32">    n <span class="fu">=</span> <span class="dv">1</span> <span class="fu">%</span> toEnum (length xs)</a>
<a class="sourceLine" id="cb13-33" data-line-number="33"></a>
<a class="sourceLine" id="cb13-34" data-line-number="34">ifThenElse <span class="dt">True</span> t _ <span class="fu">=</span> t</a>
<a class="sourceLine" id="cb13-35" data-line-number="35">ifThenElse <span class="dt">False</span> _ f <span class="fu">=</span> f</a>
<a class="sourceLine" id="cb13-36" data-line-number="36"></a>
<a class="sourceLine" id="cb13-37" data-line-number="37">die <span class="fu">=</span> uniform [<span class="dv">1</span><span class="fu">..</span><span class="dv">6</span>]</a>
<a class="sourceLine" id="cb13-38" data-line-number="38"></a>
<a class="sourceLine" id="cb13-39" data-line-number="39"><span class="fu">&gt;&gt;&gt;</span> probOf (<span class="dv">7</span><span class="fu">==</span>) <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb13-40" data-line-number="40">  x <span class="ot">&lt;-</span> die</a>
<a class="sourceLine" id="cb13-41" data-line-number="41">  y <span class="ot">&lt;-</span> die</a>
<a class="sourceLine" id="cb13-42" data-line-number="42">  pure (x <span class="fu">+</span> y)</a>
<a class="sourceLine" id="cb13-43" data-line-number="43"><span class="dv">1</span> <span class="fu">%</span> <span class="dv">6</span></a></code></pre></div>
<h1 id="free">Free</h1>
<p>Coming up with the right implementation all at once is quite difficult: luckily, there are more general techniques for designing DSLs that break the problem into smaller parts, which also give us some insight into the underlying composition of the probability monad.</p>
<p>The technique relies on an algebraic concept called “free objects”. A free object for some class is a minimal implementation of that class. The classic example is lists: they’re the free monoid. Monoid requires that you have an additive operation, an empty element, and that the additive operation be associative. Lists have all of these things: what makes them <em>free</em>, though, is that they have nothing else. For instance, the additive operation on lists (concatenation) isn’t commutative: if it was, they wouldn’t be the free monoid any more, because they satisfy an extra law that’s not in monoid.</p>
<p>For our case, we can use the free monad: this takes a functor and gives it a monad instance, in a way we know will satisfy all the laws. This encoding is used in several papers <span class="citation" data-cites="scibior_practical_2015 larsen_memory_2011">(Ścibior, Ghahramani, and Gordon <a href="#ref-scibior_practical_2015">2015</a>; Larsen <a href="#ref-larsen_memory_2011">2011</a>)</span>.</p>
<p>The idea is to first figure out what primitive operation you need. We’ll use weighted choice:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="ot">choose ::</span> <span class="dt">Prob</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span> <span class="ot">-&gt;</span> <span class="dt">Prob</span> a <span class="ot">-&gt;</span> <span class="dt">Prob</span> a</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">choose <span class="fu">=</span> <span class="fu">...</span></a></code></pre></div>
<p>Then you encode it as a functor:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Choose</span> a</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Choose</span> <span class="dt">Rational</span> a a</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">    <span class="kw">deriving</span> (<span class="dt">Functor</span>,<span class="dt">Foldable</span>)</a></code></pre></div>
<p>We’ll say the left-hand-choice has chance <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>, and the right-hand <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>−</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">1-p</annotation></semantics></math>. Then, you just wrap it in the free monad:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Prob</span> <span class="fu">=</span> <span class="dt">Free</span> <span class="dt">Choose</span></a></code></pre></div>
<p>And you already have a monad instance. Support comes from the <a href="http://hackage.haskell.org/package/base-4.11.1.0/docs/Data-Foldable.html#v:toList"><code class="sourceCode haskell"><span class="dt">Foldable</span></code></a> instance:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Data.Foldable</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2"></a>
<a class="sourceLine" id="cb17-3" data-line-number="3"><span class="ot">support ::</span> <span class="dt">Prob</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb17-4" data-line-number="4">support <span class="fu">=</span> toList</a></code></pre></div>
<p>Expectation is an “interpreter” for the DSL:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="ot">expect ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Rational</span>) <span class="ot">-&gt;</span> <span class="dt">Prob</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2">expect p <span class="fu">=</span> iter f <span class="fu">.</span> fmap p</a>
<a class="sourceLine" id="cb18-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-4" data-line-number="4">    f (<span class="dt">Choose</span> c l r) <span class="fu">=</span> l <span class="fu">*</span> c <span class="fu">+</span> r <span class="fu">*</span> (<span class="dv">1</span><span class="fu">-</span>c)</a></code></pre></div>
<p>For building up the tree, we can use Huffman’s algorithm:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="ot">fromList ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Rational</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Prob</span> a</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">fromList p <span class="fu">=</span> go <span class="fu">.</span> foldMap (\x <span class="ot">-&gt;</span> singleton (p x) (<span class="dt">Pure</span> x))</a>
<a class="sourceLine" id="cb19-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-4" data-line-number="4">    go xs <span class="fu">=</span> <span class="kw">case</span> minView xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb19-5" data-line-number="5">      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> error <span class="st">&quot;empty list&quot;</span></a>
<a class="sourceLine" id="cb19-6" data-line-number="6">      <span class="dt">Just</span> ((xp,x),ys) <span class="ot">-&gt;</span> <span class="kw">case</span> minView ys <span class="kw">of</span></a>
<a class="sourceLine" id="cb19-7" data-line-number="7">        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> x</a>
<a class="sourceLine" id="cb19-8" data-line-number="8">        <span class="dt">Just</span> ((yp,y),zs) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb19-9" data-line-number="9">          go (insertHeap (xp<span class="fu">+</span>yp) (<span class="dt">Free</span> (<span class="dt">Choose</span> (xp<span class="fu">/</span>(xp<span class="fu">+</span>yp)) x y)) zs)</a></code></pre></div>
<p>And finally, it gets the same notation as before:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1">uniform <span class="fu">=</span> fromList (const <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb20-2" data-line-number="2"></a>
<a class="sourceLine" id="cb20-3" data-line-number="3">die <span class="fu">=</span> uniform [<span class="dv">1</span><span class="fu">..</span><span class="dv">6</span>]</a>
<a class="sourceLine" id="cb20-4" data-line-number="4"></a>
<a class="sourceLine" id="cb20-5" data-line-number="5">probOf p <span class="fu">=</span> expect (bool <span class="dv">0</span> <span class="dv">1</span> <span class="fu">.</span> p)</a>
<a class="sourceLine" id="cb20-6" data-line-number="6"></a>
<a class="sourceLine" id="cb20-7" data-line-number="7"><span class="fu">&gt;&gt;&gt;</span> probOf (<span class="dv">7</span><span class="fu">==</span>) <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb20-8" data-line-number="8">  x <span class="ot">&lt;-</span> die</a>
<a class="sourceLine" id="cb20-9" data-line-number="9">  y <span class="ot">&lt;-</span> die</a>
<a class="sourceLine" id="cb20-10" data-line-number="10">  pure (x <span class="fu">+</span> y)</a>
<a class="sourceLine" id="cb20-11" data-line-number="11"><span class="dv">1</span> <span class="fu">%</span> <span class="dv">6</span></a></code></pre></div>
<p>One of the advantages of the free approach is that it’s easy to define multiple interpreters. We could, for instance, write an interpreter that constructs a diagram:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> drawTree ((,) <span class="fu">&lt;$&gt;</span> uniform <span class="st">&quot;abc&quot;</span> <span class="fu">&lt;*&gt;</span> uniform <span class="st">&quot;de&quot;</span>)</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">           ┌(<span class="ch">&#39;c&#39;</span>,<span class="ch">&#39;d&#39;</span>)</a>
<a class="sourceLine" id="cb21-3" data-line-number="3">     ┌<span class="dv">1</span> <span class="fu">%</span> 2┤</a>
<a class="sourceLine" id="cb21-4" data-line-number="4">     │     └(<span class="ch">&#39;c&#39;</span>,<span class="ch">&#39;e&#39;</span>)</a>
<a class="sourceLine" id="cb21-5" data-line-number="5"><span class="dv">1</span> <span class="fu">%</span> 3┤</a>
<a class="sourceLine" id="cb21-6" data-line-number="6">     │           ┌(<span class="ch">&#39;a&#39;</span>,<span class="ch">&#39;d&#39;</span>)</a>
<a class="sourceLine" id="cb21-7" data-line-number="7">     │     ┌<span class="dv">1</span> <span class="fu">%</span> 2┤</a>
<a class="sourceLine" id="cb21-8" data-line-number="8">     │     │     └(<span class="ch">&#39;a&#39;</span>,<span class="ch">&#39;e&#39;</span>)</a>
<a class="sourceLine" id="cb21-9" data-line-number="9">     └<span class="dv">1</span> <span class="fu">%</span> 2┤</a>
<a class="sourceLine" id="cb21-10" data-line-number="10">           │     ┌(<span class="ch">&#39;b&#39;</span>,<span class="ch">&#39;d&#39;</span>)</a>
<a class="sourceLine" id="cb21-11" data-line-number="11">           └<span class="dv">1</span> <span class="fu">%</span> 2┤</a>
<a class="sourceLine" id="cb21-12" data-line-number="12">                 └(<span class="ch">&#39;b&#39;</span>,<span class="ch">&#39;e&#39;</span>)</a></code></pre></div>
<h1 id="final">Final</h1>
<p>There’s a lot to be said about free objects in category theory, also. Specifically, they’re related to initial and terminal (also called final) objects. The encoding above is initial, the final encoding is simply <code class="sourceCode haskell"><span class="dt">Cont</span></code>:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Cont</span> r a <span class="fu">=</span> <span class="dt">Cont</span> {<span class="ot"> runCont ::</span> (a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r }</a>
<a class="sourceLine" id="cb22-2" data-line-number="2"></a>
<a class="sourceLine" id="cb22-3" data-line-number="3"><span class="kw">type</span> <span class="dt">Prob</span> <span class="fu">=</span> <span class="dt">Cont</span> <span class="dt">Rational</span></a></code></pre></div>
<p>Here, also, we get the monad instance for free. In contrast to previously, expect is free:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1">expect <span class="fu">=</span> flip runCont</a></code></pre></div>
<p>Support, though, isn’t possible.</p>
<p>This version is also called the Giry monad: there’s a deep and fascinating theory behind it, which I probably won’t be able to do justice to here. Check out Jared Tobin’s post <span class="citation" data-cites="tobin_implementing_2017">(<a href="#ref-tobin_implementing_2017">2017</a>)</span> for a good deep dive on it.</p>
<h1 id="cofree">Cofree</h1>
<p>The branching structure of the tree captures the semantics of the probability monad well, but it doesn’t give us much insight into the original implementation. The question is, how can we deconstruct this:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Prob</span> a</a>
<a class="sourceLine" id="cb24-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Prob</span></a>
<a class="sourceLine" id="cb24-3" data-line-number="3">    {<span class="ot"> runProb ::</span> [(a, <span class="dt">Rational</span>)]</a>
<a class="sourceLine" id="cb24-4" data-line-number="4">    }</a></code></pre></div>
<p>Eric Kidd <span class="citation" data-cites="kidd_build_2007">(<a href="#ref-kidd_build_2007">2007</a>)</span> pointed out that the monad is the composition of the writer and list monads:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Prob</span> <span class="fu">=</span> <span class="dt">WriterT</span> (<span class="dt">Product</span> <span class="dt">Rational</span>) []</a></code></pre></div>
<p>but that seems unsatisfying: in contrast to the tree-based version, we don’t encode any branching structure, we’re able to have empty distributions, and it has the combinatorial explosion problem.</p>
<p>Adding a weighting to nondeterminism is encapsulated more concretely by the <code class="sourceCode haskell"><span class="dt">ListT</span></code> transformer. It looks like this:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">ListT</span> m a</a>
<a class="sourceLine" id="cb26-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">ListT</span></a>
<a class="sourceLine" id="cb26-3" data-line-number="3">    {<span class="ot"> runListT ::</span> m (<span class="dt">Maybe</span> (a, <span class="dt">ListT</span> m a))</a>
<a class="sourceLine" id="cb26-4" data-line-number="4">    }</a></code></pre></div>
<p>It’s a cons-list, with an effect before every layer<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>.</p>
<p>While this can be used to give us the monad we need, I’ve found that something more like this fits the abstraction better:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="kw">data</span> <span class="dt">ListT</span> m a</a>
<a class="sourceLine" id="cb27-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">ListT</span> a (m (<span class="dt">Maybe</span> (<span class="dt">ListT</span> m a)))</a></code></pre></div>
<p>It’s a nonempty list, with the first element exposed. Turns out this is very similar to the cofree comonad:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Cofree</span> f a <span class="fu">=</span> a <span class="fu">:&lt;</span> f (<span class="dt">Cofree</span> f a)</a></code></pre></div>
<p>Just like the initial free encoding, we can start with a primitive operation:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Perhaps</span> a</a>
<a class="sourceLine" id="cb29-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Impossible</span></a>
<a class="sourceLine" id="cb29-3" data-line-number="3">    <span class="fu">|</span> <span class="dt">WithChance</span> <span class="dt">Rational</span> a</a>
<a class="sourceLine" id="cb29-4" data-line-number="4">    <span class="kw">deriving</span> (<span class="dt">Functor</span>,<span class="dt">Foldable</span>)</a></code></pre></div>
<p>And we get all of our instances as well:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Prob</span> a</a>
<a class="sourceLine" id="cb30-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Prob</span></a>
<a class="sourceLine" id="cb30-3" data-line-number="3">    {<span class="ot"> runProb ::</span> <span class="dt">Cofree</span> <span class="dt">Perhaps</span> a</a>
<a class="sourceLine" id="cb30-4" data-line-number="4">    } <span class="kw">deriving</span> (<span class="dt">Functor</span>,<span class="dt">Foldable</span>)</a>
<a class="sourceLine" id="cb30-5" data-line-number="5">    </a>
<a class="sourceLine" id="cb30-6" data-line-number="6"><span class="kw">instance</span> <span class="dt">Comonad</span> <span class="dt">Prob</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-7" data-line-number="7">    extract (<span class="dt">Prob</span> xs) <span class="fu">=</span> extract xs</a>
<a class="sourceLine" id="cb30-8" data-line-number="8">    duplicate (<span class="dt">Prob</span> xs) <span class="fu">=</span> <span class="dt">Prob</span> (fmap <span class="dt">Prob</span> (duplicate xs))</a>
<a class="sourceLine" id="cb30-9" data-line-number="9"></a>
<a class="sourceLine" id="cb30-10" data-line-number="10"><span class="ot">foldProb ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Rational</span> <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Prob</span> a <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb30-11" data-line-number="11">foldProb f b <span class="fu">=</span> r <span class="fu">.</span> runProb</a>
<a class="sourceLine" id="cb30-12" data-line-number="12">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-13" data-line-number="13">    r (x <span class="fu">:&lt;</span> <span class="dt">Impossible</span>) <span class="fu">=</span> b x</a>
<a class="sourceLine" id="cb30-14" data-line-number="14">    r (x <span class="fu">:&lt;</span> <span class="dt">WithChance</span> p xs) <span class="fu">=</span> f x p (r xs)</a>
<a class="sourceLine" id="cb30-15" data-line-number="15"></a>
<a class="sourceLine" id="cb30-16" data-line-number="16"><span class="ot">uniform ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Prob</span> a</a>
<a class="sourceLine" id="cb30-17" data-line-number="17">uniform (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="dt">Prob</span> (coiterW f (<span class="dt">EnvT</span> (length xs) (x <span class="fu">:|</span> xs)))</a>
<a class="sourceLine" id="cb30-18" data-line-number="18">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-19" data-line-number="19">    f (<span class="dt">EnvT</span> <span class="dv">0</span> (_ <span class="fu">:|</span> [])) <span class="fu">=</span> <span class="dt">Impossible</span></a>
<a class="sourceLine" id="cb30-20" data-line-number="20">    f (<span class="dt">EnvT</span> n (_ <span class="fu">:|</span> (y<span class="fu">:</span>ys))) </a>
<a class="sourceLine" id="cb30-21" data-line-number="21">        <span class="fu">=</span> <span class="dt">WithChance</span> (<span class="dv">1</span> <span class="fu">%</span> fromIntegral n) (<span class="dt">EnvT</span> (n <span class="fu">-</span> <span class="dv">1</span>) (y<span class="fu">:|</span>ys))</a>
<a class="sourceLine" id="cb30-22" data-line-number="22"></a>
<a class="sourceLine" id="cb30-23" data-line-number="23"><span class="ot">expect ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Rational</span>) <span class="ot">-&gt;</span> <span class="dt">Prob</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span></a>
<a class="sourceLine" id="cb30-24" data-line-number="24">expect p <span class="fu">=</span> foldProb f p</a>
<a class="sourceLine" id="cb30-25" data-line-number="25">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-26" data-line-number="26">    f x n xs <span class="fu">=</span> (p x <span class="fu">*</span> n <span class="fu">+</span> xs) <span class="fu">/</span> (n <span class="fu">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb30-27" data-line-number="27"></a>
<a class="sourceLine" id="cb30-28" data-line-number="28"><span class="ot">probOf ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Prob</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span></a>
<a class="sourceLine" id="cb30-29" data-line-number="29">probOf p <span class="fu">=</span> expect (\x <span class="ot">-&gt;</span> <span class="kw">if</span> p x <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb30-30" data-line-number="30"></a>
<a class="sourceLine" id="cb30-31" data-line-number="31"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Prob</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-32" data-line-number="32">    pure x <span class="fu">=</span> <span class="dt">Prob</span> (x <span class="fu">:&lt;</span> <span class="dt">Impossible</span>)</a>
<a class="sourceLine" id="cb30-33" data-line-number="33">    (<span class="fu">&lt;*&gt;</span>) <span class="fu">=</span> ap</a>
<a class="sourceLine" id="cb30-34" data-line-number="34">    </a>
<a class="sourceLine" id="cb30-35" data-line-number="35"><span class="ot">append ::</span> <span class="dt">Prob</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span> <span class="ot">-&gt;</span> <span class="dt">Prob</span> a <span class="ot">-&gt;</span> <span class="dt">Prob</span> a</a>
<a class="sourceLine" id="cb30-36" data-line-number="36">append <span class="fu">=</span> foldProb f (\x y <span class="ot">-&gt;</span>  <span class="dt">Prob</span> <span class="fu">.</span> (x <span class="fu">:&lt;</span>) <span class="fu">.</span> <span class="dt">WithChance</span> y <span class="fu">.</span> runProb)</a>
<a class="sourceLine" id="cb30-37" data-line-number="37">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-38" data-line-number="38">    f e r a p <span class="fu">=</span> <span class="dt">Prob</span> <span class="fu">.</span> (e <span class="fu">:&lt;</span>) <span class="fu">.</span> <span class="dt">WithChance</span> ip <span class="fu">.</span> runProb <span class="fu">.</span> a op</a>
<a class="sourceLine" id="cb30-39" data-line-number="39">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-40" data-line-number="40">        ip <span class="fu">=</span> p <span class="fu">*</span> r <span class="fu">/</span> (p <span class="fu">+</span> r <span class="fu">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb30-41" data-line-number="41">        op <span class="fu">=</span> p <span class="fu">/</span> (r <span class="fu">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb30-42" data-line-number="42"></a>
<a class="sourceLine" id="cb30-43" data-line-number="43"><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Prob</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-44" data-line-number="44">    xs <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> foldProb (append <span class="fu">.</span> f) f xs</a></code></pre></div>
<p>We see here that we’re talking about gambling-style odds, rather than probability. I wonder if the two representations are dual somehow?</p>
<p>The application of comonads to streams (<code class="sourceCode haskell"><span class="dt">ListT</span></code>) has been explored before <span class="citation" data-cites="uustalu_essence_2005">(Uustalu and Vene <a href="#ref-uustalu_essence_2005">2005</a>)</span>; I wonder if there are any insights to be gleaned from this particular probability comonad.</p>
<h1 id="references" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-erwig_functional_2006">
<p>Erwig, Martin, and Steve Kollmansberger. 2006. “Functional pearls: Probabilistic functional programming in Haskell.” <em>Journal of Functional Programming</em> 16 (1): 21–34. doi:<a href="https://doi.org/10.1017/S0956796805005721">10.1017/S0956796805005721</a>.</p>
</div>
<div id="ref-kidd_build_2007">
<p>Kidd, Eric. 2007. “Build your own probability monads.”</p>
</div>
<div id="ref-larsen_memory_2011">
<p>Larsen, Ken Friis. 2011. “Memory Efficient Implementation of Probability Monads.”</p>
</div>
<div id="ref-scibior_practical_2015">
<p>Ścibior, Adam, Zoubin Ghahramani, and Andrew D. Gordon. 2015. “Practical Probabilistic Programming with Monads.” In <em>Proceedings of the 2015 ACM SIGPLAN Symposium on Haskell</em>, 50:165–176. Haskell ’15. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/2804302.2804317">10.1145/2804302.2804317</a>.</p>
</div>
<div id="ref-tobin_implementing_2017">
<p>Tobin, Jared. 2017. “Implementing the Giry Monad.” <em>jtobin.io</em>.</p>
</div>
<div id="ref-uustalu_essence_2005">
<p>Uustalu, Tarmo, and Varmo Vene. 2005. “The Essence of Dataflow Programming.” In <em>Proceedings of the Third Asian Conference on Programming Languages and Systems</em>, 2–18. APLAS’05. Berlin, Heidelberg: Springer-Verlag. doi:<a href="https://doi.org/10.1007/11575467_2">10.1007/11575467_2</a>.</p>
</div>
</div>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Note this is <em>not</em> the same as the <code class="sourceCode haskell"><span class="dt">ListT</span></code> in <a href="http://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-List.html">transformers</a>; instead it’s a “<a href="https://wiki.haskell.org/ListT_done_right">ListT done right</a>”.<a href="#fnref1" class="footnote-back">↩</a></p></li>
</ol>
</section>
]]></description>
    <pubDate>Sat, 30 Jun 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-06-30-probability-5-ways.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Scheduling Effects</title>
    <link>https://doisinkidney.com/posts/2018-06-23-scheduling-effects.html</link>
    <description><![CDATA[<div class="info">
    Posted on June 23, 2018
</div>
<div class="info">
    
        Part 4 of a <a href="/series/Breadth-First%20Traversals.html">7-part series on Breadth-First Traversals</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<p>After the <a href="2018-06-03-breadth-first-traversals-in-too-much-detail.html">last post</a>, Noah Easterly pointed me to their <a href="https://hackage.haskell.org/package/tree-traversals">tree-traversals library</a>, and in particular the <a href="https://hackage.haskell.org/package/tree-traversals-0.1.0.0/docs/Control-Applicative-Phases.html#t:Phases"><code class="sourceCode haskell"><span class="dt">Phases</span></code></a> applicative transformer. It allows you to batch applicative effects to be run together: for the breadth-first traversal, we can batch the effects from each level together, giving us a lovely short solution to the problem.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1">breadthFirst c <span class="fu">=</span> runPhasesForwards <span class="fu">.</span> go</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">    go (x<span class="fu">:&lt;</span>xs) <span class="fu">=</span> liftA2 (<span class="fu">:&lt;</span>) (now (c x)) (delay (traverse go xs))</a></code></pre></div>
<p>In my efforts to speed this implementation up, I came across a wide and interesting literature on scheduling effects, which I’ll go through a little here.</p>
<h1 id="coroutines">Coroutines</h1>
<p>The first thing that jumps to mind, for me, when I think of “scheduling” is coroutines. These are constructs that let you finely control the order of execution of effects. They’re well explored in Haskell by now, and most libraries will let you do something like the following:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1">oneThenTwo <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  liftIO <span class="fu">$</span> print <span class="dv">1</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  delay <span class="fu">$</span> liftIO <span class="fu">$</span> print <span class="dv">2</span></a></code></pre></div>
<p>We first print <code>1</code>, then, after a delay, we print <code>2</code>. The <code class="sourceCode haskell">delay</code> doesn’t make a difference if we just run the whole thing:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> retract oneThenTwo</a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="dv">1</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="dv">2</span></a></code></pre></div>
<p>But you can see its effect when we use the <code class="sourceCode haskell">interleave</code> combinator:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> retract <span class="fu">$</span> interleave (replicate <span class="dv">3</span> oneThenTwo)</a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="dv">1</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="dv">1</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="dv">1</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="dv">2</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6"><span class="dv">2</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7"><span class="dv">2</span></a></code></pre></div>
<p>Hopefully you can see how useful this might be, and the similarity to the <code class="sourceCode haskell"><span class="dt">Phases</span></code> construction.</p>
<p>The genealogy of most coroutine libraries in Haskell seems to trace back to <span class="citation" data-cites="blazevic_coroutine_2011">Blažević (<a href="#ref-blazevic_coroutine_2011">2011</a>)</span> or <span class="citation" data-cites="kiselyov_iteratees_2012">Kiselyov (<a href="#ref-kiselyov_iteratees_2012">2012</a>)</span>: the implementation I have been using in these past few examples (<a href="http://hackage.haskell.org/package/free-5.0.2/docs/Control-Monad-Trans-Iter.html"><code>IterT</code></a>) comes from a slightly different place. Let’s take a quick detour to explore it a little.</p>
<h1 id="partiality">Partiality</h1>
<p>In functional programming, there are several constructions for modeling error-like states: <code class="sourceCode haskell"><span class="dt">Maybe</span></code> for your nulls, <code class="sourceCode haskell"><span class="dt">Either</span></code> for your exceptions. What separates these approaches from the “unsafe” variants (null pointers, unchecked exceptions) is that we can <em>prove</em>, in the type system, that the error case is handled correctly.</p>
<p>Conspicuously absent from the usual toolbox for modeling partiality is a way to model <em>nontermination</em>. At first glance, it may seem strange to attempt to do so in Haskell. After all, if I have a function of type:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a></code></pre></div>
<p>I can prove that I won’t throw any errors (with <code class="sourceCode haskell"><span class="dt">Either</span></code>, that is), because the type <code class="sourceCode haskell"><span class="dt">Int</span></code> doesn’t contain <code class="sourceCode haskell"><span class="dt">Left</span> _</code>. I’ve also proved, miraculously, that I won’t make any null dereferences, because <code class="sourceCode haskell"><span class="dt">Int</span></code> also doesn’t contain <code class="sourceCode haskell"><span class="dt">Nothing</span></code>. I <em>haven’t</em> proved, however, that I won’t loop infinitely, because (in Haskell), <code class="sourceCode haskell"><span class="dt">Int</span></code> absolutely <em>does</em> contain <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>⊥</mi><annotation encoding="application/x-tex">\bot</annotation></semantics></math>.</p>
<p>So we’re somewhat scuppered. On the other hand, While we can’t <em>prove</em> termination in Haskell, we can:</p>
<ol>
<li>Model it.</li>
<li>Prove it in something else.</li>
</ol>
<p>Which is exactly what Venanzio Capretta did in the fascinating (and quite accessible) talk “Partiality is an effect” <span class="citation" data-cites="capretta_partiality_2004">(Capretta, Altenkirch, and Uustalu <a href="#ref-capretta_partiality_2004">2004</a>)</span><a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>.</p>
<p>The monad in question looks like this:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode idris"><code class="sourceCode idris"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Iter</span> a</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Now</span> a</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">    <span class="fu">|</span> <span class="dt">Later</span> (<span class="dt">Inf</span> (<span class="dt">Iter</span> a))</a></code></pre></div>
<p>We’re writing in Idris for the time being, so that we can prove termination and so on. The “recursive call” to <code class="sourceCode haskell"><span class="dt">Iter</span></code> is guarded by the <code class="sourceCode haskell"><span class="dt">Inf</span></code> type: this turns on a different kind of totality checking in the compiler. Usually, Idris will prevent you from constructing infinite values. But that’s exactly what we want to do here. Take the little-known function <a href="http://hackage.haskell.org/package/base-4.11.1.0/docs/Prelude.html#v:until"><code class="sourceCode haskell">until</code></a>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1">until<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a></code></pre></div>
<p>It’s clearly not necessarily total, and the totality checker will complain as such when we try and implement it directly:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode idris"><code class="sourceCode idris"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="fu">until</span> <span class="ot">:</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">until p f x <span class="fu">=</span> <span class="kw">if</span> p x <span class="kw">then</span> x <span class="kw">else</span> until p f (f x)</a></code></pre></div>
<p>But we can use <code class="sourceCode haskell"><span class="dt">Iter</span></code> to model that possible totality:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode idris"><code class="sourceCode idris"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="fu">until</span> <span class="ot">:</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Iter</span> a</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">until p f x <span class="fu">=</span> <span class="kw">if</span> p x <span class="kw">then</span> <span class="dt">Now</span> x <span class="kw">else</span> <span class="dt">Later</span> (until p f (f x))</a></code></pre></div>
<p>Of course, nothing’s for free: when we get the ability to construct infinite values, we lose the ability to consume them.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode idris"><code class="sourceCode idris"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="fu">run</span> <span class="ot">:</span> <span class="dt">Iter</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">run (<span class="dt">Now</span> x) <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">run (<span class="dt">Later</span> x) <span class="fu">=</span> run x</a></code></pre></div>
<p>We get an error on the <code class="sourceCode haskell">run</code> function. However, as you would expect, we can run <em>guarded</em> iteration: iteration up until some finite point.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode idris"><code class="sourceCode idris"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="fu">runUntil</span> <span class="ot">:</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Iter</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">runUntil <span class="dt">Z</span> <span class="fu">_</span> <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">runUntil (<span class="dt">S</span> n) (<span class="dt">Now</span> x) <span class="fu">=</span> <span class="dt">Just</span> x</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">runUntil (<span class="dt">S</span> n) (<span class="dt">Later</span> x) <span class="fu">=</span> runUntil n x</a></code></pre></div>
<p>Making our way back to Haskell, we must first—as is the law—add a type parameter, and upgrade our humble monad to a monad transformer:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">IterT</span> m a <span class="fu">=</span> <span class="dt">IterT</span> {<span class="ot"> runIterT ::</span> m (<span class="dt">Either</span> a (<span class="dt">IterT</span> m a)) }</a>
<a class="sourceLine" id="cb12-2" data-line-number="2"></a>
<a class="sourceLine" id="cb12-3" data-line-number="3"><span class="kw">type</span> <span class="dt">Iter</span> <span class="fu">=</span> <span class="dt">IterT</span> <span class="dt">Identity</span></a></code></pre></div>
<p>The semantic meaning of the extra <code class="sourceCode haskell">m</code> here is interesting: each layer adds not just a recursive step, or a single iteration, but a single effect. Interpreting things in this way gets us back to the original goal:</p>
<h1 id="scheduling">Scheduling</h1>
<p>The <code class="sourceCode haskell"><span class="dt">Later</span></code> constructor above can be translated to a <code class="sourceCode haskell">delay</code> function on the transformer:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1">delay <span class="fu">=</span> <span class="dt">IterT</span> <span class="fu">.</span> pure <span class="fu">.</span> <span class="dt">Right</span></a></code></pre></div>
<p>And using this again, we can write the following incredibly short definition for <code class="sourceCode haskell">unfoldTreeM_BF</code>:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="ot">unfoldTreeM_BF ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (b <span class="ot">-&gt;</span> m (a, [b])) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> m (<span class="dt">Tree</span> a)</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">unfoldTreeM_BF f <span class="fu">=</span> retract <span class="fu">.</span> go</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-4" data-line-number="4">    go b <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb14-5" data-line-number="5">      (x,xs) <span class="ot">&lt;-</span> lift (f b)</a>
<a class="sourceLine" id="cb14-6" data-line-number="6">      fmap (<span class="dt">Node</span> x) (interleave (map (delay <span class="fu">.</span> go) xs))</a></code></pre></div>
<h1 id="applicative">Applicative</h1>
<p>It would be nice to bring this back to traversals, but alas, <code class="sourceCode haskell"><span class="dt">IterT</span></code> is pretty monad-centric. What’s more, if it’s analogous to <code class="sourceCode haskell"><span class="dt">Phases</span></code> it certainly doesn’t look like it:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Phases</span> f a <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2">  <span class="dt">Lift</span><span class="ot"> ::</span> f a <span class="ot">-&gt;</span> <span class="dt">Phases</span> f a</a>
<a class="sourceLine" id="cb15-3" data-line-number="3"><span class="ot">  (:&lt;*&gt;) ::</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Phases</span> f a <span class="ot">-&gt;</span> <span class="dt">Phases</span> f b</a></code></pre></div>
<p>However, in the documentation for <a href="http://hackage.haskell.org/package/free-5.0.2/docs/Control-Monad-Trans-Iter.html#t:IterT"><code class="sourceCode haskell"><span class="dt">IterT</span></code></a>, there’s the following little note:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="dt">IterT</span> <span class="fu">~</span> <span class="dt">FreeT</span> <span class="dt">Identity</span></a></code></pre></div>
<p>Where <code class="sourceCode haskell"><span class="dt">FreeT</span></code> is the <a href="http://hackage.haskell.org/package/free-5.0.2/docs/Control-Monad-Trans-Free.html">free monad transformer</a>. This seems to strongly hint that we could get the same thing for applicatives with <a href="http://hackage.haskell.org/package/free-5.0.2/docs/Control-Applicative-Trans-Free.html"><code class="sourceCode haskell"><span class="dt">ApT</span></code></a>. Let’s try it:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Phases</span> f a <span class="fu">=</span> <span class="dt">Phases</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2">    {<span class="ot"> runPhases ::</span> <span class="dt">ApT</span> <span class="dt">Identity</span> f a</a>
<a class="sourceLine" id="cb17-3" data-line-number="3">    } <span class="kw">deriving</span> <span class="dt">Functor</span></a></code></pre></div>
<p>The <code class="sourceCode haskell"><span class="dt">Applicative</span></code> instance is a little hairy, but it <em>seems</em> correct:</p>
<details>
<p><summary> Applicative Instance </summary></p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2">         <span class="dt">Applicative</span> (<span class="dt">Phases</span> f) <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3">    pure <span class="fu">=</span> <span class="dt">Phases</span> <span class="fu">.</span> pure</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">    liftA2 f&#39; (<span class="dt">Phases</span> (<span class="dt">ApT</span> xs&#39;)) (<span class="dt">Phases</span> (<span class="dt">ApT</span> ys&#39;)) <span class="fu">=</span></a>
<a class="sourceLine" id="cb18-5" data-line-number="5">        <span class="dt">Phases</span> (<span class="dt">ApT</span> (liftA2 (go f&#39;) xs&#39; ys&#39;))</a>
<a class="sourceLine" id="cb18-6" data-line-number="6">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-7" data-line-number="7">        go</a>
<a class="sourceLine" id="cb18-8" data-line-number="8"><span class="ot">            ::</span> <span class="ot">∀</span> a b c<span class="fu">.</span></a>
<a class="sourceLine" id="cb18-9" data-line-number="9">               (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c)</a>
<a class="sourceLine" id="cb18-10" data-line-number="10">            <span class="ot">-&gt;</span> <span class="dt">ApF</span> <span class="dt">Identity</span> f a</a>
<a class="sourceLine" id="cb18-11" data-line-number="11">            <span class="ot">-&gt;</span> <span class="dt">ApF</span> <span class="dt">Identity</span> f b</a>
<a class="sourceLine" id="cb18-12" data-line-number="12">            <span class="ot">-&gt;</span> <span class="dt">ApF</span> <span class="dt">Identity</span> f c</a>
<a class="sourceLine" id="cb18-13" data-line-number="13">        go f (<span class="dt">Pure</span> x) ys <span class="fu">=</span> fmap (f x) ys</a>
<a class="sourceLine" id="cb18-14" data-line-number="14">        go f xs (<span class="dt">Pure</span> y) <span class="fu">=</span> fmap (<span class="ot">`f`</span> y) xs</a>
<a class="sourceLine" id="cb18-15" data-line-number="15">        go f (<span class="dt">Ap</span> x (<span class="dt">ApT</span> xs)) (<span class="dt">Ap</span> y (<span class="dt">ApT</span> ys)) <span class="fu">=</span></a>
<a class="sourceLine" id="cb18-16" data-line-number="16">            <span class="dt">Ap</span></a>
<a class="sourceLine" id="cb18-17" data-line-number="17">                (liftA2 (,) x y)</a>
<a class="sourceLine" id="cb18-18" data-line-number="18">                (<span class="dt">ApT</span> (liftA2 (go (\xx yy <span class="ot">-&gt;</span> uncurry f <span class="fu">.</span> (xx <span class="fu">***</span> yy))) xs ys))</a></code></pre></div>
</details>
<p>(on a side note: thank <em>goodness</em> for <code class="sourceCode haskell">liftA2</code> finally getting into <code class="sourceCode haskell"><span class="dt">Applicative</span></code>)</p>
<p>And we get all the normal combinators:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="ot">delay ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">Phases</span> f a <span class="ot">-&gt;</span> <span class="dt">Phases</span> f a</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">delay <span class="fu">=</span> <span class="dt">Phases</span> <span class="fu">.</span> <span class="dt">ApT</span> <span class="fu">.</span> pure <span class="fu">.</span> <span class="dt">Ap</span> (pure ()) <span class="fu">.</span> fmap const <span class="fu">.</span> runPhases</a>
<a class="sourceLine" id="cb19-3" data-line-number="3"></a>
<a class="sourceLine" id="cb19-4" data-line-number="4"><span class="ot">lift ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Phases</span> f a</a>
<a class="sourceLine" id="cb19-5" data-line-number="5">lift <span class="fu">=</span> <span class="dt">Phases</span> <span class="fu">.</span> liftApO</a></code></pre></div>
<p>The issue comes with running the thing at the end: <code class="sourceCode haskell"><span class="dt">Monad</span></code> creeps back in.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="ot">retract ::</span> <span class="dt">Monad</span> f <span class="ot">=&gt;</span> <span class="dt">Phases</span> f a <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb20-2" data-line-number="2">retract <span class="fu">=</span> fmap (runIdentity <span class="fu">.</span> retractAp) <span class="fu">.</span> joinApT <span class="fu">.</span> runPhases</a></code></pre></div>
<p>Because the effects are all layered on top of each other, you need to flatten them out at the end, which requires <code class="sourceCode haskell">join</code>. Mind you, it does work: it’s just not as general as it could be.</p>
<p>All’s not lost, though. Turns out, we never needed the transformer in the first place: we could just define the different applicative instance straight off.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Phases</span> f a <span class="fu">=</span> <span class="dt">Phases</span></a>
<a class="sourceLine" id="cb21-2" data-line-number="2">    {<span class="ot"> runPhases ::</span> <span class="dt">Ap</span> f a</a>
<a class="sourceLine" id="cb21-3" data-line-number="3">    } <span class="kw">deriving</span> <span class="dt">Functor</span></a>
<a class="sourceLine" id="cb21-4" data-line-number="4"></a>
<a class="sourceLine" id="cb21-5" data-line-number="5"><span class="kw">instance</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb21-6" data-line-number="6">         <span class="dt">Applicative</span> (<span class="dt">Phases</span> f) <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-7" data-line-number="7">    pure <span class="fu">=</span> <span class="dt">Phases</span> <span class="fu">.</span> <span class="dt">Pure</span></a>
<a class="sourceLine" id="cb21-8" data-line-number="8">    liftA2 f&#39; (<span class="dt">Phases</span> xs&#39;) (<span class="dt">Phases</span> ys&#39;) <span class="fu">=</span> <span class="dt">Phases</span> (go f&#39; xs&#39; ys&#39;)</a>
<a class="sourceLine" id="cb21-9" data-line-number="9">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-10" data-line-number="10"><span class="ot">        go ::</span> <span class="ot">∀</span> a b c<span class="fu">.</span></a>
<a class="sourceLine" id="cb21-11" data-line-number="11">              (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c)</a>
<a class="sourceLine" id="cb21-12" data-line-number="12">           <span class="ot">-&gt;</span> <span class="dt">Ap</span> f a</a>
<a class="sourceLine" id="cb21-13" data-line-number="13">           <span class="ot">-&gt;</span> <span class="dt">Ap</span> f b</a>
<a class="sourceLine" id="cb21-14" data-line-number="14">           <span class="ot">-&gt;</span> <span class="dt">Ap</span> f c</a>
<a class="sourceLine" id="cb21-15" data-line-number="15">        go f (<span class="dt">Pure</span> x) ys <span class="fu">=</span> fmap (f x) ys</a>
<a class="sourceLine" id="cb21-16" data-line-number="16">        go f xs (<span class="dt">Pure</span> y) <span class="fu">=</span> fmap (<span class="ot">`f`</span> y) xs</a>
<a class="sourceLine" id="cb21-17" data-line-number="17">        go f (<span class="dt">Ap</span> x xs) (<span class="dt">Ap</span> y ys) <span class="fu">=</span></a>
<a class="sourceLine" id="cb21-18" data-line-number="18">            <span class="dt">Ap</span></a>
<a class="sourceLine" id="cb21-19" data-line-number="19">                (liftA2 (,) x y)</a>
<a class="sourceLine" id="cb21-20" data-line-number="20">                (go (\xx yy <span class="ot">-&gt;</span> uncurry f <span class="fu">.</span> (xx <span class="fu">***</span> yy)) xs ys)</a>
<a class="sourceLine" id="cb21-21" data-line-number="21"></a>
<a class="sourceLine" id="cb21-22" data-line-number="22"><span class="ot">delay ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">Phases</span> f a <span class="ot">-&gt;</span> <span class="dt">Phases</span> f a</a>
<a class="sourceLine" id="cb21-23" data-line-number="23">delay <span class="fu">=</span> <span class="dt">Phases</span> <span class="fu">.</span> <span class="dt">Ap</span> (pure ()) <span class="fu">.</span> fmap const <span class="fu">.</span> runPhases</a>
<a class="sourceLine" id="cb21-24" data-line-number="24"></a>
<a class="sourceLine" id="cb21-25" data-line-number="25"><span class="ot">retract ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">Phases</span> f a <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb21-26" data-line-number="26">retract <span class="fu">=</span> retractAp <span class="fu">.</span> runPhases</a>
<a class="sourceLine" id="cb21-27" data-line-number="27"></a>
<a class="sourceLine" id="cb21-28" data-line-number="28"><span class="ot">lift ::</span> f a <span class="ot">-&gt;</span> <span class="dt">Phases</span> f a</a>
<a class="sourceLine" id="cb21-29" data-line-number="29">lift <span class="fu">=</span> <span class="dt">Phases</span> <span class="fu">.</span> liftAp</a></code></pre></div>
<h1 id="more-coroutines">More Coroutines</h1>
<p>In the wonderful article Coroutine Pipelines <span class="citation" data-cites="blazevic_coroutine_2011">(Blažević <a href="#ref-blazevic_coroutine_2011">2011</a>)</span>, several different threads on coroutine-like constructions are unified. What I’ve demonstrated above isn’t yet as powerful as what you might see in a full coroutine library: ideally, you’d want generators and sinks. As it turns out, when we look back at the note from <code class="sourceCode haskell"><span class="dt">IterT</span></code>:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="dt">IterT</span> <span class="fu">~</span> <span class="dt">FreeT</span> <span class="dt">Identity</span></a></code></pre></div>
<p>We can get both of those other constructs by swapping out <code class="sourceCode haskell"><span class="dt">Identity</span></code><a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="dt">Generator</span> a <span class="fu">=</span> <span class="dt">FreeT</span> ((,) a)</a>
<a class="sourceLine" id="cb23-2" data-line-number="2"><span class="dt">Sink</span> a <span class="fu">=</span> <span class="dt">FreeT</span> ((<span class="ot">-&gt;</span>) a)</a></code></pre></div>
<p>(<code class="sourceCode haskell"><span class="dt">Sink</span></code> is usually called an <code class="sourceCode haskell"><span class="dt">Iteratee</span></code>)</p>
<p>This is the fundamental abstraction that underlies things like the pipes library <span class="citation" data-cites="gonzalez_pipes_2018">(Gonzalez <a href="#ref-gonzalez_pipes_2018">2018</a>)</span>.</p>
<h1 id="interleaving">Interleaving</h1>
<p>The only missing part from the first coroutine example by now is <code class="sourceCode haskell">interleave</code>. In the free library, it has the following signature:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="ot">interleave ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> [<span class="dt">IterT</span> m a] <span class="ot">-&gt;</span> <span class="dt">IterT</span> m [a]</a></code></pre></div>
<p>But we should be able to spot that, really, it’s a traversal. And, as a traversal, it should rely on some underlying <code class="sourceCode haskell"><span class="dt">Applicative</span></code> instance. Let’s try and come up with one:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Parallel</span> m f a <span class="fu">=</span> <span class="dt">Parallel</span></a>
<a class="sourceLine" id="cb25-2" data-line-number="2">    {<span class="ot"> runParallel ::</span> <span class="dt">FreeT</span> m f a</a>
<a class="sourceLine" id="cb25-3" data-line-number="3">    }</a>
<a class="sourceLine" id="cb25-4" data-line-number="4"></a>
<a class="sourceLine" id="cb25-5" data-line-number="5"><span class="kw">instance</span> (<span class="dt">Functor</span> f, <span class="dt">Functor</span> m) <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb25-6" data-line-number="6">         <span class="dt">Functor</span> (<span class="dt">Parallel</span> m f) <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-7" data-line-number="7">    fmap f <span class="fu">=</span> <span class="dt">Parallel</span> <span class="fu">.</span> <span class="dt">FreeT</span> <span class="fu">.</span> fmap go <span class="fu">.</span> runFreeT <span class="fu">.</span> runParallel</a>
<a class="sourceLine" id="cb25-8" data-line-number="8">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-9" data-line-number="9">        go <span class="fu">=</span> bimap f (<span class="dt">FreeT</span> <span class="fu">.</span> fmap go <span class="fu">.</span> runFreeT)</a>
<a class="sourceLine" id="cb25-10" data-line-number="10"></a>
<a class="sourceLine" id="cb25-11" data-line-number="11"><span class="kw">instance</span> (<span class="dt">Applicative</span> f, <span class="dt">Applicative</span> m) <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb25-12" data-line-number="12">         <span class="dt">Applicative</span> (<span class="dt">Parallel</span> m f) <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-13" data-line-number="13">    pure <span class="fu">=</span> <span class="dt">Parallel</span> <span class="fu">.</span> <span class="dt">FreeT</span> <span class="fu">.</span> pure <span class="fu">.</span> <span class="dt">Pure</span></a>
<a class="sourceLine" id="cb25-14" data-line-number="14">    <span class="dt">Parallel</span> fs&#39; <span class="fu">&lt;*&gt;</span> <span class="dt">Parallel</span> xs&#39; <span class="fu">=</span> <span class="dt">Parallel</span> (unw fs&#39; xs&#39;)</a>
<a class="sourceLine" id="cb25-15" data-line-number="15">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-16" data-line-number="16">        unw (<span class="dt">FreeT</span> fs) (<span class="dt">FreeT</span> xs) <span class="fu">=</span> <span class="dt">FreeT</span> (liftA2 go fs xs)</a>
<a class="sourceLine" id="cb25-17" data-line-number="17">        go (<span class="dt">Pure</span> f) <span class="fu">=</span> bimap f (runParallel <span class="fu">.</span> fmap f <span class="fu">.</span> <span class="dt">Parallel</span>)</a>
<a class="sourceLine" id="cb25-18" data-line-number="18">        go (<span class="dt">Free</span> fs) <span class="fu">=</span> <span class="dt">Free</span> <span class="fu">.</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb25-19" data-line-number="19">            <span class="dt">Pure</span> x <span class="ot">-&gt;</span> fmap (runParallel <span class="fu">.</span> fmap (<span class="fu">$</span>x) <span class="fu">.</span> <span class="dt">Parallel</span>) fs</a>
<a class="sourceLine" id="cb25-20" data-line-number="20">            <span class="dt">Free</span> xs <span class="ot">-&gt;</span> liftA2 unw fs xs</a></code></pre></div>
<p>Now, interleave is just <code class="sourceCode haskell">sequenceA</code>!</p>
<h1 id="applicatives-again">Applicatives, Again</h1>
<p>So we can see that there’s a “parallel” applicative for both the free monad and the free applicative. To try and understand this type a little better, we can leverage our intuition about a much simpler, more familiar setting: lists. There’s an interesting similarity between lists and the free monad: <code class="sourceCode haskell"><span class="dt">FreeT</span> ((,) a)</code>) looks a lot like “<a href="https://wiki.haskell.org/ListT_done_right"><code class="sourceCode haskell"><span class="dt">ListT</span></code> done right</a>” (so much so, in fact, that most coroutine libraries provide their own version of it). More concretely, list also has a famous “parallel” applicative: <a href="http://hackage.haskell.org/package/base-4.11.1.0/docs/Control-Applicative.html#t:ZipList"><code class="sourceCode haskell"><span class="dt">ZipList</span></code></a>!</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">ZipList</span> a</a>
<a class="sourceLine" id="cb26-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">ZipList</span> </a>
<a class="sourceLine" id="cb26-3" data-line-number="3">    {<span class="ot"> getZipList ::</span> [a]</a>
<a class="sourceLine" id="cb26-4" data-line-number="4">    } <span class="kw">deriving</span> <span class="dt">Functor</span></a>
<a class="sourceLine" id="cb26-5" data-line-number="5"></a>
<a class="sourceLine" id="cb26-6" data-line-number="6"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">ZipList</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb26-7" data-line-number="7">  pure <span class="fu">=</span> <span class="dt">ZipList</span> <span class="fu">.</span> repeat</a>
<a class="sourceLine" id="cb26-8" data-line-number="8">  liftA2 f (<span class="dt">ZipList</span> xs) (<span class="dt">ZipList</span> ys) <span class="fu">=</span> <span class="dt">ZipList</span> (zipWith f xs ys)</a></code></pre></div>
<p>We’ll use some of our knowledge about <code class="sourceCode haskell"><span class="dt">ZipList</span></code> to help us in the next section.</p>
<h1 id="timekeeping">Timekeeping</h1>
<p>We’ve seen that efforts to model both coroutines and partiality end up in the same neighborhood: there’s yet another way to get there, which seems (at first) almost the opposite of the second. It starts with a blog post from Conor McBride <span class="citation" data-cites="mcbride_time_2009">(<a href="#ref-mcbride_time_2009">2009</a>)</span> called “Time flies like an applicative functor”. Curiously, here too breadth-first labeling is the focus. Remember first the lovely circular solution from <span class="citation" data-cites="jones_linear-time_1993-1">(<span class="citeproc-not-found" data-reference-id="jones_linear-time_1993-1"><strong>???</strong></span>)</span>:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a <span class="fu">=</span> <span class="dt">Leaf</span> <span class="fu">|</span> <span class="dt">Node</span> a (<span class="dt">Tree</span> a) (<span class="dt">Tree</span> a)</a>
<a class="sourceLine" id="cb27-2" data-line-number="2"></a>
<a class="sourceLine" id="cb27-3" data-line-number="3"><span class="ot">relabel ::</span> <span class="dt">Tree</span> x <span class="ot">-&gt;</span> [[a]] <span class="ot">-&gt;</span> (<span class="dt">Tree</span> a, [[a]])</a>
<a class="sourceLine" id="cb27-4" data-line-number="4">relabel <span class="dt">Leaf</span> xss <span class="fu">=</span> (<span class="dt">Leaf</span>,xss)</a>
<a class="sourceLine" id="cb27-5" data-line-number="5">relabel (<span class="dt">Node</span> _ l r) ((x<span class="fu">:</span>xs)<span class="fu">:</span>xss0) <span class="fu">=</span></a>
<a class="sourceLine" id="cb27-6" data-line-number="6">  <span class="kw">let</span> (l&#39;,xss1) <span class="fu">=</span> relabel l xss0</a>
<a class="sourceLine" id="cb27-7" data-line-number="7">      (r&#39;,xss2) <span class="fu">=</span> relabel r xss1</a>
<a class="sourceLine" id="cb27-8" data-line-number="8">  <span class="kw">in</span> (<span class="dt">Node</span> x l&#39; r&#39;,xs<span class="fu">:</span>xss2)</a>
<a class="sourceLine" id="cb27-9" data-line-number="9">  </a>
<a class="sourceLine" id="cb27-10" data-line-number="10"><span class="ot">bflabel ::</span> <span class="dt">Tree</span> x <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb27-11" data-line-number="11">bflabel tr xs <span class="fu">=</span> u</a>
<a class="sourceLine" id="cb27-12" data-line-number="12">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb27-13" data-line-number="13">    (u,xss) <span class="fu">=</span> relabel tr (xs<span class="fu">:</span>xss)</a></code></pre></div>
<p>As lovely as it is, spare a thought for the poor totality checker: it’s hard to imagine how it would even <em>start</em> to show that something so lazy and circular would terminate. <code class="sourceCode haskell"><span class="dt">IterT</span></code> won’t help us here, either: it can help us express programs that <em>might</em> diverge, not weird-looking ones that definitely won’t.</p>
<p>The solution presented is a type (<code class="sourceCode haskell"><span class="dt">De</span></code>) which has a limited set of combinators: a fixpoint (<code class="sourceCode haskell"><span class="ot">fix ::</span> (<span class="dt">De</span> x <span class="ot">-&gt;</span> x) <span class="ot">-&gt;</span> x</code>), and an applicative instance. As long as all problematic recursive calls are instead expressed using those combinators, the termination checker should be satisfied.</p>
<p><code class="sourceCode haskell"><span class="dt">De</span></code> can be thought of as a “delay” wrapper. Values of type <code class="sourceCode haskell"><span class="dt">De</span> a</code> are one step in the future, <code class="sourceCode haskell"><span class="dt">De</span> (<span class="dt">De</span> a)</code> are two, and so on. This idea was later expanded upon in <span class="citation" data-cites="atkey_how_2011">Atkey (<a href="#ref-atkey_how_2011">2011</a>)</span> and <span class="citation" data-cites="atkey_productive_2013">Atkey and McBride (<a href="#ref-atkey_productive_2013">2013</a>)</span> to <em>clock variables</em>. Instead of types with a delay, types are tagged with how much more time they have (something like “fuel” in the Idris sense, maybe). So a value of type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>a</mi><mstyle mathvariant="sans-serif"><mi>𝖪</mi></mstyle></msup><annotation encoding="application/x-tex">a^\mathsf{K}</annotation></semantics></math> is tagged with time <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="sans-serif"><mi>𝖪</mi></mstyle><annotation encoding="application/x-tex">\mathsf{K}</annotation></semantics></math>, effectively meaning “I have <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="sans-serif"><mi>𝖪</mi></mstyle><annotation encoding="application/x-tex">\mathsf{K}</annotation></semantics></math> productive steps left before I diverge”. “Productive steps” will mean something different for every data type: for lists, it could mean that it can produce up until the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="sans-serif"><mi>𝖪</mi></mstyle><annotation encoding="application/x-tex">\mathsf{K}</annotation></semantics></math>th cons-cell. In the paper <span class="citation" data-cites="atkey_productive_2013">(Atkey and McBride <a href="#ref-atkey_productive_2013">2013</a>)</span> this is fleshed out a little more, with fixpoint combinators and so on. As a concrete example, take the type of the cons operator on streams:</p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">Cons</mtext><mo>:</mo><mtext mathvariant="normal">a</mtext><mo>→</mo><msup><mtext mathvariant="normal">Stream a</mtext><mstyle mathvariant="sans-serif"><mi>𝖪</mi></mstyle></msup><mo>→</mo><msup><mtext mathvariant="normal">Stream a</mtext><mrow><mstyle mathvariant="sans-serif"><mi>𝖪</mi></mstyle><mo>+</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">\begin{equation}
\text{Cons} : \text{a}
\rightarrow \text{Stream a}^\mathsf{K}
\rightarrow \text{Stream a}^{\mathsf{K}+1}
\end{equation}</annotation></semantics></math>
<p>It increments the clock on the type, saying that it has one more productive step than it did before. This is kind of the opposite of a “delay”: previously, the scheduling types have meant “this is available <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="sans-serif"><mi>𝖪</mi></mstyle><annotation encoding="application/x-tex">\mathsf{K}</annotation></semantics></math> number of steps in the future” rather than “this is available for another <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="sans-serif"><mi>𝖪</mi></mstyle><annotation encoding="application/x-tex">\mathsf{K}</annotation></semantics></math> steps”. We can still describe delays in this system, though, using the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mo>⊳</mo><mstyle mathvariant="sans-serif"><mi>𝖪</mi></mstyle></msup><annotation encoding="application/x-tex">\rhd^\mathsf{K}</annotation></semantics></math> notation:</p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">Cons</mtext><mo>:</mo><mtext mathvariant="normal">a</mtext><mo>→</mo><mover><mo>⊳</mo><mstyle mathvariant="sans-serif"><mi>𝖪</mi></mstyle></mover><mtext mathvariant="normal">Stream a</mtext><mo>→</mo><mtext mathvariant="normal">Stream a</mtext></mrow><annotation encoding="application/x-tex">\begin{equation}
\text{Cons} : \text{a}
\rightarrow \rhd^\mathsf{K}\text{Stream a}
\rightarrow \text{Stream a}
\end{equation}</annotation></semantics></math>
<p>Let’s first try express some of this in the free monad:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1"><span class="kw">data</span> <span class="dt">K</span> <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">|</span> <span class="dt">S</span> <span class="dt">K</span></a>
<a class="sourceLine" id="cb28-2" data-line-number="2"></a>
<a class="sourceLine" id="cb28-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Delay</span><span class="ot"> ::</span> <span class="dt">K</span> <span class="ot">-&gt;</span> (<span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> (<span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb28-4" data-line-number="4">  <span class="dt">Now</span><span class="ot">   ::</span> a <span class="ot">-&gt;</span> <span class="dt">Delay</span> n f m a</a>
<a class="sourceLine" id="cb28-5" data-line-number="5">  <span class="dt">Later</span><span class="ot"> ::</span> f (<span class="dt">DelayT</span> n f m a) <span class="ot">-&gt;</span> <span class="dt">Delay</span> (<span class="dt">S</span> n) f m a</a>
<a class="sourceLine" id="cb28-6" data-line-number="6"></a>
<a class="sourceLine" id="cb28-7" data-line-number="7"><span class="kw">instance</span> (<span class="dt">Functor</span> f, <span class="dt">Functor</span> m) <span class="ot">=&gt;</span> <span class="dt">Functor</span> (<span class="dt">Delay</span> n f m) <span class="kw">where</span></a>
<a class="sourceLine" id="cb28-8" data-line-number="8">  fmap f (<span class="dt">Now</span> x) <span class="fu">=</span> <span class="dt">Now</span> (f x)</a>
<a class="sourceLine" id="cb28-9" data-line-number="9">  fmap f (<span class="dt">Later</span> xs) <span class="fu">=</span> <span class="dt">Later</span> (fmap (fmap f) xs)</a>
<a class="sourceLine" id="cb28-10" data-line-number="10"></a>
<a class="sourceLine" id="cb28-11" data-line-number="11"><span class="kw">newtype</span> <span class="dt">DelayT</span> n f m a <span class="fu">=</span> <span class="dt">DelayT</span> {<span class="ot"> runDelayT ::</span> m (<span class="dt">Delay</span> n f m a) }</a>
<a class="sourceLine" id="cb28-12" data-line-number="12"></a>
<a class="sourceLine" id="cb28-13" data-line-number="13"><span class="kw">instance</span> (<span class="dt">Functor</span> f, <span class="dt">Functor</span> m) <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb28-14" data-line-number="14">         <span class="dt">Functor</span> (<span class="dt">DelayT</span> n f m) <span class="kw">where</span></a>
<a class="sourceLine" id="cb28-15" data-line-number="15">    fmap f <span class="fu">=</span> <span class="dt">DelayT</span> <span class="fu">.</span> fmap (fmap f) <span class="fu">.</span> runDelayT</a></code></pre></div>
<p>We can straight away express one of the combinators from the paper, <code class="sourceCode haskell">force</code>:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" data-line-number="1"><span class="ot">force ::</span> <span class="dt">Functor</span> m <span class="ot">=&gt;</span> (<span class="ot">∀</span> k<span class="fu">.</span> <span class="dt">DelayT</span> k f m a) <span class="ot">-&gt;</span> m a</a>
<a class="sourceLine" id="cb29-2" data-line-number="2">force (<span class="dt">DelayT</span> xs) <span class="fu">=</span> fmap f xs</a>
<a class="sourceLine" id="cb29-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb29-4" data-line-number="4"><span class="ot">    f ::</span> <span class="dt">Delay</span> <span class="dt">Z</span> f m a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb29-5" data-line-number="5">    f (<span class="dt">Now</span> x) <span class="fu">=</span> x</a></code></pre></div>
<p>Similar trick to <a href="http://hackage.haskell.org/package/base-4.11.1.0/docs/Control-Monad-ST.html#v:runST"><code class="sourceCode haskell">runST</code></a> here: if the type is delayed however long we want it to be, then it mustn’t really be delayed at all.</p>
<p>Next, remember that we have types for streams (generators) from the <code class="sourceCode haskell"><span class="dt">IterT</span></code> monad:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Stream</span> n a <span class="fu">=</span> <span class="dt">DelayT</span> n ((,) a)</a></code></pre></div>
<p>And cons does indeed have the right type:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" data-line-number="1"><span class="ot">cons ::</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Stream</span> n a m b <span class="ot">-&gt;</span> <span class="dt">Stream</span> (<span class="dt">S</span> n) a m b</a>
<a class="sourceLine" id="cb31-2" data-line-number="2">cons x xs <span class="fu">=</span> <span class="dt">DelayT</span> (pure (<span class="dt">Later</span> (x,xs)))</a></code></pre></div>
<p>We also get an applicative:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" data-line-number="1"><span class="kw">instance</span> (<span class="dt">Applicative</span> f, <span class="dt">Applicative</span> m) <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb32-2" data-line-number="2">         <span class="dt">Applicative</span> (<span class="dt">DelayT</span> n f m) <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-3" data-line-number="3">    pure <span class="fu">=</span> <span class="dt">DelayT</span> <span class="fu">.</span> pure <span class="fu">.</span> <span class="dt">Now</span></a>
<a class="sourceLine" id="cb32-4" data-line-number="4">    <span class="dt">DelayT</span> fs&#39; <span class="fu">&lt;*&gt;</span> <span class="dt">DelayT</span> xs&#39; <span class="fu">=</span> <span class="dt">DelayT</span> (liftA2 go fs&#39; xs&#39;)</a>
<a class="sourceLine" id="cb32-5" data-line-number="5">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-6" data-line-number="6"><span class="ot">        go ::</span> <span class="ot">∀</span> k a b<span class="fu">.</span> <span class="dt">Delay</span> k f m (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Delay</span> k f m a <span class="ot">-&gt;</span> <span class="dt">Delay</span> k f m b</a>
<a class="sourceLine" id="cb32-7" data-line-number="7">        go (<span class="dt">Now</span> f) <span class="fu">=</span> fmap f</a>
<a class="sourceLine" id="cb32-8" data-line-number="8">        go (<span class="dt">Later</span> fs) <span class="fu">=</span> <span class="dt">Later</span> <span class="fu">.</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb32-9" data-line-number="9">            <span class="dt">Now</span> x <span class="ot">-&gt;</span> fmap (fmap (<span class="fu">$</span>x)) fs</a>
<a class="sourceLine" id="cb32-10" data-line-number="10">            <span class="dt">Later</span> xs <span class="ot">-&gt;</span> liftA2 (<span class="fu">&lt;*&gt;</span>) fs xs</a></code></pre></div>
<p>Now, I’m not sure how much this stuff actually corresponds to the paper, but what caught my eye is the statement that <code class="sourceCode haskell"><span class="dt">De</span></code> is a classic “applicative-not-monad”: just like <code class="sourceCode haskell"><span class="dt">ZipList</span></code>. However, under the analogy that the free monad is listy, and the parallel construction is ziplist-y, what we have in the <code class="sourceCode haskell"><span class="dt">DelayT</span></code> is the equivalent of a length-indexed list. These have an applicative instance similar to ziplists: but they also have a monad. Can we apply the same trick here?</p>
<h1 id="future-posts">Future Posts</h1>
<p>There’s a lot of fascinating stuff out there—about clock variables, especially—that I hope to get a chance to learn about once I get a chance. What I’m particularly interested to follow up on includes:</p>
<ol>
<li>Comonads and their relationship to these constructions. Streams are naturally expressed as comonads, could they be used as a basis on which to build a similar “delay” mechanism?</li>
<li>I’d love to explore more efficient implementations like the ones in <span class="citation" data-cites="spivey_faster_2017">Spivey (<a href="#ref-spivey_faster_2017">2017</a>)</span>.</li>
<li>I’m interested to see the relationship between these types, power series, and algebras for combinatorial search <span class="citation" data-cites="spivey_algebras_2009">(Spivey <a href="#ref-spivey_algebras_2009">2009</a>)</span>.</li>
</ol>
<h1 id="references" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-atkey_how_2011">
<p>Atkey, Robert. 2011. “How to be a Productive Programmer - by putting things off until tomorrow.” Heriot-Watt University.</p>
</div>
<div id="ref-atkey_productive_2013">
<p>Atkey, Robert, and Conor McBride. 2013. “Productive coprogramming with guarded recursion.” In, 197. ACM Press. doi:<a href="https://doi.org/10.1145/2500365.2500597">10.1145/2500365.2500597</a>.</p>
</div>
<div id="ref-blazevic_coroutine_2011">
<p>Blažević, Mario. 2011. “Coroutine Pipelines.” <em>The Monad.Reader</em> 19 (19) (August): 29–50.</p>
</div>
<div id="ref-capretta_partiality_2004">
<p>Capretta, Venanzio, Thorsten Altenkirch, and Tarmo Uustalu. 2004. “Partiality is an effect.” In <em>Dependently Typed Programming</em>, 04381:20. Dagstuhl Seminar Proceedings. Dagstuhl, Germany: Internationales Begegnungs- und Forschungszentrum für Informatik (IBFI), Schloss Dagstuhl, Germany.</p>
</div>
<div id="ref-gonzalez_pipes_2018">
<p>Gonzalez, Gabriel. 2018. “Pipes: Compositional pipelines.”</p>
</div>
<div id="ref-kiselyov_iteratees_2012">
<p>Kiselyov, Oleg. 2012. “Iteratees.” In <em>Proceedings of the 11th International Conference on Functional and Logic Programming</em>, 166–181. Lecture Notes in Computer Science. Berlin, Heidelberg: Springer, Berlin, Heidelberg. doi:<a href="https://doi.org/10.1007/978-3-642-29822-6_15">10.1007/978-3-642-29822-6_15</a>.</p>
</div>
<div id="ref-mcbride_time_2009">
<p>McBride, Conor. 2009. “Time flies like an applicative functor.” <em>Epilogue for Epigram</em>.</p>
</div>
<div id="ref-spivey_algebras_2009">
<p>Spivey, J. Michael. 2009. “Algebras for combinatorial search.” <em>Journal of Functional Programming</em> 19 (3-4) (July): 469–487. doi:<a href="https://doi.org/10.1017/S0956796809007321">10.1017/S0956796809007321</a>.</p>
</div>
<div id="ref-spivey_faster_2017">
<p>Spivey, Michael. 2017. “Faster coroutine pipelines.” <em>Proceedings of the ACM on Programming Languages</em> 1 (ICFP) (August): 1–23. doi:<a href="https://doi.org/10.1145/3110249">10.1145/3110249</a>.</p>
</div>
</div>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>There is a later, seemingly more formal version of the talk available <span class="citation" data-cites="capretta_partiality_2005">(<span class="citeproc-not-found" data-reference-id="capretta_partiality_2005"><strong>???</strong></span>)</span>, but the one from 2004 was a little easier for me to understand, and had a lot more Haskell code.<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>Small note: <code>(,) a</code> and <code>(-&gt;) a</code> are adjunct. I wonder if there is any implication from this? Certainly, producers and consumers seem adjunct, but there’s no instance I can find for it in adjunctions.<a href="#fnref2" class="footnote-back">↩</a></p></li>
</ol>
</section>
]]></description>
    <pubDate>Sat, 23 Jun 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-06-23-scheduling-effects.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Breadth-First Traversals in Far Too Much Detail</title>
    <link>https://doisinkidney.com/posts/2018-06-03-breadth-first-traversals-in-too-much-detail.html</link>
    <description><![CDATA[<div class="info">
    Posted on June  3, 2018
</div>
<div class="info">
    
        Part 3 of a <a href="/series/Breadth-First%20Traversals.html">7-part series on Breadth-First Traversals</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<p>After looking at the algorithms I <a href="2018-06-01-rose-trees-breadth-first-traversing.html">posted last time</a>, I noticed some patterns emerging which I thought deserved a slightly longer post. I’ll go through the problem <span class="citation" data-cites="gibbons_breadth-first_2015">(Gibbons <a href="#ref-gibbons_breadth-first_2015">2015</a>)</span> in a little more detail, and present some more algorithms to go along with it.</p>
<h1 id="the-problem">The Problem</h1>
<p>The original question was posed by <a href="https://www.facebook.com/groups/programming.haskell/permalink/985981691412832/">Etian Chatav</a>:</p>
<blockquote>
<p>What is the correct way to write breadth first traversal of a <code class="sourceCode haskell">[<span class="dt">Tree</span>]</code>?</p>
</blockquote>
<p>The breadth-first traversal here is a traversal in the lensy sense, i.e:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">breadthFirst ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> [<span class="dt">Tree</span> a] <span class="ot">-&gt;</span> f [<span class="dt">Tree</span> b]</a></code></pre></div>
<p>The <code class="sourceCode haskell"><span class="dt">Tree</span></code> type we’re referring to here is a rose tree; we can take the one defined in <a href="http://hackage.haskell.org/package/containers-0.5.11.0/docs/Data-Tree.html#t:Tree"><code class="sourceCode haskell"><span class="dt">Data.Tree</span></code></a>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Node</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">    {<span class="ot"> rootLabel ::</span> a</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">    ,<span class="ot"> subForest ::</span> [<span class="dt">Tree</span> a]</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">    }</a></code></pre></div>
<p>Finally, instead of solving the (somewhat intermediate) problem of traversing a forest, we’ll look directly at traversing the tree itself. In other words, our solution should have the type:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">breadthFirst ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> f (<span class="dt">Tree</span> b)</a></code></pre></div>
<h1 id="breadth-first-enumeration">Breadth-First Enumeration</h1>
<p>As in <span class="citation" data-cites="gibbons_breadth-first_2015">Gibbons (<a href="#ref-gibbons_breadth-first_2015">2015</a>)</span>, let’s first look at just converting the tree to a list in breadth-first order. In other words, given the tree:</p>
<pre><code>   ┌3
 ┌2┤
 │ └4
1┤
 │ ┌6
 └5┤
   └7</code></pre>
<p>We want the list:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1">[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">5</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">6</span>,<span class="dv">7</span>]</a></code></pre></div>
<p>Last time I looked at this problem, the function I arrived at was as follows:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">breadthFirstEnumerate ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">breadthFirstEnumerate ts <span class="fu">=</span> f ts b []</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">    f (<span class="dt">Node</span> x xs) fw bw <span class="fu">=</span> x <span class="fu">:</span> fw (xs <span class="fu">:</span> bw)</a>
<a class="sourceLine" id="cb6-5" data-line-number="5"></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">    b [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">    b qs <span class="fu">=</span> foldl (foldr f) b qs []</a></code></pre></div>
<p>It’s admittedly a little difficult to understand, but it’s really not too complex: we’re popping items off the front of a queue, and pushing the subforest onto the end. <code class="sourceCode haskell">fw</code> is the recursive call here: that’s where we send the queue with the element pushed on. Even though it may <em>look</em> like we’re pushing onto the front (as we’re using a cons), this is really the <em>end</em> of the queue, since it’s being consumed in reverse, with <code class="sourceCode haskell">foldl</code>.</p>
<p>We can compare it to the technique used in <span class="citation" data-cites="allison_circular_2006">Allison (<a href="#ref-allison_circular_2006">2006</a>)</span> and <span class="citation" data-cites="smith_lloyd_2009">Smith (<a href="#ref-smith_lloyd_2009">2009</a>)</span>, where it’s called <em>corecursive queues</em>. Breadth-first enumeration is accomplished as follows in <span class="citation" data-cites="smith_lloyd_2009">Smith (<a href="#ref-smith_lloyd_2009">2009</a>)</span>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">levelOrder ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">levelOrder tr <span class="fu">=</span> map rootLabel qs</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">    qs <span class="fu">=</span> enqs [tr] <span class="dv">0</span> qs</a>
<a class="sourceLine" id="cb7-5" data-line-number="5"></a>
<a class="sourceLine" id="cb7-6" data-line-number="6">    enqs []     n xs <span class="fu">=</span> deq n xs</a>
<a class="sourceLine" id="cb7-7" data-line-number="7">    enqs (t<span class="fu">:</span>ts) n xs <span class="fu">=</span> t <span class="fu">:</span> enqs  ts (n<span class="fu">+</span><span class="dv">1</span>) xs</a>
<a class="sourceLine" id="cb7-8" data-line-number="8"></a>
<a class="sourceLine" id="cb7-9" data-line-number="9">    deq <span class="dv">0</span> _      <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb7-10" data-line-number="10">    deq n (x<span class="fu">:</span>xs) <span class="fu">=</span> enqs (subForest x) (n<span class="fu">-</span><span class="dv">1</span>) xs</a></code></pre></div>
<p>We get to avoid tracking the length of the queue, however.</p>
<h1 id="level-order-enumeration">Level-Order Enumeration</h1>
<p>Before we go the full way to traversal, we can try add a little structure to our breadth-first enumeration, by delimiting between levels in the tree. We want our function to have the following type:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">levels ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [[a]]</a></code></pre></div>
<p>Looking back at our example tree:</p>
<pre><code>   ┌3
 ┌2┤
 │ └4
1┤
 │ ┌6
 └5┤
   └7</code></pre>
<p>We now want the list:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">[[<span class="dv">1</span>],[<span class="dv">2</span>,<span class="dv">5</span>],[<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">6</span>,<span class="dv">7</span>]]</a></code></pre></div>
<p>This function is strictly more powerful than <code class="sourceCode haskell">breadthFirstEnumerate</code>, as we can define one in terms of the other:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1">breadthFirstEnumerate <span class="fu">=</span> concat <span class="fu">.</span> levels</a></code></pre></div>
<p>It’s also just a generally useful function, so there are several example implementations available online.</p>
<h3 id="iterative-style">Iterative-Style</h3>
<p>The one provided in <a href="http://hackage.haskell.org/package/containers-0.5.11.0/docs/src/Data.Tree.html#levels">Data.Tree</a> is as follows:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1">levels t <span class="fu">=</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">    map (map rootLabel) <span class="fu">$</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">        takeWhile (not <span class="fu">.</span> null) <span class="fu">$</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">        iterate (concatMap subForest) [t]</a></code></pre></div>
<p>Pretty nice, but it looks to me like it’s doing a lot of redundant work. We could write it as an unfold:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1">levels t <span class="fu">=</span>  unfoldr (f <span class="fu">.</span> concat) [[t]]</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">    f [] <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4">    f xs <span class="fu">=</span> <span class="dt">Just</span> (unzip [(y,ys) <span class="fu">|</span> <span class="dt">Node</span> y ys <span class="ot">&lt;-</span> xs])</a></code></pre></div>
<p>The performance danger here lies in <code class="sourceCode haskell">unzip</code>: one could potentially optimize that for a speedup.</p>
<h3 id="with-an-implicit-queue">With an (implicit) Queue</h3>
<p>Another definition, in the style of <code class="sourceCode haskell">breadthFirstEnumerate</code> above, is as follows:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1">levels ts <span class="fu">=</span> f b ts [] []</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3">    f k (<span class="dt">Node</span> x xs) ls qs <span class="fu">=</span> k (x <span class="fu">:</span> ls) (xs <span class="fu">:</span> qs)</a>
<a class="sourceLine" id="cb14-4" data-line-number="4"></a>
<a class="sourceLine" id="cb14-5" data-line-number="5">    b _ [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb14-6" data-line-number="6">    b k qs <span class="fu">=</span> k <span class="fu">:</span> foldl (foldl f) b qs [] []</a></code></pre></div>
<p>Here, we maintain a stack building up the current level, as well as a queue that we send to the next level. Because we’re consing onto the front of the stack, the subforest needs to be traversed in reverse, to build up the output list in the right order. This is why we’re using a second <code class="sourceCode haskell">foldl</code> here, whereas the original had <code class="sourceCode haskell">foldr</code> on the inner loop.</p>
<h3 id="zippy-style">Zippy-Style</h3>
<p>Looking at the implicit queue version, I noticed that it’s just using a church-encoded pair to reverse the direction of the fold. Instead of doing both reversals, we can use a normal pair, and run it in one direction:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1">levels ts <span class="fu">=</span> b (f ts ([],[]))</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-3" data-line-number="3">    f (<span class="dt">Node</span> x xs) (ls,qs) <span class="fu">=</span> (x<span class="fu">:</span>ls,xs<span class="fu">:</span>qs)</a>
<a class="sourceLine" id="cb15-4" data-line-number="4"></a>
<a class="sourceLine" id="cb15-5" data-line-number="5">    b (_,[]) <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb15-6" data-line-number="6">    b (k,qs) <span class="fu">=</span> k <span class="fu">:</span> b (foldr (flip (foldr f)) ([],[]) qs)</a></code></pre></div>
<p>Secondly, we’re running a fold on the second component of the pair: why not run the fold immediately, rather than building the intermediate list. In fact, we’re running a fold over the <em>whole</em> thing, which we can do straight away:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1">levels ts <span class="fu">=</span> f ts []</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3">    f (<span class="dt">Node</span> x xs) (q<span class="fu">:</span>qs) <span class="fu">=</span> (x<span class="fu">:</span>q) <span class="fu">:</span> foldr f qs xs</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">    f (<span class="dt">Node</span> x xs) []     <span class="fu">=</span> [x]   <span class="fu">:</span> foldr f [] xs</a></code></pre></div>
<p>After looking at it for a while, I realized it’s similar to an inlined version of the algorithm presented in <span class="citation" data-cites="gibbons_breadth-first_2015">Gibbons (<a href="#ref-gibbons_breadth-first_2015">2015</a>)</span>:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1">levels t <span class="fu">=</span> [rootLabel t] <span class="fu">:</span> foldr (lzw (<span class="fu">++</span>)) [] (map levels (subForest t))</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb17-3" data-line-number="3">    lzw f (x<span class="fu">:</span>xs) (y<span class="fu">:</span>ys) <span class="fu">=</span> f x y <span class="fu">:</span> lzw f xs ys</a>
<a class="sourceLine" id="cb17-4" data-line-number="4">    lzw _ xs [] <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb17-5" data-line-number="5">    lzw _ [] ys <span class="fu">=</span> ys</a></code></pre></div>
<h1 id="cofree">Cofree</h1>
<p>Before going any further, all of the functions so far can be redefined to work on the <a href="http://hackage.haskell.org/package/free-5.0.2/docs/Control-Comonad-Cofree.html">cofree comonad</a>:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Cofree</span> f a <span class="fu">=</span> a <span class="fu">:&lt;</span> f (<span class="dt">Cofree</span> f a)</a></code></pre></div>
<p>When <code class="sourceCode haskell">f</code> is specialized to <code class="sourceCode haskell">[]</code>, we get the original rose tree. So far, though, all we actually require is <code class="sourceCode haskell"><span class="dt">Foldable</span></code>.</p>
<p>From now on, then, we’ll use <code class="sourceCode haskell"><span class="dt">Cofree</span></code> instead of <code class="sourceCode haskell"><span class="dt">Tree</span></code>.</p>
<h1 id="traversing">Traversing</h1>
<p>Finally, we can begin on the traversal itself. We know how to execute the effects in the right order, what’s missing is to build the tree back up in the right order.</p>
<h3 id="filling">Filling</h3>
<p>First thing we’ll use is a trick with <code class="sourceCode haskell"><span class="dt">Traversable</span></code>, where we fill a container from a list. In other words:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1">fill [(),(),(),()] [<span class="dv">1</span><span class="fu">..</span>] <span class="fu">=</span> ([<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>],[<span class="dv">5</span><span class="fu">..</span>])</a></code></pre></div>
<p>With the state monad (or applicative, in this case, I suppose), we can define a “pop” action, which takes an element from the supply:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1">pop <span class="fu">=</span> state (\(x<span class="fu">:</span>xs) <span class="ot">-&gt;</span> (x,xs))</a></code></pre></div>
<p>And then we <code class="sourceCode haskell">traverse</code> that action over our container:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1">fill <span class="fu">=</span> traverse (const pop)</a></code></pre></div>
<p>When we use fill, it’ll have the following type:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="ot">breadthFirst ::</span> (<span class="dt">Applicative</span> f, <span class="dt">Traversable</span> t)</a>
<a class="sourceLine" id="cb22-2" data-line-number="2">             <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> <span class="dt">Cofree</span> t a <span class="ot">-&gt;</span> f (<span class="dt">Cofree</span> t b)</a>
<a class="sourceLine" id="cb22-3" data-line-number="3">breadthFirst <span class="fu">=</span> <span class="fu">...</span></a>
<a class="sourceLine" id="cb22-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-5" data-line-number="5">    <span class="fu">...</span></a>
<a class="sourceLine" id="cb22-6" data-line-number="6"><span class="ot">    fill ::</span> t (<span class="dt">Cofree</span> t a) <span class="ot">-&gt;</span> <span class="dt">State</span> [<span class="dt">Cofree</span> t b] (t (<span class="dt">Cofree</span> t b))</a>
<a class="sourceLine" id="cb22-7" data-line-number="7">    fill <span class="fu">=</span> traverse (const pop)</a></code></pre></div>
<p>Hopefully that makes sense: we’re going to get the subforest from here:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Cofree</span> t a <span class="fu">=</span> a <span class="fu">:&lt;</span> t (<span class="dt">Cofree</span> t a)</a>
<a class="sourceLine" id="cb23-2" data-line-number="2">                       <span class="fu">^^^^^^^^^^^^^^</span></a></code></pre></div>
<p>And we’re going to fill it with the result of the traversal, which changes the contents from <code>a</code>s to <code>b</code>s.</p>
<h3 id="composing-applicatives">Composing Applicatives</h3>
<p>One of the nice things about working with applicatives is that they compose, in a variety of different ways. In other words, if I have one effect, <code class="sourceCode haskell">f</code>, and another <code class="sourceCode haskell">g</code>, and I want to run them both on the contents of some list, I can do it in one pass, either by layering the effects, or putting them side-by-side.</p>
<p>In our case, we need to deal with two effects: the one generated by the traversal, (the one the caller wants to use), and the internal state we’re using to fill up the forests in our tree. We could use <a href="http://hackage.haskell.org/package/base-4.11.1.0/docs/Data-Functor-Compose.html#t:Compose"><code class="sourceCode haskell"><span class="dt">Compose</span></code></a> explicitly, but we can avoid some calls to <code class="sourceCode haskell">pure</code> if we write the combinators we’re going to use directly:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1">map2</a>
<a class="sourceLine" id="cb24-2" data-line-number="2"><span class="ot">    ::</span> (<span class="dt">Functor</span> f, <span class="dt">Functor</span> g)</a>
<a class="sourceLine" id="cb24-3" data-line-number="3">    <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> g b <span class="ot">-&gt;</span> f (g c)</a>
<a class="sourceLine" id="cb24-4" data-line-number="4">map2 f x xs <span class="fu">=</span></a>
<a class="sourceLine" id="cb24-5" data-line-number="5">    fmap (\y <span class="ot">-&gt;</span> fmap (f y) xs) x</a>
<a class="sourceLine" id="cb24-6" data-line-number="6"></a>
<a class="sourceLine" id="cb24-7" data-line-number="7">app2</a>
<a class="sourceLine" id="cb24-8" data-line-number="8"><span class="ot">    ::</span> (<span class="dt">Applicative</span> f, <span class="dt">Applicative</span> g)</a>
<a class="sourceLine" id="cb24-9" data-line-number="9">    <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> g b <span class="ot">-&gt;</span> f (g c) <span class="ot">-&gt;</span> f (g d)</a>
<a class="sourceLine" id="cb24-10" data-line-number="10">app2 f x xs <span class="fu">=</span></a>
<a class="sourceLine" id="cb24-11" data-line-number="11">    liftA2 (\y <span class="ot">-&gt;</span> liftA2 (f y) xs) x</a></code></pre></div>
<p>The outer applicative (<code>f</code>) will be the user’s effect, the inner will be <code>State</code>.</p>
<h1 id="take-1-zippy-style-traversing">Take 1: Zippy-Style Traversing</h1>
<p>First we’ll try convert the zippy-style <code class="sourceCode haskell">levels</code> to a traversal. First, convert the function over to the cofree comonad:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1">levels tr <span class="fu">=</span> f tr []</a>
<a class="sourceLine" id="cb25-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-3" data-line-number="3">    f (x<span class="fu">:&lt;</span>xs) (q<span class="fu">:</span>qs) <span class="fu">=</span> (x<span class="fu">:</span>q) <span class="fu">:</span> foldr f qs xs</a>
<a class="sourceLine" id="cb25-4" data-line-number="4">    f (x<span class="fu">:&lt;</span>xs) []     <span class="fu">=</span> [x]   <span class="fu">:</span> foldr f [] xs</a></code></pre></div>
<p>Next, instead of building up a list of just the root labels, we’ll pair them with the subforests:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1">breadthFirst tr <span class="fu">=</span> f tr []</a>
<a class="sourceLine" id="cb26-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb26-3" data-line-number="3">    f (x<span class="fu">:&lt;</span>xs) (q<span class="fu">:</span>qs) <span class="fu">=</span> ((x,xs)<span class="fu">:</span>q) <span class="fu">:</span> foldr f qs xs</a>
<a class="sourceLine" id="cb26-4" data-line-number="4">    f (x<span class="fu">:&lt;</span>xs) []     <span class="fu">=</span> [(x,xs)]   <span class="fu">:</span> foldr f [] xs</a></code></pre></div>
<p>Next, we’ll fill the subforests:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1">breadthFirst tr <span class="fu">=</span> f tr []</a>
<a class="sourceLine" id="cb27-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb27-3" data-line-number="3">    f (x<span class="fu">:&lt;</span>xs) (q<span class="fu">:</span>qs) <span class="fu">=</span> ((x,fill xs)<span class="fu">:</span>q) <span class="fu">:</span> foldr f qs xs</a>
<a class="sourceLine" id="cb27-4" data-line-number="4">    f (x<span class="fu">:&lt;</span>xs) []     <span class="fu">=</span> [(x,fill xs)]   <span class="fu">:</span> foldr f [] xs</a></code></pre></div>
<p>Then, we can run the applicative effect on the root label:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1">breadthFirst c tr <span class="fu">=</span> f tr []</a>
<a class="sourceLine" id="cb28-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb28-3" data-line-number="3">    f (x<span class="fu">:&lt;</span>xs) (q<span class="fu">:</span>qs) <span class="fu">=</span> ((c x,fill xs)<span class="fu">:</span>q) <span class="fu">:</span> foldr f qs xs</a>
<a class="sourceLine" id="cb28-4" data-line-number="4">    f (x<span class="fu">:&lt;</span>xs) []     <span class="fu">=</span> [(c x,fill xs)]   <span class="fu">:</span> foldr f [] xs</a></code></pre></div>
<p>Now, to combine the effects, we can use the combinators we defined before:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" data-line-number="1">breadthFirst c tr <span class="fu">=</span> f tr []</a>
<a class="sourceLine" id="cb29-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb29-3" data-line-number="3">    f (x<span class="fu">:&lt;</span>xs) (q<span class="fu">:</span>qs) <span class="fu">=</span></a>
<a class="sourceLine" id="cb29-4" data-line-number="4">        app2 (\y ys zs <span class="ot">-&gt;</span> (y<span class="fu">:&lt;</span>ys) <span class="fu">:</span> zs) (c x) (fill xs) q <span class="fu">:</span> foldr f qs xs</a>
<a class="sourceLine" id="cb29-5" data-line-number="5">    f (x<span class="fu">:&lt;</span>xs) [] <span class="fu">=</span></a>
<a class="sourceLine" id="cb29-6" data-line-number="6">        map2 (\y ys <span class="ot">-&gt;</span> [y<span class="fu">:&lt;</span>ys]) (c x) (fill xs) <span class="fu">:</span> foldr f [] xs</a></code></pre></div>
<p>This builds a list containing all of the level-wise traversals of the tree. To collapse them into one, we can use a fold:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="ot">breadthFirst ::</span> (<span class="dt">Traversable</span> t, <span class="dt">Applicative</span> f)</a>
<a class="sourceLine" id="cb30-2" data-line-number="2">             <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b)</a>
<a class="sourceLine" id="cb30-3" data-line-number="3">             <span class="ot">-&gt;</span> <span class="dt">Cofree</span> t a</a>
<a class="sourceLine" id="cb30-4" data-line-number="4">             <span class="ot">-&gt;</span> f (<span class="dt">Cofree</span> t b)</a>
<a class="sourceLine" id="cb30-5" data-line-number="5">breadthFirst c tr <span class="fu">=</span></a>
<a class="sourceLine" id="cb30-6" data-line-number="6">    head <span class="fu">&lt;$&gt;</span> foldr (liftA2 evalState) (pure []) (f tr [])</a>
<a class="sourceLine" id="cb30-7" data-line-number="7">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-8" data-line-number="8">    f (x<span class="fu">:&lt;</span>xs) (q<span class="fu">:</span>qs) <span class="fu">=</span></a>
<a class="sourceLine" id="cb30-9" data-line-number="9">        app2 (\y ys zs <span class="ot">-&gt;</span> (y<span class="fu">:&lt;</span>ys)<span class="fu">:</span>zs) (c x) (fill xs) q <span class="fu">:</span> foldr f qs xs</a>
<a class="sourceLine" id="cb30-10" data-line-number="10">    f (x<span class="fu">:&lt;</span>xs) [] <span class="fu">=</span></a>
<a class="sourceLine" id="cb30-11" data-line-number="11">        map2 (\y ys <span class="ot">-&gt;</span> [y<span class="fu">:&lt;</span>ys]) (c x) (fill xs) <span class="fu">:</span> foldr f [] xs</a></code></pre></div>
<h1 id="take-2-queue-based-traversing">Take 2: Queue-Based Traversing</h1>
<p>Converting the queue-based implementation is easy once we’ve done it with the zippy one. The result is (to my eye) a little easier to read, also:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" data-line-number="1">breadthFirst</a>
<a class="sourceLine" id="cb31-2" data-line-number="2"><span class="ot">    ::</span> (<span class="dt">Applicative</span> f, <span class="dt">Traversable</span> t)</a>
<a class="sourceLine" id="cb31-3" data-line-number="3">    <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> <span class="dt">Cofree</span> t a <span class="ot">-&gt;</span> f (<span class="dt">Cofree</span> t b)</a>
<a class="sourceLine" id="cb31-4" data-line-number="4">breadthFirst c tr <span class="fu">=</span></a>
<a class="sourceLine" id="cb31-5" data-line-number="5">    fmap head (f b tr e [])</a>
<a class="sourceLine" id="cb31-6" data-line-number="6">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb31-7" data-line-number="7">    f k (x<span class="fu">:&lt;</span>xs) ls qs <span class="fu">=</span></a>
<a class="sourceLine" id="cb31-8" data-line-number="8">      k (app2 (\y ys zs <span class="ot">-&gt;</span> (y<span class="fu">:&lt;</span>ys)<span class="fu">:</span>zs) (c x) (fill xs) ls) (xs<span class="fu">:</span>qs)</a>
<a class="sourceLine" id="cb31-9" data-line-number="9"></a>
<a class="sourceLine" id="cb31-10" data-line-number="10">    b _ [] <span class="fu">=</span> pure []</a>
<a class="sourceLine" id="cb31-11" data-line-number="11">    b l qs <span class="fu">=</span> liftA2 evalState l (foldl (foldl f) b qs e [])</a>
<a class="sourceLine" id="cb31-12" data-line-number="12"></a>
<a class="sourceLine" id="cb31-13" data-line-number="13">    e <span class="fu">=</span> pure (pure [])</a></code></pre></div>
<p>There are a couple things to notice here: first, we’re not using <code class="sourceCode haskell">map2</code> anywhere. That’s because in the zippy version we were able to notice when the queue was exhausted, so we could just output the singleton effect. Here, instead, we’re using <code class="sourceCode haskell">pure (pure [])</code>: this is potentially a source of inefficiency, as <code class="sourceCode haskell">liftA2 f (pure x) y</code> is less efficient than <code class="sourceCode haskell">fmap (f x) y</code> for some applicatives.</p>
<p>On the other hand, we don’t build up a list of levels to be combined with <code class="sourceCode haskell">foldr (liftA2 evalState)</code> at any point: we combine them at every level immediately. You may be able to do the same in the zippy version, but I haven’t figured it out yet.</p>
<h3 id="yoneda">Yoneda</h3>
<p>The final point to make here is to do with the very last thing we do in the traversal: <code class="sourceCode haskell">fmap head</code>. Strictly speaking, any <code class="sourceCode haskell">fmap</code>s in the code should be unnecessary: we <em>should</em> be able to fuse them all with any call to <code class="sourceCode haskell">liftA2</code>. This transformation is often called the “Yoneda embedding”. We can use it here like so:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" data-line-number="1">breadthFirst</a>
<a class="sourceLine" id="cb32-2" data-line-number="2"><span class="ot">    ::</span> <span class="ot">∀</span> t a f b<span class="fu">.</span> (<span class="dt">Traversable</span> t, <span class="dt">Applicative</span> f)</a>
<a class="sourceLine" id="cb32-3" data-line-number="3">    <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> <span class="dt">Cofree</span> t a <span class="ot">-&gt;</span> f (<span class="dt">Cofree</span> t b)</a>
<a class="sourceLine" id="cb32-4" data-line-number="4">breadthFirst c tr <span class="fu">=</span> f (b head) tr e []</a>
<a class="sourceLine" id="cb32-5" data-line-number="5">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-6" data-line-number="6">    f k (x<span class="fu">:&lt;</span>xs) ls qs <span class="fu">=</span></a>
<a class="sourceLine" id="cb32-7" data-line-number="7">        k (app2 (\y ys zs <span class="ot">-&gt;</span> (y<span class="fu">:&lt;</span>ys) <span class="fu">:</span> zs) (c x) (fill xs) ls) (xs <span class="fu">:</span> qs)</a>
<a class="sourceLine" id="cb32-8" data-line-number="8"></a>
<a class="sourceLine" id="cb32-9" data-line-number="9"><span class="ot">    b ::</span> <span class="ot">∀</span> x<span class="fu">.</span> ([<span class="dt">Cofree</span> t b] <span class="ot">-&gt;</span> x)</a>
<a class="sourceLine" id="cb32-10" data-line-number="10">      <span class="ot">-&gt;</span> f (<span class="dt">State</span> [<span class="dt">Cofree</span> t b] [<span class="dt">Cofree</span> t b])</a>
<a class="sourceLine" id="cb32-11" data-line-number="11">      <span class="ot">-&gt;</span> [t (<span class="dt">Cofree</span> t a)]</a>
<a class="sourceLine" id="cb32-12" data-line-number="12">      <span class="ot">-&gt;</span> f x</a>
<a class="sourceLine" id="cb32-13" data-line-number="13">    b k _ [] <span class="fu">=</span> pure (k [])</a>
<a class="sourceLine" id="cb32-14" data-line-number="14">    b k l qs <span class="fu">=</span></a>
<a class="sourceLine" id="cb32-15" data-line-number="15">        liftA2 (\x <span class="ot">-&gt;</span> k <span class="fu">.</span> evalState x) l (foldl (foldl f) (b id) qs e [])</a>
<a class="sourceLine" id="cb32-16" data-line-number="16"></a>
<a class="sourceLine" id="cb32-17" data-line-number="17">    e <span class="fu">=</span> pure (pure [])</a></code></pre></div>
<p>Notice that we need scoped type variables here, since the type of <code class="sourceCode haskell">b</code> changes depending on when it’s called.</p>
<h1 id="take-3-iterative-traversing">Take 3: Iterative Traversing</h1>
<p>Transforming the iterative version is slightly different from the other two:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" data-line-number="1">breadthFirst c tr <span class="fu">=</span> fmap head (go [tr])</a>
<a class="sourceLine" id="cb33-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb33-3" data-line-number="3">    go [] <span class="fu">=</span> pure []</a>
<a class="sourceLine" id="cb33-4" data-line-number="4">    go xs <span class="fu">=</span></a>
<a class="sourceLine" id="cb33-5" data-line-number="5">        liftA2</a>
<a class="sourceLine" id="cb33-6" data-line-number="6">            evalState</a>
<a class="sourceLine" id="cb33-7" data-line-number="7">            (getCompose (traverse f xs))</a>
<a class="sourceLine" id="cb33-8" data-line-number="8">            (go (foldr (\(_<span class="fu">:&lt;</span>ys) b <span class="ot">-&gt;</span> foldr (<span class="fu">:</span>) b ys) [] xs))</a>
<a class="sourceLine" id="cb33-9" data-line-number="9">    f (x<span class="fu">:&lt;</span>xs) <span class="fu">=</span> <span class="dt">Compose</span> (map2 (<span class="fu">:&lt;</span>) (c x) (fill xs))</a></code></pre></div>
<p>We’re using <code class="sourceCode haskell"><span class="dt">Compose</span></code> directly here, in contrast to the other two algorithms.</p>
<h1 id="comparison">Comparison</h1>
<p>Performance-wise, no one algorithm wins out in every case. For enumeration, the zippy algorithm is the fastest in most cases—except when the tree had a large branching factor; then, the iterative algorithm wins out. For the traversals, the iterative algorithm is usually better—except for monads with more expensive applicative instances.</p>
<p>I’m still not convinced that the zippy traversal is as optimized as it could be, however. If anyone has a better implementation, I’d love to see it!</p>
<h1 id="fusion">Fusion</h1>
<p>Using the composability of applicatives, we can fuse several operations over traversables into one pass. Unfortunately, however, this can often introduce a memory overhead that makes the whole operation slower overall. One such example is the iterative algorithm above:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" data-line-number="1">breadthFirst c tr <span class="fu">=</span> fmap head (go [tr])</a>
<a class="sourceLine" id="cb34-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb34-3" data-line-number="3">    go [] <span class="fu">=</span> pure []</a>
<a class="sourceLine" id="cb34-4" data-line-number="4">    go xs <span class="fu">=</span> liftA2 evalState zs (go (ys []))</a>
<a class="sourceLine" id="cb34-5" data-line-number="5">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb34-6" data-line-number="6">        <span class="dt">Compose</span> (<span class="dt">Endo</span> ys,<span class="dt">Compose</span> zs) <span class="fu">=</span> traverse f xs</a>
<a class="sourceLine" id="cb34-7" data-line-number="7">    f (x <span class="fu">:&lt;</span> xs) <span class="fu">=</span></a>
<a class="sourceLine" id="cb34-8" data-line-number="8">        <span class="dt">Compose</span></a>
<a class="sourceLine" id="cb34-9" data-line-number="9">            (<span class="dt">Endo</span> (flip (foldr (<span class="fu">:</span>)) xs)</a>
<a class="sourceLine" id="cb34-10" data-line-number="10">            ,<span class="dt">Compose</span> (map2 (<span class="fu">:&lt;</span>) (c x) (fill xs)))</a></code></pre></div>
<p>We only traverse the subforest of each node once now, fusing the fill operation with building the list to send to the recursive call. This is expensive (especially memory-wise), though, and traversing the descendant is cheap; the result is that the one-pass version is slower (in my tests).</p>
<h1 id="generalizing">Generalizing</h1>
<p>The cofree comonad allows us to generalize over the type of “descendants”—from lists (in <code class="sourceCode haskell"><span class="dt">Tree</span></code>) to anything traversable. We could also generalize over the type of the traversal itself: given a way to access the descendants of a node, we should be able to traverse all nodes in a breadth-first order. This kind of thing is usually accomplished by <a href="http://hackage.haskell.org/package/lens-4.16.1/docs/Control-Lens-Plated.html">Plated</a>: it’s a class that gives you a traversal over the immediate descendants of some recursive type. Adapting the iterative version is relatively simple:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb35-1" data-line-number="1"><span class="ot">breadthFirstOf ::</span> <span class="dt">Traversal&#39;</span> a a <span class="ot">-&gt;</span> <span class="dt">Traversal&#39;</span> a a</a>
<a class="sourceLine" id="cb35-2" data-line-number="2">breadthFirstOf trav c tr <span class="fu">=</span> fmap head (go [tr])</a>
<a class="sourceLine" id="cb35-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb35-4" data-line-number="4">    go [] <span class="fu">=</span> pure []</a>
<a class="sourceLine" id="cb35-5" data-line-number="5">    go xs <span class="fu">=</span></a>
<a class="sourceLine" id="cb35-6" data-line-number="6">        liftA2</a>
<a class="sourceLine" id="cb35-7" data-line-number="7">            evalState</a>
<a class="sourceLine" id="cb35-8" data-line-number="8">            (getCompose (traverse f xs))</a>
<a class="sourceLine" id="cb35-9" data-line-number="9">            (go (foldr (\ys b <span class="ot">-&gt;</span> foldrOf trav (<span class="fu">:</span>) b ys) [] xs))</a>
<a class="sourceLine" id="cb35-10" data-line-number="10">    f xs <span class="fu">=</span> <span class="dt">Compose</span> (fmap fill (c xs))</a>
<a class="sourceLine" id="cb35-11" data-line-number="11">    fill <span class="fu">=</span> trav (const (<span class="dt">State</span> (\(x<span class="fu">:</span>xs) <span class="ot">-&gt;</span> (x, xs))))</a></code></pre></div>
<p>We can use this version to get back some of the old functions above:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" data-line-number="1"><span class="ot">breadthFirstEnumerate ::</span>  <span class="dt">Traversable</span> f <span class="ot">=&gt;</span> <span class="dt">Cofree</span> f a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb36-2" data-line-number="2">breadthFirstEnumerate <span class="fu">=</span> toListOf (breadthFirstOf plate <span class="fu">.</span> _extract)</a></code></pre></div>
<h1 id="unfolding">Unfolding</h1>
<p>Building a tree breadth-first, monadically, is still an unsolved problem <span class="citation" data-cites="feuer_is_2015">(it looks like: Feuer <a href="#ref-feuer_is_2015">2015</a>)</span>.</p>
<p>Using some of these we can implement a monadic breadth-first unfold for the cofree comonad:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb37-1" data-line-number="1"><span class="ot">unfoldM ::</span> (<span class="dt">Monad</span> m, <span class="dt">Traversable</span> t)</a>
<a class="sourceLine" id="cb37-2" data-line-number="2">        <span class="ot">=&gt;</span> (b <span class="ot">-&gt;</span> m (a, t b))</a>
<a class="sourceLine" id="cb37-3" data-line-number="3">        <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb37-4" data-line-number="4">        <span class="ot">-&gt;</span> m (<span class="dt">Cofree</span> t a)</a>
<a class="sourceLine" id="cb37-5" data-line-number="5">unfoldM c tr <span class="fu">=</span> go head [tr]</a>
<a class="sourceLine" id="cb37-6" data-line-number="6">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb37-7" data-line-number="7">    go k [] <span class="fu">=</span> pure (k [])</a>
<a class="sourceLine" id="cb37-8" data-line-number="8">    go k xs <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb37-9" data-line-number="9">        ys <span class="ot">&lt;-</span> traverse c xs</a>
<a class="sourceLine" id="cb37-10" data-line-number="10">        go (k <span class="fu">.</span> evalState (traverse f ys)) (toList (<span class="dt">Compose</span> (<span class="dt">Compose</span> ys)))</a>
<a class="sourceLine" id="cb37-11" data-line-number="11">    f (x,xs) <span class="fu">=</span> fmap (x<span class="fu">:&lt;</span>) (fill xs)</a></code></pre></div>
<h1 id="references" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-allison_circular_2006">
<p>Allison, Lloyd. 2006. “Circular Programs and Self-Referential Structures.” <em>Software: Practice and Experience</em> 19 (2) (October): 99–109. doi:<a href="https://doi.org/10.1002/spe.4380190202">10.1002/spe.4380190202</a>. <a href="http://users.monash.edu/~lloyd/tildeFP/1989SPE/" class="uri">http://users.monash.edu/~lloyd/tildeFP/1989SPE/</a>.</p>
</div>
<div id="ref-feuer_is_2015">
<p>Feuer, David. 2015. “Is a lazy, breadth-first monadic rose tree unfold possible?” Question. <em>Stack Overflow</em>. <a href="https://stackoverflow.com/q/27748526" class="uri">https://stackoverflow.com/q/27748526</a>.</p>
</div>
<div id="ref-gibbons_breadth-first_2015">
<p>Gibbons, Jeremy. 2015. “Breadth-First Traversal.” <em>Patterns in Functional Programming</em>. <a href="https://patternsinfp.wordpress.com/2015/03/05/breadth-first-traversal/" class="uri">https://patternsinfp.wordpress.com/2015/03/05/breadth-first-traversal/</a>.</p>
</div>
<div id="ref-smith_lloyd_2009">
<p>Smith, Leon P. 2009. “Lloyd Allison’s Corecursive Queues: Why Continuations Matter.” <em>The Monad.Reader</em> 14 (14) (July): 28. <a href="https://meldingmonads.files.wordpress.com/2009/06/corecqueues.pdf" class="uri">https://meldingmonads.files.wordpress.com/2009/06/corecqueues.pdf</a>.</p>
</div>
</div>
]]></description>
    <pubDate>Sun, 03 Jun 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-06-03-breadth-first-traversals-in-too-much-detail.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Breadth-First Rose Trees: Traversals and the Cofree Comonad</title>
    <link>https://doisinkidney.com/posts/2018-06-01-rose-trees-breadth-first-traversing.html</link>
    <description><![CDATA[<div class="info">
    Posted on June  1, 2018
</div>
<div class="info">
    
        Part 2 of a <a href="/series/Breadth-First%20Traversals.html">7-part series on Breadth-First Traversals</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<p>I was looking again at the issue of writing breadth-first traversals for rose trees, and in particular the problem explored in <span class="citation" data-cites="gibbons_breadth-first_2015">Gibbons (<a href="#ref-gibbons_breadth-first_2015">2015</a>)</span>. The breadth-first traversal here is a traversal in the lensy sense.</p>
<p>First, let’s look back at getting the levels out of the tree. Here’s the old function I arrived at last time:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">levels ::</span> <span class="dt">Forest</span> a <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">levels ts <span class="fu">=</span> foldl f b ts [] []</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">    f k (<span class="dt">Node</span> x xs) ls qs <span class="fu">=</span> k (x <span class="fu">:</span> ls) (xs <span class="fu">:</span> qs)</a>
<a class="sourceLine" id="cb1-5" data-line-number="5"></a>
<a class="sourceLine" id="cb1-6" data-line-number="6">    b _ [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb1-7" data-line-number="7">    b k qs <span class="fu">=</span> k <span class="fu">:</span> foldl (foldl f) b qs [] []</a></code></pre></div>
<p>After wrangling the definition a little, I got to the following (much cleaner) definition:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">levels ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">levels tr <span class="fu">=</span> f tr [] <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  f (<span class="dt">Node</span> x xs) (y<span class="fu">:</span>ys) <span class="fu">=</span> (x<span class="fu">:</span>y) <span class="fu">:</span> foldr f ys xs</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">  f (<span class="dt">Node</span> x xs) []     <span class="fu">=</span> [x]   <span class="fu">:</span> foldr f [] xs</a></code></pre></div>
<h1 id="cofree">Cofree</h1>
<p>Before going any further, all of the functions so far can be redefined to work on the <a href="http://hackage.haskell.org/package/free-5.0.2/docs/Control-Comonad-Cofree.html">cofree comonad</a>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Cofree</span> f a <span class="fu">=</span> a <span class="fu">:&lt;</span> f (<span class="dt">Cofree</span> f a)</a></code></pre></div>
<p>When <code class="sourceCode haskell">f</code> is specialized to <code class="sourceCode haskell">[]</code>, we get the original rose tree. But what we actually require is much less specific: <code class="sourceCode haskell">levels</code>, for instance, only needs <code class="sourceCode haskell"><span class="dt">Foldable</span></code>.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">levelsCofree ::</span> <span class="dt">Foldable</span> f <span class="ot">=&gt;</span> <span class="dt">Cofree</span> f a <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">levelsCofree tr <span class="fu">=</span> f tr []</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">    f (x<span class="fu">:&lt;</span>xs) (y<span class="fu">:</span>ys) <span class="fu">=</span> (x<span class="fu">:</span>y) <span class="fu">:</span> foldr f ys xs</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">    f (x<span class="fu">:&lt;</span>xs) []     <span class="fu">=</span> [x]   <span class="fu">:</span> foldr f [] xs</a></code></pre></div>
<p>Using this, we can write the efficient breadth-first traversal:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1">breadthFirst</a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="ot">    ::</span> (<span class="dt">Applicative</span> f, <span class="dt">Traversable</span> t)</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">    <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> <span class="dt">Cofree</span> t a <span class="ot">-&gt;</span> f (<span class="dt">Cofree</span> t b)</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">breadthFirst c (t<span class="fu">:&lt;</span>ts) <span class="fu">=</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">    liftA2 evalState (map2 (<span class="fu">:&lt;</span>) (c t) (fill ts)) chld</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-7" data-line-number="7">    chld <span class="fu">=</span> foldr (liftA2 evalState) (pure []) (foldr f [] ts)</a>
<a class="sourceLine" id="cb5-8" data-line-number="8">    fill <span class="fu">=</span> traverse (const (state (\(x<span class="fu">:</span>xs) <span class="ot">-&gt;</span> (x,xs))))</a>
<a class="sourceLine" id="cb5-9" data-line-number="9"></a>
<a class="sourceLine" id="cb5-10" data-line-number="10">    f (x<span class="fu">:&lt;</span>xs) (q<span class="fu">:</span>qs)</a>
<a class="sourceLine" id="cb5-11" data-line-number="11">        <span class="fu">=</span> app2 (\y ys zs <span class="ot">-&gt;</span> (y<span class="fu">:&lt;</span>ys) <span class="fu">:</span> zs) (c x) (fill xs) q</a>
<a class="sourceLine" id="cb5-12" data-line-number="12">        <span class="fu">:</span> foldr f qs xs</a>
<a class="sourceLine" id="cb5-13" data-line-number="13">    f (x<span class="fu">:&lt;</span>xs) []</a>
<a class="sourceLine" id="cb5-14" data-line-number="14">        <span class="fu">=</span> map2 (\y ys <span class="ot">-&gt;</span> [y<span class="fu">:&lt;</span>ys]) (c x) (fill xs)</a>
<a class="sourceLine" id="cb5-15" data-line-number="15">        <span class="fu">:</span> foldr f [] xs</a>
<a class="sourceLine" id="cb5-16" data-line-number="16"></a>
<a class="sourceLine" id="cb5-17" data-line-number="17">    map2 k x xs <span class="fu">=</span> fmap   (\y <span class="ot">-&gt;</span> fmap   (k y) xs) x</a>
<a class="sourceLine" id="cb5-18" data-line-number="18">    app2 k x xs <span class="fu">=</span> liftA2 (\y <span class="ot">-&gt;</span> liftA2 (k y) xs) x</a></code></pre></div>
<p>At every level, the subforest’s shape it taken (<code class="sourceCode haskell">fill</code>), and it’s traversed recursively. We can fuse these two steps into one:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1">breadthFirst</a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="ot">    ::</span> (<span class="dt">Traversable</span> t, <span class="dt">Applicative</span> f)</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">    <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> <span class="dt">Cofree</span> t a  <span class="ot">-&gt;</span> f (<span class="dt">Cofree</span> t b)</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">breadthFirst c (t<span class="fu">:&lt;</span>ts) <span class="fu">=</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">    liftA2</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">        evalState</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">        (map2 (<span class="fu">:&lt;</span>) (c t) fill)</a>
<a class="sourceLine" id="cb6-8" data-line-number="8">        (foldr (liftA2 evalState) (pure []) (chld []))</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-10" data-line-number="10">    <span class="dt">Compose</span> (<span class="dt">Endo</span> chld,fill) <span class="fu">=</span> go ts</a>
<a class="sourceLine" id="cb6-11" data-line-number="11"></a>
<a class="sourceLine" id="cb6-12" data-line-number="12">    go <span class="fu">=</span> traverse (\x <span class="ot">-&gt;</span> <span class="dt">Compose</span> (<span class="dt">Endo</span> (f x), state (\(y<span class="fu">:</span>ys) <span class="ot">-&gt;</span> (y,ys))))</a>
<a class="sourceLine" id="cb6-13" data-line-number="13"></a>
<a class="sourceLine" id="cb6-14" data-line-number="14">    f (x<span class="fu">:&lt;</span>xs) (q<span class="fu">:</span>qs) <span class="fu">=</span> app2 (\y ys zs <span class="ot">-&gt;</span> (y<span class="fu">:&lt;</span>ys) <span class="fu">:</span> zs) (c x) r q <span class="fu">:</span> rs qs</a>
<a class="sourceLine" id="cb6-15" data-line-number="15">      <span class="kw">where</span> <span class="dt">Compose</span> (<span class="dt">Endo</span> rs,r) <span class="fu">=</span> go xs</a>
<a class="sourceLine" id="cb6-16" data-line-number="16">    f (x<span class="fu">:&lt;</span>xs) [] <span class="fu">=</span> map2 (\y ys <span class="ot">-&gt;</span> [y<span class="fu">:&lt;</span>ys]) (c x) r <span class="fu">:</span> rs []</a>
<a class="sourceLine" id="cb6-17" data-line-number="17">      <span class="kw">where</span> <span class="dt">Compose</span> (<span class="dt">Endo</span> rs,r) <span class="fu">=</span> go xs</a>
<a class="sourceLine" id="cb6-18" data-line-number="18"></a>
<a class="sourceLine" id="cb6-19" data-line-number="19">    map2 k x xs <span class="fu">=</span> fmap   (\y <span class="ot">-&gt;</span> fmap   (k y) xs) x</a>
<a class="sourceLine" id="cb6-20" data-line-number="20">    app2 k x xs <span class="fu">=</span> liftA2 (\y <span class="ot">-&gt;</span> liftA2 (k y) xs) x</a></code></pre></div>
<p>The overhead from this approach scraps any benefit, though.</p>
<div id="refs" class="references">
<div id="ref-gibbons_breadth-first_2015">
<p>Gibbons, Jeremy. 2015. “Breadth-First Traversal.” <em>Patterns in Functional Programming</em>. <a href="https://patternsinfp.wordpress.com/2015/03/05/breadth-first-traversal/" class="uri">https://patternsinfp.wordpress.com/2015/03/05/breadth-first-traversal/</a>.</p>
</div>
</div>
]]></description>
    <pubDate>Fri, 01 Jun 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-06-01-rose-trees-breadth-first-traversing.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Sorting Small Things in Haskell</title>
    <link>https://doisinkidney.com/posts/2018-05-06-sorting-small.html</link>
    <description><![CDATA[<div class="info">
    Posted on May  6, 2018
</div>
<div class="info">
    
        Part 1 of a <a href="/series/Sorting.html">1-part series on Sorting</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Algorithms.html">Algorithms</a>
    
</div>

<p>I was working on some performance-intensive stuff recently, and I ran into the issue of sorting very small amounts of values (think 3, 4, 5).</p>
<p>The standard way to do this is with <a href="https://en.wikipedia.org/wiki/Sorting_network">sorting networks</a>. The way I’ll be using doesn’t actually perform any parallelism (unfortunately), but it is a clean way to write the networks in Haskell without too much repetition.</p>
<p><a href="http://pages.ripco.net/~jgamble/nw.html">This</a> website will generate an optimal sorting network for your given size, and the output (for 3) looks like this:</p>
<pre><code>[[1,2]]
[[0,2]]
[[0,1]]</code></pre>
<p>Each pair of indices represents a “compare-and-swap” operation: so the first line means “compare the value at 1 to the value at 2: if it’s bigger, swap them”. For 5, the network looks like this:</p>
<pre><code>[[0,1],[2,3]]
[[0,2],[1,3]]
[[1,2],[0,4]]
[[1,4]]
[[2,4]]
[[3,4]]</code></pre>
<p>Pairs on the same line can be performed in parallel.</p>
<p>For our case, I’m going to be looking at sorting tuples, but the technique can easily be generalized to vectors, etc.</p>
<p>The first trick is to figure out how to do “swapping”: we don’t want mutation, so what we can do instead is swap the <em>reference</em> to some value, by shadowing its name. In other words:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">swap2 ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> (a, a)</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">swap2 lte x y <span class="fu">|</span> lte x y <span class="fu">=</span> (x, y)</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">              <span class="fu">|</span> otherwise <span class="fu">=</span> (y, x)</a>
<a class="sourceLine" id="cb3-4" data-line-number="4"></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="ot">sort3 ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> (a,a,a) <span class="ot">-&gt;</span> (a,a,a)</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">sort3 lte (_0,_1,_2)</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">    <span class="fu">=</span> <span class="kw">case</span> swap2 lte _1 _2 <span class="kw">of</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8">      (_1, _2) <span class="ot">-&gt;</span> <span class="kw">case</span> swap2 lte _0 _2 <span class="kw">of</span></a>
<a class="sourceLine" id="cb3-9" data-line-number="9">        (_0, _2) <span class="ot">-&gt;</span> <span class="kw">case</span> swap2 lte _0 _1 <span class="kw">of</span></a>
<a class="sourceLine" id="cb3-10" data-line-number="10">          (_0, _1) <span class="ot">-&gt;</span> (_0, _1, _2)</a></code></pre></div>
<p>The indentation is hard to read, though, and wrapping-and-unwrapping tuples makes me nervous about the performance (although it may be inlined). The next step is to <em>church-encode</em> the pairs returned:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">swap2 ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">swap2 lte x y k</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">    <span class="fu">|</span> lte x y <span class="fu">=</span> k x y</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">    <span class="fu">|</span> otherwise <span class="fu">=</span> k y x</a>
<a class="sourceLine" id="cb4-5" data-line-number="5"></a>
<a class="sourceLine" id="cb4-6" data-line-number="6"><span class="ot">sort3 ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> (a,a,a) <span class="ot">-&gt;</span> (a,a,a)</a>
<a class="sourceLine" id="cb4-7" data-line-number="7">sort3 lte (_0,_1,_2)</a>
<a class="sourceLine" id="cb4-8" data-line-number="8">    <span class="fu">=</span> swap2 lte _1 _2 <span class="fu">$</span> \ _1 _2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb4-9" data-line-number="9">      swap2 lte _0 _2 <span class="fu">$</span> \ _0 _2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb4-10" data-line-number="10">      swap2 lte _0 _1 <span class="fu">$</span> \ _0 _1 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb4-11" data-line-number="11">      (_0,_1,_2)</a></code></pre></div>
<p>Then, to get this to compile down to efficient code, we can make judicious use of <a href="http://hackage.haskell.org/package/base-4.11.1.0/docs/GHC-Exts.html#v:inline"><code class="sourceCode haskell">inline</code></a> from GHC.Exts:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">import</span> <span class="dt">GHC.Exts</span> (inline)</a>
<a class="sourceLine" id="cb5-2" data-line-number="2"></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="ot">swap2 ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">swap2 lte x y k</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">    <span class="fu">|</span> inline lte x y <span class="fu">=</span> inline k x y</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">    <span class="fu">|</span> otherwise <span class="fu">=</span> inline k y x</a>
<a class="sourceLine" id="cb5-7" data-line-number="7"><span class="ot">{-# INLINE swap2 #-}</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8"></a>
<a class="sourceLine" id="cb5-9" data-line-number="9"><span class="ot">sort3 ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> (a, a, a) <span class="ot">-&gt;</span> (a, a, a)</a>
<a class="sourceLine" id="cb5-10" data-line-number="10">sort3 lte (_0,_1,_2)</a>
<a class="sourceLine" id="cb5-11" data-line-number="11">    <span class="fu">=</span> swap2 lte _1 _2 <span class="fu">$</span> \ _1 _2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb5-12" data-line-number="12">      swap2 lte _0 _2 <span class="fu">$</span> \ _0 _2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb5-13" data-line-number="13">      swap2 lte _0 _1 <span class="fu">$</span> \ _0 _1 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb5-14" data-line-number="14">      (_0,_1,_2)</a>
<a class="sourceLine" id="cb5-15" data-line-number="15"><span class="ot">{-# INLINE sort3 #-}</span></a></code></pre></div>
<p>And to see if this really does make efficient code, let’s look at the core (cleaned up):</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1">sort3</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  <span class="fu">=</span> \ (<span class="ot">lte ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">      (<span class="ot">ds ::</span> (a, a, a)) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">      <span class="kw">case</span> ds <span class="kw">of</span> wild_X8 (_0, _1, _2) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">      <span class="kw">case</span> lte _1 _2 <span class="kw">of</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">        <span class="dt">False</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb6-7" data-line-number="7">          <span class="kw">case</span> lte _0 _1 <span class="kw">of</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">            <span class="dt">False</span> <span class="ot">-&gt;</span> (_2, _1, _0)</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">            <span class="dt">True</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb6-10" data-line-number="10">              <span class="kw">case</span> lte _0 _2 <span class="kw">of</span></a>
<a class="sourceLine" id="cb6-11" data-line-number="11">                <span class="dt">False</span> <span class="ot">-&gt;</span> (_2, _0, _1)</a>
<a class="sourceLine" id="cb6-12" data-line-number="12">                <span class="dt">True</span> <span class="ot">-&gt;</span> (_0, _2, _1)</a>
<a class="sourceLine" id="cb6-13" data-line-number="13">        <span class="dt">True</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb6-14" data-line-number="14">          <span class="kw">case</span> lte _0 _2 <span class="kw">of</span></a>
<a class="sourceLine" id="cb6-15" data-line-number="15">            <span class="dt">False</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb6-16" data-line-number="16">              <span class="kw">case</span> lte _2 _1 <span class="kw">of</span></a>
<a class="sourceLine" id="cb6-17" data-line-number="17">                <span class="dt">False</span> <span class="ot">-&gt;</span> (_1, _2, _0)</a>
<a class="sourceLine" id="cb6-18" data-line-number="18">                <span class="dt">True</span> <span class="ot">-&gt;</span> (_2, _1, _0)</a>
<a class="sourceLine" id="cb6-19" data-line-number="19">            <span class="dt">True</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb6-20" data-line-number="20">              <span class="kw">case</span> lte _0 _1 <span class="kw">of</span></a>
<a class="sourceLine" id="cb6-21" data-line-number="21">                <span class="dt">False</span> <span class="ot">-&gt;</span> (_1, _0, _2)</a>
<a class="sourceLine" id="cb6-22" data-line-number="22">                <span class="dt">True</span> <span class="ot">-&gt;</span> wild_X8</a></code></pre></div>
<p>Fantastic! When we specialize to <code class="sourceCode haskell"><span class="dt">Int</span></code>, we get all of the proper unpacking:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">sort3Int ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Int</span>, <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">sort3Int <span class="fu">=</span> inline sort3 (<span class="fu">&lt;=</span>)</a></code></pre></div>
<p>Core (with just the variable names cleaned up this time):</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">sort3Int</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  <span class="fu">=</span> \ (<span class="ot">w ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>, <span class="dt">Int</span>)) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">      <span class="kw">case</span> w <span class="kw">of</span> w_X { (_0, _1, _2) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">      <span class="kw">case</span> _0 <span class="kw">of</span> w_0 { <span class="dt">GHC.Types.I</span><span class="fu">#</span> _0U <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5">      <span class="kw">case</span> _1 <span class="kw">of</span> w_1 { <span class="dt">GHC.Types.I</span><span class="fu">#</span> _1U <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">      <span class="kw">case</span> _2 <span class="kw">of</span> w_2 { <span class="dt">GHC.Types.I</span><span class="fu">#</span> _2U <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb8-7" data-line-number="7">      <span class="kw">case</span> <span class="fu">GHC.Prim.&lt;=#</span> _1U _2U <span class="kw">of</span> {</a>
<a class="sourceLine" id="cb8-8" data-line-number="8">        __DEFAULT <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb8-9" data-line-number="9">          <span class="kw">case</span> <span class="fu">GHC.Prim.&lt;=#</span> _0U _1U <span class="kw">of</span> {</a>
<a class="sourceLine" id="cb8-10" data-line-number="10">            __DEFAULT <span class="ot">-&gt;</span> (w_2, w_1, w_0);</a>
<a class="sourceLine" id="cb8-11" data-line-number="11">            <span class="dv">1</span><span class="fu">#</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb8-12" data-line-number="12">              <span class="kw">case</span> <span class="fu">GHC.Prim.&lt;=#</span> _0U _2U <span class="kw">of</span> {</a>
<a class="sourceLine" id="cb8-13" data-line-number="13">                __DEFAULT <span class="ot">-&gt;</span> (w_2, w_0, w_1);</a>
<a class="sourceLine" id="cb8-14" data-line-number="14">                <span class="dv">1</span><span class="fu">#</span> <span class="ot">-&gt;</span> (w_0, w_2, w_1)</a>
<a class="sourceLine" id="cb8-15" data-line-number="15">              }</a>
<a class="sourceLine" id="cb8-16" data-line-number="16">          };</a>
<a class="sourceLine" id="cb8-17" data-line-number="17">        <span class="dv">1</span><span class="fu">#</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb8-18" data-line-number="18">          <span class="kw">case</span> <span class="fu">GHC.Prim.&lt;=#</span> _0U _2U <span class="kw">of</span> {</a>
<a class="sourceLine" id="cb8-19" data-line-number="19">            __DEFAULT <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb8-20" data-line-number="20">              <span class="kw">case</span> <span class="fu">GHC.Prim.&lt;=#</span> _2U _1U <span class="kw">of</span> {</a>
<a class="sourceLine" id="cb8-21" data-line-number="21">                __DEFAULT <span class="ot">-&gt;</span> (w_1, w_2, w_0);</a>
<a class="sourceLine" id="cb8-22" data-line-number="22">                <span class="dv">1</span><span class="fu">#</span> <span class="ot">-&gt;</span> (w_2, w_1, w_0)</a>
<a class="sourceLine" id="cb8-23" data-line-number="23">              };</a>
<a class="sourceLine" id="cb8-24" data-line-number="24">            <span class="dv">1</span><span class="fu">#</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb8-25" data-line-number="25">              <span class="kw">case</span> <span class="fu">GHC.Prim.&lt;=#</span> _0U _1U <span class="kw">of</span> {</a>
<a class="sourceLine" id="cb8-26" data-line-number="26">                __DEFAULT <span class="ot">-&gt;</span> (w_1, w_0, w_2);</a>
<a class="sourceLine" id="cb8-27" data-line-number="27">                <span class="dv">1</span><span class="fu">#</span> <span class="ot">-&gt;</span> w_X</a>
<a class="sourceLine" id="cb8-28" data-line-number="28">              }</a>
<a class="sourceLine" id="cb8-29" data-line-number="29">          }</a>
<a class="sourceLine" id="cb8-30" data-line-number="30">      }</a>
<a class="sourceLine" id="cb8-31" data-line-number="31">      }</a>
<a class="sourceLine" id="cb8-32" data-line-number="32">      }</a>
<a class="sourceLine" id="cb8-33" data-line-number="33">      }</a>
<a class="sourceLine" id="cb8-34" data-line-number="34">      }</a></code></pre></div>
<p>Now, for the real test: sorting 5-tuples, using the network above.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">sort5 ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> (a,a,a,a,a) <span class="ot">-&gt;</span> (a,a,a,a,a)</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">sort5 lte (_0,_1,_2,_3,_4)</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">    <span class="fu">=</span> swap2 lte _0 _1 <span class="fu">$</span> \ _0 _1 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4">      swap2 lte _2 _3 <span class="fu">$</span> \ _2 _3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">      swap2 lte _0 _2 <span class="fu">$</span> \ _0 _2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6">      swap2 lte _1 _3 <span class="fu">$</span> \ _1 _3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-7" data-line-number="7">      swap2 lte _1 _2 <span class="fu">$</span> \ _1 _2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-8" data-line-number="8">      swap2 lte _0 _4 <span class="fu">$</span> \ _0 _4 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-9" data-line-number="9">      swap2 lte _1 _4 <span class="fu">$</span> \ _1 _4 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-10" data-line-number="10">      swap2 lte _2 _4 <span class="fu">$</span> \ _2 _4 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-11" data-line-number="11">      swap2 lte _3 _4 <span class="fu">$</span> \ _3 _4 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-12" data-line-number="12">      (_0,_1,_2,_3,_4)</a>
<a class="sourceLine" id="cb9-13" data-line-number="13"><span class="ot">{-# INLINE sort5 #-}</span></a></code></pre></div>
<p>The core output from this is over 1000 lines long: you can see it (with the variable names cleaned up) <a href="https://gist.github.com/oisdk/ec25d76d918135c4c28777e1b84ead5f">here</a>.</p>
<p>In my benchmarks, these functions are indeed quicker than their counterparts in vector, but I’m not confident in my knowledge of Haskell performance to make much of a strong statement about them.</p>
]]></description>
    <pubDate>Sun, 06 May 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-05-06-sorting-small.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Type-Level Induction in Haskell</title>
    <link>https://doisinkidney.com/posts/2018-05-05-induction.html</link>
    <description><![CDATA[<div class="info">
    Posted on May  5, 2018
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Dependent%20Types.html">Dependent Types</a>
    
</div>

<p>The code from this post is available as a <a href="https://gist.github.com/oisdk/23c430b807c788dd43dc4d986c5fdfdd">gist</a>.</p>
<p>One of the most basic tools for use in type-level programming is the Peano definition of the natural numbers:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> ℕ</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Z</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">    <span class="fu">|</span> <span class="dt">S</span> ℕ</a></code></pre></div>
<p>Using the new <code class="sourceCode haskell"><span class="dt">TypeFamilyDependencies</span></code> extension, these numbers can be used to describe the “size” of some type. I’m going to use the proportion symbol here:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">type</span> family (t <span class="ot">∷</span> k) ∝ (n <span class="ot">∷</span> ℕ) <span class="fu">=</span> (a <span class="ot">∷</span> <span class="dt">Type</span>) <span class="fu">|</span> a <span class="ot">→</span> t n k</a></code></pre></div>
<p>Using this type family we can describe induction on the natural numbers:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Finite</span> n <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">    induction <span class="ot">∷</span> t ∝ <span class="dt">Z</span> <span class="ot">→</span> (<span class="ot">∀</span> k<span class="fu">.</span> t ∝ k <span class="ot">→</span> t ∝ <span class="dt">S</span> k) <span class="ot">→</span> t ∝ n</a>
<a class="sourceLine" id="cb3-3" data-line-number="3"></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="kw">instance</span> <span class="dt">Finite</span> <span class="dt">Z</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">    induction z _ <span class="fu">=</span> z</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">    <span class="ot">{-# inline induction #-}</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7"></a>
<a class="sourceLine" id="cb3-8" data-line-number="8"><span class="kw">instance</span> <span class="dt">Finite</span> n <span class="ot">⇒</span> <span class="dt">Finite</span> (<span class="dt">S</span> n) <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-9" data-line-number="9">    induction z s <span class="fu">=</span> s (induction z s)</a>
<a class="sourceLine" id="cb3-10" data-line-number="10">    <span class="ot">{-# inline induction #-}</span></a></code></pre></div>
<p>The <code class="sourceCode haskell">induction</code> function reads as the standard mathematical definition of induction: given a proof (value) of the zero case, and a proof that any proof is true for its successor, we can give you a proof of the case for any finite number.</p>
<p>An added bonus here is that the size of something can usually be resolved at compile-time, so any inductive function on it should also be resolved at compile time.</p>
<p>We can use it to provide the standard instances for basic length-indexed lists:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:-</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="kw">data</span> <span class="dt">List</span> n a <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">        <span class="dt">Nil</span>  <span class="ot">∷</span> <span class="dt">List</span> <span class="dt">Z</span> a</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">        (<span class="fu">:-</span>) <span class="ot">∷</span> a <span class="ot">→</span> <span class="dt">List</span> n a <span class="ot">→</span> <span class="dt">List</span> (<span class="dt">S</span> n) a</a></code></pre></div>
<p>Some instances for those lists are easy:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">List</span> n) <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">    fmap _ <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">    fmap f (x <span class="fu">:-</span> xs) <span class="fu">=</span> f x <span class="fu">:-</span> fmap f xs</a></code></pre></div>
<p>However, for <code class="sourceCode haskell"><span class="dt">Applicative</span></code>, we need some way to recurse on the size of the list. This is where induction comes in.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">type</span> <span class="kw">instance</span> <span class="ch">&#39;(List,a) ∝ n = List n a</span></a></code></pre></div>
<p>This lets us write <code class="sourceCode haskell">pure</code> in a pleasingly simple way:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Finite</span> n <span class="ot">⇒</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">         <span class="dt">Applicative</span> (<span class="dt">List</span> n) <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">    pure x <span class="fu">=</span> induction <span class="dt">Nil</span> (x <span class="fu">:-</span>)</a></code></pre></div>
<p>But can we also write <code class="sourceCode haskell"><span class="fu">&lt;*&gt;</span></code> using induction? Yes! Because we’ve factored out the induction itself, we just need to describe the notion of a “sized” function:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">data</span> a ↦ b</a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="kw">type</span> <span class="kw">instance</span> ((x <span class="ot">∷</span> a) ↦ (y <span class="ot">∷</span> b)) ∝ n <span class="fu">=</span> (x ∝ n) <span class="ot">→</span> (y ∝ n)</a></code></pre></div>
<p>Then we can write <code class="sourceCode haskell"><span class="fu">&lt;*&gt;</span></code> as so:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Finite</span> n <span class="ot">⇒</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">         <span class="dt">Applicative</span> (<span class="dt">List</span> n) <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">    pure x <span class="fu">=</span> induction <span class="dt">Nil</span> (x <span class="fu">:-</span>)</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">    (<span class="fu">&lt;*&gt;</span>) <span class="fu">=</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">        induction</a>
<a class="sourceLine" id="cb9-6" data-line-number="6">            (\<span class="dt">Nil</span> <span class="dt">Nil</span> <span class="ot">→</span> <span class="dt">Nil</span>)</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">            (\k (f <span class="fu">:-</span> fs) (x <span class="fu">:-</span> xs) <span class="ot">→</span> f x <span class="fu">:-</span> k fs xs)</a></code></pre></div>
<p>What about the <code class="sourceCode haskell"><span class="dt">Monad</span></code> instance? For that, we need a little bit of plumbing: the type signature of <code class="sourceCode haskell"><span class="fu">&gt;&gt;=</span></code> is:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">(<span class="fu">&gt;&gt;=</span>) <span class="ot">∷</span> m a <span class="ot">→</span> (a <span class="ot">→</span> m b) <span class="ot">→</span> m b</a></code></pre></div>
<p>One of the parameters (the second <code>a</code>) doesn’t have a size: we’ll need to work around that, with <code class="sourceCode haskell"><span class="dt">Const</span></code>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">type</span> <span class="kw">instance</span> (<span class="dt">Const</span> a <span class="ot">∷</span> ℕ <span class="ot">→</span> <span class="dt">Type</span>) ∝ n <span class="fu">=</span> <span class="dt">Const</span> a n</a></code></pre></div>
<p>Using this, we can write our <code class="sourceCode haskell"><span class="dt">Monad</span></code> instance:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1">head&#39; <span class="ot">∷</span> <span class="dt">List</span> (<span class="dt">S</span> n) a <span class="ot">→</span> a</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">head&#39; (x <span class="fu">:-</span> _) <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb12-3" data-line-number="3"></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">tail&#39; <span class="ot">∷</span> <span class="dt">List</span> (<span class="dt">S</span> n) a <span class="ot">→</span> <span class="dt">List</span> n a</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">tail&#39; (_ <span class="fu">:-</span> xs) <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb12-6" data-line-number="6"></a>
<a class="sourceLine" id="cb12-7" data-line-number="7"><span class="kw">instance</span> <span class="dt">Finite</span> n <span class="ot">⇒</span></a>
<a class="sourceLine" id="cb12-8" data-line-number="8">         <span class="dt">Monad</span> (<span class="dt">List</span> n) <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-9" data-line-number="9">    xs <span class="fu">&gt;&gt;=</span> (f <span class="ot">∷</span> a <span class="ot">→</span> <span class="dt">List</span> n b) <span class="fu">=</span></a>
<a class="sourceLine" id="cb12-10" data-line-number="10">        induction</a>
<a class="sourceLine" id="cb12-11" data-line-number="11">            (\<span class="dt">Nil</span> _ <span class="ot">→</span> <span class="dt">Nil</span>)</a>
<a class="sourceLine" id="cb12-12" data-line-number="12">            (\k (y <span class="fu">:-</span> ys) fn <span class="ot">→</span> head&#39; (fn (<span class="dt">Const</span> y)) <span class="fu">:-</span></a>
<a class="sourceLine" id="cb12-13" data-line-number="13">                               k ys (tail&#39; <span class="fu">.</span> fn <span class="fu">.</span> <span class="dt">Const</span> <span class="fu">.</span> getConst))</a>
<a class="sourceLine" id="cb12-14" data-line-number="14">            xs</a>
<a class="sourceLine" id="cb12-15" data-line-number="15">            (f <span class="fu">.</span> getConst <span class="ot">∷</span> <span class="dt">Const</span> a n <span class="ot">→</span> <span class="dt">List</span> n b)</a></code></pre></div>
<h2 id="type-family-dependencies">Type Family Dependencies</h2>
<p>Getting the above to work actually took a surprising amount of work: the crux is that the <code class="sourceCode haskell">∝</code> type family needs to be injective, so the “successor” proof can typecheck. Unfortunately, this means that every type can only have one notion of “size”. What I’d prefer is to be able to pass in a function indicating exactly <em>how</em> to get the size out of a type, that could change depending on the situation. So we could recurse on the first argument of a function, for instance, or just its second, or just the result. This would need either type-level lambdas (which would be cool), or <a href="https://ghc.haskell.org/trac/ghc/ticket/10832">generalized type family dependencies</a>.</p>
]]></description>
    <pubDate>Sat, 05 May 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-05-05-induction.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>5 Cool Things You Can Do With Pattern Synonyms</title>
    <link>https://doisinkidney.com/posts/2018-04-12-pattern-synonyms.html</link>
    <description><![CDATA[<div class="info">
    Posted on April 12, 2018
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Pattern%20Synonyms.html">Pattern Synonyms</a>
    
</div>

<p><a href="https://ghc.haskell.org/trac/ghc/wiki/PatternSynonyms">Pattern Synonyms</a> is an excellent extension for Haskell. There are some <a href="https://ocharles.org.uk/blog/posts/2014-12-03-pattern-synonyms.html">very</a> <a href="https://www.schoolofhaskell.com/user/icelandj/Pattern%20synonyms">cool</a> examples of their use out there, and I thought I’d add to the list.</p>
<h1 id="make-things-look-like-lists">Make Things Look Like Lists</h1>
<p>Lists are <em>the</em> fundamental data structure for functional programmers. Unfortunately, once more specialized structures are required, you often have to switch over to an uncomfortable, annoying API which isn’t as pleasant or fun to use as cons and nil. With pattern synonyms, though, that’s not so! For instance, here’s how you would do it with a run-length-encoded list:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> <span class="dt">List</span> a</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">    <span class="fu">|</span> <span class="dt">ConsN</span> <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">Int</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">            a</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">            (<span class="dt">List</span> a)</a>
<a class="sourceLine" id="cb1-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="ot">cons ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a</a>
<a class="sourceLine" id="cb1-8" data-line-number="8">cons x (<span class="dt">ConsN</span> i y ys)</a>
<a class="sourceLine" id="cb1-9" data-line-number="9">  <span class="fu">|</span> x <span class="fu">==</span> y <span class="fu">=</span> <span class="dt">ConsN</span> (i<span class="fu">+</span><span class="dv">1</span>) y ys</a>
<a class="sourceLine" id="cb1-10" data-line-number="10">cons x xs <span class="fu">=</span> <span class="dt">ConsN</span> <span class="dv">1</span> x xs</a>
<a class="sourceLine" id="cb1-11" data-line-number="11"></a>
<a class="sourceLine" id="cb1-12" data-line-number="12"><span class="ot">uncons ::</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, <span class="dt">List</span> a)</a>
<a class="sourceLine" id="cb1-13" data-line-number="13">uncons <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb1-14" data-line-number="14">uncons (<span class="dt">ConsN</span> <span class="dv">1</span> x xs) <span class="fu">=</span> <span class="dt">Just</span> (x, xs)</a>
<a class="sourceLine" id="cb1-15" data-line-number="15">uncons (<span class="dt">ConsN</span> n x xs) <span class="fu">=</span> <span class="dt">Just</span> (x, <span class="dt">ConsN</span> (n<span class="fu">-</span><span class="dv">1</span>) x xs)</a>
<a class="sourceLine" id="cb1-16" data-line-number="16"></a>
<a class="sourceLine" id="cb1-17" data-line-number="17"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:-</span></a>
<a class="sourceLine" id="cb1-18" data-line-number="18">pattern<span class="ot"> (:-) ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a</a>
<a class="sourceLine" id="cb1-19" data-line-number="19">pattern x <span class="fu">:-</span> xs <span class="ot">&lt;-</span> (uncons <span class="ot">-&gt;</span> <span class="dt">Just</span> (x, xs))</a>
<a class="sourceLine" id="cb1-20" data-line-number="20">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-21" data-line-number="21">    x <span class="fu">:-</span> xs <span class="fu">=</span> cons x xs</a>
<a class="sourceLine" id="cb1-22" data-line-number="22"><span class="ot">{-# COMPLETE Nil, (:-) #-}</span></a>
<a class="sourceLine" id="cb1-23" data-line-number="23"></a>
<a class="sourceLine" id="cb1-24" data-line-number="24">zip<span class="ot"> ::</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> b <span class="ot">-&gt;</span> <span class="dt">List</span> (a,b)</a>
<a class="sourceLine" id="cb1-25" data-line-number="25">zip (x <span class="fu">:-</span> xs) (y <span class="fu">:-</span> ys) <span class="fu">=</span> (x,y) <span class="fu">:-</span> zip xs ys</a>
<a class="sourceLine" id="cb1-26" data-line-number="26">zip _ _ <span class="fu">=</span> <span class="dt">Nil</span></a></code></pre></div>
<p>A little more useful would be to do the same with a heap:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Leaf</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">    <span class="fu">|</span> <span class="dt">Node</span> a (<span class="dt">Tree</span> a) (<span class="dt">Tree</span> a)</a>
<a class="sourceLine" id="cb2-4" data-line-number="4"></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="ot">smerge ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">smerge <span class="dt">Leaf</span> ys <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">smerge xs <span class="dt">Leaf</span> <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">smerge h1<span class="fu">@</span>(<span class="dt">Node</span> x lx rx) h2<span class="fu">@</span>(<span class="dt">Node</span> y ly ry)</a>
<a class="sourceLine" id="cb2-9" data-line-number="9">  <span class="fu">|</span> x <span class="fu">&lt;=</span> y    <span class="fu">=</span> <span class="dt">Node</span> x (smerge h2 rx) lx</a>
<a class="sourceLine" id="cb2-10" data-line-number="10">  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Node</span> y (smerge h1 ry) ly</a>
<a class="sourceLine" id="cb2-11" data-line-number="11"></a>
<a class="sourceLine" id="cb2-12" data-line-number="12"><span class="ot">cons ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb2-13" data-line-number="13">cons x <span class="fu">=</span> smerge (<span class="dt">Node</span> x <span class="dt">Leaf</span> <span class="dt">Leaf</span>)</a>
<a class="sourceLine" id="cb2-14" data-line-number="14"></a>
<a class="sourceLine" id="cb2-15" data-line-number="15"><span class="ot">uncons ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, <span class="dt">Tree</span> a)</a>
<a class="sourceLine" id="cb2-16" data-line-number="16">uncons <span class="dt">Leaf</span> <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb2-17" data-line-number="17">uncons (<span class="dt">Node</span> x l r) <span class="fu">=</span> <span class="dt">Just</span> (x, smerge l r)</a>
<a class="sourceLine" id="cb2-18" data-line-number="18"></a>
<a class="sourceLine" id="cb2-19" data-line-number="19"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:-</span></a>
<a class="sourceLine" id="cb2-20" data-line-number="20">pattern<span class="ot"> (:-) ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb2-21" data-line-number="21">pattern x <span class="fu">:-</span> xs <span class="ot">&lt;-</span> (uncons <span class="ot">-&gt;</span> <span class="dt">Just</span> (x, xs))</a>
<a class="sourceLine" id="cb2-22" data-line-number="22">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-23" data-line-number="23">    x <span class="fu">:-</span> xs <span class="fu">=</span> cons x xs</a>
<a class="sourceLine" id="cb2-24" data-line-number="24"><span class="ot">{-# COMPLETE Leaf, (:-) #-}</span></a>
<a class="sourceLine" id="cb2-25" data-line-number="25"></a>
<a class="sourceLine" id="cb2-26" data-line-number="26">sort<span class="ot"> ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb2-27" data-line-number="27">sort <span class="fu">=</span> go <span class="fu">.</span> foldr (<span class="fu">:-</span>) <span class="dt">Leaf</span></a>
<a class="sourceLine" id="cb2-28" data-line-number="28">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-29" data-line-number="29">    go <span class="dt">Leaf</span> <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb2-30" data-line-number="30">    go (x <span class="fu">:-</span> xs) <span class="fu">=</span> x <span class="fu">:</span> go xs</a></code></pre></div>
<p>In fact, this pattern can be generalized, so <em>any</em> container-like-thing with a cons-like-thing can be modified as you would with lists. You can see the generalization in <a href="https://hackage.haskell.org/package/lens-4.16.1/docs/Control-Lens-Cons.html#v::-60-">lens</a>.</p>
<h1 id="retroactively-make-lyah-examples-work">Retroactively Make <a href="http://learnyouahaskell.com">LYAH</a> Examples Work</h1>
<p>One of the most confusing things I remember about learning Haskell early-on was that the vast majority of the Monads examples didn’t work, because they were written pre-transformers. In other words, the state monad was defined like so:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">State</span> s a <span class="fu">=</span> <span class="dt">State</span> {<span class="ot"> runState ::</span> s <span class="ot">-&gt;</span> (a, s) }</a></code></pre></div>
<p>But in transformers nowadays (which is where you get <code class="sourceCode haskell"><span class="dt">State</span></code> from if you import it in the normal way), the definition is:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">StateT</span> s m a <span class="fu">=</span> <span class="dt">StateT</span> {<span class="ot"> runStateT ::</span> s <span class="ot">-&gt;</span> m (a, s) }</a>
<a class="sourceLine" id="cb4-2" data-line-number="2"></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="kw">type</span> <span class="dt">State</span> s <span class="fu">=</span> <span class="dt">StateT</span> s <span class="dt">Identity</span></a></code></pre></div>
<p>This results in some <em>very</em> confusing error messages when you try run example code.</p>
<p>However, we can pretend that the change never happened, with a simple pattern synonym:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">StateT</span> s m a <span class="fu">=</span> <span class="dt">StateT</span> {<span class="ot"> runStateT ::</span> s <span class="ot">-&gt;</span> m (a, s) }</a>
<a class="sourceLine" id="cb5-2" data-line-number="2"></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="kw">type</span> <span class="dt">State</span> s <span class="fu">=</span> <span class="dt">StateT</span> s <span class="dt">Identity</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4"></a>
<a class="sourceLine" id="cb5-5" data-line-number="5"><span class="ot">runState ::</span> <span class="dt">State</span> s a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> (a, s)</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">runState xs <span class="fu">=</span> runIdentity <span class="fu">.</span> runStateT xs</a>
<a class="sourceLine" id="cb5-7" data-line-number="7"></a>
<a class="sourceLine" id="cb5-8" data-line-number="8">pattern <span class="dt">State</span><span class="ot"> ::</span> (s <span class="ot">-&gt;</span> (a, s)) <span class="ot">-&gt;</span> <span class="dt">State</span> s a</a>
<a class="sourceLine" id="cb5-9" data-line-number="9">pattern <span class="dt">State</span> x <span class="ot">&lt;-</span> (runState <span class="ot">-&gt;</span> x)</a>
<a class="sourceLine" id="cb5-10" data-line-number="10">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-11" data-line-number="11">    <span class="dt">State</span> x <span class="fu">=</span> <span class="dt">StateT</span> (<span class="dt">Identity</span> <span class="fu">.</span> x)</a></code></pre></div>
<h1 id="getting-type-level-numbers-with-an-efficient-runtime-representation">Getting Type-Level Numbers With an Efficient Runtime Representation</h1>
<p>If you want to write type-level proofs on numbers, you’ll probably end up using Peano numerals and singletons:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Nat</span> <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">|</span> <span class="dt">S</span> <span class="dt">Nat</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Natty</span> n <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">  <span class="dt">Zy</span><span class="ot"> ::</span> <span class="dt">Natty</span> <span class="dt">Z</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">  <span class="dt">Sy</span><span class="ot"> ::</span> <span class="dt">Natty</span> n <span class="ot">-&gt;</span> <span class="dt">Natty</span> (<span class="dt">S</span> n)</a>
<a class="sourceLine" id="cb6-6" data-line-number="6"></a>
<a class="sourceLine" id="cb6-7" data-line-number="7"><span class="kw">type</span> family (<span class="fu">+</span>) (<span class="ot">n ::</span> <span class="dt">Nat</span>) (<span class="ot">m ::</span> <span class="dt">Nat</span>)<span class="ot"> ::</span> <span class="dt">Nat</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">  <span class="dt">Z</span> <span class="fu">+</span> m <span class="fu">=</span> m</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">  <span class="dt">S</span> n <span class="fu">+</span> m <span class="fu">=</span> <span class="dt">S</span> (n <span class="fu">+</span> m)</a>
<a class="sourceLine" id="cb6-10" data-line-number="10"></a>
<a class="sourceLine" id="cb6-11" data-line-number="11"><span class="ot">plusZeroIsZero ::</span> <span class="dt">Natty</span> n <span class="ot">-&gt;</span> n <span class="fu">+</span> <span class="dt">Z</span> <span class="fu">:~:</span> n</a>
<a class="sourceLine" id="cb6-12" data-line-number="12">plusZeroIsZero <span class="dt">Zy</span> <span class="fu">=</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb6-13" data-line-number="13">plusZeroIsZero (<span class="dt">Sy</span> n) <span class="fu">=</span> <span class="kw">case</span> plusZeroIsZero n <span class="kw">of</span></a>
<a class="sourceLine" id="cb6-14" data-line-number="14">  <span class="dt">Refl</span> <span class="ot">-&gt;</span> <span class="dt">Refl</span></a></code></pre></div>
<p>Pretty cool, right? We can even erase the proof (if we really trust it) using rewrite rules:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">{-# RULES </span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="ot">&quot;plusZeroIsZero&quot; forall n. plusZeroIsZero n = unsafeCoerce Refl</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="ot">#-}</span></a></code></pre></div>
<p>This isn’t <em>ideal</em>, but it’s getting there.</p>
<p>However, if we ever want to use these things at runtime (perhaps as a type-level indication of some data structure’s size), we’re going to rely on the value-level Peano addition, which is bad news.</p>
<p>Not so with pattern synonyms!</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">data</span> family <span class="dt">The</span><span class="ot"> k ::</span> k <span class="ot">-&gt;</span> <span class="dt">Type</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"></a>
<a class="sourceLine" id="cb8-3" data-line-number="3"><span class="kw">class</span> <span class="dt">Sing</span> (<span class="ot">a ::</span> k) <span class="kw">where</span><span class="ot"> sing ::</span> <span class="dt">The</span> k (<span class="ot">a ::</span> k)</a>
<a class="sourceLine" id="cb8-4" data-line-number="4"></a>
<a class="sourceLine" id="cb8-5" data-line-number="5"><span class="kw">data</span> <span class="dt">Nat</span> <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">|</span> <span class="dt">S</span> <span class="dt">Nat</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6"></a>
<a class="sourceLine" id="cb8-7" data-line-number="7"><span class="kw">newtype</span> <span class="kw">instance</span> <span class="dt">The</span> <span class="dt">Nat</span> n <span class="fu">=</span> <span class="dt">NatSing</span> <span class="dt">Natural</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8"></a>
<a class="sourceLine" id="cb8-9" data-line-number="9"><span class="kw">instance</span> <span class="dt">Sing</span> <span class="dt">Z</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-10" data-line-number="10">    sing <span class="fu">=</span> <span class="dt">NatSing</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb8-11" data-line-number="11"></a>
<a class="sourceLine" id="cb8-12" data-line-number="12"><span class="kw">instance</span> <span class="dt">Sing</span> n <span class="ot">=&gt;</span> <span class="dt">Sing</span> (<span class="dt">S</span> n) <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-13" data-line-number="13">    sing <span class="fu">=</span></a>
<a class="sourceLine" id="cb8-14" data-line-number="14">        (<span class="ot">coerce ::</span> (<span class="dt">Natural</span> <span class="ot">-&gt;</span> <span class="dt">Natural</span>) <span class="ot">-&gt;</span> (<span class="dt">The</span> <span class="dt">Nat</span> n <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> (<span class="dt">S</span> n)))</a>
<a class="sourceLine" id="cb8-15" data-line-number="15">            succ sing</a>
<a class="sourceLine" id="cb8-16" data-line-number="16"></a>
<a class="sourceLine" id="cb8-17" data-line-number="17"><span class="kw">data</span> <span class="dt">Natty</span> n <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-18" data-line-number="18">        <span class="dt">ZZy</span><span class="ot"> ::</span> <span class="dt">Natty</span> <span class="dt">Z</span></a>
<a class="sourceLine" id="cb8-19" data-line-number="19">        <span class="dt">SSy</span><span class="ot"> ::</span> <span class="dt">The</span> <span class="dt">Nat</span> n <span class="ot">-&gt;</span> <span class="dt">Natty</span> (<span class="dt">S</span> n)</a>
<a class="sourceLine" id="cb8-20" data-line-number="20"></a>
<a class="sourceLine" id="cb8-21" data-line-number="21"><span class="ot">getNatty ::</span> <span class="dt">The</span> <span class="dt">Nat</span> n <span class="ot">-&gt;</span> <span class="dt">Natty</span> n</a>
<a class="sourceLine" id="cb8-22" data-line-number="22">getNatty (<span class="dt">NatSing</span><span class="ot"> n ::</span> <span class="dt">The</span> <span class="dt">Nat</span> n) <span class="fu">=</span> <span class="kw">case</span> n <span class="kw">of</span></a>
<a class="sourceLine" id="cb8-23" data-line-number="23">  <span class="dv">0</span> <span class="ot">-&gt;</span> gcastWith (unsafeCoerce <span class="dt">Refl</span><span class="ot"> ::</span> n <span class="fu">:~:</span> <span class="dt">Z</span>) <span class="dt">ZZy</span></a>
<a class="sourceLine" id="cb8-24" data-line-number="24">  _ <span class="ot">-&gt;</span> gcastWith (unsafeCoerce <span class="dt">Refl</span><span class="ot"> ::</span> n <span class="fu">:~:</span> <span class="dt">S</span> m) (<span class="dt">SSy</span> (<span class="dt">NatSing</span> (pred n)))</a>
<a class="sourceLine" id="cb8-25" data-line-number="25"></a>
<a class="sourceLine" id="cb8-26" data-line-number="26">pattern <span class="dt">Zy</span><span class="ot"> ::</span> () <span class="ot">=&gt;</span> (n <span class="fu">~</span> <span class="dt">Z</span>) <span class="ot">=&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> n</a>
<a class="sourceLine" id="cb8-27" data-line-number="27">pattern <span class="dt">Zy</span> <span class="ot">&lt;-</span> (getNatty <span class="ot">-&gt;</span> <span class="dt">ZZy</span>) <span class="kw">where</span> <span class="dt">Zy</span> <span class="fu">=</span> <span class="dt">NatSing</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb8-28" data-line-number="28"></a>
<a class="sourceLine" id="cb8-29" data-line-number="29">pattern <span class="dt">Sy</span><span class="ot"> ::</span> () <span class="ot">=&gt;</span> (n <span class="fu">~</span> <span class="dt">S</span> m) <span class="ot">=&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> m <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> n</a>
<a class="sourceLine" id="cb8-30" data-line-number="30">pattern <span class="dt">Sy</span> x <span class="ot">&lt;-</span> (getNatty <span class="ot">-&gt;</span> <span class="dt">SSy</span> x) <span class="kw">where</span> <span class="dt">Sy</span> (<span class="dt">NatSing</span> x) <span class="fu">=</span> <span class="dt">NatSing</span> (succ x)</a>
<a class="sourceLine" id="cb8-31" data-line-number="31"><span class="ot">{-# COMPLETE Zy, Sy #-}</span></a>
<a class="sourceLine" id="cb8-32" data-line-number="32"></a>
<a class="sourceLine" id="cb8-33" data-line-number="33"><span class="kw">type</span> family (<span class="fu">+</span>) (<span class="ot">n ::</span> <span class="dt">Nat</span>) (<span class="ot">m ::</span> <span class="dt">Nat</span>)<span class="ot"> ::</span> <span class="dt">Nat</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-34" data-line-number="34">        <span class="dt">Z</span> <span class="fu">+</span> m <span class="fu">=</span> m</a>
<a class="sourceLine" id="cb8-35" data-line-number="35">        <span class="dt">S</span> n <span class="fu">+</span> m <span class="fu">=</span> <span class="dt">S</span> (n <span class="fu">+</span> m)</a>
<a class="sourceLine" id="cb8-36" data-line-number="36"></a>
<a class="sourceLine" id="cb8-37" data-line-number="37"><span class="co">-- | Efficient addition, with type-level proof.</span></a>
<a class="sourceLine" id="cb8-38" data-line-number="38"><span class="ot">add ::</span> <span class="dt">The</span> <span class="dt">Nat</span> n <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> m <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> (n <span class="fu">+</span> m)</a>
<a class="sourceLine" id="cb8-39" data-line-number="39">add <span class="fu">=</span> (<span class="ot">coerce ::</span> (<span class="dt">Natural</span> <span class="ot">-&gt;</span> <span class="dt">Natural</span> <span class="ot">-&gt;</span> <span class="dt">Natural</span>)</a>
<a class="sourceLine" id="cb8-40" data-line-number="40">              <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> n <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> m <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> (n <span class="fu">+</span> m)) (<span class="fu">+</span>)</a>
<a class="sourceLine" id="cb8-41" data-line-number="41"></a>
<a class="sourceLine" id="cb8-42" data-line-number="42"><span class="co">-- | Proof on efficient representation.</span></a>
<a class="sourceLine" id="cb8-43" data-line-number="43"><span class="ot">addZeroRight ::</span> <span class="dt">The</span> <span class="dt">Nat</span> n <span class="ot">-&gt;</span> n <span class="fu">+</span> <span class="dt">Z</span> <span class="fu">:~:</span> n</a>
<a class="sourceLine" id="cb8-44" data-line-number="44">addZeroRight <span class="dt">Zy</span> <span class="fu">=</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb8-45" data-line-number="45">addZeroRight (<span class="dt">Sy</span> n) <span class="fu">=</span> gcastWith (addZeroRight n) <span class="dt">Refl</span></a></code></pre></div>
<p>(unfortunately, incomplete pattern warnings don’t work here)</p>
<h1 id="hide-your-implementations">Hide Your Implementations</h1>
<p>So you’ve got a tree type:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Tip</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">    <span class="fu">|</span> <span class="dt">Bin</span> a (<span class="dt">Tree</span> a) (<span class="dt">Tree</span> a)</a></code></pre></div>
<p>And you’ve spent some time writing a (reasonably difficult) function on the tree:</p>
<details>
<p><summary> Complicated function on the tree </summary></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">showTree ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">showTree <span class="dt">Tip</span> <span class="fu">=</span> <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3">showTree (<span class="dt">Bin</span> x&#39; ls&#39; rs&#39;) <span class="fu">=</span> go <span class="dt">True</span> id xlen&#39; ls&#39;</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">                          <span class="fu">$</span> showString xshw&#39;</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">                          <span class="fu">$</span> endc ls&#39; rs&#39;</a>
<a class="sourceLine" id="cb10-6" data-line-number="6">                          <span class="fu">$</span> showChar <span class="ch">&#39;\n&#39;</span></a>
<a class="sourceLine" id="cb10-7" data-line-number="7">                          <span class="fu">$</span> go <span class="dt">False</span> id xlen&#39; rs&#39; <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb10-8" data-line-number="8">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-9" data-line-number="9">    xshw&#39; <span class="fu">=</span> show x&#39;</a>
<a class="sourceLine" id="cb10-10" data-line-number="10">    xlen&#39; <span class="fu">=</span> length xshw&#39;</a>
<a class="sourceLine" id="cb10-11" data-line-number="11"></a>
<a class="sourceLine" id="cb10-12" data-line-number="12">    go _ _ _ <span class="dt">Tip</span> <span class="fu">=</span> id</a>
<a class="sourceLine" id="cb10-13" data-line-number="13">    go up k i (<span class="dt">Bin</span> x ls rs) <span class="fu">=</span> branch <span class="dt">True</span> ls</a>
<a class="sourceLine" id="cb10-14" data-line-number="14">                            <span class="fu">.</span> k</a>
<a class="sourceLine" id="cb10-15" data-line-number="15">                            <span class="fu">.</span> pad i</a>
<a class="sourceLine" id="cb10-16" data-line-number="16">                            <span class="fu">.</span> showChar (bool <span class="ch">&#39;└&#39;</span> <span class="ch">&#39;┌&#39;</span> up)</a>
<a class="sourceLine" id="cb10-17" data-line-number="17">                            <span class="fu">.</span> showString xshw</a>
<a class="sourceLine" id="cb10-18" data-line-number="18">                            <span class="fu">.</span> endc ls rs</a>
<a class="sourceLine" id="cb10-19" data-line-number="19">                            <span class="fu">.</span> showChar <span class="ch">&#39;\n&#39;</span></a>
<a class="sourceLine" id="cb10-20" data-line-number="20">                            <span class="fu">.</span> branch <span class="dt">False</span> rs</a>
<a class="sourceLine" id="cb10-21" data-line-number="21">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-22" data-line-number="22">        xshw <span class="fu">=</span> show x</a>
<a class="sourceLine" id="cb10-23" data-line-number="23">        xlen <span class="fu">=</span> length xshw</a>
<a class="sourceLine" id="cb10-24" data-line-number="24">        branch d</a>
<a class="sourceLine" id="cb10-25" data-line-number="25">          <span class="fu">|</span> d <span class="fu">==</span> up <span class="fu">=</span> go d (k <span class="fu">.</span> pad i) (xlen <span class="fu">+</span> <span class="dv">1</span>) </a>
<a class="sourceLine" id="cb10-26" data-line-number="26">          <span class="fu">|</span> otherwise <span class="fu">=</span> go d (k <span class="fu">.</span> pad i <span class="fu">.</span> showChar <span class="ch">&#39;│&#39;</span>) xlen </a>
<a class="sourceLine" id="cb10-27" data-line-number="27"></a>
<a class="sourceLine" id="cb10-28" data-line-number="28">    endc <span class="dt">Tip</span>    <span class="dt">Tip</span>    <span class="fu">=</span> id</a>
<a class="sourceLine" id="cb10-29" data-line-number="29">    endc <span class="dt">Bin</span> {} <span class="dt">Tip</span>    <span class="fu">=</span> showChar <span class="ch">&#39;┘&#39;</span></a>
<a class="sourceLine" id="cb10-30" data-line-number="30">    endc <span class="dt">Tip</span>    <span class="dt">Bin</span> {} <span class="fu">=</span> showChar <span class="ch">&#39;┐&#39;</span></a>
<a class="sourceLine" id="cb10-31" data-line-number="31">    endc <span class="dt">Bin</span> {} <span class="dt">Bin</span> {} <span class="fu">=</span> showChar <span class="ch">&#39;┤&#39;</span></a>
<a class="sourceLine" id="cb10-32" data-line-number="32"></a>
<a class="sourceLine" id="cb10-33" data-line-number="33">    pad <span class="fu">=</span> (<span class="fu">++</span>) <span class="fu">.</span> flip replicate <span class="ch">&#39; &#39;</span></a></code></pre></div>
</details>
<p>But, for some reason or another, you need to add a field to your <code class="sourceCode haskell"><span class="dt">Bin</span></code> constructor, to store the size of the subtree (for instance). Does this function have to change? No! Simply change the tree definition as so:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Tip</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">    <span class="fu">|</span> <span class="dt">Bin&#39;</span> <span class="dt">Int</span> a (<span class="dt">Tree</span> a) (<span class="dt">Tree</span> a)</a>
<a class="sourceLine" id="cb11-4" data-line-number="4"></a>
<a class="sourceLine" id="cb11-5" data-line-number="5">pattern <span class="dt">Bin</span> x ls rs <span class="ot">&lt;-</span> <span class="dt">Bin&#39;</span> n x ls rs</a>
<a class="sourceLine" id="cb11-6" data-line-number="6"><span class="ot">{-# COMPLETE Tip, Bin #-}</span></a></code></pre></div>
<p>And all the old code works!</p>
<p>This gets to the core of pattern synonyms: it’s another tool which we can use to separate implementation from API.</p>
<h1 id="better-smart-constructors">Better Smart Constructors</h1>
<p>Say you’ve got a data type that has certain constraints on what values it can hold. You’re not writing a paper for ICFP, so expressing those constraints as a beautiful type isn’t required: you just want to only export the constructor and accessors, and write some tests to make sure that those functions always obey the constraints.</p>
<p>But once you do this you’ve lost something: pattern-matching. Let’s get it back with pattern synonyms!</p>
<p>As our simple example, our constraint is going to be “A list where the values are always ordered”:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">List</span> a <span class="fu">=</span> <span class="dt">List</span> {<span class="ot"> getList ::</span> [a] }</a>
<a class="sourceLine" id="cb12-2" data-line-number="2"></a>
<a class="sourceLine" id="cb12-3" data-line-number="3"><span class="ot">cons ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a</a>
<a class="sourceLine" id="cb12-4" data-line-number="4">cons x (<span class="dt">List</span> xs) <span class="fu">=</span> <span class="dt">List</span> (insert x xs)</a>
<a class="sourceLine" id="cb12-5" data-line-number="5"></a>
<a class="sourceLine" id="cb12-6" data-line-number="6"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:-</span></a>
<a class="sourceLine" id="cb12-7" data-line-number="7">pattern<span class="ot"> (:-) ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a</a>
<a class="sourceLine" id="cb12-8" data-line-number="8">pattern x <span class="fu">:-</span> xs <span class="ot">&lt;-</span> (<span class="dt">List</span> (x<span class="fu">:</span>xs))</a>
<a class="sourceLine" id="cb12-9" data-line-number="9">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-10" data-line-number="10">    x <span class="fu">:-</span> xs <span class="fu">=</span> cons x xs</a>
<a class="sourceLine" id="cb12-11" data-line-number="11"></a>
<a class="sourceLine" id="cb12-12" data-line-number="12">pattern <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">List</span> []</a>
<a class="sourceLine" id="cb12-13" data-line-number="13"><span class="ot">{-# COMPLETE Nil, (:-) #-}</span></a></code></pre></div>
]]></description>
    <pubDate>Thu, 12 Apr 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-04-12-pattern-synonyms.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Countdown</title>
    <link>https://doisinkidney.com/posts/2018-03-20-countdown.html</link>
    <description><![CDATA[<div class="info">
    Posted on March 20, 2018
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Algorithms.html">Algorithms</a>
    
</div>

<p>There’s a popular UK TV show called <a href="https://en.wikipedia.org/wiki/Countdown_(game_show)">Countdown</a> with a round where contestants have to get as close to some target number as possible by constructing an arithmetic expression from six random numbers.</p>
<p>You don’t have to use all of the numbers, and you’re allowed use four operations: addition, subtraction, multiplication, and division. Additionally, each stage of the calculation must result in a positive integer.</p>
<p>Here’s an example. Try get to the target 586:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mo>,</mo><mn>25</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>5</mn><mo>,</mo><mn>3</mn><mo>,</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">100,25,1,5,3,10</annotation></semantics></math></p>
<p>On the show, contestants get 30 seconds to think of an answer.</p>
<details>
<summary> Solution </summary> <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>25</mn><mo>*</mo><mn>3</mn><mo>+</mo><mn>10</mn><mo>+</mo><mn>100</mn><mo>*</mo><mn>5</mn><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">25 * 3 + 10 + 100 * 5 + 1</annotation></semantics></math>
</details>
<p>Solving it in Haskell was first explored in depth in <span class="citation" data-cites="hutton_countdown_2002">Hutton (<a href="#ref-hutton_countdown_2002">2002</a>)</span>. There, a basic “generate-and-test” implementation was provided and proven correct.</p>
<p>As an optimization problem, there are several factors which will influence the choice of algorithm:</p>
<ol type="1">
<li>There’s no obvious heuristic for constructing subexpressions in order to get to a final result. In other words, if we have <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>25</mn><mo>*</mo><mn>3</mn><mo>+</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">25 * 3 + 10</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>25</mn><mo>*</mo><mn>3</mn><mo>*</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">25 * 3 * 10</annotation></semantics></math>, there’s no easy way to tell which is “closer” to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>586</mn><annotation encoding="application/x-tex">586</annotation></semantics></math>. The latter is closer numerically, but the former is what we ended up using in the solution.</li>
<li>Because certain subexpressions aren’t allowed, we’ll be able to prune the search space as we go.</li>
<li>Ideally, we’d only want to calculate each possible subexpression once, making it a pretty standard dynamic programming problem.</li>
</ol>
<p>I’ll be focusing on the third point in this post, but we can add the second point in at the end. First, however, let’s write a naive implementation.</p>
<h2 id="generating-all-expressions">Generating all Expressions</h2>
<p>I can’t think of a simpler way to solve the problem than generate-and-test, so we’ll work from there. Testing is easy (<code class="sourceCode haskell">(target <span class="fu">==</span>) <span class="fu">.</span> eval</code>), so we’ll focus on generation. The core function we’ll use for this is usually called “unmerges”:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1">unmerges [x,y] <span class="fu">=</span> [([x],[y])]</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">unmerges (x<span class="fu">:</span>xs) <span class="fu">=</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">    ([x],xs) <span class="fu">:</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">    concat</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">        [ [(x<span class="fu">:</span>ys,zs),(ys,x<span class="fu">:</span>zs)]</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">        <span class="fu">|</span> (ys,zs) <span class="ot">&lt;-</span> unmerges xs ]</a>
<a class="sourceLine" id="cb1-7" data-line-number="7">unmerges _ <span class="fu">=</span> []</a></code></pre></div>
<p>It generates all possible 2-partitions of a list, ignoring order:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> unmerges <span class="st">&quot;abc&quot;</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">[(<span class="st">&quot;a&quot;</span>,<span class="st">&quot;bc&quot;</span>),(<span class="st">&quot;ab&quot;</span>,<span class="st">&quot;c&quot;</span>),(<span class="st">&quot;b&quot;</span>,<span class="st">&quot;ac&quot;</span>)]</a></code></pre></div>
<p>I haven’t looked much into how to optimize this function or make it nicer, as we’ll be swapping it out later.</p>
<p>Next, we need to make the recursive calls:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">allExprs ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a]) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">allExprs _ [x] <span class="fu">=</span> [x]</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">allExprs c xs <span class="fu">=</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">    [ e</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">    <span class="fu">|</span> (ys,zs) <span class="ot">&lt;-</span> unmerges xs</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">    , y <span class="ot">&lt;-</span> allExprs c ys</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">    , z <span class="ot">&lt;-</span> allExprs c zs</a>
<a class="sourceLine" id="cb3-8" data-line-number="8">    , e <span class="ot">&lt;-</span> c y z ]</a></code></pre></div>
<p>Finally, using the <a href="https://hackage.haskell.org/package/simple-reflect">simple-reflect</a> library, we can take a look at the output:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> allExprs (\x y <span class="ot">-&gt;</span> [x<span class="fu">+</span>y,x<span class="fu">*</span>y]) [<span class="dv">1</span>,<span class="dv">2</span>]<span class="ot"> ::</span> [<span class="dt">Expr</span>]</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">[<span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span>,<span class="dv">1</span> <span class="fu">*</span> <span class="dv">2</span>]</a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="fu">&gt;&gt;&gt;</span> allExprs (\x y <span class="ot">-&gt;</span> [x<span class="fu">+</span>y]) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]<span class="ot"> ::</span> [<span class="dt">Expr</span>]</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">[<span class="dv">1</span> <span class="fu">+</span> (<span class="dv">2</span> <span class="fu">+</span> <span class="dv">3</span>),<span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span> <span class="fu">+</span> <span class="dv">3</span>,<span class="dv">2</span> <span class="fu">+</span> (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">3</span>)]</a></code></pre></div>
<p>Even at this early stage, we can actually already write a rudimentary solution:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">countdown ::</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> [<span class="dt">Expr</span>]</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">countdown xs targ <span class="fu">=</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">    filter</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">        ((<span class="fu">==</span>) targ <span class="fu">.</span> toInteger)</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">        (allExprs</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">             (\x y <span class="ot">-&gt;</span> [x,y,x<span class="fu">+</span>y,x<span class="fu">*</span>y])</a>
<a class="sourceLine" id="cb5-7" data-line-number="7">             (map fromInteger xs))</a>
<a class="sourceLine" id="cb5-8" data-line-number="8"></a>
<a class="sourceLine" id="cb5-9" data-line-number="9"><span class="fu">&gt;&gt;&gt;</span> mapM_ print (countdown [<span class="dv">100</span>,<span class="dv">25</span>,<span class="dv">1</span>,<span class="dv">5</span>,<span class="dv">3</span>,<span class="dv">10</span>] <span class="dv">586</span>)</a>
<a class="sourceLine" id="cb5-10" data-line-number="10"><span class="dv">1</span> <span class="fu">+</span> (<span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> (<span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> <span class="dv">10</span>))</a>
<a class="sourceLine" id="cb5-11" data-line-number="11"><span class="dv">1</span> <span class="fu">+</span> (<span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> <span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb5-12" data-line-number="12"><span class="dv">1</span> <span class="fu">+</span> (<span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> (<span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> <span class="dv">10</span>))</a>
<a class="sourceLine" id="cb5-13" data-line-number="13"><span class="dv">1</span> <span class="fu">+</span> <span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> (<span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb5-14" data-line-number="14"><span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> (<span class="dv">1</span> <span class="fu">+</span> (<span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> <span class="dv">10</span>))</a>
<a class="sourceLine" id="cb5-15" data-line-number="15"><span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb5-16" data-line-number="16"><span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> (<span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">10</span>))</a>
<a class="sourceLine" id="cb5-17" data-line-number="17"><span class="dv">1</span> <span class="fu">+</span> (<span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> <span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span>) <span class="fu">+</span> <span class="dv">10</span></a>
<a class="sourceLine" id="cb5-18" data-line-number="18"><span class="dv">1</span> <span class="fu">+</span> <span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> <span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> <span class="dv">10</span></a>
<a class="sourceLine" id="cb5-19" data-line-number="19"><span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span>) <span class="fu">+</span> <span class="dv">10</span></a>
<a class="sourceLine" id="cb5-20" data-line-number="20"><span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> <span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb5-21" data-line-number="21"><span class="dv">1</span> <span class="fu">+</span> <span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> (<span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb5-22" data-line-number="22"><span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> (<span class="dv">1</span> <span class="fu">+</span> (<span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> <span class="dv">10</span>))</a>
<a class="sourceLine" id="cb5-23" data-line-number="23"><span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb5-24" data-line-number="24"><span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> (<span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">10</span>))</a></code></pre></div>
<p>As you can see from the output, there’s a lot of repetition. We’ll need to do some memoization to speed it up.</p>
<h2 id="pure-memoization">Pure Memoization</h2>
<p>The normal way most programmers think about “memoization” is something like this:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb6-1" data-line-number="1">memo_dict <span class="op">=</span> {<span class="dv">0</span>:<span class="dv">0</span>,<span class="dv">1</span>:<span class="dv">1</span>}</a>
<a class="sourceLine" id="cb6-2" data-line-number="2"></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="kw">def</span> fib(n):</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">    <span class="cf">if</span> n <span class="kw">in</span> memo_dict:</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">        <span class="cf">return</span> memo_dict[n]</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">    <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">        res <span class="op">=</span> fib(n<span class="dv">-1</span>) <span class="op">+</span> fib(n<span class="dv">-2</span>)</a>
<a class="sourceLine" id="cb6-8" data-line-number="8">        memo_dict[n] <span class="op">=</span> res</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">        <span class="cf">return</span> res</a></code></pre></div>
<p>In other words, it’s a fundamentally stateful process. We need to mutate some mapping when we haven’t seen the argument before.</p>
<p>Using laziness, though, we can emulate the same behavior purely. Instead of mutating the mapping on function calls, we fill the whole thing at the beginning, and then index into it. As long as the mapping is lazy, it’ll only evaluate the function calls when they’re needed. We could use lists as our mapping to the natural numbers:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1">fibs <span class="fu">=</span> <span class="dv">0</span> <span class="fu">:</span> <span class="dv">1</span> <span class="fu">:</span> map fib [<span class="dv">2</span><span class="fu">..</span>]</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">fib n <span class="fu">=</span> fibs <span class="fu">!!</span> (n<span class="fu">-</span><span class="dv">1</span>) <span class="fu">+</span> fibs <span class="fu">!!</span> (n<span class="fu">-</span><span class="dv">2</span>)</a></code></pre></div>
<p>The benefit here is that we avoid the extra work of redundant calls. However, we pay for the speedup in three ways:</p>
<ol class="example" type="1">
<li>Space: we need to take up memory space storing the cached solutions.</li>
<li>Indexing: while we no longer have to pay for the expensive recursive calls, we <em>do</em> now have to pay for indexing into the data structure. In this example, we’re paying linear time to index into the list.</li>
<li>Generality: the memoization is tied directly to the argument type to the function. We need to be able to use the argument to our memoized function as an index into some data structure. While a lot of argument types admit some type of indexing (whether they’re <code class="sourceCode haskell"><span class="dt">Hashable</span></code>, <code class="sourceCode haskell"><span class="dt">Ord</span></code>, etc.), some don’t, and we can’t memoize those using this technique.</li>
</ol>
<p>We’re going to look at a technique that allow us to somewhat mitigate 2 and 3 above, using something called a <em>nexus</em>.</p>
<h2 id="nexuses">Nexuses</h2>
<p>The standard technique of memoization is focused on the arguments to the function, creating a concrete representation of them in memory to map to the results. Using nexuses, as described in <span class="citation" data-cites="bird_functional_2003">Bird and Hinze (<a href="#ref-bird_functional_2003">2003</a>)</span>, we’ll instead focus on the function itself, creating a concrete representation of its call graph in memory. Here’s the call graph of Fibonacci:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">                                            ┌fib(<span class="dv">1</span>)<span class="fu">=</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">                                   ┌fib(<span class="dv">2</span>)<span class="fu">=</span>1┤</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">                                   │        └fib(<span class="dv">0</span>)<span class="fu">=</span><span class="dv">0</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">                          ┌fib(<span class="dv">3</span>)<span class="fu">=</span>2┤</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">                          │        └fib(<span class="dv">1</span>)<span class="fu">=</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">                 ┌fib(<span class="dv">4</span>)<span class="fu">=</span>3┤</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">                 │        │        ┌fib(<span class="dv">1</span>)<span class="fu">=</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8">                 │        └fib(<span class="dv">2</span>)<span class="fu">=</span>1┤</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">                 │                 └fib(<span class="dv">0</span>)<span class="fu">=</span><span class="dv">0</span></a>
<a class="sourceLine" id="cb8-10" data-line-number="10">        ┌fib(<span class="dv">5</span>)<span class="fu">=</span>5┤</a>
<a class="sourceLine" id="cb8-11" data-line-number="11">        │        │                 ┌fib(<span class="dv">1</span>)<span class="fu">=</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb8-12" data-line-number="12">        │        │        ┌fib(<span class="dv">2</span>)<span class="fu">=</span>1┤</a>
<a class="sourceLine" id="cb8-13" data-line-number="13">        │        │        │        └fib(<span class="dv">0</span>)<span class="fu">=</span><span class="dv">0</span></a>
<a class="sourceLine" id="cb8-14" data-line-number="14">        │        └fib(<span class="dv">3</span>)<span class="fu">=</span>2┤</a>
<a class="sourceLine" id="cb8-15" data-line-number="15">        │                 └fib(<span class="dv">1</span>)<span class="fu">=</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb8-16" data-line-number="16">fib(<span class="dv">6</span>)<span class="fu">=</span>8┤</a>
<a class="sourceLine" id="cb8-17" data-line-number="17">        │                          ┌fib(<span class="dv">1</span>)<span class="fu">=</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb8-18" data-line-number="18">        │                 ┌fib(<span class="dv">2</span>)<span class="fu">=</span>1┤</a>
<a class="sourceLine" id="cb8-19" data-line-number="19">        │                 │        └fib(<span class="dv">0</span>)<span class="fu">=</span><span class="dv">0</span></a>
<a class="sourceLine" id="cb8-20" data-line-number="20">        │        ┌fib(<span class="dv">3</span>)<span class="fu">=</span>2┤</a>
<a class="sourceLine" id="cb8-21" data-line-number="21">        │        │        └fib(<span class="dv">1</span>)<span class="fu">=</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb8-22" data-line-number="22">        └fib(<span class="dv">4</span>)<span class="fu">=</span>3┤</a>
<a class="sourceLine" id="cb8-23" data-line-number="23">                 │        ┌fib(<span class="dv">1</span>)<span class="fu">=</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb8-24" data-line-number="24">                 └fib(<span class="dv">2</span>)<span class="fu">=</span>1┤</a>
<a class="sourceLine" id="cb8-25" data-line-number="25">                          └fib(<span class="dv">0</span>)<span class="fu">=</span><span class="dv">0</span></a></code></pre></div>
<p>Turning <em>that</em> into a concrete datatype wouldn’t do us much good: it still has the massively redundant computations in it. However, we can recognize that entire subtrees are duplicates of each other: in those cases, instead of creating both subtrees, we could just create one and have each parent point to it<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1">        ┌fib(<span class="dv">5</span>)<span class="fu">=</span>5┬────────┬fib(<span class="dv">3</span>)<span class="fu">=</span>2┬────────┬fib(<span class="dv">1</span>)<span class="fu">=</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2">fib(<span class="dv">6</span>)<span class="fu">=</span>8┤        │        │        │        │</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">        └────────┴fib(<span class="dv">4</span>)<span class="fu">=</span>3┴────────┴fib(<span class="dv">2</span>)<span class="fu">=</span>1┴fib(<span class="dv">0</span>)<span class="fu">=</span><span class="dv">0</span></a></code></pre></div>
<p>This is a nexus. In Haskell, it’s not observably different from the other form, except that it takes up significantly less space. It’s also much quicker to construct.</p>
<p>If we use it to memoize <code class="sourceCode haskell">fib</code>, we’ll no longer be indexing on the argument: we’ll instead follow the relevant branch in the tree to the subcomputation, which is just chasing a pointer. It also means the argument doesn’t have to be constrained to any specific type. Here’s how you’d do it:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Leaf</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">    <span class="fu">|</span> <span class="dt">Node</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">    {<span class="ot"> val   ::</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5">    ,<span class="ot"> left  ::</span> <span class="dt">Tree</span></a>
<a class="sourceLine" id="cb12-6" data-line-number="6">    ,<span class="ot"> right ::</span> <span class="dt">Tree</span>}</a>
<a class="sourceLine" id="cb12-7" data-line-number="7"></a>
<a class="sourceLine" id="cb12-8" data-line-number="8"><span class="ot">fib ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb12-9" data-line-number="9">fib <span class="fu">=</span> val <span class="fu">.</span> go</a>
<a class="sourceLine" id="cb12-10" data-line-number="10">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-11" data-line-number="11">    go <span class="dv">0</span> <span class="fu">=</span> <span class="dt">Node</span> <span class="dv">0</span> <span class="dt">Leaf</span> <span class="dt">Leaf</span></a>
<a class="sourceLine" id="cb12-12" data-line-number="12">    go <span class="dv">1</span> <span class="fu">=</span> <span class="dt">Node</span> <span class="dv">1</span> (<span class="dt">Node</span> <span class="dv">0</span> <span class="dt">Leaf</span> <span class="dt">Leaf</span>) <span class="dt">Leaf</span></a>
<a class="sourceLine" id="cb12-13" data-line-number="13">    go n <span class="fu">=</span> node t (left t) <span class="kw">where</span> t <span class="fu">=</span> go (n<span class="fu">-</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb12-14" data-line-number="14">    node l r <span class="fu">=</span> <span class="dt">Node</span> (val l <span class="fu">+</span> val r) l r</a></code></pre></div>
<p>So this approach sounds amazing, right? No constraints on the argument type, no need to pay for indexing: why doesn’t everyone use it everywhere? The main reason is that figuring out a nexus for the call-graph is <em>hard</em>. In fact, finding an optimal one is NP-hard in general <span class="citation" data-cites="steffen_table_2006">(Steffen and Giegerich <a href="#ref-steffen_table_2006">2006</a>)</span>.</p>
<p>The second problem is that it’s difficult to abstract out. The standard technique of memoization relies on building a mapping from keys to values: about as bread-and-butter as it gets in programming. Even more, we already know how to say “values of this type can be used efficiently as keys in some mapping”: for Data.Map it’s <code class="sourceCode haskell"><span class="dt">Ord</span></code>, for Data.HashMap it’s <code class="sourceCode haskell"><span class="dt">Hashable</span></code>. All of this together means we can build a nice library for memoization which exports the two following functions:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="ot">memoHash ::</span> <span class="dt">Hashable</span> a <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b)</a>
<a class="sourceLine" id="cb13-2" data-line-number="2"><span class="ot">memoOrd ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b)</a></code></pre></div>
<p>Building a nexus, however, is not bread-and-butter. On top of that, it’s difficult to say something like “recursive functions of this structure can be constructed using a nexus”. What’s the typeclass for that? In comparison to the signatures above, the constraint will need to be on the <em>arrows</em>, not the <code class="sourceCode haskell">a</code>. Even talking about the structure of recursive functions is regarded as somewhat of an advanced subject: that said, the <a href="https://hackage.haskell.org/package/recursion-schemes">recursion-schemes</a> package allows us to do so, and even has facilities for constructing something <em>like</em> nexuses with histomorphisms <span class="citation" data-cites="tobin_time_2016">(Tobin <a href="#ref-tobin_time_2016">2016</a>)</span>. I’m still looking to see if there’s a library out there that <em>does</em> manage to abstract nexuses in an ergonomic way, so I’d love to hear if there was one (or if there’s some more generalized form which accomplishes the same).</p>
<h2 id="memoizing-countdown">Memoizing Countdown</h2>
<p>That’s enough preamble. The nexus we want to construct for countdown is <em>not</em> going to memoize as much as possible: in particular, we’re only going to memoize the shape of the trees, not the operators used. This will massively reduce the memory overhead, and still give a decent speedup <span class="citation" data-cites="bird_countdown:_2005">(Bird and Mu <a href="#ref-bird_countdown:_2005">2005</a>, 11 “building a skeleton tree first”)</span>.</p>
<p>With that in mind, the ideal nexus looks something like this:</p>
<p><img src="/images/boolean-lattice.svg" /></p>
<p>We can represent the tree in Haskell as a rose tree:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Node</span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3">    {<span class="ot"> root   ::</span> a</a>
<a class="sourceLine" id="cb14-4" data-line-number="4">    ,<span class="ot"> forest ::</span> <span class="dt">Forest</span> a</a>
<a class="sourceLine" id="cb14-5" data-line-number="5">    }</a>
<a class="sourceLine" id="cb14-6" data-line-number="6"></a>
<a class="sourceLine" id="cb14-7" data-line-number="7"><span class="kw">type</span> <span class="dt">Forest</span> a <span class="fu">=</span> [<span class="dt">Tree</span> a]</a></code></pre></div>
<p>Constructing the nexus itself isn’t actually the most interesting part of this solution: <em>consuming</em> it is. We need to be able to go from the structure above into a list that’s the equivalent of <code class="sourceCode haskell">unmerges</code>. Doing a breadth-first traversal of the diagram above (without the top element) will give us:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mi>c</mi><mo>,</mo><mi>a</mi><mi>b</mi><mi>d</mi><mo>,</mo><mi>a</mi><mi>c</mi><mi>d</mi><mo>,</mo><mi>b</mi><mi>c</mi><mi>d</mi><mo>,</mo><mi>a</mi><mi>b</mi><mo>,</mo><mi>a</mi><mi>c</mi><mo>,</mo><mi>b</mi><mi>c</mi><mo>,</mo><mi>a</mi><mi>d</mi><mo>,</mo><mi>b</mi><mi>d</mi><mo>,</mo><mi>c</mi><mi>d</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo>,</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">abc, abd, acd, bcd, ab, ac, bc, ad, bd, cd, a, b, c, d</annotation></semantics></math></p>
<p>If you split that list in half, and zip it with its reverse, you’ll get the output of <code class="sourceCode haskell">unmerges</code>.</p>
<p>However, the breadth-first traversal of the diagram isn’t the same thing as the breadth-first traversal of the rose tree. The latter will traverse <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mi>c</mi><mo>,</mo><mi>a</mi><mi>b</mi><mi>d</mi><mo>,</mo><mi>a</mi><mi>c</mi><mi>d</mi><mo>,</mo><mi>b</mi><mi>c</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">abc, abd, acd, bcd</annotation></semantics></math>, and then the children of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">abc</annotation></semantics></math> (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mo>,</mo><mi>a</mi><mi>c</mi><mo>,</mo><mi>b</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">ab,ac,bc</annotation></semantics></math>), and then the children of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">abd</annotation></semantics></math> (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mo>,</mo><mi>a</mi><mi>d</mi><mo>,</mo><mi>b</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">ab,ad,bd</annotation></semantics></math>): and here’s our problem. We traverse <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">ab</annotation></semantics></math> twice, because we can’t know that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">abc</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">abd</annotation></semantics></math> are pointing to the same value. What we have to do is first prune the tree, removing duplicates, and then perform a breadth-first traversal on that.</p>
<h3 id="pruning">Pruning</h3>
<p>Luckily, the duplicates follow a pattern, allowing us to remove them without having to do any equality checking. In each row, the first node has no duplicates in its children, the second’s first child is a duplicate, the third’s first and second children are duplicates, and so on. You should be able to see this in the diagram above. Adapting a little from the paper, we get an algorithm like this:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="ot">para ::</span> (a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">para f b <span class="fu">=</span> go</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-4" data-line-number="4">    go [] <span class="fu">=</span> b</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">    go (x<span class="fu">:</span>xs) <span class="fu">=</span> f x xs (go xs)</a>
<a class="sourceLine" id="cb15-6" data-line-number="6"></a>
<a class="sourceLine" id="cb15-7" data-line-number="7"><span class="ot">prune ::</span> <span class="dt">Forest</span> a <span class="ot">-&gt;</span> <span class="dt">Forest</span> a</a>
<a class="sourceLine" id="cb15-8" data-line-number="8">prune ts <span class="fu">=</span> pruneAt ts <span class="dv">0</span> </a>
<a class="sourceLine" id="cb15-9" data-line-number="9">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-10" data-line-number="10">    pruneAt <span class="fu">=</span> para f (const [])</a>
<a class="sourceLine" id="cb15-11" data-line-number="11">    f (<span class="dt">Node</span> x []) t _ _ <span class="fu">=</span> <span class="dt">Node</span> x [] <span class="fu">:</span> t</a>
<a class="sourceLine" id="cb15-12" data-line-number="12">    f (<span class="dt">Node</span> x us) _ a k <span class="fu">=</span></a>
<a class="sourceLine" id="cb15-13" data-line-number="13">        <span class="dt">Node</span> x (pruneAt (drop k us) k) <span class="fu">:</span> a (k <span class="fu">+</span> <span class="dv">1</span>)</a></code></pre></div>
<h3 id="breadth-first-traversal">Breadth-First Traversal</h3>
<p>I went through this in a <a href="/posts/2018-03-17-rose-trees-breadth-first.html">previous post</a>, so this is the end solution:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="ot">breadthFirst ::</span> <span class="dt">Forest</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">breadthFirst ts <span class="fu">=</span> foldr f b ts []</a>
<a class="sourceLine" id="cb16-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-4" data-line-number="4">    f (<span class="dt">Node</span> x xs) fw bw <span class="fu">=</span> x <span class="fu">:</span> fw (xs<span class="fu">:</span>bw)</a>
<a class="sourceLine" id="cb16-5" data-line-number="5"></a>
<a class="sourceLine" id="cb16-6" data-line-number="6">    b [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb16-7" data-line-number="7">    b q <span class="fu">=</span> foldl (foldr f) b q []</a></code></pre></div>
<p>With the appropriate incantations, this is actually the fastest implementation I’ve found.</p>
<h3 id="fusing">Fusing</h3>
<p>We can actually inline both of the above functions, fusing them together:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="ot">spanNexus ::</span> <span class="dt">Forest</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">spanNexus ts <span class="fu">=</span> foldr f (const b) ts <span class="dv">0</span> []</a>
<a class="sourceLine" id="cb17-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb17-4" data-line-number="4">    f (<span class="dt">Node</span> x us) fw k bw <span class="fu">=</span> x <span class="fu">:</span> fw (k<span class="fu">+</span><span class="dv">1</span>) ((drop k us, k) <span class="fu">:</span> bw)</a>
<a class="sourceLine" id="cb17-5" data-line-number="5"></a>
<a class="sourceLine" id="cb17-6" data-line-number="6">    b [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb17-7" data-line-number="7">    b qs <span class="fu">=</span> foldl (uncurry <span class="fu">.</span> foldr f <span class="fu">.</span> const) b qs []</a></code></pre></div>
<h3 id="halving-convolving-and-folding">Halving, Convolving, and Folding</h3>
<p>So, now we can go from the tree to our list of splits. Next step is to convert that list into the output of unmerges, by zipping the reverse of the first half with the second. We can use an algorithm described in <span class="citation" data-cites="danvy_there_2005">Danvy and Goldberg (<a href="#ref-danvy_there_2005">2005</a>)</span> to do the zipping and reversing:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1">fold xs n <span class="fu">=</span> go xs n (const [])</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3">    go xs <span class="dv">0</span>     k <span class="fu">=</span> k xs</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">    go (x<span class="fu">:</span>xs) n k <span class="fu">=</span> go xs (n<span class="fu">-</span><span class="dv">2</span>) (\(y<span class="fu">:</span>ys) <span class="ot">-&gt;</span> (x,y) <span class="fu">:</span> k ys)</a></code></pre></div>
<p>And we can inline the function which collapses those results into one:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1">fold xs n <span class="fu">=</span> go xs n (const [])</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-3" data-line-number="3">    go <span class="dv">0</span> xss k <span class="fu">=</span> k xss</a>
<a class="sourceLine" id="cb19-4" data-line-number="4">    go n (xs<span class="fu">:</span>xss) k <span class="fu">=</span></a>
<a class="sourceLine" id="cb19-5" data-line-number="5">        go (n<span class="fu">-</span><span class="dv">2</span>) xss (\(ys<span class="fu">:</span>yss) <span class="ot">-&gt;</span> [ z</a>
<a class="sourceLine" id="cb19-6" data-line-number="6">                                      <span class="fu">|</span> x <span class="ot">&lt;-</span> xs</a>
<a class="sourceLine" id="cb19-7" data-line-number="7">                                      , y <span class="ot">&lt;-</span> ys</a>
<a class="sourceLine" id="cb19-8" data-line-number="8">                                      , z <span class="ot">&lt;-</span> cmb x y</a>
<a class="sourceLine" id="cb19-9" data-line-number="9">                                      ] <span class="fu">++</span> k yss)</a></code></pre></div>
<p>And that’s all we need!</p>
<details>
<p><summary> Full Code </summary></p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Tree</span> <span class="kw">as</span> <span class="dt">Rose</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2"></a>
<a class="sourceLine" id="cb20-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb20-4" data-line-number="4">    <span class="fu">=</span> <span class="dt">Leaf</span> <span class="dt">Int</span> a</a>
<a class="sourceLine" id="cb20-5" data-line-number="5">    <span class="fu">|</span> <span class="dt">Node</span> [<span class="dt">Tree</span> a]</a>
<a class="sourceLine" id="cb20-6" data-line-number="6">    <span class="kw">deriving</span> (<span class="dt">Show</span>,<span class="dt">Eq</span>,<span class="dt">Functor</span>)</a>
<a class="sourceLine" id="cb20-7" data-line-number="7">    </a>
<a class="sourceLine" id="cb20-8" data-line-number="8"><span class="ot">enumerateTrees ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a]) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb20-9" data-line-number="9">enumerateTrees _ [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb20-10" data-line-number="10">enumerateTrees cmb xs <span class="fu">=</span> (extract <span class="fu">.</span> steps <span class="fu">.</span> initial) xs</a>
<a class="sourceLine" id="cb20-11" data-line-number="11">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-12" data-line-number="12">    step <span class="fu">=</span> map nodes <span class="fu">.</span> group</a>
<a class="sourceLine" id="cb20-13" data-line-number="13"></a>
<a class="sourceLine" id="cb20-14" data-line-number="14">    steps [x] <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb20-15" data-line-number="15">    steps xs <span class="fu">=</span> steps (step xs)</a>
<a class="sourceLine" id="cb20-16" data-line-number="16"></a>
<a class="sourceLine" id="cb20-17" data-line-number="17">    initial <span class="fu">=</span> map (<span class="dt">Leaf</span> <span class="dv">1</span> <span class="fu">.</span> flip <span class="dt">Rose.Node</span> [] <span class="fu">.</span> pure)</a>
<a class="sourceLine" id="cb20-18" data-line-number="18"></a>
<a class="sourceLine" id="cb20-19" data-line-number="19">    extract (<span class="dt">Leaf</span> _ x) <span class="fu">=</span> Rose.rootLabel x</a>
<a class="sourceLine" id="cb20-20" data-line-number="20">    extract (<span class="dt">Node</span> [x]) <span class="fu">=</span> extract x</a>
<a class="sourceLine" id="cb20-21" data-line-number="21"></a>
<a class="sourceLine" id="cb20-22" data-line-number="22">    group [_] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb20-23" data-line-number="23">    group (<span class="dt">Leaf</span> _ x<span class="fu">:</span>vs) <span class="fu">=</span> <span class="dt">Node</span> [<span class="dt">Leaf</span> <span class="dv">2</span> [x, y] <span class="fu">|</span> <span class="dt">Leaf</span> _ y <span class="ot">&lt;-</span> vs] <span class="fu">:</span> group vs</a>
<a class="sourceLine" id="cb20-24" data-line-number="24">    group (<span class="dt">Node</span>   u<span class="fu">:</span>vs) <span class="fu">=</span> <span class="dt">Node</span> (zipWith comb (group u) vs) <span class="fu">:</span> group vs</a>
<a class="sourceLine" id="cb20-25" data-line-number="25"></a>
<a class="sourceLine" id="cb20-26" data-line-number="26">    comb (<span class="dt">Leaf</span> n xs) (<span class="dt">Leaf</span> _ x) <span class="fu">=</span> <span class="dt">Leaf</span> (n <span class="fu">+</span> <span class="dv">1</span>) (xs <span class="fu">++</span> [x])</a>
<a class="sourceLine" id="cb20-27" data-line-number="27">    comb (<span class="dt">Node</span> us) (<span class="dt">Node</span> vs) <span class="fu">=</span> <span class="dt">Node</span> (zipWith comb us vs)</a>
<a class="sourceLine" id="cb20-28" data-line-number="28"></a>
<a class="sourceLine" id="cb20-29" data-line-number="29">    forest ts <span class="fu">=</span> foldr f (const b) ts <span class="dv">0</span> []</a>
<a class="sourceLine" id="cb20-30" data-line-number="30">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-31" data-line-number="31">        f (<span class="dt">Rose.Node</span> x []) fw <span class="fu">!</span>k bw <span class="fu">=</span> x <span class="fu">:</span> fw (k <span class="fu">+</span> <span class="dv">1</span>) bw</a>
<a class="sourceLine" id="cb20-32" data-line-number="32">        f (<span class="dt">Rose.Node</span> x us) fw <span class="fu">!</span>k bw <span class="fu">=</span> x <span class="fu">:</span> fw (k <span class="fu">+</span> <span class="dv">1</span>) ((drop k us, k) <span class="fu">:</span> bw)</a>
<a class="sourceLine" id="cb20-33" data-line-number="33"></a>
<a class="sourceLine" id="cb20-34" data-line-number="34">        b [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb20-35" data-line-number="35">        b qs <span class="fu">=</span> foldl (uncurry <span class="fu">.</span> foldr f <span class="fu">.</span> const) b qs []</a>
<a class="sourceLine" id="cb20-36" data-line-number="36"></a>
<a class="sourceLine" id="cb20-37" data-line-number="37">    nodes (<span class="dt">Leaf</span> n x) <span class="fu">=</span> <span class="dt">Leaf</span> <span class="dv">1</span> (node n x)</a>
<a class="sourceLine" id="cb20-38" data-line-number="38">    nodes (<span class="dt">Node</span> xs) <span class="fu">=</span> <span class="dt">Node</span> (map nodes xs)</a>
<a class="sourceLine" id="cb20-39" data-line-number="39"></a>
<a class="sourceLine" id="cb20-40" data-line-number="40">    node n ts <span class="fu">=</span> <span class="dt">Rose.Node</span> (walk (<span class="dv">2</span> <span class="fu">^</span> n <span class="fu">-</span> <span class="dv">2</span>) (forest ts) (const [])) ts</a>
<a class="sourceLine" id="cb20-41" data-line-number="41">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-42" data-line-number="42">        walk <span class="dv">0</span> xss k <span class="fu">=</span> k xss</a>
<a class="sourceLine" id="cb20-43" data-line-number="43">        walk n (xs<span class="fu">:</span>xss) k <span class="fu">=</span></a>
<a class="sourceLine" id="cb20-44" data-line-number="44">            walk (n<span class="fu">-</span><span class="dv">2</span>) xss (\(ys<span class="fu">:</span>yss) <span class="ot">-&gt;</span> [ z</a>
<a class="sourceLine" id="cb20-45" data-line-number="45">                                         <span class="fu">|</span> x <span class="ot">&lt;-</span> xs</a>
<a class="sourceLine" id="cb20-46" data-line-number="46">                                         , y <span class="ot">&lt;-</span> ys</a>
<a class="sourceLine" id="cb20-47" data-line-number="47">                                         , z <span class="ot">&lt;-</span> cmb x y</a>
<a class="sourceLine" id="cb20-48" data-line-number="48">                                         ] <span class="fu">++</span> k yss)</a></code></pre></div>
</details>
<h2 id="using-it-for-countdown">Using it for Countdown</h2>
<p>The first thing to do for the Countdown solution is to figure out a representation for expressions. The one from simple-reflect is perfect for displaying the result, but we should memoize its calculation.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Memoed</span></a>
<a class="sourceLine" id="cb21-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">Memoed</span></a>
<a class="sourceLine" id="cb21-3" data-line-number="3">  {<span class="ot"> expr   ::</span> <span class="dt">Expr</span></a>
<a class="sourceLine" id="cb21-4" data-line-number="4">  ,<span class="ot"> result ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb21-5" data-line-number="5">  }</a></code></pre></div>
<p>Then, some helpers for building:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Op</span> <span class="fu">=</span> <span class="dt">Add</span> <span class="fu">|</span> <span class="dt">Dif</span> <span class="fu">|</span> <span class="dt">Mul</span> <span class="fu">|</span> <span class="dt">Div</span></a>
<a class="sourceLine" id="cb22-2" data-line-number="2"></a>
<a class="sourceLine" id="cb22-3" data-line-number="3">binOp f g x y <span class="fu">=</span> <span class="dt">Memoed</span> ((f <span class="ot">`on`</span> expr) x y) ((g <span class="ot">`on`</span> result) x y)</a>
<a class="sourceLine" id="cb22-4" data-line-number="4"></a>
<a class="sourceLine" id="cb22-5" data-line-number="5"><span class="ot">apply ::</span> <span class="dt">Op</span> <span class="ot">-&gt;</span> <span class="dt">Memoed</span> <span class="ot">-&gt;</span> <span class="dt">Memoed</span> <span class="ot">-&gt;</span> <span class="dt">Memoed</span></a>
<a class="sourceLine" id="cb22-6" data-line-number="6">apply <span class="dt">Add</span> x y <span class="fu">=</span> binOp (<span class="fu">+</span>) (<span class="fu">+</span>) x y</a>
<a class="sourceLine" id="cb22-7" data-line-number="7">apply <span class="dt">Dif</span> x y</a>
<a class="sourceLine" id="cb22-8" data-line-number="8">  <span class="fu">|</span> result y <span class="fu">&lt;</span> result x <span class="fu">=</span> binOp (<span class="fu">-</span>) (<span class="fu">-</span>) x y</a>
<a class="sourceLine" id="cb22-9" data-line-number="9">  <span class="fu">|</span> otherwise <span class="fu">=</span> binOp (<span class="fu">-</span>) (<span class="fu">-</span>) y x</a>
<a class="sourceLine" id="cb22-10" data-line-number="10">apply <span class="dt">Mul</span> x y <span class="fu">=</span> binOp (<span class="fu">*</span>) (<span class="fu">*</span>) x y</a>
<a class="sourceLine" id="cb22-11" data-line-number="11">apply <span class="dt">Div</span> x y <span class="fu">=</span> binOp div div x y</a></code></pre></div>
<p>Finally, the full algorithm:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="ot">enumerateExprs ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Memoed</span>]</a>
<a class="sourceLine" id="cb23-2" data-line-number="2">enumerateExprs <span class="fu">=</span> enumerateTrees cmb <span class="fu">.</span> map (\x <span class="ot">-&gt;</span> <span class="dt">Memoed</span> (fromIntegral x) x)</a>
<a class="sourceLine" id="cb23-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-4" data-line-number="4">    cmb x y <span class="fu">=</span></a>
<a class="sourceLine" id="cb23-5" data-line-number="5">        nubs <span class="fu">$</span></a>
<a class="sourceLine" id="cb23-6" data-line-number="6">        x <span class="fu">:</span></a>
<a class="sourceLine" id="cb23-7" data-line-number="7">        y <span class="fu">:</span></a>
<a class="sourceLine" id="cb23-8" data-line-number="8">        [ apply op x y</a>
<a class="sourceLine" id="cb23-9" data-line-number="9">        <span class="fu">|</span> op <span class="ot">&lt;-</span> [<span class="dt">Add</span>, <span class="dt">Dif</span>, <span class="dt">Mul</span>, <span class="dt">Div</span>]</a>
<a class="sourceLine" id="cb23-10" data-line-number="10">        , legal op (result x) (result y) ]</a>
<a class="sourceLine" id="cb23-11" data-line-number="11">    legal <span class="dt">Add</span> _ _ <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb23-12" data-line-number="12">    legal <span class="dt">Dif</span> x y <span class="fu">=</span> x <span class="fu">/=</span> y</a>
<a class="sourceLine" id="cb23-13" data-line-number="13">    legal <span class="dt">Mul</span> _ _ <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb23-14" data-line-number="14">    legal <span class="dt">Div</span> x y <span class="fu">=</span> x <span class="ot">`mod`</span> y <span class="fu">==</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb23-15" data-line-number="15">    nubs xs <span class="fu">=</span> foldr f (const []) xs IntSet.empty</a>
<a class="sourceLine" id="cb23-16" data-line-number="16">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-17" data-line-number="17">        f e a s</a>
<a class="sourceLine" id="cb23-18" data-line-number="18">          <span class="fu">|</span> IntSet.member (result e) s <span class="fu">=</span> a s</a>
<a class="sourceLine" id="cb23-19" data-line-number="19">          <span class="fu">|</span> otherwise <span class="fu">=</span> e <span class="fu">:</span> a (IntSet.insert (result e) s)</a>
<a class="sourceLine" id="cb23-20" data-line-number="20"></a>
<a class="sourceLine" id="cb23-21" data-line-number="21"><span class="ot">countdown ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Expr</span>]</a>
<a class="sourceLine" id="cb23-22" data-line-number="22">countdown targ <span class="fu">=</span> map expr <span class="fu">.</span> filter ((<span class="fu">==</span>) targ <span class="fu">.</span> result) <span class="fu">.</span> enumerateExprs</a>
<a class="sourceLine" id="cb23-23" data-line-number="23"></a>
<a class="sourceLine" id="cb23-24" data-line-number="24"><span class="fu">&gt;&gt;&gt;</span> (mapM_ print <span class="fu">.</span> reduction <span class="fu">.</span> head) (countdown <span class="dv">586</span> [<span class="dv">100</span>,<span class="dv">25</span>,<span class="dv">1</span>,<span class="dv">5</span>,<span class="dv">3</span>,<span class="dv">10</span>])</a>
<a class="sourceLine" id="cb23-25" data-line-number="25"><span class="dv">25</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">+</span> <span class="dv">1</span> <span class="fu">+</span> (<span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb23-26" data-line-number="26"><span class="dv">75</span> <span class="fu">+</span> <span class="dv">1</span> <span class="fu">+</span> (<span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb23-27" data-line-number="27"><span class="dv">76</span> <span class="fu">+</span> (<span class="dv">100</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">+</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb23-28" data-line-number="28"><span class="dv">76</span> <span class="fu">+</span> (<span class="dv">500</span> <span class="fu">+</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb23-29" data-line-number="29"><span class="dv">76</span> <span class="fu">+</span> <span class="dv">510</span></a>
<a class="sourceLine" id="cb23-30" data-line-number="30"><span class="dv">586</span></a></code></pre></div>
<p>There are some optimizations going on here, taken mainly from <span class="citation" data-cites="bird_countdown:_2005">Bird and Mu (<a href="#ref-bird_countdown:_2005">2005</a>)</span>:</p>
<ol type="1">
<li>We filter out illegal operations, as described originally.</li>
<li>We filter out any expressions that have the same value.</li>
</ol>
<h2 id="testing-the-implementation">Testing the Implementation</h2>
<p>So we’ve followed the paper, written the code: time to test. The specification of the function is relatively simple: calculate all applications of the commutative operator to some input, <em>without</em> recalculating subtrees.</p>
<p>We’ll need a free structure for the “commutative operator”:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb24-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Leaf</span> a</a>
<a class="sourceLine" id="cb24-3" data-line-number="3">    <span class="fu">|</span> <span class="dt">Tree</span> a <span class="fu">:^:</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb24-4" data-line-number="4">    <span class="kw">deriving</span> (<span class="dt">Foldable</span>,<span class="dt">Eq</span>,<span class="dt">Ord</span>,<span class="dt">Show</span>)</a></code></pre></div>
<p>Here’s the problem: it’s not commutative! We can remedy it by only exporting a constructor that creates the tree in a commutative way, and we can make it a pattern synonym so it looks normal:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="ot">{-# LANGUAGE DeriveFoldable  #-}</span></a>
<a class="sourceLine" id="cb25-2" data-line-number="2"><span class="ot">{-# LANGUAGE PatternSynonyms #-}</span></a>
<a class="sourceLine" id="cb25-3" data-line-number="3"></a>
<a class="sourceLine" id="cb25-4" data-line-number="4"><span class="kw">module</span> <span class="dt">Commutative</span></a>
<a class="sourceLine" id="cb25-5" data-line-number="5">  (<span class="dt">Tree</span>(<span class="dt">Leaf</span>)</a>
<a class="sourceLine" id="cb25-6" data-line-number="6">  ,pattern (<span class="fu">:*:</span>))</a>
<a class="sourceLine" id="cb25-7" data-line-number="7">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-8" data-line-number="8"></a>
<a class="sourceLine" id="cb25-9" data-line-number="9"><span class="kw">data</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb25-10" data-line-number="10">    <span class="fu">=</span> <span class="dt">Leaf</span> a</a>
<a class="sourceLine" id="cb25-11" data-line-number="11">    <span class="fu">|</span> <span class="dt">Tree</span> a <span class="fu">:^:</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb25-12" data-line-number="12">    <span class="kw">deriving</span> (<span class="dt">Eq</span>,<span class="dt">Ord</span>,<span class="dt">Show</span>,<span class="dt">Foldable</span>)</a>
<a class="sourceLine" id="cb25-13" data-line-number="13"></a>
<a class="sourceLine" id="cb25-14" data-line-number="14">pattern<span class="ot"> (:*:) ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb25-15" data-line-number="15">pattern xs <span class="fu">:*:</span> ys <span class="ot">&lt;-</span> xs <span class="fu">:^:</span> ys <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-16" data-line-number="16">  xs <span class="fu">:*:</span> ys</a>
<a class="sourceLine" id="cb25-17" data-line-number="17">      <span class="fu">|</span> xs <span class="fu">&lt;=</span> ys <span class="fu">=</span> xs <span class="fu">:^:</span> ys</a>
<a class="sourceLine" id="cb25-18" data-line-number="18">      <span class="fu">|</span> otherwise <span class="fu">=</span> ys <span class="fu">:^:</span> xs</a>
<a class="sourceLine" id="cb25-19" data-line-number="19"></a>
<a class="sourceLine" id="cb25-20" data-line-number="20"><span class="ot">{-# COMPLETE Leaf, (:*:) #-}</span></a></code></pre></div>
<p>Now we need to check if all applications are actually tested. First, to generate all trees:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="ot">allTrees ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Set</span> (<span class="dt">Tree</span> a)</a>
<a class="sourceLine" id="cb26-2" data-line-number="2">allTrees [x] <span class="fu">=</span> Set.singleton (<span class="dt">Leaf</span> x)</a>
<a class="sourceLine" id="cb26-3" data-line-number="3">allTrees xs <span class="fu">=</span> Set.unions (map (uncurry f) (unmerges xs))</a>
<a class="sourceLine" id="cb26-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb26-5" data-line-number="5">    f ls rs <span class="fu">=</span> Set.fromList ((liftA2 (<span class="fu">:*:</span>) <span class="ot">`on`</span> (Set.toList <span class="fu">.</span> allTrees)) ls rs)</a>
<a class="sourceLine" id="cb26-6" data-line-number="6"></a>
<a class="sourceLine" id="cb26-7" data-line-number="7"><span class="ot">allSubTrees ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Set</span> (<span class="dt">Tree</span> a)</a>
<a class="sourceLine" id="cb26-8" data-line-number="8">allSubTrees [x] <span class="fu">=</span> Set.singleton (<span class="dt">Leaf</span> x)</a>
<a class="sourceLine" id="cb26-9" data-line-number="9">allSubTrees xs <span class="fu">=</span></a>
<a class="sourceLine" id="cb26-10" data-line-number="10">    Set.unions (map (uncurry f <span class="fu">.</span> (allSubTrees <span class="fu">***</span> allSubTrees)) (unmerges xs))</a>
<a class="sourceLine" id="cb26-11" data-line-number="11">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb26-12" data-line-number="12">    f ls rs <span class="fu">=</span></a>
<a class="sourceLine" id="cb26-13" data-line-number="13">        Set.unions</a>
<a class="sourceLine" id="cb26-14" data-line-number="14">            [ls, rs, Set.fromList ((liftA2 (<span class="fu">:*:</span>) <span class="ot">`on`</span> Set.toList) ls rs)]</a></code></pre></div>
<p>Then, to test:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="ot">prop_exhaustiveSearch ::</span> <span class="dt">Natural</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb27-2" data-line-number="2">prop_exhaustiveSearch n <span class="fu">=</span></a>
<a class="sourceLine" id="cb27-3" data-line-number="3">         <span class="kw">let</span> src <span class="fu">=</span> [<span class="dv">0</span> <span class="fu">..</span> fromIntegral n]</a>
<a class="sourceLine" id="cb27-4" data-line-number="4">             expect <span class="fu">=</span> allSubTrees src</a>
<a class="sourceLine" id="cb27-5" data-line-number="5">             actual <span class="fu">=</span></a>
<a class="sourceLine" id="cb27-6" data-line-number="6">                 Set.fromList</a>
<a class="sourceLine" id="cb27-7" data-line-number="7">                     (enumerateTrees</a>
<a class="sourceLine" id="cb27-8" data-line-number="8">                          (\xs ys <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb27-9" data-line-number="9">                                [xs, ys, xs <span class="fu">:*:</span> ys])</a>
<a class="sourceLine" id="cb27-10" data-line-number="10">                          (map <span class="dt">Leaf</span> src))</a>
<a class="sourceLine" id="cb27-11" data-line-number="11">         <span class="kw">in</span> expect <span class="fu">==</span> actual</a>
<a class="sourceLine" id="cb27-12" data-line-number="12"></a>
<a class="sourceLine" id="cb27-13" data-line-number="13"><span class="ot">prop_exhaustiveSearchFull ::</span> <span class="dt">Natural</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb27-14" data-line-number="14">prop_exhaustiveSearchFull n <span class="fu">=</span></a>
<a class="sourceLine" id="cb27-15" data-line-number="15">         <span class="kw">let</span> src <span class="fu">=</span> [<span class="dv">0</span> <span class="fu">..</span> fromIntegral n]</a>
<a class="sourceLine" id="cb27-16" data-line-number="16">             expect <span class="fu">=</span> Map.fromSet (const <span class="dv">1</span>) (allTrees src)</a>
<a class="sourceLine" id="cb27-17" data-line-number="17">             actual <span class="fu">=</span></a>
<a class="sourceLine" id="cb27-18" data-line-number="18">                 freqs</a>
<a class="sourceLine" id="cb27-19" data-line-number="19">                     (enumerateTrees</a>
<a class="sourceLine" id="cb27-20" data-line-number="20">                          (\xs ys <span class="ot">-&gt;</span> [xs <span class="fu">:*:</span> ys])</a>
<a class="sourceLine" id="cb27-21" data-line-number="21">                          (map <span class="dt">Leaf</span> src))</a>
<a class="sourceLine" id="cb27-22" data-line-number="22">         <span class="kw">in</span> expect <span class="fu">==</span> actual</a></code></pre></div>
<p>Testing for repeated calls is more tricky. Remember, the memoization is supposed to be unobservable: in order to see it, we’re going to have to use some unsafe operations.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1">traceSubsequences</a>
<a class="sourceLine" id="cb28-2" data-line-number="2"><span class="ot">    ::</span> ((<span class="dt">Tree</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Tree</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Tree</span> <span class="dt">Int</span>]) <span class="ot">-&gt;</span> [<span class="dt">Tree</span> <span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Tree</span> <span class="dt">Int</span>])</a>
<a class="sourceLine" id="cb28-3" data-line-number="3">    <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb28-4" data-line-number="4">    <span class="ot">-&gt;</span> (<span class="dt">Map</span> (<span class="dt">Tree</span> <span class="dt">Int</span>) <span class="dt">Int</span>, [<span class="dt">Tree</span> <span class="dt">Int</span>])</a>
<a class="sourceLine" id="cb28-5" data-line-number="5">traceSubsequences enm ints <span class="fu">=</span></a>
<a class="sourceLine" id="cb28-6" data-line-number="6">    runST <span class="fu">$</span></a>
<a class="sourceLine" id="cb28-7" data-line-number="7">    <span class="kw">do</span> ref <span class="ot">&lt;-</span> newSTRef Map.empty</a>
<a class="sourceLine" id="cb28-8" data-line-number="8">       <span class="kw">let</span> res <span class="fu">=</span> enm (combine ref) (map (conv ref) ints)</a>
<a class="sourceLine" id="cb28-9" data-line-number="9">       traverse_ (foldr seq (pure ())) res</a>
<a class="sourceLine" id="cb28-10" data-line-number="10">       intm <span class="ot">&lt;-</span> readSTRef ref</a>
<a class="sourceLine" id="cb28-11" data-line-number="11">       pure (intm, res)</a>
<a class="sourceLine" id="cb28-12" data-line-number="12">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb28-13" data-line-number="13">    combine ref xs ys <span class="fu">=</span> unsafeRunST ([xs <span class="fu">:*:</span> ys] <span class="fu">&lt;$</span> modifySTRef&#39; ref (incr (xs <span class="fu">:*:</span> ys)))</a>
<a class="sourceLine" id="cb28-14" data-line-number="14">    <span class="ot">{-# NOINLINE combine #-}</span></a>
<a class="sourceLine" id="cb28-15" data-line-number="15">    conv ref x <span class="fu">=</span> unsafeRunST (<span class="dt">Leaf</span> x <span class="fu">&lt;$</span> modifySTRef&#39; ref (incr (<span class="dt">Leaf</span> x)))</a>
<a class="sourceLine" id="cb28-16" data-line-number="16">    <span class="ot">{-# NOINLINE conv #-}</span></a>
<a class="sourceLine" id="cb28-17" data-line-number="17">    unsafeRunST cmp <span class="fu">=</span> unsafePerformIO (unsafeSTToIO cmp)</a>
<a class="sourceLine" id="cb28-18" data-line-number="18"></a>
<a class="sourceLine" id="cb28-19" data-line-number="19"><span class="ot">prop_noRepeatedCalls ::</span> <span class="dt">Property</span></a>
<a class="sourceLine" id="cb28-20" data-line-number="20">prop_noRepeatedCalls <span class="fu">=</span></a>
<a class="sourceLine" id="cb28-21" data-line-number="21">    property <span class="fu">$</span> sized <span class="fu">$</span></a>
<a class="sourceLine" id="cb28-22" data-line-number="22">    \n <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb28-23" data-line-number="23">         pure <span class="fu">$</span></a>
<a class="sourceLine" id="cb28-24" data-line-number="24">         <span class="kw">let</span> src <span class="fu">=</span> [<span class="dv">0</span> <span class="fu">..</span> n]</a>
<a class="sourceLine" id="cb28-25" data-line-number="25">             (tint,tres) <span class="fu">=</span> fmap freqs (traceSubsequences enumerateTrees src)</a>
<a class="sourceLine" id="cb28-26" data-line-number="26">             (fint,fres) <span class="fu">=</span> fmap freqs (traceSubsequences dummyEnumerate src)</a>
<a class="sourceLine" id="cb28-27" data-line-number="27">         <span class="kw">in</span> counterexample</a>
<a class="sourceLine" id="cb28-28" data-line-number="28">                (mapCompare (freqs (allSubTrees src)) tint)</a>
<a class="sourceLine" id="cb28-29" data-line-number="29">                (all (<span class="dv">1</span> <span class="fu">==</span>) tint) <span class="fu">.&amp;&amp;.</span></a>
<a class="sourceLine" id="cb28-30" data-line-number="30">            counterexample (mapCompare tres fres) (tres <span class="fu">==</span> fres) <span class="fu">.&amp;&amp;.</span></a>
<a class="sourceLine" id="cb28-31" data-line-number="31">            (n <span class="fu">&gt;</span> <span class="dv">2</span> <span class="fu">==&gt;</span> tint <span class="fu">/=</span> fint)</a></code></pre></div>
<p>Here, <code class="sourceCode haskell">dummyEnumerate</code> is some method which performs the same task, but <em>doesn’t</em> construct a nexus, so we can ensure that our tests really do catch faulty implementations.</p>
<div id="refs" class="references">
<div id="ref-bird_functional_2003">
<p>Bird, Richard, and Ralf Hinze. 2003. “Functional Pearl Trouble Shared is Trouble Halved.” In <em>Proceedings of the 2003 ACM SIGPLAN Workshop on Haskell</em>, 1–6. Haskell ’03. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/871895.871896">10.1145/871895.871896</a>. <a href="http://doi.acm.org/10.1145/871895.871896" class="uri">http://doi.acm.org/10.1145/871895.871896</a>.</p>
</div>
<div id="ref-bird_countdown:_2005">
<p>Bird, Richard, and Shin-Cheng Mu. 2005. “Countdown: A case study in origami programming.” <em>Journal of Functional Programming</em> 15 (05) (August): 679. doi:<a href="https://doi.org/10.1017/S0956796805005642">10.1017/S0956796805005642</a>. <a href="http://www.journals.cambridge.org/abstract_S0956796805005642" class="uri">http://www.journals.cambridge.org/abstract_S0956796805005642</a>.</p>
</div>
<div id="ref-danvy_there_2005">
<p>Danvy, Olivier, and Mayer Goldberg. 2005. “There and Back Again.” <em>BRICS Report Series</em> 12 (3). doi:<a href="https://doi.org/10.7146/brics.v12i3.21869">10.7146/brics.v12i3.21869</a>. <a href="https://tidsskrift.dk/brics/article/view/21869" class="uri">https://tidsskrift.dk/brics/article/view/21869</a>.</p>
</div>
<div id="ref-hutton_countdown_2002">
<p>Hutton, Graham. 2002. “The Countdown Problem.” <em>J. Funct. Program.</em> 12 (6) (November): 609–616. doi:<a href="https://doi.org/10.1017/S0956796801004300">10.1017/S0956796801004300</a>. <a href="http://www.cs.nott.ac.uk/~pszgmh/countdown.pdf" class="uri">http://www.cs.nott.ac.uk/~pszgmh/countdown.pdf</a>.</p>
</div>
<div id="ref-steffen_table_2006">
<p>Steffen, Peter, and Robert Giegerich. 2006. “Table Design in Dynamic Programming.” <em>Information and Computation</em> 204 (9) (September): 1325–1345. doi:<a href="https://doi.org/10.1016/j.ic.2006.02.006">10.1016/j.ic.2006.02.006</a>. <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.85.601&amp;rep=rep1&amp;type=pdf" class="uri">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.85.601&amp;rep=rep1&amp;type=pdf</a>.</p>
</div>
<div id="ref-tobin_time_2016">
<p>Tobin, Jared. 2016. “Time Traveling Recursion Schemes.” <em>jtobin.io</em>. <a href="https://jtobin.io/time-traveling-recursion" class="uri">https://jtobin.io/time-traveling-recursion</a>.</p>
</div>
</div>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>If you think that structure looks more like a funny linked list than a tree, that’s because it is. Instead of talking about “left” and “right” branches, we could talk about the first and second elements in a list: in fact, this is exactly what’s happening in the famous <code class="sourceCode haskell">zipWith</code> Fibonacci implementation (in reverse).</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1">fibs <span class="fu">=</span> <span class="dv">0</span> <span class="fu">:</span> <span class="dv">1</span> <span class="fu">:</span> zipWith (<span class="fu">+</span>) fibs (tail fibs)</a></code></pre></div>
<p>Or, in my favourite version:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">fib n <span class="fu">=</span> fix ((<span class="fu">:</span>) <span class="dv">0</span> <span class="fu">.</span> scanl (<span class="fu">+</span>) <span class="dv">1</span>) <span class="fu">!!</span> n</a></code></pre></div>
<a href="#fnref1" class="footnote-back">↩</a></li>
</ol>
</section>
]]></description>
    <pubDate>Tue, 20 Mar 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-03-20-countdown.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Rose Trees, Breadth-First</title>
    <link>https://doisinkidney.com/posts/2018-03-17-rose-trees-breadth-first.html</link>
    <description><![CDATA[<div class="info">
    Posted on March 17, 2018
</div>
<div class="info">
    
        Part 1 of a <a href="/series/Breadth-First%20Traversals.html">7-part series on Breadth-First Traversals</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>
    
</div>

<p>In contrast to the more common binary trees, in a rose tree every node can have any number of children.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Node</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">    {<span class="ot"> root   ::</span> a</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">    ,<span class="ot"> forest ::</span> <span class="dt">Forest</span> a</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">    }</a>
<a class="sourceLine" id="cb1-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="kw">type</span> <span class="dt">Forest</span> a <span class="fu">=</span> [<span class="dt">Tree</span> a]</a></code></pre></div>
<p>One of the important manipulations of this data structure, which forms the basis for several other algorithms, is a breadth-first traversal. I’d like to go through a couple of techniques for implementing it, and how more generally you can often get away with using much simpler data structures if you really pinpoint the API you need from them.</p>
<p>As a general technique, <span class="citation" data-cites="okasaki_breadth-first_2000">Okasaki (<a href="#ref-okasaki_breadth-first_2000">2000</a>)</span> advises that a queue be used:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">breadthFirst ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">breadthFirst tr <span class="fu">=</span> go (singleton tr)</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">    go q <span class="fu">=</span> <span class="kw">case</span> pop q <span class="kw">of</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5">      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> []</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">      <span class="dt">Just</span> (<span class="dt">Node</span> x xs,qs) <span class="ot">-&gt;</span> x <span class="fu">:</span> go (qs <span class="ot">`append`</span> xs)</a></code></pre></div>
<p>There are three functions left undefined there: <code class="sourceCode haskell">singleton</code>, <code class="sourceCode haskell">pop</code>, and <code class="sourceCode haskell">append</code>. They represent the API of our as-of-yet unimplemented queue, and their complexity will dictate the complexity of the overall algorithm. As a (bad) first choice, we could use simple lists, with the functions defined thus:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1">singleton x <span class="fu">=</span> [x]</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">pop (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="dt">Just</span> (x,xs)</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">pop [] <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">append <span class="fu">=</span> (<span class="fu">++</span>)</a></code></pre></div>
<p>Those repeated appends are bad news. The queue needs to be able to support popping from one side and appending from the other, which is something lists absolutely <em>cannot</em> do well.</p>
<p>We could swap in a more general queue implementation, possibly using Data.Sequence, or a pair of lists. But these are more complex and general than we need, so let’s try and pare down the requirements a little more.</p>
<p>First, we don’t need a pop: the go function can be expressed as a fold instead. Second, we don’t need <em>every</em> append to be immediately stuck into the queue, we can batch them, first appending to a structure that’s efficient for appends, and then converting that to a structure which is efficient for folds. In code:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">breadthFirst ::</span> <span class="dt">Forest</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">breadthFirst ts <span class="fu">=</span> foldr f b ts []</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">    f (<span class="dt">Node</span> x xs) fw bw <span class="fu">=</span> x <span class="fu">:</span> fw (xs <span class="fu">:</span> bw)</a>
<a class="sourceLine" id="cb4-5" data-line-number="5"></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">    b [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb4-7" data-line-number="7">    b qs <span class="fu">=</span> foldl (foldr f) b qs []</a></code></pre></div>
<p>We’re consing instead of appending, but the consumption is being done in the correct direction anyway, because of the <code class="sourceCode haskell">foldl</code>.</p>
<h2 id="levels">Levels</h2>
<p>So next step: to get the <code class="sourceCode haskell">levels</code> function from Data.Tree. Instead of doing a breadth-first traversal, it returns the nodes at each <em>level</em> of the tree. Conceptually, every time we did the reverse above (called <code class="sourceCode haskell">foldl</code>), we will do a cons as well:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">levels ::</span> <span class="dt">Forest</span> a <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">levels ts <span class="fu">=</span> foldl f b ts [] []</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">    f k (<span class="dt">Node</span> x xs) ls qs <span class="fu">=</span> k (x <span class="fu">:</span> ls) (xs <span class="fu">:</span> qs)</a>
<a class="sourceLine" id="cb5-5" data-line-number="5"></a>
<a class="sourceLine" id="cb5-6" data-line-number="6">    b _ [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb5-7" data-line-number="7">    b k qs <span class="fu">=</span> k <span class="fu">:</span> foldl (foldl f) b qs [] []</a></code></pre></div>
<h2 id="unfolding">Unfolding</h2>
<p>The original reason I started work on these problems was <a href="https://github.com/haskell/containers/issues/124">this</a> issue in containers. It concerns the <a href="https://hackage.haskell.org/package/containers-0.5.11.0/docs/Data-Tree.html#v:unfoldTreeM_BF"><code>unfoldTreeM_BF</code></a> function. An early go at rewriting it, inspired by levels above, looks like this:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">unfoldForestM_BF ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (b <span class="ot">-&gt;</span> m (a, [b])) <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> m (<span class="dt">Forest</span> a)</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">unfoldForestM_BF f ts <span class="fu">=</span> b [ts] (const id)</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">    b [] k <span class="fu">=</span> pure (k [] [])</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">    b qs k <span class="fu">=</span> foldl (foldr t) b qs [] (\x <span class="ot">-&gt;</span> k [] <span class="fu">.</span> foldr (uncurry run) id x)</a>
<a class="sourceLine" id="cb6-6" data-line-number="6"></a>
<a class="sourceLine" id="cb6-7" data-line-number="7">    t a fw bw k <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">        (x,cs) <span class="ot">&lt;-</span> f a</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">        <span class="kw">let</span> <span class="fu">!</span>n <span class="fu">=</span> length cs</a>
<a class="sourceLine" id="cb6-10" data-line-number="10">        fw (cs <span class="fu">:</span> bw) (k <span class="fu">.</span> (<span class="fu">:</span>) (x, n))</a>
<a class="sourceLine" id="cb6-11" data-line-number="11"></a>
<a class="sourceLine" id="cb6-12" data-line-number="12">    run x n xs ys <span class="fu">=</span></a>
<a class="sourceLine" id="cb6-13" data-line-number="13">      <span class="kw">case</span> splitAt n ys <span class="kw">of</span></a>
<a class="sourceLine" id="cb6-14" data-line-number="14">          (cs,zs) <span class="ot">-&gt;</span> <span class="dt">Node</span> x cs <span class="fu">:</span> xs zs</a></code></pre></div>
<p>It basically performs the same this as the levels function, but builds the tree back up in the end using the <code class="sourceCode haskell">run</code> function. In order to do that, we store the length of each subforest on line 9, so that each node knows how much to take from each level.</p>
<p>A possible optimization is to stop taking the length. Anything in list processing that takes a length screams “wrong” to me (although it’s not always true!) so I often try to find a way to avoid it. The first option would be to keep the <code class="sourceCode haskell">cs</code> on line 8 around, and use <em>it</em> as an indicator for the length. That keeps it around longer than strictly necessary, though. The other option is to add a third level: for <code class="sourceCode haskell">breadthFirst</code> above, we had one level; for <code class="sourceCode haskell">levels</code>, we added another, to indicate the structure of the nodes and their subtrees; here, we can add a third, to maintain that structure when building back up:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">unfoldForestM_BF ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (b <span class="ot">-&gt;</span> m (a, [b])) <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> m (<span class="dt">Forest</span> a)</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">unfoldForestM_BF f ts <span class="fu">=</span> b [ts] (\ls <span class="ot">-&gt;</span> concat <span class="fu">.</span> ls)</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">    b [] k <span class="fu">=</span> pure (k id [])</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">    b qs k <span class="fu">=</span> foldl g b qs [] (\ls <span class="ot">-&gt;</span> k id <span class="fu">.</span> ls)</a>
<a class="sourceLine" id="cb7-6" data-line-number="6"></a>
<a class="sourceLine" id="cb7-7" data-line-number="7">    g a xs qs k <span class="fu">=</span> foldr t (\ls ys <span class="ot">-&gt;</span> a ys (k <span class="fu">.</span> run ls)) xs [] qs</a>
<a class="sourceLine" id="cb7-8" data-line-number="8"></a>
<a class="sourceLine" id="cb7-9" data-line-number="9">    t a fw xs bw <span class="fu">=</span> f a <span class="fu">&gt;&gt;=</span> \(x,cs) <span class="ot">-&gt;</span> fw (x<span class="fu">:</span>xs) (cs<span class="fu">:</span>bw)</a>
<a class="sourceLine" id="cb7-10" data-line-number="10"></a>
<a class="sourceLine" id="cb7-11" data-line-number="11">    run x xs <span class="fu">=</span> uncurry (<span class="fu">:</span>) <span class="fu">.</span> foldl go ((,) [] <span class="fu">.</span> xs) x</a>
<a class="sourceLine" id="cb7-12" data-line-number="12">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-13" data-line-number="13">        go ys y (z<span class="fu">:</span>zs) <span class="fu">=</span> (<span class="dt">Node</span> y z <span class="fu">:</span> ys&#39;, zs&#39;)</a>
<a class="sourceLine" id="cb7-14" data-line-number="14">          <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-15" data-line-number="15">            (ys&#39;,zs&#39;) <span class="fu">=</span> ys zs</a></code></pre></div>
<p>This unfortunately <em>slows down</em> the code.</p>
<div id="refs" class="references">
<div id="ref-okasaki_breadth-first_2000">
<p>Okasaki, Chris. 2000. “Breadth-first Numbering: Lessons from a Small Exercise in Algorithm Design.” In <em>Proceedings of the Fifth ACM SIGPLAN International Conference on Functional Programming</em>, 131–136. ICFP ’00. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/351240.351253">10.1145/351240.351253</a>. <a href="https://www.cs.tufts.edu/~nr/cs257/archive/chris-okasaki/breadth-first.pdf" class="uri">https://www.cs.tufts.edu/~nr/cs257/archive/chris-okasaki/breadth-first.pdf</a>.</p>
</div>
</div>
]]></description>
    <pubDate>Sat, 17 Mar 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-03-17-rose-trees-breadth-first.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Single-Pass Huffman Coding</title>
    <link>https://doisinkidney.com/posts/2018-02-17-single-pass-huffman.html</link>
    <description><![CDATA[<div class="info">
    Posted on February 17, 2018
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Folds.html">Folds</a>
    
</div>

<p>While working on something else, I figured out a nice Haskell implementation of Huffman coding, and I thought I’d share it here. I’ll go through a few techniques for transforming a multi-pass algorithm into a single-pass one first, and then I’ll show how to use them for Huffman. If you just want to skip to the code, it’s provided at the end.<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a></p>
<p>The algorithm isn’t single-pass in the sense of <a href="https://www2.cs.duke.edu/csed/curious/compression/adaptivehuff.html">Adaptive Huffman Coding</a>: it still uses the normal Huffman algorithm, but the input is transformed in the same traversal that builds the tree to transform it.</p>
<h2 id="circular-programming">Circular Programming</h2>
<p>There are several techniques for turning multi-pass algorithms into single-pass ones in functional languages. Perhaps the most famous is circular programming: using <em>laziness</em> to eliminate a pass. <span class="citation" data-cites="bird_using_1984">Bird (<a href="#ref-bird_using_1984">1984</a>)</span> used this to great effect in solving the repmin problem:</p>
<blockquote>
<p>Given a tree of integers, replace every integer with the minimum integer in the tree, in one pass.</p>
</blockquote>
<p>For an imperative programmer, the problem is relatively easy: first, write the code to find the minimum value in the tree in the standard way, using a loop and a “smallest so far” accumulator. Then, inside the loop, after updating the accumulator, set the value of the leaf to be a <em>reference</em> to the accumulator.</p>
<p>At first, that solution may seem necessarily impure: we’re using global, mutable state to update many things at once. However, as the paper shows, we can claw back purity using laziness:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a <span class="fu">=</span> <span class="dt">Leaf</span> a <span class="fu">|</span> <span class="dt">Tree</span> a <span class="fu">:*:</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb2-2" data-line-number="2"></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="ot">repMin ::</span> <span class="dt">Tree</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Tree</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">repMin xs <span class="fu">=</span> ys <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5">  (m, ys) <span class="fu">=</span> go xs</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">  go (<span class="dt">Leaf</span> x) <span class="fu">=</span> (x, <span class="dt">Leaf</span> m)</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">  go (xs <span class="fu">:*:</span> ys) <span class="fu">=</span> (min x y, xs&#39; <span class="fu">:*:</span> ys&#39;)</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9">      (x,xs&#39;) <span class="fu">=</span> go xs</a>
<a class="sourceLine" id="cb2-10" data-line-number="10">      (y,ys&#39;) <span class="fu">=</span> go ys</a></code></pre></div>
<h2 id="there-and-back-again">There and Back Again</h2>
<p>Let’s say we don’t have laziness at our disposal: are we hosed? No!<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a> <span class="citation" data-cites="danvy_there_2005">Danvy and Goldberg (<a href="#ref-danvy_there_2005">2005</a>)</span> explore this very issue, by posing the question:</p>
<blockquote>
<p>Given two lists, xs and ys, can you zip xs with the reverse of ys in one pass?</p>
</blockquote>
<p>The technique used to solve the problem is named “There and Back Again”; it should be clear why from one of the solutions:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1">convolve xs ys <span class="fu">=</span> walk xs const <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  walk [] k <span class="fu">=</span> k [] ys</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">  walk (x<span class="fu">:</span>xs) k <span class="fu">=</span> walk xs (\r (y<span class="fu">:</span>ys) <span class="ot">-&gt;</span> k ((x,y) <span class="fu">:</span> r) ys)</a></code></pre></div>
<p>The traversal of one list builds up the function to consume the other. We could write repmin in the same way:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">repMin <span class="fu">=</span> uncurry (<span class="fu">$</span>) <span class="fu">.</span> go <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  go (<span class="dt">Leaf</span> x) <span class="fu">=</span> (<span class="dt">Leaf</span>, x)</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  go (xs <span class="fu">:*:</span> ys) <span class="fu">=</span> (\m <span class="ot">-&gt;</span> xs&#39; m <span class="fu">:*:</span> ys&#39; m, min xm ym) <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">    (xs&#39;,xm) <span class="fu">=</span> go xs</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">    (ys&#39;,ym) <span class="fu">=</span> go ys</a></code></pre></div>
<h2 id="cayley-representations">Cayley Representations</h2>
<p>If you’re doing a lot of appending to some list-like structure, you probably don’t want to use actual lists: you’ll end up traversing the left-hand-side of the append many more times than necessary. A type you can drop in to use instead is difference lists <span class="citation" data-cites="hughes_novel_1986">(Hughes <a href="#ref-hughes_novel_1986">1986</a>)</span>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">type</span> <span class="dt">DList</span> a <span class="fu">=</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb5-2" data-line-number="2"></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="ot">rep ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">DList</span> a</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">rep <span class="fu">=</span> (<span class="fu">++</span>)</a>
<a class="sourceLine" id="cb5-5" data-line-number="5"></a>
<a class="sourceLine" id="cb5-6" data-line-number="6">abs<span class="ot"> ::</span> <span class="dt">DList</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb5-7" data-line-number="7">abs xs <span class="fu">=</span> xs []</a>
<a class="sourceLine" id="cb5-8" data-line-number="8"></a>
<a class="sourceLine" id="cb5-9" data-line-number="9"><span class="ot">append ::</span> <span class="dt">DList</span> a <span class="ot">-&gt;</span> <span class="dt">DList</span> a <span class="ot">-&gt;</span> <span class="dt">DList</span> a</a>
<a class="sourceLine" id="cb5-10" data-line-number="10">append <span class="fu">=</span> (<span class="fu">.</span>)</a></code></pre></div>
<p><code class="sourceCode haskell">append</code> is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math> in this representation. In fact, for any monoid with a slow <code class="sourceCode haskell">mappend</code>, you can use the same trick: it’s called the Cayley representation, and available as <code class="sourceCode haskell"><span class="dt">Endo</span></code> in <a href="https://hackage.haskell.org/package/base-4.10.1.0/docs/Data-Monoid.html#t:Endo">Data.Monoid</a>.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">rep ::</span> <span class="dt">Monoid</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Endo</span> a</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">rep x <span class="fu">=</span> <span class="dt">Endo</span> (mappend x)</a>
<a class="sourceLine" id="cb6-3" data-line-number="3"></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">abs<span class="ot"> ::</span> <span class="dt">Monoid</span> a <span class="ot">=&gt;</span> <span class="dt">Endo</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">abs (<span class="dt">Endo</span> f) <span class="fu">=</span> f mempty</a>
<a class="sourceLine" id="cb6-6" data-line-number="6"></a>
<a class="sourceLine" id="cb6-7" data-line-number="7"><span class="kw">instance</span> <span class="dt">Monoid</span> (<span class="dt">Endo</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">  mempty <span class="fu">=</span> <span class="dt">Endo</span> id</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">  mappend (<span class="dt">Endo</span> f) (<span class="dt">Endo</span> g) <span class="fu">=</span> <span class="dt">Enfo</span> (f <span class="fu">.</span> g)</a></code></pre></div>
<p>You can actually do the same transformation for “monoids” in the categorical sense: applying it to monads, for instance, will give you codensity <span class="citation" data-cites="rivas_notions_2014">(Rivas and Jaskelioff <a href="#ref-rivas_notions_2014">2014</a>)</span>.</p>
<h2 id="traversable">Traversable</h2>
<p>Looking back—just for a second—to the repmin example, we should be able to spot a pattern we can generalize. There’s really nothing tree-specific about it, so why can’t we apply it to lists? Or other structures, for that matter? It turns out we can: the <code class="sourceCode haskell">mapAccumL</code> function is tailor-made to this need:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">repMin ::</span> <span class="dt">Traversable</span> t <span class="ot">=&gt;</span> t <span class="dt">Integer</span> <span class="ot">-&gt;</span> t <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">repMin xs <span class="fu">=</span> ys <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  (<span class="fu">~</span>(<span class="dt">Just</span> m), ys) <span class="fu">=</span> mapAccumL f <span class="dt">Nothing</span> xs</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">  f <span class="dt">Nothing</span> x <span class="fu">=</span> (<span class="dt">Just</span> x, m)</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">  f (<span class="dt">Just</span> y) x <span class="fu">=</span> (<span class="dt">Just</span> (min x y), m)</a></code></pre></div>
<p>The tilde before the <code class="sourceCode haskell"><span class="dt">Just</span></code> ensures this won’t fail on empty input.</p>
<h1 id="huffman-coding">Huffman Coding</h1>
<p>Finally, it’s time for the main event. Huffman coding is a <em>very</em> multi-pass algorithm, usually. The steps look like this:</p>
<ol type="1">
<li>Build a frequency table for each character in the input.</li>
<li>Build a priority queue from that frequency table.</li>
<li>Iteratively pop elements and combine them (into Huffman trees) from the queue until there’s only one left.</li>
<li>That Huffman tree can be used to construct the mapping from items back to their Huffman codes.</li>
<li>Traverse the input again, using the constructed mapping to replace elements with their codes.</li>
</ol>
<p>We can’t <em>skip</em> any of these steps: we can try perform them all at once, though.</p>
<p>Let’s write the multi-pass version first. We’ll need the frequency table:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">frequencies ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Map</span> a <span class="dt">Int</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">frequencies <span class="fu">=</span> Map.fromListWith (<span class="fu">+</span>) <span class="fu">.</span> map (flip (,) <span class="dv">1</span>)</a></code></pre></div>
<p>And a heap, ordered on the frequencies of its elements (I’m using a skew heap here):</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Heap</span> a</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  <span class="fu">|</span> <span class="dt">Node</span> <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">Int</span> a (<span class="dt">Heap</span> a) (<span class="dt">Heap</span> a)</a>
<a class="sourceLine" id="cb9-4" data-line-number="4"></a>
<a class="sourceLine" id="cb9-5" data-line-number="5"><span class="kw">instance</span> <span class="dt">Monoid</span> (<span class="dt">Heap</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6">  mappend <span class="dt">Nil</span> ys <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">  mappend xs <span class="dt">Nil</span> <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb9-8" data-line-number="8">  mappend h1<span class="fu">@</span>(<span class="dt">Node</span> i x lx rx) h2<span class="fu">@</span>(<span class="dt">Node</span> j y ly ry)</a>
<a class="sourceLine" id="cb9-9" data-line-number="9">    <span class="fu">|</span> i <span class="fu">&lt;=</span> j    <span class="fu">=</span> <span class="dt">Node</span> i x (mappend h2 rx) lx</a>
<a class="sourceLine" id="cb9-10" data-line-number="10">    <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Node</span> j y (mappend h1 ry) ly</a>
<a class="sourceLine" id="cb9-11" data-line-number="11">  mempty <span class="fu">=</span> <span class="dt">Nil</span></a></code></pre></div>
<p>Next, we need to build the tree<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>. We can use the tree type from above.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">buildTree ::</span> <span class="dt">Map</span> a <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Tree</span> a)</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">buildTree <span class="fu">=</span> prune <span class="fu">.</span> toHeap <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  toHeap <span class="fu">=</span> Map.foldMapWithKey (\k v <span class="ot">-&gt;</span> <span class="dt">Node</span> v (<span class="dt">Leaf</span> k) <span class="dt">Nil</span> <span class="dt">Nil</span>)</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">  prune <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb10-5" data-line-number="5">  prune (<span class="dt">Node</span> i x l r) <span class="fu">=</span> <span class="kw">case</span> mappend l r <span class="kw">of</span></a>
<a class="sourceLine" id="cb10-6" data-line-number="6">    <span class="dt">Nil</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> x</a>
<a class="sourceLine" id="cb10-7" data-line-number="7">    <span class="dt">Node</span> j y l&#39; r&#39; <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb10-8" data-line-number="8">      prune (mappend (<span class="dt">Node</span> (i<span class="fu">+</span>j) (x <span class="fu">:*:</span> y) <span class="dt">Nil</span> <span class="dt">Nil</span>) (mappend l&#39; r&#39;))</a></code></pre></div>
<p>Then, a way to convert between the tree and a map:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">toMapping ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Map</span> a [<span class="dt">Bool</span>]</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">toMapping (<span class="dt">Leaf</span> x) <span class="fu">=</span> Map.singleton x []</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">toMapping (xs <span class="fu">:*:</span> ys) <span class="fu">=</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4">    Map.union (fmap (<span class="dt">True</span><span class="fu">:</span>) (toMapping xs)) (fmap (<span class="dt">False</span><span class="fu">:</span>) (toMapping ys))</a></code></pre></div>
<p>And finally, putting the whole thing together:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="ot">huffman ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> (<span class="dt">Maybe</span> (<span class="dt">Tree</span> a), [[<span class="dt">Bool</span>]])</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">huffman xs <span class="fu">=</span> (tree, map (mapb <span class="fu">Map.!</span>) xs) <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">  freq <span class="fu">=</span> frequencies xs</a>
<a class="sourceLine" id="cb12-4" data-line-number="4">  tree <span class="fu">=</span> buildTree freq</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">  mapb <span class="fu">=</span> maybe Map.empty toMapping tree</a></code></pre></div>
<h2 id="removing-the-passes">Removing the passes</h2>
<p>The first thing to fix is the <code class="sourceCode haskell">toMapping</code> function: at every level, it calls <code class="sourceCode haskell">union</code>, a complex and expensive operation. However, <code class="sourceCode haskell">union</code> and <code class="sourceCode haskell">empty</code> form a monoid, so we can use the Cayley representation to reduce the calls to a minimum. Next, we want to get rid of the <code class="sourceCode haskell">fmap</code>s: we can do that by assembling a function to perform the <code class="sourceCode haskell">fmap</code> as we go, as in <code class="sourceCode haskell">convolve</code><a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a>.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="ot">toMapping ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Map</span> a [<span class="dt">Bool</span>]</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">toMapping tree <span class="fu">=</span> go tree id Map.empty <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">  go (<span class="dt">Leaf</span> x) k <span class="fu">=</span> Map.insert x (k [])</a>
<a class="sourceLine" id="cb13-4" data-line-number="4">  go (xs <span class="fu">:*:</span> ys) k <span class="fu">=</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5">    go xs (k <span class="fu">.</span> (<span class="fu">:</span>) <span class="dt">True</span>) <span class="fu">.</span> go ys (k <span class="fu">.</span> (<span class="fu">:</span>) <span class="dt">False</span>)</a></code></pre></div>
<p>Secondly, we can integrate the <code class="sourceCode haskell">toMapping</code> function with the <code class="sourceCode haskell">buildTree</code> function, removing another pass:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="ot">buildTree ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Map</span> a <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Tree</span> a, <span class="dt">Map</span> a [<span class="dt">Bool</span>])</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">buildTree <span class="fu">=</span> prune <span class="fu">.</span> toHeap <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3">  toHeap <span class="fu">=</span> Map.foldMapWithKey (\k v <span class="ot">-&gt;</span> <span class="dt">Node</span> v (<span class="dt">Leaf</span> k, leaf k) <span class="dt">Nil</span> <span class="dt">Nil</span>)</a>
<a class="sourceLine" id="cb14-4" data-line-number="4">  prune <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb14-5" data-line-number="5">  prune (<span class="dt">Node</span> i x l r) <span class="fu">=</span> <span class="kw">case</span> mappend l r <span class="kw">of</span></a>
<a class="sourceLine" id="cb14-6" data-line-number="6">    <span class="dt">Nil</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> (fmap (\k <span class="ot">-&gt;</span> k id Map.empty) x)</a>
<a class="sourceLine" id="cb14-7" data-line-number="7">    <span class="dt">Node</span> j y l&#39; r&#39; <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb14-8" data-line-number="8">      prune (mappend (<span class="dt">Node</span> (i<span class="fu">+</span>j) (cmb x y) <span class="dt">Nil</span> <span class="dt">Nil</span>) (mappend l&#39; r&#39;))</a>
<a class="sourceLine" id="cb14-9" data-line-number="9">  leaf x k <span class="fu">=</span> Map.insert x (k [])</a>
<a class="sourceLine" id="cb14-10" data-line-number="10">  node xs ys k <span class="fu">=</span> xs (k <span class="fu">.</span> (<span class="fu">:</span>) <span class="dt">True</span>) <span class="fu">.</span> ys (k <span class="fu">.</span> (<span class="fu">:</span>) <span class="dt">False</span>)</a>
<a class="sourceLine" id="cb14-11" data-line-number="11">  cmb (xt,xm) (yt,ym) <span class="fu">=</span> (xt <span class="fu">:*:</span> yt, node xm ym)</a></code></pre></div>
<p>Finally, to remove the second pass over the list, we can copy repmin, using <code class="sourceCode haskell">mapAccumL</code> to both construct the mapping and apply it to the structure in one go.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="ot">huffman ::</span> (<span class="dt">Ord</span> a, <span class="dt">Traversable</span> t) <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> (<span class="dt">Maybe</span> (<span class="dt">Tree</span> a), t [<span class="dt">Bool</span>])</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">huffman xs <span class="fu">=</span> (fmap fst tree, ys) <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-3" data-line-number="3">  (freq,ys) <span class="fu">=</span> mapAccumL f Map.empty xs</a>
<a class="sourceLine" id="cb15-4" data-line-number="4">  f fm x <span class="fu">=</span> (Map.insertWith (<span class="fu">+</span>) x <span class="dv">1</span> fm, mapb <span class="fu">Map.!</span> x)</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">  tree <span class="fu">=</span> buildTree freq</a>
<a class="sourceLine" id="cb15-6" data-line-number="6">  mapb <span class="fu">=</span> maybe Map.empty snd tree</a></code></pre></div>
<p>And that’s it!</p>
<h1 id="generalization">Generalization</h1>
<p>The similarity between the repmin function and the solution above is suggestive: is there a way to <em>encode</em> this idea of making a multi-pass algorithm single-pass? Of course! We can use an applicative:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Circular</span> a b c <span class="fu">=</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2">    <span class="dt">Circular</span> <span class="fu">!</span>a</a>
<a class="sourceLine" id="cb16-3" data-line-number="3">             (b <span class="ot">-&gt;</span> c)</a>
<a class="sourceLine" id="cb16-4" data-line-number="4"></a>
<a class="sourceLine" id="cb16-5" data-line-number="5"><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Circular</span> a b) <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-6" data-line-number="6">    fmap f (<span class="dt">Circular</span> tally run) <span class="fu">=</span> <span class="dt">Circular</span> tally (f <span class="fu">.</span> run)</a>
<a class="sourceLine" id="cb16-7" data-line-number="7"></a>
<a class="sourceLine" id="cb16-8" data-line-number="8"><span class="kw">instance</span> <span class="dt">Monoid</span> a <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb16-9" data-line-number="9">         <span class="dt">Applicative</span> (<span class="dt">Circular</span> a b) <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-10" data-line-number="10">    pure x <span class="fu">=</span> <span class="dt">Circular</span> mempty (const x)</a>
<a class="sourceLine" id="cb16-11" data-line-number="11">    <span class="dt">Circular</span> fl fr <span class="fu">&lt;*&gt;</span> <span class="dt">Circular</span> xl xr <span class="fu">=</span></a>
<a class="sourceLine" id="cb16-12" data-line-number="12">        <span class="dt">Circular</span></a>
<a class="sourceLine" id="cb16-13" data-line-number="13">            (mappend fl xl)</a>
<a class="sourceLine" id="cb16-14" data-line-number="14">            (\r <span class="ot">-&gt;</span> fr r (xr r))</a>
<a class="sourceLine" id="cb16-15" data-line-number="15"></a>
<a class="sourceLine" id="cb16-16" data-line-number="16">liftHuffman</a>
<a class="sourceLine" id="cb16-17" data-line-number="17"><span class="ot">    ::</span> <span class="dt">Ord</span> a</a>
<a class="sourceLine" id="cb16-18" data-line-number="18">    <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Circular</span> (<span class="dt">Map</span> a <span class="dt">Int</span>) (<span class="dt">Map</span> a [<span class="dt">Bool</span>]) [<span class="dt">Bool</span>]</a>
<a class="sourceLine" id="cb16-19" data-line-number="19">liftHuffman x <span class="fu">=</span> <span class="dt">Circular</span> (Map.singleton x <span class="dv">1</span>) (<span class="fu">Map.!</span> x)</a>
<a class="sourceLine" id="cb16-20" data-line-number="20"></a>
<a class="sourceLine" id="cb16-21" data-line-number="21">runHuffman</a>
<a class="sourceLine" id="cb16-22" data-line-number="22"><span class="ot">    ::</span> <span class="dt">Ord</span> a</a>
<a class="sourceLine" id="cb16-23" data-line-number="23">    <span class="ot">=&gt;</span> <span class="dt">Circular</span> (<span class="dt">Map</span> a <span class="dt">Int</span>) (<span class="dt">Map</span> a [<span class="dt">Bool</span>]) r <span class="ot">-&gt;</span> (<span class="dt">Maybe</span> (<span class="dt">Tree</span> a), r)</a>
<a class="sourceLine" id="cb16-24" data-line-number="24">runHuffman (<span class="dt">Circular</span> smry run) <span class="fu">=</span></a>
<a class="sourceLine" id="cb16-25" data-line-number="25">    maybe (<span class="dt">Nothing</span>, run Map.empty) (<span class="dt">Just</span> <span class="fu">***</span> run) (buildTree smry)</a>
<a class="sourceLine" id="cb16-26" data-line-number="26"></a>
<a class="sourceLine" id="cb16-27" data-line-number="27">huffman</a>
<a class="sourceLine" id="cb16-28" data-line-number="28"><span class="ot">    ::</span> (<span class="dt">Ord</span> a, <span class="dt">Traversable</span> t)</a>
<a class="sourceLine" id="cb16-29" data-line-number="29">    <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> (<span class="dt">Maybe</span> (<span class="dt">Tree</span> a), t [<span class="dt">Bool</span>])</a>
<a class="sourceLine" id="cb16-30" data-line-number="30">huffman <span class="fu">=</span> runHuffman <span class="fu">.</span> traverse liftHuffman</a></code></pre></div>
<p>Thanks to it being an applicative, you can do all the fun lensy things with it:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="ot">showBin ::</span> [<span class="dt">Bool</span>] <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2">showBin <span class="fu">=</span> map (bool <span class="ch">&#39;0&#39;</span> <span class="ch">&#39;1&#39;</span>)</a>
<a class="sourceLine" id="cb17-3" data-line-number="3"></a>
<a class="sourceLine" id="cb17-4" data-line-number="4"><span class="fu">&gt;&gt;&gt;</span> <span class="kw">let</span> liftBin <span class="fu">=</span> fmap showBin <span class="fu">.</span> liftHuffman</a>
<a class="sourceLine" id="cb17-5" data-line-number="5"><span class="fu">&gt;&gt;&gt;</span> (snd <span class="fu">.</span> runHuffman <span class="fu">.</span> (each<span class="fu">.</span>traverse) liftBin) (<span class="st">&quot;abb&quot;</span>, <span class="st">&quot;cad&quot;</span>, <span class="st">&quot;c&quot;</span>)</a>
<a class="sourceLine" id="cb17-6" data-line-number="6">([<span class="st">&quot;01&quot;</span>,<span class="st">&quot;11&quot;</span>,<span class="st">&quot;11&quot;</span>],[<span class="st">&quot;00&quot;</span>,<span class="st">&quot;01&quot;</span>,<span class="st">&quot;10&quot;</span>],[<span class="st">&quot;00&quot;</span>])</a></code></pre></div>
<p>Bringing us back to the start, it can also let us solve repmin!</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="ot">liftRepMin ::</span> a <span class="ot">-&gt;</span> <span class="dt">Circular</span> (<span class="dt">Option</span> (<span class="dt">Min</span> a)) a a</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">liftRepMin x <span class="fu">=</span> <span class="dt">Circular</span> (pure (pure x)) id</a>
<a class="sourceLine" id="cb18-3" data-line-number="3"></a>
<a class="sourceLine" id="cb18-4" data-line-number="4"><span class="ot">runRepMin ::</span> <span class="dt">Circular</span> (<span class="dt">Option</span> (<span class="dt">Min</span> a)) a b <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb18-5" data-line-number="5">runRepMin (<span class="dt">Circular</span> m r) <span class="fu">=</span> r (<span class="kw">case</span> m <span class="kw">of</span></a>
<a class="sourceLine" id="cb18-6" data-line-number="6">  <span class="dt">Option</span> (<span class="dt">Just</span> (<span class="dt">Min</span> x)) <span class="ot">-&gt;</span> x)</a>
<a class="sourceLine" id="cb18-7" data-line-number="7"></a>
<a class="sourceLine" id="cb18-8" data-line-number="8"><span class="ot">repMin ::</span> (<span class="dt">Ord</span> a, <span class="dt">Traversable</span> t) <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> t a</a>
<a class="sourceLine" id="cb18-9" data-line-number="9">repMin <span class="fu">=</span> runRepMin <span class="fu">.</span> traverse liftRepMin</a></code></pre></div>
<h1 id="related">Related</h1>
<p>So the <code class="sourceCode haskell"><span class="dt">Circular</span></code> type is actually just the product of reader and writer, and is closely related to the <a href="https://github.com/treeowl/sort-traversable">sort</a> type.</p>
<p>It’s also related to the <a href="https://www.reddit.com/r/haskell/comments/7qwzn4/an_update_about_the_store_monad_and_state_comonad/"><code class="sourceCode haskell"><span class="dt">Prescient</span></code></a> type, which I noticed after I’d written the above.</p>
<h1 id="references" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-bird_more_1997">
<p>Bird, Richard, Geraint Jones, and Oege De Moor. 1997. “More haste‚ less speed: Lazy versus eager evaluation.” <em>Journal of Functional Programming</em> 7 (5) (September): 541–547. doi:<a href="https://doi.org/10.1017/S0956796897002827">10.1017/S0956796897002827</a>. <a href="https://ora.ox.ac.uk/objects/uuid:761a4646-60a2-4622-a1e0-ddea11507d57/datastreams/ATTACHMENT01" class="uri">https://ora.ox.ac.uk/objects/uuid:761a4646-60a2-4622-a1e0-ddea11507d57/datastreams/ATTACHMENT01</a>.</p>
</div>
<div id="ref-bird_using_1984">
<p>Bird, R. S. 1984. “Using Circular Programs to Eliminate Multiple Traversals of Data.” <em>Acta Inf.</em> 21 (3) (October): 239–250. doi:<a href="https://doi.org/10.1007/BF00264249">10.1007/BF00264249</a>. <a href="http://dx.doi.org/10.1007/BF00264249" class="uri">http://dx.doi.org/10.1007/BF00264249</a>.</p>
</div>
<div id="ref-danvy_there_2005">
<p>Danvy, Olivier, and Mayer Goldberg. 2005. “There and Back Again.” <a href="http://brics.dk/RS/05/3/BRICS-RS-05-3.pdf" class="uri">http://brics.dk/RS/05/3/BRICS-RS-05-3.pdf</a>.</p>
</div>
<div id="ref-hughes_novel_1986">
<p>Hughes, R. John Muir. 1986. “A Novel Representation of Lists and Its Application to the Function &quot;Reverse&quot;.” <em>Information Processing Letters</em> 22 (3) (March): 141–144. doi:<a href="https://doi.org/10.1016/0020-0190(86)90059-1">10.1016/0020-0190(86)90059-1</a>. <a href="http://www.sciencedirect.com/science/article/pii/0020019086900591" class="uri">http://www.sciencedirect.com/science/article/pii/0020019086900591</a>.</p>
</div>
<div id="ref-pippenger_pure_1997">
<p>Pippenger, Nicholas. 1997. “Pure Versus Impure Lisp.” <em>ACM Trans. Program. Lang. Syst.</em> 19 (2) (March): 223–238. doi:<a href="https://doi.org/10.1145/244795.244798">10.1145/244795.244798</a>. <a href="http://doi.acm.org/10.1145/244795.244798" class="uri">http://doi.acm.org/10.1145/244795.244798</a>.</p>
</div>
<div id="ref-rivas_notions_2014">
<p>Rivas, Exequiel, and Mauro Jaskelioff. 2014. “Notions of Computation as Monoids.” <em>arXiv:1406.4823 [cs, math]</em> (May). <a href="http://arxiv.org/abs/1406.4823" class="uri">http://arxiv.org/abs/1406.4823</a>.</p>
</div>
</div>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Huffman coding single-pass implementation:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">import</span>           <span class="dt">Data.Map.Strict</span>  (<span class="dt">Map</span>)</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map.Strict</span>  <span class="kw">as</span> <span class="dt">Map</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">import</span>           <span class="dt">Data.Traversable</span> (mapAccumL)</a>
<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="kw">data</span> <span class="dt">Heap</span> a</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">  <span class="fu">=</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">  <span class="fu">|</span> <span class="dt">Node</span> <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">Int</span> a (<span class="dt">Heap</span> a) (<span class="dt">Heap</span> a)</a>
<a class="sourceLine" id="cb1-8" data-line-number="8"></a>
<a class="sourceLine" id="cb1-9" data-line-number="9"><span class="kw">instance</span> <span class="dt">Monoid</span> (<span class="dt">Heap</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10">  mappend <span class="dt">Nil</span> ys <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb1-11" data-line-number="11">  mappend xs <span class="dt">Nil</span> <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb1-12" data-line-number="12">  mappend h1<span class="fu">@</span>(<span class="dt">Node</span> i x lx rx) h2<span class="fu">@</span>(<span class="dt">Node</span> j y ly ry)</a>
<a class="sourceLine" id="cb1-13" data-line-number="13">    <span class="fu">|</span> i <span class="fu">&lt;=</span> j    <span class="fu">=</span> <span class="dt">Node</span> i x (mappend h2 rx) lx</a>
<a class="sourceLine" id="cb1-14" data-line-number="14">    <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Node</span> j y (mappend h1 ry) ly</a>
<a class="sourceLine" id="cb1-15" data-line-number="15">  mempty <span class="fu">=</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb1-16" data-line-number="16"></a>
<a class="sourceLine" id="cb1-17" data-line-number="17"><span class="kw">data</span> <span class="dt">Tree</span> a <span class="fu">=</span> <span class="dt">Leaf</span> a <span class="fu">|</span> <span class="dt">Tree</span> a <span class="fu">:*:</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb1-18" data-line-number="18"></a>
<a class="sourceLine" id="cb1-19" data-line-number="19"><span class="ot">buildTree ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Map</span> a <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Tree</span> a, <span class="dt">Map</span> a [<span class="dt">Bool</span>])</a>
<a class="sourceLine" id="cb1-20" data-line-number="20">buildTree <span class="fu">=</span> prune <span class="fu">.</span> toHeap <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-21" data-line-number="21">  toHeap <span class="fu">=</span> Map.foldMapWithKey (\k v <span class="ot">-&gt;</span> <span class="dt">Node</span> v (<span class="dt">Leaf</span> k, leaf k) <span class="dt">Nil</span> <span class="dt">Nil</span>)</a>
<a class="sourceLine" id="cb1-22" data-line-number="22">  prune <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb1-23" data-line-number="23">  prune (<span class="dt">Node</span> i x l r) <span class="fu">=</span> <span class="kw">case</span> mappend l r <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-24" data-line-number="24">    <span class="dt">Nil</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> (fmap (\k <span class="ot">-&gt;</span> k id Map.empty) x)</a>
<a class="sourceLine" id="cb1-25" data-line-number="25">    <span class="dt">Node</span> j y l&#39; r&#39; <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb1-26" data-line-number="26">      prune (mappend (<span class="dt">Node</span> (i<span class="fu">+</span>j) (cmb x y) <span class="dt">Nil</span> <span class="dt">Nil</span>) (mappend l&#39; r&#39;))</a>
<a class="sourceLine" id="cb1-27" data-line-number="27">  leaf x k <span class="fu">=</span> Map.insert x (k [])</a>
<a class="sourceLine" id="cb1-28" data-line-number="28">  node xs ys k <span class="fu">=</span> xs (k <span class="fu">.</span> (<span class="fu">:</span>) <span class="dt">True</span>) <span class="fu">.</span> ys (k <span class="fu">.</span> (<span class="fu">:</span>) <span class="dt">False</span>)</a>
<a class="sourceLine" id="cb1-29" data-line-number="29">  cmb (xt,xm) (yt,ym) <span class="fu">=</span> (xt <span class="fu">:*:</span> yt, node xm ym)</a>
<a class="sourceLine" id="cb1-30" data-line-number="30"></a>
<a class="sourceLine" id="cb1-31" data-line-number="31"><span class="ot">huffman ::</span> (<span class="dt">Ord</span> a, <span class="dt">Traversable</span> t) <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> (<span class="dt">Maybe</span> (<span class="dt">Tree</span> a), t [<span class="dt">Bool</span>])</a>
<a class="sourceLine" id="cb1-32" data-line-number="32">huffman xs <span class="fu">=</span> (fmap fst tree, ys) <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-33" data-line-number="33">  (freq,ys) <span class="fu">=</span> mapAccumL f Map.empty xs</a>
<a class="sourceLine" id="cb1-34" data-line-number="34">  f fm x <span class="fu">=</span> (Map.insertWith (<span class="fu">+</span>) x <span class="dv">1</span> fm, mapb <span class="fu">Map.!</span> x)</a>
<a class="sourceLine" id="cb1-35" data-line-number="35">  tree <span class="fu">=</span> buildTree freq</a>
<a class="sourceLine" id="cb1-36" data-line-number="36">  mapb <span class="fu">=</span> maybe Map.empty snd tree</a></code></pre></div>
<a href="#fnref1" class="footnote-back">↩</a></li>
<li id="fn2"><p>Well, that’s a little bit of a lie. In terms of asympostics, <span class="citation" data-cites="pippenger_pure_1997">Pippenger (<a href="#ref-pippenger_pure_1997">1997</a>)</span> stated a problem that could be solved in linear time in impure Lisp, but <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Ω</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\Omega(n \log n)</annotation></semantics></math> in pure Lisp. <span class="citation" data-cites="bird_more_1997">Bird, Jones, and Moor (<a href="#ref-bird_more_1997">1997</a>)</span> then produced an algorithm that could solve the problem in linear time, by using laziness. So, in some cases, laziness will give you asymptotics you can’t get without it (if you want to stay pure).<a href="#fnref2" class="footnote-back">↩</a></p></li>
<li id="fn3"><p>There’s actually a nicer version of the <code class="sourceCode haskell">buildTree</code> function which uses <code class="sourceCode haskell"><span class="dt">StateT</span> (<span class="dt">Heap</span> a) <span class="dt">Maybe</span></code>, but it’s equivalent to this one under the hood, and I though might be a little distracting.<a href="#fnref3" class="footnote-back">↩</a></p></li>
<li id="fn4"><p>Something to notice about this function is that it’s going top-down and bottom-up at the same time. Combining the maps (with <code class="sourceCode haskell">(<span class="fu">.</span>)</code>) is done bottom-up, but building the codes is top-down. This means the codes are built in reverse order! That’s why the accumulating parameter (<code class="sourceCode haskell">k</code>) is a difference list, rather than a normal list. As it happens, if normal lists were used, the function would be slightly more efficient through sharing, but the codes would all be reversed.<a href="#fnref4" class="footnote-back">↩</a></p></li>
</ol>
</section>
]]></description>
    <pubDate>Sat, 17 Feb 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-02-17-single-pass-huffman.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Monadic List Functions</title>
    <link>https://doisinkidney.com/posts/2018-02-11-monadic-list.functions.html</link>
    <description><![CDATA[<div class="info">
    Posted on February 11, 2018
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Applicative.html">Applicative</a>
    
</div>

<p>Here’s an old Haskell chestnut:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> filterM (\_ <span class="ot">-&gt;</span> [<span class="dt">False</span>, <span class="dt">True</span>]) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">[[],[<span class="dv">3</span>],[<span class="dv">2</span>],[<span class="dv">2</span>,<span class="dv">3</span>],[<span class="dv">1</span>],[<span class="dv">1</span>,<span class="dv">3</span>],[<span class="dv">1</span>,<span class="dv">2</span>],[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]]</a></code></pre></div>
<p><code class="sourceCode haskell">filterM (\_ <span class="ot">-&gt;</span> [<span class="dt">False</span>,<span class="dt">True</span>])</code> gives the power set of some input list. It’s one of the especially magical demonstrations of monads. From a high-level perspective, it makes sense: for each element in the list, we want it to be present in one output, and not present in another. It’s hard to see how it actually <em>works</em>, though. The (old<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>) <a href="https://hackage.haskell.org/package/base-4.7.0.0/docs/src/Control-Monad.html#filterM">source</a> for <code class="sourceCode haskell">filterM</code> doesn’t help hugely, either:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">filterM          ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m [a]</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">filterM _ []     <span class="fu">=</span>  return []</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">filterM p (x<span class="fu">:</span>xs) <span class="fu">=</span>  <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">   flg <span class="ot">&lt;-</span> p x</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">   ys  <span class="ot">&lt;-</span> filterM p xs</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">   return (<span class="kw">if</span> flg <span class="kw">then</span> x<span class="fu">:</span>ys <span class="kw">else</span> ys)</a></code></pre></div>
<p>Again, elegant and beautiful (aside from the three-space indent), but opaque. Despite not really getting how it works, I was encouraged by its simplicity to try my hand at some of the other functions from Data.List.</p>
<h2 id="grouping">Grouping</h2>
<p>Let’s start with the subject of my <a href="2018-01-07-groupBy.html">last post</a>. Here’s the implementation:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">groupBy ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">groupBy p xs <span class="fu">=</span> build (\c n <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">  <span class="kw">let</span> f x a q</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">        <span class="fu">|</span> q x <span class="fu">=</span> (x <span class="fu">:</span> ys, zs)</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">        <span class="fu">|</span> otherwise <span class="fu">=</span> ([], c (x <span class="fu">:</span> ys) zs)</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">        <span class="kw">where</span> (ys,zs) <span class="fu">=</span> a (p x)</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">  <span class="kw">in</span> snd (foldr f (const ([], n)) xs (const <span class="dt">False</span>)))</a></code></pre></div>
<p>It translates over pretty readily:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">groupByM ::</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> m <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m [[a]]</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">groupByM p xs <span class="fu">=</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  fmap snd (foldr f (const (pure ([], []))) xs (const (pure (<span class="dt">False</span>))))</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5">    f x a q <span class="fu">=</span> liftA2 st (q x) (a (p x)) <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">      st b (ys,zs)</a>
<a class="sourceLine" id="cb4-7" data-line-number="7">        <span class="fu">|</span> b <span class="fu">=</span> (x <span class="fu">:</span> ys, zs)</a>
<a class="sourceLine" id="cb4-8" data-line-number="8">        <span class="fu">|</span> otherwise <span class="fu">=</span> ([], (x<span class="fu">:</span>ys)<span class="fu">:</span>zs)</a></code></pre></div>
<p>Let’s try it with a similar example to <code class="sourceCode haskell">filterM</code>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> groupByM (\_ _ <span class="ot">-&gt;</span> [<span class="dt">False</span>, <span class="dt">True</span>]) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">[[[<span class="dv">1</span>],[<span class="dv">2</span>],[<span class="dv">3</span>]],[[<span class="dv">1</span>],[<span class="dv">2</span>,<span class="dv">3</span>]],[[<span class="dv">1</span>,<span class="dv">2</span>],[<span class="dv">3</span>]],[[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]]]</a></code></pre></div>
<p>It gives the partitions of the list!</p>
<h2 id="sorting">Sorting</h2>
<p>So these monadic generalisations have been discovered before, several times over. There’s even a <a href="https://hackage.haskell.org/package/monadlist-0.0.2">package</a> with monadic versions of the functions in Data.List. Exploring this idea with a little more formality is the paper “All Sorts of Permutations” <span class="citation" data-cites="christiansen_all_2016">(Christiansen, Danilenko, and Dylus <a href="#ref-christiansen_all_2016">2016</a>)</span>, and accompanying presentation <a href="https://www.youtube.com/watch?v=vV3jqTxJ9Wc">on YouTube</a>. They show that the monadic version of sort produces permutations of the input list, and examine the output from different sorting algorithms. Here’s a couple of their implementations, altered slightly:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">insertM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> m <span class="dt">Bool</span>) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m [a]</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">insertM _ x [] <span class="fu">=</span> pure [x]</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">insertM p x yys<span class="fu">@</span>(y<span class="fu">:</span>ys) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">  lte <span class="ot">&lt;-</span> p x y</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">  <span class="kw">if</span> lte</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">    <span class="kw">then</span> pure (x<span class="fu">:</span>yys)</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">    <span class="kw">else</span> fmap (y<span class="fu">:</span>) (insertM p x ys)</a>
<a class="sourceLine" id="cb6-8" data-line-number="8"></a>
<a class="sourceLine" id="cb6-9" data-line-number="9"><span class="ot">insertSortM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> m <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m [a]</a>
<a class="sourceLine" id="cb6-10" data-line-number="10">insertSortM p <span class="fu">=</span> foldrM (insertM p) []</a>
<a class="sourceLine" id="cb6-11" data-line-number="11"></a>
<a class="sourceLine" id="cb6-12" data-line-number="12"><span class="ot">partitionM ::</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m ([a],[a])</a>
<a class="sourceLine" id="cb6-13" data-line-number="13">partitionM p <span class="fu">=</span> foldr f (pure ([],[])) <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-14" data-line-number="14">  f x <span class="fu">=</span> liftA2 ifStmt (p x) <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-15" data-line-number="15">    ifStmt flg (tr,fl)</a>
<a class="sourceLine" id="cb6-16" data-line-number="16">      <span class="fu">|</span> flg <span class="fu">=</span> (x<span class="fu">:</span>tr,fl)</a>
<a class="sourceLine" id="cb6-17" data-line-number="17">      <span class="fu">|</span> otherwise <span class="fu">=</span> (tr,x<span class="fu">:</span>fl)</a>
<a class="sourceLine" id="cb6-18" data-line-number="18">      </a>
<a class="sourceLine" id="cb6-19" data-line-number="19"><span class="ot">quickSortM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> m <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m [a]</a>
<a class="sourceLine" id="cb6-20" data-line-number="20">quickSortM p [] <span class="fu">=</span> pure []</a>
<a class="sourceLine" id="cb6-21" data-line-number="21">quickSortM p (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-22" data-line-number="22">  (gt,le) <span class="ot">&lt;-</span> partitionM (p x) xs</a>
<a class="sourceLine" id="cb6-23" data-line-number="23">  ls <span class="ot">&lt;-</span> quickSortM p le</a>
<a class="sourceLine" id="cb6-24" data-line-number="24">  gs <span class="ot">&lt;-</span> quickSortM p gt</a>
<a class="sourceLine" id="cb6-25" data-line-number="25">  pure (ls <span class="fu">++</span> [x] <span class="fu">++</span> gs)</a>
<a class="sourceLine" id="cb6-26" data-line-number="26"></a>
<a class="sourceLine" id="cb6-27" data-line-number="27"><span class="fu">&gt;&gt;&gt;</span> insertSortM (\_ _ <span class="ot">-&gt;</span> [<span class="dt">False</span>,<span class="dt">True</span>]) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb6-28" data-line-number="28">[[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>],[<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">2</span>],[<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">2</span>],[<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">3</span>],[<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">1</span>],[<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">1</span>]]</a>
<a class="sourceLine" id="cb6-29" data-line-number="29"></a>
<a class="sourceLine" id="cb6-30" data-line-number="30"><span class="fu">&gt;&gt;&gt;</span> quickSortM (\_ _ <span class="ot">-&gt;</span> [<span class="dt">False</span>,<span class="dt">True</span>]) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb6-31" data-line-number="31">[[<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">1</span>],[<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">1</span>],[<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">3</span>],[<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">2</span>],[<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">2</span>],[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]]</a></code></pre></div>
<p>As it should be easy to see, they’re very concise and elegant, and strongly resemble the pure versions of the algorithms.</p>
<h2 id="state">State</h2>
<p>So the examples above are very interesting and cool, but they don’t necessarily have a place in real Haskell code. If you wanted to find the permutations, partitions, or power set of a list you’d probably use a more standard implementation. That’s not to say that these monadic functions have no uses, though: especially when coupled with <code class="sourceCode haskell"><span class="dt">State</span></code> they yield readable and fast implementations for certain tricky functions. <code class="sourceCode haskell">ordNub</code>, for instance:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">ordNub ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">ordNub <span class="fu">=</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  flip evalState Set.empty <span class="fu">.</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">  filterM</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">    (\x <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6">       flg <span class="ot">&lt;-</span> gets (Set.notMember x)</a>
<a class="sourceLine" id="cb7-7" data-line-number="7">       when flg (modify (Set.insert x))</a>
<a class="sourceLine" id="cb7-8" data-line-number="8">       pure flg)</a></code></pre></div>
<p>Alternatively, using a monadic version of <code class="sourceCode haskell">maximumOn</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">maximumOnM ::</span> (<span class="dt">Applicative</span> m, <span class="dt">Ord</span> b) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m (<span class="dt">Maybe</span> a)</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">maximumOnM p <span class="fu">=</span> (fmap <span class="fu">.</span> fmap) snd <span class="fu">.</span> foldl f (pure <span class="dt">Nothing</span>)</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">    f a e <span class="fu">=</span> liftA2 g a (p e)</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">        g <span class="dt">Nothing</span> q <span class="fu">=</span> <span class="dt">Just</span> (q, e)</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">        g b<span class="fu">@</span>(<span class="dt">Just</span> (o, y)) q</a>
<a class="sourceLine" id="cb8-8" data-line-number="8">          <span class="fu">|</span> o <span class="fu">&lt;</span> q <span class="fu">=</span> <span class="dt">Just</span> (q, e)</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">          <span class="fu">|</span> otherwise <span class="fu">=</span> b</a></code></pre></div>
<p>You can write a one-pass <code class="sourceCode haskell">mostFrequent</code>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">mostFrequent ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">mostFrequent <span class="fu">=</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  flip evalState Map.empty <span class="fu">.</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4">  maximumOnM</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">    (\x <span class="ot">-&gt;</span> maybe <span class="dv">1</span> succ <span class="fu">&lt;$&gt;</span> state (Map.insertLookupWithKey (const (<span class="fu">+</span>)) x <span class="dv">1</span>))</a></code></pre></div>
<h2 id="decision-trees">Decision Trees</h2>
<p>One of the nicest things about the paper was the diagrams of decision trees provided for each sorting algorithm. I couldn’t find a library to do that for me, so I had a go at producing my own. First, we’ll need a data type to represent the tree itself:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">data</span> <span class="dt">DecTree</span> t a</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">Pure</span> a</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  <span class="fu">|</span> <span class="dt">Choice</span> t (<span class="dt">DecTree</span> t a) (<span class="dt">DecTree</span> t a)</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">  <span class="kw">deriving</span> <span class="dt">Functor</span></a></code></pre></div>
<p>We’ll say the left branch is “true” and the right “false”. Applicative and monad instances are relatively mechanical<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Applicative</span> (<span class="dt">DecTree</span> t) <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2">  pure <span class="fu">=</span> <span class="dt">Pure</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  <span class="dt">Pure</span> f <span class="fu">&lt;*&gt;</span> xs <span class="fu">=</span> fmap f xs</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">  <span class="dt">Choice</span> c ls rs <span class="fu">&lt;*&gt;</span> xs <span class="fu">=</span> <span class="dt">Choice</span> c (ls <span class="fu">&lt;*&gt;</span> xs) (rs <span class="fu">&lt;*&gt;</span> xs)</a>
<a class="sourceLine" id="cb11-5" data-line-number="5">  </a>
<a class="sourceLine" id="cb11-6" data-line-number="6"><span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">DecTree</span> t) <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-7" data-line-number="7">  <span class="dt">Pure</span> x <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> f x</a>
<a class="sourceLine" id="cb11-8" data-line-number="8">  <span class="dt">Choice</span> c ls rs <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">Choice</span> c (ls <span class="fu">&gt;&gt;=</span> f) (rs <span class="fu">&gt;&gt;=</span> f)</a></code></pre></div>
<p>We can now create a comparator function that constructs one of these trees, and remembers the values it was given:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="ot">traceCompare ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">DecTree</span> (a,a) <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">traceCompare x y <span class="fu">=</span> <span class="dt">Choice</span> (x,y) (<span class="dt">Pure</span> <span class="dt">True</span>) (<span class="dt">Pure</span> <span class="dt">False</span>)</a></code></pre></div>
<p>Finally, to draw the tree, I’ll use a function from my <a href="https://github.com/oisdk/binary-tree">binary tree</a> library:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="ot">printDecTree ::</span> (<span class="dt">Show</span> a, <span class="dt">Show</span> b) <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">DecTree</span> (a,a) b <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">printDecTree rel t <span class="fu">=</span> putStr (drawTreeWith id (go t) <span class="st">&quot;&quot;</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">  go (<span class="dt">Pure</span> xs) <span class="fu">=</span> <span class="dt">Node</span> (show xs) <span class="dt">Leaf</span> <span class="dt">Leaf</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4">  go (<span class="dt">Choice</span> (x,y) tr fl) <span class="fu">=</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5">    <span class="dt">Node</span> (show x <span class="fu">++</span> rel <span class="fu">++</span> show y) (go tr) (go fl)</a></code></pre></div>
<p>And we get these really nice diagrams out:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> (printDecTree <span class="st">&quot;&lt;=&quot;</span> <span class="fu">.</span> insertSortM traceCompare) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb14-2" data-line-number="2"></a>
<a class="sourceLine" id="cb14-3" data-line-number="3">         ┌[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb14-4" data-line-number="4">    ┌<span class="dv">1</span><span class="fu">&lt;=</span>2┤</a>
<a class="sourceLine" id="cb14-5" data-line-number="5">    │    │    ┌[<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb14-6" data-line-number="6">    │    └<span class="dv">1</span><span class="fu">&lt;=</span>3┤</a>
<a class="sourceLine" id="cb14-7" data-line-number="7">    │         └[<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb14-8" data-line-number="8"><span class="dv">2</span><span class="fu">&lt;=</span>3┤</a>
<a class="sourceLine" id="cb14-9" data-line-number="9">    │    ┌[<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">2</span>]</a>
<a class="sourceLine" id="cb14-10" data-line-number="10">    └<span class="dv">1</span><span class="fu">&lt;=</span>3┤</a>
<a class="sourceLine" id="cb14-11" data-line-number="11">         │    ┌[<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">2</span>]</a>
<a class="sourceLine" id="cb14-12" data-line-number="12">         └<span class="dv">1</span><span class="fu">&lt;=</span>2┤</a>
<a class="sourceLine" id="cb14-13" data-line-number="13">              └[<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb14-14" data-line-number="14"></a>
<a class="sourceLine" id="cb14-15" data-line-number="15"><span class="fu">&gt;&gt;&gt;</span> (printDecTree <span class="st">&quot;&lt;=&quot;</span> <span class="fu">.</span> quickSortM traceCompare) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb14-16" data-line-number="16"></a>
<a class="sourceLine" id="cb14-17" data-line-number="17">              ┌[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb14-18" data-line-number="18">         ┌<span class="dv">2</span><span class="fu">&lt;=</span>3┤</a>
<a class="sourceLine" id="cb14-19" data-line-number="19">         │    └[<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">2</span>]</a>
<a class="sourceLine" id="cb14-20" data-line-number="20">    ┌<span class="dv">1</span><span class="fu">&lt;=</span>3┤</a>
<a class="sourceLine" id="cb14-21" data-line-number="21">    │    └[<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">2</span>]</a>
<a class="sourceLine" id="cb14-22" data-line-number="22"><span class="dv">1</span><span class="fu">&lt;=</span>2┤</a>
<a class="sourceLine" id="cb14-23" data-line-number="23">    │    ┌[<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb14-24" data-line-number="24">    └<span class="dv">1</span><span class="fu">&lt;=</span>3┤</a>
<a class="sourceLine" id="cb14-25" data-line-number="25">         │    ┌[<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb14-26" data-line-number="26">         └<span class="dv">2</span><span class="fu">&lt;=</span>3┤</a>
<a class="sourceLine" id="cb14-27" data-line-number="27">              └[<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">1</span>]</a></code></pre></div>
<p>We can also try it out with the other monadic list functions:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> (printDecTree <span class="st">&quot;=&quot;</span> <span class="fu">.</span> groupByM traceCompare) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb15-2" data-line-number="2"></a>
<a class="sourceLine" id="cb15-3" data-line-number="3">       ┌[[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]]</a>
<a class="sourceLine" id="cb15-4" data-line-number="4">   ┌<span class="dv">2</span><span class="fu">=</span>3┤</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">   │   └[[<span class="dv">1</span>,<span class="dv">2</span>],[<span class="dv">3</span>]]</a>
<a class="sourceLine" id="cb15-6" data-line-number="6"><span class="dv">1</span><span class="fu">=</span>2┤</a>
<a class="sourceLine" id="cb15-7" data-line-number="7">   │   ┌[[<span class="dv">1</span>],[<span class="dv">2</span>,<span class="dv">3</span>]]</a>
<a class="sourceLine" id="cb15-8" data-line-number="8">   └<span class="dv">2</span><span class="fu">=</span>3┤</a>
<a class="sourceLine" id="cb15-9" data-line-number="9">       └[[<span class="dv">1</span>],[<span class="dv">2</span>],[<span class="dv">3</span>]]</a></code></pre></div>
<h2 id="applicative">Applicative</h2>
<p>You might notice that none of these “monadic” functions actually require a monad constraint: they’re all applicative. There’s a straightforward implementation that relies only on applicative for most of these functions, with a notable exception: sort. Getting <em>that</em> to work with just applicative is the subject of a future post.</p>
<h3 id="references" class="unnumbered">References</h3>
<div id="refs" class="references">
<div id="ref-christiansen_all_2016">
<p>Christiansen, Jan, Nikita Danilenko, and Sandra Dylus. 2016. “All Sorts of Permutations (Functional Pearl).” In <em>Proceedings of the 21st ACM SIGPLAN International Conference on Functional Programming</em>, 168–179. ICFP 2016. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/2951913.2951949">10.1145/2951913.2951949</a>. <a href="http://informatik.uni-kiel.de/~sad/icfp2016-preprint.pdf" class="uri">http://informatik.uni-kiel.de/~sad/icfp2016-preprint.pdf</a>.</p>
</div>
</div>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>The definition has since been <a href="https://hackage.haskell.org/package/base-4.10.1.0/docs/src/Control.Monad.html#filterM">updated</a> to more modern Haskell: it now uses a fold, and only requires <code class="sourceCode haskell"><span class="dt">Applicative</span></code>.<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>Part of the reason the instances are so mechanical is that this type strongly resembles the <a href="https://hackage.haskell.org/package/free-5/docs/Control-Monad-Free.html#t:Free">free monad</a>:</p>
<p><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Free</span> f a <span class="fu">=</span> <span class="dt">Pure</span> a <span class="fu">|</span> <span class="dt">Free</span> (f (<span class="dt">Free</span> f a))</code></p>
<p>In fact, the example given in the <code class="sourceCode haskell"><span class="dt">MonadFree</span></code> class is the following:</p>
<p><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Pair</span> a <span class="fu">=</span> <span class="dt">Pair</span> a a</code></p>
<p><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Tree</span> <span class="fu">=</span> <span class="dt">Free</span> <span class="dt">Pair</span></code></p>
<p>The only difference with the above type and the decision tree is that the decision tree carries a tag with it.</p>
<p>So what’s so interesting about this relationship? Well, <code class="sourceCode haskell"><span class="dt">Pair</span></code> is actually a <a href="https://hackage.haskell.org/package/adjunctions-4.4/docs/Data-Functor-Rep.html">representable functor</a>. Any representable functor <code class="sourceCode haskell">f a</code> can be converted to (and from) a function <code class="sourceCode haskell">key <span class="ot">-&gt;</span> a</code>, where <code class="sourceCode haskell">key</code> is the specific key for <code class="sourceCode haskell">f</code>. The key for <code class="sourceCode haskell"><span class="dt">Pair</span></code> is <code class="sourceCode haskell"><span class="dt">Bool</span></code>: the result of the function we passed in to the sorting functions!</p>
<p>In general, you can make a “decision tree” for any function of type <code class="sourceCode haskell">a <span class="ot">-&gt;</span> b</code> like so:</p>
<p><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">DecTree</span> a b r <span class="fu">=</span> <span class="dt">Rep</span> f <span class="fu">~</span> b <span class="ot">=&gt;</span> <span class="dt">Free</span> (<span class="dt">Compose</span> ((,) a) f) r</code></p>
<p>But more on that in a later post.<a href="#fnref2" class="footnote-back">↩</a></p></li>
</ol>
</section>
]]></description>
    <pubDate>Sun, 11 Feb 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-02-11-monadic-list.functions.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>groupBy</title>
    <link>https://doisinkidney.com/posts/2018-01-07-groupBy.html</link>
    <description><![CDATA[<div class="info">
    Posted on January  7, 2018
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Folds.html">Folds</a>
    
</div>

<p>Here’s a useful function from <a href="https://hackage.haskell.org/package/base-4.10.1.0/docs/Data-List.html#v:groupBy">Data.List</a>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">groupBy ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">groupBy (<span class="fu">==</span>) <span class="st">&quot;aabcdda&quot;</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="co">-- [&quot;aa&quot;,&quot;b&quot;,&quot;c&quot;,&quot;dd&quot;,&quot;a&quot;]</span></a></code></pre></div>
<p>However, as has been pointed out before<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>, <code class="sourceCode haskell">groupBy</code> expects an equivalence relation, and can exhibit surprising behavior when it doesn’t get one. Let’s say, for instance, that we wanted to group numbers that were close together:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">groupClose ::</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> [[<span class="dt">Integer</span>]]</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">groupClose <span class="fu">=</span> groupBy (\x y <span class="ot">-&gt;</span> abs (x <span class="fu">-</span> y) <span class="fu">&lt;</span> <span class="dv">3</span>)</a></code></pre></div>
<p>What would you expect on the list <code>[1, 2, 3, 4, 5]</code>? All in the same group? Well, what you actually get is:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1">[[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>],[<span class="dv">4</span>,<span class="dv">5</span>]]</a></code></pre></div>
<p>This is because the implementation of <code class="sourceCode haskell">groupBy</code> only compares to the first element in each group:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">groupBy _  []           <span class="fu">=</span>  []</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">groupBy eq (x<span class="fu">:</span>xs)       <span class="fu">=</span>  (x<span class="fu">:</span>ys) <span class="fu">:</span> groupBy eq zs</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">                           <span class="kw">where</span> (ys,zs) <span class="fu">=</span> span (eq x) xs</a></code></pre></div>
<p>Brandon Simmons gave a <a href="http://brandon.si/code/an-alternative-definition-for-datalistgroupby/">definition</a> of <code class="sourceCode haskell">groupBy</code> that is perhaps more useful, but it used explicit recursion, rather than a fold.</p>
<p>A definition with <code class="sourceCode haskell">foldr</code> turned out to be trickier than I expected. I found some of the laziness properties especially difficult:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> head (groupBy (<span class="fu">==</span>) (<span class="dv">1</span><span class="fu">:</span><span class="dv">2</span><span class="fu">:</span>undefined))</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">[<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="fu">&gt;&gt;&gt;</span> (head <span class="fu">.</span> head) (groupBy (<span class="fu">==</span>) (<span class="dv">1</span><span class="fu">:</span>undefined))</a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="dv">1</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5"><span class="fu">&gt;&gt;&gt;</span> (head <span class="fu">.</span> head <span class="fu">.</span> tail) (groupBy (<span class="fu">==</span>) (<span class="dv">1</span><span class="fu">:</span><span class="dv">2</span><span class="fu">:</span>undefined))</a>
<a class="sourceLine" id="cb5-6" data-line-number="6"><span class="dv">2</span></a></code></pre></div>
<p>Here’s the definition I came up with, after some deliberation:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">groupBy ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">groupBy p xs <span class="fu">=</span> build (\c n <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  <span class="kw">let</span> f x a q</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">        <span class="fu">|</span> q x <span class="fu">=</span> (x <span class="fu">:</span> ys, zs)</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">        <span class="fu">|</span> otherwise <span class="fu">=</span> ([], c (x <span class="fu">:</span> ys) zs)</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">        <span class="kw">where</span> (ys,zs) <span class="fu">=</span> a (p x)</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">  <span class="kw">in</span> snd (foldr f (const ([], n)) xs (const <span class="dt">False</span>)))</a>
<a class="sourceLine" id="cb6-8" data-line-number="8"><span class="ot">{-# INLINE groupBy #-}</span></a></code></pre></div>
<p>Seemingly benign changes to the function will break one or more of the above tests. In particular, the laziness of a “where” binding needs to be taken into account. Here’s an early attempt which failed:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">groupBy ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">groupBy p xs <span class="fu">=</span> build (\c n <span class="ot">-&gt;</span> </a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  <span class="kw">let</span> f x a q d</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">        <span class="fu">|</span> q x <span class="fu">=</span> a (p x) (d <span class="fu">.</span> (<span class="fu">:</span>) x)</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">        <span class="fu">|</span> otherwise <span class="fu">=</span> d [] (a (p x) (c <span class="fu">.</span> (<span class="fu">:</span>) x))</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">  <span class="kw">in</span> foldr f (\_ d <span class="ot">-&gt;</span> d [] n) xs (const <span class="dt">False</span>) (\ _ y <span class="ot">-&gt;</span> y))</a></code></pre></div>
<p>Once done, though, it works as expected:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> groupBy (<span class="fu">==</span>) <span class="st">&quot;aaabcccdda&quot;</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">[<span class="st">&quot;aaa&quot;</span>,<span class="st">&quot;b&quot;</span>,<span class="st">&quot;ccc&quot;</span>,<span class="st">&quot;dd&quot;</span>,<span class="st">&quot;a&quot;</span>]</a>
<a class="sourceLine" id="cb8-3" data-line-number="3"><span class="fu">&gt;&gt;&gt;</span> groupBy (<span class="fu">==</span>) []</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">[]</a>
<a class="sourceLine" id="cb8-5" data-line-number="5"><span class="fu">&gt;&gt;&gt;</span> groupBy (<span class="fu">&lt;=</span>) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">0</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">2</span>]</a>
<a class="sourceLine" id="cb8-6" data-line-number="6">[[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">3</span>],[<span class="dv">1</span>,<span class="dv">2</span>],[<span class="dv">0</span>,<span class="dv">4</span>,<span class="dv">5</span>],[<span class="dv">2</span>]]</a></code></pre></div>
<p>It’s the fastest version I could find that obeyed the above laziness properties.</p>
<p>The <a href="https://ghc.haskell.org/trac/ghc/ticket/13593">GHC page on the issue</a> unfortunately seems to indicate the implementation won’t be changed. Ah, well. Regardless, I have a <a href="https://github.com/oisdk/groupBy">repository</a> with the implementation above (with extra fusion machinery added) and comparisons to other implementations.</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>There are several threads on the libraries mailing list on this topic:</p>
<dl>
<dt>2006</dt>
<dd><a href="http://www.haskell.org/pipermail/haskell-cafe/2006-October/019148.html">mapAccumL - find max in-sequence subsequence</a>
</dd>
<dt>2007</dt>
<dd><a href="https://mail.haskell.org/pipermail/libraries/2007-August/008028.html">Data.List.groupBy with non-transitive equality predicate</a> (this is the longest discussion on the topic)
</dd>
<dt>2008</dt>
<dd><a href="https://mail.haskell.org/pipermail/libraries/2008-September/010629.html">Generalize groupBy in a useful way?</a>
</dd>
<dt>2009</dt>
<dd><a href="https://mail.haskell.org/pipermail/libraries/2009-June/011866.html">nubBy seems broken in recent GHCs</a>
</dd>
</dl>
<a href="#fnref1" class="footnote-back">↩</a></li>
</ol>
</section>
]]></description>
    <pubDate>Sun, 07 Jan 2018 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2018-01-07-groupBy.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Balancing Folds</title>
    <link>https://doisinkidney.com/posts/2017-10-30-balancing-folds.html</link>
    <description><![CDATA[<div class="info">
    Posted on October 30, 2017
</div>
<div class="info">
    
        Part 1 of a <a href="/series/Balanced%20Folds.html">3-part series on Balanced Folds</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Folds.html">Folds</a>
    
</div>

<p>There are three main ways to fold things in Haskell: from the right, from the left, and from either side. Let’s look at the left vs right variants first. <code class="sourceCode haskell">foldr</code> works from the right:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1">foldr (<span class="fu">+</span>) <span class="dv">0</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="dv">1</span> <span class="fu">+</span> (<span class="dv">2</span> <span class="fu">+</span> (<span class="dv">3</span> <span class="fu">+</span> <span class="dv">0</span>))</a></code></pre></div>
<p>And <code class="sourceCode haskell">foldl</code> from the left:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1">foldl (<span class="fu">+</span>) <span class="dv">0</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">((<span class="dv">0</span> <span class="fu">+</span> <span class="dv">1</span>) <span class="fu">+</span> <span class="dv">2</span>) <span class="fu">+</span> <span class="dv">3</span></a></code></pre></div>
<p>As you’ll notice, the result of the two operations above is the same (6; although one may take much longer than the other). In fact, <em>whenever</em> the result of <code class="sourceCode haskell">foldr</code> and <code class="sourceCode haskell">foldl</code> is the same for a pair of arguments (in this case <code class="sourceCode haskell"><span class="fu">+</span></code> and <code class="sourceCode haskell"><span class="dv">0</span></code>), we say that that pair forms a <a href="https://hackage.haskell.org/package/base-4.10.0.0/docs/Data-Monoid.html#t:Monoid"><code class="sourceCode haskell"><span class="dt">Monoid</span></code></a> for some type (well, there’s some extra stuff to do with <code class="sourceCode haskell"><span class="dv">0</span></code>, but I only care about associativity at the moment). In this case, the <a href="https://hackage.haskell.org/package/base-4.10.0.0/docs/Data-Monoid.html#t:Sum"><code class="sourceCode haskell"><span class="dt">Sum</span></code></a> monoid is formed:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Sum</span> a <span class="fu">=</span> <span class="dt">Sum</span> {<span class="ot"> getSum ::</span> a }</a>
<a class="sourceLine" id="cb3-2" data-line-number="2"></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="kw">instance</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Sum</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">  mempty <span class="fu">=</span> <span class="dt">Sum</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">  mappend (<span class="dt">Sum</span> x) (<span class="dt">Sum</span> y) <span class="fu">=</span> <span class="dt">Sum</span> (x <span class="fu">+</span> y)</a></code></pre></div>
<p>When you know that you have a monoid, you can use the <a href="https://hackage.haskell.org/package/base-4.10.0.0/docs/Data-Foldable.html#v:foldMap"><code class="sourceCode haskell">foldMap</code></a> function: this is the third kind of fold. It says that you don’t care which of <code class="sourceCode haskell">foldl</code> or <code class="sourceCode haskell">foldr</code> is used, so the implementer of <code class="sourceCode haskell">foldMap</code> can put the parentheses wherever they want:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">foldMap <span class="dt">Sum</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">(<span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span>) <span class="fu">+</span> (<span class="dv">3</span> <span class="fu">+</span> <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="dv">0</span> <span class="fu">+</span> ((<span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span>) <span class="fu">+</span> <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">((<span class="dv">0</span> <span class="fu">+</span> <span class="dv">1</span>) <span class="fu">+</span> <span class="dv">2</span>) <span class="fu">+</span> <span class="dv">3</span></a></code></pre></div>
<p>And we can’t tell the difference from the result. This is a pretty bare-bones introduction to folds and monoids: you won’t need to know more than that for the rest of this post, but the topic area is fascinating and deep, so don’t let me give you the impression that I’ve done anything more than scratched the surface.</p>
<h1 id="other-ways-to-fold">Other Ways to Fold</h1>
<p>Quite often, we <em>do</em> care about where the parentheses go. Take, for instance, a binary tree type, with values at the leaves:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">Empty</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  <span class="fu">|</span> <span class="dt">Leaf</span> a</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">  <span class="fu">|</span> <span class="dt">Tree</span> a <span class="fu">:*:</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb5-5" data-line-number="5"></a>
<a class="sourceLine" id="cb5-6" data-line-number="6"><span class="kw">instance</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb5-7" data-line-number="7">         <span class="dt">Show</span> (<span class="dt">Tree</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8">    show <span class="dt">Empty</span> <span class="fu">=</span> <span class="st">&quot;()&quot;</span></a>
<a class="sourceLine" id="cb5-9" data-line-number="9">    show (<span class="dt">Leaf</span> x) <span class="fu">=</span> show x</a>
<a class="sourceLine" id="cb5-10" data-line-number="10">    show (l <span class="fu">:*:</span> r) <span class="fu">=</span> <span class="st">&quot;(&quot;</span> <span class="fu">++</span> show l <span class="fu">++</span> <span class="st">&quot;*&quot;</span> <span class="fu">++</span> show r <span class="fu">++</span> <span class="st">&quot;)&quot;</span></a></code></pre></div>
<p>We can’t (well, shouldn’t) us <code class="sourceCode haskell">foldMap</code> here, because we would be able to tell the difference between different arrangements of parentheses:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> foldMap something [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb6-2" data-line-number="2"></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">((<span class="dv">1</span><span class="fu">*</span><span class="dv">2</span>)<span class="fu">*</span>(<span class="dv">3</span><span class="fu">*</span>())) │ (()<span class="fu">*</span>((<span class="dv">1</span><span class="fu">*</span><span class="dv">2</span>)<span class="fu">*</span><span class="dv">3</span>)) │ (((()<span class="fu">*</span><span class="dv">1</span>)<span class="fu">*</span><span class="dv">2</span>)<span class="fu">*</span><span class="dv">3</span>)</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">───────────────┼────────────────┼───────────────</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">       ┌<span class="dv">1</span>      │      ┌()       │       ┌()</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">      ┌┤       │      ┤         │      ┌┤</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">      │└<span class="dv">2</span>      │      │ ┌<span class="dv">1</span>      │      │└<span class="dv">1</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">      ┤        │      │┌┤       │     ┌┤</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">      │┌<span class="dv">3</span>      │      ││└<span class="dv">2</span>      │     │└<span class="dv">2</span></a>
<a class="sourceLine" id="cb6-10" data-line-number="10">      └┤       │      └┤        │     ┤</a>
<a class="sourceLine" id="cb6-11" data-line-number="11">       └()     │       └<span class="dv">3</span>       │     └<span class="dv">3</span></a></code></pre></div>
<p>So we use one of the folds which lets us choose the arrangements of parentheses:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> (foldr (<span class="fu">:*:</span>) <span class="dt">Empty</span> <span class="fu">.</span> map <span class="dt">Leaf</span>) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">(<span class="dv">1</span><span class="fu">*</span>(<span class="dv">2</span><span class="fu">*</span>(<span class="dv">3</span><span class="fu">*</span>(<span class="dv">4</span><span class="fu">*</span>(<span class="dv">5</span><span class="fu">*</span>(<span class="dv">6</span><span class="fu">*</span>()))))))</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">     ┌<span class="dv">1</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">    ┌┤</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">    │└<span class="dv">2</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6">   ┌┤</a>
<a class="sourceLine" id="cb7-7" data-line-number="7">   │└<span class="dv">3</span></a>
<a class="sourceLine" id="cb7-8" data-line-number="8">  ┌┤</a>
<a class="sourceLine" id="cb7-9" data-line-number="9">  │└<span class="dv">4</span></a>
<a class="sourceLine" id="cb7-10" data-line-number="10"> ┌┤</a>
<a class="sourceLine" id="cb7-11" data-line-number="11"> │└<span class="dv">5</span></a>
<a class="sourceLine" id="cb7-12" data-line-number="12">┌┤</a>
<a class="sourceLine" id="cb7-13" data-line-number="13">│└<span class="dv">6</span></a>
<a class="sourceLine" id="cb7-14" data-line-number="14">┤</a>
<a class="sourceLine" id="cb7-15" data-line-number="15">└()</a>
<a class="sourceLine" id="cb7-16" data-line-number="16"></a>
<a class="sourceLine" id="cb7-17" data-line-number="17"><span class="fu">&gt;&gt;&gt;</span> (foldl (<span class="fu">:*:</span>) <span class="dt">Empty</span> <span class="fu">.</span> map <span class="dt">Leaf</span>) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]</a>
<a class="sourceLine" id="cb7-18" data-line-number="18">((((((()<span class="fu">*</span><span class="dv">1</span>)<span class="fu">*</span><span class="dv">2</span>)<span class="fu">*</span><span class="dv">3</span>)<span class="fu">*</span><span class="dv">4</span>)<span class="fu">*</span><span class="dv">5</span>)<span class="fu">*</span><span class="dv">6</span>)</a>
<a class="sourceLine" id="cb7-19" data-line-number="19">┌()</a>
<a class="sourceLine" id="cb7-20" data-line-number="20">┤</a>
<a class="sourceLine" id="cb7-21" data-line-number="21">│┌<span class="dv">1</span></a>
<a class="sourceLine" id="cb7-22" data-line-number="22">└┤</a>
<a class="sourceLine" id="cb7-23" data-line-number="23"> │┌<span class="dv">2</span></a>
<a class="sourceLine" id="cb7-24" data-line-number="24"> └┤</a>
<a class="sourceLine" id="cb7-25" data-line-number="25">  │┌<span class="dv">3</span></a>
<a class="sourceLine" id="cb7-26" data-line-number="26">  └┤</a>
<a class="sourceLine" id="cb7-27" data-line-number="27">   │┌<span class="dv">4</span></a>
<a class="sourceLine" id="cb7-28" data-line-number="28">   └┤</a>
<a class="sourceLine" id="cb7-29" data-line-number="29">    │┌<span class="dv">5</span></a>
<a class="sourceLine" id="cb7-30" data-line-number="30">    └┤</a>
<a class="sourceLine" id="cb7-31" data-line-number="31">     └<span class="dv">6</span></a></code></pre></div>
<p>The issue is that neither of the trees generated are necessarily what we want: often, we want something more <em>balanced</em>.</p>
<h2 id="treefold">TreeFold</h2>
<p>To try and find a more balanced fold, let’s (for now) assume we’re always going to get non-empty input. This will let us simplify the <code class="sourceCode haskell"><span class="dt">Tree</span></code> type a little, to:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">Leaf</span> a</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  <span class="fu">|</span> <span class="dt">Tree</span> a <span class="fu">:*:</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">  <span class="kw">deriving</span> <span class="dt">Foldable</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5"></a>
<a class="sourceLine" id="cb8-6" data-line-number="6"><span class="kw">instance</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb8-7" data-line-number="7">         <span class="dt">Show</span> (<span class="dt">Tree</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8">    show (<span class="dt">Leaf</span> x) <span class="fu">=</span> show x</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">    show (l <span class="fu">:*:</span> r) <span class="fu">=</span> <span class="st">&quot;(&quot;</span> <span class="fu">++</span> show l <span class="fu">++</span> <span class="st">&quot;*&quot;</span> <span class="fu">++</span> show r <span class="fu">++</span> <span class="st">&quot;)&quot;</span></a></code></pre></div>
<p>Then, we can use Jon Fairbairn’s fold described in <a href="http://www.mail-archive.com/haskell@haskell.org/msg01788.html">this</a> email, adapted a bit for our non-empty input:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Data.List.NonEmpty</span> (<span class="dt">NonEmpty</span>(..))</a>
<a class="sourceLine" id="cb9-2" data-line-number="2"></a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="ot">treeFold ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">NonEmpty</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">treeFold f <span class="fu">=</span> go</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6">    go (x <span class="fu">:|</span> []) <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">    go (a <span class="fu">:|</span> b<span class="fu">:</span>l) <span class="fu">=</span> go (f a b <span class="fu">:|</span> pairMap l)</a>
<a class="sourceLine" id="cb9-8" data-line-number="8">    pairMap (x<span class="fu">:</span>y<span class="fu">:</span>rest) <span class="fu">=</span> f x y <span class="fu">:</span> pairMap rest</a>
<a class="sourceLine" id="cb9-9" data-line-number="9">    pairMap xs <span class="fu">=</span> xs</a></code></pre></div>
<p>There are two parts to this function: <code class="sourceCode haskell">pairMap</code> and the <code class="sourceCode haskell">go</code> helper. <code class="sourceCode haskell">pairMap</code> combines adjacent elements in the list using the combining function. As a top-level function it might look like this:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">pairMap f (x<span class="fu">:</span>y<span class="fu">:</span>rest) <span class="fu">=</span> f x y <span class="fu">:</span> pairMap f rest</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">pairMap f xs <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb10-3" data-line-number="3"></a>
<a class="sourceLine" id="cb10-4" data-line-number="4">pairMap (<span class="fu">++</span>) [<span class="st">&quot;a&quot;</span>,<span class="st">&quot;b&quot;</span>,<span class="st">&quot;c&quot;</span>,<span class="st">&quot;d&quot;</span>,<span class="st">&quot;e&quot;</span>]</a>
<a class="sourceLine" id="cb10-5" data-line-number="5"><span class="co">-- [&quot;ab&quot;,&quot;cd&quot;,&quot;e&quot;]</span></a></code></pre></div>
<p>As you can see, it leaves any leftovers untouched at the end of the list.</p>
<p>The <code class="sourceCode haskell">go</code> helper applies <code class="sourceCode haskell">pairMap</code> repeatedly to the list until it has only one element. This gives us much more balanced results that <code class="sourceCode haskell">foldl</code> or <code class="sourceCode haskell">foldr</code> (turn on <code class="sourceCode haskell"><span class="fu">-</span><span class="dt">XOverloadedLists</span></code> to write non-empty lists using this syntax):</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> (treeFold (<span class="fu">:*:</span>) <span class="fu">.</span> fmap <span class="dt">Leaf</span>) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">(((<span class="dv">1</span><span class="fu">*</span><span class="dv">2</span>)<span class="fu">*</span>(<span class="dv">3</span><span class="fu">*</span><span class="dv">4</span>))<span class="fu">*</span>(<span class="dv">5</span><span class="fu">*</span><span class="dv">6</span>))</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  ┌<span class="dv">1</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4"> ┌┤</a>
<a class="sourceLine" id="cb11-5" data-line-number="5"> │└<span class="dv">2</span></a>
<a class="sourceLine" id="cb11-6" data-line-number="6">┌┤</a>
<a class="sourceLine" id="cb11-7" data-line-number="7">││┌<span class="dv">3</span></a>
<a class="sourceLine" id="cb11-8" data-line-number="8">│└┤</a>
<a class="sourceLine" id="cb11-9" data-line-number="9">│ └<span class="dv">4</span></a>
<a class="sourceLine" id="cb11-10" data-line-number="10">┤</a>
<a class="sourceLine" id="cb11-11" data-line-number="11">│┌<span class="dv">5</span></a>
<a class="sourceLine" id="cb11-12" data-line-number="12">└┤</a>
<a class="sourceLine" id="cb11-13" data-line-number="13"> └<span class="dv">6</span></a>
<a class="sourceLine" id="cb11-14" data-line-number="14"></a>
<a class="sourceLine" id="cb11-15" data-line-number="15"><span class="fu">&gt;&gt;&gt;</span> (treeFold (<span class="fu">:*:</span>) <span class="fu">.</span> fmap <span class="dt">Leaf</span>) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>]</a>
<a class="sourceLine" id="cb11-16" data-line-number="16">(((<span class="dv">1</span><span class="fu">*</span><span class="dv">2</span>)<span class="fu">*</span>(<span class="dv">3</span><span class="fu">*</span><span class="dv">4</span>))<span class="fu">*</span>((<span class="dv">5</span><span class="fu">*</span><span class="dv">6</span>)<span class="fu">*</span>(<span class="dv">7</span><span class="fu">*</span><span class="dv">8</span>)))</a>
<a class="sourceLine" id="cb11-17" data-line-number="17">  ┌<span class="dv">1</span></a>
<a class="sourceLine" id="cb11-18" data-line-number="18"> ┌┤</a>
<a class="sourceLine" id="cb11-19" data-line-number="19"> │└<span class="dv">2</span></a>
<a class="sourceLine" id="cb11-20" data-line-number="20">┌┤</a>
<a class="sourceLine" id="cb11-21" data-line-number="21">││┌<span class="dv">3</span></a>
<a class="sourceLine" id="cb11-22" data-line-number="22">│└┤</a>
<a class="sourceLine" id="cb11-23" data-line-number="23">│ └<span class="dv">4</span></a>
<a class="sourceLine" id="cb11-24" data-line-number="24">┤</a>
<a class="sourceLine" id="cb11-25" data-line-number="25">│ ┌<span class="dv">5</span></a>
<a class="sourceLine" id="cb11-26" data-line-number="26">│┌┤</a>
<a class="sourceLine" id="cb11-27" data-line-number="27">││└<span class="dv">6</span></a>
<a class="sourceLine" id="cb11-28" data-line-number="28">└┤</a>
<a class="sourceLine" id="cb11-29" data-line-number="29"> │┌<span class="dv">7</span></a>
<a class="sourceLine" id="cb11-30" data-line-number="30"> └┤</a>
<a class="sourceLine" id="cb11-31" data-line-number="31">  └<span class="dv">8</span></a></code></pre></div>
<p>However, there are still cases where one branch will be much larger than its sibling. The fold fills a balanced binary tree from the left, but any leftover elements are put at the top level. In other words:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> (treeFold (<span class="fu">:*:</span>) <span class="fu">.</span> fmap <span class="dt">Leaf</span>) [<span class="dv">1</span><span class="fu">..</span><span class="dv">9</span>]</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">((((<span class="dv">1</span><span class="fu">*</span><span class="dv">2</span>)<span class="fu">*</span>(<span class="dv">3</span><span class="fu">*</span><span class="dv">4</span>))<span class="fu">*</span>((<span class="dv">5</span><span class="fu">*</span><span class="dv">6</span>)<span class="fu">*</span>(<span class="dv">7</span><span class="fu">*</span><span class="dv">8</span>)))<span class="fu">*</span><span class="dv">9</span>)</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">   ┌<span class="dv">1</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">  ┌┤</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">  │└<span class="dv">2</span></a>
<a class="sourceLine" id="cb12-6" data-line-number="6"> ┌┤</a>
<a class="sourceLine" id="cb12-7" data-line-number="7"> ││┌<span class="dv">3</span></a>
<a class="sourceLine" id="cb12-8" data-line-number="8"> │└┤</a>
<a class="sourceLine" id="cb12-9" data-line-number="9"> │ └<span class="dv">4</span></a>
<a class="sourceLine" id="cb12-10" data-line-number="10">┌┤</a>
<a class="sourceLine" id="cb12-11" data-line-number="11">││ ┌<span class="dv">5</span></a>
<a class="sourceLine" id="cb12-12" data-line-number="12">││┌┤</a>
<a class="sourceLine" id="cb12-13" data-line-number="13">│││└<span class="dv">6</span></a>
<a class="sourceLine" id="cb12-14" data-line-number="14">│└┤</a>
<a class="sourceLine" id="cb12-15" data-line-number="15">│ │┌<span class="dv">7</span></a>
<a class="sourceLine" id="cb12-16" data-line-number="16">│ └┤</a>
<a class="sourceLine" id="cb12-17" data-line-number="17">│  └<span class="dv">8</span></a>
<a class="sourceLine" id="cb12-18" data-line-number="18">┤</a>
<a class="sourceLine" id="cb12-19" data-line-number="19">└<span class="dv">9</span></a></code></pre></div>
<p>That <code class="sourceCode haskell"><span class="dv">9</span></code> hanging out on its own there is a problem.</p>
<h2 id="typewriters-and-slaloms">Typewriters and Slaloms</h2>
<p>One observation we can make is that <code class="sourceCode haskell">pairMap</code> always starts from the same side on each iteration, like a typewriter moving from one line to the next. This has the consequence of building up the leftovers on one side, leaving them until the top level.</p>
<p>We can improve the situation slightly by going back and forth, slalom-style, so we consume leftovers on each iteration:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="ot">treeFold ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">NonEmpty</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">treeFold f <span class="fu">=</span> goTo <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">  </a>
<a class="sourceLine" id="cb13-4" data-line-number="4">  goTo (y <span class="fu">:|</span> []) <span class="fu">=</span> y</a>
<a class="sourceLine" id="cb13-5" data-line-number="5">  goTo (a <span class="fu">:|</span> b <span class="fu">:</span> rest) <span class="fu">=</span> goFro (pairMap f (f a b) rest)</a>
<a class="sourceLine" id="cb13-6" data-line-number="6">  goFro (y <span class="fu">:|</span> []) <span class="fu">=</span> y</a>
<a class="sourceLine" id="cb13-7" data-line-number="7">  goFro (a <span class="fu">:|</span> b <span class="fu">:</span> rest) <span class="fu">=</span> goTo (pairMap (flip f) (f b a) rest)</a>
<a class="sourceLine" id="cb13-8" data-line-number="8"></a>
<a class="sourceLine" id="cb13-9" data-line-number="9">  pairMap f <span class="fu">=</span> go [] <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-10" data-line-number="10">    go ys y (a<span class="fu">:</span>b<span class="fu">:</span>rest) <span class="fu">=</span> go (y<span class="fu">:</span>ys) (f a b) rest</a>
<a class="sourceLine" id="cb13-11" data-line-number="11">    go ys y [z] <span class="fu">=</span> z <span class="fu">:|</span> y <span class="fu">:</span> ys</a>
<a class="sourceLine" id="cb13-12" data-line-number="12">    go ys y [] <span class="fu">=</span> y <span class="fu">:|</span> ys</a></code></pre></div>
<p>Notice that we have to flip the combining function to make sure the ordering is the same on output. For the earlier example, this solves the issue:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> (treeFold (<span class="fu">:*:</span>) <span class="fu">.</span> fmap <span class="dt">Leaf</span>) [<span class="dv">1</span><span class="fu">..</span><span class="dv">9</span>]</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">(((<span class="dv">1</span><span class="fu">*</span><span class="dv">2</span>)<span class="fu">*</span>((<span class="dv">3</span><span class="fu">*</span><span class="dv">4</span>)<span class="fu">*</span>(<span class="dv">5</span><span class="fu">*</span><span class="dv">6</span>)))<span class="fu">*</span>((<span class="dv">7</span><span class="fu">*</span><span class="dv">8</span>)<span class="fu">*</span><span class="dv">9</span>))</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">  ┌<span class="dv">1</span></a>
<a class="sourceLine" id="cb14-4" data-line-number="4"> ┌┤</a>
<a class="sourceLine" id="cb14-5" data-line-number="5"> │└<span class="dv">2</span></a>
<a class="sourceLine" id="cb14-6" data-line-number="6">┌┤</a>
<a class="sourceLine" id="cb14-7" data-line-number="7">││ ┌<span class="dv">3</span></a>
<a class="sourceLine" id="cb14-8" data-line-number="8">││┌┤</a>
<a class="sourceLine" id="cb14-9" data-line-number="9">│││└<span class="dv">4</span></a>
<a class="sourceLine" id="cb14-10" data-line-number="10">│└┤</a>
<a class="sourceLine" id="cb14-11" data-line-number="11">│ │┌<span class="dv">5</span></a>
<a class="sourceLine" id="cb14-12" data-line-number="12">│ └┤</a>
<a class="sourceLine" id="cb14-13" data-line-number="13">│  └<span class="dv">6</span></a>
<a class="sourceLine" id="cb14-14" data-line-number="14">┤</a>
<a class="sourceLine" id="cb14-15" data-line-number="15">│ ┌<span class="dv">7</span></a>
<a class="sourceLine" id="cb14-16" data-line-number="16">│┌┤</a>
<a class="sourceLine" id="cb14-17" data-line-number="17">││└<span class="dv">8</span></a>
<a class="sourceLine" id="cb14-18" data-line-number="18">└┤</a>
<a class="sourceLine" id="cb14-19" data-line-number="19"> └<span class="dv">9</span></a></code></pre></div>
<p>It does <em>not</em> build up the tree as balanced as it possibly could, though:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> (treeFold (<span class="fu">:*:</span>) <span class="fu">.</span> fmap <span class="dt">Leaf</span>) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">((<span class="dv">1</span><span class="fu">*</span><span class="dv">2</span>)<span class="fu">*</span>((<span class="dv">3</span><span class="fu">*</span><span class="dv">4</span>)<span class="fu">*</span>(<span class="dv">5</span><span class="fu">*</span><span class="dv">6</span>)))</a>
<a class="sourceLine" id="cb15-3" data-line-number="3"> ┌<span class="dv">1</span></a>
<a class="sourceLine" id="cb15-4" data-line-number="4">┌┤</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">│└<span class="dv">2</span></a>
<a class="sourceLine" id="cb15-6" data-line-number="6">┤</a>
<a class="sourceLine" id="cb15-7" data-line-number="7">│ ┌<span class="dv">3</span></a>
<a class="sourceLine" id="cb15-8" data-line-number="8">│┌┤</a>
<a class="sourceLine" id="cb15-9" data-line-number="9">││└<span class="dv">4</span></a>
<a class="sourceLine" id="cb15-10" data-line-number="10">└┤</a>
<a class="sourceLine" id="cb15-11" data-line-number="11"> │┌<span class="dv">5</span></a>
<a class="sourceLine" id="cb15-12" data-line-number="12"> └┤</a>
<a class="sourceLine" id="cb15-13" data-line-number="13">  └<span class="dv">6</span></a></code></pre></div>
<p>There’s four elements in the right branch, and two in the left in the above example. Three in each would be optimal.</p>
<p>Wait—optimal in what sense, exactly? What do we mean when we say one tree is more balanced than another? Let’s say the “balance factor” is the largest difference in size of two sibling trees:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="ot">balFac ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2">balFac <span class="fu">=</span> fst <span class="fu">.</span> go <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3"><span class="ot">  go ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> (<span class="dt">Integer</span>, <span class="dt">Integer</span>)</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">  go (<span class="dt">Leaf</span> _) <span class="fu">=</span> (<span class="dv">0</span>, <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb16-5" data-line-number="5">  go (l <span class="fu">:*:</span> r) <span class="fu">=</span> (lb <span class="ot">`max`</span> rb <span class="ot">`max`</span> abs (rs <span class="fu">-</span> ls), rs <span class="fu">+</span> ls) <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-6" data-line-number="6">    (lb,ls) <span class="fu">=</span> go l</a>
<a class="sourceLine" id="cb16-7" data-line-number="7">    (rb,rs) <span class="fu">=</span> go r</a></code></pre></div>
<p>And one tree is more balanced than another if it has a smaller balance factor.</p>
<p>There’s effectively no limit on the balance factor for the typewriter method: when the input is one larger than a power of two, it’ll stick the one extra in one branch and the rest in another (as with <code class="sourceCode haskell">[<span class="dv">1</span><span class="fu">..</span><span class="dv">9</span>]</code> in the example above).</p>
<p>For the slalom method, it looks like there’s something more interesting going on, limit-wise. I haven’t been able to verify this formally (yet), but from what I can tell, a tree of height <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> will have at most a balance factor of the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>th <a href="https://oeis.org/A001045">Jacobsthal number</a>. That’s (apparently) also the number of ways to tie a tie using <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n + 2</annotation></semantics></math> turns.</p>
<p>That was just gathered from some quick experiments and <a href="https://oeis.org/">oeis.org</a>, but it seems to make sense intuitively. Jacobsthal numbers are defined like this:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1">j <span class="dv">0</span> <span class="fu">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2">j <span class="dv">1</span> <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb17-3" data-line-number="3">j n <span class="fu">=</span> j (n<span class="fu">-</span><span class="dv">1</span>) <span class="fu">+</span> <span class="dv">2</span> <span class="fu">*</span> j (n<span class="fu">-</span><span class="dv">2</span>)</a></code></pre></div>
<p>So, at the top level, there’s the imbalance caused by the second-last <code class="sourceCode haskell">pairFold</code>, plus the imbalance caused by the third-to-last. However, the third-to-last imbalance is twice what it was at that level, because it is now working with an already-paired-up list. Why isn’t the second last imbalance also doubled? Because it’s counteracted by the fact that we turned around: the imbalance is in an element that’s a leftover element. At least that’s what my intuition is at this point.</p>
<p>The minimum balance factor is, of course, one. Unfortunately, to achieve that, I lost some of the properties of the previous folds:</p>
<h2 id="lengths">Lengths</h2>
<p>Up until now, I have been avoiding taking the length of the incoming list. It would lose a lot of laziness, cause an extra traversal, and generally seems like an ugly solution. Nonetheless, it gives the most balanced results I could find so far:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="ot">treeFold ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">NonEmpty</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">treeFold f (x<span class="fu">:|</span>xs) <span class="fu">=</span> go (length (x<span class="fu">:</span>xs)) (x<span class="fu">:</span>xs) <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3">  go <span class="dv">1</span> [y] <span class="fu">=</span> y</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">  go n ys <span class="fu">=</span> f (go m a) (go (n<span class="fu">-</span>m) b) <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-5" data-line-number="5">    (a,b) <span class="fu">=</span> splitAt m ys </a>
<a class="sourceLine" id="cb18-6" data-line-number="6">    m <span class="fu">=</span> n <span class="ot">`div`</span> <span class="dv">2</span></a></code></pre></div>
<p><code class="sourceCode haskell">splitAt</code> is an inefficient operation, but if we let the left-hand call return its unused input from the list, we can avoid it:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="ot">treeFold ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">NonEmpty</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">treeFold f (x<span class="fu">:|</span>xs) <span class="fu">=</span> fst (go (length (x<span class="fu">:</span>xs)) (x<span class="fu">:</span>xs)) <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-3" data-line-number="3">  go <span class="dv">1</span> (y<span class="fu">:</span>ys) <span class="fu">=</span> (y,ys)</a>
<a class="sourceLine" id="cb19-4" data-line-number="4">  go n ys <span class="fu">=</span> (f l r, rs) <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-5" data-line-number="5">    (l,ls) <span class="fu">=</span> go m ys</a>
<a class="sourceLine" id="cb19-6" data-line-number="6">    (r,rs) <span class="fu">=</span> go (n<span class="fu">-</span>m) ls</a>
<a class="sourceLine" id="cb19-7" data-line-number="7">    m <span class="fu">=</span> n <span class="ot">`div`</span> <span class="dv">2</span></a></code></pre></div>
<p>Finally, you may have spotted the state monad in this last version. We can make the similarity explicit:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="ot">treeFold ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">NonEmpty</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb20-2" data-line-number="2">treeFold f (x<span class="fu">:|</span>xs) <span class="fu">=</span> evalState (go (length (x<span class="fu">:</span>xs))) (x<span class="fu">:</span>xs) <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-3" data-line-number="3">  go <span class="dv">1</span> <span class="fu">=</span> state (\(y<span class="fu">:</span>ys) <span class="ot">-&gt;</span> (y,ys))</a>
<a class="sourceLine" id="cb20-4" data-line-number="4">  go n <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb20-5" data-line-number="5">    <span class="kw">let</span> m <span class="fu">=</span> n <span class="ot">`div`</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb20-6" data-line-number="6">    l <span class="ot">&lt;-</span> go m</a>
<a class="sourceLine" id="cb20-7" data-line-number="7">    r <span class="ot">&lt;-</span> go (n<span class="fu">-</span>m)</a>
<a class="sourceLine" id="cb20-8" data-line-number="8">    return (f l r)</a></code></pre></div>
<p>And there you have it: three different ways to fold in a more balanced way. Perhaps surprisingly, the first is the fastest in my tests. I’d love to hear if there’s a more balanced version (which is lazy, ideally) that is just as efficient as the first implementation.</p>
<h1 id="stable-summation">Stable Summation</h1>
<p>I have found two other uses for these folds other than simply constructing more balanced binary trees. The first is summation of floating-point numbers. If you sum floating-point numbers in the usual way with <code class="sourceCode haskell">foldl&#39;</code> (or, indeed, with an accumulator in an imperative language), you will see an error growth of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n)</annotation></semantics></math>, where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> is the number of floats you’re summing.</p>
<p>A well-known solution to this problem is the <a href="https://en.wikipedia.org/wiki/Kahan_summation_algorithm">Kahan summation algorithm</a>. It carries with it a running compensation for accumulating errors, giving it <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math> error growth. There are two downsides to the algorithm: it takes four times the number of numerical operations to perform, and isn’t parallel.</p>
<p>For that reason, it’s often not used in practice: instead, floats are summed <em>pairwise</em>, in a manner often referred to as <a href="https://en.wikipedia.org/wiki/Pairwise_summation">cascade summation</a>. This is what’s used in <a href="https://github.com/numpy/numpy/pull/3685">NumPy</a>. The error growth isn’t quite as good—<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒪</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\log{n})</annotation></semantics></math>—but it takes the exact same number of operations as normal summation. On top of that:</p>
<h1 id="parallelization">Parallelization</h1>
<p>Dividing a fold into roughly-equal chunks is exactly the kind of problem encountered when trying to parallelize certain algorithms. Adapting the folds above so that their work is performed in parallel is surprisingly easy:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="ot">splitPar ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">splitPar f <span class="fu">=</span> go</a>
<a class="sourceLine" id="cb21-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-4" data-line-number="4">    go l r <span class="dv">0</span> <span class="fu">=</span> f (l <span class="dv">0</span>) (r <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb21-5" data-line-number="5">    go l r n <span class="fu">=</span> lt <span class="ot">`par`</span> (rt <span class="ot">`pseq`</span> f lt rt)</a>
<a class="sourceLine" id="cb21-6" data-line-number="6">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-7" data-line-number="7">        lt <span class="fu">=</span> l (n<span class="fu">-</span>m)</a>
<a class="sourceLine" id="cb21-8" data-line-number="8">        rt <span class="fu">=</span> r m</a>
<a class="sourceLine" id="cb21-9" data-line-number="9">        m <span class="fu">=</span> n <span class="ot">`div`</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb21-10" data-line-number="10"></a>
<a class="sourceLine" id="cb21-11" data-line-number="11"><span class="ot">treeFoldParallel ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">NonEmpty</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb21-12" data-line-number="12">treeFoldParallel f xs <span class="fu">=</span></a>
<a class="sourceLine" id="cb21-13" data-line-number="13">    treeFold const (splitPar f) xs numCapabilities</a></code></pre></div>
<p>The above will split the fold into <code class="sourceCode haskell">numCapabilities</code> chunks, and perform each one in parallel. <code class="sourceCode haskell">numCapabilities</code> is a constant defined in <a href="https://hackage.haskell.org/package/base-4.10.0.0/docs/GHC-Conc.html">GHC.Conc</a>: it’s the number of threads which can be run simultaneously at any one time. Alternatively, you could the function include a parameter for how many chunks to split the computation into. You could also have the fold adapt as it went, choosing whether or not to spark based on how many sparks exist at any given time:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="ot">parseq ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb22-2" data-line-number="2">parseq a b <span class="fu">=</span></a>
<a class="sourceLine" id="cb22-3" data-line-number="3">    runST</a>
<a class="sourceLine" id="cb22-4" data-line-number="4">        (bool (par a b) (seq a b) <span class="fu">&lt;$&gt;</span></a>
<a class="sourceLine" id="cb22-5" data-line-number="5">         unsafeIOToST (liftA2 (<span class="fu">&gt;</span>) numSparks getNumCapabilities))</a>
<a class="sourceLine" id="cb22-6" data-line-number="6"></a>
<a class="sourceLine" id="cb22-7" data-line-number="7"><span class="ot">treeFoldAdaptive ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb22-8" data-line-number="8">treeFoldAdaptive f <span class="fu">=</span></a>
<a class="sourceLine" id="cb22-9" data-line-number="9">    Lazy.treeFold</a>
<a class="sourceLine" id="cb22-10" data-line-number="10">        (\l r <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb22-11" data-line-number="11">              r <span class="ot">`parseq`</span> (l <span class="ot">`parseq`</span> f l r))</a></code></pre></div>
<p>Adapted from <a href="https://www.reddit.com/r/haskell/comments/73umrw/another_parallelism_primitive_parseq/dnurduu/?utm_content=permalink&amp;utm_medium=front&amp;utm_source=reddit&amp;utm_name=haskell">this</a> comment by Edward Kmett. This is actually the fastest version of all the folds.</p>
<p>All of this is provided in a <a href="https://hackage.haskell.org/package/treefold">library</a> I’ve put up on Hackage.</p>
]]></description>
    <pubDate>Mon, 30 Oct 2017 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2017-10-30-balancing-folds.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Convolutions and Semirings</title>
    <link>https://doisinkidney.com/posts/2017-10-13-convolutions-and-semirings.html</link>
    <description><![CDATA[<div class="info">
    Posted on October 13, 2017
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Semirings.html">Semirings</a>
    
</div>

<p>I have been working a little more on my <a href="https://hackage.haskell.org/package/semiring-num">semirings library</a> recently, and I have come across some interesting functions in the process. First, a quick recap on the <code class="sourceCode haskell"><span class="dt">Semiring</span></code> class and some related functions:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Semiring</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="ot">  one ::</span> a</a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="ot">  zero ::</span> a</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">  <span class="kw">infixl</span> <span class="dv">6</span> <span class="fu">&lt;+&gt;</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="ot">  (&lt;+&gt;) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">  <span class="kw">infixl</span> <span class="dv">7</span> <span class="fu">&lt;.&gt;</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="ot">  (&lt;.&gt;) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb1-8" data-line-number="8"></a>
<a class="sourceLine" id="cb1-9" data-line-number="9"><span class="ot">add ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Semiring</span> a) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb1-10" data-line-number="10">add <span class="fu">=</span> foldl&#39; (<span class="fu">&lt;+&gt;</span>) zero</a>
<a class="sourceLine" id="cb1-11" data-line-number="11"></a>
<a class="sourceLine" id="cb1-12" data-line-number="12"><span class="ot">mul ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Semiring</span> a) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb1-13" data-line-number="13">mul <span class="fu">=</span> foldl&#39; (<span class="fu">&lt;.&gt;</span>) one</a>
<a class="sourceLine" id="cb1-14" data-line-number="14"></a>
<a class="sourceLine" id="cb1-15" data-line-number="15"><span class="kw">instance</span> <span class="dt">Semiring</span> <span class="dt">Integer</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-16" data-line-number="16">  one <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-17" data-line-number="17">  zero <span class="fu">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb1-18" data-line-number="18">  (<span class="fu">&lt;+&gt;</span>) <span class="fu">=</span> (<span class="fu">+</span>)</a>
<a class="sourceLine" id="cb1-19" data-line-number="19">  (<span class="fu">&lt;.&gt;</span>) <span class="fu">=</span> (<span class="fu">*</span>)</a>
<a class="sourceLine" id="cb1-20" data-line-number="20"></a>
<a class="sourceLine" id="cb1-21" data-line-number="21"><span class="kw">instance</span> <span class="dt">Semiring</span> <span class="dt">Bool</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-22" data-line-number="22">  one <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb1-23" data-line-number="23">  zero <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb1-24" data-line-number="24">  (<span class="fu">&lt;+&gt;</span>) <span class="fu">=</span> (<span class="fu">||</span>)</a>
<a class="sourceLine" id="cb1-25" data-line-number="25">  (<span class="fu">&lt;.&gt;</span>) <span class="fu">=</span> (<span class="fu">&amp;&amp;</span>)</a></code></pre></div>
<p>You can think of it as a replacement for <code class="sourceCode haskell"><span class="dt">Num</span></code>, but it turns out to be much more generally useful than that.</p>
<h1 id="matrix-multiplication">Matrix Multiplication</h1>
<p>The first interesting function is to do with matrix multiplication. Here’s the code for multiplying two matrices represented as nested lists:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">mulMatrix ::</span> <span class="dt">Semiring</span> a <span class="ot">=&gt;</span> [[a]] <span class="ot">-&gt;</span> [[a]] <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">mulMatrix xs ys <span class="fu">=</span> map (\row <span class="ot">-&gt;</span> map (add <span class="fu">.</span> zipWith (<span class="fu">&lt;.&gt;</span>) row) cs) xs</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">    cs <span class="fu">=</span> transpose ys</a></code></pre></div>
<p>One of the issues with this code (other than its woeful performance) is that it seems needlessly list-specific. <code class="sourceCode haskell">zipWith</code> seems like the kind of thing that exists on a bunch of different structures. Indeed, the <a href="https://hackage.haskell.org/package/base-4.10.0.0/docs/Control-Applicative.html#t:ZipList"><code class="sourceCode haskell"><span class="dt">ZipList</span></code> wrapper</a> uses <code class="sourceCode haskell">zipWith</code> as its <code class="sourceCode haskell"><span class="fu">&lt;*&gt;</span></code> implementation. Let’s try that for now:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">mulMatrix ::</span> (<span class="dt">Semiring</span> a, <span class="dt">Applicative</span> f) <span class="ot">=&gt;</span> f (f a) <span class="ot">-&gt;</span> f (f a) <span class="ot">-&gt;</span> f (f a)</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">mulMatrix xs ys <span class="fu">=</span> fmap (\row <span class="ot">-&gt;</span> fmap (add <span class="fu">.</span> liftA2 (<span class="fu">&lt;.&gt;</span>) row) cs) xs</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">    cs <span class="fu">=</span> transpose ys</a></code></pre></div>
<p>Of course, now <code class="sourceCode haskell">add</code> needs to work on our <code class="sourceCode haskell">f</code>, so it should be <code class="sourceCode haskell"><span class="dt">Foldable</span></code></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">mulMatrix </a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="ot">  ::</span> (<span class="dt">Semiring</span> a, <span class="dt">Applicative</span> f, <span class="dt">Foldable</span> f) </a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  <span class="ot">=&gt;</span> f (f a) <span class="ot">-&gt;</span> f (f a) <span class="ot">-&gt;</span> f (f a)</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">mulMatrix <span class="fu">=</span> <span class="fu">...</span></a></code></pre></div>
<p><code class="sourceCode haskell">transpose</code> is the missing piece now. A little bit of <code class="sourceCode haskell"><span class="dt">Applicative</span></code> magic can help us out again, though: <code class="sourceCode haskell">sequenceA</code> is <code class="sourceCode haskell">transpose</code> on <code class="sourceCode haskell"><span class="dt">ZipList</span></code>s <span class="citation" data-cites="mcbride_applicative_2008">(McBride and Paterson <a href="#ref-mcbride_applicative_2008">2008</a>)</span>.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1">mulMatrix </a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="ot">  ::</span> (<span class="dt">Semiring</span> a, <span class="dt">Applicative</span> f, <span class="dt">Traversable</span> f) </a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  <span class="ot">=&gt;</span> f (f a) <span class="ot">-&gt;</span> f (f a) <span class="ot">-&gt;</span> f (f a)</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">mulMatrix xs ys <span class="fu">=</span> </a>
<a class="sourceLine" id="cb5-5" data-line-number="5">    fmap (\row <span class="ot">-&gt;</span> fmap (add <span class="fu">.</span> liftA2 (<span class="fu">&lt;.&gt;</span>) row) cs) xs</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-7" data-line-number="7">    cs <span class="fu">=</span> sequenceA ys</a></code></pre></div>
<p>One further generalization: The two <code class="sourceCode haskell">f</code>s don’t actually need to be the same:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1">mulMatrix</a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="ot">    ::</span> (<span class="dt">Applicative</span> n</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">       ,<span class="dt">Traversable</span> m</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">       ,<span class="dt">Applicative</span> m</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">       ,<span class="dt">Applicative</span> p</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">       ,<span class="dt">Semiring</span> a)</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">    <span class="ot">=&gt;</span> n (m a) <span class="ot">-&gt;</span> m (p a) <span class="ot">-&gt;</span> n (p a)</a>
<a class="sourceLine" id="cb6-8" data-line-number="8">mulMatrix xs ys <span class="fu">=</span> fmap (\row <span class="ot">-&gt;</span> fmap (add <span class="fu">.</span> liftA2 (<span class="fu">&lt;.&gt;</span>) row) cs) xs</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-10" data-line-number="10">    cs <span class="fu">=</span> sequenceA ys</a></code></pre></div>
<p>Happily, the way that the wrappers (<code class="sourceCode haskell">n</code>, <code class="sourceCode haskell">m</code>, and <code class="sourceCode haskell">p</code>) match up coincides precisely with how matrix dimensions match up in matrix multiplication. Quoting from the <a href="https://en.wikipedia.org/wiki/Matrix_multiplication">Wikipedia definition</a>:</p>
<blockquote>
<p>if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math> is an <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>×</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n \times m</annotation></semantics></math> matrix and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math> is an <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>×</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">m \times p</annotation></semantics></math> matrix, their matrix product <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">AB</annotation></semantics></math> is an <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>×</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">n \times p</annotation></semantics></math> matrix</p>
</blockquote>
<p>This function is present in the <a href="https://hackage.haskell.org/package/linear-1.20.7/docs/Linear-Matrix.html#v:-33--42--33-">linear package</a> with some different constraints. In fairness, <code class="sourceCode haskell"><span class="dt">Applicative</span></code> probably isn’t the best thing to use here since it doesn’t work for so many instances (<a href="https://hackage.haskell.org/package/base-4.10.0.0/docs/Control-Monad-Zip.html"><code class="sourceCode haskell"><span class="dt">MonadZip</span></code></a> or something similar may be more suitable), but it’s very handy to have, and works out-of the box for types like:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Three</span> a </a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">Three</span> a a a </a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  <span class="kw">deriving</span> (<span class="dt">Functor</span>, <span class="dt">Foldable</span>, <span class="dt">Traversable</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb7-4" data-line-number="4"></a>
<a class="sourceLine" id="cb7-5" data-line-number="5"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Three</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6">  pure x <span class="fu">=</span> <span class="dt">Three</span> x x x</a>
<a class="sourceLine" id="cb7-7" data-line-number="7">  <span class="dt">Three</span> fx fy fz <span class="fu">&lt;*&gt;</span> <span class="dt">Three</span> xx xy xz <span class="fu">=</span> <span class="dt">Three</span> (fx xx) (fy xy) (fz xz)</a></code></pre></div>
<p>Which makes it (to my mind) useful enough to keep. Also, it hugely simplified the code for <a href="https://github.com/oisdk/Square/blob/master/src/Data/Square.hs#L183">matrix multiplication in square matrices</a> I had, from <span class="citation" data-cites="okasaki_fast_1999">Okasaki (<a href="#ref-okasaki_fast_1999">1999</a>)</span>.</p>
<h1 id="convolutions">Convolutions</h1>
<p>If you’re putting a general class in a library that you want people to use, and there exist sensible instances for common Haskell types, you should probably provide those instances in the library to avoid orphans. The meaning of “sensible” here is vague: generally speaking, if there is only one obvious or clear instance, then it’s sensible. For a list instance for the semiring class, for instance, I could figure out several law-abiding definitions for <code class="sourceCode haskell"><span class="fu">&lt;+&gt;</span></code>, <code class="sourceCode haskell">one</code> and <code class="sourceCode haskell">zero</code>, but only one for <code class="haskel">&lt;.&gt;</code>: polynomial multiplication. You know, where you multiply two polynomials like so:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><mn>2</mn><mi>x</mi><mo>+</mo><mn>3</mn><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><mn>5</mn><mi>x</mi><mo>+</mo><mn>3</mn><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>4</mn><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mn>9</mn><msup><mi>x</mi><mn>5</mn></msup><mo>+</mo><mn>15</mn><msup><mi>x</mi><mn>4</mn></msup><mo>+</mo><mn>18</mn><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><mn>28</mn><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>38</mn><mi>x</mi><mo>+</mo><mn>24</mn></mrow><annotation encoding="application/x-tex">(x^3 + 2x + 3)(5x + 3x^2 + 4) = 9x^5 + 15x^4 + 18x^3 + 28x^2 + 38x + 24</annotation></semantics></math></p>
<p>A more general definition looks something like this:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msub><mi>a</mi><mn>0</mn></msub><msup><mi>x</mi><mn>0</mn></msup><mo>+</mo><msub><mi>a</mi><mn>1</mn></msub><msup><mi>x</mi><mn>1</mn></msup><mo>+</mo><msub><mi>a</mi><mn>2</mn></msub><msup><mi>x</mi><mn>2</mn></msup><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>b</mi><mn>0</mn></msub><msup><mi>x</mi><mn>0</mn></msup><mo>+</mo><msub><mi>b</mi><mn>1</mn></msub><msup><mi>x</mi><mn>1</mn></msup><mo>+</mo><msub><mi>b</mi><mn>2</mn></msub><msup><mi>x</mi><mn>2</mn></msup><mo stretchy="false" form="postfix">)</mo><mo>=</mo></mrow><annotation encoding="application/x-tex">(a_0x^0 + a_1x^1 + a_2x^2)(b_0x^0 + b_1x^1 + b_2x^2) =</annotation></semantics></math> <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>0</mn></msub><msub><mi>b</mi><mn>0</mn></msub><msup><mi>x</mi><mn>0</mn></msup><mo>+</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>a</mi><mn>0</mn></msub><msub><mi>b</mi><mn>1</mn></msub><mo>+</mo><msub><mi>a</mi><mn>1</mn></msub><msub><mi>b</mi><mn>0</mn></msub><mo stretchy="false" form="postfix">)</mo><msup><mi>x</mi><mn>1</mn></msup><mo>+</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>a</mi><mn>0</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mo>+</mo><msub><mi>a</mi><mn>1</mn></msub><msub><mi>b</mi><mn>1</mn></msub><mo>+</mo><msub><mi>a</mi><mn>2</mn></msub><msub><mi>b</mi><mn>0</mn></msub><mo stretchy="false" form="postfix">)</mo><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>a</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mo>+</mo><msub><mi>a</mi><mn>2</mn></msub><msub><mi>b</mi><mn>1</mn></msub><mo stretchy="false" form="postfix">)</mo><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><msub><mi>a</mi><mn>2</mn></msub><msub><mi>b</mi><mn>2</mn></msub><msup><mi>x</mi><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">a_0b_0x^0 + (a_0b_1 + a_1b_0)x^1 + (a_0b_2 + a_1b_1 + a_2b_0)x^2 + (a_1b_2 + a_2b_1)x^3 + a_2b_2x^4</annotation></semantics></math></p>
<p>Or, fully generalized:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>k</mi></msub><mo>=</mo><msub><mi>a</mi><mn>0</mn></msub><msub><mi>b</mi><mi>k</mi></msub><mo>+</mo><msub><mi>a</mi><mn>1</mn></msub><msub><mi>b</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><mi>…</mi><mo>+</mo><msub><mi>a</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><msub><mi>b</mi><mn>1</mn></msub><mo>+</mo><msub><mi>a</mi><mi>k</mi></msub><msub><mi>b</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">c_k = a_0b_k + a_1b_{k-1} + \ldots + a_{k-1}b_1 + a_kb_0</annotation></semantics></math> <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>×</mo><mi>g</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>n</mi><mo>+</mo><mi>m</mi></mrow></munderover><msub><mi>c</mi><mi>i</mi></msub><msup><mi>x</mi><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">f(x) \times g(x) = \sum_{i=0}^{n+m}c_ix^i</annotation></semantics></math></p>
<p>So it turns out that you can represent polynomials pretty elegantly as lists. Take an example from above:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><mn>2</mn><mi>x</mi><mo>+</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">x^3 + 2x + 3</annotation></semantics></math></p>
<p>And rearrange it in order of the powers of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><msup><mi>x</mi><mn>0</mn></msup><mo>+</mo><mn>2</mn><msup><mi>x</mi><mn>1</mn></msup><mo>+</mo><msup><mi>x</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">3x^0 + 2x^1 + x^3</annotation></semantics></math></p>
<p>And fill in missing coefficients:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><msup><mi>x</mi><mn>0</mn></msup><mo>+</mo><mn>2</mn><msup><mi>x</mi><mn>1</mn></msup><mo>+</mo><mn>0</mn><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>1</mn><msup><mi>x</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">3x^0 + 2x^1 + 0x^2 + 1x^3</annotation></semantics></math></p>
<p>And then the list representation of that polynomial is the list of those coefficients:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">[<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">0</span>, <span class="dv">1</span>]</a></code></pre></div>
<p>For me, the definitions of multiplication above were pretty hard to understand. In Haskell, however, the definition is quite beautiful:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Semiring</span> a <span class="ot">=&gt;</span> <span class="dt">Semiring</span> [a] <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">  one <span class="fu">=</span> [one]</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  zero <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">  [] <span class="fu">&lt;+&gt;</span> ys <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  xs <span class="fu">&lt;+&gt;</span> [] <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb9-6" data-line-number="6">  (x<span class="fu">:</span>xs) <span class="fu">&lt;+&gt;</span> (y<span class="fu">:</span>ys) <span class="fu">=</span> x <span class="fu">&lt;+&gt;</span> y <span class="fu">:</span> (xs <span class="fu">&lt;+&gt;</span> ys)</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">  _ <span class="fu">&lt;.&gt;</span> [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb9-8" data-line-number="8">  [] <span class="fu">&lt;.&gt;</span> _ <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb9-9" data-line-number="9">  (x<span class="fu">:</span>xs) <span class="fu">&lt;.&gt;</span> (y<span class="fu">:</span>ys) <span class="fu">=</span> (x<span class="fu">&lt;.&gt;</span>y) <span class="fu">:</span> map (x<span class="fu">&lt;.&gt;</span>) ys <span class="fu">&lt;+&gt;</span> xs <span class="fu">&lt;.&gt;</span> (y<span class="fu">:</span>ys)</a></code></pre></div>
<p>This definition for <code class="sourceCode haskell"><span class="fu">&lt;.&gt;</span></code> can be found on page 4 of <span class="citation" data-cites="mcilroy_power_1999">McIlroy (<a href="#ref-mcilroy_power_1999">1999</a>)</span>. Although there was a version of the paper with a slightly different definition:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">_ <span class="fu">&lt;.&gt;</span> [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">[] <span class="fu">&lt;.&gt;</span> _ <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">(x<span class="fu">:</span>xs) <span class="fu">&lt;.&gt;</span> (y<span class="fu">:</span>ys) </a>
<a class="sourceLine" id="cb10-4" data-line-number="4">  <span class="fu">=</span> (x<span class="fu">&lt;.&gt;</span>y) <span class="fu">:</span> (map (x<span class="fu">&lt;.&gt;</span>) ys <span class="fu">&lt;+&gt;</span> map (<span class="fu">&lt;.&gt;</span>y) xs <span class="fu">&lt;+&gt;</span> (zero <span class="fu">:</span> (xs <span class="fu">&lt;.&gt;</span> ys)))</a></code></pre></div>
<p>Similar to one which appeared in <span class="citation" data-cites="dolan_fun_2013">Dolan (<a href="#ref-dolan_fun_2013">2013</a>)</span>.</p>
<p>As it happens, I prefer the first definition. It’s shorter, and I figured out how to write it as a fold:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1">_ <span class="fu">&lt;.&gt;</span> [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">xs <span class="fu">&lt;.&gt;</span> ys <span class="fu">=</span> foldr f [] xs <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  f x zs <span class="fu">=</span> map (x <span class="fu">&lt;.&gt;</span>) ys <span class="fu">&lt;+&gt;</span> (zero <span class="fu">:</span> zs)</a></code></pre></div>
<p>And if you inline the <code class="sourceCode haskell"><span class="fu">&lt;+&gt;</span></code>, you get a reasonable speedup:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1">xs <span class="fu">&lt;.&gt;</span> ys <span class="fu">=</span> foldr f [] xs</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">    f x zs <span class="fu">=</span> foldr (g x) id ys (zero <span class="fu">:</span> zs)</a>
<a class="sourceLine" id="cb12-4" data-line-number="4">    g x y a (z<span class="fu">:</span>zs) <span class="fu">=</span> x <span class="fu">&lt;.&gt;</span> y <span class="fu">&lt;+&gt;</span> z <span class="fu">:</span> a zs</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">    g x y a [] <span class="fu">=</span> x <span class="fu">&lt;.&gt;</span> y <span class="fu">:</span> a []</a></code></pre></div>
<p>The definition of <code class="sourceCode haskell"><span class="fu">&lt;+&gt;</span></code> can also use a fold on either side for fusion purposes:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1">(<span class="fu">&lt;+&gt;</span>) <span class="fu">=</span> foldr f id <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">  f x xs (y<span class="fu">:</span>ys) <span class="fu">=</span> x <span class="fu">&lt;+&gt;</span> y <span class="fu">:</span> xs ys</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">  f x xs [] <span class="fu">=</span> x <span class="fu">:</span> xs []</a>
<a class="sourceLine" id="cb13-4" data-line-number="4"></a>
<a class="sourceLine" id="cb13-5" data-line-number="5">(<span class="fu">&lt;+&gt;</span>) <span class="fu">=</span> flip (foldr f id) <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-6" data-line-number="6">  f y ys (x<span class="fu">:</span>xs) <span class="fu">=</span> x <span class="fu">&lt;+&gt;</span> y <span class="fu">:</span> ys xs</a>
<a class="sourceLine" id="cb13-7" data-line-number="7">  f y ys [] <span class="fu">=</span> y <span class="fu">:</span> ys []</a></code></pre></div>
<p>There are rules in the library to choose one of the above definitions if fusion is available.</p>
<p>This definition is much more widely useful than it may seem at first. Say, for instance, you wanted to search through pairs of things from two infinite lists. You can’t use the normal way to pair things for lists, the Cartesian product, because it will diverge:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1">[(x,y) <span class="fu">|</span> x <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span>], y <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span>]]</a>
<a class="sourceLine" id="cb14-2" data-line-number="2"><span class="co">-- [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10)...</span></a></code></pre></div>
<p>You’ll never get beyond 1 in the first list. Zipping isn’t an option either, because you won’t really explore the search space, only corresponding pairs. <a href="https://byorgey.wordpress.com/2008/04/22/list-convolutions/">Brent Yorgey showed</a> that if you want a list like this:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1">[(y,x<span class="fu">-</span>y) <span class="fu">|</span> x <span class="ot">&lt;-</span> [<span class="dv">0</span><span class="fu">..</span>], y <span class="ot">&lt;-</span> [<span class="dv">0</span><span class="fu">..</span>x] ]</a>
<a class="sourceLine" id="cb15-2" data-line-number="2"><span class="co">-- [(0,0),(0,1),(1,0),(0,2),(1,1),(2,0),(0,3),(1,2),(2,1),(3,0)...</span></a></code></pre></div>
<p>Then what you’re looking for is a convolution (the same thing as polynomial multiplication). <code class="sourceCode haskell"><span class="fu">&lt;.&gt;</span></code> above can be adapted readily:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="ot">convolve ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [[(a,b)]]</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">convolve xs ys <span class="fu">=</span> foldr f [] xs</a>
<a class="sourceLine" id="cb16-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-4" data-line-number="4">    f x zs <span class="fu">=</span> foldr (g x) id ys ([] <span class="fu">:</span> zs)</a>
<a class="sourceLine" id="cb16-5" data-line-number="5">    g x y a (z<span class="fu">:</span>zs) <span class="fu">=</span> ((x, y) <span class="fu">:</span> z) <span class="fu">:</span> a zs</a>
<a class="sourceLine" id="cb16-6" data-line-number="6">    g x y a [] <span class="fu">=</span> [(x, y)] <span class="fu">:</span> a []</a></code></pre></div>
<p>Flatten out this result to get your ordering. This convolution is a little different from the one in the blog post. By inlining <code class="sourceCode haskell"><span class="fu">&lt;+&gt;</span></code> we can avoid the expensive <code class="sourceCode haskell"><span class="fu">++</span></code> function, without using difference lists.</p>
<h1 id="long-multiplication">Long Multiplication</h1>
<p>Here’s another cool use of lists as polynomials: they can be used as a <a href="https://en.Wikipedia.org/wiki/Positional_notation">positional numeral system</a>. Most common numeral systems are positional, including Arabic (the system you most likely use, where twenty-four is written as 24) and binary. Non-positional systems are things like Roman numerals. Looking at the Arabic system for now, we see that the way of writing down numbers:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1989</mn><annotation encoding="application/x-tex">1989</annotation></semantics></math></p>
<p>Can be thought of the sum of each digit multiplied by ten to the power of its position:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1989</mn><mo>=</mo><mn>1</mn><mo>×</mo><msup><mn>10</mn><mn>3</mn></msup><mo>+</mo><mn>9</mn><mo>×</mo><msup><mn>10</mn><mn>2</mn></msup><mo>+</mo><mn>8</mn><mo>×</mo><msup><mn>10</mn><mn>1</mn></msup><mo>+</mo><mn>9</mn><mo>×</mo><msup><mn>10</mn><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">1989 = 1 \times 10^3 \plus 9 \times 10^2 \plus 8 \times 10^1 \plus 9 \times 10^0</annotation></semantics></math> <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1989</mn><mo>=</mo><mn>1</mn><mo>×</mo><mn>1000</mn><mo>+</mo><mn>9</mn><mo>×</mo><mn>100</mn><mo>+</mo><mn>8</mn><mo>×</mo><mn>10</mn><mo>+</mo><mn>9</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1989 = 1 \times 1000 \plus 9 \times 100 \plus 8 \times 10 \plus 9 \times 1</annotation></semantics></math> <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1989</mn><mo>=</mo><mn>1000</mn><mo>+</mo><mn>900</mn><mo>+</mo><mn>80</mn><mo>+</mo><mn>9</mn></mrow><annotation encoding="application/x-tex">1989 = 1000 \plus 900 \plus 80 \plus 9</annotation></semantics></math> <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1989</mn><mo>=</mo><mn>1989</mn></mrow><annotation encoding="application/x-tex">1989 = 1989</annotation></semantics></math></p>
<p>Where the positions are numbered from the right. In other words, it’s our polynomial list from above in reverse. As well as that, the convolution is long multiplication.</p>
<p>Now, taking this straight off we can try some examples:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="co">-- 12 + 15 = 27</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2">[<span class="dv">2</span>, <span class="dv">1</span>] <span class="fu">&lt;+&gt;</span> [<span class="dv">5</span>, <span class="dv">1</span>] <span class="fu">==</span> [<span class="dv">7</span>, <span class="dv">2</span>]</a>
<a class="sourceLine" id="cb17-3" data-line-number="3"></a>
<a class="sourceLine" id="cb17-4" data-line-number="4"><span class="co">-- 23 * 2 = 46</span></a>
<a class="sourceLine" id="cb17-5" data-line-number="5">[<span class="dv">3</span>, <span class="dv">2</span>] <span class="fu">&lt;.&gt;</span> [<span class="dv">2</span>] <span class="fu">==</span> [<span class="dv">6</span>, <span class="dv">4</span>]</a></code></pre></div>
<p>The issue, of course, is that we’re not handling carrying properly:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1">[<span class="dv">6</span>] <span class="fu">&lt;+&gt;</span> [<span class="dv">6</span>] <span class="fu">==</span> [<span class="dv">12</span>]</a></code></pre></div>
<p>No matter: we can perform all the carries after the addition, and everything works out fine:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1">carry</a>
<a class="sourceLine" id="cb19-2" data-line-number="2"><span class="ot">    ::</span> <span class="dt">Integral</span> a</a>
<a class="sourceLine" id="cb19-3" data-line-number="3">    <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb19-4" data-line-number="4">carry base xs <span class="fu">=</span> foldr f (toBase base) xs <span class="dv">0</span></a>
<a class="sourceLine" id="cb19-5" data-line-number="5">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-6" data-line-number="6">    f e a cin <span class="fu">=</span> r <span class="fu">:</span> a q <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-7" data-line-number="7">      (q,r) <span class="fu">=</span> quotRem (cin <span class="fu">+</span> e) base</a>
<a class="sourceLine" id="cb19-8" data-line-number="8">        </a>
<a class="sourceLine" id="cb19-9" data-line-number="9"><span class="ot">toBase ::</span> <span class="dt">Integral</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb19-10" data-line-number="10">toBase base <span class="fu">=</span> unfoldr f <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-11" data-line-number="11">  f <span class="dv">0</span> <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb19-12" data-line-number="12">  f n <span class="fu">=</span> <span class="dt">Just</span> (swap (quotRem n base))</a></code></pre></div>
<p>Wrap the whole thing in a newtype and we can have a <code class="sourceCode haskell"><span class="dt">Num</span></code> instance:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Positional</span> </a>
<a class="sourceLine" id="cb20-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">Positional</span> </a>
<a class="sourceLine" id="cb20-3" data-line-number="3">  {<span class="ot"> withBase ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> [<span class="dt">Integer</span>] </a>
<a class="sourceLine" id="cb20-4" data-line-number="4">  } </a>
<a class="sourceLine" id="cb20-5" data-line-number="5"></a>
<a class="sourceLine" id="cb20-6" data-line-number="6"><span class="kw">instance</span> <span class="dt">Num</span> <span class="dt">Positional</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-7" data-line-number="7">  <span class="dt">Positional</span> x <span class="fu">+</span> <span class="dt">Positional</span> y <span class="fu">=</span> <span class="dt">Positional</span> (carry <span class="fu">&lt;*&gt;</span> x <span class="fu">&lt;+&gt;</span> y)</a>
<a class="sourceLine" id="cb20-8" data-line-number="8">  <span class="dt">Positional</span> x <span class="fu">*</span> <span class="dt">Positional</span> y <span class="fu">=</span> <span class="dt">Positional</span> (carry <span class="fu">&lt;*&gt;</span> x <span class="fu">&lt;.&gt;</span> y)</a>
<a class="sourceLine" id="cb20-9" data-line-number="9">  fromInteger m <span class="fu">=</span> <span class="dt">Positional</span> (\base <span class="ot">-&gt;</span> toBase base m)</a>
<a class="sourceLine" id="cb20-10" data-line-number="10">  abs <span class="fu">=</span> id</a>
<a class="sourceLine" id="cb20-11" data-line-number="11">  signum <span class="fu">=</span> id</a>
<a class="sourceLine" id="cb20-12" data-line-number="12">  negate <span class="fu">=</span> id</a>
<a class="sourceLine" id="cb20-13" data-line-number="13">  </a>
<a class="sourceLine" id="cb20-14" data-line-number="14"><span class="ot">toDigits ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Positional</span> <span class="ot">-&gt;</span> [<span class="dt">Integer</span>]</a>
<a class="sourceLine" id="cb20-15" data-line-number="15">toDigits base p <span class="fu">=</span> reverse (withBase p base)</a></code></pre></div>
<p>This also lets us choose our base after the fact:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1">sumHundred <span class="fu">=</span> (sum <span class="fu">.</span> map fromInteger) [<span class="dv">1</span><span class="fu">..</span><span class="dv">100</span>]</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">toDigits <span class="dv">10</span> sumHundred</a>
<a class="sourceLine" id="cb21-3" data-line-number="3"><span class="co">-- [5,0,5,0]</span></a>
<a class="sourceLine" id="cb21-4" data-line-number="4">toDigits <span class="dv">2</span> sumHundred</a>
<a class="sourceLine" id="cb21-5" data-line-number="5"><span class="co">-- [1,0,0,1,1,1,0,1,1,1,0,1,0]</span></a></code></pre></div>
<h1 id="vectors">Vectors</h1>
<p>All the hand-optimizing, inlining, and fusion magic in the world won’t make a list-based implementation of convolution faster than a proper one on vectors, unfortunately. In particular, for larger vectors, a fast Fourier transform can be used. Also, usually code like this will be parallelized, rather than sequential. That said, it can be helpful to implement the slower version on vectors, in the usual indexed way, for comparison’s sake:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Semiring</span> a <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb22-2" data-line-number="2">         <span class="dt">Semiring</span> (<span class="dt">Vector</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-3" data-line-number="3">    one <span class="fu">=</span> Vector.singleton one</a>
<a class="sourceLine" id="cb22-4" data-line-number="4">    zero <span class="fu">=</span> Vector.empty</a>
<a class="sourceLine" id="cb22-5" data-line-number="5">    xs <span class="fu">&lt;+&gt;</span> ys <span class="fu">=</span></a>
<a class="sourceLine" id="cb22-6" data-line-number="6">        <span class="kw">case</span> compare (Vector.length xs) (Vector.length ys) <span class="kw">of</span></a>
<a class="sourceLine" id="cb22-7" data-line-number="7">            <span class="dt">EQ</span> <span class="ot">-&gt;</span> Vector.zipWith (<span class="fu">&lt;+&gt;</span>) xs ys</a>
<a class="sourceLine" id="cb22-8" data-line-number="8">            <span class="dt">LT</span> <span class="ot">-&gt;</span> Vector.unsafeAccumulate (<span class="fu">&lt;+&gt;</span>) ys (Vector.indexed xs)</a>
<a class="sourceLine" id="cb22-9" data-line-number="9">            <span class="dt">GT</span> <span class="ot">-&gt;</span> Vector.unsafeAccumulate (<span class="fu">&lt;+&gt;</span>) xs (Vector.indexed ys)</a>
<a class="sourceLine" id="cb22-10" data-line-number="10">    signal <span class="fu">&lt;.&gt;</span> kernel</a>
<a class="sourceLine" id="cb22-11" data-line-number="11">      <span class="fu">|</span> Vector.null signal <span class="fu">=</span> Vector.empty</a>
<a class="sourceLine" id="cb22-12" data-line-number="12">      <span class="fu">|</span> Vector.null kernel <span class="fu">=</span> Vector.empty</a>
<a class="sourceLine" id="cb22-13" data-line-number="13">      <span class="fu">|</span> otherwise <span class="fu">=</span> Vector.generate (slen <span class="fu">+</span> klen <span class="fu">-</span> <span class="dv">1</span>) f</a>
<a class="sourceLine" id="cb22-14" data-line-number="14">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-15" data-line-number="15">        f n <span class="fu">=</span></a>
<a class="sourceLine" id="cb22-16" data-line-number="16">            foldl&#39;</a>
<a class="sourceLine" id="cb22-17" data-line-number="17">                (\a k <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb22-18" data-line-number="18">                      a <span class="fu">&lt;+&gt;</span></a>
<a class="sourceLine" id="cb22-19" data-line-number="19">                      Vector.unsafeIndex signal k <span class="fu">&lt;.&gt;</span></a>
<a class="sourceLine" id="cb22-20" data-line-number="20">                      Vector.unsafeIndex kernel (n <span class="fu">-</span> k))</a>
<a class="sourceLine" id="cb22-21" data-line-number="21">                zero</a>
<a class="sourceLine" id="cb22-22" data-line-number="22">                [kmin <span class="fu">..</span> kmax]</a>
<a class="sourceLine" id="cb22-23" data-line-number="23">          <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-24" data-line-number="24">            <span class="fu">!</span>kmin <span class="fu">=</span> max <span class="dv">0</span> (n <span class="fu">-</span> (klen <span class="fu">-</span> <span class="dv">1</span>))</a>
<a class="sourceLine" id="cb22-25" data-line-number="25">            <span class="fu">!</span>kmax <span class="fu">=</span> min n (slen <span class="fu">-</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb22-26" data-line-number="26">        <span class="fu">!</span>slen <span class="fu">=</span> Vector.length signal</a>
<a class="sourceLine" id="cb22-27" data-line-number="27">        <span class="fu">!</span>klen <span class="fu">=</span> Vector.length kernel</a></code></pre></div>
<h1 id="search">Search</h1>
<p>As has been observed before <span class="citation" data-cites="rivas_monoids_2015">(Rivas, Jaskelioff, and Schrijvers <a href="#ref-rivas_monoids_2015">2015</a>)</span> there’s a pretty suggestive similarity between semirings and the <code class="sourceCode haskell"><span class="dt">Applicative</span></code>/<code class="sourceCode haskell"><span class="dt">Alternative</span></code> classes in Haskell:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Semiring</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-2" data-line-number="2"><span class="ot">  one ::</span> a</a>
<a class="sourceLine" id="cb23-3" data-line-number="3"><span class="ot">  zero ::</span> a</a>
<a class="sourceLine" id="cb23-4" data-line-number="4"><span class="ot">  (&lt;+&gt;) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb23-5" data-line-number="5"><span class="ot">  (&lt;.&gt;) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb23-6" data-line-number="6"></a>
<a class="sourceLine" id="cb23-7" data-line-number="7"><span class="kw">class</span> <span class="dt">Applicative</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-8" data-line-number="8"><span class="ot">  pure ::</span> a <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb23-9" data-line-number="9"><span class="ot">  (&lt;*&gt;) ::</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</a>
<a class="sourceLine" id="cb23-10" data-line-number="10"></a>
<a class="sourceLine" id="cb23-11" data-line-number="11"><span class="kw">class</span> <span class="dt">Alternative</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-12" data-line-number="12"><span class="ot">  empty ::</span> f a</a>
<a class="sourceLine" id="cb23-13" data-line-number="13"><span class="ot">  (&lt;|&gt;) ::</span> f a <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f a</a></code></pre></div>
<p>So can our implementation of convolution be used to implement the methods for these classes? Partially:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Search</span> f a <span class="fu">=</span> <span class="dt">Search</span> {<span class="ot"> runSearch ::</span> [f a] }</a>
<a class="sourceLine" id="cb24-2" data-line-number="2"></a>
<a class="sourceLine" id="cb24-3" data-line-number="3"><span class="kw">instance</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Functor</span> (<span class="dt">Search</span> f) <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-4" data-line-number="4">  fmap f (<span class="dt">Search</span> xs) <span class="fu">=</span> <span class="dt">Search</span> ((fmap<span class="fu">.</span>fmap) f xs)</a>
<a class="sourceLine" id="cb24-5" data-line-number="5"></a>
<a class="sourceLine" id="cb24-6" data-line-number="6"><span class="kw">instance</span> <span class="dt">Alternative</span> f <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="dt">Search</span> f) <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-7" data-line-number="7">  pure x <span class="fu">=</span> <span class="dt">Search</span> [pure x]</a>
<a class="sourceLine" id="cb24-8" data-line-number="8">  _ <span class="fu">&lt;*&gt;</span> <span class="dt">Search</span> [] <span class="fu">=</span> <span class="dt">Search</span> []</a>
<a class="sourceLine" id="cb24-9" data-line-number="9">  <span class="dt">Search</span> xs <span class="fu">&lt;*&gt;</span> <span class="dt">Search</span> ys <span class="fu">=</span> <span class="dt">Search</span> (foldr f [] xs) <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-10" data-line-number="10">    f x zs <span class="fu">=</span> foldr (g x) id ys (empty <span class="fu">:</span> zs)</a>
<a class="sourceLine" id="cb24-11" data-line-number="11">    g x y a (z<span class="fu">:</span>zs) <span class="fu">=</span> (x <span class="fu">&lt;*&gt;</span> y <span class="fu">&lt;|&gt;</span> z) <span class="fu">:</span> a zs</a>
<a class="sourceLine" id="cb24-12" data-line-number="12">    g x y a [] <span class="fu">=</span> (x <span class="fu">&lt;*&gt;</span> y) <span class="fu">:</span> a []</a>
<a class="sourceLine" id="cb24-13" data-line-number="13"></a>
<a class="sourceLine" id="cb24-14" data-line-number="14"><span class="kw">instance</span> <span class="dt">Alternative</span> f <span class="ot">=&gt;</span> <span class="dt">Alternative</span> (<span class="dt">Search</span> f) <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-15" data-line-number="15">  <span class="dt">Search</span> xs <span class="fu">&lt;|&gt;</span> <span class="dt">Search</span> ys <span class="fu">=</span> <span class="dt">Search</span> (go xs ys) <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-16" data-line-number="16">    go [] ys <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb24-17" data-line-number="17">    go xs [] <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb24-18" data-line-number="18">    go (x<span class="fu">:</span>xs) (y<span class="fu">:</span>ys) <span class="fu">=</span> (x <span class="fu">&lt;|&gt;</span> y) <span class="fu">:</span> go xs ys</a>
<a class="sourceLine" id="cb24-19" data-line-number="19">  empty <span class="fu">=</span> <span class="dt">Search</span> []</a></code></pre></div>
<p>At first, this seems perfect: the types all match up, and the definitions seem sensible. The issue is with the laws: <code class="sourceCode haskell"><span class="dt">Applicative</span></code> and <code class="sourceCode haskell"><span class="dt">Alternative</span></code> are missing <em>four</em> that semirings require. In particular: commutativity of plus, annihilation by zero, and distributivity left and right:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1">xs <span class="fu">&lt;|&gt;</span> ys <span class="fu">=</span> ys <span class="fu">&lt;|&gt;</span> xs</a>
<a class="sourceLine" id="cb25-2" data-line-number="2">empty <span class="fu">&lt;*&gt;</span> xs <span class="fu">=</span> fs <span class="fu">&lt;*&gt;</span> empty <span class="fu">=</span> empty</a>
<a class="sourceLine" id="cb25-3" data-line-number="3">fs <span class="fu">&lt;*&gt;</span> (xs <span class="fu">&lt;|&gt;</span> ys) <span class="fu">=</span> fs <span class="fu">&lt;*&gt;</span> xs <span class="fu">&lt;|&gt;</span> fs <span class="fu">&lt;*&gt;</span> ys</a>
<a class="sourceLine" id="cb25-4" data-line-number="4">(fs <span class="fu">&lt;|&gt;</span> gs) <span class="fu">&lt;*&gt;</span> xs <span class="fu">=</span> fs <span class="fu">&lt;*&gt;</span> xs <span class="fu">&lt;|&gt;</span> gs <span class="fu">&lt;*&gt;</span> ys</a></code></pre></div>
<p>The vast majority of the instances of <code class="sourceCode haskell"><span class="dt">Alternative</span></code> today fail one or more of these laws. Taking lists as an example, <code class="sourceCode haskell"><span class="fu">++</span></code> obviously isn’t commutative, and <code class="sourceCode haskell"><span class="fu">&lt;*&gt;</span></code> only distributes when it’s on the right.</p>
<p>What’s the problem, though? Polynomial multiplication follows <em>more</em> laws than those required by <code class="sourceCode haskell"><span class="dt">Applicative</span></code>: why should that worry us? Unfortunately, in order for multiplication to follow those laws, it actually relies on the underlying semiring being law-abiding. And it <em>fails</em> the applicative laws when it isn’t.</p>
<p>There are two angles from which we could come at this problem: either we relax the semiring laws and try and make our implementation of convolution rely on them as little as possible, or we find <code class="sourceCode haskell"><span class="dt">Alternative</span></code> instances which follow the semiring laws. Or we could meet in the middle, relaxing the laws as much as possible until we find some <code class="sourceCode haskell"><span class="dt">Alternative</span></code>s that meet our standards.</p>
<p>This has actually been accomplished in several papers: the previously mentioned <span class="citation" data-cites="rivas_monoids_2015">Rivas, Jaskelioff, and Schrijvers (<a href="#ref-rivas_monoids_2015">2015</a>)</span> discusses near-semirings, defined as semiring-like structures with associativity, identity, and these two laws:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>×</mo><mi>x</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">0 \times x = 0</annotation></semantics></math> <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo><mo>×</mo><mi>z</mi><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>×</mo><mi>z</mi><mo stretchy="false" form="postfix">)</mo><mo>+</mo><mo stretchy="false" form="prefix">(</mo><mi>y</mi><mo>×</mo><mi>z</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(x \plus y) \times z = (x \times z) \plus (y \times z)</annotation></semantics></math></p>
<p>In contrast to normal semirings, zero only annihilates when it’s on the left, and multiplication only distributes over addition when it’s on the right. Addition is not required to be commutative.</p>
<p>The lovely paper <span class="citation" data-cites="spivey_algebras_2009">Spivey (<a href="#ref-spivey_algebras_2009">2009</a>)</span> has a similar concept: a “bunch”.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Bunch</span> m <span class="kw">where</span></a>
<a class="sourceLine" id="cb26-2" data-line-number="2"><span class="ot">  return ::</span> a <span class="ot">-&gt;</span> m a</a>
<a class="sourceLine" id="cb26-3" data-line-number="3"><span class="ot">  (&gt;&gt;=) ::</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b</a>
<a class="sourceLine" id="cb26-4" data-line-number="4"><span class="ot">  zero ::</span> m a</a>
<a class="sourceLine" id="cb26-5" data-line-number="5"><span class="ot">  (&lt;|&gt;) ::</span> m a <span class="ot">-&gt;</span> m a <span class="ot">-&gt;</span> m a</a>
<a class="sourceLine" id="cb26-6" data-line-number="6"><span class="ot">  wrap ::</span> m a <span class="ot">-&gt;</span> m a</a></code></pre></div>
<p>The laws are all the same (with <code class="sourceCode haskell"><span class="fu">&lt;*&gt;</span></code> implemented in terms of <code class="sourceCode haskell"><span class="fu">&gt;&gt;=</span></code>), and the extra <code class="sourceCode haskell">wrap</code> operation can be expressed like so:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="ot">wrap ::</span> <span class="dt">Alternative</span> f <span class="ot">=&gt;</span> <span class="dt">Search</span> f a <span class="ot">-&gt;</span> <span class="dt">Search</span> f a</a>
<a class="sourceLine" id="cb27-2" data-line-number="2">wrap (<span class="dt">Search</span> xs) <span class="fu">=</span> <span class="dt">Search</span> (empty <span class="fu">:</span> xs)</a></code></pre></div>
<p>A definition of <code class="sourceCode haskell"><span class="fu">&gt;&gt;=</span></code> for our polynomials is also provided:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1">[] <span class="fu">&gt;&gt;=</span> _ <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb28-2" data-line-number="2">(x<span class="fu">:</span>xs) <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> foldr (<span class="fu">&lt;|&gt;</span>) empty (fmap f x) <span class="fu">&lt;|&gt;</span> wrap (xs <span class="fu">&gt;&gt;=</span> f)</a></code></pre></div>
<p>This will require the underlying <code class="sourceCode haskell">f</code> to be <code class="sourceCode haskell"><span class="dt">Foldable</span></code>. We can inline a little, and express the whole thing as a fold:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" data-line-number="1"><span class="kw">instance</span> (<span class="dt">Foldable</span> f, <span class="dt">Alternative</span> f) <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">Search</span> f) <span class="kw">where</span></a>
<a class="sourceLine" id="cb29-2" data-line-number="2">  <span class="dt">Search</span> xs <span class="fu">&gt;&gt;=</span> k <span class="fu">=</span> foldr f empty xs <span class="kw">where</span></a>
<a class="sourceLine" id="cb29-3" data-line-number="3">    f e a <span class="fu">=</span> foldr ((<span class="fu">&lt;|&gt;</span>) <span class="fu">.</span> k) (wrap a) e</a></code></pre></div>
<p>For <code class="sourceCode haskell"><span class="dt">Search</span></code> to meet the requirements of a bunch, the paper notes that the <code class="sourceCode haskell">f</code> must be assumed to be a bag, i.e., the order of its elements must be ignored.</p>
<p><span class="citation" data-cites="kiselyov_backtracking_2005">Kiselyov et al. (<a href="#ref-kiselyov_backtracking_2005">2005</a>)</span> kind of goes the other direction, defining a monad which has fair disjunction and conjunction. Unfortunately, the fair conjunction loses associativity.</p>
<h1 id="distance">Distance</h1>
<p>The end of the paper on algebras for combinatorial search wonders if notions of distance could be added to some of the algebras. I <em>think</em> that should be as simple as supplying a suitable near-semiring for <code class="sourceCode haskell">f</code>, but the definition of <code class="sourceCode haskell"><span class="fu">&gt;&gt;=</span></code> would need to be changed. The near-semiring I had in mind was the probability monad. It works correctly if inlined:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Search</span> s a <span class="fu">=</span> <span class="dt">Search</span> {<span class="ot"> runSearch ::</span> [[(a,s)]] }</a>
<a class="sourceLine" id="cb30-2" data-line-number="2"></a>
<a class="sourceLine" id="cb30-3" data-line-number="3"><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Search</span> s) <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-4" data-line-number="4">  fmap f (<span class="dt">Search</span> xs) <span class="fu">=</span> <span class="dt">Search</span> ((fmap<span class="fu">.</span>fmap<span class="fu">.</span>first) f xs)</a>
<a class="sourceLine" id="cb30-5" data-line-number="5"></a>
<a class="sourceLine" id="cb30-6" data-line-number="6"><span class="kw">instance</span> <span class="dt">Semiring</span> s <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="dt">Search</span> s) <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-7" data-line-number="7">  pure x <span class="fu">=</span> <span class="dt">Search</span> [[(x,one)]]</a>
<a class="sourceLine" id="cb30-8" data-line-number="8">  _ <span class="fu">&lt;*&gt;</span> <span class="dt">Search</span> [] <span class="fu">=</span> <span class="dt">Search</span> []</a>
<a class="sourceLine" id="cb30-9" data-line-number="9">  <span class="dt">Search</span> xs <span class="fu">&lt;*&gt;</span> <span class="dt">Search</span> ys <span class="fu">=</span> <span class="dt">Search</span> (foldr f [] xs) <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-10" data-line-number="10">    f x zs <span class="fu">=</span> foldr (g x) id ys (empty <span class="fu">:</span> zs)</a>
<a class="sourceLine" id="cb30-11" data-line-number="11">    g x y a (z<span class="fu">:</span>zs) <span class="fu">=</span> (m x y <span class="fu">++</span> z) <span class="fu">:</span> a zs</a>
<a class="sourceLine" id="cb30-12" data-line-number="12">    g x y a [] <span class="fu">=</span> (m x y) <span class="fu">:</span> a []</a>
<a class="sourceLine" id="cb30-13" data-line-number="13">    m ls rs <span class="fu">=</span> [(l r, lp<span class="fu">&lt;.&gt;</span>rp) <span class="fu">|</span> (l,lp) <span class="ot">&lt;-</span> ls, (r,rp) <span class="ot">&lt;-</span> rs]</a>
<a class="sourceLine" id="cb30-14" data-line-number="14"></a>
<a class="sourceLine" id="cb30-15" data-line-number="15"><span class="kw">instance</span> <span class="dt">Semiring</span> s <span class="ot">=&gt;</span> <span class="dt">Alternative</span> (<span class="dt">Search</span> s) <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-16" data-line-number="16">  <span class="dt">Search</span> xs <span class="fu">&lt;|&gt;</span> <span class="dt">Search</span> ys <span class="fu">=</span> <span class="dt">Search</span> (go xs ys) <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-17" data-line-number="17">    go [] ys <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb30-18" data-line-number="18">    go xs [] <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb30-19" data-line-number="19">    go (x<span class="fu">:</span>xs) (y<span class="fu">:</span>ys) <span class="fu">=</span> (x <span class="fu">++</span> y) <span class="fu">:</span> go xs ys</a>
<a class="sourceLine" id="cb30-20" data-line-number="20">  empty <span class="fu">=</span> <span class="dt">Search</span> []</a>
<a class="sourceLine" id="cb30-21" data-line-number="21"></a>
<a class="sourceLine" id="cb30-22" data-line-number="22"><span class="ot">wrap ::</span> <span class="dt">Search</span> s a <span class="ot">-&gt;</span> <span class="dt">Search</span> s a</a>
<a class="sourceLine" id="cb30-23" data-line-number="23">wrap (<span class="dt">Search</span> xs) <span class="fu">=</span> <span class="dt">Search</span> ([] <span class="fu">:</span> xs)</a>
<a class="sourceLine" id="cb30-24" data-line-number="24"></a>
<a class="sourceLine" id="cb30-25" data-line-number="25"><span class="kw">instance</span> <span class="dt">Semiring</span> s <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">Search</span> s) <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-26" data-line-number="26">  <span class="dt">Search</span> xs <span class="fu">&gt;&gt;=</span> k <span class="fu">=</span> foldr f empty xs <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-27" data-line-number="27">    f e a <span class="fu">=</span> foldr ((<span class="fu">&lt;|&gt;</span>) <span class="fu">.</span> uncurry (mulIn <span class="fu">.</span> k)) (wrap a) e</a>
<a class="sourceLine" id="cb30-28" data-line-number="28">    mulIn (<span class="dt">Search</span> x) xp <span class="fu">=</span> <span class="dt">Search</span> ((fmap<span class="fu">.</span>fmap<span class="fu">.</span>fmap) (xp<span class="fu">&lt;.&gt;</span>) x)</a></code></pre></div>
<p>But I couldn’t figure out how to get it to work for a more generalized inner monad. The above could probably be sped up, or randomized, using the many well-known techniques for probability monad optimization.</p>
<h1 id="references" class="unnumbered">References</h1>
<div id="refs" class="references">
<div id="ref-dolan_fun_2013">
<p>Dolan, Stephen. 2013. “Fun with semirings: A functional pearl on the abuse of linear algebra.” In, 48:101. ACM Press. doi:<a href="https://doi.org/10.1145/2500365.2500613">10.1145/2500365.2500613</a>. <a href="https://www.cl.cam.ac.uk/~sd601/papers/semirings.pdf" class="uri">https://www.cl.cam.ac.uk/~sd601/papers/semirings.pdf</a>.</p>
</div>
<div id="ref-kiselyov_backtracking_2005">
<p>Kiselyov, Oleg, Chung-chieh Shan, Daniel P Friedman, and Amr Sabry. 2005. “Backtracking, interleaving, and terminating monad transformers (functional pearl).” <em>ACM SIGPLAN Notices</em> 40 (9): 192–203. <a href="http://okmij.org/ftp/Computation/monads.html#LogicT" class="uri">http://okmij.org/ftp/Computation/monads.html#LogicT</a>.</p>
</div>
<div id="ref-mcbride_applicative_2008">
<p>McBride, Conor, and Ross Paterson. 2008. “Applicative programming with effects.” <em>Journal of functional programming</em> 18 (01): 1–13. <a href="http://strictlypositive.org/Idiom.pdf" class="uri">http://strictlypositive.org/Idiom.pdf</a>.</p>
</div>
<div id="ref-mcilroy_power_1999">
<p>McIlroy, M. Douglas. 1999. “Power Series, Power Serious.” <em>J. Funct. Program.</em> 9 (3) (May): 325–337. doi:<a href="https://doi.org/10.1017/S0956796899003299">10.1017/S0956796899003299</a>. <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.333.3156&amp;rep=rep1&amp;type=pdf" class="uri">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.333.3156&amp;rep=rep1&amp;type=pdf</a>.</p>
</div>
<div id="ref-okasaki_fast_1999">
<p>Okasaki, Chris. 1999. “From Fast Exponentiation to Square Matrices: An Adventure in Types.” In <em>Proceedings of the ACM SIGPLAN International Conference on Functional Programming (ICFP’99), Paris, France, September 27-29, 1999</em>, 34:28. ACM. <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.456.357&amp;rep=rep1&amp;type=pdf" class="uri">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.456.357&amp;rep=rep1&amp;type=pdf</a>.</p>
</div>
<div id="ref-rivas_monoids_2015">
<p>Rivas, Exequiel, Mauro Jaskelioff, and Tom Schrijvers. 2015. “From monoids to near-semirings: The essence of MonadPlus and Alternative.” In <em>Proceedings of the 17th International Symposium on Principles and Practice of Declarative Programming</em>, 196–207. ACM. doi:<a href="https://doi.org/10.1145/2790449.2790514">10.1145/2790449.2790514</a>. <a href="http://www.fceia.unr.edu.ar/~mauro/pubs/FromMonoidstoNearsemirings.pdf" class="uri">http://www.fceia.unr.edu.ar/~mauro/pubs/FromMonoidstoNearsemirings.pdf</a>.</p>
</div>
<div id="ref-spivey_algebras_2009">
<p>Spivey, J. Michael. 2009. “Algebras for combinatorial search.” <em>Journal of Functional Programming</em> 19 (3-4) (July): 469–487. doi:<a href="https://doi.org/10.1017/S0956796809007321">10.1017/S0956796809007321</a>. <a href="https://pdfs.semanticscholar.org/db3e/373bb6e7e7837ebc524da0a25903958554ed.pdf" class="uri">https://pdfs.semanticscholar.org/db3e/373bb6e7e7837ebc524da0a25903958554ed.pdf</a>.</p>
</div>
</div>
]]></description>
    <pubDate>Fri, 13 Oct 2017 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2017-10-13-convolutions-and-semirings.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Applicative Arithmetic</title>
    <link>https://doisinkidney.com/posts/2017-09-25-applicative-arithmetic.html</link>
    <description><![CDATA[<div class="info">
    Posted on September 25, 2017
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Applicative.html">Applicative</a>
    
</div>

<h1 id="safer-arithmetic">Safer Arithmetic</h1>
<p>There are a couple partial functions in the Haskell Prelude which people seem to agree shouldn’t be there. <code class="sourceCode haskell">head</code>, for example, will throw an error on an empty list. Most seem to agree that it should work something more like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1">head<span class="ot"> ::</span> <span class="dt">Foldable</span> f <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">head <span class="fu">=</span> foldr (const <span class="fu">.</span> <span class="dt">Just</span>) <span class="dt">Nothing</span></a></code></pre></div>
<p>There are other examples, like <code class="sourceCode haskell">last</code>, <code class="sourceCode haskell"><span class="fu">!!</span></code>, etc.</p>
<p>One which people <em>don’t</em> agree on, however, is division by zero. In the current Prelude, the following will throw an error:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="dv">1</span> <span class="fu">/</span> <span class="dv">0</span></a></code></pre></div>
<p>The “safe” version might have a signature like this:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">(/) ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</a></code></pre></div>
<p>However, this turns out to be quite a headache for writing code generally. So the default is the (somewhat) unsafe version.</p>
<p>Is there a way to introduce a safer version without much overhead, so the programmer is given the option? Of course! With some newtype magic, it’s pretty simple to write a wrapper which catches division by zero in some arbitrary monad:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">AppNum</span> f a <span class="fu">=</span> <span class="dt">AppNum</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">    {<span class="ot"> runAppNum ::</span> f a</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">    } <span class="kw">deriving</span> (<span class="dt">Functor</span>,<span class="dt">Applicative</span>,<span class="dt">Monad</span>,<span class="dt">Alternative</span>,<span class="dt">Show</span>,<span class="dt">Eq</span>,<span class="dt">MonadFail</span>)</a>
<a class="sourceLine" id="cb4-4" data-line-number="4"></a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="kw">instance</span> (<span class="dt">Num</span> a, <span class="dt">Applicative</span> f) <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">         <span class="dt">Num</span> (<span class="dt">AppNum</span> f a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7">    abs <span class="fu">=</span> fmap abs</a>
<a class="sourceLine" id="cb4-8" data-line-number="8">    signum <span class="fu">=</span> fmap signum</a>
<a class="sourceLine" id="cb4-9" data-line-number="9">    (<span class="fu">+</span>) <span class="fu">=</span> liftA2 (<span class="fu">+</span>)</a>
<a class="sourceLine" id="cb4-10" data-line-number="10">    (<span class="fu">*</span>) <span class="fu">=</span> liftA2 (<span class="fu">*</span>)</a>
<a class="sourceLine" id="cb4-11" data-line-number="11">    (<span class="fu">-</span>) <span class="fu">=</span> liftA2 (<span class="fu">-</span>)</a>
<a class="sourceLine" id="cb4-12" data-line-number="12">    negate <span class="fu">=</span> fmap negate</a>
<a class="sourceLine" id="cb4-13" data-line-number="13">    fromInteger <span class="fu">=</span> pure <span class="fu">.</span> fromInteger</a>
<a class="sourceLine" id="cb4-14" data-line-number="14"></a>
<a class="sourceLine" id="cb4-15" data-line-number="15"><span class="kw">instance</span> (<span class="dt">Fractional</span> a, <span class="dt">MonadFail</span> f, <span class="dt">Eq</span> a) <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb4-16" data-line-number="16">         <span class="dt">Fractional</span> (<span class="dt">AppNum</span> f a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-17" data-line-number="17">    fromRational <span class="fu">=</span> pure <span class="fu">.</span> fromRational</a>
<a class="sourceLine" id="cb4-18" data-line-number="18">    xs <span class="fu">/</span> ys <span class="fu">=</span></a>
<a class="sourceLine" id="cb4-19" data-line-number="19">        ys <span class="fu">&gt;&gt;=</span></a>
<a class="sourceLine" id="cb4-20" data-line-number="20">        \<span class="kw">case</span></a>
<a class="sourceLine" id="cb4-21" data-line-number="21">            <span class="dv">0</span> <span class="ot">-&gt;</span> fail <span class="st">&quot;divide by zero&quot;</span></a>
<a class="sourceLine" id="cb4-22" data-line-number="22">            y <span class="ot">-&gt;</span> fmap (<span class="fu">/</span> y) xs</a></code></pre></div>
<p>I’m using the <code class="sourceCode haskell"><span class="fu">-</span><span class="dt">XLambdaCase</span></code> extension and <code class="sourceCode haskell"><span class="dt">MonadFail</span></code> here.</p>
<h1 id="free-applicatives">Free Applicatives</h1>
<p>You’ll notice that you only need <code class="sourceCode haskell"><span class="dt">Applicative</span></code> for most of the arithmetic operations above. In fact, you only need <code class="sourceCode haskell"><span class="dt">Monad</span></code> when you want to examine the contents of <code class="sourceCode haskell">f</code>. Using that fact, we can manipulate expression trees using the free applicative from the <a href="https://hackage.haskell.org/package/free">free</a> package. Say, for instance, we want to have free variables in our expressions. Using <code class="sourceCode haskell"><span class="dt">Either</span></code>, it’s pretty easy:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">type</span> <span class="dt">WithVars</span> <span class="fu">=</span> <span class="dt">AppNum</span> (<span class="dt">Ap</span> (<span class="dt">Either</span> <span class="dt">String</span>)) <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="ot">var ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">WithVars</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">var <span class="fu">=</span> <span class="dt">AppNum</span> <span class="fu">.</span> liftAp <span class="fu">.</span> <span class="dt">Left</span></a></code></pre></div>
<p>We can collect the free variables from an expression:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">vars ::</span> <span class="dt">WithVars</span> <span class="ot">-&gt;</span> [<span class="dt">String</span>]</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">vars <span class="fu">=</span> runAp_ (either pure (const [])) <span class="fu">.</span> runAppNum</a>
<a class="sourceLine" id="cb6-3" data-line-number="3"></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">x <span class="fu">=</span> <span class="dv">1</span><span class="ot"> ::</span> <span class="dt">WithVars</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">y <span class="fu">=</span> var <span class="st">&quot;y&quot;</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">z <span class="fu">=</span> var <span class="st">&quot;z&quot;</span></a>
<a class="sourceLine" id="cb6-7" data-line-number="7"></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">vars (x <span class="fu">+</span> y <span class="fu">+</span> z) <span class="co">-- [&quot;y&quot;,&quot;z&quot;]</span></a></code></pre></div>
<p>If we want to sub in, though, we’re going to run into a problem: we can’t just pass in a <code class="sourceCode haskell"><span class="dt">Map</span> <span class="dt">String</span> <span class="dt">Integer</span></code> because you’re able to construct values like this:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">bad ::</span> <span class="dt">AppNum</span> (<span class="dt">Ap</span> (<span class="dt">Either</span> <span class="dt">String</span>)) (<span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>)</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">bad <span class="fu">=</span> <span class="dt">AppNum</span> (liftAp (<span class="dt">Left</span> <span class="st">&quot;oh noes&quot;</span>))</a></code></pre></div>
<p>We’d need to pass in a <code class="sourceCode haskell"><span class="dt">Map</span> <span class="dt">String</span> (<span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>)</code> as well; in fact you’d need a map for every possible type. Which isn’t feasible.</p>
<h1 id="gadts">GADTs</h1>
<p>Luckily, we <em>can</em> constrain the types of variables in our expression so that they’re always <code class="sourceCode haskell"><span class="dt">Integer</span></code>, using a GADT:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Variable</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">        <span class="dt">Constant</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Variable</span> a</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">        <span class="dt">Variable</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Variable</span> <span class="dt">Integer</span></a></code></pre></div>
<p>The type above seems useless on its own: it doesn’t have a <code class="sourceCode haskell"><span class="dt">Functor</span></code> instance, never mind an <code class="sourceCode haskell"><span class="dt">Applicative</span></code>, so how can it fit into <code class="sourceCode haskell"><span class="dt">AppNum</span></code>?</p>
<p>The magic comes from the free applicative, which converts any type of kind <code class="sourceCode haskell"><span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></code> into an applicative. With that in mind, we can change around the previous code:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">type</span> <span class="dt">WithVars</span> <span class="fu">=</span> <span class="dt">AppNum</span> (<span class="dt">Ap</span> <span class="dt">Variable</span>) <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"></a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="ot">var ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">WithVars</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4">var <span class="fu">=</span> <span class="dt">AppNum</span> <span class="fu">.</span> liftAp <span class="fu">.</span> <span class="dt">Variable</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5"></a>
<a class="sourceLine" id="cb9-6" data-line-number="6"><span class="ot">vars ::</span> <span class="dt">WithVars</span> <span class="ot">-&gt;</span> [<span class="dt">String</span>]</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">vars <span class="fu">=</span> runAp_ f <span class="fu">.</span> runAppNum</a>
<a class="sourceLine" id="cb9-8" data-line-number="8">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-9" data-line-number="9"><span class="ot">    f ::</span> <span class="dt">Variable</span> a <span class="ot">-&gt;</span> [<span class="dt">String</span>]</a>
<a class="sourceLine" id="cb9-10" data-line-number="10">    f (<span class="dt">Constant</span> _) <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb9-11" data-line-number="11">    f (<span class="dt">Variable</span> s) <span class="fu">=</span> [s]</a></code></pre></div>
<p>And write the function to sub in for us:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">variableA</a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="ot">    ::</span> <span class="dt">Applicative</span> f</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">    <span class="ot">=&gt;</span> (<span class="dt">String</span> <span class="ot">-&gt;</span> f <span class="dt">Integer</span>) <span class="ot">-&gt;</span> <span class="dt">Variable</span> a <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">variableA _ (<span class="dt">Constant</span> x) <span class="fu">=</span> pure x</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">variableA f (<span class="dt">Variable</span> s) <span class="fu">=</span> f s</a>
<a class="sourceLine" id="cb10-6" data-line-number="6"></a>
<a class="sourceLine" id="cb10-7" data-line-number="7"><span class="ot">variable ::</span> (<span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>) <span class="ot">-&gt;</span> <span class="dt">Variable</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb10-8" data-line-number="8">variable _ (<span class="dt">Constant</span> x) <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb10-9" data-line-number="9">variable f (<span class="dt">Variable</span> s) <span class="fu">=</span> f s</a>
<a class="sourceLine" id="cb10-10" data-line-number="10"></a>
<a class="sourceLine" id="cb10-11" data-line-number="11"><span class="ot">replace ::</span> <span class="dt">Map</span> <span class="dt">String</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">WithVars</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb10-12" data-line-number="12">replace m <span class="fu">=</span> runAp (variable (m <span class="fu">Map.!</span>)) <span class="fu">.</span> runAppNum</a>
<a class="sourceLine" id="cb10-13" data-line-number="13"></a>
<a class="sourceLine" id="cb10-14" data-line-number="14">replace (Map.fromList [(<span class="st">&quot;z&quot;</span>,<span class="dv">2</span>), (<span class="st">&quot;y&quot;</span>,<span class="dv">3</span>)]) (x <span class="fu">+</span> y <span class="fu">+</span> z)</a>
<a class="sourceLine" id="cb10-15" data-line-number="15"><span class="co">-- 6</span></a></code></pre></div>
<h1 id="accumulation">Accumulation</h1>
<p>This will fail if a free variable isn’t present in the map, unfortunately. To fix it, we <em>could</em> use <code class="sourceCode haskell"><span class="dt">Either</span></code> instead of <code class="sourceCode haskell"><span class="dt">Identity</span></code>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">replace ::</span> <span class="dt">Map</span> <span class="dt">String</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">WithVars</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2">replace m <span class="fu">=</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">    runAp</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">        (variableA <span class="fu">$</span></a>
<a class="sourceLine" id="cb11-5" data-line-number="5">         \s <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb11-6" data-line-number="6">              maybe (<span class="dt">Left</span> s) <span class="dt">Right</span> (Map.lookup s m)) <span class="fu">.</span></a>
<a class="sourceLine" id="cb11-7" data-line-number="7">    runAppNum</a></code></pre></div>
<p>But this only gives us the first missing variable encountered. We’d like to get back <em>all</em> of the missing variables, ideally: accumulating the <code class="sourceCode haskell"><span class="dt">Left</span></code>s. <code class="sourceCode haskell"><span class="dt">Either</span></code> doesn’t accumulate values, as if it did it would <a href="https://stackoverflow.com/a/23611068/4892417">break the monad laws</a>.</p>
<p>There’s no issue with the <em>applicative</em> laws, though, which is why the <a href="https://hackage.haskell.org/package/validation-0.5.4">validation</a> package provides a <em>non-monadic</em> either-like type, which we can use here.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="ot">replace ::</span> <span class="dt">Map</span> <span class="dt">String</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">WithVars</span> <span class="ot">-&gt;</span> <span class="dt">AccValidation</span> [<span class="dt">String</span>] <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">replace m <span class="fu">=</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">    runAp</a>
<a class="sourceLine" id="cb12-4" data-line-number="4">        (variableA <span class="fu">$</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5">         \s <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb12-6" data-line-number="6">              maybe (<span class="dt">AccFailure</span> [s]) pure (Map.lookup s m)) <span class="fu">.</span></a>
<a class="sourceLine" id="cb12-7" data-line-number="7">    runAppNum</a>
<a class="sourceLine" id="cb12-8" data-line-number="8"></a>
<a class="sourceLine" id="cb12-9" data-line-number="9">replace (Map.fromList []) (x <span class="fu">+</span> y <span class="fu">+</span> z)</a>
<a class="sourceLine" id="cb12-10" data-line-number="10"><span class="co">-- AccFailure [&quot;y&quot;,&quot;z&quot;]</span></a></code></pre></div>
<h1 id="other-uses">Other uses</h1>
<p>There are a bunch more applicatives you could use instead of <code class="sourceCode haskell"><span class="dt">Either</span></code>. Using lists, for instance, you could calculate the possible outcomes from a range of inputs:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1">range<span class="ot"> ::</span> <span class="dt">WithVars</span> <span class="ot">-&gt;</span> [<span class="dt">Integer</span>]</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">range <span class="fu">=</span> runAp (variable (const [<span class="dv">1</span><span class="fu">..</span><span class="dv">3</span>])) <span class="fu">.</span> runAppNum</a>
<a class="sourceLine" id="cb13-3" data-line-number="3"></a>
<a class="sourceLine" id="cb13-4" data-line-number="4">range (x <span class="fu">+</span> y <span class="fu">+</span> z)</a>
<a class="sourceLine" id="cb13-5" data-line-number="5"><span class="co">-- [3,4,5,4,5,6,5,6,7]</span></a></code></pre></div>
<p>Or you could ask the user for input:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="ot">query ::</span> <span class="dt">WithVars</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2">query <span class="fu">=</span> runAp (variable f) <span class="fu">.</span> runAppNum</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-4" data-line-number="4">    f s <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb14-5" data-line-number="5">      putStr <span class="st">&quot;Input a value for &quot;</span></a>
<a class="sourceLine" id="cb14-6" data-line-number="6">      putStrLn s</a>
<a class="sourceLine" id="cb14-7" data-line-number="7">      fmap read getLine</a></code></pre></div>
<p>Finally, and this one’s a bit exotic, you could examine every variable in turn, with defaults for the others:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1">zygo</a>
<a class="sourceLine" id="cb15-2" data-line-number="2"><span class="ot">    ::</span> (forall x<span class="fu">.</span> f x <span class="ot">-&gt;</span> x)</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">    <span class="ot">-&gt;</span> (forall x<span class="fu">.</span> f x <span class="ot">-&gt;</span> (x <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> b)</a>
<a class="sourceLine" id="cb15-4" data-line-number="4">    <span class="ot">-&gt;</span> <span class="dt">Ap</span> f a</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">    <span class="ot">-&gt;</span> [b]</a>
<a class="sourceLine" id="cb15-6" data-line-number="6">zygo (<span class="ot">l ::</span> forall x<span class="fu">.</span> f x <span class="ot">-&gt;</span> x) (<span class="ot">c ::</span> forall x<span class="fu">.</span> f x <span class="ot">-&gt;</span> (x <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> b) <span class="fu">=</span></a>
<a class="sourceLine" id="cb15-7" data-line-number="7">    fst <span class="fu">.</span> go id</a>
<a class="sourceLine" id="cb15-8" data-line-number="8">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-9" data-line-number="9"><span class="ot">    go ::</span> forall c<span class="fu">.</span> (c <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Ap</span> f c <span class="ot">-&gt;</span> ([b], c)</a>
<a class="sourceLine" id="cb15-10" data-line-number="10">    go _ (<span class="dt">Pure</span> x) <span class="fu">=</span> ([], x)</a>
<a class="sourceLine" id="cb15-11" data-line-number="11">    go k (<span class="dt">Ap</span> x f) <span class="fu">=</span> (c x (k <span class="fu">.</span> ls) <span class="fu">:</span> xs, ls lx)</a>
<a class="sourceLine" id="cb15-12" data-line-number="12">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-13" data-line-number="13">        (xs,ls) <span class="fu">=</span> go (k <span class="fu">.</span> (<span class="fu">$</span> lx)) f</a>
<a class="sourceLine" id="cb15-14" data-line-number="14">        lx <span class="fu">=</span> l x</a>
<a class="sourceLine" id="cb15-15" data-line-number="15"></a>
<a class="sourceLine" id="cb15-16" data-line-number="16"><span class="ot">examineEach ::</span> <span class="dt">WithVars</span> <span class="ot">-&gt;</span> [<span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>]</a>
<a class="sourceLine" id="cb15-17" data-line-number="17">examineEach <span class="fu">=</span> zygo (variable (const <span class="dv">1</span>)) g <span class="fu">.</span> runAppNum</a>
<a class="sourceLine" id="cb15-18" data-line-number="18">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-19" data-line-number="19"><span class="ot">    g ::</span> <span class="dt">Variable</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb15-20" data-line-number="20">    g (<span class="dt">Constant</span> x) rhs _ <span class="fu">=</span> rhs x</a>
<a class="sourceLine" id="cb15-21" data-line-number="21">    g (<span class="dt">Variable</span> _) rhs i <span class="fu">=</span> rhs i</a></code></pre></div>
<p>This produces a list of functions which are equivalent to subbing in for each variable with the rest set to 1.</p>
]]></description>
    <pubDate>Mon, 25 Sep 2017 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2017-09-25-applicative-arithmetic.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Verifying Data Structures in Haskell</title>
    <link>https://doisinkidney.com/posts/2017-04-23-verifying-data-structures-in-haskell-lhs.html</link>
    <description><![CDATA[<div class="info">
    Posted on April 23, 2017
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Dependent%20Types.html">Dependent Types</a>, <a href="/tags/Data%20Structures.html">Data Structures</a>
    
</div>

<div class="sourceCode" id="cb1"><pre class="sourceCode haskell literate hidden_source"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">{-# LANGUAGE DataKinds #-}</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="ot">{-# LANGUAGE TypeOperators #-}</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="ot">{-# LANGUAGE TypeFamilies #-}</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="ot">{-# LANGUAGE TypeInType #-}</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="ot">{-# LANGUAGE KindSignatures #-}</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="ot">{-# LANGUAGE GADTs #-}</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="ot">{-# LANGUAGE RankNTypes #-}</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"><span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9"><span class="ot">{-# LANGUAGE BangPatterns #-}</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10"><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11"><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></a>
<a class="sourceLine" id="cb1-12" data-line-number="12"><span class="ot">{-# LANGUAGE RebindableSyntax #-}</span></a>
<a class="sourceLine" id="cb1-13" data-line-number="13"></a>
<a class="sourceLine" id="cb1-14" data-line-number="14"><span class="ot">{-# OPTIONS_GHC -fplugin GHC.TypeLits.Normalise #-}</span></a>
<a class="sourceLine" id="cb1-15" data-line-number="15"></a>
<a class="sourceLine" id="cb1-16" data-line-number="16"><span class="kw">module</span> <span class="dt">VerifiedDataStructures</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-17" data-line-number="17"></a>
<a class="sourceLine" id="cb1-18" data-line-number="18"><span class="kw">import</span> <span class="dt">Data.Kind</span> <span class="kw">hiding</span> (type (*))</a>
<a class="sourceLine" id="cb1-19" data-line-number="19"><span class="kw">import</span> <span class="dt">Data.Type.Equality</span></a>
<a class="sourceLine" id="cb1-20" data-line-number="20"><span class="kw">import</span> <span class="dt">Unsafe.Coerce</span></a>
<a class="sourceLine" id="cb1-21" data-line-number="21"><span class="kw">import</span> <span class="dt">GHC.TypeLits</span> <span class="kw">hiding</span> (type (&lt;=))</a>
<a class="sourceLine" id="cb1-22" data-line-number="22"><span class="kw">import</span> <span class="dt">Data.Proxy</span></a>
<a class="sourceLine" id="cb1-23" data-line-number="23"><span class="kw">import</span> <span class="dt">Data.Coerce</span></a>
<a class="sourceLine" id="cb1-24" data-line-number="24"><span class="kw">import</span> <span class="dt">Prelude</span></a></code></pre></div>
<p>A while ago I read <a href="https://www.reddit.com/r/haskell/comments/63a4ea/fast_total_sorting_of_arbitrary_traversable/">this</a> post on reddit (by David Feuer), about sorting traversables (which was a follow-up on <a href="http://elvishjerricco.github.io/2017/03/23/applicative-sorting.html">this</a> post by Will Fancher), and I was inspired to write some pseudo-dependently-typed Haskell. The post (and subsequent <a href="https://github.com/treeowl/sort-traversable">library</a>) detailed how to use size-indexed heaps to perform fast, total sorting on any traversable. I ended up with a <a href="https://github.com/oisdk/type-indexed-queues">library</a> which has five size-indexed heaps (Braun, pairing, binomial, skew, and leftist), each verified for structural correctness. I also included the non-indexed implementations of each for comparison (as well as benchmarks, tests, and all that good stuff).</p>
<p>The purpose of this post is to go through some of the tricks I used and problems I encountered writing a lot of type-level code in modern Haskell.</p>
<h3 id="type-level-numbers-in-haskell">Type-Level Numbers in Haskell</h3>
<p>In order to index things by their size, we’ll need a type-level representation of size. We’ll use <a href="https://wiki.haskell.org/Peano_numbers">Peano</a> numbers for now:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Peano</span> <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">|</span> <span class="dt">S</span> <span class="dt">Peano</span></a></code></pre></div>
<p><code class="sourceCode haskell"><span class="dt">Z</span></code> stands for zero, and <code class="sourceCode haskell"><span class="dt">S</span></code> for successor. The terseness is pretty necessary here, unfortunately: arithmetic becomes unreadable otherwise. The simplicity of this definition is useful for proofs and manipulation; however any runtime representation of these numbers is going to be woefully slow.</p>
<p>With the <code class="sourceCode haskell"><span class="dt">DataKinds</span></code> extension, the above is automatically promoted to the type-level, so we can write type-level functions (type families) on the <code class="sourceCode haskell"><span class="dt">Peano</span></code> type:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">Plus</span> (<span class="ot">n ::</span> <span class="dt">Peano</span>) (<span class="ot">m ::</span> <span class="dt">Peano</span>)<span class="ot"> ::</span> <span class="dt">Peano</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">        <span class="dt">Plus</span> <span class="dt">Z</span> m <span class="fu">=</span> m</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">        <span class="dt">Plus</span> (<span class="dt">S</span> n) m <span class="fu">=</span> <span class="dt">S</span> (<span class="dt">Plus</span> n m)</a></code></pre></div>
<p>Here the <code class="sourceCode haskell"><span class="dt">TypeFamilies</span></code> extension is needed. I’ll try and mention every extension I’m using as we go, but I might forget a few, so check the repository for all of the examples (quick aside: I <em>did</em> manage to avoid using <code class="sourceCode haskell"><span class="dt">UndecidableInstances</span></code>, but more on that later). One pragma that’s worth mentioning is:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">{-# OPTIONS_GHC -fno-warn-unticked-promoted-constructors #-}</span></a></code></pre></div>
<p>This suppresses warnings on the definition of <code class="sourceCode haskell"><span class="dt">Plus</span></code> above. Without it, GHC would want us to write:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">Plus</span> (<span class="ot">n ::</span> <span class="dt">Peano</span>) (<span class="ot">m ::</span> <span class="dt">Peano</span>)<span class="ot"> ::</span> <span class="dt">Peano</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">        <span class="dt">Plus</span> <span class="ch">&#39;Z m = m</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">        <span class="dt">Plus</span> (<span class="ch">&#39;S n) m = &#39;</span><span class="dt">S</span> (<span class="dt">Plus</span> n m)</a></code></pre></div>
<p>I think that looks pretty ugly, and it can get much worse with more involved arithmetic. The only thing I have found the warnings useful for is <code class="sourceCode haskell">[]</code>: the type-level empty list gives an error in its unticked form.</p>
<h3 id="using-the-type-level-numbers-with-a-pairing-heap">Using the Type-Level Numbers with a Pairing Heap</h3>
<p>In the original post, a pairing heap <span class="citation" data-cites="fredman_pairing_1986">(Fredman et al. <a href="#ref-fredman_pairing_1986">1986</a>)</span> was used, for its simplicity and performance. The implementation looked like this:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Heap</span> n a <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  <span class="dt">E</span><span class="ot"> ::</span> <span class="dt">Heap</span> <span class="dt">Z</span> a</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  <span class="dt">T</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">HVec</span> n a <span class="ot">-&gt;</span> <span class="dt">Heap</span> (<span class="dt">S</span> n) a</a>
<a class="sourceLine" id="cb6-4" data-line-number="4"></a>
<a class="sourceLine" id="cb6-5" data-line-number="5"><span class="kw">data</span> <span class="dt">HVec</span> n a <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">  <span class="dt">HNil</span><span class="ot"> ::</span> <span class="dt">HVec</span> <span class="dt">Z</span> a</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">  <span class="dt">HCons</span><span class="ot"> ::</span> <span class="dt">Heap</span> m a <span class="ot">-&gt;</span> <span class="dt">HVec</span> n a <span class="ot">-&gt;</span> <span class="dt">HVec</span> (<span class="dt">Plus</span> m n) a</a></code></pre></div>
<p>You immediately run into trouble when you try to define merge:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">merge ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Heap</span> m a <span class="ot">-&gt;</span> <span class="dt">Heap</span> n a <span class="ot">-&gt;</span> <span class="dt">Heap</span> (<span class="dt">Plus</span> m n) a</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">merge <span class="dt">E</span> ys <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">merge xs <span class="dt">E</span> <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">merge h1<span class="fu">@</span>(<span class="dt">T</span> x xs) h2<span class="fu">@</span>(<span class="dt">T</span> y ys)</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">  <span class="fu">|</span> x <span class="fu">&lt;=</span> y <span class="fu">=</span> <span class="dt">T</span> x (<span class="dt">HCons</span> h2 xs)</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">T</span> y (<span class="dt">HCons</span> h1 ys)</a></code></pre></div>
<p>Three errors show up here, but we’ll look at the first one:</p>
<blockquote>
<p><code>Could not deduce (m ~ (Plus m Z))</code></p>
</blockquote>
<p>GHC doesn’t know that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mi>x</mi><mo>+</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x = x + 0</annotation></semantics></math>. Somehow, we’ll have to <em>prove</em> that it does.</p>
<h3 id="singletons">Singletons</h3>
<p>In a language with true dependent types, proving the proposition above is as simple as:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode idris"><code class="sourceCode idris"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="fu">plusZeroNeutral</span> <span class="ot">:</span> (n <span class="ot">:</span> <span class="dt">Nat</span>) <span class="ot">-&gt;</span> n <span class="fu">+</span> <span class="dv">0</span> <span class="fu">=</span> n</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">plusZeroNeutral <span class="dt">Z</span> <span class="fu">=</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">plusZeroNeutral (<span class="dt">S</span> k) <span class="fu">=</span> cong (plusZeroNeutral k)</a></code></pre></div>
<p>(this example is in Idris)</p>
<p>In Haskell, on the other hand, we can’t do the same: functions on the value-level <code class="sourceCode haskell"><span class="dt">Peano</span></code> have no relationship with functions on the type-level <code class="sourceCode haskell"><span class="dt">Peano</span></code>. There’s no way to automatically link or promote one to the other.</p>
<p>This is where singletons come in <span class="citation" data-cites="eisenberg_dependently_2012">(Eisenberg and Weirich <a href="#ref-eisenberg_dependently_2012">2012</a>)</span>. A singleton is a datatype which mirrors a type-level value exactly, except that it has a type parameter which matches the equivalent value on the type-level. In this way, we can write functions on the value-level which are linked to the type-level. Here’s a potential singleton for <code class="sourceCode haskell"><span class="dt">Peano</span></code>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Natty</span> n <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">    <span class="dt">Zy</span><span class="ot"> ::</span> <span class="dt">Natty</span> <span class="dt">Z</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">    <span class="dt">Sy</span><span class="ot"> ::</span> <span class="dt">Natty</span> n <span class="ot">-&gt;</span> <span class="dt">Natty</span> (<span class="dt">S</span> n)</a></code></pre></div>
<p>(we need <code class="sourceCode haskell"><span class="dt">GADTs</span></code> for this example)</p>
<p>Now, when we pattern-match on <code class="sourceCode haskell"><span class="dt">Natty</span></code>, we get a proof of whatever its type parameter was. Here’s a trivial example:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">isZero ::</span> <span class="dt">Natty</span> n <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (n <span class="fu">:~:</span> <span class="dt">Z</span>)</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">isZero <span class="dt">Zy</span> <span class="fu">=</span> <span class="dt">Just</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3">isZero (<span class="dt">Sy</span> _) <span class="fu">=</span> <span class="dt">Nothing</span></a></code></pre></div>
<p>When we match on <code class="sourceCode haskell"><span class="dt">Zy</span></code>, the <em>only value</em> which <code class="sourceCode haskell">n</code> could have been is <code class="sourceCode haskell"><span class="dt">Z</span></code>, because the only way to construct <code class="sourceCode haskell"><span class="dt">Zy</span></code> is if the type parameter is <code class="sourceCode haskell"><span class="dt">Z</span></code>.</p>
<p>Using this technique, the <code class="sourceCode haskell">plusZeroNeutral</code> proof looks reasonably similar to the Idris version:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">plusZeroNeutral ::</span> <span class="dt">Natty</span> n <span class="ot">-&gt;</span> <span class="dt">Plus</span> n <span class="dt">Z</span> <span class="fu">:~:</span> n</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">plusZeroNeutral <span class="dt">Zy</span> <span class="fu">=</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">plusZeroNeutral (<span class="dt">Sy</span> n) <span class="fu">=</span> <span class="kw">case</span> plusZeroNeutral n <span class="kw">of</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4">    <span class="dt">Refl</span> <span class="ot">-&gt;</span> <span class="dt">Refl</span></a></code></pre></div>
<p>To generalize the singletons a little, we could probably use the <a href="https://hackage.haskell.org/package/singletons">singletons</a> library, or we could roll our own:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">data</span> family <span class="dt">The</span><span class="ot"> k ::</span> k <span class="ot">-&gt;</span> <span class="dt">Type</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2"></a>
<a class="sourceLine" id="cb12-3" data-line-number="3"><span class="kw">data</span> <span class="kw">instance</span> <span class="dt">The</span> <span class="dt">Peano</span> n <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">    <span class="dt">Zy</span><span class="ot"> ::</span> <span class="dt">The</span> <span class="dt">Peano</span> <span class="dt">Z</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5">    <span class="dt">Sy</span><span class="ot"> ::</span> <span class="dt">The</span> <span class="dt">Peano</span> n <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Peano</span> (<span class="dt">S</span> n)</a>
<a class="sourceLine" id="cb12-6" data-line-number="6"></a>
<a class="sourceLine" id="cb12-7" data-line-number="7"><span class="ot">plusZeroNeutral ::</span> <span class="dt">The</span> <span class="dt">Peano</span> n <span class="ot">-&gt;</span> <span class="dt">Plus</span> n <span class="dt">Z</span> <span class="fu">:~:</span> n</a>
<a class="sourceLine" id="cb12-8" data-line-number="8">plusZeroNeutral <span class="dt">Zy</span> <span class="fu">=</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb12-9" data-line-number="9">plusZeroNeutral (<span class="dt">Sy</span> n) <span class="fu">=</span> <span class="kw">case</span> plusZeroNeutral n <span class="kw">of</span></a>
<a class="sourceLine" id="cb12-10" data-line-number="10">    <span class="dt">Refl</span> <span class="ot">-&gt;</span> <span class="dt">Refl</span></a></code></pre></div>
<p>The <code class="sourceCode haskell"><span class="dt">The</span></code> naming is kind of cute, I think. It makes the signature look <em>almost</em> like the Idris version (<code class="sourceCode idris">the</code> is a function from the Idris standard library). The <code class="sourceCode haskell"><span class="dt">The</span></code> type family requires the <code class="sourceCode haskell"><span class="dt">TypeInType</span></code> extension, which I’ll talk a little more about later.</p>
<h3 id="proof-erasure-and-totality">Proof Erasure and Totality</h3>
<p>There’s an issue with these kinds of proofs: the proof code runs <em>every time</em> it is needed. Since the same value is coming out the other end each time (<code class="sourceCode haskell"><span class="dt">Refl</span></code>), this seems wasteful.</p>
<p>In a language like Idris, this problem is avoided by noticing that you’re only using the proof for its type information, and then erasing it at runtime. In Haskell, we can accomplish the same with a rule:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="ot">{-# NOINLINE plusZeroNeutral #-}</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2"></a>
<a class="sourceLine" id="cb13-3" data-line-number="3"><span class="ot">{-# RULES</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4"><span class="ot">&quot;plusZeroNeutral&quot; forall x. plusZeroNeutral x </span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5"><span class="ot">  = unsafeCoerce (Refl :: &#39;Z :~: &#39;Z)</span></a>
<a class="sourceLine" id="cb13-6" data-line-number="6"><span class="ot"> #-}</span></a></code></pre></div>
<p>This basically says “if this type-checks, then the proof must exist, and therefore the proof must be valid. So don’t bother running it”. Unfortunately, that’s a <em>little bit</em> of a lie. It’s pretty easy to write a proof which type-checks that <em>isn’t</em> valid:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="ot">falseIsTrue ::</span> <span class="dt">False</span> <span class="fu">:~:</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2">falseIsTrue <span class="fu">=</span> falseIsTrue</a></code></pre></div>
<p>We won’t be able to perform computations which rely on this proof in Haskell, though: because the computation will never terminate, the proof will never provide an answer. This means that, while the proof isn’t valid, it <em>is</em> type safe. That is, of course, unless we use our manual proof-erasure technique. The <code class="sourceCode haskell"><span class="dt">RULES</span></code> pragma will happily replace it with the <code class="sourceCode haskell">unsafeCoerce</code> version, effectively introducing unsoundness into our proofs. The reason that this doesn’t cause a problem for language like Idris is that Idris has a totality checker: you <em>can’t</em> write the above definition (with the totality checker turned on) in Idris.</p>
<p>So what’s the solution? Do we have to suffer through the slower proof code to maintain correctness? In reality, it’s usually OK to assume termination. It’s pretty easy to see that a proof like <code class="sourceCode haskell">plusZeroNeutral</code> is total. It’s worth bearing in mind, though, that until Haskell gets a totality checker (<a href="https://typesandkinds.wordpress.com/2016/07/24/dependent-types-in-haskell-progress-report/">likely never</a>, apparently) these proofs aren’t “proper”.</p>
<h3 id="generating-singletons">Generating Singletons</h3>
<p>One extra thing: while you’re proving things in one area of your code, you might not have the relevant singleton handy. To generate them on-demand, you’ll need a typeclass:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="kw">class</span> <span class="dt">KnownSing</span> (<span class="ot">x ::</span> k) <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2"><span class="ot">    sing ::</span> <span class="dt">The</span> k x</a>
<a class="sourceLine" id="cb15-3" data-line-number="3"></a>
<a class="sourceLine" id="cb15-4" data-line-number="4"><span class="kw">instance</span> <span class="dt">KnownSing</span> <span class="dt">Z</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-5" data-line-number="5">    sing <span class="fu">=</span> <span class="dt">Zy</span></a>
<a class="sourceLine" id="cb15-6" data-line-number="6"></a>
<a class="sourceLine" id="cb15-7" data-line-number="7"><span class="kw">instance</span> <span class="dt">KnownSing</span> n <span class="ot">=&gt;</span> <span class="dt">KnownSing</span> (<span class="dt">S</span> n) <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-8" data-line-number="8">    sing <span class="fu">=</span> <span class="dt">Sy</span> sing</a></code></pre></div>
<p>This kind of drives home the inefficiency of singleton-based proofs, and why it’s important to erase them aggressively.</p>
<h3 id="proofs-bundled-with-the-data-structure">Proofs Bundled with the Data Structure</h3>
<p>One other way to solve these problems is to try find a data structure which runs the proof code anyway. As an example, consider a length-indexed list:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:-</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2"><span class="kw">data</span> <span class="dt">List</span> n a <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3">    <span class="dt">Nil</span><span class="ot"> ::</span> <span class="dt">List</span> <span class="dt">Z</span> a</a>
<a class="sourceLine" id="cb16-4" data-line-number="4"><span class="ot">    (:-) ::</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> n a <span class="ot">-&gt;</span> <span class="dt">List</span> (<span class="dt">S</span> n) a</a></code></pre></div>
<p>You might worry that concatenation of two lists requires some expensive proof code, like <code class="sourceCode haskell">merge</code> for the pairing heap. Maybe surprisingly, the default implementation just works:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">++</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2"><span class="ot">(++) ::</span> <span class="dt">List</span> n a <span class="ot">-&gt;</span> <span class="dt">List</span> m a <span class="ot">-&gt;</span> <span class="dt">List</span> (<span class="dt">Plus</span> n m) a</a>
<a class="sourceLine" id="cb17-3" data-line-number="3">(<span class="fu">++</span>) <span class="dt">Nil</span> ys <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb17-4" data-line-number="4">(<span class="fu">++</span>) (x <span class="fu">:-</span> xs) ys <span class="fu">=</span> x <span class="fu">:-</span> xs <span class="fu">++</span> ys</a></code></pre></div>
<p>Why? Well, if you look back to the definition of <code class="sourceCode haskell"><span class="dt">Plus</span></code>, it’s almost exactly the same as the definition of <code class="sourceCode haskell">(<span class="fu">++</span>)</code>. In effect, we’re using <em>lists</em> as the singleton for <code class="sourceCode haskell"><span class="dt">Peano</span></code> here.</p>
<p>The question is, then: is there a heap which performs these proofs automatically for functions like merge? As far as I can tell: <em>almost</em>. First though:</p>
<h3 id="small-digression-manipulating-and-using-the-length-indexed-list">Small Digression: Manipulating and Using the Length-Indexed List</h3>
<p>The standard definition of <code class="sourceCode haskell"><span class="fu">++</span></code> on normal lists can be cleaned up a little with <code class="sourceCode haskell">foldr</code></p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="ot">(++) ::</span> [a] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">(<span class="fu">++</span>) <span class="fu">=</span> flip (foldr (<span class="fu">:</span>))</a></code></pre></div>
<p>Can we get a similar definition for our length-indexed lists? Turns out we can, but the type of <code class="sourceCode haskell">foldr</code> needs to be a little different:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="ot">foldrList ::</span> (forall x<span class="fu">.</span> a <span class="ot">-&gt;</span> b x <span class="ot">-&gt;</span> b (<span class="dt">S</span> x)) </a>
<a class="sourceLine" id="cb19-2" data-line-number="2">          <span class="ot">-&gt;</span> b m <span class="ot">-&gt;</span> <span class="dt">List</span> n a <span class="ot">-&gt;</span> b (n <span class="fu">+</span> m)</a>
<a class="sourceLine" id="cb19-3" data-line-number="3">foldrList f b <span class="dt">Nil</span> <span class="fu">=</span> b</a>
<a class="sourceLine" id="cb19-4" data-line-number="4">foldrList f b (x <span class="fu">:-</span> xs) <span class="fu">=</span> f x (foldrList f b xs)</a>
<a class="sourceLine" id="cb19-5" data-line-number="5"></a>
<a class="sourceLine" id="cb19-6" data-line-number="6"><span class="kw">newtype</span> <span class="dt">Flip</span> (<span class="ot">f ::</span> t <span class="ot">-&gt;</span> u <span class="ot">-&gt;</span> <span class="dt">Type</span>) (<span class="ot">a ::</span> u) (<span class="ot">b ::</span> t) </a>
<a class="sourceLine" id="cb19-7" data-line-number="7">    <span class="fu">=</span> <span class="dt">Flip</span> {<span class="ot"> unFlip ::</span> f b a }</a>
<a class="sourceLine" id="cb19-8" data-line-number="8"></a>
<a class="sourceLine" id="cb19-9" data-line-number="9"><span class="ot">foldrList1 ::</span> (forall x<span class="fu">.</span> a <span class="ot">-&gt;</span> b x c <span class="ot">-&gt;</span> b (<span class="dt">S</span> x) c) </a>
<a class="sourceLine" id="cb19-10" data-line-number="10">           <span class="ot">-&gt;</span> b m c <span class="ot">-&gt;</span> <span class="dt">List</span> n a <span class="ot">-&gt;</span> b (n <span class="fu">+</span> m) c</a>
<a class="sourceLine" id="cb19-11" data-line-number="11">foldrList1 f b </a>
<a class="sourceLine" id="cb19-12" data-line-number="12">    <span class="fu">=</span> unFlip <span class="fu">.</span> foldrList (\e <span class="ot">-&gt;</span> <span class="dt">Flip</span> <span class="fu">.</span> f e <span class="fu">.</span> unFlip) (<span class="dt">Flip</span> b)</a>
<a class="sourceLine" id="cb19-13" data-line-number="13"></a>
<a class="sourceLine" id="cb19-14" data-line-number="14"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">++</span></a>
<a class="sourceLine" id="cb19-15" data-line-number="15"><span class="ot">(++) ::</span> <span class="dt">List</span> n a <span class="ot">-&gt;</span> <span class="dt">List</span> m a <span class="ot">-&gt;</span> <span class="dt">List</span> (n <span class="fu">+</span> m) a</a>
<a class="sourceLine" id="cb19-16" data-line-number="16">(<span class="fu">++</span>) <span class="fu">=</span> flip (foldrList1 (<span class="fu">:-</span>))</a></code></pre></div>
<p>So what’s the point of this more complicated version? Well, if this were normal Haskell, we might get some foldr-fusion or something (in reality we would probably use <a href="http://hackage.haskell.org/package/base-4.9.1.0/docs/GHC-Exts.html#v:augment"><code class="sourceCode haskell">augment</code></a> if that were the purpose).</p>
<p>With this type-level business, though, there’s a similar application: loop unrolling. Consider the natural-number type again. We can write a typeclass which will perform induction over them:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="kw">class</span> <span class="dt">KnownPeano</span> (<span class="ot">n ::</span> <span class="dt">Peano</span>)  <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2"><span class="ot">    unrollRepeat ::</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb20-3" data-line-number="3"></a>
<a class="sourceLine" id="cb20-4" data-line-number="4"><span class="kw">instance</span> <span class="dt">KnownPeano</span> <span class="dt">Z</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-5" data-line-number="5">    unrollRepeat _ <span class="fu">=</span> const id</a>
<a class="sourceLine" id="cb20-6" data-line-number="6">    <span class="ot">{-# INLINE unrollRepeat #-}</span></a>
<a class="sourceLine" id="cb20-7" data-line-number="7"></a>
<a class="sourceLine" id="cb20-8" data-line-number="8"><span class="kw">instance</span> <span class="dt">KnownPeano</span> n <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb20-9" data-line-number="9">         <span class="dt">KnownPeano</span> (<span class="dt">S</span> n) <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-10" data-line-number="10">    unrollRepeat (<span class="ot">_ ::</span> <span class="dt">Proxy</span> (<span class="dt">S</span> n)) f x <span class="fu">=</span></a>
<a class="sourceLine" id="cb20-11" data-line-number="11">        f (unrollRepeat (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> n) f x)</a>
<a class="sourceLine" id="cb20-12" data-line-number="12">    <span class="ot">{-# INLINE unrollRepeat #-}</span></a></code></pre></div>
<p>Because the recursion here calls a different <code class="sourceCode haskell">unrollRepeat</code> function in the “recursive” call, we get around the <a href="http://stackoverflow.com/questions/42179783/is-there-any-way-to-inline-a-recursive-function">usual hurdle</a> of not being able to inline recursive calls. That means that the whole loop will be unrolled, at compile-time. We can do the same for foldr:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="kw">class</span> <span class="dt">HasFoldr</span> (<span class="ot">n ::</span> <span class="dt">Peano</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-2" data-line-number="2">    unrollFoldr </a>
<a class="sourceLine" id="cb21-3" data-line-number="3"><span class="ot">        ::</span> (forall x<span class="fu">.</span> a <span class="ot">-&gt;</span> b x <span class="ot">-&gt;</span> b (<span class="dt">S</span> x)) </a>
<a class="sourceLine" id="cb21-4" data-line-number="4">        <span class="ot">-&gt;</span> b m </a>
<a class="sourceLine" id="cb21-5" data-line-number="5">        <span class="ot">-&gt;</span> <span class="dt">List</span> n a </a>
<a class="sourceLine" id="cb21-6" data-line-number="6">        <span class="ot">-&gt;</span> b (n <span class="fu">+</span> m)</a>
<a class="sourceLine" id="cb21-7" data-line-number="7">  </a>
<a class="sourceLine" id="cb21-8" data-line-number="8"><span class="kw">instance</span> <span class="dt">HasFoldr</span> <span class="dt">Z</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-9" data-line-number="9">    unrollFoldr _ b _ <span class="fu">=</span> b</a>
<a class="sourceLine" id="cb21-10" data-line-number="10">    <span class="ot">{-# INLINE unrollFoldr #-}</span></a>
<a class="sourceLine" id="cb21-11" data-line-number="11"></a>
<a class="sourceLine" id="cb21-12" data-line-number="12"><span class="kw">instance</span> <span class="dt">HasFoldr</span> n <span class="ot">=&gt;</span> <span class="dt">HasFoldr</span> (<span class="dt">S</span> n) <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-13" data-line-number="13">    unrollFoldr f b (x <span class="fu">:-</span> xs) <span class="fu">=</span> f x (unrollFoldr f b xs)</a>
<a class="sourceLine" id="cb21-14" data-line-number="14">    <span class="ot">{-# INLINE unrollFoldr #-}</span></a></code></pre></div>
<p>I can’t think of many uses for this technique, but one that comes to mind is an n-ary uncurry (like Lisp’s <a href="https://en.wikipedia.org/wiki/Apply#Common_Lisp_and_Scheme">apply</a>):</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:-</span></a>
<a class="sourceLine" id="cb22-2" data-line-number="2"><span class="kw">data</span> <span class="dt">List</span> (<span class="ot">xs ::</span> [<span class="fu">*</span>]) <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-3" data-line-number="3">        <span class="dt">Nil</span><span class="ot"> ::</span> <span class="dt">List</span> <span class="ch">&#39;[]</span></a>
<a class="sourceLine" id="cb22-4" data-line-number="4"><span class="ot">        (:-) ::</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> xs <span class="ot">-&gt;</span> <span class="dt">List</span> (a <span class="ch">&#39;: xs)</span></a>
<a class="sourceLine" id="cb22-5" data-line-number="5"></a>
<a class="sourceLine" id="cb22-6" data-line-number="6"><span class="kw">class</span> <span class="dt">KnownList</span> (<span class="ot">xs ::</span> [<span class="fu">*</span>])  <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-7" data-line-number="7">    foldrT</a>
<a class="sourceLine" id="cb22-8" data-line-number="8"><span class="ot">        ::</span> (forall y ys<span class="fu">.</span> y <span class="ot">-&gt;</span> result ys <span class="ot">-&gt;</span> result (y <span class="ch">&#39;: ys))</span></a>
<a class="sourceLine" id="cb22-9" data-line-number="9">        <span class="ot">-&gt;</span> result <span class="ch">&#39;[]</span></a>
<a class="sourceLine" id="cb22-10" data-line-number="10">        <span class="ot">-&gt;</span> <span class="dt">List</span> xs</a>
<a class="sourceLine" id="cb22-11" data-line-number="11">        <span class="ot">-&gt;</span> result xs</a>
<a class="sourceLine" id="cb22-12" data-line-number="12"></a>
<a class="sourceLine" id="cb22-13" data-line-number="13"><span class="kw">instance</span> <span class="dt">KnownList</span> (<span class="ch">&#39;[] :: [*]) where</span></a>
<a class="sourceLine" id="cb22-14" data-line-number="14">    foldrT _ <span class="fu">=</span> const</a>
<a class="sourceLine" id="cb22-15" data-line-number="15">    <span class="ot">{-# INLINE foldrT #-}</span></a>
<a class="sourceLine" id="cb22-16" data-line-number="16"></a>
<a class="sourceLine" id="cb22-17" data-line-number="17"><span class="kw">instance</span> <span class="dt">KnownList</span> xs <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb22-18" data-line-number="18">         <span class="dt">KnownList</span> (x <span class="ch">&#39;: xs) where</span></a>
<a class="sourceLine" id="cb22-19" data-line-number="19">    foldrT f b (x <span class="fu">:-</span> xs) <span class="fu">=</span> f x (foldrT f b xs)</a>
<a class="sourceLine" id="cb22-20" data-line-number="20">    <span class="ot">{-# INLINE foldrT #-}</span></a>
<a class="sourceLine" id="cb22-21" data-line-number="21"></a>
<a class="sourceLine" id="cb22-22" data-line-number="22"><span class="kw">type</span> family <span class="dt">Func</span> (<span class="ot">xs ::</span> [<span class="fu">*</span>]) (<span class="ot">y ::</span> <span class="fu">*</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-23" data-line-number="23">        <span class="dt">Func</span> <span class="ch">&#39;[] y = y</span></a>
<a class="sourceLine" id="cb22-24" data-line-number="24">        <span class="dt">Func</span> (x <span class="ch">&#39;: xs) y = x -&gt; Func xs y</span></a>
<a class="sourceLine" id="cb22-25" data-line-number="25"></a>
<a class="sourceLine" id="cb22-26" data-line-number="26"><span class="kw">newtype</span> <span class="dt">FunType</span> y xs <span class="fu">=</span> <span class="dt">FunType</span></a>
<a class="sourceLine" id="cb22-27" data-line-number="27">    {<span class="ot"> runFun ::</span> <span class="dt">Func</span> xs y <span class="ot">-&gt;</span> y</a>
<a class="sourceLine" id="cb22-28" data-line-number="28">    }</a>
<a class="sourceLine" id="cb22-29" data-line-number="29"></a>
<a class="sourceLine" id="cb22-30" data-line-number="30">uncurry</a>
<a class="sourceLine" id="cb22-31" data-line-number="31"><span class="ot">    ::</span> <span class="dt">KnownList</span> xs</a>
<a class="sourceLine" id="cb22-32" data-line-number="32">    <span class="ot">=&gt;</span> <span class="dt">Func</span> xs y <span class="ot">-&gt;</span> <span class="dt">List</span> xs <span class="ot">-&gt;</span> y</a>
<a class="sourceLine" id="cb22-33" data-line-number="33">uncurry f l <span class="fu">=</span></a>
<a class="sourceLine" id="cb22-34" data-line-number="34">    runFun</a>
<a class="sourceLine" id="cb22-35" data-line-number="35">        (foldrT</a>
<a class="sourceLine" id="cb22-36" data-line-number="36">             (c (\x g h <span class="ot">-&gt;</span> g (h x)))</a>
<a class="sourceLine" id="cb22-37" data-line-number="37">             (<span class="dt">FunType</span> id)</a>
<a class="sourceLine" id="cb22-38" data-line-number="38">             l)</a>
<a class="sourceLine" id="cb22-39" data-line-number="39">        f</a>
<a class="sourceLine" id="cb22-40" data-line-number="40">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-41" data-line-number="41"><span class="ot">    c ::</span> (a <span class="ot">-&gt;</span> ((<span class="dt">Func</span> xs y <span class="ot">-&gt;</span> y) <span class="ot">-&gt;</span> (<span class="dt">Func</span> zs z <span class="ot">-&gt;</span> z)))</a>
<a class="sourceLine" id="cb22-42" data-line-number="42">      <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> (<span class="dt">FunType</span> y xs <span class="ot">-&gt;</span> <span class="dt">FunType</span> z zs))</a>
<a class="sourceLine" id="cb22-43" data-line-number="43">    c <span class="fu">=</span> coerce</a>
<a class="sourceLine" id="cb22-44" data-line-number="44">    <span class="ot">{-# INLINE c #-}</span></a>
<a class="sourceLine" id="cb22-45" data-line-number="45"><span class="ot">{-# INLINE uncurry #-}</span></a></code></pre></div>
<p>I <em>think</em> that you can be guaranteed the above is inlined at compile-time, making it essentially equivalent to a handwritten <code class="sourceCode haskell">uncurry</code>.</p>
<h3 id="binomial-heaps">Binomial Heaps</h3>
<p>Anyway, back to the size-indexed heaps. The reason that <code class="sourceCode haskell">(<span class="fu">++</span>)</code> worked so easily on lists is that a list can be thought of as the data-structure equivalent to Peano numbers. Another numeric-system-based data structure is the binomial heap, which is based on binary numbering <span class="citation" data-cites="hinze_functional_1999">(I’m going mainly off of the description from Hinze <a href="#ref-hinze_functional_1999">1999</a>)</span>.</p>
<p>So, to work with binary numbers, let’s get some preliminaries on the type-level out of the way:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="kw">data</span> <span class="kw">instance</span> <span class="dt">The</span> <span class="dt">Bool</span> x <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-2" data-line-number="2">    <span class="dt">Falsy</span><span class="ot"> ::</span> <span class="dt">The</span> <span class="dt">Bool</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb23-3" data-line-number="3">    <span class="dt">Truey</span><span class="ot"> ::</span> <span class="dt">The</span> <span class="dt">Bool</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb23-4" data-line-number="4"></a>
<a class="sourceLine" id="cb23-5" data-line-number="5"><span class="kw">data</span> <span class="kw">instance</span> <span class="dt">The</span> [k] xs <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-6" data-line-number="6">    <span class="dt">Nily</span><span class="ot"> ::</span> <span class="dt">The</span> [k] <span class="ch">&#39;[]</span></a>
<a class="sourceLine" id="cb23-7" data-line-number="7">    <span class="dt">Cony</span><span class="ot"> ::</span> <span class="dt">The</span> k x <span class="ot">-&gt;</span> <span class="dt">The</span> [k] xs <span class="ot">-&gt;</span> <span class="dt">The</span> [k] (x <span class="fu">:</span> xs)</a>
<a class="sourceLine" id="cb23-8" data-line-number="8"></a>
<a class="sourceLine" id="cb23-9" data-line-number="9"><span class="kw">instance</span> <span class="dt">KnownSing</span> <span class="dt">True</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-10" data-line-number="10">    sing <span class="fu">=</span> <span class="dt">Truey</span></a>
<a class="sourceLine" id="cb23-11" data-line-number="11"></a>
<a class="sourceLine" id="cb23-12" data-line-number="12"><span class="kw">instance</span> <span class="dt">KnownSing</span> <span class="dt">False</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-13" data-line-number="13">    sing <span class="fu">=</span> <span class="dt">Falsy</span></a>
<a class="sourceLine" id="cb23-14" data-line-number="14"></a>
<a class="sourceLine" id="cb23-15" data-line-number="15"><span class="kw">instance</span> <span class="dt">KnownSing</span> <span class="ch">&#39;[] where</span></a>
<a class="sourceLine" id="cb23-16" data-line-number="16">    sing <span class="fu">=</span> <span class="dt">Nily</span></a>
<a class="sourceLine" id="cb23-17" data-line-number="17"></a>
<a class="sourceLine" id="cb23-18" data-line-number="18"><span class="kw">instance</span> (<span class="dt">KnownSing</span> xs, <span class="dt">KnownSing</span> x) <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb23-19" data-line-number="19">         <span class="dt">KnownSing</span> (x <span class="fu">:</span> xs) <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-20" data-line-number="20">    sing <span class="fu">=</span> <span class="dt">Cony</span> sing sing</a></code></pre></div>
<p>We’ll represent a binary number as a list of Booleans:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">Sum</span> (<span class="ot">x ::</span> <span class="dt">Bool</span>) (<span class="ot">y ::</span> <span class="dt">Bool</span>) (<span class="ot">cin ::</span> <span class="dt">Bool</span>)<span class="ot"> ::</span> <span class="dt">Bool</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-2" data-line-number="2">        <span class="dt">Sum</span> <span class="dt">False</span> <span class="dt">False</span> <span class="dt">False</span> <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb24-3" data-line-number="3">        <span class="dt">Sum</span> <span class="dt">False</span> <span class="dt">False</span> <span class="dt">True</span>  <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb24-4" data-line-number="4">        <span class="dt">Sum</span> <span class="dt">False</span> <span class="dt">True</span>  <span class="dt">False</span> <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb24-5" data-line-number="5">        <span class="dt">Sum</span> <span class="dt">False</span> <span class="dt">True</span>  <span class="dt">True</span>  <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb24-6" data-line-number="6">        <span class="dt">Sum</span> <span class="dt">True</span>  <span class="dt">False</span> <span class="dt">False</span> <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb24-7" data-line-number="7">        <span class="dt">Sum</span> <span class="dt">True</span>  <span class="dt">False</span> <span class="dt">True</span>  <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb24-8" data-line-number="8">        <span class="dt">Sum</span> <span class="dt">True</span>  <span class="dt">True</span>  <span class="dt">False</span> <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb24-9" data-line-number="9">        <span class="dt">Sum</span> <span class="dt">True</span>  <span class="dt">True</span>  <span class="dt">True</span>  <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb24-10" data-line-number="10"></a>
<a class="sourceLine" id="cb24-11" data-line-number="11"><span class="kw">type</span> family <span class="dt">Carry</span> (<span class="ot">x ::</span> <span class="dt">Bool</span>) (<span class="ot">y ::</span> <span class="dt">Bool</span>) (<span class="ot">cin ::</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb24-12" data-line-number="12">     (<span class="ot">xs ::</span> [<span class="dt">Bool</span>]) (<span class="ot">ys ::</span> [<span class="dt">Bool</span>])<span class="ot"> ::</span> [<span class="dt">Bool</span>] <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-13" data-line-number="13">        <span class="dt">Carry</span> <span class="dt">False</span> <span class="dt">False</span> <span class="dt">False</span> xs ys <span class="fu">=</span> <span class="dt">Add</span> <span class="dt">False</span> xs ys</a>
<a class="sourceLine" id="cb24-14" data-line-number="14">        <span class="dt">Carry</span> <span class="dt">False</span> <span class="dt">False</span> <span class="dt">True</span>  xs ys <span class="fu">=</span> <span class="dt">Add</span> <span class="dt">False</span> xs ys</a>
<a class="sourceLine" id="cb24-15" data-line-number="15">        <span class="dt">Carry</span> <span class="dt">False</span> <span class="dt">True</span>  <span class="dt">False</span> xs ys <span class="fu">=</span> <span class="dt">Add</span> <span class="dt">False</span> xs ys</a>
<a class="sourceLine" id="cb24-16" data-line-number="16">        <span class="dt">Carry</span> <span class="dt">False</span> <span class="dt">True</span>  <span class="dt">True</span>  xs ys <span class="fu">=</span> <span class="dt">Add</span> <span class="dt">True</span>  xs ys</a>
<a class="sourceLine" id="cb24-17" data-line-number="17">        <span class="dt">Carry</span> <span class="dt">True</span>  <span class="dt">False</span> <span class="dt">False</span> xs ys <span class="fu">=</span> <span class="dt">Add</span> <span class="dt">False</span> xs ys</a>
<a class="sourceLine" id="cb24-18" data-line-number="18">        <span class="dt">Carry</span> <span class="dt">True</span>  <span class="dt">False</span> <span class="dt">True</span>  xs ys <span class="fu">=</span> <span class="dt">Add</span> <span class="dt">True</span>  xs ys</a>
<a class="sourceLine" id="cb24-19" data-line-number="19">        <span class="dt">Carry</span> <span class="dt">True</span>  <span class="dt">True</span>  <span class="dt">False</span> xs ys <span class="fu">=</span> <span class="dt">Add</span> <span class="dt">True</span>  xs ys</a>
<a class="sourceLine" id="cb24-20" data-line-number="20">        <span class="dt">Carry</span> <span class="dt">True</span>  <span class="dt">True</span>  <span class="dt">True</span>  xs ys <span class="fu">=</span> <span class="dt">Add</span> <span class="dt">True</span>  xs ys</a>
<a class="sourceLine" id="cb24-21" data-line-number="21"></a>
<a class="sourceLine" id="cb24-22" data-line-number="22"><span class="kw">type</span> family <span class="dt">Add</span> (<span class="ot">cin ::</span> <span class="dt">Bool</span>) (<span class="ot">xs ::</span> [<span class="dt">Bool</span>]) (<span class="ot">ys ::</span> [<span class="dt">Bool</span>]) <span class="ot">::</span></a>
<a class="sourceLine" id="cb24-23" data-line-number="23">     [<span class="dt">Bool</span>] <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-24" data-line-number="24">        <span class="dt">Add</span> c (x <span class="fu">:</span> xs) (y <span class="fu">:</span> ys) <span class="fu">=</span> <span class="dt">Sum</span> x y c <span class="fu">:</span> <span class="dt">Carry</span> x y c xs ys</a>
<a class="sourceLine" id="cb24-25" data-line-number="25">        <span class="dt">Add</span> <span class="dt">False</span> <span class="ch">&#39;[] ys = ys</span></a>
<a class="sourceLine" id="cb24-26" data-line-number="26">        <span class="dt">Add</span> <span class="dt">False</span> xs <span class="ch">&#39;[] = xs</span></a>
<a class="sourceLine" id="cb24-27" data-line-number="27">        <span class="dt">Add</span> <span class="dt">True</span>  <span class="ch">&#39;[] ys = CarryOne ys</span></a>
<a class="sourceLine" id="cb24-28" data-line-number="28">        <span class="dt">Add</span> <span class="dt">True</span>  xs <span class="ch">&#39;[] = CarryOne xs</span></a>
<a class="sourceLine" id="cb24-29" data-line-number="29"></a>
<a class="sourceLine" id="cb24-30" data-line-number="30"><span class="kw">type</span> family <span class="dt">CarryOne</span> (<span class="ot">xs ::</span> [<span class="dt">Bool</span>])<span class="ot"> ::</span> [<span class="dt">Bool</span>] <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-31" data-line-number="31">        <span class="dt">CarryOne</span> <span class="ch">&#39;[] = True : &#39;</span>[]</a>
<a class="sourceLine" id="cb24-32" data-line-number="32">        <span class="dt">CarryOne</span> (<span class="dt">False</span> <span class="fu">:</span> xs) <span class="fu">=</span> <span class="dt">True</span> <span class="fu">:</span> xs</a>
<a class="sourceLine" id="cb24-33" data-line-number="33">        <span class="dt">CarryOne</span> (<span class="dt">True</span>  <span class="fu">:</span> xs) <span class="fu">=</span> <span class="dt">False</span> <span class="fu">:</span> <span class="dt">CarryOne</span> xs</a></code></pre></div>
<p>The odd definition of <code class="sourceCode haskell"><span class="dt">Carry</span></code> is to avoid <code class="sourceCode haskell"><span class="dt">UndecidableInstances</span></code>: if we had written, instead:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">Carry</span> (<span class="ot">x ::</span> <span class="dt">Bool</span>) (<span class="ot">y ::</span> <span class="dt">Bool</span>) (<span class="ot">cin ::</span> <span class="dt">Bool</span>)<span class="ot"> ::</span> <span class="dt">Bool</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-2" data-line-number="2">        <span class="dt">Carry</span> <span class="dt">False</span> <span class="dt">False</span> <span class="dt">False</span> <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb25-3" data-line-number="3">        <span class="dt">Carry</span> <span class="dt">False</span> <span class="dt">False</span> <span class="dt">True</span>  <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb25-4" data-line-number="4">        <span class="dt">Carry</span> <span class="dt">False</span> <span class="dt">True</span>  <span class="dt">False</span> <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb25-5" data-line-number="5">        <span class="dt">Carry</span> <span class="dt">False</span> <span class="dt">True</span>  <span class="dt">True</span>  <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb25-6" data-line-number="6">        <span class="dt">Carry</span> <span class="dt">True</span>  <span class="dt">False</span> <span class="dt">False</span> <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb25-7" data-line-number="7">        <span class="dt">Carry</span> <span class="dt">True</span>  <span class="dt">False</span> <span class="dt">True</span>  <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb25-8" data-line-number="8">        <span class="dt">Carry</span> <span class="dt">True</span>  <span class="dt">True</span>  <span class="dt">False</span> <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb25-9" data-line-number="9">        <span class="dt">Carry</span> <span class="dt">True</span>  <span class="dt">True</span>  <span class="dt">True</span>  <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb25-10" data-line-number="10"></a>
<a class="sourceLine" id="cb25-11" data-line-number="11"><span class="kw">type</span> family <span class="dt">Add</span> (<span class="ot">cin ::</span> <span class="dt">Bool</span>) (<span class="ot">xs ::</span> [<span class="dt">Bool</span>]) (<span class="ot">ys ::</span> [<span class="dt">Bool</span>]) <span class="ot">::</span></a>
<a class="sourceLine" id="cb25-12" data-line-number="12">     [<span class="dt">Bool</span>] <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-13" data-line-number="13">        <span class="dt">Add</span> c (x <span class="fu">:</span> xs) (y <span class="fu">:</span> ys) <span class="fu">=</span> <span class="dt">Sum</span> x y c <span class="fu">:</span> <span class="dt">Add</span> (<span class="dt">Carry</span> x y c) xs ys</a>
<a class="sourceLine" id="cb25-14" data-line-number="14">        <span class="dt">Add</span> <span class="dt">False</span> <span class="ch">&#39;[] ys = ys</span></a>
<a class="sourceLine" id="cb25-15" data-line-number="15">        <span class="dt">Add</span> <span class="dt">False</span> xs <span class="ch">&#39;[] = xs</span></a>
<a class="sourceLine" id="cb25-16" data-line-number="16">        <span class="dt">Add</span> <span class="dt">True</span>  <span class="ch">&#39;[] ys = CarryOne ys</span></a>
<a class="sourceLine" id="cb25-17" data-line-number="17">        <span class="dt">Add</span> <span class="dt">True</span>  xs <span class="ch">&#39;[] = CarryOne xs</span></a></code></pre></div>
<p>We would have been warned about nested type-family application.</p>
<p>Now we can base the merge function very closely on these type families. First, though, we’ll have to implement the heap.</p>
<h3 id="almost-verified-data-structures">Almost-Verified Data Structures</h3>
<p>There are different potential properties you can verify in a data structure. In the sort-traversable post, the property of interest was that the number of elements in the structure would stay the same after adding and removing some number <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> of elements. For this post, we’ll also verify structural invariants. I won’t, however, verify the <a href="https://www.cs.cmu.edu/~adamchik/15-121/lectures/Binary%20Heaps/heaps.html">heap property</a>. Maybe in a later post.</p>
<p>When indexing a data structure by its size, you encode an awful lot of information into the type signature: the type becomes very <em>specific</em> to the structure in question. It is possible, though, to encode a fair few structural invariants <em>without</em> getting so specific. Here’s a signature for “perfect leaf tree”:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="kw">data</span> <span class="dt">BalTree</span> a <span class="fu">=</span> <span class="dt">Leaf</span> a <span class="fu">|</span> <span class="dt">Node</span> (<span class="dt">BalTree</span> (a,a))</a></code></pre></div>
<p>With that signature, it’s <em>impossible</em> to create a tree with more elements in its left branch than its right; the size of the tree, however, remains unspecified. You can use a similar trick to implement <a href="https://github.com/oisdk/Square">matrices which must be square</a> <span class="citation" data-cites="okasaki_fast_1999">(from Okasaki <a href="#ref-okasaki_fast_1999">1999</a>)</span>: the usual trick (<code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Matrix</span> n a <span class="fu">=</span> <span class="dt">List</span> n (<span class="dt">List</span> n a)</code>) is too specific, providing size information at compile-time. If you’re interested in this approach, there are several more examples in <span class="citation" data-cites="hinze_manufacturing_2001">Hinze (<a href="#ref-hinze_manufacturing_2001">2001</a>)</span>.</p>
<p>It is possible to go from the size-indexed version back to the non-indexed version, with an existential (<code class="sourceCode haskell"><span class="dt">RankNTypes</span></code> for this example):</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="kw">data</span> <span class="dt">ErasedSize</span> f a <span class="fu">=</span> forall (<span class="ot">n ::</span> <span class="dt">Peano</span>)<span class="fu">.</span> <span class="dt">ErasedSize</span></a>
<a class="sourceLine" id="cb27-2" data-line-number="2">    {<span class="ot"> runErasedSize ::</span> f n a</a>
<a class="sourceLine" id="cb27-3" data-line-number="3">    }</a></code></pre></div>
<p>This will let you prove invariants in your implementation using an index, while keeping the user-facing type signature general and non-indexed.</p>
<h3 id="a-fully-structurally-verified-binomial-heap">A Fully-Structurally-Verified Binomial Heap</h3>
<p><span class="citation" data-cites="wasserman_playing_2010">Wasserman (<a href="#ref-wasserman_playing_2010">2010</a>)</span>, was able to encode all of the structural invariants of the binomial heap <em>without</em> indexing by its size (well, all invariants except truncation, which turned out to be important a little later). I’ll be using a similar approach, except I’ll leverage some of the newer bells and whistles in GHC. Where Wasserman’s version used types like this for the numbering:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Zero</span> a <span class="fu">=</span> <span class="dt">Zero</span></a>
<a class="sourceLine" id="cb28-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Succ</span> rk a <span class="fu">=</span> <span class="dt">BinomTree</span> rk a <span class="fu">:&lt;</span> rk a</a>
<a class="sourceLine" id="cb28-3" data-line-number="3"><span class="kw">data</span> <span class="dt">BinomTree</span> rk a <span class="fu">=</span> <span class="dt">BinomTree</span> a (rk a)</a></code></pre></div>
<p>We can reuse the type-level Peano numbers with a GADT:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:-</span></a>
<a class="sourceLine" id="cb29-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Binomial</span> xs rk a <span class="kw">where</span></a>
<a class="sourceLine" id="cb29-3" data-line-number="3">       <span class="dt">Nil</span><span class="ot"> ::</span> <span class="dt">Binomial</span> <span class="ch">&#39;[] n a</span></a>
<a class="sourceLine" id="cb29-4" data-line-number="4">       <span class="dt">Skip</span><span class="ot"> ::</span> <span class="dt">Binomial</span> xs (<span class="dt">S</span> rk) a <span class="ot">-&gt;</span> <span class="dt">Binomial</span> (<span class="dt">False</span> <span class="fu">:</span> xs) rk a</a>
<a class="sourceLine" id="cb29-5" data-line-number="5"><span class="ot">       (:-) ::</span> <span class="dt">Tree</span> rk a </a>
<a class="sourceLine" id="cb29-6" data-line-number="6">            <span class="ot">-&gt;</span> <span class="dt">Binomial</span> xs (<span class="dt">S</span> rk) a </a>
<a class="sourceLine" id="cb29-7" data-line-number="7">            <span class="ot">-&gt;</span> <span class="dt">Binomial</span> (<span class="dt">True</span> <span class="fu">:</span> xs) rk a</a>
<a class="sourceLine" id="cb29-8" data-line-number="8"></a>
<a class="sourceLine" id="cb29-9" data-line-number="9"><span class="kw">data</span> <span class="dt">Tree</span> rk a <span class="fu">=</span> <span class="dt">Root</span> a (<span class="dt">Node</span> rk a)</a>
<a class="sourceLine" id="cb29-10" data-line-number="10"></a>
<a class="sourceLine" id="cb29-11" data-line-number="11"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:&lt;</span></a>
<a class="sourceLine" id="cb29-12" data-line-number="12"><span class="kw">data</span> <span class="dt">Node</span> n a <span class="kw">where</span></a>
<a class="sourceLine" id="cb29-13" data-line-number="13">       <span class="dt">NilN</span><span class="ot"> ::</span> <span class="dt">Node</span> <span class="dt">Z</span> a</a>
<a class="sourceLine" id="cb29-14" data-line-number="14"><span class="ot">       (:&lt;) ::</span> <span class="dt">Tree</span> n a <span class="ot">-&gt;</span> <span class="dt">Node</span> n a <span class="ot">-&gt;</span> <span class="dt">Node</span> (<span class="dt">S</span> n) a</a></code></pre></div>
<p>The definition of <code class="sourceCode haskell"><span class="dt">Tree</span></code> here ensures that any tree of rank <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> has <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mi>n</mi></msup><annotation encoding="application/x-tex">2^n</annotation></semantics></math> elements. The binomial heap, then, is a list of trees, in ascending order of size, with a <code class="sourceCode haskell"><span class="dt">True</span></code> at every point in its type-level list where a tree is present, and a <code class="sourceCode haskell"><span class="dt">False</span></code> wherever one is absent. In other words, the type-level list is a binary encoding of the number of elements it contains.</p>
<p>And here are the merge functions:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="ot">mergeTree ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Tree</span> rk a <span class="ot">-&gt;</span> <span class="dt">Tree</span> rk a <span class="ot">-&gt;</span> <span class="dt">Tree</span> (<span class="dt">S</span> rk) a</a>
<a class="sourceLine" id="cb30-2" data-line-number="2">mergeTree xr<span class="fu">@</span>(<span class="dt">Root</span> x xs) yr<span class="fu">@</span>(<span class="dt">Root</span> y ys)</a>
<a class="sourceLine" id="cb30-3" data-line-number="3">  <span class="fu">|</span> x <span class="fu">&lt;=</span> y    <span class="fu">=</span> <span class="dt">Root</span> x (yr <span class="fu">:&lt;</span> xs)</a>
<a class="sourceLine" id="cb30-4" data-line-number="4">  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Root</span> y (xr <span class="fu">:&lt;</span> ys)</a>
<a class="sourceLine" id="cb30-5" data-line-number="5"></a>
<a class="sourceLine" id="cb30-6" data-line-number="6">merge </a>
<a class="sourceLine" id="cb30-7" data-line-number="7"><span class="ot">    ::</span> <span class="dt">Ord</span> a </a>
<a class="sourceLine" id="cb30-8" data-line-number="8">    <span class="ot">=&gt;</span> <span class="dt">Binomial</span> xs z a </a>
<a class="sourceLine" id="cb30-9" data-line-number="9">    <span class="ot">-&gt;</span> <span class="dt">Binomial</span> ys z a </a>
<a class="sourceLine" id="cb30-10" data-line-number="10">    <span class="ot">-&gt;</span> <span class="dt">Binomial</span> (<span class="dt">Add</span> <span class="dt">False</span> xs ys) z a</a>
<a class="sourceLine" id="cb30-11" data-line-number="11">merge <span class="dt">Nil</span> ys              <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb30-12" data-line-number="12">merge xs <span class="dt">Nil</span>              <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb30-13" data-line-number="13">merge (<span class="dt">Skip</span> xs) (<span class="dt">Skip</span> ys) <span class="fu">=</span> <span class="dt">Skip</span> (merge xs ys)</a>
<a class="sourceLine" id="cb30-14" data-line-number="14">merge (<span class="dt">Skip</span> xs) (y <span class="fu">:-</span> ys) <span class="fu">=</span> y <span class="fu">:-</span> merge xs ys</a>
<a class="sourceLine" id="cb30-15" data-line-number="15">merge (x <span class="fu">:-</span> xs) (<span class="dt">Skip</span> ys) <span class="fu">=</span> x <span class="fu">:-</span> merge xs ys</a>
<a class="sourceLine" id="cb30-16" data-line-number="16">merge (x <span class="fu">:-</span> xs) (y <span class="fu">:-</span> ys) <span class="fu">=</span> <span class="dt">Skip</span> (mergeCarry (mergeTree x y) xs ys)</a>
<a class="sourceLine" id="cb30-17" data-line-number="17"></a>
<a class="sourceLine" id="cb30-18" data-line-number="18">mergeCarry</a>
<a class="sourceLine" id="cb30-19" data-line-number="19"><span class="ot">    ::</span> <span class="dt">Ord</span> a</a>
<a class="sourceLine" id="cb30-20" data-line-number="20">    <span class="ot">=&gt;</span> <span class="dt">Tree</span> rk a </a>
<a class="sourceLine" id="cb30-21" data-line-number="21">    <span class="ot">-&gt;</span> <span class="dt">Binomial</span> xs rk a </a>
<a class="sourceLine" id="cb30-22" data-line-number="22">    <span class="ot">-&gt;</span> <span class="dt">Binomial</span> ys rk a </a>
<a class="sourceLine" id="cb30-23" data-line-number="23">    <span class="ot">-&gt;</span> <span class="dt">Binomial</span> (<span class="dt">Add</span> <span class="dt">True</span> xs ys) rk a</a>
<a class="sourceLine" id="cb30-24" data-line-number="24">mergeCarry t <span class="dt">Nil</span> ys              <span class="fu">=</span> carryOne t ys</a>
<a class="sourceLine" id="cb30-25" data-line-number="25">mergeCarry t xs <span class="dt">Nil</span>              <span class="fu">=</span> carryOne t xs</a>
<a class="sourceLine" id="cb30-26" data-line-number="26">mergeCarry t (<span class="dt">Skip</span> xs) (<span class="dt">Skip</span> ys) <span class="fu">=</span> t <span class="fu">:-</span> merge xs ys</a>
<a class="sourceLine" id="cb30-27" data-line-number="27">mergeCarry t (<span class="dt">Skip</span> xs) (y <span class="fu">:-</span> ys) <span class="fu">=</span> <span class="dt">Skip</span> (mergeCarry (mergeTree t y) xs ys)</a>
<a class="sourceLine" id="cb30-28" data-line-number="28">mergeCarry t (x <span class="fu">:-</span> xs) (<span class="dt">Skip</span> ys) <span class="fu">=</span> <span class="dt">Skip</span> (mergeCarry (mergeTree t x) xs ys)</a>
<a class="sourceLine" id="cb30-29" data-line-number="29">mergeCarry t (x <span class="fu">:-</span> xs) (y <span class="fu">:-</span> ys) <span class="fu">=</span> t <span class="fu">:-</span> mergeCarry (mergeTree x y) xs ys</a>
<a class="sourceLine" id="cb30-30" data-line-number="30"></a>
<a class="sourceLine" id="cb30-31" data-line-number="31">carryOne </a>
<a class="sourceLine" id="cb30-32" data-line-number="32"><span class="ot">    ::</span> <span class="dt">Ord</span> a </a>
<a class="sourceLine" id="cb30-33" data-line-number="33">    <span class="ot">=&gt;</span> <span class="dt">Tree</span> rk a <span class="ot">-&gt;</span> <span class="dt">Binomial</span> xs rk a <span class="ot">-&gt;</span> <span class="dt">Binomial</span> (<span class="dt">CarryOne</span> xs) rk a</a>
<a class="sourceLine" id="cb30-34" data-line-number="34">carryOne t <span class="dt">Nil</span>       <span class="fu">=</span> t <span class="fu">:-</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb30-35" data-line-number="35">carryOne t (<span class="dt">Skip</span> xs) <span class="fu">=</span> t <span class="fu">:-</span> xs</a>
<a class="sourceLine" id="cb30-36" data-line-number="36">carryOne t (x <span class="fu">:-</span> xs) <span class="fu">=</span> <span class="dt">Skip</span> (carryOne (mergeTree t x) xs)</a></code></pre></div>
<p>You’ll notice that no proofs are needed: that’s because the merge function itself is the same as the type family, like the way <code class="sourceCode haskell"><span class="fu">++</span></code> for lists was the same as the <code class="sourceCode haskell"><span class="dt">Plus</span></code> type family.</p>
<p>Of course, this structure is only verified insofar as you believe the type families. It does provide a degree of double-entry, though: any mistake in the type family will have to be mirrored in the merge function to type-check. On top of that, we can write some proofs of properties we might expect:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" data-line-number="1">addCommutes</a>
<a class="sourceLine" id="cb31-2" data-line-number="2"><span class="ot">  ::</span> <span class="dt">The</span> [<span class="dt">Bool</span>] xs</a>
<a class="sourceLine" id="cb31-3" data-line-number="3">  <span class="ot">-&gt;</span> <span class="dt">The</span> [<span class="dt">Bool</span>] ys</a>
<a class="sourceLine" id="cb31-4" data-line-number="4">  <span class="ot">-&gt;</span> <span class="dt">Add</span> <span class="dt">False</span> xs ys <span class="fu">:~:</span> <span class="dt">Add</span> <span class="dt">False</span> ys xs</a>
<a class="sourceLine" id="cb31-5" data-line-number="5">addCommutes <span class="dt">Nily</span> _ <span class="fu">=</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb31-6" data-line-number="6">addCommutes _ <span class="dt">Nily</span> <span class="fu">=</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb31-7" data-line-number="7">addCommutes (<span class="dt">Cony</span> <span class="dt">Falsy</span> xs) (<span class="dt">Cony</span> <span class="dt">Falsy</span> ys) <span class="fu">=</span></a>
<a class="sourceLine" id="cb31-8" data-line-number="8">    gcastWith (addCommutes xs ys) <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb31-9" data-line-number="9">addCommutes (<span class="dt">Cony</span> <span class="dt">Truey</span> xs) (<span class="dt">Cony</span> <span class="dt">Falsy</span> ys) <span class="fu">=</span></a>
<a class="sourceLine" id="cb31-10" data-line-number="10">    gcastWith (addCommutes xs ys) <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb31-11" data-line-number="11">addCommutes (<span class="dt">Cony</span> <span class="dt">Falsy</span> xs) (<span class="dt">Cony</span> <span class="dt">Truey</span> ys) <span class="fu">=</span></a>
<a class="sourceLine" id="cb31-12" data-line-number="12">    gcastWith (addCommutes xs ys) <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb31-13" data-line-number="13">addCommutes (<span class="dt">Cony</span> <span class="dt">Truey</span> xs) (<span class="dt">Cony</span> <span class="dt">Truey</span> ys) <span class="fu">=</span></a>
<a class="sourceLine" id="cb31-14" data-line-number="14">    gcastWith (addCommutesCarry xs ys) <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb31-15" data-line-number="15"></a>
<a class="sourceLine" id="cb31-16" data-line-number="16">addCommutesCarry</a>
<a class="sourceLine" id="cb31-17" data-line-number="17"><span class="ot">  ::</span> <span class="dt">The</span> [<span class="dt">Bool</span>] xs</a>
<a class="sourceLine" id="cb31-18" data-line-number="18">  <span class="ot">-&gt;</span> <span class="dt">The</span> [<span class="dt">Bool</span>] ys</a>
<a class="sourceLine" id="cb31-19" data-line-number="19">  <span class="ot">-&gt;</span> <span class="dt">Add</span> <span class="dt">True</span> xs ys <span class="fu">:~:</span> <span class="dt">Add</span> <span class="dt">True</span> ys xs</a>
<a class="sourceLine" id="cb31-20" data-line-number="20">addCommutesCarry <span class="dt">Nily</span> _ <span class="fu">=</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb31-21" data-line-number="21">addCommutesCarry _ <span class="dt">Nily</span> <span class="fu">=</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb31-22" data-line-number="22">addCommutesCarry (<span class="dt">Cony</span> <span class="dt">Falsy</span> xs) (<span class="dt">Cony</span> <span class="dt">Falsy</span> ys) <span class="fu">=</span></a>
<a class="sourceLine" id="cb31-23" data-line-number="23">    gcastWith (addCommutes xs ys) <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb31-24" data-line-number="24">addCommutesCarry (<span class="dt">Cony</span> <span class="dt">Truey</span> xs) (<span class="dt">Cony</span> <span class="dt">Falsy</span> ys) <span class="fu">=</span></a>
<a class="sourceLine" id="cb31-25" data-line-number="25">    gcastWith (addCommutesCarry xs ys) <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb31-26" data-line-number="26">addCommutesCarry (<span class="dt">Cony</span> <span class="dt">Falsy</span> xs) (<span class="dt">Cony</span> <span class="dt">Truey</span> ys) <span class="fu">=</span></a>
<a class="sourceLine" id="cb31-27" data-line-number="27">    gcastWith (addCommutesCarry xs ys) <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb31-28" data-line-number="28">addCommutesCarry (<span class="dt">Cony</span> <span class="dt">Truey</span> xs) (<span class="dt">Cony</span> <span class="dt">Truey</span> ys) <span class="fu">=</span></a>
<a class="sourceLine" id="cb31-29" data-line-number="29">    gcastWith (addCommutesCarry xs ys) <span class="dt">Refl</span></a></code></pre></div>
<p>Unfortunately, though, this method <em>does</em> require proofs (ugly proofs) for the delete-min operation. One of the issues is truncation: since the binary digits are stored least-significant-bit first, the same number can be represented with any number of trailing zeroes. This kept causing problems for me when it came to subtraction, and adding the requirement of no trailing zeroes (truncation) to the constructors for the heap was a pain, requiring extra proofs on merge to show that it preserves truncation.</p>
<h3 id="doubly-dependent-types">Doubly-Dependent Types</h3>
<p>Since some of these properties are much easier to verify on the type-level Peano numbers, one approach might be to convert back and forth between Peano numbers and binary, and use the proofs on Peano numbers instead.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">BintoPeano</span> (<span class="ot">xs ::</span> [<span class="dt">Bool</span>])<span class="ot"> ::</span> <span class="dt">Peano</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-2" data-line-number="2">        <span class="dt">BintoPeano</span> <span class="ch">&#39;[] = Z</span></a>
<a class="sourceLine" id="cb32-3" data-line-number="3">        <span class="dt">BintoPeano</span> (<span class="dt">False</span> <span class="fu">:</span> xs) <span class="fu">=</span> <span class="dt">BintoPeano</span> xs <span class="fu">+</span> <span class="dt">BintoPeano</span> xs</a>
<a class="sourceLine" id="cb32-4" data-line-number="4">        <span class="dt">BintoPeano</span> (<span class="dt">True</span> <span class="fu">:</span> xs) <span class="fu">=</span> <span class="dt">S</span> (<span class="dt">BintoPeano</span> xs <span class="fu">+</span> <span class="dt">BintoPeano</span> xs)</a></code></pre></div>
<p>First problem: this requires <code class="sourceCode haskell"><span class="dt">UndecidableInstances</span></code>. I’d <em>really</em> rather not have that turned on, to be honest. In Idris (and Agda), you can <em>prove</em> decidability using <a href="https://www.idris-lang.org/docs/0.12/contrib_doc/docs/Control.WellFounded.html">a number of different methods</a>, but this isn’t available in Haskell yet.</p>
<p>Regardless, we can push on.</p>
<p>To go in the other direction, we’ll need to calculate the parity of natural numbers. Taken from <a href="http://docs.idris-lang.org/en/latest/tutorial/theorems.html#theorems-in-practice">the Idris tutorial</a>:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Parity</span> (<span class="ot">n ::</span> <span class="dt">Peano</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb33-2" data-line-number="2">    <span class="dt">Even</span><span class="ot"> ::</span> <span class="dt">The</span> <span class="dt">Peano</span> n <span class="ot">-&gt;</span> <span class="dt">Parity</span> (n <span class="fu">+</span> n)</a>
<a class="sourceLine" id="cb33-3" data-line-number="3">    <span class="dt">Odd</span><span class="ot">  ::</span> <span class="dt">The</span> <span class="dt">Peano</span> n <span class="ot">-&gt;</span> <span class="dt">Parity</span> (<span class="dt">S</span> (n <span class="fu">+</span> n))</a>
<a class="sourceLine" id="cb33-4" data-line-number="4"></a>
<a class="sourceLine" id="cb33-5" data-line-number="5"><span class="ot">parity ::</span> <span class="dt">The</span> <span class="dt">Peano</span> n <span class="ot">-&gt;</span> <span class="dt">Parity</span> n</a>
<a class="sourceLine" id="cb33-6" data-line-number="6">parity <span class="dt">Zy</span> <span class="fu">=</span> <span class="dt">Even</span> <span class="dt">Zy</span></a>
<a class="sourceLine" id="cb33-7" data-line-number="7">parity (<span class="dt">Sy</span> <span class="dt">Zy</span>) <span class="fu">=</span> <span class="dt">Odd</span> <span class="dt">Zy</span></a>
<a class="sourceLine" id="cb33-8" data-line-number="8">parity (<span class="dt">Sy</span> (<span class="dt">Sy</span> n)) <span class="fu">=</span> <span class="kw">case</span> parity n <span class="kw">of</span></a>
<a class="sourceLine" id="cb33-9" data-line-number="9">  <span class="dt">Even</span> m <span class="ot">-&gt;</span> gcastWith (plusSuccDistrib m m) (<span class="dt">Even</span> (<span class="dt">Sy</span> m))</a>
<a class="sourceLine" id="cb33-10" data-line-number="10">  <span class="dt">Odd</span>  m <span class="ot">-&gt;</span> gcastWith (plusSuccDistrib m m) (<span class="dt">Odd</span> (<span class="dt">Sy</span> m))</a>
<a class="sourceLine" id="cb33-11" data-line-number="11"></a>
<a class="sourceLine" id="cb33-12" data-line-number="12"><span class="ot">plusSuccDistrib ::</span> <span class="dt">The</span> <span class="dt">Peano</span> n <span class="ot">-&gt;</span> proxy m <span class="ot">-&gt;</span> n <span class="fu">+</span> <span class="dt">S</span> m <span class="fu">:~:</span> <span class="dt">S</span> (n <span class="fu">+</span> m)</a>
<a class="sourceLine" id="cb33-13" data-line-number="13">plusSuccDistrib <span class="dt">Zy</span> _ <span class="fu">=</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb33-14" data-line-number="14">plusSuccDistrib (<span class="dt">Sy</span> n) p <span class="fu">=</span> gcastWith (plusSuccDistrib n p) <span class="dt">Refl</span></a></code></pre></div>
<p>We need this function on the type-level, though, not the value-level: here, again, we run into trouble. What does <code class="sourceCode haskell">gcastWith</code> look like on the type-level? As far as I can tell, it doesn’t exist (yet. Although I haven’t looked deeply into the singletons library yet).</p>
<p>This idea of doing dependently-typed stuff on the type-level <em>started</em> to be possible with <code class="sourceCode haskell"><span class="dt">TypeInType</span></code>. For instance, we could have defined our binary type as:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Binary</span><span class="ot"> ::</span> <span class="dt">Peano</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb34-2" data-line-number="2">    <span class="dt">O</span><span class="ot"> ::</span> <span class="dt">Binary</span> n <span class="ot">-&gt;</span> <span class="dt">Binary</span> (n <span class="fu">+</span> n)</a>
<a class="sourceLine" id="cb34-3" data-line-number="3">    <span class="dt">I</span><span class="ot"> ::</span> <span class="dt">Binary</span> n <span class="ot">-&gt;</span> <span class="dt">Binary</span> (<span class="dt">S</span> (n <span class="fu">+</span> n))</a>
<a class="sourceLine" id="cb34-4" data-line-number="4">    <span class="dt">E</span><span class="ot"> ::</span> <span class="dt">Binary</span> <span class="dt">Z</span></a></code></pre></div>
<p>And then the binomial heap as:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb35-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Binomial</span> (<span class="ot">xs ::</span> <span class="dt">Binary</span> n) (<span class="ot">rk ::</span> <span class="dt">Peano</span>) (<span class="ot">a ::</span> <span class="dt">Type</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb35-2" data-line-number="2">       <span class="dt">Nil</span><span class="ot"> ::</span> <span class="dt">Binomial</span> <span class="dt">E</span> n a</a>
<a class="sourceLine" id="cb35-3" data-line-number="3">       <span class="dt">Skip</span><span class="ot"> ::</span> <span class="dt">Binomial</span> xs (<span class="dt">S</span> rk) a <span class="ot">-&gt;</span> <span class="dt">Binomial</span> (<span class="dt">O</span> xs) rk a</a>
<a class="sourceLine" id="cb35-4" data-line-number="4"><span class="ot">       (:-) ::</span> <span class="dt">Tree</span> rk a </a>
<a class="sourceLine" id="cb35-5" data-line-number="5">            <span class="ot">-&gt;</span> <span class="dt">Binomial</span> xs (<span class="dt">S</span> rk) a </a>
<a class="sourceLine" id="cb35-6" data-line-number="6">            <span class="ot">-&gt;</span> <span class="dt">Binomial</span> (<span class="dt">I</span> xs) rk a</a></code></pre></div>
<p>What we’re doing here is indexing a type <em>by an indexed type</em>. <a href="http://stackoverflow.com/a/13241158/4892417">This wasn’t possible in Haskell a few years ago</a>. It still doesn’t get us a nice definition of subtraction, though.</p>
<h3 id="using-a-typechecker-plugin">Using a Typechecker Plugin</h3>
<p>It’s pretty clear that this approach gets tedious almost immediately. What’s more, if we want the proofs to be erased, we introduce potential for errors.</p>
<p>The solution? Beef up GHC’s typechecker with a plugin. I first came across this approach in <a href="https://www.youtube.com/watch?v=u_OsUlwkmBQ">Kenneth Foner’s talk at Compose</a>. He used a plugin that called out to the <a href="https://github.com/Z3Prover/z3">Z3 theorem prover</a> <span class="citation" data-cites="diatchki_improving_2015">(from Diatchki <a href="#ref-diatchki_improving_2015">2015</a>)</span>; I’ll use a <a href="https://hackage.haskell.org/package/ghc-typelits-natnormalise">simpler plugin</a> which just normalizes type-literals.</p>
<p>From what I’ve used of these plugins so far, they seem to work really well. They’re very unobtrusive, only requiring a pragma at the top of your file:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" data-line-number="1"><span class="ot">{-# OPTIONS_GHC -fplugin GHC.TypeLits.Normalise #-}</span></a></code></pre></div>
<p>The plugin is only called when GHC can’t unify two types: this means you don’t get odd-looking error messages in unrelated code (in fact, the error messages I’ve seen so far have been excellent—a real improvement on the standard error messages for type-level arithmetic). Another benefit is that we get to use type-level literals (<code class="sourceCode haskell"><span class="dt">Nat</span></code> imported from <a href="https://hackage.haskell.org/package/base-4.9.1.0/docs/GHC-TypeLits.html">GHC.TypeLits</a>), rather then the noisy-looking type-level Peano numbers.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb37-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> n a <span class="fu">=</span> <span class="dt">Root</span> a (<span class="dt">Node</span> n a)</a>
<a class="sourceLine" id="cb37-2" data-line-number="2"></a>
<a class="sourceLine" id="cb37-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Node</span><span class="ot"> ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb37-4" data-line-number="4">        <span class="dt">NilN</span><span class="ot"> ::</span> <span class="dt">Node</span> <span class="dv">0</span> a</a>
<a class="sourceLine" id="cb37-5" data-line-number="5"><span class="ot">        (:&lt;) ::</span> <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span>(<span class="dt">Tree</span> n a)</a>
<a class="sourceLine" id="cb37-6" data-line-number="6">             <span class="ot">-&gt;</span> <span class="dt">Node</span> n a</a>
<a class="sourceLine" id="cb37-7" data-line-number="7">             <span class="ot">-&gt;</span> <span class="dt">Node</span> (<span class="dv">1</span> <span class="fu">+</span> n) a</a>
<a class="sourceLine" id="cb37-8" data-line-number="8"></a>
<a class="sourceLine" id="cb37-9" data-line-number="9"><span class="ot">mergeTree ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Tree</span> n a <span class="ot">-&gt;</span> <span class="dt">Tree</span> n a <span class="ot">-&gt;</span> <span class="dt">Tree</span> (<span class="dv">1</span> <span class="fu">+</span> n) a</a>
<a class="sourceLine" id="cb37-10" data-line-number="10">mergeTree xr<span class="fu">@</span>(<span class="dt">Root</span> x xs) yr<span class="fu">@</span>(<span class="dt">Root</span> y ys)</a>
<a class="sourceLine" id="cb37-11" data-line-number="11">  <span class="fu">|</span> x <span class="fu">&lt;=</span> y    <span class="fu">=</span> <span class="dt">Root</span> x (yr <span class="fu">:&lt;</span> xs)</a>
<a class="sourceLine" id="cb37-12" data-line-number="12">  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Root</span> y (xr <span class="fu">:&lt;</span> ys)</a>
<a class="sourceLine" id="cb37-13" data-line-number="13"></a>
<a class="sourceLine" id="cb37-14" data-line-number="14"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:-</span></a>
<a class="sourceLine" id="cb37-15" data-line-number="15"><span class="kw">data</span> <span class="dt">Binomial</span><span class="ot"> ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb37-16" data-line-number="16">        <span class="dt">Nil</span><span class="ot">  ::</span> <span class="dt">Binomial</span> n <span class="dv">0</span> a</a>
<a class="sourceLine" id="cb37-17" data-line-number="17"><span class="ot">        (:-) ::</span> <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span>(<span class="dt">Tree</span> z a)</a>
<a class="sourceLine" id="cb37-18" data-line-number="18">             <span class="ot">-&gt;</span> <span class="dt">Binomial</span> (<span class="dv">1</span> <span class="fu">+</span> z) xs a</a>
<a class="sourceLine" id="cb37-19" data-line-number="19">             <span class="ot">-&gt;</span> <span class="dt">Binomial</span> z (<span class="dv">1</span> <span class="fu">+</span> xs <span class="fu">+</span> xs) a</a>
<a class="sourceLine" id="cb37-20" data-line-number="20">        <span class="dt">Skip</span><span class="ot"> ::</span> <span class="dt">Binomial</span> (<span class="dv">1</span> <span class="fu">+</span> z) (<span class="dv">1</span> <span class="fu">+</span> xs) a</a>
<a class="sourceLine" id="cb37-21" data-line-number="21">             <span class="ot">-&gt;</span> <span class="dt">Binomial</span> z (<span class="dv">2</span> <span class="fu">+</span> xs <span class="fu">+</span> xs) a</a></code></pre></div>
<p>This definition also ensures that the binomial heap has no trailing zeroes in its binary representation: the <code class="sourceCode haskell"><span class="dt">Skip</span></code> constructor can only be applied to a heap bigger than zero.</p>
<p>Since we’re going to be looking at several different heaps, we’ll need a class to represent all of them:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb38-1" data-line-number="1"><span class="kw">class</span> <span class="dt">IndexedQueue</span> h a <span class="kw">where</span></a>
<a class="sourceLine" id="cb38-2" data-line-number="2"></a>
<a class="sourceLine" id="cb38-3" data-line-number="3">    <span class="ot">{-# MINIMAL insert, empty, minViewMay, minView #-}</span></a>
<a class="sourceLine" id="cb38-4" data-line-number="4"></a>
<a class="sourceLine" id="cb38-5" data-line-number="5">    empty</a>
<a class="sourceLine" id="cb38-6" data-line-number="6"><span class="ot">        ::</span> h <span class="dv">0</span> a</a>
<a class="sourceLine" id="cb38-7" data-line-number="7"></a>
<a class="sourceLine" id="cb38-8" data-line-number="8">    minView</a>
<a class="sourceLine" id="cb38-9" data-line-number="9"><span class="ot">        ::</span> h (<span class="dv">1</span> <span class="fu">+</span> n) a <span class="ot">-&gt;</span> (a, h n a)</a>
<a class="sourceLine" id="cb38-10" data-line-number="10"></a>
<a class="sourceLine" id="cb38-11" data-line-number="11">    singleton</a>
<a class="sourceLine" id="cb38-12" data-line-number="12"><span class="ot">        ::</span> a <span class="ot">-&gt;</span> h <span class="dv">1</span> a</a>
<a class="sourceLine" id="cb38-13" data-line-number="13">    singleton <span class="fu">=</span> flip insert empty</a>
<a class="sourceLine" id="cb38-14" data-line-number="14"></a>
<a class="sourceLine" id="cb38-15" data-line-number="15">    insert</a>
<a class="sourceLine" id="cb38-16" data-line-number="16"><span class="ot">        ::</span> a <span class="ot">-&gt;</span> h n a <span class="ot">-&gt;</span> h (<span class="dv">1</span> <span class="fu">+</span> n) a</a>
<a class="sourceLine" id="cb38-17" data-line-number="17"></a>
<a class="sourceLine" id="cb38-18" data-line-number="18">    minViewMay</a>
<a class="sourceLine" id="cb38-19" data-line-number="19"><span class="ot">       ::</span> h n a</a>
<a class="sourceLine" id="cb38-20" data-line-number="20">       <span class="ot">-&gt;</span> (n <span class="fu">~</span> <span class="dv">0</span> <span class="ot">=&gt;</span> b)</a>
<a class="sourceLine" id="cb38-21" data-line-number="21">       <span class="ot">-&gt;</span> (forall m<span class="fu">.</span> (<span class="dv">1</span> <span class="fu">+</span> m) <span class="fu">~</span> n <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> h m a <span class="ot">-&gt;</span> b)</a>
<a class="sourceLine" id="cb38-22" data-line-number="22">       <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb38-23" data-line-number="23"></a>
<a class="sourceLine" id="cb38-24" data-line-number="24"><span class="kw">class</span> <span class="dt">IndexedQueue</span> h a <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb38-25" data-line-number="25">      <span class="dt">MeldableIndexedQueue</span> h a <span class="kw">where</span></a>
<a class="sourceLine" id="cb38-26" data-line-number="26">    merge</a>
<a class="sourceLine" id="cb38-27" data-line-number="27"><span class="ot">        ::</span> h n a <span class="ot">-&gt;</span> h m a <span class="ot">-&gt;</span> h (n <span class="fu">+</span> m) a</a></code></pre></div>
<p>You’ll need <code class="sourceCode haskell"><span class="dt">MultiParamTypeClasses</span></code> for this one.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb39-1" data-line-number="1">mergeB</a>
<a class="sourceLine" id="cb39-2" data-line-number="2"><span class="ot">    ::</span> <span class="dt">Ord</span> a</a>
<a class="sourceLine" id="cb39-3" data-line-number="3">    <span class="ot">=&gt;</span> <span class="dt">Binomial</span> z xs a <span class="ot">-&gt;</span> <span class="dt">Binomial</span> z ys a <span class="ot">-&gt;</span> <span class="dt">Binomial</span> z (xs <span class="fu">+</span> ys) a</a>
<a class="sourceLine" id="cb39-4" data-line-number="4">mergeB <span class="dt">Nil</span> ys              <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb39-5" data-line-number="5">mergeB xs <span class="dt">Nil</span>              <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb39-6" data-line-number="6">mergeB (<span class="dt">Skip</span> xs) (<span class="dt">Skip</span> ys) <span class="fu">=</span> <span class="dt">Skip</span> (mergeB xs ys)</a>
<a class="sourceLine" id="cb39-7" data-line-number="7">mergeB (<span class="dt">Skip</span> xs) (y <span class="fu">:-</span> ys) <span class="fu">=</span> y <span class="fu">:-</span> mergeB xs ys</a>
<a class="sourceLine" id="cb39-8" data-line-number="8">mergeB (x <span class="fu">:-</span> xs) (<span class="dt">Skip</span> ys) <span class="fu">=</span> x <span class="fu">:-</span> mergeB xs ys</a>
<a class="sourceLine" id="cb39-9" data-line-number="9">mergeB (x <span class="fu">:-</span> xs) (y <span class="fu">:-</span> ys) <span class="fu">=</span> <span class="dt">Skip</span> (mergeCarry (mergeTree x y) xs ys)</a>
<a class="sourceLine" id="cb39-10" data-line-number="10"></a>
<a class="sourceLine" id="cb39-11" data-line-number="11">mergeCarry</a>
<a class="sourceLine" id="cb39-12" data-line-number="12"><span class="ot">    ::</span> <span class="dt">Ord</span> a</a>
<a class="sourceLine" id="cb39-13" data-line-number="13">    <span class="ot">=&gt;</span> <span class="dt">Tree</span> z a</a>
<a class="sourceLine" id="cb39-14" data-line-number="14">    <span class="ot">-&gt;</span> <span class="dt">Binomial</span> z xs a</a>
<a class="sourceLine" id="cb39-15" data-line-number="15">    <span class="ot">-&gt;</span> <span class="dt">Binomial</span> z ys a</a>
<a class="sourceLine" id="cb39-16" data-line-number="16">    <span class="ot">-&gt;</span> <span class="dt">Binomial</span> z (<span class="dv">1</span> <span class="fu">+</span> xs <span class="fu">+</span> ys) a</a>
<a class="sourceLine" id="cb39-17" data-line-number="17">mergeCarry <span class="fu">!</span>t <span class="dt">Nil</span> ys              <span class="fu">=</span> carryOne t ys</a>
<a class="sourceLine" id="cb39-18" data-line-number="18">mergeCarry <span class="fu">!</span>t xs <span class="dt">Nil</span>              <span class="fu">=</span> carryOne t xs</a>
<a class="sourceLine" id="cb39-19" data-line-number="19">mergeCarry <span class="fu">!</span>t (<span class="dt">Skip</span> xs) (<span class="dt">Skip</span> ys) <span class="fu">=</span> t <span class="fu">:-</span> mergeB xs ys</a>
<a class="sourceLine" id="cb39-20" data-line-number="20">mergeCarry <span class="fu">!</span>t (<span class="dt">Skip</span> xs) (y <span class="fu">:-</span> ys) <span class="fu">=</span> <span class="dt">Skip</span> (mergeCarry (mergeTree t y) xs ys)</a>
<a class="sourceLine" id="cb39-21" data-line-number="21">mergeCarry <span class="fu">!</span>t (x <span class="fu">:-</span> xs) (<span class="dt">Skip</span> ys) <span class="fu">=</span> <span class="dt">Skip</span> (mergeCarry (mergeTree t x) xs ys)</a>
<a class="sourceLine" id="cb39-22" data-line-number="22">mergeCarry <span class="fu">!</span>t (x <span class="fu">:-</span> xs) (y <span class="fu">:-</span> ys) <span class="fu">=</span> t <span class="fu">:-</span> mergeCarry (mergeTree x y) xs ys</a>
<a class="sourceLine" id="cb39-23" data-line-number="23"></a>
<a class="sourceLine" id="cb39-24" data-line-number="24"><span class="ot">carryOne ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Tree</span> z a <span class="ot">-&gt;</span> <span class="dt">Binomial</span> z xs a <span class="ot">-&gt;</span> <span class="dt">Binomial</span> z (<span class="dv">1</span> <span class="fu">+</span> xs) a</a>
<a class="sourceLine" id="cb39-25" data-line-number="25">carryOne <span class="fu">!</span>t <span class="dt">Nil</span>       <span class="fu">=</span> t <span class="fu">:-</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb39-26" data-line-number="26">carryOne <span class="fu">!</span>t (<span class="dt">Skip</span> xs) <span class="fu">=</span> t <span class="fu">:-</span> xs</a>
<a class="sourceLine" id="cb39-27" data-line-number="27">carryOne <span class="fu">!</span>t (x <span class="fu">:-</span> xs) <span class="fu">=</span> <span class="dt">Skip</span> (carryOne (mergeTree t x) xs)</a>
<a class="sourceLine" id="cb39-28" data-line-number="28"></a>
<a class="sourceLine" id="cb39-29" data-line-number="29"><span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">MeldableIndexedQueue</span> (<span class="dt">Binomial</span> <span class="dv">0</span>) a <span class="kw">where</span></a>
<a class="sourceLine" id="cb39-30" data-line-number="30">    merge <span class="fu">=</span> mergeB</a>
<a class="sourceLine" id="cb39-31" data-line-number="31">    <span class="ot">{-# INLINE merge #-}</span></a>
<a class="sourceLine" id="cb39-32" data-line-number="32"></a>
<a class="sourceLine" id="cb39-33" data-line-number="33"><span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">IndexedQueue</span> (<span class="dt">Binomial</span> <span class="dv">0</span>) a <span class="kw">where</span></a>
<a class="sourceLine" id="cb39-34" data-line-number="34">    empty <span class="fu">=</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb39-35" data-line-number="35">    singleton x <span class="fu">=</span> <span class="dt">Root</span> x <span class="dt">NilN</span> <span class="fu">:-</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb39-36" data-line-number="36">    insert <span class="fu">=</span> merge <span class="fu">.</span> singleton</a></code></pre></div>
<p>(<code class="sourceCode haskell"><span class="dt">BangPatterns</span></code> for this example)</p>
<p>On top of that, it’s very easy to define delete-min:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb40-1" data-line-number="1">    minView xs <span class="fu">=</span> <span class="kw">case</span> minViewZip xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb40-2" data-line-number="2">      <span class="dt">Zipper</span> x _ ys <span class="ot">-&gt;</span> (x, ys)</a>
<a class="sourceLine" id="cb40-3" data-line-number="3">    minViewMay q b f <span class="fu">=</span> <span class="kw">case</span> q <span class="kw">of</span></a>
<a class="sourceLine" id="cb40-4" data-line-number="4">      <span class="dt">Nil</span> <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb40-5" data-line-number="5">      _ <span class="fu">:-</span> _ <span class="ot">-&gt;</span> uncurry f (minView q)</a>
<a class="sourceLine" id="cb40-6" data-line-number="6">      <span class="dt">Skip</span> _ <span class="ot">-&gt;</span> uncurry f (minView q)</a>
<a class="sourceLine" id="cb40-7" data-line-number="7"></a>
<a class="sourceLine" id="cb40-8" data-line-number="8"><span class="kw">data</span> <span class="dt">Zipper</span> a n rk <span class="fu">=</span> <span class="dt">Zipper</span> <span class="fu">!</span>a (<span class="dt">Node</span> rk a) (<span class="dt">Binomial</span> rk n a)</a>
<a class="sourceLine" id="cb40-9" data-line-number="9"></a>
<a class="sourceLine" id="cb40-10" data-line-number="10"><span class="ot">skip ::</span> <span class="dt">Binomial</span> (<span class="dv">1</span> <span class="fu">+</span> z) xs a <span class="ot">-&gt;</span> <span class="dt">Binomial</span> z (xs <span class="fu">+</span> xs) a</a>
<a class="sourceLine" id="cb40-11" data-line-number="11">skip x <span class="fu">=</span> <span class="kw">case</span> x <span class="kw">of</span></a>
<a class="sourceLine" id="cb40-12" data-line-number="12">  <span class="dt">Nil</span>    <span class="ot">-&gt;</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb40-13" data-line-number="13">  <span class="dt">Skip</span> _ <span class="ot">-&gt;</span> <span class="dt">Skip</span> x</a>
<a class="sourceLine" id="cb40-14" data-line-number="14">  _ <span class="fu">:-</span> _ <span class="ot">-&gt;</span> <span class="dt">Skip</span> x</a>
<a class="sourceLine" id="cb40-15" data-line-number="15"></a>
<a class="sourceLine" id="cb40-16" data-line-number="16"><span class="kw">data</span> <span class="dt">MinViewZipper</span> a n rk <span class="kw">where</span></a>
<a class="sourceLine" id="cb40-17" data-line-number="17">    <span class="dt">Infty</span><span class="ot"> ::</span> <span class="dt">MinViewZipper</span> a <span class="dv">0</span> rk</a>
<a class="sourceLine" id="cb40-18" data-line-number="18">    <span class="dt">Min</span><span class="ot"> ::</span> <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span>(<span class="dt">Zipper</span> a n rk) <span class="ot">-&gt;</span> <span class="dt">MinViewZipper</span> a (n<span class="fu">+</span><span class="dv">1</span>) rk</a>
<a class="sourceLine" id="cb40-19" data-line-number="19"></a>
<a class="sourceLine" id="cb40-20" data-line-number="20"><span class="ot">slideLeft ::</span> <span class="dt">Zipper</span> a n (<span class="dv">1</span> <span class="fu">+</span> rk) <span class="ot">-&gt;</span> <span class="dt">Zipper</span> a (<span class="dv">1</span> <span class="fu">+</span> n <span class="fu">+</span> n) rk</a>
<a class="sourceLine" id="cb40-21" data-line-number="21">slideLeft (<span class="dt">Zipper</span> m (t <span class="fu">:&lt;</span> ts) hs)</a>
<a class="sourceLine" id="cb40-22" data-line-number="22">  <span class="fu">=</span> <span class="dt">Zipper</span> m ts (t <span class="fu">:-</span> hs)</a>
<a class="sourceLine" id="cb40-23" data-line-number="23"></a>
<a class="sourceLine" id="cb40-24" data-line-number="24">pushLeft </a>
<a class="sourceLine" id="cb40-25" data-line-number="25"><span class="ot">  ::</span> <span class="dt">Ord</span> a </a>
<a class="sourceLine" id="cb40-26" data-line-number="26">  <span class="ot">=&gt;</span> <span class="dt">Tree</span> rk a </a>
<a class="sourceLine" id="cb40-27" data-line-number="27">  <span class="ot">-&gt;</span> <span class="dt">Zipper</span> a n (<span class="dv">1</span> <span class="fu">+</span> rk) </a>
<a class="sourceLine" id="cb40-28" data-line-number="28">  <span class="ot">-&gt;</span> <span class="dt">Zipper</span> a (<span class="dv">2</span> <span class="fu">+</span> n <span class="fu">+</span> n) rk</a>
<a class="sourceLine" id="cb40-29" data-line-number="29">pushLeft c (<span class="dt">Zipper</span> m (t <span class="fu">:&lt;</span> ts) hs)</a>
<a class="sourceLine" id="cb40-30" data-line-number="30">  <span class="fu">=</span> <span class="dt">Zipper</span> m ts (<span class="dt">Skip</span> (carryOne (mergeTree c t) hs))</a>
<a class="sourceLine" id="cb40-31" data-line-number="31"></a>
<a class="sourceLine" id="cb40-32" data-line-number="32"><span class="ot">minViewZip ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Binomial</span> rk (<span class="dv">1</span> <span class="fu">+</span> n) a <span class="ot">-&gt;</span> <span class="dt">Zipper</span> a n rk</a>
<a class="sourceLine" id="cb40-33" data-line-number="33">minViewZip (<span class="dt">Skip</span> xs) <span class="fu">=</span> slideLeft (minViewZip xs)</a>
<a class="sourceLine" id="cb40-34" data-line-number="34">minViewZip (t<span class="fu">@</span>(<span class="dt">Root</span> x ts) <span class="fu">:-</span> f) <span class="fu">=</span> <span class="kw">case</span> minViewZipMay f <span class="kw">of</span></a>
<a class="sourceLine" id="cb40-35" data-line-number="35">  <span class="dt">Min</span> ex<span class="fu">@</span>(<span class="dt">Zipper</span> minKey _ _) <span class="fu">|</span> minKey <span class="fu">&lt;</span> x <span class="ot">-&gt;</span> pushLeft t ex</a>
<a class="sourceLine" id="cb40-36" data-line-number="36">  _                          <span class="ot">-&gt;</span> <span class="dt">Zipper</span> x ts (skip f)</a>
<a class="sourceLine" id="cb40-37" data-line-number="37"></a>
<a class="sourceLine" id="cb40-38" data-line-number="38"><span class="ot">minViewZipMay ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Binomial</span> rk n a <span class="ot">-&gt;</span> <span class="dt">MinViewZipper</span> a n rk</a>
<a class="sourceLine" id="cb40-39" data-line-number="39">minViewZipMay (<span class="dt">Skip</span> xs) <span class="fu">=</span> <span class="dt">Min</span> (slideLeft (minViewZip xs))</a>
<a class="sourceLine" id="cb40-40" data-line-number="40">minViewZipMay <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Infty</span></a>
<a class="sourceLine" id="cb40-41" data-line-number="41">minViewZipMay (t<span class="fu">@</span>(<span class="dt">Root</span> x ts) <span class="fu">:-</span> f) <span class="fu">=</span> <span class="dt">Min</span> <span class="fu">$</span> <span class="kw">case</span> minViewZipMay f <span class="kw">of</span></a>
<a class="sourceLine" id="cb40-42" data-line-number="42">  <span class="dt">Min</span> ex<span class="fu">@</span>(<span class="dt">Zipper</span> minKey _ _) <span class="fu">|</span> minKey <span class="fu">&lt;</span> x <span class="ot">-&gt;</span> pushLeft t ex</a>
<a class="sourceLine" id="cb40-43" data-line-number="43">  _                          <span class="ot">-&gt;</span> <span class="dt">Zipper</span> x ts (skip f)</a></code></pre></div>
<p>Similarly, compare the version of the pairing heap with the plugin:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb41-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Heap</span> n a <span class="kw">where</span></a>
<a class="sourceLine" id="cb41-2" data-line-number="2">  <span class="dt">E</span><span class="ot"> ::</span> <span class="dt">Heap</span> <span class="dv">0</span> a</a>
<a class="sourceLine" id="cb41-3" data-line-number="3">  <span class="dt">T</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">HVec</span> n a <span class="ot">-&gt;</span> <span class="dt">Heap</span> (<span class="dv">1</span> <span class="fu">+</span> n) a</a>
<a class="sourceLine" id="cb41-4" data-line-number="4"></a>
<a class="sourceLine" id="cb41-5" data-line-number="5"><span class="kw">data</span> <span class="dt">HVec</span> n a <span class="kw">where</span></a>
<a class="sourceLine" id="cb41-6" data-line-number="6">  <span class="dt">HNil</span><span class="ot"> ::</span> <span class="dt">HVec</span> <span class="dv">0</span> a</a>
<a class="sourceLine" id="cb41-7" data-line-number="7">  <span class="dt">HCons</span><span class="ot"> ::</span> <span class="dt">Heap</span> m a <span class="ot">-&gt;</span> <span class="dt">HVec</span> n a <span class="ot">-&gt;</span> <span class="dt">HVec</span> (m <span class="fu">+</span> n) a</a>
<a class="sourceLine" id="cb41-8" data-line-number="8"></a>
<a class="sourceLine" id="cb41-9" data-line-number="9"><span class="ot">insert ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Heap</span> n a <span class="ot">-&gt;</span> <span class="dt">Heap</span> (<span class="dv">1</span> <span class="fu">+</span> n) a</a>
<a class="sourceLine" id="cb41-10" data-line-number="10">insert x xs <span class="fu">=</span> merge (<span class="dt">T</span> x <span class="dt">HNil</span>) xs</a>
<a class="sourceLine" id="cb41-11" data-line-number="11"></a>
<a class="sourceLine" id="cb41-12" data-line-number="12"><span class="ot">merge ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Heap</span> m a <span class="ot">-&gt;</span> <span class="dt">Heap</span> n a <span class="ot">-&gt;</span> <span class="dt">Heap</span> (m <span class="fu">+</span> n) a</a>
<a class="sourceLine" id="cb41-13" data-line-number="13">merge <span class="dt">E</span> ys <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb41-14" data-line-number="14">merge xs <span class="dt">E</span> <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb41-15" data-line-number="15">merge h1<span class="fu">@</span>(<span class="dt">T</span> x xs) h2<span class="fu">@</span>(<span class="dt">T</span> y ys)</a>
<a class="sourceLine" id="cb41-16" data-line-number="16">  <span class="fu">|</span> x <span class="fu">&lt;=</span> y <span class="fu">=</span> <span class="dt">T</span> x (<span class="dt">HCons</span> h2 xs)</a>
<a class="sourceLine" id="cb41-17" data-line-number="17">  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">T</span> y (<span class="dt">HCons</span> h1 ys)</a>
<a class="sourceLine" id="cb41-18" data-line-number="18"></a>
<a class="sourceLine" id="cb41-19" data-line-number="19"><span class="ot">minView ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Heap</span> (<span class="dv">1</span> <span class="fu">+</span> n) a <span class="ot">-&gt;</span> (a, <span class="dt">Heap</span> n a)</a>
<a class="sourceLine" id="cb41-20" data-line-number="20">minView (<span class="dt">T</span> x hs) <span class="fu">=</span> (x, mergePairs hs)</a>
<a class="sourceLine" id="cb41-21" data-line-number="21"></a>
<a class="sourceLine" id="cb41-22" data-line-number="22"><span class="ot">mergePairs ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">HVec</span> n a <span class="ot">-&gt;</span> <span class="dt">Heap</span> n a</a>
<a class="sourceLine" id="cb41-23" data-line-number="23">mergePairs <span class="dt">HNil</span> <span class="fu">=</span> <span class="dt">E</span></a>
<a class="sourceLine" id="cb41-24" data-line-number="24">mergePairs (<span class="dt">HCons</span> h <span class="dt">HNil</span>) <span class="fu">=</span> h</a>
<a class="sourceLine" id="cb41-25" data-line-number="25">mergePairs (<span class="dt">HCons</span> h1 (<span class="dt">HCons</span> h2 hs)) <span class="fu">=</span></a>
<a class="sourceLine" id="cb41-26" data-line-number="26">    merge (merge h1 h2) (mergePairs hs)</a></code></pre></div>
<p>To the version without the plugin:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb42-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Heap</span> n a <span class="kw">where</span></a>
<a class="sourceLine" id="cb42-2" data-line-number="2">  <span class="dt">E</span><span class="ot"> ::</span> <span class="dt">Heap</span> <span class="dt">Z</span> a</a>
<a class="sourceLine" id="cb42-3" data-line-number="3">  <span class="dt">T</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">HVec</span> n a <span class="ot">-&gt;</span> <span class="dt">Heap</span> (<span class="dt">S</span> n) a</a>
<a class="sourceLine" id="cb42-4" data-line-number="4"></a>
<a class="sourceLine" id="cb42-5" data-line-number="5"><span class="kw">data</span> <span class="dt">HVec</span> n a <span class="kw">where</span></a>
<a class="sourceLine" id="cb42-6" data-line-number="6">  <span class="dt">HNil</span><span class="ot"> ::</span> <span class="dt">HVec</span> <span class="dt">Z</span> a</a>
<a class="sourceLine" id="cb42-7" data-line-number="7">  <span class="dt">HCons</span><span class="ot"> ::</span> <span class="dt">Heap</span> m a <span class="ot">-&gt;</span> <span class="dt">HVec</span> n a <span class="ot">-&gt;</span> <span class="dt">HVec</span> (m <span class="fu">+</span> n) a</a>
<a class="sourceLine" id="cb42-8" data-line-number="8"></a>
<a class="sourceLine" id="cb42-9" data-line-number="9"><span class="kw">class</span> <span class="dt">Sized</span> h <span class="kw">where</span></a>
<a class="sourceLine" id="cb42-10" data-line-number="10"><span class="ot">  size ::</span> h n a <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Peano</span> n</a>
<a class="sourceLine" id="cb42-11" data-line-number="11"></a>
<a class="sourceLine" id="cb42-12" data-line-number="12"><span class="kw">instance</span> <span class="dt">Sized</span> <span class="dt">Heap</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb42-13" data-line-number="13">  size <span class="dt">E</span> <span class="fu">=</span> <span class="dt">Zy</span></a>
<a class="sourceLine" id="cb42-14" data-line-number="14">  size (<span class="dt">T</span> _ xs) <span class="fu">=</span> <span class="dt">Sy</span> (size xs)</a>
<a class="sourceLine" id="cb42-15" data-line-number="15"></a>
<a class="sourceLine" id="cb42-16" data-line-number="16"><span class="ot">plus ::</span> <span class="dt">The</span> <span class="dt">Peano</span> n <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Peano</span> m <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Peano</span> (n <span class="fu">+</span> m)</a>
<a class="sourceLine" id="cb42-17" data-line-number="17">plus <span class="dt">Zy</span> m <span class="fu">=</span> m</a>
<a class="sourceLine" id="cb42-18" data-line-number="18">plus (<span class="dt">Sy</span> n) m <span class="fu">=</span> <span class="dt">Sy</span> (plus n m)</a>
<a class="sourceLine" id="cb42-19" data-line-number="19"></a>
<a class="sourceLine" id="cb42-20" data-line-number="20"><span class="kw">instance</span> <span class="dt">Sized</span> <span class="dt">HVec</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb42-21" data-line-number="21">  size <span class="dt">HNil</span> <span class="fu">=</span> <span class="dt">Zy</span></a>
<a class="sourceLine" id="cb42-22" data-line-number="22">  size (<span class="dt">HCons</span> h hs) <span class="fu">=</span> size h <span class="ot">`plus`</span> size hs</a>
<a class="sourceLine" id="cb42-23" data-line-number="23"></a>
<a class="sourceLine" id="cb42-24" data-line-number="24"><span class="ot">insert ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Heap</span> n a <span class="ot">-&gt;</span> <span class="dt">Heap</span> (<span class="dt">S</span> n) a</a>
<a class="sourceLine" id="cb42-25" data-line-number="25">insert x xs <span class="fu">=</span> merge (<span class="dt">T</span> x <span class="dt">HNil</span>) xs</a>
<a class="sourceLine" id="cb42-26" data-line-number="26"></a>
<a class="sourceLine" id="cb42-27" data-line-number="27"><span class="ot">merge ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Heap</span> m a <span class="ot">-&gt;</span> <span class="dt">Heap</span> n a <span class="ot">-&gt;</span> <span class="dt">Heap</span> (m <span class="fu">+</span> n) a</a>
<a class="sourceLine" id="cb42-28" data-line-number="28">merge <span class="dt">E</span> ys <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb42-29" data-line-number="29">merge xs <span class="dt">E</span> <span class="fu">=</span> <span class="kw">case</span> plusZero (size xs) <span class="kw">of</span> <span class="dt">Refl</span> <span class="ot">-&gt;</span> xs</a>
<a class="sourceLine" id="cb42-30" data-line-number="30">merge h1<span class="fu">@</span>(<span class="dt">T</span> x xs) h2<span class="fu">@</span>(<span class="dt">T</span> y ys)</a>
<a class="sourceLine" id="cb42-31" data-line-number="31">  <span class="fu">|</span> x <span class="fu">&lt;=</span> y <span class="fu">=</span> <span class="kw">case</span> plusCommutative (size h2) (size xs) <span class="kw">of</span></a>
<a class="sourceLine" id="cb42-32" data-line-number="32">                    <span class="dt">Refl</span> <span class="ot">-&gt;</span> <span class="dt">T</span> x (<span class="dt">HCons</span> h2 xs)</a>
<a class="sourceLine" id="cb42-33" data-line-number="33">  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="kw">case</span> plusSuccDistrib (size xs) (size ys) <span class="kw">of</span></a>
<a class="sourceLine" id="cb42-34" data-line-number="34">                    <span class="dt">Refl</span> <span class="ot">-&gt;</span> <span class="dt">T</span> y (<span class="dt">HCons</span> h1 ys)</a>
<a class="sourceLine" id="cb42-35" data-line-number="35"></a>
<a class="sourceLine" id="cb42-36" data-line-number="36"><span class="ot">minView ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Heap</span> (<span class="dt">S</span> n) a <span class="ot">-&gt;</span> (a, <span class="dt">Heap</span> n a)</a>
<a class="sourceLine" id="cb42-37" data-line-number="37">minView (<span class="dt">T</span> x hs) <span class="fu">=</span> (x, mergePairs hs)</a>
<a class="sourceLine" id="cb42-38" data-line-number="38"></a>
<a class="sourceLine" id="cb42-39" data-line-number="39"><span class="ot">mergePairs ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">HVec</span> n a <span class="ot">-&gt;</span> <span class="dt">Heap</span> n a</a>
<a class="sourceLine" id="cb42-40" data-line-number="40">mergePairs <span class="dt">HNil</span> <span class="fu">=</span> <span class="dt">E</span></a>
<a class="sourceLine" id="cb42-41" data-line-number="41">mergePairs (<span class="dt">HCons</span> h <span class="dt">HNil</span>) <span class="fu">=</span> <span class="kw">case</span> plusZero (size h) <span class="kw">of</span> <span class="dt">Refl</span> <span class="ot">-&gt;</span> h</a>
<a class="sourceLine" id="cb42-42" data-line-number="42">mergePairs (<span class="dt">HCons</span> h1 (<span class="dt">HCons</span> h2 hs)) <span class="fu">=</span></a>
<a class="sourceLine" id="cb42-43" data-line-number="43">  <span class="kw">case</span> plusAssoc (size h1) (size h2) (size hs) <span class="kw">of</span></a>
<a class="sourceLine" id="cb42-44" data-line-number="44">    <span class="dt">Refl</span> <span class="ot">-&gt;</span> merge (merge h1 h2) (mergePairs hs)</a></code></pre></div>
<h3 id="leftist-heaps">Leftist Heaps</h3>
<p>The typechecker plugin makes it relatively easy to implement several other heaps: skew, Braun, etc. You’ll need one extra trick to implement a <a href="http://lambda.jstolarek.com/2014/10/weight-biased-leftist-heaps-verified-in-haskell-using-dependent-types/">leftist heap</a>, though. Let’s take a look at the unverified version:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb43-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Leftist</span> a</a>
<a class="sourceLine" id="cb43-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Leaf</span></a>
<a class="sourceLine" id="cb43-3" data-line-number="3">    <span class="fu">|</span> <span class="dt">Node</span> <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">Int</span></a>
<a class="sourceLine" id="cb43-4" data-line-number="4">           a</a>
<a class="sourceLine" id="cb43-5" data-line-number="5">           (<span class="dt">Leftist</span> a)</a>
<a class="sourceLine" id="cb43-6" data-line-number="6">           (<span class="dt">Leftist</span> a)</a>
<a class="sourceLine" id="cb43-7" data-line-number="7"></a>
<a class="sourceLine" id="cb43-8" data-line-number="8"><span class="ot">rank ::</span> <span class="dt">Leftist</span> s <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb43-9" data-line-number="9">rank <span class="dt">Leaf</span>          <span class="fu">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb43-10" data-line-number="10">rank (<span class="dt">Node</span> r _ _ _) <span class="fu">=</span> r</a>
<a class="sourceLine" id="cb43-11" data-line-number="11"><span class="ot">{-# INLINE rank #-}</span></a>
<a class="sourceLine" id="cb43-12" data-line-number="12"></a>
<a class="sourceLine" id="cb43-13" data-line-number="13"><span class="ot">mergeL ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Leftist</span> a <span class="ot">-&gt;</span> <span class="dt">Leftist</span> a <span class="ot">-&gt;</span> <span class="dt">Leftist</span> a</a>
<a class="sourceLine" id="cb43-14" data-line-number="14">mergeL <span class="dt">Leaf</span> h2 <span class="fu">=</span> h2</a>
<a class="sourceLine" id="cb43-15" data-line-number="15">mergeL h1 <span class="dt">Leaf</span> <span class="fu">=</span> h1</a>
<a class="sourceLine" id="cb43-16" data-line-number="16">mergeL h1<span class="fu">@</span>(<span class="dt">Node</span> w1 p1 l1 r1) h2<span class="fu">@</span>(<span class="dt">Node</span> w2 p2 l2 r2)</a>
<a class="sourceLine" id="cb43-17" data-line-number="17">  <span class="fu">|</span> p1 <span class="fu">&lt;</span> p2 <span class="fu">=</span></a>
<a class="sourceLine" id="cb43-18" data-line-number="18">      <span class="kw">if</span> ll <span class="fu">&lt;=</span> lr</a>
<a class="sourceLine" id="cb43-19" data-line-number="19">          <span class="kw">then</span> <span class="dt">LNode</span> (w1 <span class="fu">+</span> w2) p1 l1 (mergeL r1 h2)</a>
<a class="sourceLine" id="cb43-20" data-line-number="20">          <span class="kw">else</span> <span class="dt">LNode</span> (w1 <span class="fu">+</span> w2) p1 (mergeL r1 h2) l1</a>
<a class="sourceLine" id="cb43-21" data-line-number="21">  <span class="fu">|</span> otherwise <span class="fu">=</span></a>
<a class="sourceLine" id="cb43-22" data-line-number="22">      <span class="kw">if</span> rl <span class="fu">&lt;=</span> rr</a>
<a class="sourceLine" id="cb43-23" data-line-number="23">          <span class="kw">then</span> <span class="dt">LNode</span> (w1 <span class="fu">+</span> w2) p2 l2 (mergeL r2 h1)</a>
<a class="sourceLine" id="cb43-24" data-line-number="24">          <span class="kw">else</span> <span class="dt">LNode</span> (w1 <span class="fu">+</span> w2) p2 (mergeL r2 h1) l2</a>
<a class="sourceLine" id="cb43-25" data-line-number="25">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb43-26" data-line-number="26">    ll <span class="fu">=</span> rank r1 <span class="fu">+</span> w2</a>
<a class="sourceLine" id="cb43-27" data-line-number="27">    lr <span class="fu">=</span> rank l1</a>
<a class="sourceLine" id="cb43-28" data-line-number="28">    rl <span class="fu">=</span> rank r2 <span class="fu">+</span> w1</a>
<a class="sourceLine" id="cb43-29" data-line-number="29">    rr <span class="fu">=</span> rank l2</a></code></pre></div>
<p>In a weight-biased leftist heap, the left branch in any tree must have at least as many elements as the right branch. Ideally, we would encode that in the representation of size-indexed leftist heap:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb44-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Leftist</span> n a <span class="kw">where</span></a>
<a class="sourceLine" id="cb44-2" data-line-number="2">        <span class="dt">Leaf</span><span class="ot"> ::</span> <span class="dt">Leftist</span> <span class="dv">0</span> a</a>
<a class="sourceLine" id="cb44-3" data-line-number="3">        <span class="dt">Node</span><span class="ot"> ::</span> <span class="fu">!</span>(<span class="dt">The</span> <span class="dt">Nat</span> (n <span class="fu">+</span> m <span class="fu">+</span> <span class="dv">1</span>))</a>
<a class="sourceLine" id="cb44-4" data-line-number="4">             <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb44-5" data-line-number="5">             <span class="ot">-&gt;</span> <span class="dt">Leftist</span> n a</a>
<a class="sourceLine" id="cb44-6" data-line-number="6">             <span class="ot">-&gt;</span> <span class="dt">Leftist</span> m a</a>
<a class="sourceLine" id="cb44-7" data-line-number="7">             <span class="ot">-&gt;</span> <span class="fu">!</span>(m <span class="fu">&lt;=</span> n)</a>
<a class="sourceLine" id="cb44-8" data-line-number="8">             <span class="ot">-&gt;</span> <span class="dt">Leftist</span> (n <span class="fu">+</span> m <span class="fu">+</span> <span class="dv">1</span>) a</a>
<a class="sourceLine" id="cb44-9" data-line-number="9"></a>
<a class="sourceLine" id="cb44-10" data-line-number="10"><span class="ot">rank ::</span> <span class="dt">Leftist</span> n s <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> n</a>
<a class="sourceLine" id="cb44-11" data-line-number="11">rank <span class="dt">Leaf</span>             <span class="fu">=</span> sing</a>
<a class="sourceLine" id="cb44-12" data-line-number="12">rank (<span class="dt">Node</span> r _ _ _ _) <span class="fu">=</span> r</a>
<a class="sourceLine" id="cb44-13" data-line-number="13"><span class="ot">{-# INLINE rank #-}</span></a></code></pre></div>
<p>Two problems, though: first of all, we need to be able to <em>compare</em> the sizes of two heaps, in the merge function. If we were using the type-level Peano numbers, this would be too slow. More importantly, though, we need the comparison to provide a <em>proof</em> of the ordering, so that we can use it in the resulting <code class="sourceCode haskell"><span class="dt">Node</span></code> constructor.</p>
<h3 id="integer-backed-type-level-numbers">Integer-Backed Type-Level Numbers</h3>
<p>In Agda, the Peano type is actually backed by Haskell’s <code class="sourceCode haskell"><span class="dt">Integer</span></code> at runtime. This allows compile-time proofs to be written about values which are calculated efficiently. We can mimic the same thing in Haskell with a newtype wrapper <em>around</em> <code class="sourceCode haskell"><span class="dt">Integer</span></code> with a phantom <code class="sourceCode haskell"><span class="dt">Peano</span></code> parameter, if we promise to never put an integer in which has a different value to its phantom value. We can make this promise a little more trustworthy if we don’t export the newtype constructor.</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb45-1" data-line-number="1"><span class="kw">newtype</span> <span class="kw">instance</span> <span class="dt">The</span> <span class="dt">Nat</span> n <span class="kw">where</span></a>
<a class="sourceLine" id="cb45-2" data-line-number="2">        <span class="dt">NatSing</span><span class="ot"> ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> n</a>
<a class="sourceLine" id="cb45-3" data-line-number="3"></a>
<a class="sourceLine" id="cb45-4" data-line-number="4"><span class="kw">instance</span> <span class="dt">KnownNat</span> n <span class="ot">=&gt;</span> <span class="dt">KnownSing</span> n <span class="kw">where</span></a>
<a class="sourceLine" id="cb45-5" data-line-number="5">    sing <span class="fu">=</span> <span class="dt">NatSing</span> <span class="fu">$</span> Prelude.fromInteger <span class="fu">$</span> natVal (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> n)</a></code></pre></div>
<p><code class="sourceCode haskell"><span class="dt">FlexibleInstances</span></code> is needed for the instance. We can also encode all the necessary arithmetic:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb46-1" data-line-number="1"><span class="kw">infixl</span> <span class="dv">6</span> <span class="fu">+.</span></a>
<a class="sourceLine" id="cb46-2" data-line-number="2"><span class="ot">(+.) ::</span> <span class="dt">The</span> <span class="dt">Nat</span> n <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> m <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> (n <span class="fu">+</span> m)</a>
<a class="sourceLine" id="cb46-3" data-line-number="3">(<span class="fu">+.</span>) <span class="fu">=</span></a>
<a class="sourceLine" id="cb46-4" data-line-number="4">    (<span class="ot">coerce ::</span> (<span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>) </a>
<a class="sourceLine" id="cb46-5" data-line-number="5">            <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> n <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> m <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> (n <span class="fu">+</span> m))</a>
<a class="sourceLine" id="cb46-6" data-line-number="6">        (<span class="fu">+</span>)</a>
<a class="sourceLine" id="cb46-7" data-line-number="7"><span class="ot">{-# INLINE (+.) #-}</span></a></code></pre></div>
<p>Finally, the compare function (<code class="sourceCode haskell"><span class="dt">ScopedTypeVariables</span></code> for this):</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb47-1" data-line-number="1">infix <span class="dv">4</span> <span class="fu">&lt;=.</span></a>
<a class="sourceLine" id="cb47-2" data-line-number="2"><span class="ot">(&lt;=.) ::</span> <span class="dt">The</span> <span class="dt">Nat</span> n <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Nat</span> m <span class="ot">-&gt;</span> <span class="dt">The</span> <span class="dt">Bool</span> (n <span class="fu">&lt;=?</span> m)</a>
<a class="sourceLine" id="cb47-3" data-line-number="3">(<span class="fu">&lt;=.</span>) (<span class="dt">NatSing</span><span class="ot"> x ::</span> <span class="dt">The</span> <span class="dt">Nat</span> n) (<span class="dt">NatSing</span><span class="ot"> y ::</span> <span class="dt">The</span> <span class="dt">Nat</span> m)</a>
<a class="sourceLine" id="cb47-4" data-line-number="4">  <span class="fu">|</span> x <span class="fu">&lt;=</span> y <span class="fu">=</span> </a>
<a class="sourceLine" id="cb47-5" data-line-number="5">      <span class="kw">case</span> (unsafeCoerce (<span class="dt">Refl</span><span class="ot"> ::</span> <span class="dt">True</span> <span class="fu">:~:</span> <span class="dt">True</span>)<span class="ot"> ::</span> (n <span class="fu">&lt;=?</span> m) <span class="fu">:~:</span> <span class="dt">True</span>) <span class="kw">of</span></a>
<a class="sourceLine" id="cb47-6" data-line-number="6">        <span class="dt">Refl</span> <span class="ot">-&gt;</span> <span class="dt">Truey</span></a>
<a class="sourceLine" id="cb47-7" data-line-number="7">  <span class="fu">|</span> otherwise <span class="fu">=</span> </a>
<a class="sourceLine" id="cb47-8" data-line-number="8">      <span class="kw">case</span> (unsafeCoerce (<span class="dt">Refl</span><span class="ot"> ::</span> <span class="dt">True</span> <span class="fu">:~:</span> <span class="dt">True</span>)<span class="ot"> ::</span> (n <span class="fu">&lt;=?</span> m) <span class="fu">:~:</span> <span class="dt">False</span>) <span class="kw">of</span></a>
<a class="sourceLine" id="cb47-9" data-line-number="9">        <span class="dt">Refl</span> <span class="ot">-&gt;</span> <span class="dt">Falsy</span></a>
<a class="sourceLine" id="cb47-10" data-line-number="10"><span class="ot">{-# INLINE (&lt;=.) #-}</span></a>
<a class="sourceLine" id="cb47-11" data-line-number="11"></a>
<a class="sourceLine" id="cb47-12" data-line-number="12"><span class="ot">totalOrder ::</span>  p n <span class="ot">-&gt;</span> q m <span class="ot">-&gt;</span> (n <span class="fu">&lt;=?</span> m) <span class="fu">:~:</span> <span class="dt">False</span> <span class="ot">-&gt;</span> (m <span class="fu">&lt;=?</span> n) <span class="fu">:~:</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb47-13" data-line-number="13">totalOrder (<span class="ot">_ ::</span> p n) (<span class="ot">_ ::</span> q m) <span class="dt">Refl</span> <span class="fu">=</span> </a>
<a class="sourceLine" id="cb47-14" data-line-number="14">    unsafeCoerce <span class="dt">Refl</span><span class="ot"> ::</span> (m <span class="fu">&lt;=?</span> n) <span class="fu">:~:</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb47-15" data-line-number="15"></a>
<a class="sourceLine" id="cb47-16" data-line-number="16"><span class="kw">type</span> x <span class="fu">&lt;=</span> y <span class="fu">=</span> (x <span class="fu">&lt;=?</span> y) <span class="fu">:~:</span> <span class="dt">True</span></a></code></pre></div>
<p>It’s worth mentioning that all of these functions are somewhat axiomatic: there’s no checking of these definitions going on, and any later proofs are only correct in terms of these functions.</p>
<p>If we want our merge function to <em>really</em> look like the non-verified version, though, we’ll have to mess around with the syntax a little.</p>
<h3 id="a-dependent-if-then-else">A Dependent if-then-else</h3>
<p>When matching on a singleton, <em>within</em> the case-match, proof of the singleton’s type is provided. For instance:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb48-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">IfThenElse</span> (<span class="ot">c ::</span> <span class="dt">Bool</span>) (<span class="ot">true ::</span> k) (<span class="ot">false ::</span> k)<span class="ot"> ::</span> k</a>
<a class="sourceLine" id="cb48-2" data-line-number="2">     <span class="kw">where</span></a>
<a class="sourceLine" id="cb48-3" data-line-number="3">        <span class="dt">IfThenElse</span> <span class="dt">True</span> true false <span class="fu">=</span> true</a>
<a class="sourceLine" id="cb48-4" data-line-number="4">        <span class="dt">IfThenElse</span> <span class="dt">False</span> true false <span class="fu">=</span> false</a>
<a class="sourceLine" id="cb48-5" data-line-number="5"></a>
<a class="sourceLine" id="cb48-6" data-line-number="6"><span class="ot">intOrString ::</span> <span class="dt">The</span> <span class="dt">Bool</span> cond <span class="ot">-&gt;</span> <span class="dt">IfThenElse</span> cond <span class="dt">Int</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb48-7" data-line-number="7">intOrString <span class="dt">Truey</span> <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb48-8" data-line-number="8">intOrString <span class="dt">Falsy</span> <span class="fu">=</span> <span class="st">&quot;abc&quot;</span></a></code></pre></div>
<p>In Haskell, since we can overload the if-then-else construct (with <code class="sourceCode haskell"><span class="dt">RebindableSyntax</span></code>), we can provide the same syntax, while hiding the dependent nature:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb49-1" data-line-number="1"><span class="ot">ifThenElse ::</span> <span class="dt">The</span> <span class="dt">Bool</span> c <span class="ot">-&gt;</span> (c <span class="fu">:~:</span> <span class="dt">True</span> <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (c <span class="fu">:~:</span> <span class="dt">False</span> <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb49-2" data-line-number="2">ifThenElse <span class="dt">Truey</span> t _ <span class="fu">=</span> t <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb49-3" data-line-number="3">ifThenElse <span class="dt">Falsy</span> _ f <span class="fu">=</span> f <span class="dt">Refl</span></a></code></pre></div>
<h3 id="verified-merge">Verified Merge</h3>
<p>Finally, then, we can write the implementation for merge, which looks almost <em>exactly</em> the same as the non-verified merge:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb50-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">IndexedQueue</span> <span class="dt">Leftist</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb50-2" data-line-number="2"></a>
<a class="sourceLine" id="cb50-3" data-line-number="3">    minView (<span class="dt">Node</span> _ x l r _) <span class="fu">=</span> (x, merge l r)</a>
<a class="sourceLine" id="cb50-4" data-line-number="4">    <span class="ot">{-# INLINE minView #-}</span></a>
<a class="sourceLine" id="cb50-5" data-line-number="5"></a>
<a class="sourceLine" id="cb50-6" data-line-number="6"></a>
<a class="sourceLine" id="cb50-7" data-line-number="7">    singleton x <span class="fu">=</span> <span class="dt">Node</span> sing x <span class="dt">Leaf</span> <span class="dt">Leaf</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb50-8" data-line-number="8">    <span class="ot">{-# INLINE singleton #-}</span></a>
<a class="sourceLine" id="cb50-9" data-line-number="9"></a>
<a class="sourceLine" id="cb50-10" data-line-number="10">    empty <span class="fu">=</span> <span class="dt">Leaf</span></a>
<a class="sourceLine" id="cb50-11" data-line-number="11">    <span class="ot">{-# INLINE empty #-}</span></a>
<a class="sourceLine" id="cb50-12" data-line-number="12"></a>
<a class="sourceLine" id="cb50-13" data-line-number="13">    insert <span class="fu">=</span> merge <span class="fu">.</span> singleton</a>
<a class="sourceLine" id="cb50-14" data-line-number="14">    <span class="ot">{-# INLINE insert #-}</span></a>
<a class="sourceLine" id="cb50-15" data-line-number="15"></a>
<a class="sourceLine" id="cb50-16" data-line-number="16">    minViewMay <span class="dt">Leaf</span> b _             <span class="fu">=</span> b</a>
<a class="sourceLine" id="cb50-17" data-line-number="17">    minViewMay (<span class="dt">Node</span> _ x l r _) _ f <span class="fu">=</span> f x (merge l r)</a>
<a class="sourceLine" id="cb50-18" data-line-number="18"></a>
<a class="sourceLine" id="cb50-19" data-line-number="19"><span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb50-20" data-line-number="20">         <span class="dt">MeldableIndexedQueue</span> <span class="dt">Leftist</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb50-21" data-line-number="21">    merge <span class="dt">Leaf</span> h2 <span class="fu">=</span> h2</a>
<a class="sourceLine" id="cb50-22" data-line-number="22">    merge h1 <span class="dt">Leaf</span> <span class="fu">=</span> h1</a>
<a class="sourceLine" id="cb50-23" data-line-number="23">    merge h1<span class="fu">@</span>(<span class="dt">Node</span> w1 p1 l1 r1 _) h2<span class="fu">@</span>(<span class="dt">Node</span> w2 p2 l2 r2 _)</a>
<a class="sourceLine" id="cb50-24" data-line-number="24">      <span class="fu">|</span> p1 <span class="fu">&lt;</span> p2 <span class="fu">=</span></a>
<a class="sourceLine" id="cb50-25" data-line-number="25">          <span class="kw">if</span> ll <span class="fu">&lt;=.</span> lr</a>
<a class="sourceLine" id="cb50-26" data-line-number="26">             <span class="kw">then</span> <span class="dt">Node</span> (w1 <span class="fu">+.</span> w2) p1 l1 (merge r1 h2)</a>
<a class="sourceLine" id="cb50-27" data-line-number="27">             <span class="kw">else</span> <span class="dt">Node</span> (w1 <span class="fu">+.</span> w2) p1 (merge r1 h2) l1 <span class="fu">.</span> totalOrder ll lr</a>
<a class="sourceLine" id="cb50-28" data-line-number="28">      <span class="fu">|</span> otherwise <span class="fu">=</span></a>
<a class="sourceLine" id="cb50-29" data-line-number="29">          <span class="kw">if</span> rl <span class="fu">&lt;=.</span> rr</a>
<a class="sourceLine" id="cb50-30" data-line-number="30">              <span class="kw">then</span> <span class="dt">Node</span> (w1 <span class="fu">+.</span> w2) p2 l2 (merge r2 h1)</a>
<a class="sourceLine" id="cb50-31" data-line-number="31">              <span class="kw">else</span> <span class="dt">Node</span> (w1 <span class="fu">+.</span> w2) p2 (merge r2 h1) l2 <span class="fu">.</span> totalOrder rl rr</a>
<a class="sourceLine" id="cb50-32" data-line-number="32">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb50-33" data-line-number="33">        ll <span class="fu">=</span> rank r1 <span class="fu">+.</span> w2</a>
<a class="sourceLine" id="cb50-34" data-line-number="34">        lr <span class="fu">=</span> rank l1</a>
<a class="sourceLine" id="cb50-35" data-line-number="35">        rl <span class="fu">=</span> rank r2 <span class="fu">+.</span> w1</a>
<a class="sourceLine" id="cb50-36" data-line-number="36">        rr <span class="fu">=</span> rank l2</a>
<a class="sourceLine" id="cb50-37" data-line-number="37">    <span class="ot">{-# INLINE merge #-}</span></a></code></pre></div>
<p>What’s cool about this implementation is that it has the same performance as the non-verified version (if <code class="sourceCode haskell"><span class="dt">Integer</span></code> is swapped out for <code class="sourceCode haskell"><span class="dt">Int</span></code>, that is), and it <em>looks</em> pretty much the same. This is very close to static verification for free.</p>
<h3 id="generalizing-sort-to-parts">Generalizing Sort to Parts</h3>
<p>The <code class="sourceCode haskell"><span class="dt">Sort</span></code> type used in the original blog post can be generalized to <em>any</em> indexed container.</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb51-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Parts</span> f g a b r <span class="kw">where</span></a>
<a class="sourceLine" id="cb51-2" data-line-number="2">    <span class="dt">Parts</span><span class="ot"> ::</span> (forall n<span class="fu">.</span> g (m <span class="fu">+</span> n) b <span class="ot">-&gt;</span> (g n b, r))</a>
<a class="sourceLine" id="cb51-3" data-line-number="3">         <span class="ot">-&gt;</span> <span class="fu">!</span>(f m a)</a>
<a class="sourceLine" id="cb51-4" data-line-number="4">         <span class="ot">-&gt;</span> <span class="dt">Parts</span> f g a b r</a>
<a class="sourceLine" id="cb51-5" data-line-number="5"></a>
<a class="sourceLine" id="cb51-6" data-line-number="6"><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Parts</span> f g a b) <span class="kw">where</span></a>
<a class="sourceLine" id="cb51-7" data-line-number="7">  fmap f (<span class="dt">Parts</span> g h) <span class="fu">=</span></a>
<a class="sourceLine" id="cb51-8" data-line-number="8">    <span class="dt">Parts</span> (\h&#39; <span class="ot">-&gt;</span> <span class="kw">case</span> g h&#39; <span class="kw">of</span> (remn, r) <span class="ot">-&gt;</span> (remn, f r)) h</a>
<a class="sourceLine" id="cb51-9" data-line-number="9">  <span class="ot">{-# INLINE fmap #-}</span></a>
<a class="sourceLine" id="cb51-10" data-line-number="10"></a>
<a class="sourceLine" id="cb51-11" data-line-number="11"><span class="kw">instance</span> (<span class="dt">IndexedQueue</span> f x, <span class="dt">MeldableIndexedQueue</span> f x) <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb51-12" data-line-number="12">          <span class="dt">Applicative</span> (<span class="dt">Parts</span> f g x y) <span class="kw">where</span></a>
<a class="sourceLine" id="cb51-13" data-line-number="13">    pure x <span class="fu">=</span> <span class="dt">Parts</span> (\h <span class="ot">-&gt;</span> (h, x)) empty</a>
<a class="sourceLine" id="cb51-14" data-line-number="14">    <span class="ot">{-# INLINE pure #-}</span></a>
<a class="sourceLine" id="cb51-15" data-line-number="15"></a>
<a class="sourceLine" id="cb51-16" data-line-number="16">    (<span class="dt">Parts</span> f (<span class="ot">xs ::</span> f m x)<span class="ot"> ::</span> <span class="dt">Parts</span> f g x y (a <span class="ot">-&gt;</span> b)) <span class="fu">&lt;*&gt;</span> </a>
<a class="sourceLine" id="cb51-17" data-line-number="17">      <span class="dt">Parts</span> g (<span class="ot">ys ::</span> f n x) <span class="fu">=</span></a>
<a class="sourceLine" id="cb51-18" data-line-number="18">        <span class="dt">Parts</span> h (merge xs ys)</a>
<a class="sourceLine" id="cb51-19" data-line-number="19">        <span class="kw">where</span></a>
<a class="sourceLine" id="cb51-20" data-line-number="20"><span class="ot">          h ::</span> forall o <span class="fu">.</span> g ((m <span class="fu">+</span> n) <span class="fu">+</span> o) y <span class="ot">-&gt;</span> (g o y, b)</a>
<a class="sourceLine" id="cb51-21" data-line-number="21">          h v <span class="fu">=</span> <span class="kw">case</span> f v <span class="kw">of</span> { (v&#39;, a) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb51-22" data-line-number="22">                    <span class="kw">case</span> g v&#39; <span class="kw">of</span> { (v&#39;&#39;, b) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb51-23" data-line-number="23">                      (v&#39;&#39;, a b)}}</a>
<a class="sourceLine" id="cb51-24" data-line-number="24">    <span class="ot">{-# INLINABLE (&lt;*&gt;) #-}</span></a></code></pre></div>
<p>This version doesn’t insist that you order the elements of the heap in any particular way: we could use indexed difference lists to reverse a container, or indexed lists to calculate permutations of a container, for instance.</p>
<h3 id="other-uses-for-size-indexed-heaps">Other Uses For Size-Indexed Heaps</h3>
<p>I’d be very interested to see any other uses of these indexed heaps, if anyone has any ideas. Potentially the could be used in any place where there is a need for some heap which is known to be of a certain size (a true prime sieve, for instance).</p>
<h3 id="the-library">The Library</h3>
<p>I’ve explored all of these ideas <a href="https://github.com/oisdk/type-indexed-queues">here</a>. It has implementations of all the heaps I mentioned, as well as the index-erasing type, and a size-indexed list, for reversing traversables. In the future, I might add things like a Fibonacci heap, or the optimal Brodal/Okasaki heap <span class="citation" data-cites="brodal_optimal_1996">(Brodal and Okasaki <a href="#ref-brodal_optimal_1996">1996</a>)</span>.</p>
<hr />
<div id="refs" class="references">
<div id="ref-brodal_optimal_1996">
<p>Brodal, Gerth Stølting, and Chris Okasaki. 1996. “Optimal Purely Functional Priority Queues.” <em>Journal of Functional Programming</em> 6 (6) (November): 839–857. doi:<a href="https://doi.org/10.1017/S095679680000201X">10.1017/S095679680000201X</a>. <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.48.973" class="uri">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.48.973</a>.</p>
</div>
<div id="ref-diatchki_improving_2015">
<p>Diatchki, Iavor S. 2015. “Improving Haskell Types with SMT.” In <em>Proceedings of the 2015 ACM SIGPLAN Symposium on Haskell</em>, 1–10. Haskell ’15. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/2804302.2804307">10.1145/2804302.2804307</a>. <a href="http://yav.github.io/publications/improving-smt-types.pdf" class="uri">http://yav.github.io/publications/improving-smt-types.pdf</a>.</p>
</div>
<div id="ref-eisenberg_dependently_2012">
<p>Eisenberg, Richard A., and Stephanie Weirich. 2012. “Dependently Typed Programming with Singletons.” In <em>Proceedings of the 2012 Haskell Symposium</em>, 117–130. Haskell ’12. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/2364506.2364522">10.1145/2364506.2364522</a>. <a href="http://cs.brynmawr.edu/~rae/papers/2012/singletons/paper.pdf" class="uri">http://cs.brynmawr.edu/~rae/papers/2012/singletons/paper.pdf</a>.</p>
</div>
<div id="ref-fredman_pairing_1986">
<p>Fredman, Michael L., Robert Sedgewick, Daniel D. Sleator, and Robert E. Tarjan. 1986. “The pairing heap: A new form of self-adjusting heap.” <em>Algorithmica</em> 1 (1-4) (January): 111–129. doi:<a href="https://doi.org/10.1007/BF01840439">10.1007/BF01840439</a>. <a href="http://www.cs.princeton.edu/courses/archive/fall09/cos521/Handouts/pairingheaps.pdf" class="uri">http://www.cs.princeton.edu/courses/archive/fall09/cos521/Handouts/pairingheaps.pdf</a>.</p>
</div>
<div id="ref-hinze_functional_1999">
<p>Hinze, Ralf. 1999. “Functional Pearls: Explaining Binomial Heaps.” <em>Journal of Functional Programming</em> 9 (1) (January): 93–104. doi:<a href="https://doi.org/10.1017/S0956796899003317">10.1017/S0956796899003317</a>. <a href="http://www.cs.ox.ac.uk/ralf.hinze/publications/#J1" class="uri">http://www.cs.ox.ac.uk/ralf.hinze/publications/#J1</a>.</p>
</div>
<div id="ref-hinze_manufacturing_2001">
<p>———. 2001. “Manufacturing datatypes.” <em>Journal of Functional Programming</em> 11 (5) (September): 493–524. doi:<a href="https://doi.org/10.1017/S095679680100404X">10.1017/S095679680100404X</a>. <a href="http://www.cs.ox.ac.uk/ralf.hinze/publications/#J6" class="uri">http://www.cs.ox.ac.uk/ralf.hinze/publications/#J6</a>.</p>
</div>
<div id="ref-okasaki_fast_1999">
<p>Okasaki, Chris. 1999. “From Fast Exponentiation to Square Matrices: An Adventure in Types.” In <em>Proceedings of the ACM SIGPLAN International Conference on Functional Programming (ICFP’99), Paris, France, September 27-29, 1999</em>, 34:28. ACM. <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.456.357&amp;rep=rep1&amp;type=pdf" class="uri">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.456.357&amp;rep=rep1&amp;type=pdf</a>.</p>
</div>
<div id="ref-wasserman_playing_2010">
<p>Wasserman, Louis. 2010. “Playing with Priority Queues.” <em>The Monad.Reader</em> 16 (16) (May): 37. <a href="https://themonadreader.files.wordpress.com/2010/05/issue16.pdf" class="uri">https://themonadreader.files.wordpress.com/2010/05/issue16.pdf</a>.</p>
</div>
</div>
]]></description>
    <pubDate>Sun, 23 Apr 2017 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2017-04-23-verifying-data-structures-in-haskell-lhs.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Fun with Recursion Schemes</title>
    <link>https://doisinkidney.com/posts/2017-03-30-fun-with-recursion-schemes.html</link>
    <description><![CDATA[<div class="info">
    Posted on March 30, 2017
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Recursion%20Schemes.html">Recursion Schemes</a>
    
</div>

<h2 id="folding-algebras">Folding Algebras</h2>
<p>I saw <a href="https://www.reddit.com/r/haskell/comments/608y0l/would_this_sugar_make_sense/">this</a> post on reddit recently, and it got me thinking about recursion schemes. One of the primary motivations behind them is the reduction of boilerplate. The classic example is evaluation of arithmetic expressions:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> <span class="dt">ExprF</span> a</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">LitF</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  <span class="fu">|</span> (<span class="fu">:+:</span>) a a</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">  <span class="fu">|</span> (<span class="fu">:*:</span>) a a</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">  <span class="kw">deriving</span> <span class="dt">Functor</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="kw">type</span> <span class="dt">Expr</span> <span class="fu">=</span> <span class="dt">Fix</span> <span class="dt">ExprF</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"></a>
<a class="sourceLine" id="cb1-9" data-line-number="9"><span class="ot">eval ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10">eval <span class="fu">=</span> unfix <span class="fu">&gt;&gt;&gt;</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11">  <span class="dt">LitF</span> n <span class="ot">-&gt;</span> n</a>
<a class="sourceLine" id="cb1-12" data-line-number="12">  x <span class="fu">:+:</span> y <span class="ot">-&gt;</span> eval x <span class="fu">+</span> eval y</a>
<a class="sourceLine" id="cb1-13" data-line-number="13">  x <span class="fu">:*:</span> y <span class="ot">-&gt;</span> eval x <span class="fu">*</span> eval y</a></code></pre></div>
<p>The calls to <code class="sourceCode haskell">eval</code> are the boilerplate: this is where the main recursion scheme, <code class="sourceCode haskell">cata</code> can help.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">evalF ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">evalF <span class="fu">=</span> cata <span class="fu">$</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  <span class="dt">LitF</span> n <span class="ot">-&gt;</span> n</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">  x <span class="fu">:+:</span> y <span class="ot">-&gt;</span> x <span class="fu">+</span> y</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">  x <span class="fu">:*:</span> y <span class="ot">-&gt;</span> x <span class="fu">*</span> y</a></code></pre></div>
<p>I still feel like there’s boilerplate, though. Ideally I’d like to write this:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">evalF ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">evalF <span class="fu">=</span> cata <span class="fu">$</span> <span class="fu">???</span> <span class="fu">$</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">  <span class="dt">Lit</span> <span class="ot">-&gt;</span> id</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">  <span class="dt">Add</span> <span class="ot">-&gt;</span> (<span class="fu">+</span>)</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">  <span class="dt">Mul</span> <span class="ot">-&gt;</span> (<span class="fu">*</span>)</a></code></pre></div>
<p>The <code class="sourceCode haskell"><span class="fu">???</span></code> needs to be filled in. It’s a little tricky, though: the type of the algebra changes depending on what expression it’s given. GADTs will allow us to attach types to cases:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">data</span> <span class="dt">ExprI</span> a r f <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  <span class="dt">Lit</span><span class="ot"> ::</span> <span class="dt">ExprI</span> a b (<span class="dt">Integer</span> <span class="ot">-&gt;</span> b)</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  <span class="dt">Add</span><span class="ot"> ::</span> <span class="dt">ExprI</span> a b (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b)</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">  <span class="dt">Mul</span><span class="ot"> ::</span> <span class="dt">ExprI</span> a b (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b)</a></code></pre></div>
<p>The first type parameter is the same as the first type parameter to <code class="sourceCode haskell"><span class="dt">ExprF</span></code>. The second is the output type of the algebra, and the third is the type of the fold required to produce that output type. The third type parameter <em>depends</em> on the case matched in the GADT. Using this, we can write a function which converts a fold/pattern match to a standard algebra:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">foldAlg ::</span> (forall f<span class="fu">.</span> <span class="dt">ExprI</span> a r f <span class="ot">-&gt;</span> f) <span class="ot">-&gt;</span> (<span class="dt">ExprF</span> a <span class="ot">-&gt;</span> r)</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">foldAlg f (<span class="dt">LitF</span> i)  <span class="fu">=</span> f <span class="dt">Lit</span> i</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">foldAlg f (x <span class="fu">:+:</span> y) <span class="fu">=</span> f <span class="dt">Add</span> x y</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">foldAlg f (x <span class="fu">:*:</span> y) <span class="fu">=</span> f <span class="dt">Mul</span> x y</a></code></pre></div>
<p>And finally, we can write the nice evaluation algebra:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">evalF ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">evalF <span class="fu">=</span> cata <span class="fu">$</span> foldAlg <span class="fu">$</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  <span class="dt">Lit</span> <span class="ot">-&gt;</span> id</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">  <span class="dt">Add</span> <span class="ot">-&gt;</span> (<span class="fu">+</span>)</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">  <span class="dt">Mul</span> <span class="ot">-&gt;</span> (<span class="fu">*</span>)</a></code></pre></div>
<p>I hacked together some quick template Haskell to generate the matchers over <a href="https://github.com/oisdk/pattern-folds">here</a>. It uses a class <code class="sourceCode haskell"><span class="dt">AsPatternFold</span></code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">class</span> <span class="dt">AsPatternFold</span> x f <span class="fu">|</span> x <span class="ot">-&gt;</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="ot">  foldMatch ::</span> (forall a<span class="fu">.</span> f r a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (x <span class="ot">-&gt;</span> r)</a></code></pre></div>
<p>And you generate the extra data type, with an instance, by doing this:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">makePatternFolds <span class="ch">&#39;&#39;</span><span class="dt">ExprF</span></a></code></pre></div>
<p>The code it generates can be used like this:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">evalF ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">evalF <span class="fu">=</span> cata <span class="fu">$</span> foldMatch <span class="fu">$</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  <span class="dt">LitI</span> <span class="ot">-&gt;</span> id</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">  (<span class="fu">:+|</span>) <span class="ot">-&gt;</span> (<span class="fu">+</span>)</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  (<span class="fu">:*|</span>) <span class="ot">-&gt;</span> (<span class="fu">*</span>)</a></code></pre></div>
<p>It’s terribly hacky at the moment, I may clean it up later.</p>
<h2 id="record-case">Record Case</h2>
<p>There’s another approach to the same idea that is slightly more sensible, using record wildcards. You define a handler for you datatype (an algebra):</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">data</span> <span class="dt">ExprAlg</span> a r</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">ExprAlg</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  {<span class="ot"> litF ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> r</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">  ,<span class="ot"> (+:) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> r</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">  ,<span class="ot"> (*:) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> r }</a></code></pre></div>
<p>Then, to use it, you define how to interact between the handler and the datatype, like before. The benefit is that record wildcard syntax allows you to piggy back on the function definition syntax, like so:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">data</span> <span class="dt">ExprF</span> a</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">LitF</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  <span class="fu">|</span> (<span class="fu">:+:</span>) a a</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">  <span class="fu">|</span> (<span class="fu">:*:</span>) a a</a>
<a class="sourceLine" id="cb11-5" data-line-number="5"></a>
<a class="sourceLine" id="cb11-6" data-line-number="6">makeHandler <span class="ch">&#39;&#39;</span><span class="dt">ExprF</span></a>
<a class="sourceLine" id="cb11-7" data-line-number="7"></a>
<a class="sourceLine" id="cb11-8" data-line-number="8"><span class="ot">exprAlg ::</span> <span class="dt">ExprF</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb11-9" data-line-number="9">exprAlg <span class="fu">=</span> index <span class="dt">ExprFAlg</span> {<span class="fu">..</span>} <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-10" data-line-number="10">  litF <span class="fu">=</span> id</a>
<a class="sourceLine" id="cb11-11" data-line-number="11">  (<span class="fu">+:</span>) <span class="fu">=</span> (<span class="fu">+</span>)</a>
<a class="sourceLine" id="cb11-12" data-line-number="12">  (<span class="fu">*:</span>) <span class="fu">=</span> (<span class="fu">*</span>)</a></code></pre></div>
<p>This approach is much more principled: the <code class="sourceCode haskell">index</code> function, for example, comes from the <a href="https://hackage.haskell.org/package/adjunctions">adjunctions</a> package, from the <a href="https://hackage.haskell.org/package/adjunctions-4.3/docs/Data-Functor-Rep.html"><code class="sourceCode haskell"><span class="dt">Representable</span></code></a> class. That’s because those algebras are actually representable functors, with their representation being the thing they match. They also conform to a whole bunch of things automatically, letting you combine them interesting ways.</p>
<h2 id="printing-expressions">Printing Expressions</h2>
<p>Properly printing expressions, with minimal parentheses, is a surprisingly difficult problem. <span class="citation" data-cites="ramsey_unparsing_1998">Ramsey (<a href="#ref-ramsey_unparsing_1998">1998</a>)</span> provides a solution of the form:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1">isParens side (<span class="dt">Assoc</span> ao po) (<span class="dt">Assoc</span> ai pi) <span class="fu">=</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">  pi <span class="fu">&lt;=</span> po <span class="fu">&amp;&amp;</span> (pi <span class="fu">/=</span> po <span class="fu">||</span> ai <span class="fu">/=</span> ao <span class="fu">||</span> ao <span class="fu">/=</span> side)</a></code></pre></div>
<p>Using this, we can write an algebra for printing expressions. It should work in the general case, not just on the expression type defined above, so we need to make another unfixed functor to describe the printing of an expression:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Side</span> <span class="fu">=</span> <span class="dt">L</span> <span class="fu">|</span> <span class="dt">R</span> <span class="kw">deriving</span> <span class="dt">Eq</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2"></a>
<a class="sourceLine" id="cb13-3" data-line-number="3"><span class="kw">data</span> <span class="dt">ShowExpr</span> t e</a>
<a class="sourceLine" id="cb13-4" data-line-number="4">  <span class="fu">=</span> <span class="dt">ShowLit</span> {<span class="ot"> _repr ::</span> t }</a>
<a class="sourceLine" id="cb13-5" data-line-number="5">  <span class="fu">|</span> <span class="dt">Prefix</span>  {<span class="ot"> _repr ::</span> t,<span class="ot"> _assoc ::</span> (<span class="dt">Int</span>,<span class="dt">Side</span>),<span class="ot"> _child  ::</span> e }</a>
<a class="sourceLine" id="cb13-6" data-line-number="6">  <span class="fu">|</span> <span class="dt">Postfix</span> {<span class="ot"> _repr ::</span> t,<span class="ot"> _assoc ::</span> (<span class="dt">Int</span>,<span class="dt">Side</span>),<span class="ot"> _child  ::</span> e }</a>
<a class="sourceLine" id="cb13-7" data-line-number="7">  <span class="fu">|</span> <span class="dt">Binary</span>  {<span class="ot"> _repr ::</span> t,<span class="ot"> _assoc ::</span> (<span class="dt">Int</span>,<span class="dt">Side</span>),<span class="ot"> _lchild ::</span> e</a>
<a class="sourceLine" id="cb13-8" data-line-number="8">                                              ,<span class="ot"> _rchild ::</span> e }</a>
<a class="sourceLine" id="cb13-9" data-line-number="9">  <span class="kw">deriving</span> <span class="dt">Functor</span></a>
<a class="sourceLine" id="cb13-10" data-line-number="10">  </a>
<a class="sourceLine" id="cb13-11" data-line-number="11">makeLenses <span class="ch">&#39;&#39;</span><span class="dt">ShowExpr</span></a></code></pre></div>
<p>The lenses are probably overkill. For printing, we need not only the precedence of the current level, but also the precedence one level below. Seems like the perfect case for a zygomorphism:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="ot">showExprAlg ::</span> <span class="dt">Semigroup</span> t</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">            <span class="ot">=&gt;</span> (t <span class="ot">-&gt;</span> t)</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">            <span class="ot">-&gt;</span> <span class="dt">ShowExpr</span> t (<span class="dt">Maybe</span> (<span class="dt">Int</span>,<span class="dt">Side</span>), t)</a>
<a class="sourceLine" id="cb14-4" data-line-number="4">            <span class="ot">-&gt;</span> t</a>
<a class="sourceLine" id="cb14-5" data-line-number="5">showExprAlg prns <span class="fu">=</span> \<span class="kw">case</span> </a>
<a class="sourceLine" id="cb14-6" data-line-number="6">    <span class="dt">ShowLit</span> t               <span class="ot">-&gt;</span>                   t</a>
<a class="sourceLine" id="cb14-7" data-line-number="7">    <span class="dt">Prefix</span>  t s       (q,y) <span class="ot">-&gt;</span>                   t <span class="fu">&lt;&gt;</span> ifPrns <span class="dt">R</span> s q y</a>
<a class="sourceLine" id="cb14-8" data-line-number="8">    <span class="dt">Postfix</span> t s (p,x)       <span class="ot">-&gt;</span> ifPrns <span class="dt">L</span> s p x <span class="fu">&lt;&gt;</span> t</a>
<a class="sourceLine" id="cb14-9" data-line-number="9">    <span class="dt">Binary</span>  t s (p,x) (q,y) <span class="ot">-&gt;</span> ifPrns <span class="dt">L</span> s p x <span class="fu">&lt;&gt;</span> t <span class="fu">&lt;&gt;</span> ifPrns <span class="dt">R</span> s q y</a>
<a class="sourceLine" id="cb14-10" data-line-number="10">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-11" data-line-number="11">    ifPrns sid (op,oa) (<span class="dt">Just</span> (ip,ia))</a>
<a class="sourceLine" id="cb14-12" data-line-number="12">      <span class="fu">|</span> ip <span class="fu">&lt;</span> op <span class="fu">||</span> ip <span class="fu">==</span> op <span class="fu">&amp;&amp;</span> (ia <span class="fu">/=</span> oa <span class="fu">||</span> sid <span class="fu">/=</span> oa) <span class="fu">=</span> prns</a>
<a class="sourceLine" id="cb14-13" data-line-number="13">    ifPrns _ _ _ <span class="fu">=</span> id</a></code></pre></div>
<p>The first argument to this algebra is the parenthesizing function. This algebra works fine for when the <code class="sourceCode haskell"><span class="dt">ShowExpr</span></code> type is already constructed:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="ot">showExpr&#39; ::</span> <span class="dt">Semigroup</span> t <span class="ot">=&gt;</span> (t <span class="ot">-&gt;</span> t) <span class="ot">-&gt;</span> <span class="dt">Fix</span> (<span class="dt">ShowExpr</span> t) <span class="ot">-&gt;</span> t</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">showExpr&#39; <span class="fu">=</span> zygo (preview assoc) <span class="fu">.</span> showExprAlg</a></code></pre></div>
<p>But we still need to construct the <code class="sourceCode haskell"><span class="dt">ShowExpr</span></code> from something else first. <code class="sourceCode haskell">hylo</code> might be a good fit:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="ot">hylo ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (f b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> f a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b</a></code></pre></div>
<p>But that performs a catamorphism after an anamorphism, and we want a zygomorphism after an anamorphism. Luckily, the <a href="https://hackage.haskell.org/package/recursion-schemes">recursion-schemes</a> library is constructed in such a way that different schemes can be stuck together relatively easily:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1">hylozygo</a>
<a class="sourceLine" id="cb17-2" data-line-number="2"><span class="ot">    ::</span> <span class="dt">Functor</span> f</a>
<a class="sourceLine" id="cb17-3" data-line-number="3">    <span class="ot">=&gt;</span> (f a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (f (a, b) <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> f c) <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb17-4" data-line-number="4">hylozygo x y z <span class="fu">=</span> ghylo (distZygo x) distAna y (fmap <span class="dt">Identity</span> <span class="fu">.</span> z)</a>
<a class="sourceLine" id="cb17-5" data-line-number="5"></a>
<a class="sourceLine" id="cb17-6" data-line-number="6"><span class="ot">showExpr ::</span> <span class="dt">Semigroup</span> t</a>
<a class="sourceLine" id="cb17-7" data-line-number="7">         <span class="ot">=&gt;</span> (t <span class="ot">-&gt;</span> t)</a>
<a class="sourceLine" id="cb17-8" data-line-number="8">         <span class="ot">-&gt;</span> (e <span class="ot">-&gt;</span> <span class="dt">ShowExpr</span> t e)</a>
<a class="sourceLine" id="cb17-9" data-line-number="9">         <span class="ot">-&gt;</span> e <span class="ot">-&gt;</span> t</a>
<a class="sourceLine" id="cb17-10" data-line-number="10">showExpr <span class="fu">=</span> hylozygo (preview assoc) <span class="fu">.</span> showExprAlg</a></code></pre></div>
<p>Let’s try it out, with a right-associative operator this time to make things more difficult:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="kw">data</span> <span class="dt">ExprF</span> a</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">LitF</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3">  <span class="fu">|</span> (<span class="fu">:+:</span>) a a</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">  <span class="fu">|</span> (<span class="fu">:*:</span>) a a</a>
<a class="sourceLine" id="cb18-5" data-line-number="5">  <span class="fu">|</span> (<span class="fu">:^:</span>) a a</a>
<a class="sourceLine" id="cb18-6" data-line-number="6">  <span class="kw">deriving</span> <span class="dt">Functor</span></a>
<a class="sourceLine" id="cb18-7" data-line-number="7"></a>
<a class="sourceLine" id="cb18-8" data-line-number="8">makeHandler <span class="ch">&#39;&#39;</span><span class="dt">ExprF</span></a>
<a class="sourceLine" id="cb18-9" data-line-number="9"></a>
<a class="sourceLine" id="cb18-10" data-line-number="10"><span class="kw">newtype</span> <span class="dt">Expr</span> <span class="fu">=</span> <span class="dt">Expr</span> {<span class="ot"> runExpr ::</span> <span class="dt">ExprF</span> <span class="dt">Expr</span> }</a>
<a class="sourceLine" id="cb18-11" data-line-number="11"></a>
<a class="sourceLine" id="cb18-12" data-line-number="12"><span class="kw">instance</span> <span class="dt">Num</span> <span class="dt">Expr</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-13" data-line-number="13">  fromInteger <span class="fu">=</span> <span class="dt">Expr</span> <span class="fu">.</span> <span class="dt">LitF</span></a>
<a class="sourceLine" id="cb18-14" data-line-number="14">  x <span class="fu">+</span> y <span class="fu">=</span> <span class="dt">Expr</span> (x <span class="fu">:+:</span> y)</a>
<a class="sourceLine" id="cb18-15" data-line-number="15">  x <span class="fu">*</span> y <span class="fu">=</span> <span class="dt">Expr</span> (x <span class="fu">:*:</span> y)</a>
<a class="sourceLine" id="cb18-16" data-line-number="16">  </a>
<a class="sourceLine" id="cb18-17" data-line-number="17"><span class="kw">infixr</span> <span class="dv">8</span> <span class="fu">^*</span></a>
<a class="sourceLine" id="cb18-18" data-line-number="18"><span class="ot">(^*) ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></a>
<a class="sourceLine" id="cb18-19" data-line-number="19">x <span class="fu">^*</span> y <span class="fu">=</span> <span class="dt">Expr</span> (x <span class="fu">:^:</span> y)</a>
<a class="sourceLine" id="cb18-20" data-line-number="20"></a>
<a class="sourceLine" id="cb18-21" data-line-number="21"><span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Expr</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-22" data-line-number="22">  show <span class="fu">=</span></a>
<a class="sourceLine" id="cb18-23" data-line-number="23">    showExpr</a>
<a class="sourceLine" id="cb18-24" data-line-number="24">      (\x <span class="ot">-&gt;</span> <span class="st">&quot;(&quot;</span> <span class="fu">++</span> x <span class="fu">++</span> <span class="st">&quot;)&quot;</span>)</a>
<a class="sourceLine" id="cb18-25" data-line-number="25">      (index <span class="dt">ExprFAlg</span> {<span class="fu">..</span>} <span class="fu">.</span> runExpr)</a>
<a class="sourceLine" id="cb18-26" data-line-number="26">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-27" data-line-number="27">      litF <span class="fu">=</span> <span class="dt">ShowLit</span> <span class="fu">.</span> show</a>
<a class="sourceLine" id="cb18-28" data-line-number="28">      (<span class="fu">+:</span>) <span class="fu">=</span> <span class="dt">Binary</span> <span class="st">&quot; + &quot;</span> (<span class="dv">6</span>,<span class="dt">L</span>)</a>
<a class="sourceLine" id="cb18-29" data-line-number="29">      (<span class="fu">*:</span>) <span class="fu">=</span> <span class="dt">Binary</span> <span class="st">&quot; * &quot;</span> (<span class="dv">7</span>,<span class="dt">L</span>)</a>
<a class="sourceLine" id="cb18-30" data-line-number="30">      (<span class="fu">^:</span>) <span class="fu">=</span> <span class="dt">Binary</span> <span class="st">&quot; ^ &quot;</span> (<span class="dv">8</span>,<span class="dt">R</span>)</a></code></pre></div>
<p>Since we only specified <code class="sourceCode haskell"><span class="dt">Semigroup</span></code> in the definition of <code class="sourceCode haskell">showExpr</code>, we can use the more efficient difference-list definition of <code class="sourceCode haskell"><span class="dt">Show</span></code>:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Expr</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-2" data-line-number="2">    showsPrec _ <span class="fu">=</span></a>
<a class="sourceLine" id="cb19-3" data-line-number="3">      appEndo <span class="fu">.</span> showExpr</a>
<a class="sourceLine" id="cb19-4" data-line-number="4">        (<span class="dt">Endo</span> <span class="fu">.</span> showParen <span class="dt">True</span> <span class="fu">.</span> appEndo)</a>
<a class="sourceLine" id="cb19-5" data-line-number="5">        (index <span class="dt">ExprFAlg</span> {<span class="fu">..</span>} <span class="fu">.</span> runExpr)</a>
<a class="sourceLine" id="cb19-6" data-line-number="6">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-7" data-line-number="7">        litF <span class="fu">=</span> <span class="dt">ShowLit</span> <span class="fu">.</span> <span class="dt">Endo</span> <span class="fu">.</span> shows</a>
<a class="sourceLine" id="cb19-8" data-line-number="8">        (<span class="fu">+:</span>) <span class="fu">=</span> <span class="dt">Binary</span> (<span class="dt">Endo</span> (<span class="st">&quot; + &quot;</span> <span class="fu">++</span>)) (<span class="dv">6</span>,<span class="dt">L</span>)</a>
<a class="sourceLine" id="cb19-9" data-line-number="9">        (<span class="fu">*:</span>) <span class="fu">=</span> <span class="dt">Binary</span> (<span class="dt">Endo</span> (<span class="st">&quot; * &quot;</span> <span class="fu">++</span>)) (<span class="dv">7</span>,<span class="dt">L</span>)</a>
<a class="sourceLine" id="cb19-10" data-line-number="10">        (<span class="fu">^:</span>) <span class="fu">=</span> <span class="dt">Binary</span> (<span class="dt">Endo</span> (<span class="st">&quot; ^ &quot;</span> <span class="fu">++</span>)) (<span class="dv">8</span>,<span class="dt">R</span>)</a>
<a class="sourceLine" id="cb19-11" data-line-number="11"></a>
<a class="sourceLine" id="cb19-12" data-line-number="12"><span class="dv">1</span> <span class="fu">^*</span> <span class="dv">2</span> <span class="fu">^*</span> <span class="dv">3</span>         <span class="co">-- 1 ^ 2 ^ 3</span></a>
<a class="sourceLine" id="cb19-13" data-line-number="13">(<span class="dv">1</span> <span class="fu">^*</span> <span class="dv">2</span>) <span class="fu">^*</span> <span class="dv">3</span>       <span class="co">-- (1 ^ 2) ^ 3</span></a>
<a class="sourceLine" id="cb19-14" data-line-number="14"><span class="dv">1</span> <span class="fu">*</span> <span class="dv">2</span> <span class="fu">+</span> <span class="dv">3</span><span class="ot">   ::</span> <span class="dt">Expr</span> <span class="co">-- 1 * 2 + 3</span></a>
<a class="sourceLine" id="cb19-15" data-line-number="15"><span class="dv">1</span> <span class="fu">*</span> (<span class="dv">2</span> <span class="fu">+</span> <span class="dv">3</span>)<span class="ot"> ::</span> <span class="dt">Expr</span> <span class="co">-- 1 * (2 + 3)</span></a></code></pre></div>
<div id="refs" class="references">
<div id="ref-ramsey_unparsing_1998">
<p>Ramsey, Norman. 1998. “Unparsing Expressions With Prefix and Postfix Operators.” <em>Software—Practice &amp; Experience</em> 28 (12): 1327–1356. <a href="http://www.cs.tufts.edu/%7Enr/pubs/unparse-abstract.html">http://www.cs.tufts.edu/%7Enr/pubs/unparse-abstract.html</a>.</p>
</div>
</div>
]]></description>
    <pubDate>Thu, 30 Mar 2017 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2017-03-30-fun-with-recursion-schemes.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Constrained Applicatives</title>
    <link>https://doisinkidney.com/posts/2017-03-08-constrained-applicatives.html</link>
    <description><![CDATA[<div class="info">
    Posted on March  8, 2017
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Applicative.html">Applicative</a>
    
</div>

<p>In Haskell restricted monads are monads which can’t contain every type. <code class="sourceCode haskell"><span class="dt">Set</span></code> is a good example. If you look in the documentation for <a href="https://hackage.haskell.org/package/containers-0.5.10.1/docs/Data-Set.html">Data.Set</a> you’ll see several functions which correspond to functions in the Functor/Applicative/Monad typeclass hierarchy:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1">map<span class="ot"> ::</span> <span class="dt">Ord</span> b <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Set</span> a <span class="ot">-&gt;</span> <span class="dt">Set</span> b</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="ot">singleton ::</span> a <span class="ot">-&gt;</span> <span class="dt">Set</span> a</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">foldMap<span class="ot"> ::</span> <span class="dt">Ord</span> b <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Set</span> b) <span class="ot">-&gt;</span> <span class="dt">Set</span> a <span class="ot">-&gt;</span> <span class="dt">Set</span> b <span class="co">-- specialized</span></a></code></pre></div>
<p>Unfortunately, though, <code class="sourceCode haskell"><span class="dt">Set</span></code> can’t conform to <code class="sourceCode haskell"><span class="dt">Functor</span></code>, because the signature of <code class="sourceCode haskell">fmap</code> looks like this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1">fmap<span class="ot"> ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</a></code></pre></div>
<p>It doesn’t have an <code class="sourceCode haskell"><span class="dt">Ord</span></code> constraint.</p>
<p>This is annoying: when using <code class="sourceCode haskell"><span class="dt">Set</span></code>, lots of things have to be imported qualified, and you have to remember the slightly different names of extra functions like <code class="sourceCode haskell">map</code>. More importantly, you’ve lost the ability to write generic code over <code class="sourceCode haskell"><span class="dt">Functor</span></code> or <code class="sourceCode haskell"><span class="dt">Monad</span></code> which will work on <code class="sourceCode haskell"><span class="dt">Set</span></code>.</p>
<p>There are a number of ways to get around this problem. <a href="http://okmij.org/ftp/Haskell/set-monad.html#set-cps">Here</a>, an approach using reflection-reification is explored. These are the types involved:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">SetC</span> a <span class="fu">=</span> </a>
<a class="sourceLine" id="cb3-2" data-line-number="2">       <span class="dt">SetC</span>{<span class="ot">unSetC ::</span> forall r<span class="fu">.</span> <span class="dt">Ord</span> r <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Set</span> r) <span class="ot">-&gt;</span> <span class="dt">Set</span> r}</a>
<a class="sourceLine" id="cb3-3" data-line-number="3"></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="ot">reifySet ::</span> <span class="dt">Ord</span> r <span class="ot">=&gt;</span> <span class="dt">SetC</span> r <span class="ot">-&gt;</span> <span class="dt">Set</span> r</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">reifySet m <span class="fu">=</span> unSetC m singleton</a>
<a class="sourceLine" id="cb3-6" data-line-number="6"></a>
<a class="sourceLine" id="cb3-7" data-line-number="7"><span class="ot">reflectSet ::</span> <span class="dt">Ord</span> r <span class="ot">=&gt;</span> <span class="dt">Set</span> r <span class="ot">-&gt;</span> <span class="dt">SetC</span> r</a>
<a class="sourceLine" id="cb3-8" data-line-number="8">reflectSet s <span class="fu">=</span> <span class="dt">SetC</span> <span class="fu">$</span> \k <span class="ot">-&gt;</span> S.foldr (\x r <span class="ot">-&gt;</span> k x <span class="ot">`union`</span> r) S.empty s</a></code></pre></div>
<p><code class="sourceCode haskell"><span class="dt">SetC</span></code> is just <code class="sourceCode haskell"><span class="dt">Cont</span></code> in disguise. In fact, we can generalize this pattern, using Constraint Kinds:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">FreeT</span> c m a <span class="fu">=</span> </a>
<a class="sourceLine" id="cb4-2" data-line-number="2">       <span class="dt">FreeT</span> {<span class="ot"> runFreeT ::</span> forall r<span class="fu">.</span> c r <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m r) <span class="ot">-&gt;</span> m r}</a>
<a class="sourceLine" id="cb4-3" data-line-number="3"></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="ot">reifySet ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">FreeT</span> <span class="dt">Ord</span> <span class="dt">Set</span> a <span class="ot">-&gt;</span> <span class="dt">Set</span> a</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">reifySet m <span class="fu">=</span> runFreeT m singleton</a>
<a class="sourceLine" id="cb4-6" data-line-number="6"></a>
<a class="sourceLine" id="cb4-7" data-line-number="7"><span class="ot">reflectSet ::</span> <span class="dt">Set</span> r <span class="ot">-&gt;</span> <span class="dt">FreeT</span> <span class="dt">Ord</span> <span class="dt">Set</span> r</a>
<a class="sourceLine" id="cb4-8" data-line-number="8">reflectSet s <span class="fu">=</span> <span class="dt">FreeT</span> <span class="fu">$</span> \k <span class="ot">-&gt;</span> S.foldr (\x r <span class="ot">-&gt;</span> k x <span class="ot">`union`</span> r) S.empty s</a></code></pre></div>
<p><code class="sourceCode haskell"><span class="dt">FreeT</span></code> looks an <em>awful lot</em> like <code class="sourceCode haskell"><span class="dt">ContT</span></code> by now. The type has some other interesting applications, though. For instance, this type:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">type</span> <span class="dt">FM</span> <span class="fu">=</span> <span class="dt">FreeT</span> <span class="dt">Monoid</span> <span class="dt">Identity</span></a></code></pre></div>
<p>Is the free monoid. If we use a transformers-style type synonym, the naming becomes even nicer:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Free</span> c <span class="fu">=</span> <span class="dt">FreeT</span> c <span class="dt">Identity</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="ot">runFree ::</span> c r <span class="ot">=&gt;</span> <span class="dt">Free</span> c a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">runFree xs f <span class="fu">=</span> runIdentity (runFreeT xs (pure <span class="fu">.</span> f))</a>
<a class="sourceLine" id="cb6-5" data-line-number="5"></a>
<a class="sourceLine" id="cb6-6" data-line-number="6"><span class="kw">instance</span> <span class="dt">Foldable</span> (<span class="dt">Free</span> <span class="dt">Monoid</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-7" data-line-number="7">  foldMap <span class="fu">=</span> flip runFree</a></code></pre></div>
<p>Check out <a href="https://hackage.haskell.org/package/free-functors">this package</a> for an implementation of the non-transformer <code class="sourceCode haskell"><span class="dt">Free</span></code>.</p>
<h2 id="different-classes">Different Classes</h2>
<p>This is still unsatisfying, though. Putting annotations around your code feels inelegant. The next solution is to replace the monad class altogether with our own, and turn on <code class="sourceCode haskell"><span class="fu">-</span><span class="dt">XRebindableSyntax</span></code>. There are a few ways to design this new class. One option is to use <a href="http://okmij.org/ftp/Haskell/types.html#restricted-datatypes">multi-parameter type classes</a>. Another solution is with an associated type:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  <span class="kw">type</span> <span class="dt">Suitable</span> f<span class="ot"> a ::</span> <span class="dt">Constraint</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="ot">  fmap ::</span> <span class="dt">Suitable</span> f b <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</a></code></pre></div>
<p>This is similar to the approach taken in the <a href="https://hackage.haskell.org/package/rmonad">rmonad</a> library, except that library doesn’t use constraint kinds (they weren’t available when the library was made), so it has to make do with a <code class="sourceCode haskell"><span class="dt">Suitable</span></code> class. Also, the signature for <code class="sourceCode haskell">fmap</code> in rmonad is:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">fmap<span class="ot"> ::</span> (<span class="dt">Suitable</span> f a, <span class="dt">Suitable</span> f b) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</a></code></pre></div>
<p>I don’t want to constrain <code class="sourceCode haskell">a</code>: I figure if you can get something <em>into</em> your monad, it <em>must</em> be suitable. And I really want to reduce the syntactic overhead of writing extra types next to your functions.</p>
<p>There’s also the <a href="https://hackage.haskell.org/package/supermonad-0.1/docs/Control-Supermonad-Constrained.html">supermonad</a> library out there which is much more general than any of these examples: it supports indexed monads as well as constrained.</p>
<p>Anyway,<code class="sourceCode haskell"><span class="dt">Monad</span></code> is defined similarly to <code class="sourceCode haskell"><span class="dt">Functor</span></code>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Functor</span> m <span class="ot">=&gt;</span> <span class="dt">Monad</span> m <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="ot">  return ::</span> <span class="dt">Suitable</span> m a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> m a</a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="ot">  (&gt;&gt;=) ::</span> <span class="dt">Suitable</span> m b <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b</a></code></pre></div>
<p>Again, I want to minimize the use of <code class="sourceCode haskell"><span class="dt">Suitable</span></code>, so for <code class="sourceCode haskell"><span class="fu">&gt;&gt;=</span></code> there’s only a constraint on <code class="sourceCode haskell">b</code>.</p>
<p>Finally, here’s the <code class="sourceCode haskell"><span class="dt">Set</span></code> instance:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Set</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">    <span class="kw">type</span> <span class="dt">Suitable</span> <span class="dt">Set</span> a <span class="fu">=</span> <span class="dt">Ord</span> a</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">    fmap <span class="fu">=</span> Set.map</a></code></pre></div>
<h2 id="monomorphic">Monomorphic</h2>
<p>With equality constraints, you can actually make <em>monomorphic</em> containers conform to these classes (or, at least, wrappers around them).</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2"></a>
<a class="sourceLine" id="cb11-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Text</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4">  <span class="dt">Text</span><span class="ot"> ::</span> <span class="dt">Text.Text</span> <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="dt">Char</span></a>
<a class="sourceLine" id="cb11-5" data-line-number="5"></a>
<a class="sourceLine" id="cb11-6" data-line-number="6"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Text</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-7" data-line-number="7">  <span class="kw">type</span> <span class="dt">Suitable</span> <span class="dt">Text</span> a <span class="fu">=</span> a <span class="fu">~</span> <span class="dt">Char</span></a>
<a class="sourceLine" id="cb11-8" data-line-number="8">  fmap f (<span class="dt">Text</span> xs) <span class="fu">=</span> <span class="dt">Text</span> (Text.map f xs)</a></code></pre></div>
<p>This pattern can be generalized with some more GADT magic:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Monomorphic</span> xs a b <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">        <span class="dt">Monomorphic</span><span class="ot"> ::</span> (a <span class="fu">~</span> b) <span class="ot">=&gt;</span> xs <span class="ot">-&gt;</span> <span class="dt">Monomorphic</span> xs a b</a>
<a class="sourceLine" id="cb12-3" data-line-number="3"></a>
<a class="sourceLine" id="cb12-4" data-line-number="4"><span class="kw">instance</span> (<span class="dt">MonoFunctor</span> xs, a <span class="fu">~</span> <span class="dt">Element</span> xs) <span class="ot">=&gt;</span> <span class="dt">Functor</span> (<span class="dt">Monomorphic</span> xs a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5">  <span class="kw">type</span> <span class="dt">Suitable</span> (<span class="dt">Monomorphic</span> xs a) b <span class="fu">=</span> a <span class="fu">~</span> b</a>
<a class="sourceLine" id="cb12-6" data-line-number="6">  fmap f (<span class="dt">Monomorphic</span> xs) <span class="fu">=</span> <span class="dt">Monomorphic</span> (omap f xs)</a></code></pre></div>
<p>Where <code class="sourceCode haskell">omap</code> comes from the <a href="https://hackage.haskell.org/package/mono-traversable">mono-traversable</a> package. You could go a little further, to <code class="sourceCode haskell"><span class="dt">Foldable</span></code>:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">instance</span> (<span class="dt">MonoFoldable</span> xs, element <span class="fu">~</span> <span class="dt">Element</span> xs) <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">         <span class="dt">Foldable</span> (<span class="dt">Monomorphic</span> xs element) <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">    foldr f b (<span class="dt">Monomorphic</span> xs) <span class="fu">=</span> ofoldr f b xs</a>
<a class="sourceLine" id="cb13-4" data-line-number="4">    foldMap f (<span class="dt">Monomorphic</span> xs) <span class="fu">=</span> ofoldMap f xs</a>
<a class="sourceLine" id="cb13-5" data-line-number="5">    foldl&#39; f b (<span class="dt">Monomorphic</span> xs) <span class="fu">=</span> ofoldl&#39; f b xs</a>
<a class="sourceLine" id="cb13-6" data-line-number="6">    toList (<span class="dt">Monomorphic</span> xs) <span class="fu">=</span> otoList xs</a>
<a class="sourceLine" id="cb13-7" data-line-number="7">    null (<span class="dt">Monomorphic</span> xs) <span class="fu">=</span> onull xs</a>
<a class="sourceLine" id="cb13-8" data-line-number="8">    length (<span class="dt">Monomorphic</span> xs) <span class="fu">=</span> olength xs</a>
<a class="sourceLine" id="cb13-9" data-line-number="9">    foldr1 f (<span class="dt">Monomorphic</span> xs) <span class="fu">=</span> ofoldr1Ex f xs</a>
<a class="sourceLine" id="cb13-10" data-line-number="10">    elem x (<span class="dt">Monomorphic</span> xs) <span class="fu">=</span> oelem x xs</a>
<a class="sourceLine" id="cb13-11" data-line-number="11">    maximum (<span class="dt">Monomorphic</span> xs) <span class="fu">=</span> maximumEx xs</a>
<a class="sourceLine" id="cb13-12" data-line-number="12">    minimum (<span class="dt">Monomorphic</span> xs) <span class="fu">=</span> minimumEx xs</a>
<a class="sourceLine" id="cb13-13" data-line-number="13">    sum (<span class="dt">Monomorphic</span> xs) <span class="fu">=</span> osum xs</a>
<a class="sourceLine" id="cb13-14" data-line-number="14">    product (<span class="dt">Monomorphic</span> xs) <span class="fu">=</span> oproduct xs</a></code></pre></div>
<h2 id="back-to-normal">Back to normal</h2>
<p>Changing the <code class="sourceCode haskell"><span class="dt">FreeT</span></code> type above a little, we can go back to normal functors and monads, and write more general reify and reflect functions:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">FreeT</span> m a <span class="fu">=</span> </a>
<a class="sourceLine" id="cb14-2" data-line-number="2">       <span class="dt">FreeT</span> {<span class="ot"> runFreeT ::</span> forall r<span class="fu">.</span> <span class="dt">Suitable</span> m r <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m r) <span class="ot">-&gt;</span> m r}</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">       </a>
<a class="sourceLine" id="cb14-4" data-line-number="4"><span class="ot">reify ::</span> (<span class="dt">Monad</span> m, <span class="dt">Suitable</span> m a) <span class="ot">=&gt;</span> <span class="dt">FreeT</span> m a <span class="ot">-&gt;</span> m a</a>
<a class="sourceLine" id="cb14-5" data-line-number="5">reify <span class="fu">=</span> flip runFreeT return</a>
<a class="sourceLine" id="cb14-6" data-line-number="6"></a>
<a class="sourceLine" id="cb14-7" data-line-number="7"><span class="ot">reflect ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> <span class="dt">FreeT</span> m a</a>
<a class="sourceLine" id="cb14-8" data-line-number="8">reflect x <span class="fu">=</span> <span class="dt">FreeT</span> (x <span class="fu">&gt;&gt;=</span>)</a></code></pre></div>
<p>So now our types, when wrapped, can conform to the Prelude’s <code class="sourceCode haskell"><span class="dt">Functor</span></code>. It would be nice if this type could be written like so:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="ot">reify ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">FreeT</span> (<span class="dt">Suitable</span> m) m a <span class="ot">-&gt;</span> m a</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">reify <span class="fu">=</span> flip runFreeT return</a>
<a class="sourceLine" id="cb15-3" data-line-number="3"></a>
<a class="sourceLine" id="cb15-4" data-line-number="4"><span class="ot">reflect ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> <span class="dt">FreeT</span> (<span class="dt">Suitable</span> m) m a</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">reflect x <span class="fu">=</span> <span class="dt">FreeT</span> (x <span class="fu">&gt;&gt;=</span>)</a></code></pre></div>
<p>But unfortunately type families cannot be partially applied.</p>
<h2 id="applicatives">Applicatives</h2>
<p>The classes above aren’t very modern: they’re missing applicative. This one is tricky:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Applicative</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2"><span class="ot">  pure ::</span> <span class="dt">Suitable</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb16-3" data-line-number="3"><span class="ot">  (&lt;*&gt;) ::</span> <span class="dt">Suitable</span> f b <span class="ot">=&gt;</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</a></code></pre></div>
<p>The issue is <code class="sourceCode haskell">f (a <span class="ot">-&gt;</span> b)</code>. There’s no <em>way</em> you’re getting some type like that into <code class="sourceCode haskell"><span class="dt">Set</span></code>. This means that <code class="sourceCode haskell"><span class="fu">&lt;*&gt;</span></code> is effectively useless. No problem, you think: define <code class="sourceCode haskell">liftA2</code> instead:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Applicative</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2"><span class="ot">  pure ::</span> <span class="dt">Suitable</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb17-3" data-line-number="3"><span class="ot">  liftA2 ::</span> <span class="dt">Suitable</span> f c <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f c</a>
<a class="sourceLine" id="cb17-4" data-line-number="4"></a>
<a class="sourceLine" id="cb17-5" data-line-number="5"><span class="ot">(&lt;*&gt;) ::</span> (<span class="dt">Applicative</span> f, <span class="dt">Suitable</span> f b) <span class="ot">=&gt;</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</a>
<a class="sourceLine" id="cb17-6" data-line-number="6">(<span class="fu">&lt;*&gt;</span>) <span class="fu">=</span> liftA2 (<span class="fu">$</span>)</a></code></pre></div>
<p>Great! Now we can use it with set. However, there’s no way (that I can see) to define the other lift functions: <code class="sourceCode haskell">liftA3</code>, etc. Of course, if <code class="sourceCode haskell"><span class="fu">&gt;&gt;=</span></code> is available, it’s as simple as:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1">liftA3 f xs ys zs <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2">  x <span class="ot">&lt;-</span> xs</a>
<a class="sourceLine" id="cb18-3" data-line-number="3">  y <span class="ot">&lt;-</span> ys</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">  z <span class="ot">&lt;-</span> zs</a>
<a class="sourceLine" id="cb18-5" data-line-number="5">  pure (f x y z)</a></code></pre></div>
<p>But now we can’t define it for non-monadic applicatives (square matrices, ZipLists, etc.). This also forces us to use <code class="sourceCode haskell"><span class="fu">&gt;&gt;=</span></code> when <code class="sourceCode haskell"><span class="fu">&lt;*&gt;</span></code> <a href="https://simonmar.github.io/posts/2015-10-20-Fun-With-Haxl-1.html">may have been more efficient</a>.</p>
<p>The functions we’re interested in defining look like this:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="ot">liftA2 ::</span> <span class="dt">Suitable</span> f c <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f c</a>
<a class="sourceLine" id="cb19-2" data-line-number="2"><span class="ot">liftA3 ::</span> <span class="dt">Suitable</span> f d <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f c <span class="ot">-&gt;</span> f d</a>
<a class="sourceLine" id="cb19-3" data-line-number="3"><span class="ot">liftA4 ::</span> <span class="dt">Suitable</span> f e <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> d <span class="ot">-&gt;</span> e) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f c <span class="ot">-&gt;</span> f d <span class="ot">-&gt;</span> f e</a></code></pre></div>
<p>There’s a clear pattern, but no obvious way to abstract over it. Type-level shenanigans to the rescue!</p>
<p>The pattern might be expressed like this:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="ot">liftA ::</span> <span class="dt">Func</span> args <span class="ot">-&gt;</span> <span class="dt">Func</span> lifted args</a></code></pre></div>
<p>We can store these types as heterogeneous lists:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:-</span></a>
<a class="sourceLine" id="cb21-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Vect</span> xs <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-3" data-line-number="3">  <span class="dt">Nil</span><span class="ot">  ::</span> <span class="dt">Vect</span> <span class="ch">&#39;[]</span></a>
<a class="sourceLine" id="cb21-4" data-line-number="4"><span class="ot">  (:-) ::</span> x <span class="ot">-&gt;</span> <span class="dt">Vect</span> xs <span class="ot">-&gt;</span> <span class="dt">Vect</span> (x <span class="ch">&#39;: xs)</span></a>
<a class="sourceLine" id="cb21-5" data-line-number="5"></a>
<a class="sourceLine" id="cb21-6" data-line-number="6"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:*</span></a>
<a class="sourceLine" id="cb21-7" data-line-number="7"><span class="kw">data</span> <span class="dt">AppVect</span> f xs <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-8" data-line-number="8">  <span class="dt">NilA</span><span class="ot"> ::</span> <span class="dt">AppVect</span> f <span class="ch">&#39;[]</span></a>
<a class="sourceLine" id="cb21-9" data-line-number="9"><span class="ot">  (:*) ::</span> f x <span class="ot">-&gt;</span> <span class="dt">AppVect</span> f xs <span class="ot">-&gt;</span> <span class="dt">AppVect</span> f (x <span class="ch">&#39;: xs)</span></a></code></pre></div>
<p>And <code class="sourceCode haskell">liftA</code> can be represented like this:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1">liftA</a>
<a class="sourceLine" id="cb22-2" data-line-number="2"><span class="ot">    ::</span> <span class="dt">Suitable</span> f b</a>
<a class="sourceLine" id="cb22-3" data-line-number="3">    <span class="ot">=&gt;</span> (<span class="dt">Vect</span> xs <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">AppVect</span> f xs <span class="ot">-&gt;</span> f b</a>
<a class="sourceLine" id="cb22-4" data-line-number="4"></a>
<a class="sourceLine" id="cb22-5" data-line-number="5">liftA2</a>
<a class="sourceLine" id="cb22-6" data-line-number="6"><span class="ot">    ::</span> <span class="dt">Suitable</span> f c</a>
<a class="sourceLine" id="cb22-7" data-line-number="7">    <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f c</a>
<a class="sourceLine" id="cb22-8" data-line-number="8">liftA2 f xs ys <span class="fu">=</span></a>
<a class="sourceLine" id="cb22-9" data-line-number="9">    liftA</a>
<a class="sourceLine" id="cb22-10" data-line-number="10">        (\(x <span class="fu">:-</span> y <span class="fu">:-</span> <span class="dt">Nil</span>) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb22-11" data-line-number="11">              f x y)</a>
<a class="sourceLine" id="cb22-12" data-line-number="12">        (xs <span class="fu">:*</span> ys <span class="fu">:*</span> <span class="dt">NilA</span>)</a>
<a class="sourceLine" id="cb22-13" data-line-number="13"></a>
<a class="sourceLine" id="cb22-14" data-line-number="14">liftA3</a>
<a class="sourceLine" id="cb22-15" data-line-number="15"><span class="ot">    ::</span> <span class="dt">Suitable</span> f d</a>
<a class="sourceLine" id="cb22-16" data-line-number="16">    <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f c <span class="ot">-&gt;</span> f d</a>
<a class="sourceLine" id="cb22-17" data-line-number="17">liftA3 f xs ys zs <span class="fu">=</span></a>
<a class="sourceLine" id="cb22-18" data-line-number="18">    liftA</a>
<a class="sourceLine" id="cb22-19" data-line-number="19">        (\(x <span class="fu">:-</span> y <span class="fu">:-</span> z <span class="fu">:-</span> <span class="dt">Nil</span>) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb22-20" data-line-number="20">              f x y z)</a>
<a class="sourceLine" id="cb22-21" data-line-number="21">        (xs <span class="fu">:*</span> ys <span class="fu">:*</span> zs <span class="fu">:*</span> <span class="dt">NilA</span>)</a></code></pre></div>
<p>Cool! For unrestricted applicatives, we can define <code class="sourceCode haskell">liftA</code> in terms of <code class="sourceCode haskell"><span class="fu">&lt;*&gt;</span></code>:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="ot">liftAP ::</span> (<span class="dt">Prelude.Applicative</span> f) </a>
<a class="sourceLine" id="cb23-2" data-line-number="2">       <span class="ot">=&gt;</span> (<span class="dt">Vect</span> xs <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (<span class="dt">AppVect</span> f xs <span class="ot">-&gt;</span> f b)</a>
<a class="sourceLine" id="cb23-3" data-line-number="3">liftAP f <span class="dt">NilA</span> <span class="fu">=</span> Prelude.pure (f <span class="dt">Nil</span>)</a>
<a class="sourceLine" id="cb23-4" data-line-number="4">liftAP f (x <span class="fu">:*</span> <span class="dt">NilA</span>) </a>
<a class="sourceLine" id="cb23-5" data-line-number="5">  <span class="fu">=</span> Prelude.fmap (f <span class="fu">.</span> (<span class="fu">:-</span><span class="dt">Nil</span>)) x</a>
<a class="sourceLine" id="cb23-6" data-line-number="6">liftAP f (x <span class="fu">:*</span> xs) </a>
<a class="sourceLine" id="cb23-7" data-line-number="7">  <span class="fu">=</span>  ((f <span class="fu">.</span>) <span class="fu">.</span> (<span class="fu">:-</span>)) <span class="fu">Prelude.&lt;$&gt;</span> x <span class="fu">Prelude.&lt;*&gt;</span> liftAP id xs</a></code></pre></div>
<p>And for types with a monad instance, we can define it in terms of <code class="sourceCode haskell"><span class="fu">&gt;&gt;=</span></code>:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="ot">liftAM ::</span> (<span class="dt">Monad</span> f, <span class="dt">Suitable</span> f b) </a>
<a class="sourceLine" id="cb24-2" data-line-number="2">       <span class="ot">=&gt;</span> (<span class="dt">Vect</span> xs <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (<span class="dt">AppVect</span> f xs <span class="ot">-&gt;</span> f b)</a>
<a class="sourceLine" id="cb24-3" data-line-number="3">liftAM f <span class="dt">NilA</span> <span class="fu">=</span> pure (f <span class="dt">Nil</span>)</a>
<a class="sourceLine" id="cb24-4" data-line-number="4">liftAM f (x <span class="fu">:*</span> <span class="dt">NilA</span>) <span class="fu">=</span> fmap (f <span class="fu">.</span> (<span class="fu">:-</span><span class="dt">Nil</span>)) x</a>
<a class="sourceLine" id="cb24-5" data-line-number="5">liftAM f (x <span class="fu">:*</span> xs) <span class="fu">=</span> x <span class="fu">&gt;&gt;=</span> \y <span class="ot">-&gt;</span> liftAM (f <span class="fu">.</span> (y<span class="fu">:-</span>)) xs</a></code></pre></div>
<h2 id="efficiency">Efficiency</h2>
<p>This approach is <em>really</em> slow. Every function wraps up its arguments in a <code class="sourceCode haskell"><span class="dt">Vect</span></code>, and it’s just generally awful.</p>
<p>What about <em>not</em> wrapping up the function? Type families can help here:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">FunType</span> (<span class="ot">xs ::</span> [<span class="fu">*</span>]) (<span class="ot">y ::</span> <span class="fu">*</span>)<span class="ot"> ::</span> <span class="fu">*</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-2" data-line-number="2">  <span class="dt">FunType</span> <span class="ch">&#39;[] y = y</span></a>
<a class="sourceLine" id="cb25-3" data-line-number="3">  <span class="dt">FunType</span> (x <span class="ch">&#39;: xs) y = x -&gt; FunType xs y</span></a></code></pre></div>
<p>It gets really difficult to define <code class="sourceCode haskell">liftA</code> using <code class="sourceCode haskell"><span class="fu">&lt;*&gt;</span></code> now, though. <code class="sourceCode haskell">liftAM</code>, on the other hand, is a breeze:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="ot">liftAM ::</span> <span class="dt">Monad</span> f <span class="ot">=&gt;</span> <span class="dt">FunType</span> xs a <span class="ot">-&gt;</span> <span class="dt">AppVect</span> f xs <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb26-2" data-line-number="2">liftAM f <span class="dt">Nil</span> <span class="fu">=</span> pure f</a>
<a class="sourceLine" id="cb26-3" data-line-number="3">liftAM f (x <span class="fu">:&lt;</span> xs) <span class="fu">=</span> x <span class="fu">&gt;&gt;=</span> \y <span class="ot">-&gt;</span> liftAM (f y) xs</a></code></pre></div>
<p>And no vector constructors on the right of the bind!</p>
<p>Still, no decent definition using <code class="sourceCode haskell"><span class="fu">&lt;*&gt;</span></code>. The problem is that we’re using a cons-list to represent a function’s arguments, but <code class="sourceCode haskell"><span class="fu">&lt;*&gt;</span></code> is left-associative, so it builds up arguments as a snoc list. Lets try using a snoc-list as the type family:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="kw">infixl</span> <span class="dv">5</span> <span class="fu">:&gt;</span></a>
<a class="sourceLine" id="cb27-2" data-line-number="2"><span class="kw">data</span> <span class="dt">AppVect</span> f xs <span class="kw">where</span></a>
<a class="sourceLine" id="cb27-3" data-line-number="3">  <span class="dt">Nil</span><span class="ot"> ::</span> <span class="dt">AppVect</span> f <span class="ch">&#39;[]</span></a>
<a class="sourceLine" id="cb27-4" data-line-number="4"><span class="ot">  (:&gt;) ::</span> <span class="dt">AppVect</span> f xs <span class="ot">-&gt;</span> f x <span class="ot">-&gt;</span> <span class="dt">AppVect</span> f (x <span class="ch">&#39;: xs)</span></a>
<a class="sourceLine" id="cb27-5" data-line-number="5"></a>
<a class="sourceLine" id="cb27-6" data-line-number="6"><span class="kw">type</span> family <span class="dt">FunType</span> (<span class="ot">xs ::</span> [<span class="fu">*</span>]) (<span class="ot">y ::</span> <span class="fu">*</span>)<span class="ot"> ::</span> <span class="fu">*</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb27-7" data-line-number="7">  <span class="dt">FunType</span> <span class="ch">&#39;[] y = y</span></a>
<a class="sourceLine" id="cb27-8" data-line-number="8">  <span class="dt">FunType</span> (x <span class="ch">&#39;: xs) y = FunType xs (x -&gt; y)</span></a>
<a class="sourceLine" id="cb27-9" data-line-number="9"></a>
<a class="sourceLine" id="cb27-10" data-line-number="10">liftA</a>
<a class="sourceLine" id="cb27-11" data-line-number="11"><span class="ot">    ::</span> <span class="dt">Suitable</span> f a</a>
<a class="sourceLine" id="cb27-12" data-line-number="12">    <span class="ot">=&gt;</span> <span class="dt">FunType</span> xs a <span class="ot">-&gt;</span> <span class="dt">AppVect</span> f xs <span class="ot">-&gt;</span> f a</a></code></pre></div>
<p><code class="sourceCode haskell">liftAP</code> now gets a natural definition:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1"><span class="ot">liftAP ::</span> <span class="dt">Prelude.Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">FunType</span> xs a <span class="ot">-&gt;</span> <span class="dt">AppVect</span> f xs <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb28-2" data-line-number="2">liftAP f <span class="dt">Nil</span> <span class="fu">=</span> Prelude.pure f</a>
<a class="sourceLine" id="cb28-3" data-line-number="3">liftAP f (<span class="dt">Nil</span> <span class="fu">:&gt;</span> xs) <span class="fu">=</span> Prelude.fmap f xs</a>
<a class="sourceLine" id="cb28-4" data-line-number="4">liftAP f (ys <span class="fu">:&gt;</span> xs) <span class="fu">=</span> liftAP f ys <span class="fu">Prelude.&lt;*&gt;</span> xs</a></code></pre></div>
<p>But what about <code class="sourceCode haskell">liftAM</code>? It’s much more difficult, fundamentally because <code class="sourceCode haskell"><span class="fu">&gt;&gt;=</span></code> builds up arguments as a cons-list. To convert between the two efficiently, we need to use the trick for reversing lists efficiently: build up the reversed list as you go.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" data-line-number="1"><span class="ot">liftAM ::</span> (<span class="dt">Monad</span> f, <span class="dt">Suitable</span> f a) <span class="ot">=&gt;</span> <span class="dt">FunType</span> xs a <span class="ot">-&gt;</span> <span class="dt">AppVect</span> f xs <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb29-2" data-line-number="2">liftAM <span class="fu">=</span> go pure <span class="kw">where</span></a>
<a class="sourceLine" id="cb29-3" data-line-number="3"><span class="ot">  go ::</span> (<span class="dt">Suitable</span> f b, <span class="dt">Monad</span> f) </a>
<a class="sourceLine" id="cb29-4" data-line-number="4">     <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> <span class="dt">FunType</span> xs a <span class="ot">-&gt;</span> <span class="dt">AppVect</span> f xs <span class="ot">-&gt;</span> f b</a>
<a class="sourceLine" id="cb29-5" data-line-number="5">  go f g <span class="dt">Nil</span> <span class="fu">=</span> f g</a>
<a class="sourceLine" id="cb29-6" data-line-number="6">  go f g (xs <span class="fu">:&gt;</span> x) <span class="fu">=</span> go (\c <span class="ot">-&gt;</span> x <span class="fu">&gt;&gt;=</span> f <span class="fu">.</span> c) g xs</a></code></pre></div>
<p>Using these definitions, we can make <code class="sourceCode haskell"><span class="dt">Set</span></code>, <code class="sourceCode haskell"><span class="dt">Text</span></code>, and all the rest of them applicatives, while preserving the applicative operations. Also, from my preliminary testing, there seems to be <em>no</em> overhead in using these new definitions for <code class="sourceCode haskell"><span class="fu">&lt;*&gt;</span></code>.</p>
<h2 id="normalized-embedding">Normalized Embedding</h2>
<p>In <span class="citation" data-cites="sculthorpe_constrained-monad_2013">Sculthorpe et al. (<a href="#ref-sculthorpe_constrained-monad_2013">2013</a>)</span>, there’s discussion of this type:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="kw">data</span> <span class="dt">NM</span><span class="ot"> ::</span> (<span class="fu">*</span> <span class="ot">-&gt;</span> <span class="dt">Constraint</span>) <span class="ot">-&gt;</span> (<span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-2" data-line-number="2">  <span class="dt">Return</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">NM</span> c t a</a>
<a class="sourceLine" id="cb30-3" data-line-number="3">  <span class="dt">Bind</span><span class="ot"> ::</span> c x <span class="ot">=&gt;</span> t x <span class="ot">-&gt;</span> (x <span class="ot">-&gt;</span> <span class="dt">NM</span> c t a) <span class="ot">-&gt;</span> <span class="dt">NM</span> c t a</a></code></pre></div>
<p>This type allows constrained monads to become normal monads. It can be used for the same purpose as the <code class="sourceCode haskell"><span class="dt">FreeT</span></code> type from above. In the paper, the free type is called <code class="sourceCode haskell"><span class="dt">RCodT</span></code>.</p>
<p>One way to look at the type is as a concrete representation of the monad class, with each method being a constructor.</p>
<p>You might wonder if there are similar constructs for functor and applicative. Functor is simple:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" data-line-number="1"><span class="kw">data</span> <span class="dt">NF</span><span class="ot"> ::</span> (<span class="fu">*</span> <span class="ot">-&gt;</span> <span class="dt">Constraint</span>) <span class="ot">-&gt;</span> (<span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb31-2" data-line-number="2">  <span class="dt">FMap</span><span class="ot"> ::</span> c x <span class="ot">=&gt;</span> (x <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> t x <span class="ot">-&gt;</span> <span class="dt">NF</span> c t a</a></code></pre></div>
<p>Again, this can conform to functor (and <em>only</em> functor), and can be interpreted when the final type is <code class="sourceCode haskell"><span class="dt">Suitable</span></code>.</p>
<p>Like above, it has a continuation version, <a href="https://hackage.haskell.org/package/kan-extensions-5.0.1/docs/Data-Functor-Yoneda.html">Yoneda</a>.</p>
<p>For applicatives, though, the situation is different. In the paper, they weren’t able to define a transformer for applicatives that could be interpreted in some restricted applicative. I needed one because I wanted to use <code class="sourceCode haskell"><span class="fu">-</span><span class="dt">XApplicativeDo</span></code> notation: the desugaring uses <code class="sourceCode haskell"><span class="fu">&lt;*&gt;</span></code>, not the <code class="sourceCode haskell">liftAn</code> functions, so I wanted to construct a free applicative using <code class="sourceCode haskell"><span class="fu">&lt;*&gt;</span></code>, and run it using the lift functions. What I managed to cobble to gether doesn’t <em>really</em> solve the problem, but it works for <code>-XApplicativeDo</code>!</p>
<p>The key with a lot of this was realizing that <code class="sourceCode haskell"><span class="fu">&lt;*&gt;</span></code> is <em>snoc</em>, not cons. Using a <a href="https://ro-che.info/articles/2013-03-31-flavours-of-free-applicative-functors">free applicative</a>:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Free</span> f a <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-2" data-line-number="2">  <span class="dt">Pure</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Free</span> f a</a>
<a class="sourceLine" id="cb32-3" data-line-number="3">  <span class="dt">Ap</span><span class="ot"> ::</span> <span class="dt">Free</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Free</span> f b</a>
<a class="sourceLine" id="cb32-4" data-line-number="4"></a>
<a class="sourceLine" id="cb32-5" data-line-number="5"><span class="kw">instance</span> <span class="dt">Prelude.Functor</span> (<span class="dt">Free</span> f) <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-6" data-line-number="6">  fmap f (<span class="dt">Pure</span> a) <span class="fu">=</span> <span class="dt">Pure</span> (f a)</a>
<a class="sourceLine" id="cb32-7" data-line-number="7">  fmap f (<span class="dt">Ap</span> x y) <span class="fu">=</span> <span class="dt">Ap</span> ((f <span class="fu">.</span>) <span class="fu">Prelude.&lt;$&gt;</span> x) y</a>
<a class="sourceLine" id="cb32-8" data-line-number="8"></a>
<a class="sourceLine" id="cb32-9" data-line-number="9"><span class="kw">instance</span> <span class="dt">Prelude.Applicative</span> (<span class="dt">Free</span> f) <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-10" data-line-number="10">  pure <span class="fu">=</span> <span class="dt">Pure</span></a>
<a class="sourceLine" id="cb32-11" data-line-number="11">  <span class="dt">Pure</span> f <span class="fu">&lt;*&gt;</span> y <span class="fu">=</span> Prelude.fmap f y</a>
<a class="sourceLine" id="cb32-12" data-line-number="12">  <span class="dt">Ap</span> x y <span class="fu">&lt;*&gt;</span> z <span class="fu">=</span> <span class="dt">Ap</span> (flip <span class="fu">Prelude.&lt;$&gt;</span> x <span class="fu">Prelude.&lt;*&gt;</span> z) y</a></code></pre></div>
<p>This type can conform to <code class="sourceCode haskell"><span class="dt">Applicative</span></code> and <code class="sourceCode haskell"><span class="dt">Functor</span></code> no problem. And all it needs to turn back into a constrained applicative is for the outer type to be suitable:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" data-line-number="1"><span class="ot">lift ::</span> f a <span class="ot">-&gt;</span> <span class="dt">Free</span> f a</a>
<a class="sourceLine" id="cb33-2" data-line-number="2">lift <span class="fu">=</span> <span class="dt">Ap</span> (<span class="dt">Pure</span> id)</a>
<a class="sourceLine" id="cb33-3" data-line-number="3"></a>
<a class="sourceLine" id="cb33-4" data-line-number="4">lower</a>
<a class="sourceLine" id="cb33-5" data-line-number="5"><span class="ot">    ::</span> forall f a c<span class="fu">.</span></a>
<a class="sourceLine" id="cb33-6" data-line-number="6">       <span class="dt">Free</span> f a</a>
<a class="sourceLine" id="cb33-7" data-line-number="7">    <span class="ot">-&gt;</span> (forall xs<span class="fu">.</span> <span class="dt">FunType</span> xs a <span class="ot">-&gt;</span> <span class="dt">AppVect</span> f xs <span class="ot">-&gt;</span> f c)</a>
<a class="sourceLine" id="cb33-8" data-line-number="8">    <span class="ot">-&gt;</span> f c</a>
<a class="sourceLine" id="cb33-9" data-line-number="9">lower (<span class="dt">Pure</span> x) f <span class="fu">=</span> f x <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb33-10" data-line-number="10">lower (<span class="dt">Ap</span> fs<span class="ot"> x ::</span> <span class="dt">Free</span> f a) f <span class="fu">=</span></a>
<a class="sourceLine" id="cb33-11" data-line-number="11">    lower fs (\ft av <span class="ot">-&gt;</span> f ft (av <span class="fu">:&gt;</span> x))</a>
<a class="sourceLine" id="cb33-12" data-line-number="12"></a>
<a class="sourceLine" id="cb33-13" data-line-number="13">lowerConstrained</a>
<a class="sourceLine" id="cb33-14" data-line-number="14"><span class="ot">    ::</span> (<span class="dt">Constrained.Applicative</span> f, <span class="dt">Suitable</span> f a)</a>
<a class="sourceLine" id="cb33-15" data-line-number="15">    <span class="ot">=&gt;</span> <span class="dt">Free</span> f a <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb33-16" data-line-number="16">lowerConstrained x <span class="fu">=</span> lower x liftA</a></code></pre></div>
<p>There’s probably a more efficient way to encode it, though.</p>
<div id="refs" class="references">
<div id="ref-sculthorpe_constrained-monad_2013">
<p>Sculthorpe, Neil, Jan Bracker, George Giorgidze, and Andy Gill. 2013. “The Constrained-monad Problem.” In <em>Proceedings of the 18th ACM SIGPLAN International Conference on Functional Programming</em>, 287–298. ICFP ’13. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/2500365.2500602">10.1145/2500365.2500602</a>. <a href="http://ku-fpg.github.io/files/Sculthorpe-13-ConstrainedMonad.pdf" class="uri">http://ku-fpg.github.io/files/Sculthorpe-13-ConstrainedMonad.pdf</a>.</p>
</div>
</div>
]]></description>
    <pubDate>Wed, 08 Mar 2017 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2017-03-08-constrained-applicatives.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Semirings</title>
    <link>https://doisinkidney.com/posts/2016-11-17-semirings-lhs.html</link>
    <description><![CDATA[<div class="info">
    Posted on November 17, 2016
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Semirings.html">Semirings</a>
    
</div>

<div class="sourceCode" id="cb1"><pre class="sourceCode haskell literate hidden_source"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving, TypeFamilies #-}</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="ot">{-# LANGUAGE DeriveFunctor, DeriveFoldable, DeriveTraversable #-}</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="ot">{-# LANGUAGE PatternSynonyms, ViewPatterns, LambdaCase #-}</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="ot">{-# LANGUAGE RankNTypes, FlexibleInstances, FlexibleContexts #-}</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="ot">{-# LANGUAGE OverloadedStrings, OverloadedLists, MonadComprehensions #-}</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="kw">module</span> <span class="dt">Semirings</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"></a>
<a class="sourceLine" id="cb1-9" data-line-number="9"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map.Strict</span> <span class="kw">as</span> <span class="dt">Map</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10"><span class="kw">import</span>           <span class="dt">Data.Map.Strict</span>      (<span class="dt">Map</span>)</a>
<a class="sourceLine" id="cb1-11" data-line-number="11"><span class="kw">import</span>           <span class="dt">Data.Monoid</span>  <span class="kw">hiding</span>  (<span class="dt">Endo</span>(..))</a>
<a class="sourceLine" id="cb1-12" data-line-number="12"><span class="kw">import</span>           <span class="dt">Data.Foldable</span> <span class="kw">hiding</span> (toList)</a>
<a class="sourceLine" id="cb1-13" data-line-number="13"><span class="kw">import</span>           <span class="dt">Control.Applicative</span></a>
<a class="sourceLine" id="cb1-14" data-line-number="14"><span class="kw">import</span>           <span class="dt">Control.Arrow</span>        (first)</a>
<a class="sourceLine" id="cb1-15" data-line-number="15"><span class="kw">import</span>           <span class="dt">Control.Monad.Cont</span></a>
<a class="sourceLine" id="cb1-16" data-line-number="16"><span class="kw">import</span>           <span class="dt">Data.Functor.Identity</span></a>
<a class="sourceLine" id="cb1-17" data-line-number="17"><span class="kw">import</span>           <span class="dt">GHC.Exts</span></a>
<a class="sourceLine" id="cb1-18" data-line-number="18"><span class="kw">import</span>           <span class="dt">Data.List</span> <span class="kw">hiding</span>     (insert)</a>
<a class="sourceLine" id="cb1-19" data-line-number="19"><span class="kw">import</span>           <span class="dt">Data.Maybe</span>           (mapMaybe)</a></code></pre></div>
<p>I’ve been playing around a lot with semirings recently. A semiring is anything with addition, multiplication, zero and one. You can represent that in Haskell as:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Semiring</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="ot">  zero ::</span> a</a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="ot">  one  ::</span> a</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">  <span class="kw">infixl</span> <span class="dv">7</span> <span class="fu">&lt;.&gt;</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="ot">  (&lt;.&gt;) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">  <span class="kw">infixl</span> <span class="dv">6</span> <span class="fu">&lt;+&gt;</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7"><span class="ot">  (&lt;+&gt;) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a></code></pre></div>
<p>It’s kind of like a combination of two <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Monoid.html">monoids</a>. It has the normal monoid laws:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1">x <span class="fu">&lt;+&gt;</span> (y <span class="fu">&lt;+&gt;</span> z) <span class="fu">=</span> (x <span class="fu">&lt;+&gt;</span> y) <span class="fu">&lt;+&gt;</span> z</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">x <span class="fu">&lt;.&gt;</span> (y <span class="fu">&lt;.&gt;</span> z) <span class="fu">=</span> (x <span class="fu">&lt;.&gt;</span> y) <span class="fu">&lt;.&gt;</span> z</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">x <span class="fu">&lt;+&gt;</span> zero <span class="fu">=</span> zero <span class="fu">&lt;+&gt;</span> x <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">x <span class="fu">&lt;.&gt;</span> one  <span class="fu">=</span> one  <span class="fu">&lt;.&gt;</span> x <span class="fu">=</span> x</a></code></pre></div>
<p>And a few extra:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">x <span class="fu">&lt;+&gt;</span> y <span class="fu">=</span> y <span class="fu">&lt;+&gt;</span> x</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">x <span class="fu">&lt;.&gt;</span> (y <span class="fu">&lt;+&gt;</span> z) <span class="fu">=</span> (x <span class="fu">&lt;.&gt;</span> y) <span class="fu">&lt;+&gt;</span> (x <span class="fu">&lt;.&gt;</span> z)</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">(x <span class="fu">&lt;+&gt;</span> y) <span class="fu">&lt;.&gt;</span> z <span class="fu">=</span> (x <span class="fu">&lt;.&gt;</span> z) <span class="fu">&lt;+&gt;</span> (y <span class="fu">&lt;.&gt;</span> z)</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">zero <span class="fu">&lt;.&gt;</span> a <span class="fu">=</span> a <span class="fu">&lt;.&gt;</span> zero <span class="fu">=</span> zero</a></code></pre></div>
<p>I should note that what I’m calling a semiring here is often called a <a href="https://ncatlab.org/nlab/show/rig">rig</a>. I actually prefer the name “rig”: a rig is a ring without <strong>n</strong>egatives (cute!); whereas a <em>semi</em>ring is a rig without neutral elements, which mirrors the definition of a semigroup. The nomenclature in this area is a bit of a mess, though, so I went with the more commonly-used name for the sake of googleability.</p>
<p>At first glance, it looks quite numeric. Indeed, <a href="https://pursuit.purescript.org/packages/purescript-prelude/1.1.0/docs/Data.Semiring">PureScript</a> uses it as the basis for its numeric hierarchy. (In my experience so far, it’s nicer to use than Haskell’s <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Num"><code class="sourceCode haskell"><span class="dt">Num</span></code></a>)</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Semiring</span> <span class="dt">Integer</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">  zero <span class="fu">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  one  <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">  (<span class="fu">&lt;+&gt;</span>) <span class="fu">=</span> (<span class="fu">+</span>)</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">  (<span class="fu">&lt;.&gt;</span>) <span class="fu">=</span> (<span class="fu">*</span>)</a>
<a class="sourceLine" id="cb5-6" data-line-number="6"></a>
<a class="sourceLine" id="cb5-7" data-line-number="7"><span class="kw">instance</span> <span class="dt">Semiring</span> <span class="dt">Double</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8">  zero <span class="fu">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb5-9" data-line-number="9">  one  <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb5-10" data-line-number="10">  (<span class="fu">&lt;+&gt;</span>) <span class="fu">=</span> (<span class="fu">+</span>)</a>
<a class="sourceLine" id="cb5-11" data-line-number="11">  (<span class="fu">&lt;.&gt;</span>) <span class="fu">=</span> (<span class="fu">*</span>)</a></code></pre></div>
<p>However, there are far more types which can form a valid <code class="sourceCode haskell"><span class="dt">Semiring</span></code> instance than can form a valid <code class="sourceCode haskell"><span class="dt">Num</span></code> instance: the <code class="sourceCode haskell">negate</code> method, for example, excludes types representing the natural numbers:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">ChurchNat</span> <span class="fu">=</span> <span class="dt">ChurchNat</span> </a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  {<span class="ot"> runNat ::</span> forall a<span class="fu">.</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a}</a>
<a class="sourceLine" id="cb6-3" data-line-number="3"> </a>
<a class="sourceLine" id="cb6-4" data-line-number="4"><span class="kw">data</span> <span class="dt">Nat</span> <span class="fu">=</span> <span class="dt">Zero</span> <span class="fu">|</span> <span class="dt">Succ</span> <span class="dt">Nat</span></a></code></pre></div>
<p>These form perfectly sensible semirings, though:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Semiring</span> <span class="dt">ChurchNat</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  zero <span class="fu">=</span> <span class="dt">ChurchNat</span> (const id)</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  one <span class="fu">=</span> <span class="dt">ChurchNat</span> (<span class="fu">$</span>)</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">  <span class="dt">ChurchNat</span> n <span class="fu">&lt;+&gt;</span> <span class="dt">ChurchNat</span> m <span class="fu">=</span> <span class="dt">ChurchNat</span> (\f <span class="ot">-&gt;</span> n f <span class="fu">.</span> m f)</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">  <span class="dt">ChurchNat</span> n <span class="fu">&lt;.&gt;</span> <span class="dt">ChurchNat</span> m <span class="fu">=</span> <span class="dt">ChurchNat</span> (n <span class="fu">.</span> m)</a>
<a class="sourceLine" id="cb7-6" data-line-number="6"></a>
<a class="sourceLine" id="cb7-7" data-line-number="7"><span class="kw">instance</span> <span class="dt">Semiring</span> <span class="dt">Nat</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-8" data-line-number="8">  zero <span class="fu">=</span> <span class="dt">Zero</span></a>
<a class="sourceLine" id="cb7-9" data-line-number="9">  one <span class="fu">=</span> <span class="dt">Succ</span> <span class="dt">Zero</span></a>
<a class="sourceLine" id="cb7-10" data-line-number="10">  <span class="dt">Zero</span> <span class="fu">&lt;+&gt;</span> x <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb7-11" data-line-number="11">  <span class="dt">Succ</span> x <span class="fu">&lt;+&gt;</span> y <span class="fu">=</span> <span class="dt">Succ</span> (x <span class="fu">&lt;+&gt;</span> y)</a>
<a class="sourceLine" id="cb7-12" data-line-number="12">  <span class="dt">Zero</span> <span class="fu">&lt;.&gt;</span> _ <span class="fu">=</span> <span class="dt">Zero</span></a>
<a class="sourceLine" id="cb7-13" data-line-number="13">  <span class="dt">Succ</span> <span class="dt">Zero</span> <span class="fu">&lt;.&gt;</span> x <span class="fu">=</span>x</a>
<a class="sourceLine" id="cb7-14" data-line-number="14">  <span class="dt">Succ</span> x <span class="fu">&lt;.&gt;</span> y <span class="fu">=</span> y <span class="fu">&lt;+&gt;</span> (x <span class="fu">&lt;.&gt;</span> y)</a></code></pre></div>
<p>The other missing method is <code class="sourceCode haskell">fromInteger</code>, which means decidedly non-numeric types are allowed:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Semiring</span> <span class="dt">Bool</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  zero <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  one  <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">  (<span class="fu">&lt;+&gt;</span>) <span class="fu">=</span> (<span class="fu">||</span>)</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">  (<span class="fu">&lt;.&gt;</span>) <span class="fu">=</span> (<span class="fu">&amp;&amp;</span>)</a></code></pre></div>
<p>We can provide a more general definition of the <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Monoid.html#t:Sum"><code class="sourceCode haskell"><span class="dt">Sum</span></code></a> and <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Monoid.html#t:Product"><code class="sourceCode haskell"><span class="dt">Product</span></code></a> newtypes from <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Monoid.html#g:3">Data.Monoid</a>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Add</span> a <span class="fu">=</span> <span class="dt">Add</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">  {<span class="ot"> getAdd ::</span> a</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Read</span>, <span class="dt">Show</span>, <span class="dt">Semiring</span>)</a>
<a class="sourceLine" id="cb9-4" data-line-number="4"></a>
<a class="sourceLine" id="cb9-5" data-line-number="5"><span class="kw">newtype</span> <span class="dt">Mul</span> a <span class="fu">=</span> <span class="dt">Mul</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6">  {<span class="ot"> getMul ::</span> a</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Read</span>, <span class="dt">Show</span>, <span class="dt">Semiring</span>)</a>
<a class="sourceLine" id="cb9-8" data-line-number="8"></a>
<a class="sourceLine" id="cb9-9" data-line-number="9"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Add</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-10" data-line-number="10">  fmap f (<span class="dt">Add</span> x) <span class="fu">=</span> <span class="dt">Add</span> (f x)</a>
<a class="sourceLine" id="cb9-11" data-line-number="11"></a>
<a class="sourceLine" id="cb9-12" data-line-number="12"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Add</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-13" data-line-number="13">  pure <span class="fu">=</span> <span class="dt">Add</span></a>
<a class="sourceLine" id="cb9-14" data-line-number="14">  <span class="dt">Add</span> f <span class="fu">&lt;*&gt;</span> <span class="dt">Add</span> x <span class="fu">=</span> <span class="dt">Add</span> (f x)</a></code></pre></div>
<p>I’m using <code class="sourceCode haskell"><span class="dt">Add</span></code> and <code class="sourceCode haskell"><span class="dt">Mul</span></code> here to avoid name clashing.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Semiring</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Add</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">  mempty <span class="fu">=</span> <span class="dt">Add</span> zero</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  <span class="dt">Add</span> x <span class="ot">`mappend`</span> <span class="dt">Add</span> y <span class="fu">=</span> <span class="dt">Add</span> (x <span class="fu">&lt;+&gt;</span> y)</a>
<a class="sourceLine" id="cb10-4" data-line-number="4"></a>
<a class="sourceLine" id="cb10-5" data-line-number="5"><span class="kw">instance</span> <span class="dt">Semiring</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Mul</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-6" data-line-number="6">  mempty <span class="fu">=</span> <span class="dt">Mul</span> one</a>
<a class="sourceLine" id="cb10-7" data-line-number="7">  <span class="dt">Mul</span> x <span class="ot">`mappend`</span> <span class="dt">Mul</span> y <span class="fu">=</span> <span class="dt">Mul</span> (x <span class="fu">&lt;.&gt;</span> y)</a>
<a class="sourceLine" id="cb10-8" data-line-number="8">  </a>
<a class="sourceLine" id="cb10-9" data-line-number="9"><span class="ot">add ::</span> (<span class="dt">Semiring</span> a, <span class="dt">Foldable</span> f) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb10-10" data-line-number="10">add <span class="fu">=</span> getAdd <span class="fu">.</span> foldMap <span class="dt">Add</span></a>
<a class="sourceLine" id="cb10-11" data-line-number="11"></a>
<a class="sourceLine" id="cb10-12" data-line-number="12"><span class="ot">mul ::</span> (<span class="dt">Semiring</span> a, <span class="dt">Foldable</span> f) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb10-13" data-line-number="13">mul <span class="fu">=</span> getMul <span class="fu">.</span> foldMap <span class="dt">Mul</span></a></code></pre></div>
<p><code class="sourceCode haskell">add</code> and <code class="sourceCode haskell">mul</code> are equivalent to <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Foldable.html#v:sum"><code class="sourceCode haskell">sum</code></a> and <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Foldable.html#v:product"><code class="sourceCode haskell">product</code></a>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell literate prop"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1">add xs <span class="fu">==</span> sum (<span class="ot">xs ::</span> [<span class="dt">Integer</span>])</a></code></pre></div>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell literate prop"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1">mul xs <span class="fu">==</span> product (<span class="ot">xs ::</span> [<span class="dt">Integer</span>])</a></code></pre></div>
<p>But they now work with a wider array of types: non-negative numbers, as we’ve seen, but specialised to <code class="sourceCode haskell"><span class="dt">Bool</span></code> we get the familiar <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Monoid.html#t:Any"><code class="sourceCode haskell"><span class="dt">Any</span></code></a> and <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Monoid.html#t:All"><code class="sourceCode haskell"><span class="dt">All</span></code></a> newtypes (and their corresponding folds).</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell literate prop"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1">add xs <span class="fu">==</span> or (<span class="ot">xs ::</span> [<span class="dt">Bool</span>])</a></code></pre></div>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell literate prop"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1">mul xs <span class="fu">==</span> and (<span class="ot">xs ::</span> [<span class="dt">Bool</span>])</a></code></pre></div>
<p>So far, nothing amazing. We avoid a little bit of code duplication, that’s all.</p>
<h2 id="a-semiring-map">A Semiring Map</h2>
<p>In older versions of Python, <a href="https://www.python.org/dev/peps/pep-0218/">there was no native set type</a>. In its place, dictionaries were used, where the values would be booleans. In a similar fashion, before the <a href="https://docs.python.org/2/library/collections.html#collections.Counter">Counter</a> type was added in 2.7, the traditional way of representing a multiset was using a dictionary where the values were integers.</p>
<p>Using semirings, both of these data structures can have the same type:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">GeneralMap</span> a b <span class="fu">=</span> <span class="dt">GeneralMap</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2">  {<span class="ot"> getMap ::</span> <span class="dt">Map</span> a b</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">  } <span class="kw">deriving</span> (<span class="dt">Functor</span>, <span class="dt">Foldable</span>, <span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>)</a></code></pre></div>
<p>If operations are defined in terms of the <code class="sourceCode haskell"><span class="dt">Semiring</span></code> class, the same code will work on a set <em>and</em> a multiset:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="ot">insert ::</span> (<span class="dt">Ord</span> a, <span class="dt">Semiring</span> b) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a b <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a b</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">insert x <span class="fu">=</span> <span class="dt">GeneralMap</span> <span class="fu">.</span> Map.insertWith (<span class="fu">&lt;+&gt;</span>) x one <span class="fu">.</span> getMap</a>
<a class="sourceLine" id="cb16-3" data-line-number="3"></a>
<a class="sourceLine" id="cb16-4" data-line-number="4"><span class="ot">delete ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a b <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a b</a>
<a class="sourceLine" id="cb16-5" data-line-number="5">delete x <span class="fu">=</span> <span class="dt">GeneralMap</span> <span class="fu">.</span> Map.delete x <span class="fu">.</span> getMap</a></code></pre></div>
<p>How to get back the dictionary-like behaviour, then? Well, operations like <code class="sourceCode haskell">lookup</code> and <code class="sourceCode haskell">assoc</code> are better suited to a <code class="sourceCode haskell"><span class="dt">Monoid</span></code> constraint, rather than <code class="sourceCode haskell"><span class="dt">Semiring</span></code>:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1">lookup<span class="ot"> ::</span> (<span class="dt">Ord</span> a, <span class="dt">Monoid</span> b) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a b <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">lookup x <span class="fu">=</span> fold <span class="fu">.</span> Map.lookup x <span class="fu">.</span> getMap</a>
<a class="sourceLine" id="cb17-3" data-line-number="3"></a>
<a class="sourceLine" id="cb17-4" data-line-number="4"><span class="ot">assoc ::</span> (<span class="dt">Ord</span> a, <span class="dt">Applicative</span> f, <span class="dt">Monoid</span> (f b)) </a>
<a class="sourceLine" id="cb17-5" data-line-number="5">      <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a (f b) <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a (f b)</a>
<a class="sourceLine" id="cb17-6" data-line-number="6">assoc k v <span class="fu">=</span> <span class="dt">GeneralMap</span> <span class="fu">.</span> Map.insertWith mappend k (pure v) <span class="fu">.</span> getMap</a></code></pre></div>
<p><code class="sourceCode haskell">lookup</code> is a function which should work on sets and multisets: however <code class="sourceCode haskell"><span class="dt">Bool</span></code> and <code class="sourceCode haskell"><span class="dt">Integer</span></code> don’t have <code class="sourceCode haskell"><span class="dt">Monoid</span></code> instances. To fix this, we can use the <code class="sourceCode haskell"><span class="dt">Add</span></code> newtype from earlier. The interface for each of these data structures can now be expressed like this:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Set</span>      a   <span class="fu">=</span> <span class="dt">GeneralMap</span> a (<span class="dt">Add</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb18-2" data-line-number="2"><span class="kw">type</span> <span class="dt">MultiSet</span> a   <span class="fu">=</span> <span class="dt">GeneralMap</span> a (<span class="dt">Add</span> <span class="dt">Integer</span>)</a>
<a class="sourceLine" id="cb18-3" data-line-number="3"><span class="kw">type</span> <span class="dt">Map</span>      a b <span class="fu">=</span> <span class="dt">GeneralMap</span> a (<span class="dt">First</span> b)</a>
<a class="sourceLine" id="cb18-4" data-line-number="4"><span class="kw">type</span> <span class="dt">MultiMap</span> a b <span class="fu">=</span> <span class="dt">GeneralMap</span> a [b]</a></code></pre></div>
<p>And each of the functions on the <code class="sourceCode haskell"><span class="dt">GeneralMap</span></code> specialises like this:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="co">-- Set</span></a>
<a class="sourceLine" id="cb19-2" data-line-number="2"><span class="ot">insert ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Set</span> a <span class="ot">-&gt;</span> <span class="dt">Set</span> a</a>
<a class="sourceLine" id="cb19-3" data-line-number="3">lookup<span class="ot"> ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Set</span> a <span class="ot">-&gt;</span> <span class="dt">Add</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb19-4" data-line-number="4"><span class="ot">delete ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Set</span> a <span class="ot">-&gt;</span> <span class="dt">Set</span> a</a>
<a class="sourceLine" id="cb19-5" data-line-number="5"></a>
<a class="sourceLine" id="cb19-6" data-line-number="6"><span class="co">-- MultiSet</span></a>
<a class="sourceLine" id="cb19-7" data-line-number="7"><span class="ot">insert ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">MultiSet</span> a <span class="ot">-&gt;</span> <span class="dt">MultiSet</span> a</a>
<a class="sourceLine" id="cb19-8" data-line-number="8">lookup<span class="ot"> ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">MultiSet</span> a <span class="ot">-&gt;</span> <span class="dt">Add</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb19-9" data-line-number="9"><span class="ot">delete ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">MultiSet</span> a <span class="ot">-&gt;</span> <span class="dt">MultiSet</span> a</a>
<a class="sourceLine" id="cb19-10" data-line-number="10"></a>
<a class="sourceLine" id="cb19-11" data-line-number="11"><span class="co">-- Map</span></a>
<a class="sourceLine" id="cb19-12" data-line-number="12"><span class="ot">assoc  ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Map</span> a b <span class="ot">-&gt;</span> <span class="dt">Map</span> a b</a>
<a class="sourceLine" id="cb19-13" data-line-number="13">lookup<span class="ot"> ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Map</span> a b <span class="ot">-&gt;</span> <span class="dt">First</span> b</a>
<a class="sourceLine" id="cb19-14" data-line-number="14"><span class="ot">delete ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Map</span> a b <span class="ot">-&gt;</span> <span class="dt">Map</span> a b</a>
<a class="sourceLine" id="cb19-15" data-line-number="15"></a>
<a class="sourceLine" id="cb19-16" data-line-number="16"><span class="co">-- MultiMap</span></a>
<a class="sourceLine" id="cb19-17" data-line-number="17"><span class="ot">assoc  ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">MultiMap</span> a b <span class="ot">-&gt;</span> <span class="dt">MultiMap</span> a b</a>
<a class="sourceLine" id="cb19-18" data-line-number="18">lookup<span class="ot"> ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">MultiMap</span> a b <span class="ot">-&gt;</span> [b]</a>
<a class="sourceLine" id="cb19-19" data-line-number="19"><span class="ot">delete ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">MultiMap</span> a b <span class="ot">-&gt;</span> <span class="dt">MultiMap</span> a b</a></code></pre></div>
<p>This was actually where I first came across semirings: I was trying to avoid code duplication for a trie implementation. I wanted to get the Boom Hierarchy <span class="citation" data-cites="boom_further_1981">(<a href="#ref-boom_further_1981">1981</a>)</span> (plus maps) from the same underlying implementation.</p>
<p>It works <em>okay</em>. On the one hand, it’s nice that you don’t have to wrap the map type itself to get the different behaviour. There’s only one <code class="sourceCode haskell">delete</code> function, which works on sets, maps, multisets, etc. I don’t need to import the <code class="sourceCode haskell"><span class="dt">TrieSet</span></code> module qualified, to differentiate between the <em>four</em> <code class="sourceCode haskell">delete</code> functions I’ve written.</p>
<p>On the other hand, the <code class="sourceCode haskell"><span class="dt">Add</span></code> wrapper is a pain: having <code class="sourceCode haskell">lookup</code> return the wrapped values is ugly, and the <code class="sourceCode haskell"><span class="dt">Applicative</span></code> constraint is unwieldy (we only use it for <code class="sourceCode haskell">pure</code>). Both of those problems could be solved by using something like the <a href="https://hackage.haskell.org/package/newtype-0.2/docs/Control-Newtype.html#t:Newtype"><code class="sourceCode haskell"><span class="dt">Newtype</span></code></a> or <a href="https://hackage.haskell.org/package/lens-4.15.1/docs/Control-Lens-Wrapped.html#t:Wrapped"><code class="sourceCode haskell"><span class="dt">Wrapped</span></code></a> class, which provide facilities for wrapping and unwrapping, but that might be overkill.</p>
<p>While <code class="sourceCode haskell"><span class="dt">Monoid</span></code> and <code class="sourceCode haskell"><span class="dt">Semiring</span></code> can take you pretty far, even to a <code class="sourceCode haskell"><span class="dt">Monoid</span></code> instance:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="ot">fromList ::</span> (<span class="dt">Ord</span> a, <span class="dt">Semiring</span> b, <span class="dt">Foldable</span> f) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a b</a>
<a class="sourceLine" id="cb20-2" data-line-number="2">fromList <span class="fu">=</span> foldr insert (<span class="dt">GeneralMap</span> Map.empty)</a>
<a class="sourceLine" id="cb20-3" data-line-number="3"></a>
<a class="sourceLine" id="cb20-4" data-line-number="4"><span class="ot">fromAssocs ::</span> (<span class="dt">Ord</span> a, <span class="dt">Applicative</span> f, <span class="dt">Monoid</span> (f b), <span class="dt">Foldable</span> t) </a>
<a class="sourceLine" id="cb20-5" data-line-number="5">           <span class="ot">=&gt;</span> t (a, b) <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a (f b)</a>
<a class="sourceLine" id="cb20-6" data-line-number="6">fromAssocs <span class="fu">=</span> foldr (uncurry assoc) (<span class="dt">GeneralMap</span> Map.empty)</a>
<a class="sourceLine" id="cb20-7" data-line-number="7"></a>
<a class="sourceLine" id="cb20-8" data-line-number="8"><span class="kw">instance</span> (<span class="dt">Ord</span> a, <span class="dt">Monoid</span> b) <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">GeneralMap</span> a b) <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-9" data-line-number="9">  mempty <span class="fu">=</span> <span class="dt">GeneralMap</span> Map.empty</a>
<a class="sourceLine" id="cb20-10" data-line-number="10">  mappend (<span class="dt">GeneralMap</span> x) (<span class="dt">GeneralMap</span> y) <span class="fu">=</span> </a>
<a class="sourceLine" id="cb20-11" data-line-number="11">    <span class="dt">GeneralMap</span> (Map.unionWith mappend x y)</a>
<a class="sourceLine" id="cb20-12" data-line-number="12"></a>
<a class="sourceLine" id="cb20-13" data-line-number="13"><span class="ot">singleton ::</span> <span class="dt">Semiring</span> b <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a b</a>
<a class="sourceLine" id="cb20-14" data-line-number="14">singleton x <span class="fu">=</span> <span class="dt">GeneralMap</span> (Map.singleton x one)</a></code></pre></div>
<p>They seem to fall down around functions like <code class="sourceCode haskell">intersection</code>:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="ot">intersection ::</span> (<span class="dt">Ord</span> a, <span class="dt">Semiring</span> b)</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">             <span class="ot">=&gt;</span> <span class="dt">GeneralMap</span> a b <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a b <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> a b</a>
<a class="sourceLine" id="cb21-3" data-line-number="3">intersection (<span class="dt">GeneralMap</span> x) (<span class="dt">GeneralMap</span> y) <span class="fu">=</span></a>
<a class="sourceLine" id="cb21-4" data-line-number="4">  <span class="dt">GeneralMap</span> (Map.intersectionWith (<span class="fu">&lt;.&gt;</span>) x y)</a></code></pre></div>
<p>It works for sets, but it doesn’t make sense for multisets, and it doesn’t work for maps.</p>
<p>I couldn’t find a semiring for the map-like types which would give me a sensible intersection. I’m probably after a different algebraic structure.</p>
<h2 id="a-probability-semiring">A Probability Semiring</h2>
<p>While looking for a semiring to represent a valid intersection, I came across the probability semiring. It’s just the normal semiring over the rationals, with a lower bound of 0, and an upper of 1.</p>
<p>It’s useful in some cool ways: you can combine it with a list to get the probability monad <span class="citation" data-cites="erwig_functional_2006">(Erwig and Kollmansberger <a href="#ref-erwig_functional_2006">2006</a>)</span>. There’s an example in PureScript’s <a href="https://pursuit.purescript.org/packages/purescript-distributions/">Distributions</a> package.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Prob</span> s a <span class="fu">=</span> <span class="dt">Prob</span> {<span class="ot"> runProb ::</span> [(a,s)] }</a></code></pre></div>
<p>There are some drawbacks to this representation, performance-wise. In particular, there’s a combinatorial explosion on every monadic bind. One of the strategies to reduce this explosion is to use a map:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Prob</span> s a <span class="fu">=</span> <span class="dt">Prob</span> {<span class="ot"> runProb ::</span> <span class="dt">Map</span> a s }</a></code></pre></div>
<p>Because this doesn’t allow duplicate keys, it will flatten the association list on every bind. Unfortunately, the performance gain doesn’t always materialize, and in some cases there’s a performance <em>loss</em> <span class="citation" data-cites="larsen_memory_2011">(Larsen <a href="#ref-larsen_memory_2011">2011</a>)</span>. Also, the <code class="sourceCode haskell"><span class="dt">Ord</span></code> constraint on the keys prevents it from conforming to <code class="sourceCode haskell"><span class="dt">Monad</span></code> (at least not without <a href="http://okmij.org/ftp/Haskell/set-monad.html">difficulty</a>).</p>
<p>Interestingly, this type is exactly the same as the <code class="sourceCode haskell"><span class="dt">GeneralMap</span></code> from before. This is a theme I kept running into, actually: the <code class="sourceCode haskell"><span class="dt">GeneralMap</span></code> type represents not just maps, multimaps, sets, multisets, but also a whole host of other data structures.</p>
<h2 id="cont">Cont</h2>
<p>Edward Kmett had an interesting blog post about “Free Modules and Functional Linear Functionals” <span class="citation" data-cites="kmett_modules_2011">(<a href="#ref-kmett_modules_2011">2011</a><a href="#ref-kmett_modules_2011">b</a>)</span>. In it, he talked about this type:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="kw">infixr</span> <span class="dv">0</span> <span class="fu">$*</span></a>
<a class="sourceLine" id="cb24-2" data-line-number="2"><span class="kw">newtype</span> <span class="dt">Linear</span> r a <span class="fu">=</span> <span class="dt">Linear</span> {<span class="ot"> ($*) ::</span> (a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r }</a></code></pre></div>
<p>Also known as <a href="https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Cont.html#t:Cont"><code class="sourceCode haskell"><span class="dt">Cont</span></code></a>, the continuation monad. It can encode the probability monad:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="ot">fromProbs ::</span> (<span class="dt">Semiring</span> s, <span class="dt">Applicative</span> m) <span class="ot">=&gt;</span> [(a,s)] <span class="ot">-&gt;</span> <span class="dt">ContT</span> s m a</a>
<a class="sourceLine" id="cb25-2" data-line-number="2">fromProbs xs <span class="fu">=</span> <span class="dt">ContT</span> <span class="fu">$</span> \k <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb25-3" data-line-number="3">  foldr (\(x,s) a <span class="ot">-&gt;</span> liftA2 (<span class="fu">&lt;+&gt;</span>) (fmap (s<span class="fu">&lt;.&gt;</span>) (k x)) a) (pure zero) xs</a>
<a class="sourceLine" id="cb25-4" data-line-number="4"></a>
<a class="sourceLine" id="cb25-5" data-line-number="5"><span class="ot">probOfT ::</span> (<span class="dt">Semiring</span> r, <span class="dt">Applicative</span> m) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">ContT</span> r m a <span class="ot">-&gt;</span> m r</a>
<a class="sourceLine" id="cb25-6" data-line-number="6">probOfT e c <span class="fu">=</span> runContT c (\x <span class="ot">-&gt;</span> <span class="kw">if</span> e x <span class="kw">then</span> pure one <span class="kw">else</span> pure zero)</a>
<a class="sourceLine" id="cb25-7" data-line-number="7"></a>
<a class="sourceLine" id="cb25-8" data-line-number="8"><span class="ot">probOf ::</span> <span class="dt">Semiring</span> r <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Cont</span> r a <span class="ot">-&gt;</span> r</a>
<a class="sourceLine" id="cb25-9" data-line-number="9">probOf e <span class="fu">=</span> runIdentity <span class="fu">.</span> probOfT e</a>
<a class="sourceLine" id="cb25-10" data-line-number="10"></a>
<a class="sourceLine" id="cb25-11" data-line-number="11"><span class="ot">uniform ::</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">ContT</span> <span class="dt">Double</span> m a</a>
<a class="sourceLine" id="cb25-12" data-line-number="12">uniform xs <span class="fu">=</span></a>
<a class="sourceLine" id="cb25-13" data-line-number="13">  <span class="kw">let</span> s <span class="fu">=</span> <span class="fl">1.0</span> <span class="fu">/</span> fromIntegral (length xs)</a>
<a class="sourceLine" id="cb25-14" data-line-number="14">  <span class="kw">in</span> fromProbs (map (flip (,) s) xs)</a></code></pre></div>
<p>Multiplication isn’t paid for on every bind, making this (potentially) a more efficient implementation than both the map and the association list.</p>
<p>You can actually make the whole thing a semiring:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="kw">instance</span> (<span class="dt">Semiring</span> r, <span class="dt">Applicative</span> m) <span class="ot">=&gt;</span> <span class="dt">Semiring</span> (<span class="dt">ContT</span> r m a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb26-2" data-line-number="2">  one  <span class="fu">=</span> <span class="dt">ContT</span> (const (pure one))</a>
<a class="sourceLine" id="cb26-3" data-line-number="3">  zero <span class="fu">=</span> <span class="dt">ContT</span> (const (pure zero))</a>
<a class="sourceLine" id="cb26-4" data-line-number="4">  f <span class="fu">&lt;+&gt;</span> g <span class="fu">=</span> <span class="dt">ContT</span> (\k <span class="ot">-&gt;</span> liftA2 (<span class="fu">&lt;+&gt;</span>) (runContT f k) (runContT g k))</a>
<a class="sourceLine" id="cb26-5" data-line-number="5">  f <span class="fu">&lt;.&gt;</span> g <span class="fu">=</span> <span class="dt">ContT</span> (\k <span class="ot">-&gt;</span> liftA2 (<span class="fu">&lt;.&gt;</span>) (runContT f k) (runContT g k))</a></code></pre></div>
<p>Which gives you a lovely <code class="sourceCode haskell"><span class="dt">Alternative</span></code> instance:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="kw">instance</span> (<span class="dt">Semiring</span> r, <span class="dt">Applicative</span> m) <span class="ot">=&gt;</span> <span class="dt">Alternative</span> (<span class="dt">ContT</span> r m) <span class="kw">where</span></a>
<a class="sourceLine" id="cb27-2" data-line-number="2">  (<span class="fu">&lt;|&gt;</span>) <span class="fu">=</span> (<span class="fu">&lt;+&gt;</span>)</a>
<a class="sourceLine" id="cb27-3" data-line-number="3">  empty <span class="fu">=</span> zero</a></code></pre></div>
<p>This sheds some light on what was going on with the unsatisfactory <code class="sourceCode haskell">intersection</code> function on <code class="sourceCode haskell"><span class="dt">GeneralMap</span></code>: it’s actually <em>multiplication</em>. If you wanted to stretch the analogy and make <code class="sourceCode haskell"><span class="dt">GeneralMap</span></code> conform to <code class="sourceCode haskell"><span class="dt">Semiring</span></code>, you could use the empty map for <code class="sourceCode haskell">zero</code>, <code class="sourceCode haskell">mappend</code> for <code class="sourceCode haskell"><span class="fu">&lt;+&gt;</span></code>, but you’d run into trouble for <code class="sourceCode haskell">one</code>. <code class="sourceCode haskell">one</code> is the map where every possible key has a value of one. In other words, you’d have to enumerate over every possible value for the keys. Interestingly, there’s kind of the inverse problem for Cont: while it has an easy <code class="sourceCode haskell"><span class="dt">Semiring</span></code> instance, in order to <em>inspect</em> the values you have to enumerate over all the possible keys.</p>
<p>I now have a name for the probability monad / general map / Cont thing: a <em>covector</em>.</p>
<p>I think that the transformer version of Cont has a valid interpretation, also. If I ever understand <span class="citation" data-cites="hirschowitz_modules_2010">Hirschowitz and Maggesi (<a href="#ref-hirschowitz_modules_2010">2010</a>)</span> I’ll put it into a later follow-up post.</p>
<h2 id="conditional-choice">Conditional choice</h2>
<p>As a short digression, you can beef up the <code class="sourceCode haskell"><span class="fu">&lt;|&gt;</span></code> operator a little, with something like <a href="http://zenzike.com/posts/2011-08-01-the-conditional-choice-operator">the conditional choice operator</a>:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1"><span class="kw">data</span> <span class="dt">BiWeighted</span> s <span class="fu">=</span> s <span class="fu">:|:</span> s</a>
<a class="sourceLine" id="cb28-2" data-line-number="2"><span class="kw">infixl</span> <span class="dv">8</span> <span class="fu">:|:</span></a>
<a class="sourceLine" id="cb28-3" data-line-number="3"></a>
<a class="sourceLine" id="cb28-4" data-line-number="4"><span class="ot">(|&gt;) ::</span> (<span class="dt">Applicative</span> m, <span class="dt">Semiring</span> s)</a>
<a class="sourceLine" id="cb28-5" data-line-number="5">     <span class="ot">=&gt;</span> <span class="dt">BiWeighted</span> s</a>
<a class="sourceLine" id="cb28-6" data-line-number="6">     <span class="ot">-&gt;</span> <span class="dt">ContT</span> s m a</a>
<a class="sourceLine" id="cb28-7" data-line-number="7">     <span class="ot">-&gt;</span> <span class="dt">ContT</span> s m a</a>
<a class="sourceLine" id="cb28-8" data-line-number="8">     <span class="ot">-&gt;</span> <span class="dt">ContT</span> s m a</a>
<a class="sourceLine" id="cb28-9" data-line-number="9">((lp <span class="fu">:|:</span> rp) <span class="fu">|&gt;</span> r) l <span class="fu">=</span></a>
<a class="sourceLine" id="cb28-10" data-line-number="10">  (mapContT<span class="fu">.</span>fmap<span class="fu">.</span>(<span class="fu">&lt;.&gt;</span>)) lp l <span class="fu">&lt;|&gt;</span> (mapContT<span class="fu">.</span>fmap<span class="fu">.</span>(<span class="fu">&lt;.&gt;</span>)) rp r</a>
<a class="sourceLine" id="cb28-11" data-line-number="11"><span class="co">--</span></a>
<a class="sourceLine" id="cb28-12" data-line-number="12"><span class="ot">(&lt;|) ::</span> <span class="dt">ContT</span> s m a</a>
<a class="sourceLine" id="cb28-13" data-line-number="13">     <span class="ot">-&gt;</span> (<span class="dt">ContT</span> s m a <span class="ot">-&gt;</span> <span class="dt">ContT</span> s m a)</a>
<a class="sourceLine" id="cb28-14" data-line-number="14">     <span class="ot">-&gt;</span> <span class="dt">ContT</span> s m a</a>
<a class="sourceLine" id="cb28-15" data-line-number="15">l <span class="fu">&lt;|</span> r <span class="fu">=</span> r l</a>
<a class="sourceLine" id="cb28-16" data-line-number="16"></a>
<a class="sourceLine" id="cb28-17" data-line-number="17"><span class="kw">infixr</span> <span class="dv">0</span> <span class="fu">&lt;|</span></a>
<a class="sourceLine" id="cb28-18" data-line-number="18"><span class="kw">infixr</span> <span class="dv">0</span> <span class="fu">|&gt;</span></a></code></pre></div>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" data-line-number="1">probOf (<span class="ch">&#39;a&#39;</span><span class="fu">==</span>) (uniform <span class="st">&quot;a&quot;</span> <span class="fu">&lt;|</span> <span class="fl">0.4</span> <span class="fu">:|:</span> <span class="fl">0.6</span> <span class="fu">|&gt;</span> uniform <span class="st">&quot;b&quot;</span>)</a>
<a class="sourceLine" id="cb29-2" data-line-number="2"><span class="fl">0.4</span></a></code></pre></div>
<h2 id="unleak">UnLeak</h2>
<p>If you fiddle around with the probability monad, you can break it apart in interesting ways. For instance, extracting the <code class="sourceCode haskell"><span class="dt">WriterT</span></code> monad transformer gives you:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="dt">WriterT</span> (<span class="dt">Product</span> <span class="dt">Double</span>) []</a></code></pre></div>
<p>Eric Kidd describes it as <code class="sourceCode haskell"><span class="dt">PerhapsT</span></code>: a <code class="sourceCode haskell"><span class="dt">Maybe</span></code> with attached probability in his <a href="http://www.randomhacks.net/2007/02/21/refactoring-probability-distributions/">excellent blog post</a> <span class="citation" data-cites="kidd_build_2007">(and his paper in <a href="#ref-kidd_build_2007">2007</a>)</span>.</p>
<p>Straight away, we can optimise this representation by transforming the <a href="https://mail.haskell.org/pipermail/libraries/2013-March/019528.html">leaky</a> <code class="sourceCode haskell"><span class="dt">WriterT</span></code> into a state monad:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">WeightedT</span> s m a <span class="fu">=</span> <span class="dt">WeightedT</span> </a>
<a class="sourceLine" id="cb31-2" data-line-number="2">  {<span class="ot"> getWeightedT ::</span> s <span class="ot">-&gt;</span> m (a, s)</a>
<a class="sourceLine" id="cb31-3" data-line-number="3">  } <span class="kw">deriving</span> <span class="dt">Functor</span></a>
<a class="sourceLine" id="cb31-4" data-line-number="4">  </a>
<a class="sourceLine" id="cb31-5" data-line-number="5"><span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="dt">WeightedT</span> s m) <span class="kw">where</span></a>
<a class="sourceLine" id="cb31-6" data-line-number="6">  pure x <span class="fu">=</span> <span class="dt">WeightedT</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> pure (x,s)</a>
<a class="sourceLine" id="cb31-7" data-line-number="7">  <span class="dt">WeightedT</span> fs <span class="fu">&lt;*&gt;</span> <span class="dt">WeightedT</span> xs <span class="fu">=</span> <span class="dt">WeightedT</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb31-8" data-line-number="8">    (f, p) <span class="ot">&lt;-</span> fs s</a>
<a class="sourceLine" id="cb31-9" data-line-number="9">    (x, t) <span class="ot">&lt;-</span> xs p</a>
<a class="sourceLine" id="cb31-10" data-line-number="10">    pure (f x, t)</a>
<a class="sourceLine" id="cb31-11" data-line-number="11">  </a>
<a class="sourceLine" id="cb31-12" data-line-number="12"><span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">WeightedT</span> s m) <span class="kw">where</span></a>
<a class="sourceLine" id="cb31-13" data-line-number="13">  <span class="dt">WeightedT</span> x <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">WeightedT</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb31-14" data-line-number="14">    (x, p) <span class="ot">&lt;-</span> x s</a>
<a class="sourceLine" id="cb31-15" data-line-number="15">    getWeightedT (f x) p</a></code></pre></div>
<p>I’m not sure yet, but I think this might have something to do with the isomorphism between <code class="sourceCode haskell"><span class="dt">Cont</span> ((<span class="ot">-&gt;</span>) s)</code> and <code>State s</code> <span class="citation" data-cites="kmett_free_2011">(Kmett <a href="#ref-kmett_free_2011">2011</a><a href="#ref-kmett_free_2011">a</a>)</span>.</p>
<p>You can even make it look like a normal (non-transformer) writer with some pattern synonyms:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Weighted</span> s <span class="fu">=</span> <span class="dt">WeightedT</span> s <span class="dt">Identity</span></a>
<a class="sourceLine" id="cb32-2" data-line-number="2"></a>
<a class="sourceLine" id="cb32-3" data-line-number="3">pattern <span class="dt">Weighted</span> w <span class="ot">&lt;-</span> (runIdentity <span class="fu">.</span> flip getWeightedT zero <span class="ot">-&gt;</span> w) <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-4" data-line-number="4">  <span class="dt">Weighted</span> (x,w) <span class="fu">=</span> <span class="dt">WeightedT</span> (\s <span class="ot">-&gt;</span> <span class="dt">Identity</span> (x, s <span class="fu">&lt;.&gt;</span> w) )</a></code></pre></div>
<p>And you can pretend that you’ve just got a normal tuple:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" data-line-number="1"><span class="ot">half ::</span> a <span class="ot">-&gt;</span> <span class="dt">Weighted</span> <span class="dt">Double</span> a</a>
<a class="sourceLine" id="cb33-2" data-line-number="2">half x <span class="fu">=</span> <span class="dt">Weighted</span> (x, <span class="fl">0.5</span>)</a>
<a class="sourceLine" id="cb33-3" data-line-number="3"></a>
<a class="sourceLine" id="cb33-4" data-line-number="4"><span class="ot">runWeighted ::</span> <span class="dt">Semiring</span> s <span class="ot">=&gt;</span> <span class="dt">Weighted</span> s a <span class="ot">-&gt;</span> (a, s)</a>
<a class="sourceLine" id="cb33-5" data-line-number="5">runWeighted (<span class="dt">Weighted</span> w) <span class="fu">=</span> w</a>
<a class="sourceLine" id="cb33-6" data-line-number="6"></a>
<a class="sourceLine" id="cb33-7" data-line-number="7"><span class="ot">evalWeighted ::</span> <span class="dt">Semiring</span> s <span class="ot">=&gt;</span> <span class="dt">Weighted</span> s a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb33-8" data-line-number="8">evalWeighted (<span class="dt">Weighted</span> (x,_)) <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb33-9" data-line-number="9"></a>
<a class="sourceLine" id="cb33-10" data-line-number="10"><span class="ot">execWeighted ::</span> <span class="dt">Semiring</span> s <span class="ot">=&gt;</span> <span class="dt">Weighted</span> s a <span class="ot">-&gt;</span> s</a>
<a class="sourceLine" id="cb33-11" data-line-number="11">execWeighted (<span class="dt">Weighted</span> (_,s)) <span class="fu">=</span> s</a></code></pre></div>
<h2 id="free">Free</h2>
<p>Looking back at Cont, it is reminiscent of a particular encoding of the free monoid from <span class="citation" data-cites="doel_free_2015">Doel (<a href="#ref-doel_free_2015">2015</a>)</span>:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">FreeMonoid</span> a <span class="fu">=</span> <span class="dt">FreeMonoid</span></a>
<a class="sourceLine" id="cb34-2" data-line-number="2">  { forall m<span class="fu">.</span> <span class="dt">Monoid</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m) <span class="ot">-&gt;</span> m }</a></code></pre></div>
<p>So possibly covectors represent the free semiring, in some way.</p>
<p>Another encoding which looks free-ish is one of the efficient implementations of the probability monad from <span class="citation" data-cites="larsen_memory_2011">Larsen (<a href="#ref-larsen_memory_2011">2011</a>)</span>:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb35-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Dist</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb35-2" data-line-number="2">  <span class="dt">Certainly</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Dist</span> a <span class="co">-- only possible value</span></a>
<a class="sourceLine" id="cb35-3" data-line-number="3">  <span class="dt">Choice</span><span class="ot"> ::</span> <span class="dt">Probability</span> <span class="ot">-&gt;</span> <span class="dt">Dist</span> a <span class="ot">-&gt;</span> <span class="dt">Dist</span> a <span class="ot">-&gt;</span> <span class="dt">Dist</span> a</a>
<a class="sourceLine" id="cb35-4" data-line-number="4">  <span class="dt">Fmap</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Dist</span> a <span class="ot">-&gt;</span> <span class="dt">Dist</span> b</a>
<a class="sourceLine" id="cb35-5" data-line-number="5">  <span class="dt">Join</span><span class="ot"> ::</span> <span class="dt">Dist</span> (<span class="dt">Dist</span> a) <span class="ot">-&gt;</span> <span class="dt">Dist</span> a</a></code></pre></div>
<p>This looks an awful lot like a weighted <a href="https://hackage.haskell.org/package/free-4.12.4/docs/Control-Alternative-Free.html">free alternative</a>. Is it a free semiring, then?</p>
<p>Maybe. There’s a parallel between the relationship between monoids and semirings and applicatives and <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Applicative.html#t:Alternative"><code class="sourceCode haskell"><span class="dt">Alternative</span></code></a>s <span class="citation" data-cites="rivas_monoids_2015">(Rivas, Jaskelioff, and Schrijvers <a href="#ref-rivas_monoids_2015">2015</a>)</span>. In a way, where monads are monoids in the category of endofunctors, alternatives are <em>semirings</em> in the category of endofunctors.</p>
<p>This parallel probably isn’t what I first thought it was. First of all, the above paper uses near-semirings, not semirings. A near-semiring is a semiring where the requirements for left distribution of multiplication over addition and commutative addition are dropped. Secondly, the class which most mirrors near-semirings is <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Monad.html#t:MonadPlus"><code class="sourceCode haskell"><span class="dt">MonadPlus</span></code></a>, not alternative. (alternative doesn’t have annihilation) Thirdly, right distribution of multiplication over addition <em>isn’t</em> required <code class="sourceCode haskell"><span class="dt">MonadPlus</span></code>: it’s a further law required on top of the existing laws. Fourthly, most types in the Haskell ecosystem today which conform to <code class="sourceCode haskell"><span class="dt">MonadPlus</span></code> <em>don’t</em> conform to this extra law: in fact, those that do seem to be lists of some kind or another.</p>
<p>A further class is probably needed on top of the two already there, with the extra laws <span class="citation" data-cites="fischer_reinventing_2009">(called <code class="sourceCode haskell"><span class="dt">Nondet</span></code> in Fischer <a href="#ref-fischer_reinventing_2009">2009</a>)</span>.</p>
<p>An actual free near-semiring looks like this:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Free</span> f x <span class="fu">=</span> <span class="dt">Free</span> {<span class="ot"> unFree ::</span> [<span class="dt">FFree</span> f x] }</a>
<a class="sourceLine" id="cb36-2" data-line-number="2"><span class="kw">data</span> <span class="dt">FFree</span> f x <span class="fu">=</span> <span class="dt">Pure</span> x <span class="fu">|</span> <span class="dt">Con</span> (f (<span class="dt">Free</span> f x))</a></code></pre></div>
<p>Specialised to the <code class="sourceCode haskell"><span class="dt">Identity</span></code> monad, that becomes:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb37-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Forest</span> a <span class="fu">=</span> <span class="dt">Forest</span> {<span class="ot"> unForest ::</span> [<span class="dt">Tree</span> x] }</a>
<a class="sourceLine" id="cb37-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Tree</span> x <span class="fu">=</span> <span class="dt">Leaf</span> x <span class="fu">|</span> <span class="dt">Branch</span> (<span class="dt">Forest</span> x)</a></code></pre></div>
<p>De-specialised to the <a href="https://hackage.haskell.org/package/free-4.12.4/docs/Control-Monad-Trans-Free.html">free monad transformer</a>, it becomes:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb38-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">FreeT</span> f m a <span class="fu">=</span> <span class="dt">FreeT</span></a>
<a class="sourceLine" id="cb38-2" data-line-number="2">  {<span class="ot"> runFreeT ::</span> m (<span class="dt">FreeF</span> f a (<span class="dt">FreeT</span> f m a)) }</a>
<a class="sourceLine" id="cb38-3" data-line-number="3"></a>
<a class="sourceLine" id="cb38-4" data-line-number="4"><span class="kw">data</span> <span class="dt">FreeF</span> f a b</a>
<a class="sourceLine" id="cb38-5" data-line-number="5">  <span class="fu">=</span> <span class="dt">Pure</span> a</a>
<a class="sourceLine" id="cb38-6" data-line-number="6">  <span class="fu">|</span> <span class="dt">Free</span> (f b)</a>
<a class="sourceLine" id="cb38-7" data-line-number="7"></a>
<a class="sourceLine" id="cb38-8" data-line-number="8"><span class="kw">type</span> <span class="dt">FreeNearSemiring</span> f <span class="fu">=</span> <span class="dt">FreeT</span> f []</a></code></pre></div>
<p>These definitions all lend themselves to combinatorial search <span class="citation" data-cites="spivey_algebras_2009 fischer_reinventing_2009 piponi_monad_2009">(Spivey <a href="#ref-spivey_algebras_2009">2009</a>; Fischer <a href="#ref-fischer_reinventing_2009">2009</a>; Piponi <a href="#ref-piponi_monad_2009">2009</a>)</span>, with one extra operation needed: <code class="sourceCode haskell">wrap</code>.</p>
<h2 id="odds">Odds</h2>
<p>Does the <a href="/posts/2016-09-27-odds-lhs.html">odds monad</a> fit in to any of this?</p>
<p>While <code class="sourceCode haskell"><span class="dt">WriterT</span> (<span class="dt">Product</span> <span class="dt">Rational</span>) []</code> is a valid definition of the traditional probability monad, it’s <em>not</em> the same as the odds monad. If you take the odds monad, and parameterize it over the weight of the tail, you get this:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb39-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Odds</span> m a <span class="fu">=</span> <span class="dt">Certain</span> a <span class="fu">|</span> <span class="dt">Choice</span> (m (a, <span class="dt">Odds</span> a))</a></code></pre></div>
<p>Which looks remarkably like <a href="http://www.haskellforall.com/2016/07/list-transformer-beginner-friendly-listt.html"><code class="sourceCode haskell"><span class="dt">ListT</span></code> done right</a>:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb40-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">ListT</span> m a <span class="fu">=</span> <span class="dt">ListT</span> {<span class="ot"> next ::</span> m (<span class="dt">Step</span> m a) }</a>
<a class="sourceLine" id="cb40-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Step</span> m a <span class="fu">=</span> <span class="dt">Cons</span> a (<span class="dt">ListT</span> m a) <span class="fu">|</span> <span class="dt">Nil</span></a></code></pre></div>
<p>That suggests a relationship between probability and odds:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb41-1" data-line-number="1"><span class="dt">WriterT</span> (<span class="dt">Product</span>  <span class="dt">Rational</span>) [] <span class="fu">=</span> <span class="dt">Probability</span></a>
<a class="sourceLine" id="cb41-2" data-line-number="2"><span class="dt">ListT</span>   (<span class="dt">Weighted</span> <span class="dt">Rational</span>)    <span class="fu">=</span> <span class="dt">Odds</span></a></code></pre></div>
<p><code class="sourceCode haskell"><span class="dt">ListT</span></code> isn’t a perfect match, though: it allows empty lists. To correct this, you could use the <a href="https://hackage.haskell.org/package/free-4.12.4/docs/Control-Comonad-Cofree.html">Cofree Comonad</a>:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb42-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Cofree</span> f a <span class="fu">=</span> a <span class="fu">:&lt;</span> (f (<span class="dt">Cofree</span> f a))</a></code></pre></div>
<p>Subbing in <code class="sourceCode haskell"><span class="dt">Maybe</span></code> for <code class="sourceCode haskell">f</code>, you get a non-empty list. A <em>weighted</em> <code class="sourceCode haskell"><span class="dt">Maybe</span></code> is basically <a href="http://www.randomhacks.net/2007/02/21/refactoring-probability-distributions/"><code class="sourceCode haskell"><span class="dt">PerhapsT</span></code></a>, as was mentioned earlier.</p>
<h2 id="generalizing-semirings">Generalizing Semirings</h2>
<p>Types in haskell also form a semiring.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb43-1" data-line-number="1">(<span class="fu">&lt;.&gt;</span>) <span class="fu">=</span> (,)</a>
<a class="sourceLine" id="cb43-2" data-line-number="2">one <span class="fu">=</span> ()</a>
<a class="sourceLine" id="cb43-3" data-line-number="3"></a>
<a class="sourceLine" id="cb43-4" data-line-number="4">(<span class="fu">&lt;+&gt;</span>) <span class="fu">=</span> <span class="dt">Either</span></a>
<a class="sourceLine" id="cb43-5" data-line-number="5">zero <span class="fu">=</span> <span class="dt">Void</span></a></code></pre></div>
<p>There’s a subset of semirings which are <a href="https://en.wikipedia.org/wiki/Semiring#Star_semirings">star semirings</a>. They have an operation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>*</mo><annotation encoding="application/x-tex">*</annotation></semantics></math> such that:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>*</mo><mo>=</mo><mn>1</mn><mo>+</mo><mi>a</mi><mi>a</mi><mo>*</mo><mo>=</mo><mn>1</mn><mo>+</mo><mi>a</mi><mo>*</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">a* = 1 + aa* = 1 + a*a</annotation></semantics></math></p>
<p>Or, as a class:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb44-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Semiring</span> a <span class="ot">=&gt;</span> <span class="dt">StarSemiring</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb44-2" data-line-number="2"><span class="ot">  star ::</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb44-3" data-line-number="3">  star x <span class="fu">=</span> one <span class="fu">&lt;+&gt;</span> plus x</a>
<a class="sourceLine" id="cb44-4" data-line-number="4"><span class="ot">  plus ::</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb44-5" data-line-number="5">  plus x <span class="fu">=</span> x <span class="fu">&lt;.&gt;</span> star x</a></code></pre></div>
<p>Using this on types, you get:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb45-1" data-line-number="1">star a <span class="fu">=</span> <span class="dt">Either</span> () (a, star a)</a></code></pre></div>
<p>Which is just a standard list! Some pseudo-haskell on alternatives will give you:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb46-1" data-line-number="1"><span class="ot">star ::</span> (<span class="dt">Alternative</span> f, <span class="dt">Monoid</span> a) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb46-2" data-line-number="2">star x <span class="fu">=</span> (x <span class="fu">&lt;.&gt;</span> star x) <span class="fu">&lt;+&gt;</span> pure mempty <span class="kw">where</span></a>
<a class="sourceLine" id="cb46-3" data-line-number="3">  (<span class="fu">&lt;.&gt;</span>) <span class="fu">=</span> liftA2 mappend</a>
<a class="sourceLine" id="cb46-4" data-line-number="4">  (<span class="fu">&lt;+&gt;</span>) <span class="fu">=</span> <span class="fu">&lt;|&gt;</span></a></code></pre></div>
<p>Also known as <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Applicative.html#v:many"><code class="sourceCode haskell">many</code></a>. (although note that this breaks all the laws)</p>
<p>The <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>*</mo><annotation encoding="application/x-tex">*</annotation></semantics></math> for rationals is defined as <span class="citation" data-cites="droste_semirings_2009">(Droste and Kuich <a href="#ref-droste_semirings_2009">2009</a>, p8)</span>:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>*</mo><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd columnalign="left"><mfrac><mn>1</mn><mrow><mn>1</mn><mo>−</mo><mi>a</mi></mrow></mfrac></mtd><mtd columnalign="left"><mspace width="1.0em"></mspace><mrow><mtext mathvariant="normal">if </mtext><mspace width="0.333em"></mspace></mrow></mtd><mtd columnalign="left"><mn>0</mn><mo>≤</mo><mi>a</mi><mo>&lt;</mo><mn>1</mn><mo>,</mo></mtd></mtr><mtr><mtd columnalign="left"><mi>∞</mi></mtd><mtd columnalign="left"><mspace width="1.0em"></mspace><mrow><mtext mathvariant="normal">if </mtext><mspace width="0.333em"></mspace></mrow></mtd><mtd columnalign="left"><mi>a</mi><mo>≥</mo><mn>1</mn><mi>.</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">a* = \begin{cases}
  \frac{1}{1 - a} &amp; \quad \text{if  } &amp; 0 \leq a \lt 1, \\
  \infty          &amp; \quad \text{if  } &amp; a \geq 1.
\end{cases}</annotation></semantics></math></p>
<p>So, combining the probability with the type-level business, the star of <code>Writer s a</code> is:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb47-1" data-line-number="1"><span class="dt">Either</span> (<span class="dv">1</span>, a) (a, s <span class="fu">/</span> (<span class="dv">1</span> <span class="fu">-</span> s), star (<span class="dt">Writer</span> s a))</a></code></pre></div>
<p>Or, to put it another way: the odds monad!</p>
<h2 id="endo">Endo</h2>
<p>An <a href="https://ncatlab.org/nlab/show/endomorphism">endomorphism</a> is a morphism from an object to itself. A less general definition (and the one <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Monoid.html#t:Endo">most often used</a> in Haskell) is a function of the type <code class="sourceCode haskell">a <span class="ot">-&gt;</span> a</code>:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb48-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Endo</span> a <span class="fu">=</span> <span class="dt">Endo</span> {<span class="ot"> appEndo ::</span> a <span class="ot">-&gt;</span> a }</a></code></pre></div>
<p>It forms a monoid under composition:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb49-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Monoid</span> (<span class="dt">Endo</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb49-2" data-line-number="2">  mempty <span class="fu">=</span> <span class="dt">Endo</span> id</a>
<a class="sourceLine" id="cb49-3" data-line-number="3">  mappend (<span class="dt">Endo</span> f) (<span class="dt">Endo</span> g) <span class="fu">=</span> <span class="dt">Endo</span> (f <span class="fu">.</span> g)</a></code></pre></div>
<p>If the underlying type is itself a commutative monoid, it also forms near-semiring:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb50-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Monoid</span> a <span class="ot">=&gt;</span> <span class="dt">Semiring</span> (<span class="dt">Endo</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb50-2" data-line-number="2">  <span class="dt">Endo</span> f <span class="fu">&lt;+&gt;</span> <span class="dt">Endo</span> g <span class="fu">=</span> <span class="dt">Endo</span> (\x <span class="ot">-&gt;</span> f x <span class="fu">&lt;&gt;</span> g x)</a>
<a class="sourceLine" id="cb50-3" data-line-number="3">  zero <span class="fu">=</span> <span class="dt">Endo</span> (const mempty)</a>
<a class="sourceLine" id="cb50-4" data-line-number="4">  one <span class="fu">=</span> <span class="dt">Endo</span> id</a>
<a class="sourceLine" id="cb50-5" data-line-number="5">  <span class="dt">Endo</span> f <span class="fu">&lt;.&gt;</span> <span class="dt">Endo</span> g <span class="fu">=</span> <span class="dt">Endo</span> (f <span class="fu">.</span> g)</a>
<a class="sourceLine" id="cb50-6" data-line-number="6">  </a>
<a class="sourceLine" id="cb50-7" data-line-number="7"><span class="kw">instance</span> (<span class="dt">Monoid</span> a, <span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">StarSemiring</span> (<span class="dt">Endo</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb50-8" data-line-number="8">  star (<span class="dt">Endo</span> f) <span class="fu">=</span> <span class="dt">Endo</span> converge <span class="kw">where</span></a>
<a class="sourceLine" id="cb50-9" data-line-number="9">    converge x <span class="fu">=</span> x <span class="fu">&lt;&gt;</span> (<span class="kw">if</span> y <span class="fu">==</span> mempty <span class="kw">then</span> y <span class="kw">else</span> converge y) <span class="kw">where</span></a>
<a class="sourceLine" id="cb50-10" data-line-number="10">      y <span class="fu">=</span> f x</a></code></pre></div>
<p>Here’s something interesting: there’s a similarity here to the semiring for church numerals. In fact, as far as I can tell, the functions are <em>exactly</em> the same when applied to endomorphisms of endomorphisms. To the extent that you could define church numerals with something as simple as this:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb51-1" data-line-number="1"><span class="kw">type</span> <span class="dt">ChurchEndoNat</span> <span class="fu">=</span> forall a<span class="fu">.</span> <span class="dt">Endo</span> (<span class="dt">Endo</span> a)</a></code></pre></div>
<p>And it works!</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb52-1" data-line-number="1">two,<span class="ot"> three ::</span> <span class="dt">ChurchEndoNat</span></a>
<a class="sourceLine" id="cb52-2" data-line-number="2">two <span class="fu">=</span> one <span class="fu">&lt;+&gt;</span> one</a>
<a class="sourceLine" id="cb52-3" data-line-number="3">three <span class="fu">=</span> one <span class="fu">&lt;+&gt;</span> two</a>
<a class="sourceLine" id="cb52-4" data-line-number="4"></a>
<a class="sourceLine" id="cb52-5" data-line-number="5"><span class="ot">unChurch ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">ChurchEndoNat</span> <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb52-6" data-line-number="6">unChurch f <span class="fu">=</span> appEndo (appEndo f (<span class="dt">Endo</span> (<span class="dv">1</span><span class="fu">+</span>))) <span class="dv">0</span></a></code></pre></div>
<div class="sourceCode" id="cb53"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell"><a class="sourceLine" id="cb53-1" data-line-number="1">unChurch (two <span class="fu">&lt;.&gt;</span> three)</a>
<a class="sourceLine" id="cb53-2" data-line-number="2"><span class="dv">6</span></a></code></pre></div>
<h2 id="regex">Regex</h2>
<p>One of the most important applications (and a source of much of the notation) is regular expressions. In fact, the free semiring looks like a haskell datatype for regular expressions:</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb54-1" data-line-number="1"><span class="kw">data</span> <span class="dt">FreeStar</span> a</a>
<a class="sourceLine" id="cb54-2" data-line-number="2"> <span class="fu">=</span> <span class="dt">Gen</span> a</a>
<a class="sourceLine" id="cb54-3" data-line-number="3"> <span class="fu">|</span> <span class="dt">Zer</span></a>
<a class="sourceLine" id="cb54-4" data-line-number="4"> <span class="fu">|</span> <span class="dt">One</span></a>
<a class="sourceLine" id="cb54-5" data-line-number="5"> <span class="fu">|</span> <span class="dt">FreeStar</span> a <span class="fu">:&lt;+&gt;</span> <span class="dt">FreeStar</span> a</a>
<a class="sourceLine" id="cb54-6" data-line-number="6"> <span class="fu">|</span> <span class="dt">FreeStar</span> a <span class="fu">:&lt;.&gt;</span> <span class="dt">FreeStar</span> a</a>
<a class="sourceLine" id="cb54-7" data-line-number="7"> <span class="fu">|</span> <span class="dt">Star</span> (<span class="dt">FreeStar</span> a)</a>
<a class="sourceLine" id="cb54-8" data-line-number="8"></a>
<a class="sourceLine" id="cb54-9" data-line-number="9"><span class="kw">instance</span> <span class="dt">Semiring</span> (<span class="dt">FreeStar</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb54-10" data-line-number="10">  (<span class="fu">&lt;+&gt;</span>) <span class="fu">=</span> (<span class="fu">:&lt;+&gt;</span>)</a>
<a class="sourceLine" id="cb54-11" data-line-number="11">  (<span class="fu">&lt;.&gt;</span>) <span class="fu">=</span> (<span class="fu">:&lt;.&gt;</span>)</a>
<a class="sourceLine" id="cb54-12" data-line-number="12">  zero <span class="fu">=</span> <span class="dt">Zer</span></a>
<a class="sourceLine" id="cb54-13" data-line-number="13">  one <span class="fu">=</span> <span class="dt">One</span></a>
<a class="sourceLine" id="cb54-14" data-line-number="14">  </a>
<a class="sourceLine" id="cb54-15" data-line-number="15"><span class="kw">instance</span> <span class="dt">StarSemiring</span> (<span class="dt">FreeStar</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb54-16" data-line-number="16">  star <span class="fu">=</span> <span class="dt">Star</span></a>
<a class="sourceLine" id="cb54-17" data-line-number="17">  </a>
<a class="sourceLine" id="cb54-18" data-line-number="18"><span class="ot">interpret ::</span> <span class="dt">StarSemiring</span> s <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> s) <span class="ot">-&gt;</span> <span class="dt">FreeStar</span> a <span class="ot">-&gt;</span> s</a>
<a class="sourceLine" id="cb54-19" data-line-number="19">interpret f <span class="fu">=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb54-20" data-line-number="20">  <span class="dt">Gen</span> x <span class="ot">-&gt;</span> f x</a>
<a class="sourceLine" id="cb54-21" data-line-number="21">  <span class="dt">Zer</span> <span class="ot">-&gt;</span> zero</a>
<a class="sourceLine" id="cb54-22" data-line-number="22">  <span class="dt">One</span> <span class="ot">-&gt;</span> one</a>
<a class="sourceLine" id="cb54-23" data-line-number="23">  l <span class="fu">:&lt;+&gt;</span> r <span class="ot">-&gt;</span> interpret f l <span class="fu">&lt;+&gt;</span> interpret f r</a>
<a class="sourceLine" id="cb54-24" data-line-number="24">  l <span class="fu">:&lt;.&gt;</span> r <span class="ot">-&gt;</span> interpret f l <span class="fu">&lt;.&gt;</span> interpret f r</a>
<a class="sourceLine" id="cb54-25" data-line-number="25">  <span class="dt">Star</span> x <span class="ot">-&gt;</span> star (interpret f x)</a></code></pre></div>
<p>Then, interpreting the regex is as simple as writing an interpreter (with some help from <code class="sourceCode haskell"><span class="dt">Endo</span></code>):</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb55-1" data-line-number="1"><span class="ot">asRegex ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> <span class="dt">FreeStar</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb55-2" data-line-number="2">asRegex fs <span class="fu">=</span> any null <span class="fu">.</span> appEndo (interpret f fs) <span class="fu">.</span> pure <span class="kw">where</span></a>
<a class="sourceLine" id="cb55-3" data-line-number="3">  f p <span class="fu">=</span> <span class="dt">Endo</span> <span class="fu">.</span> mapMaybe <span class="fu">$</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb55-4" data-line-number="4">    (x<span class="fu">:</span>xs) <span class="fu">|</span> p x <span class="ot">-&gt;</span> <span class="dt">Just</span> xs</a>
<a class="sourceLine" id="cb55-5" data-line-number="5">    _ <span class="ot">-&gt;</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb55-6" data-line-number="6"></a>
<a class="sourceLine" id="cb55-7" data-line-number="7"><span class="ot">char&#39; ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">FreeStar</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb55-8" data-line-number="8">char&#39; c <span class="fu">=</span> <span class="dt">Gen</span> (c<span class="fu">==</span>)</a></code></pre></div>
<p>Actually, you don’t need the free version at all!</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb56-1" data-line-number="1"><span class="ot">runRegex ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> <span class="dt">Endo</span> [[a]] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb56-2" data-line-number="2">runRegex fs <span class="fu">=</span> any null <span class="fu">.</span> appEndo fs <span class="fu">.</span> pure</a>
<a class="sourceLine" id="cb56-3" data-line-number="3"></a>
<a class="sourceLine" id="cb56-4" data-line-number="4"><span class="ot">char ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Endo</span> [[a]]</a>
<a class="sourceLine" id="cb56-5" data-line-number="5">char c <span class="fu">=</span> <span class="dt">Endo</span> <span class="fu">.</span> mapMaybe <span class="fu">$</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb56-6" data-line-number="6">  (x<span class="fu">:</span>xs) <span class="fu">|</span> c <span class="fu">==</span> x <span class="ot">-&gt;</span> <span class="dt">Just</span> xs</a>
<a class="sourceLine" id="cb56-7" data-line-number="7">  _ <span class="ot">-&gt;</span> <span class="dt">Nothing</span>  </a></code></pre></div>
<p>With some <code class="sourceCode haskell"><span class="fu">-</span><span class="dt">XOverloadedStrings</span></code> magic, you get a pretty nice interface:</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb57-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">IsString</span> (<span class="dt">Endo</span> [<span class="dt">String</span>]) <span class="kw">where</span></a>
<a class="sourceLine" id="cb57-2" data-line-number="2">  fromString <span class="fu">=</span> mul <span class="fu">.</span> map char <span class="fu">.</span> reverse</a>
<a class="sourceLine" id="cb57-3" data-line-number="3">  </a>
<a class="sourceLine" id="cb57-4" data-line-number="4"><span class="ot">(&lt;^&gt;) ::</span> <span class="dt">Semiring</span> s <span class="ot">=&gt;</span> s <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> s</a>
<a class="sourceLine" id="cb57-5" data-line-number="5">(<span class="fu">&lt;^&gt;</span>) <span class="fu">=</span> flip (<span class="fu">&lt;.&gt;</span>)</a>
<a class="sourceLine" id="cb57-6" data-line-number="6"></a>
<a class="sourceLine" id="cb57-7" data-line-number="7"><span class="ot">greet ::</span> <span class="dt">Endo</span> [<span class="dt">String</span>]</a>
<a class="sourceLine" id="cb57-8" data-line-number="8">greet <span class="fu">=</span> <span class="st">&quot;H&quot;</span> <span class="fu">&lt;^&gt;</span> (<span class="st">&quot;a&quot;</span> <span class="fu">&lt;+&gt;</span> <span class="st">&quot;e&quot;</span>) <span class="fu">&lt;^&gt;</span> <span class="st">&quot;llo&quot;</span></a></code></pre></div>
<div class="sourceCode" id="cb58"><pre class="sourceCode haskell literate example hidden_source"><code class="sourceCode haskell"><a class="sourceLine" id="cb58-1" data-line-number="1"><span class="fu">:</span>set <span class="fu">-</span><span class="dt">XOverloadedStrings</span></a></code></pre></div>
<div class="sourceCode" id="cb59"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell"><a class="sourceLine" id="cb59-1" data-line-number="1">runRegex greet <span class="st">&quot;Hello&quot;</span></a>
<a class="sourceLine" id="cb59-2" data-line-number="2"><span class="dt">True</span></a></code></pre></div>
<div class="sourceCode" id="cb60"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell"><a class="sourceLine" id="cb60-1" data-line-number="1">runRegex greet <span class="st">&quot;Hallo&quot;</span></a>
<a class="sourceLine" id="cb60-2" data-line-number="2"><span class="dt">True</span></a></code></pre></div>
<div class="sourceCode" id="cb61"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell"><a class="sourceLine" id="cb61-1" data-line-number="1">runRegex greet <span class="st">&quot;Halo&quot;</span></a>
<a class="sourceLine" id="cb61-2" data-line-number="2"><span class="dt">False</span></a></code></pre></div>
<h2 id="efficiency">Efficiency</h2>
<p>Of course, that’s about as slow as it gets when it comes to regexes. A faster representation is a <a href="https://swtch.com/~rsc/regexp/regexp1.html">nondeterministic finite automaton</a>. One such implementation in haskell is <a href="https://github.com/Gabriel439/slides/blob/master/regex/regex.md">Gabriel Gonzalez’s</a>.</p>
<p>The regex type in that example can be immediately made to conform to <code class="sourceCode haskell"><span class="dt">Semiring</span></code> and <code class="sourceCode haskell"><span class="dt">StarSemiring</span></code>. However, it might be more interesting to translate the <em>implementation</em> into using semirings. The type of a regex looks like this:</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb62-1" data-line-number="1"><span class="kw">type</span> <span class="dt">State</span> <span class="fu">=</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb62-2" data-line-number="2"></a>
<a class="sourceLine" id="cb62-3" data-line-number="3">{<span class="ot"> _startingStates         ::</span> <span class="dt">Set</span> <span class="dt">State</span></a>
<a class="sourceLine" id="cb62-4" data-line-number="4">,<span class="ot"> _transitionFunction     ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="ot">-&gt;</span> <span class="dt">Set</span> <span class="dt">State</span></a>
<a class="sourceLine" id="cb62-5" data-line-number="5">,<span class="ot"> _acceptingStates        ::</span> <span class="dt">Set</span> <span class="dt">State</span> }</a></code></pre></div>
<p>The set data structure jumps out as an opportunity to sub in arbitrary semirings.Swapping in the <code class="sourceCode haskell"><span class="dt">GeneralMap</span></code> is reasonably easy:</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb63-1" data-line-number="1"><span class="kw">type</span> <span class="dt">State</span> <span class="fu">=</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb63-2" data-line-number="2"></a>
<a class="sourceLine" id="cb63-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Regex</span> i s <span class="fu">=</span> <span class="dt">Regex</span></a>
<a class="sourceLine" id="cb63-4" data-line-number="4">  {<span class="ot"> _numberOfStates     ::</span> <span class="dt">Int</span> </a>
<a class="sourceLine" id="cb63-5" data-line-number="5">  ,<span class="ot"> _startingStates     ::</span> <span class="dt">GeneralMap</span> <span class="dt">State</span> s</a>
<a class="sourceLine" id="cb63-6" data-line-number="6">  ,<span class="ot"> _transitionFunction ::</span> i <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> <span class="dt">State</span> s</a>
<a class="sourceLine" id="cb63-7" data-line-number="7">  ,<span class="ot"> _acceptingStates    ::</span> <span class="dt">GeneralMap</span> <span class="dt">State</span> s }</a>
<a class="sourceLine" id="cb63-8" data-line-number="8"></a>
<a class="sourceLine" id="cb63-9" data-line-number="9"><span class="ot">isEnd ::</span> <span class="dt">Semiring</span> s <span class="ot">=&gt;</span> <span class="dt">Regex</span> i s <span class="ot">-&gt;</span> s</a>
<a class="sourceLine" id="cb63-10" data-line-number="10">isEnd (<span class="dt">Regex</span> _ as _ bs) <span class="fu">=</span> add (intersection as bs)</a>
<a class="sourceLine" id="cb63-11" data-line-number="11"></a>
<a class="sourceLine" id="cb63-12" data-line-number="12"><span class="ot">match ::</span> <span class="dt">Regex</span> <span class="dt">Char</span> (<span class="dt">Add</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb63-13" data-line-number="13">match r <span class="fu">=</span> getAdd <span class="fu">.</span> isEnd <span class="fu">.</span> foldl&#39; run r <span class="kw">where</span></a>
<a class="sourceLine" id="cb63-14" data-line-number="14">  run (<span class="dt">Regex</span> n (<span class="dt">GeneralMap</span> as) f bs) i <span class="fu">=</span> <span class="dt">Regex</span> n as&#39; f bs</a>
<a class="sourceLine" id="cb63-15" data-line-number="15">    <span class="kw">where</span> as&#39; <span class="fu">=</span> mconcat [ fmap (v<span class="fu">&lt;.&gt;</span>) (f i k)  <span class="fu">|</span> (k,v) <span class="ot">&lt;-</span> Map.assocs as ]</a>
<a class="sourceLine" id="cb63-16" data-line-number="16"></a>
<a class="sourceLine" id="cb63-17" data-line-number="17"></a>
<a class="sourceLine" id="cb63-18" data-line-number="18"><span class="ot">satisfy ::</span> <span class="dt">Semiring</span> s <span class="ot">=&gt;</span> (i <span class="ot">-&gt;</span> s) <span class="ot">-&gt;</span> <span class="dt">Regex</span> i (<span class="dt">Add</span> s)</a>
<a class="sourceLine" id="cb63-19" data-line-number="19">satisfy predicate <span class="fu">=</span> <span class="dt">Regex</span> <span class="dv">2</span> as f bs</a>
<a class="sourceLine" id="cb63-20" data-line-number="20">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb63-21" data-line-number="21">    as <span class="fu">=</span> singleton <span class="dv">0</span></a>
<a class="sourceLine" id="cb63-22" data-line-number="22">    bs <span class="fu">=</span> singleton <span class="dv">1</span></a>
<a class="sourceLine" id="cb63-23" data-line-number="23"></a>
<a class="sourceLine" id="cb63-24" data-line-number="24">    f i <span class="dv">0</span> <span class="fu">=</span> assoc <span class="dv">1</span> (predicate i) mempty</a>
<a class="sourceLine" id="cb63-25" data-line-number="25">    f _ _ <span class="fu">=</span> mempty</a>
<a class="sourceLine" id="cb63-26" data-line-number="26"></a>
<a class="sourceLine" id="cb63-27" data-line-number="27"><span class="ot">once ::</span> <span class="dt">Eq</span> i <span class="ot">=&gt;</span> i <span class="ot">-&gt;</span> <span class="dt">Regex</span> i (<span class="dt">Add</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb63-28" data-line-number="28">once x <span class="fu">=</span> satisfy (<span class="fu">==</span> x)</a>
<a class="sourceLine" id="cb63-29" data-line-number="29"></a>
<a class="sourceLine" id="cb63-30" data-line-number="30"><span class="ot">shift ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> <span class="dt">State</span> s <span class="ot">-&gt;</span> <span class="dt">GeneralMap</span> <span class="dt">State</span> s</a>
<a class="sourceLine" id="cb63-31" data-line-number="31">shift n <span class="fu">=</span> <span class="dt">GeneralMap</span> <span class="fu">.</span> Map.fromAscList <span class="fu">.</span> (map<span class="fu">.</span>first) (<span class="fu">+</span> n) <span class="fu">.</span> Map.toAscList <span class="fu">.</span> getMap</a>
<a class="sourceLine" id="cb63-32" data-line-number="32"></a>
<a class="sourceLine" id="cb63-33" data-line-number="33"><span class="kw">instance</span> (<span class="dt">Semiring</span> s, <span class="dt">Monoid</span> s) <span class="ot">=&gt;</span> <span class="dt">Semiring</span> (<span class="dt">Regex</span> i s) <span class="kw">where</span></a>
<a class="sourceLine" id="cb63-34" data-line-number="34"></a>
<a class="sourceLine" id="cb63-35" data-line-number="35">  one <span class="fu">=</span> <span class="dt">Regex</span> <span class="dv">1</span> (singleton <span class="dv">0</span>) (\_ _ <span class="ot">-&gt;</span> mempty) (singleton <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb63-36" data-line-number="36">  zero <span class="fu">=</span> <span class="dt">Regex</span> <span class="dv">0</span> mempty (\_ _ <span class="ot">-&gt;</span> mempty) mempty</a>
<a class="sourceLine" id="cb63-37" data-line-number="37"></a>
<a class="sourceLine" id="cb63-38" data-line-number="38">  <span class="dt">Regex</span> nL asL fL bsL <span class="fu">&lt;+&gt;</span> <span class="dt">Regex</span> nR asR fR bsR <span class="fu">=</span> <span class="dt">Regex</span> n as f bs</a>
<a class="sourceLine" id="cb63-39" data-line-number="39">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb63-40" data-line-number="40">      n  <span class="fu">=</span> nL <span class="fu">+</span> nR</a>
<a class="sourceLine" id="cb63-41" data-line-number="41">      as <span class="fu">=</span> mappend asL (shift nL asR)</a>
<a class="sourceLine" id="cb63-42" data-line-number="42">      bs <span class="fu">=</span> mappend bsL (shift nL bsR)</a>
<a class="sourceLine" id="cb63-43" data-line-number="43">      f i s <span class="fu">|</span> s <span class="fu">&lt;</span> nL    <span class="fu">=</span> fL i s</a>
<a class="sourceLine" id="cb63-44" data-line-number="44">            <span class="fu">|</span> otherwise <span class="fu">=</span> shift nL (fR i (s <span class="fu">-</span> nL))</a>
<a class="sourceLine" id="cb63-45" data-line-number="45"></a>
<a class="sourceLine" id="cb63-46" data-line-number="46">  <span class="dt">Regex</span> nL asL fL bsL <span class="fu">&lt;.&gt;</span> <span class="dt">Regex</span> nR asR fR bsR <span class="fu">=</span> <span class="dt">Regex</span> n as f bs <span class="kw">where</span></a>
<a class="sourceLine" id="cb63-47" data-line-number="47"></a>
<a class="sourceLine" id="cb63-48" data-line-number="48">    n <span class="fu">=</span> nL <span class="fu">+</span> nR</a>
<a class="sourceLine" id="cb63-49" data-line-number="49"></a>
<a class="sourceLine" id="cb63-50" data-line-number="50">    as <span class="fu">=</span> <span class="kw">let</span> ss <span class="fu">=</span> add (intersection asL bsL)</a>
<a class="sourceLine" id="cb63-51" data-line-number="51">         <span class="kw">in</span> mappend asL (fmap (ss<span class="fu">&lt;.&gt;</span>) (shift nL asR))</a>
<a class="sourceLine" id="cb63-52" data-line-number="52"></a>
<a class="sourceLine" id="cb63-53" data-line-number="53">    f i s <span class="fu">=</span></a>
<a class="sourceLine" id="cb63-54" data-line-number="54">        <span class="kw">if</span> s <span class="fu">&lt;</span> nL</a>
<a class="sourceLine" id="cb63-55" data-line-number="55">        <span class="kw">then</span> <span class="kw">let</span> ss <span class="fu">=</span> add (intersection r bsL)</a>
<a class="sourceLine" id="cb63-56" data-line-number="56">             <span class="kw">in</span> mappend r (fmap (ss<span class="fu">&lt;.&gt;</span>) (shift nL asR))</a>
<a class="sourceLine" id="cb63-57" data-line-number="57">        <span class="kw">else</span> shift nL (fR i (s <span class="fu">-</span> nL))</a>
<a class="sourceLine" id="cb63-58" data-line-number="58">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb63-59" data-line-number="59">        r <span class="fu">=</span> fL i s</a>
<a class="sourceLine" id="cb63-60" data-line-number="60">    bs <span class="fu">=</span> shift nL bsR</a>
<a class="sourceLine" id="cb63-61" data-line-number="61"></a>
<a class="sourceLine" id="cb63-62" data-line-number="62"><span class="kw">instance</span> (<span class="dt">StarSemiring</span> s, <span class="dt">Monoid</span> s) <span class="ot">=&gt;</span> <span class="dt">StarSemiring</span> (<span class="dt">Regex</span> i s) <span class="kw">where</span></a>
<a class="sourceLine" id="cb63-63" data-line-number="63">  star (<span class="dt">Regex</span> n as f bs) <span class="fu">=</span> <span class="dt">Regex</span> n as f&#39; as</a>
<a class="sourceLine" id="cb63-64" data-line-number="64">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb63-65" data-line-number="65">      f&#39; i s <span class="fu">=</span></a>
<a class="sourceLine" id="cb63-66" data-line-number="66">          <span class="kw">let</span> r <span class="fu">=</span> f i s</a>
<a class="sourceLine" id="cb63-67" data-line-number="67">              ss <span class="fu">=</span> add (intersection r bs)</a>
<a class="sourceLine" id="cb63-68" data-line-number="68">          <span class="kw">in</span> mappend r (fmap (ss<span class="fu">&lt;.&gt;</span>) as)</a>
<a class="sourceLine" id="cb63-69" data-line-number="69"></a>
<a class="sourceLine" id="cb63-70" data-line-number="70">  plus (<span class="dt">Regex</span> n as f bs) <span class="fu">=</span> <span class="dt">Regex</span> n as f&#39; bs</a>
<a class="sourceLine" id="cb63-71" data-line-number="71">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb63-72" data-line-number="72">      f&#39; i s <span class="fu">=</span></a>
<a class="sourceLine" id="cb63-73" data-line-number="73">          <span class="kw">let</span> r <span class="fu">=</span> f i s</a>
<a class="sourceLine" id="cb63-74" data-line-number="74">              ss <span class="fu">=</span> add (intersection r bs)</a>
<a class="sourceLine" id="cb63-75" data-line-number="75">          <span class="kw">in</span> mappend r (fmap (ss<span class="fu">&lt;.&gt;</span>) as)</a>
<a class="sourceLine" id="cb63-76" data-line-number="76"></a>
<a class="sourceLine" id="cb63-77" data-line-number="77"></a>
<a class="sourceLine" id="cb63-78" data-line-number="78"><span class="kw">instance</span> <span class="dt">IsString</span> (<span class="dt">Regex</span> <span class="dt">Char</span> (<span class="dt">Add</span> <span class="dt">Bool</span>)) <span class="kw">where</span></a>
<a class="sourceLine" id="cb63-79" data-line-number="79">  fromString <span class="fu">=</span> mul <span class="fu">.</span> map once</a></code></pre></div>
<p>This begins to show some of the real power of using semirings and covectors. We have a normal regular expression implementation when we use the covector over bools. Use the probability semiring, and you’ve got probabilistic parsing.</p>
<p>Swap in the <a href="https://ncatlab.org/nlab/show/max-plus+algebra">tropical semiring</a>: a semiring over the reals where addition is the max function, and multiplication is addition of reals. Now you’ve got a depth-first parser.</p>
<p>That’s how you might swap in different interpretations. How about swapping in different <em>implementations</em>? Well, there might be some use to swapping in the <a href="https://en.wikipedia.org/wiki/CYK_algorithm">CYK algorithm</a>, or the Gauss-Jordan-Floyd-Warshall-McNaughton-Yamada algorithm <span class="citation" data-cites="oconnor_very_2011">(O’Connor <a href="#ref-oconnor_very_2011">2011</a>)</span>.</p>
<p>Alternatively, you can swap in the underlying data structure. Instead of a map, if you use an integer (each bit being a value, the keys being the bit position), you have a super-fast implementation (and the final implementation used in the original example). Finally, you could use a different representation of the state transfer function: a matrix.</p>
<h2 id="square-matrices">Square Matrices</h2>
<p>A square matrix can be understood as a map from pairs of indices to values. This lets us use it to represent the state transfer function. Take, for instance, a regular expression with three possible states. Its state transfer function might look like this:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">transfer</mtext><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd columnalign="left"><mn>1</mn><mspace width="1.0em"></mspace></mtd><mtd columnalign="left"><mo stretchy="false" form="prefix">{</mo><mn>2</mn><mo>,</mo><mn>3</mn><mo stretchy="false" form="postfix">}</mo></mtd></mtr><mtr><mtd columnalign="left"><mn>2</mn><mspace width="1.0em"></mspace></mtd><mtd columnalign="left"><mo stretchy="false" form="prefix">{</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo></mtd></mtr><mtr><mtd columnalign="left"><mn>3</mn><mspace width="1.0em"></mspace></mtd><mtd columnalign="left"><mi>∅</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\text{transfer} = \begin{cases}
1 \quad &amp; \{ 2, 3 \} \\
2 \quad &amp; \{ 1 \} \\
3 \quad &amp; \emptyset
\end{cases}</annotation></semantics></math></p>
<p>It has the type of:</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb64-1" data-line-number="1"><span class="dt">State</span> <span class="ot">-&gt;</span> <span class="dt">Set</span> <span class="dt">State</span></a></code></pre></div>
<p>Where <code class="sourceCode haskell"><span class="dt">State</span></code> is an integer. You can represent the set as a vector, where each position is a key, and each value is whether or not that key is present:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">transfer</mtext><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd columnalign="left"><mn>1</mn><mspace width="1.0em"></mspace></mtd><mtd columnalign="left"><mn>0</mn></mtd><mtd columnalign="left"><mn>1</mn></mtd><mtd columnalign="left"><mn>1</mn></mtd></mtr><mtr><mtd columnalign="left"><mn>2</mn><mspace width="1.0em"></mspace></mtd><mtd columnalign="left"><mn>1</mn></mtd><mtd columnalign="left"><mn>0</mn></mtd><mtd columnalign="left"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="left"><mn>3</mn><mspace width="1.0em"></mspace></mtd><mtd columnalign="left"><mn>0</mn></mtd><mtd columnalign="left"><mn>0</mn></mtd><mtd columnalign="left"><mn>0</mn></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\text{transfer} = \begin{cases}
1 \quad &amp; 0 &amp; 1 &amp; 1 \\
2 \quad &amp; 1 &amp; 0 &amp; 0 \\
3 \quad &amp; 0 &amp; 0 &amp; 0 \end{cases}</annotation></semantics></math></p>
<p>Then, the matrix representation is obvious:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">transfer</mtext><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center"><mn>0</mn></mtd><mtd columnalign="center"><mn>1</mn></mtd><mtd columnalign="center"><mn>1</mn></mtd></mtr><mtr><mtd columnalign="center"><mn>1</mn></mtd><mtd columnalign="center"><mn>0</mn></mtd><mtd columnalign="center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center"><mn>0</mn></mtd><mtd columnalign="center"><mn>0</mn></mtd><mtd columnalign="center"><mn>0</mn></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\text{transfer} = \left( \begin{array}{ccc}
0 &amp; 1 &amp; 1 \\
1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 \end{array} \right)</annotation></semantics></math></p>
<p>This is the semiring of square matrices. It is, of course, yet <em>another</em> covector. The “keys” are the transfers: <code class="sourceCode haskell"><span class="dv">1</span> <span class="ot">-&gt;</span> <span class="dv">2</span></code> or <code class="sourceCode haskell"><span class="dv">2</span> <span class="ot">-&gt;</span> <span class="dv">3</span></code>, represented by the indices of the matrix. The “values” are whether or not that transfer is permitted.</p>
<p>The algorithms for the usual semiring operations on matrices like this are well-known and well-optimized. I haven’t yet benchmarked them in Haskell using the matrix libraries, so I don’t know how they compare to the other approaches. In the meantime, there’s an elegant list-based implementation in <span class="citation" data-cites="dolan_fun_2013">Dolan (<a href="#ref-dolan_fun_2013">2013</a>)</span>:</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb65-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Matrix</span> a <span class="fu">=</span> <span class="dt">Scalar</span> a</a>
<a class="sourceLine" id="cb65-2" data-line-number="2">              <span class="fu">|</span> <span class="dt">Matrix</span> [[a]]</a>
<a class="sourceLine" id="cb65-3" data-line-number="3">              </a>
<a class="sourceLine" id="cb65-4" data-line-number="4"><span class="ot">mjoin ::</span> (<span class="dt">Matrix</span> a, <span class="dt">Matrix</span> a, <span class="dt">Matrix</span> a, <span class="dt">Matrix</span> a) <span class="ot">-&gt;</span> <span class="dt">Matrix</span> a</a>
<a class="sourceLine" id="cb65-5" data-line-number="5">mjoin (<span class="dt">Matrix</span> ws, <span class="dt">Matrix</span> xs, <span class="dt">Matrix</span> ys, <span class="dt">Matrix</span> zs) <span class="fu">=</span></a>
<a class="sourceLine" id="cb65-6" data-line-number="6">  <span class="dt">Matrix</span> ((zipWith (<span class="fu">++</span>) ws xs) <span class="fu">++</span> (zipWith (<span class="fu">++</span>) ys zs))</a>
<a class="sourceLine" id="cb65-7" data-line-number="7">  </a>
<a class="sourceLine" id="cb65-8" data-line-number="8"><span class="ot">msplit ::</span> <span class="dt">Matrix</span> a <span class="ot">-&gt;</span> (<span class="dt">Matrix</span> a, <span class="dt">Matrix</span> a, <span class="dt">Matrix</span> a, <span class="dt">Matrix</span> a)</a>
<a class="sourceLine" id="cb65-9" data-line-number="9">msplit (<span class="dt">Matrix</span> (row<span class="fu">:</span>rows)) <span class="fu">=</span> </a>
<a class="sourceLine" id="cb65-10" data-line-number="10">  (<span class="dt">Matrix</span> [[first]], <span class="dt">Matrix</span> [top]</a>
<a class="sourceLine" id="cb65-11" data-line-number="11">  ,<span class="dt">Matrix</span> left,      <span class="dt">Matrix</span> rest )</a>
<a class="sourceLine" id="cb65-12" data-line-number="12">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb65-13" data-line-number="13">    (first<span class="fu">:</span>top) <span class="fu">=</span> row</a>
<a class="sourceLine" id="cb65-14" data-line-number="14">    (left,rest) <span class="fu">=</span> unzip (map (\(x<span class="fu">:</span>xs) <span class="ot">-&gt;</span> ([x],xs)) rows)</a>
<a class="sourceLine" id="cb65-15" data-line-number="15">    </a>
<a class="sourceLine" id="cb65-16" data-line-number="16"><span class="kw">instance</span> <span class="dt">Semiring</span> a <span class="ot">=&gt;</span> <span class="dt">Semiring</span> (<span class="dt">Matrix</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb65-17" data-line-number="17">  zero <span class="fu">=</span> <span class="dt">Scalar</span> zero</a>
<a class="sourceLine" id="cb65-18" data-line-number="18">  one <span class="fu">=</span> <span class="dt">Scalar</span> one</a>
<a class="sourceLine" id="cb65-19" data-line-number="19">  <span class="dt">Scalar</span> x <span class="fu">&lt;+&gt;</span> <span class="dt">Scalar</span> y <span class="fu">=</span> <span class="dt">Scalar</span> (x <span class="fu">&lt;+&gt;</span> y)</a>
<a class="sourceLine" id="cb65-20" data-line-number="20">  <span class="dt">Matrix</span> x <span class="fu">&lt;+&gt;</span> <span class="dt">Matrix</span> y <span class="fu">=</span></a>
<a class="sourceLine" id="cb65-21" data-line-number="21">    <span class="dt">Matrix</span> (zipWith (zipWith (<span class="fu">&lt;+&gt;</span>)) x y)</a>
<a class="sourceLine" id="cb65-22" data-line-number="22">  <span class="dt">Scalar</span> x <span class="fu">&lt;+&gt;</span> m <span class="fu">=</span> m <span class="fu">&lt;+&gt;</span> <span class="dt">Scalar</span> x</a>
<a class="sourceLine" id="cb65-23" data-line-number="23">  <span class="dt">Matrix</span> [[x]] <span class="fu">&lt;+&gt;</span> <span class="dt">Scalar</span> y <span class="fu">=</span> <span class="dt">Matrix</span> [[x <span class="fu">&lt;+&gt;</span> y]]</a>
<a class="sourceLine" id="cb65-24" data-line-number="24">  x <span class="fu">&lt;+&gt;</span> y <span class="fu">=</span> mjoin (first <span class="fu">&lt;+&gt;</span> y, top, left, rest <span class="fu">&lt;+&gt;</span> y)</a>
<a class="sourceLine" id="cb65-25" data-line-number="25">    <span class="kw">where</span> (first, top, left, rest) <span class="fu">=</span> msplit x</a>
<a class="sourceLine" id="cb65-26" data-line-number="26">  <span class="dt">Scalar</span> x <span class="fu">&lt;.&gt;</span> <span class="dt">Scalar</span> y <span class="fu">=</span> <span class="dt">Scalar</span> (x <span class="fu">&lt;.&gt;</span> y)</a>
<a class="sourceLine" id="cb65-27" data-line-number="27">  <span class="dt">Scalar</span> x <span class="fu">&lt;.&gt;</span> <span class="dt">Matrix</span> y <span class="fu">=</span> <span class="dt">Matrix</span> ((map<span class="fu">.</span>map) (x<span class="fu">&lt;.&gt;</span>) y)</a>
<a class="sourceLine" id="cb65-28" data-line-number="28">  <span class="dt">Matrix</span> x <span class="fu">&lt;.&gt;</span> <span class="dt">Scalar</span> y <span class="fu">=</span> <span class="dt">Matrix</span> ((map<span class="fu">.</span>map) (<span class="fu">&lt;.&gt;</span>y) x)</a>
<a class="sourceLine" id="cb65-29" data-line-number="29">  <span class="dt">Matrix</span> x <span class="fu">&lt;.&gt;</span> <span class="dt">Matrix</span> y <span class="fu">=</span> </a>
<a class="sourceLine" id="cb65-30" data-line-number="30">    <span class="dt">Matrix</span> [ [ foldl1 (<span class="fu">&lt;+&gt;</span>) (zipWith (<span class="fu">&lt;.&gt;</span>) row col) <span class="fu">|</span> col <span class="ot">&lt;-</span> cols ] </a>
<a class="sourceLine" id="cb65-31" data-line-number="31">           <span class="fu">|</span> row <span class="ot">&lt;-</span> x ] <span class="kw">where</span> cols <span class="fu">=</span> transpose y</a>
<a class="sourceLine" id="cb65-32" data-line-number="32"></a>
<a class="sourceLine" id="cb65-33" data-line-number="33"><span class="kw">instance</span> <span class="dt">StarSemiring</span> a <span class="ot">=&gt;</span> <span class="dt">StarSemiring</span> (<span class="dt">Matrix</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb65-34" data-line-number="34">  star (<span class="dt">Matrix</span> [[x]]) <span class="fu">=</span> <span class="dt">Matrix</span> [[star x]]</a>
<a class="sourceLine" id="cb65-35" data-line-number="35">  star m <span class="fu">=</span> mjoin (first&#39; <span class="fu">&lt;+&gt;</span> top&#39; <span class="fu">&lt;.&gt;</span> rest&#39; <span class="fu">&lt;.&gt;</span> left&#39;</a>
<a class="sourceLine" id="cb65-36" data-line-number="36">                 ,top&#39; <span class="fu">&lt;.&gt;</span> rest&#39;, rest&#39; <span class="fu">&lt;.&gt;</span> left&#39;, rest&#39;)</a>
<a class="sourceLine" id="cb65-37" data-line-number="37">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb65-38" data-line-number="38">      (first, top, left, rest) <span class="fu">=</span> msplit m</a>
<a class="sourceLine" id="cb65-39" data-line-number="39">      first&#39; <span class="fu">=</span> star first</a>
<a class="sourceLine" id="cb65-40" data-line-number="40">      top&#39; <span class="fu">=</span> first&#39; <span class="fu">&lt;.&gt;</span> top</a>
<a class="sourceLine" id="cb65-41" data-line-number="41">      left&#39; <span class="fu">=</span> left <span class="fu">&lt;.&gt;</span> first&#39;</a>
<a class="sourceLine" id="cb65-42" data-line-number="42">      rest&#39; <span class="fu">=</span> star (rest <span class="fu">&lt;+&gt;</span> left&#39; <span class="fu">&lt;.&gt;</span> top)</a></code></pre></div>
<h2 id="permutation-parsing">Permutation parsing</h2>
<p>A lot of the use from semirings comes from “attaching” them to other values. Attaching a semiring to effects (in the form of an applicative) can give you <em>repetition</em> of those effects. The excellent <a href="http://hackage.haskell.org/package/ReplicateEffects">ReplicateEffects</a> library explores this concept in depth.</p>
<p>It’s based on this type:</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb66-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Replicate</span> a b</a>
<a class="sourceLine" id="cb66-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb66-3" data-line-number="3">  <span class="fu">|</span> <span class="dt">Cons</span> (<span class="dt">Maybe</span> b) (<span class="dt">Replicate</span> a (a <span class="ot">-&gt;</span> b))</a></code></pre></div>
<p>This type can be made to conform to <code class="sourceCode haskell"><span class="dt">Semiring</span></code> (and <code class="sourceCode haskell"><span class="dt">Starsemiring</span></code>, etc) trivially.</p>
<p>In the simplest case, it has the same behaviour as <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Monad.html#v:replicateM"><code class="sourceCode haskell">replicateM</code></a>. Even the more complex combinators, like <code class="sourceCode haskell">atLeast</code>, can be built on <code class="sourceCode haskell"><span class="dt">Alternative</span></code>:</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb67-1" data-line-number="1"><span class="ot">atLeast ::</span> <span class="dt">Alternative</span> f <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f [a]</a>
<a class="sourceLine" id="cb67-2" data-line-number="2">atLeast m f <span class="fu">=</span> go (max <span class="dv">0</span> m) <span class="kw">where</span></a>
<a class="sourceLine" id="cb67-3" data-line-number="3">  go <span class="dv">0</span> <span class="fu">=</span> many f</a>
<a class="sourceLine" id="cb67-4" data-line-number="4">  go n <span class="fu">=</span> liftA2 (<span class="fu">:</span>) f (go (n<span class="fu">-</span><span class="dv">1</span>))</a>
<a class="sourceLine" id="cb67-5" data-line-number="5">  </a>
<a class="sourceLine" id="cb67-6" data-line-number="6"><span class="ot">atMost ::</span> <span class="dt">Alternative</span> f <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f [a]</a>
<a class="sourceLine" id="cb67-7" data-line-number="7">atMost m f <span class="fu">=</span> go (max <span class="dv">0</span> m) <span class="kw">where</span></a>
<a class="sourceLine" id="cb67-8" data-line-number="8">  go <span class="dv">0</span> <span class="fu">=</span> pure []</a>
<a class="sourceLine" id="cb67-9" data-line-number="9">  go n <span class="fu">=</span> liftA2 (<span class="fu">:</span>) f (go (n<span class="fu">-</span><span class="dv">1</span>)) <span class="fu">&lt;|&gt;</span> pure []</a></code></pre></div>
<p>There are two main benefits over using the standard alternative implementation. First, you can choose greedy or lazy evaluation of the effects <em>after</em> the replication is built.</p>
<p>Secondly, the <em>order</em> of the effects doesn’t have to be specified. This allows you to execute permutations of the effects, in a permutation parser, for instance. The permutation is totally decoupled from the declaration of the repetition (it’s in a totally separate library, in fact: <a href="http://hackage.haskell.org/package/PermuteEffects">PermuteEffects</a>). Its construction is reminiscent of the <a href="https://hackage.haskell.org/package/free-4.12.4/docs/Control-Alternative-Free.html#t:AltF">free alternative</a>.</p>
<p>Having the replicate type conform to <code class="sourceCode haskell"><span class="dt">Semiring</span></code> is all well and good: what I’m interested in is seeing if its implementation is another semiring-based object in disguise. I’ll revisit this in a later post.</p>
<h2 id="algebraic-search">Algebraic Search</h2>
<p>List comprehension notation is one of my all-time favourite bits of syntactic sugar. It seems almost <em>too</em> declarative to have a reasonable implementation strategy. The vast majority of the time, it actually works in a sensible way. There are exceptions, though. Take a reasonable definition of a list of Pythagorean triples:</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb68-1" data-line-number="1">[ (x,y,z) <span class="fu">|</span> x <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span>], y <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span>], z <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span>], x<span class="fu">*</span>x <span class="fu">+</span> y<span class="fu">*</span>y <span class="fu">==</span> z<span class="fu">*</span>z ]</a></code></pre></div>
<p>This expression will diverge without yielding a single triple. It will search through every possible value for <code class="sourceCode haskell">z</code> before incrementing either <code class="sourceCode haskell">x</code> or <code class="sourceCode haskell">y</code>. Since there are infinite values for <code class="sourceCode haskell">z</code>, it will never find a triple. In other words, vanilla list comprehensions in Haskell perform depth-first search.</p>
<p>In order to express other kinds of search (either breadth-first or depth-bounded), different monads are needed. These monads are explored in <span class="citation" data-cites="fischer_reinventing_2009">Fischer (<a href="#ref-fischer_reinventing_2009">2009</a>)</span> and <span class="citation" data-cites="spivey_algebras_2009">Spivey (<a href="#ref-spivey_algebras_2009">2009</a>)</span>.</p>
<p>You can actually use the <em>exact</em> same notation as above with arbitrary alternative monads using <code class="sourceCode haskell"><span class="fu">-</span><span class="dt">XMonadComprehensions</span></code> and <code class="sourceCode haskell"><span class="fu">-</span><span class="dt">XOverloadedLists</span></code>.</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb69-1" data-line-number="1"><span class="ot">trips ::</span> ( <span class="dt">Alternative</span> m</a>
<a class="sourceLine" id="cb69-2" data-line-number="2">         , <span class="dt">Monad</span> m</a>
<a class="sourceLine" id="cb69-3" data-line-number="3">         , <span class="dt">IsList</span> (m <span class="dt">Integer</span>)</a>
<a class="sourceLine" id="cb69-4" data-line-number="4">         , <span class="dt">Enum</span> (<span class="dt">Item</span> (m <span class="dt">Integer</span>))</a>
<a class="sourceLine" id="cb69-5" data-line-number="5">         , <span class="dt">Num</span> (<span class="dt">Item</span> (m <span class="dt">Integer</span>)))</a>
<a class="sourceLine" id="cb69-6" data-line-number="6">      <span class="ot">=&gt;</span> m (<span class="dt">Integer</span>,<span class="dt">Integer</span>,<span class="dt">Integer</span>)</a>
<a class="sourceLine" id="cb69-7" data-line-number="7">trips <span class="fu">=</span> [ (x,y,z) <span class="fu">|</span> x <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span>], y <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span>], z <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span>], x<span class="fu">*</span>x <span class="fu">+</span> y<span class="fu">*</span>y <span class="fu">==</span> z<span class="fu">*</span>z ]</a></code></pre></div>
<p>So then, here’s the challenge: swap in different <code class="sourceCode haskell">m</code>s via a type annotation, and prevent <code class="sourceCode haskell">trips</code> from diverging before getting any triples.</p>
<p>As one example, here’s some code adapted from <span class="citation" data-cites="fischer_reinventing_2009">Fischer (<a href="#ref-fischer_reinventing_2009">2009</a>)</span>:</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb70-1" data-line-number="1"><span class="kw">instance</span> (<span class="dt">Monoid</span> r, <span class="dt">Applicative</span> m) <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">ContT</span> r m a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb70-2" data-line-number="2">  mempty <span class="fu">=</span> <span class="dt">ContT</span> (const (pure mempty))</a>
<a class="sourceLine" id="cb70-3" data-line-number="3">  mappend (<span class="dt">ContT</span> f) (<span class="dt">ContT</span> g) <span class="fu">=</span> <span class="dt">ContT</span> (\x <span class="ot">-&gt;</span> liftA2 mappend (f x) (g x))</a>
<a class="sourceLine" id="cb70-4" data-line-number="4">  </a>
<a class="sourceLine" id="cb70-5" data-line-number="5"><span class="kw">newtype</span> <span class="dt">List</span> a <span class="fu">=</span> <span class="dt">List</span> </a>
<a class="sourceLine" id="cb70-6" data-line-number="6">  {<span class="ot"> runList ::</span> forall m<span class="fu">.</span> <span class="dt">Monoid</span> m <span class="ot">=&gt;</span> <span class="dt">Cont</span> m a } <span class="kw">deriving</span> <span class="dt">Functor</span></a>
<a class="sourceLine" id="cb70-7" data-line-number="7"></a>
<a class="sourceLine" id="cb70-8" data-line-number="8"><span class="kw">instance</span> <span class="dt">Foldable</span> <span class="dt">List</span> <span class="kw">where</span> foldMap <span class="fu">=</span> flip (runCont<span class="fu">.</span>runList)</a>
<a class="sourceLine" id="cb70-9" data-line-number="9">  </a>
<a class="sourceLine" id="cb70-10" data-line-number="10"><span class="kw">instance</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">List</span> a) <span class="kw">where</span> show <span class="fu">=</span> show <span class="fu">.</span> foldr (<span class="fu">:</span>) []</a>
<a class="sourceLine" id="cb70-11" data-line-number="11"></a>
<a class="sourceLine" id="cb70-12" data-line-number="12"><span class="kw">instance</span> <span class="dt">Monoid</span> (<span class="dt">List</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb70-13" data-line-number="13">  mappend (<span class="dt">List</span> x) (<span class="dt">List</span> y) <span class="fu">=</span> <span class="dt">List</span> (mappend x y)</a>
<a class="sourceLine" id="cb70-14" data-line-number="14">  mempty <span class="fu">=</span> <span class="dt">List</span> mempty</a>
<a class="sourceLine" id="cb70-15" data-line-number="15">  </a>
<a class="sourceLine" id="cb70-16" data-line-number="16"><span class="kw">instance</span> <span class="dt">Monoid</span> a <span class="ot">=&gt;</span> <span class="dt">Semiring</span> (<span class="dt">List</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb70-17" data-line-number="17">  zero <span class="fu">=</span> mempty</a>
<a class="sourceLine" id="cb70-18" data-line-number="18">  (<span class="fu">&lt;+&gt;</span>) <span class="fu">=</span> mappend</a>
<a class="sourceLine" id="cb70-19" data-line-number="19">  (<span class="fu">&lt;.&gt;</span>) <span class="fu">=</span> liftA2 mappend</a>
<a class="sourceLine" id="cb70-20" data-line-number="20">  one <span class="fu">=</span> pure mempty</a>
<a class="sourceLine" id="cb70-21" data-line-number="21"></a>
<a class="sourceLine" id="cb70-22" data-line-number="22"><span class="ot">bfs ::</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb70-23" data-line-number="23">bfs <span class="fu">=</span> toList <span class="fu">.</span> fold <span class="fu">.</span> levels <span class="fu">.</span> anyOf</a>
<a class="sourceLine" id="cb70-24" data-line-number="24"></a>
<a class="sourceLine" id="cb70-25" data-line-number="25"><span class="kw">newtype</span> <span class="dt">Levels</span> a <span class="fu">=</span> <span class="dt">Levels</span> {<span class="ot"> levels ::</span> [<span class="dt">List</span> a] } <span class="kw">deriving</span> <span class="dt">Functor</span></a>
<a class="sourceLine" id="cb70-26" data-line-number="26"></a>
<a class="sourceLine" id="cb70-27" data-line-number="27"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Levels</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb70-28" data-line-number="28">  pure x <span class="fu">=</span> <span class="dt">Levels</span> [pure x]</a>
<a class="sourceLine" id="cb70-29" data-line-number="29">  <span class="dt">Levels</span> fs <span class="fu">&lt;*&gt;</span> <span class="dt">Levels</span> xs <span class="fu">=</span> <span class="dt">Levels</span> [ f <span class="fu">&lt;*&gt;</span> x <span class="fu">|</span> f <span class="ot">&lt;-</span> fs, x <span class="ot">&lt;-</span> xs ]</a>
<a class="sourceLine" id="cb70-30" data-line-number="30">  </a>
<a class="sourceLine" id="cb70-31" data-line-number="31"><span class="kw">instance</span> <span class="dt">Alternative</span> <span class="dt">Levels</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb70-32" data-line-number="32">  empty <span class="fu">=</span> <span class="dt">Levels</span> []</a>
<a class="sourceLine" id="cb70-33" data-line-number="33">  <span class="dt">Levels</span> x <span class="fu">&lt;|&gt;</span> <span class="dt">Levels</span> y <span class="fu">=</span> <span class="dt">Levels</span> (mempty <span class="fu">:</span> merge x y)</a>
<a class="sourceLine" id="cb70-34" data-line-number="34"></a>
<a class="sourceLine" id="cb70-35" data-line-number="35"><span class="kw">instance</span> <span class="dt">IsList</span> (<span class="dt">List</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb70-36" data-line-number="36">  <span class="kw">type</span> <span class="dt">Item</span> (<span class="dt">List</span> a) <span class="fu">=</span> a</a>
<a class="sourceLine" id="cb70-37" data-line-number="37">  fromList <span class="fu">=</span> anyOf</a>
<a class="sourceLine" id="cb70-38" data-line-number="38">  toList <span class="fu">=</span> foldr (<span class="fu">:</span>) []</a>
<a class="sourceLine" id="cb70-39" data-line-number="39">  </a>
<a class="sourceLine" id="cb70-40" data-line-number="40"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">List</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb70-41" data-line-number="41">  pure x <span class="fu">=</span> <span class="dt">List</span> (pure x)</a>
<a class="sourceLine" id="cb70-42" data-line-number="42">  (<span class="fu">&lt;*&gt;</span>) <span class="fu">=</span> ap</a>
<a class="sourceLine" id="cb70-43" data-line-number="43"></a>
<a class="sourceLine" id="cb70-44" data-line-number="44"><span class="kw">instance</span> <span class="dt">Alternative</span> <span class="dt">List</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb70-45" data-line-number="45">  empty <span class="fu">=</span> mempty</a>
<a class="sourceLine" id="cb70-46" data-line-number="46">  (<span class="fu">&lt;|&gt;</span>) <span class="fu">=</span> mappend</a>
<a class="sourceLine" id="cb70-47" data-line-number="47"></a>
<a class="sourceLine" id="cb70-48" data-line-number="48"><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">List</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb70-49" data-line-number="49">  x <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> foldMap f x</a>
<a class="sourceLine" id="cb70-50" data-line-number="50"></a>
<a class="sourceLine" id="cb70-51" data-line-number="51"><span class="ot">anyOf ::</span> (<span class="dt">Alternative</span> m, <span class="dt">Foldable</span> f) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> m a</a>
<a class="sourceLine" id="cb70-52" data-line-number="52">anyOf <span class="fu">=</span> getAlt <span class="fu">.</span> foldMap (<span class="dt">Alt</span> <span class="fu">.</span> pure)</a>
<a class="sourceLine" id="cb70-53" data-line-number="53"></a>
<a class="sourceLine" id="cb70-54" data-line-number="54"><span class="ot">merge ::</span> [<span class="dt">List</span> a] <span class="ot">-&gt;</span> [<span class="dt">List</span> a] <span class="ot">-&gt;</span> [<span class="dt">List</span> a]</a>
<a class="sourceLine" id="cb70-55" data-line-number="55">merge []      ys    <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb70-56" data-line-number="56">merge xs      []    <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb70-57" data-line-number="57">merge (x<span class="fu">:</span>xs) (y<span class="fu">:</span>ys) <span class="fu">=</span> mappend x y <span class="fu">:</span> merge xs ys</a></code></pre></div>
<div class="sourceCode" id="cb71"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell"><a class="sourceLine" id="cb71-1" data-line-number="1">take <span class="dv">3</span> (bfs trips)</a>
<a class="sourceLine" id="cb71-2" data-line-number="2">[(<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>),(<span class="dv">4</span>,<span class="dv">3</span>,<span class="dv">5</span>),(<span class="dv">6</span>,<span class="dv">8</span>,<span class="dv">10</span>)]</a></code></pre></div>
<p>The only relevance to semirings is the merge function. The semiring over lists is the semiring over polynomials:</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb72-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Semiring</span> a <span class="ot">=&gt;</span> <span class="dt">Semiring</span> [a] <span class="kw">where</span></a>
<a class="sourceLine" id="cb72-2" data-line-number="2">  one <span class="fu">=</span> [one]</a>
<a class="sourceLine" id="cb72-3" data-line-number="3">  zero <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb72-4" data-line-number="4">  [] <span class="fu">&lt;+&gt;</span> ys <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb72-5" data-line-number="5">  xs <span class="fu">&lt;+&gt;</span> [] <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb72-6" data-line-number="6">  (x<span class="fu">:</span>xs) <span class="fu">&lt;+&gt;</span> (y<span class="fu">:</span>ys) <span class="fu">=</span> (x <span class="fu">&lt;+&gt;</span> y) <span class="fu">:</span> (xs <span class="fu">&lt;+&gt;</span> ys)</a>
<a class="sourceLine" id="cb72-7" data-line-number="7">  [] <span class="fu">&lt;.&gt;</span> _ <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb72-8" data-line-number="8">  _ <span class="fu">&lt;.&gt;</span> [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb72-9" data-line-number="9">  (x<span class="fu">:</span>xs) <span class="fu">&lt;.&gt;</span> (y<span class="fu">:</span>ys) <span class="fu">=</span></a>
<a class="sourceLine" id="cb72-10" data-line-number="10">    (x <span class="fu">&lt;.&gt;</span> y) <span class="fu">:</span> (map (x <span class="fu">&lt;.&gt;</span>) ys <span class="fu">&lt;+&gt;</span> map (<span class="fu">&lt;.&gt;</span> y) xs <span class="fu">&lt;+&gt;</span> (xs <span class="fu">&lt;.&gt;</span> ys))</a></code></pre></div>
<p>The <code class="sourceCode haskell"><span class="fu">&lt;+&gt;</span></code> is the same as the <code class="sourceCode haskell">merge</code> function. I think the <code class="sourceCode haskell"><span class="fu">&lt;.&gt;</span></code> might be a more valid definition of the <code class="sourceCode haskell"><span class="fu">&lt;*&gt;</span></code> function, also.</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb73-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Levels</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb73-2" data-line-number="2">  pure x <span class="fu">=</span> <span class="dt">Levels</span> [pure x]</a>
<a class="sourceLine" id="cb73-3" data-line-number="3">  <span class="dt">Levels</span> [] <span class="fu">&lt;*&gt;</span> _ <span class="fu">=</span> <span class="dt">Levels</span> []</a>
<a class="sourceLine" id="cb73-4" data-line-number="4">  _ <span class="fu">&lt;*&gt;</span> <span class="dt">Levels</span> [] <span class="fu">=</span> <span class="dt">Levels</span> []</a>
<a class="sourceLine" id="cb73-5" data-line-number="5">  <span class="dt">Levels</span> (f<span class="fu">:</span>fs) <span class="fu">&lt;*&gt;</span> <span class="dt">Levels</span> (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="dt">Levels</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb73-6" data-line-number="6">    (f <span class="fu">&lt;*&gt;</span> x) <span class="fu">:</span> levels (<span class="dt">Levels</span> (fmap (f <span class="fu">&lt;*&gt;</span>) xs) </a>
<a class="sourceLine" id="cb73-7" data-line-number="7">             <span class="fu">&lt;|&gt;</span> <span class="dt">Levels</span> (fmap (<span class="fu">&lt;*&gt;</span> x) fs)</a>
<a class="sourceLine" id="cb73-8" data-line-number="8">             <span class="fu">&lt;|&gt;</span> (<span class="dt">Levels</span> fs <span class="fu">&lt;*&gt;</span> <span class="dt">Levels</span> xs))</a></code></pre></div>
<h2 id="conclusion">Conclusion</h2>
<p>I’ve only scratched the surface of this abstraction. There are several other interesting semirings: polynomials, logs, Viterbi, Łukasiewicz, languages, multisets, bidirectional parsers, etc. Hopefully I’ll eventually be able to put this stuff into a library or something. In the meantime, I definitely will write some posts on the application to context-free parsing, bidirectional parsing (I just read <span class="citation" data-cites="breitner_showcasing_2016">Breitner (<a href="#ref-breitner_showcasing_2016">2016</a>)</span>) and search.</p>
<h2 id="references" class="unnumbered">References</h2>
<div id="refs" class="references">
<div id="ref-boom_further_1981">
<p>Boom, H. J. 1981. “Further thoughts on Abstracto.” <em>Working Paper ELC-9, IFIP WG 2.1</em>. <a href="http://www.kestrel.edu/home/people/meertens/publications/papers/Abstracto_reader.pdf" class="uri">http://www.kestrel.edu/home/people/meertens/publications/papers/Abstracto_reader.pdf</a>.</p>
</div>
<div id="ref-breitner_showcasing_2016">
<p>Breitner, Joachim. 2016. “Showcasing Applicative.” <em>Joachim Breitner’s Blog</em>. <a href="http://www.joachim-breitner.de/blog/710-Showcasing_Applicative" class="uri">http://www.joachim-breitner.de/blog/710-Showcasing_Applicative</a>.</p>
</div>
<div id="ref-doel_free_2015">
<p>Doel, Dan. 2015. “Free Monoids in Haskell.” <em>The Comonad.Reader</em>. <a href="http://comonad.com/reader/2015/free-monoids-in-haskell/" class="uri">http://comonad.com/reader/2015/free-monoids-in-haskell/</a>.</p>
</div>
<div id="ref-dolan_fun_2013">
<p>Dolan, Stephen. 2013. “Fun with semirings: A functional pearl on the abuse of linear algebra.” In, 48:101. ACM Press. doi:<a href="https://doi.org/10.1145/2500365.2500613">10.1145/2500365.2500613</a>. <a href="https://www.cl.cam.ac.uk/~sd601/papers/semirings.pdf" class="uri">https://www.cl.cam.ac.uk/~sd601/papers/semirings.pdf</a>.</p>
</div>
<div id="ref-droste_semirings_2009">
<p>Droste, Manfred, and Werner Kuich. 2009. “Semirings and Formal Power Series.” In <em>Handbook of Weighted Automata</em>, ed by. Manfred Droste, Werner Kuich, and Heiko Vogler, 1:3–28. Monographs in Theoretical Computer Science. An EATCS Series. Berlin, Heidelberg: Springer Berlin Heidelberg. <a href="http://staff.mmcs.sfedu.ru/~ulysses/Edu/Marktoberdorf_2009/working_material/Esparsa/Kuich.%20Semirings%20and%20FPS.pdf">http://staff.mmcs.sfedu.ru/~ulysses/Edu/Marktoberdorf_2009/working_material/Esparsa/Kuich.%20Semirings%20and%20FPS.pdf</a>.</p>
</div>
<div id="ref-erwig_functional_2006">
<p>Erwig, Martin, and Steve Kollmansberger. 2006. “Functional pearls: Probabilistic functional programming in Haskell.” <em>Journal of Functional Programming</em> 16 (1): 21–34. doi:<a href="https://doi.org/10.1017/S0956796805005721">10.1017/S0956796805005721</a>. <a href="http://web.engr.oregonstate.edu/~erwig/papers/abstracts.html#JFP06a" class="uri">http://web.engr.oregonstate.edu/~erwig/papers/abstracts.html#JFP06a</a>.</p>
</div>
<div id="ref-fischer_reinventing_2009">
<p>Fischer, Sebastian. 2009. “Reinventing Haskell Backtracking.” In <em>Informatik 2009, Im Fokus das Leben (ATPS’09)</em>. GI Edition. <a href="http://www-ps.informatik.uni-kiel.de/~sebf/data/pub/atps09.pdf" class="uri">http://www-ps.informatik.uni-kiel.de/~sebf/data/pub/atps09.pdf</a>.</p>
</div>
<div id="ref-hirschowitz_modules_2010">
<p>Hirschowitz, André, and Marco Maggesi. 2010. “Modules over monads and initial semantics.” <em>Information and Computation</em> 208 (5). Special Issue: 14th Workshop on Logic, Language, Information and Computation (WoLLIC 2007) (May): 545–564. doi:<a href="https://doi.org/10.1016/j.ic.2009.07.003">10.1016/j.ic.2009.07.003</a>. <a href="https://pdfs.semanticscholar.org/3e0c/c79e8cda9246cb954da6fd8aaaa394fecdc3.pdf" class="uri">https://pdfs.semanticscholar.org/3e0c/c79e8cda9246cb954da6fd8aaaa394fecdc3.pdf</a>.</p>
</div>
<div id="ref-kidd_build_2007">
<p>Kidd, Eric. 2007. “Build your own probability monads.” <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.129.9502&amp;rep=rep1&amp;type=pdf" class="uri">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.129.9502&amp;rep=rep1&amp;type=pdf</a>.</p>
</div>
<div id="ref-kmett_free_2011">
<p>Kmett, Edward. 2011a. “Free Monads for Less (Part 2 of 3): Yoneda.” <em>The Comonad.Reader</em>. <a href="http://comonad.com/reader/2011/free-monads-for-less-2/" class="uri">http://comonad.com/reader/2011/free-monads-for-less-2/</a>.</p>
</div>
<div id="ref-kmett_modules_2011">
<p>———. 2011b. “Modules and Functional Linear Functionals.” <em>The Comonad.Reader</em>. <a href="http://comonad.com/reader/2011/free-modules-and-functional-linear-functionals/" class="uri">http://comonad.com/reader/2011/free-modules-and-functional-linear-functionals/</a>.</p>
</div>
<div id="ref-larsen_memory_2011">
<p>Larsen, Ken Friis. 2011. “Memory Efficient Implementation of Probability Monads.” <a href="http://www.diku.dk/~kflarsen/t/ProbMonad-unpublished.pdf" class="uri">http://www.diku.dk/~kflarsen/t/ProbMonad-unpublished.pdf</a>.</p>
</div>
<div id="ref-oconnor_very_2011">
<p>O’Connor, Russell. 2011. “A Very General Method of Computing Shortest Paths.” <em>Russell O’Connor’s Blog</em>. <a href="http://r6.ca/blog/20110808T035622Z.html" class="uri">http://r6.ca/blog/20110808T035622Z.html</a>.</p>
</div>
<div id="ref-piponi_monad_2009">
<p>Piponi, Dan. 2009. “A Monad for Combinatorial Search with Heuristics.” <em>A Neighborhood of Infinity</em>. <a href="http://blog.sigfpe.com/2009/07/monad-for-combinatorial-search-with.html" class="uri">http://blog.sigfpe.com/2009/07/monad-for-combinatorial-search-with.html</a>.</p>
</div>
<div id="ref-rivas_monoids_2015">
<p>Rivas, Exequiel, Mauro Jaskelioff, and Tom Schrijvers. 2015. “From monoids to near-semirings: The essence of MonadPlus and Alternative.” In <em>Proceedings of the 17th International Symposium on Principles and Practice of Declarative Programming</em>, 196–207. ACM. doi:<a href="https://doi.org/10.1145/2790449.2790514">10.1145/2790449.2790514</a>. <a href="http://www.fceia.unr.edu.ar/~mauro/pubs/FromMonoidstoNearsemirings.pdf" class="uri">http://www.fceia.unr.edu.ar/~mauro/pubs/FromMonoidstoNearsemirings.pdf</a>.</p>
</div>
<div id="ref-spivey_algebras_2009">
<p>Spivey, J. Michael. 2009. “Algebras for combinatorial search.” <em>Journal of Functional Programming</em> 19 (3-4) (July): 469–487. doi:<a href="https://doi.org/10.1017/S0956796809007321">10.1017/S0956796809007321</a>. <a href="https://pdfs.semanticscholar.org/db3e/373bb6e7e7837ebc524da0a25903958554ed.pdf" class="uri">https://pdfs.semanticscholar.org/db3e/373bb6e7e7837ebc524da0a25903958554ed.pdf</a>.</p>
</div>
</div>
]]></description>
    <pubDate>Thu, 17 Nov 2016 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2016-11-17-semirings-lhs.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Probability Trees</title>
    <link>https://doisinkidney.com/posts/2016-09-30-prob-trees-lhs.html</link>
    <description><![CDATA[<div class="info">
    Posted on September 30, 2016
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Probability.html">Probability</a>
    
</div>

<div class="sourceCode" id="cb1"><pre class="sourceCode haskell literate hidden_source"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">{-# language DeriveFunctor, DeriveFoldable #-}</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="ot">{-# language PatternSynonyms, ViewPatterns #-}</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="kw">module</span> <span class="dt">ProbTree</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="kw">import</span> <span class="dt">Data.Monoid</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map.Strict</span> <span class="kw">as</span> <span class="dt">Map</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"><span class="kw">import</span> <span class="dt">Data.Map.Strict</span> (<span class="dt">Map</span>)</a>
<a class="sourceLine" id="cb1-9" data-line-number="9"><span class="kw">import</span> <span class="dt">Control.Arrow</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10"><span class="kw">import</span> <span class="dt">Data.Ratio</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11"><span class="kw">import</span> <span class="dt">Data.Foldable</span></a></code></pre></div>
<p>Previously, I tried to figure out how to make the probability monad more “listy”. I read a little more about the topic <span class="citation" data-cites="erwig_functional_2006 kidd_build_2007">(especially Erwig and Kollmansberger <a href="#ref-erwig_functional_2006">2006</a>; and Kidd <a href="#ref-kidd_build_2007">2007</a>)</span>.</p>
<p>I then thought about what a probability monad would look like if it was based on other data structures. I feel like the standard version really wants to be:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">ProperProb</span> a <span class="fu">=</span> <span class="dt">ProperProb</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  {<span class="ot"> yes ::</span> <span class="dt">Map</span> a (<span class="dt">Product</span> <span class="dt">Rational</span>) }</a></code></pre></div>
<p>But of course a monad instance isn’t allowed.</p>
<p>Similar to a map, though, is a binary tree:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">data</span> <span class="dt">BinaryTree</span> a <span class="fu">=</span> <span class="dt">Leaf</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">                  <span class="fu">|</span> <span class="dt">Node</span> (<span class="dt">BinaryTree</span> a) a (<span class="dt">BinaryTree</span> a)</a></code></pre></div>
<p>And it feels better for probability - <em>flatter</em>, somehow. Transmuting it into a probability-thing:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Odds</span> a <span class="fu">=</span> <span class="dt">Certain</span> a</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">            <span class="fu">|</span> <span class="dt">Choice</span> (<span class="dt">Odds</span> a) <span class="dt">Rational</span> (<span class="dt">Odds</span> a)</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">            <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Functor</span>, <span class="dt">Foldable</span>, <span class="dt">Show</span>)</a></code></pre></div>
<p>That looks good to me. A choice between two different branches feels more natural than a choice between a head and a tail.</p>
<p>The fold is similar to before, with an unfold for good measure:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">foldOdds ::</span> (b <span class="ot">-&gt;</span> <span class="dt">Rational</span> <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">foldOdds f b <span class="fu">=</span> r <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  r (<span class="dt">Certain</span> x) <span class="fu">=</span> b x</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">  r (<span class="dt">Choice</span> xs p ys) <span class="fu">=</span> f (r xs) p (r ys)</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">  </a>
<a class="sourceLine" id="cb5-6" data-line-number="6"><span class="ot">unfoldOdds ::</span> (b <span class="ot">-&gt;</span> <span class="dt">Either</span> a (b,<span class="dt">Rational</span>,b)) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Odds</span> a</a>
<a class="sourceLine" id="cb5-7" data-line-number="7">unfoldOdds f <span class="fu">=</span> r <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8">  r b <span class="fu">=</span> <span class="kw">case</span> f b <span class="kw">of</span></a>
<a class="sourceLine" id="cb5-9" data-line-number="9">    <span class="dt">Left</span> a <span class="ot">-&gt;</span> <span class="dt">Certain</span> a</a>
<a class="sourceLine" id="cb5-10" data-line-number="10">    <span class="dt">Right</span> (x,p,y) <span class="ot">-&gt;</span> <span class="dt">Choice</span> (r x) p (r y)</a>
<a class="sourceLine" id="cb5-11" data-line-number="11">  </a>
<a class="sourceLine" id="cb5-12" data-line-number="12"><span class="ot">fi ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb5-13" data-line-number="13">fi <span class="dt">True</span>  t _ <span class="fu">=</span> t</a>
<a class="sourceLine" id="cb5-14" data-line-number="14">fi <span class="dt">False</span> _ f <span class="fu">=</span> f</a></code></pre></div>
<p>I changed the pattern synonym a little:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="ot">unRatio ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Rational</span> <span class="ot">-&gt;</span> (a,a)</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">unRatio <span class="fu">=</span> numerator   <span class="fu">&amp;&amp;&amp;</span> denominator </a>
<a class="sourceLine" id="cb6-4" data-line-number="4">      <span class="fu">&gt;&gt;&gt;</span> fromInteger <span class="fu">***</span> fromInteger</a>
<a class="sourceLine" id="cb6-5" data-line-number="5"></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">pattern n <span class="fu">:%</span> d <span class="ot">&lt;-</span> (unRatio <span class="ot">-&gt;</span> (n,d))</a></code></pre></div>
<p>Then, the <code class="sourceCode haskell">probOf</code> function:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">probOf ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">probOf e <span class="fu">=</span> foldOdds f b <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  b x <span class="fu">=</span> fi (e <span class="fu">==</span> x) <span class="dv">1</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">  f x (n<span class="fu">:%</span>d) y <span class="fu">=</span> (x <span class="fu">*</span> n <span class="fu">+</span> y <span class="fu">*</span> d) <span class="fu">/</span> (n <span class="fu">+</span> d)</a></code></pre></div>
<p>This version doesn’t have the option for short-circuiting on the first value it finds.</p>
<p>For generating from lists, you can try to evenly divide the list among each branch.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">fromListOdds ::</span> (([b], <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Integer</span>) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Odds</span> a)</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">fromListOdds fr e <span class="fu">=</span> r <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  r [] <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">  r xs <span class="fu">=</span> <span class="dt">Just</span> (unfoldOdds f (xs, length xs))</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">  f ([x],_) <span class="fu">=</span> <span class="dt">Left</span> (e x)</a>
<a class="sourceLine" id="cb8-6" data-line-number="6">  f (xs ,n) <span class="fu">=</span> <span class="dt">Right</span> ((ys,l), fr (ys,l) <span class="fu">%</span> fr (zs,r), (zs,r)) <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-7" data-line-number="7">    l <span class="fu">=</span> n <span class="ot">`div`</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8">    r <span class="fu">=</span> n <span class="fu">-</span> l</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">    (ys,zs) <span class="fu">=</span> splitAt l xs</a>
<a class="sourceLine" id="cb8-10" data-line-number="10"></a>
<a class="sourceLine" id="cb8-11" data-line-number="11"><span class="ot">equalOdds ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Odds</span> a)</a>
<a class="sourceLine" id="cb8-12" data-line-number="12">equalOdds <span class="fu">=</span> fromListOdds (fromIntegral <span class="fu">.</span> snd) id</a>
<a class="sourceLine" id="cb8-13" data-line-number="13"></a>
<a class="sourceLine" id="cb8-14" data-line-number="14"><span class="ot">fromDistrib ::</span> [(a,<span class="dt">Integer</span>)] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Odds</span> a)</a>
<a class="sourceLine" id="cb8-15" data-line-number="15">fromDistrib <span class="fu">=</span> fromListOdds (sum <span class="fu">.</span> map snd <span class="fu">.</span> fst) fst</a></code></pre></div>
<p>What’s really nice about this version is the fact that the old <code class="sourceCode haskell">append</code> is just the <code class="sourceCode haskell"><span class="dt">Choice</span></code> constructor, leaving the instances to be really nice:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">flatten ::</span> <span class="dt">Odds</span> (<span class="dt">Odds</span> a) <span class="ot">-&gt;</span> <span class="dt">Odds</span> a</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">flatten <span class="fu">=</span> foldOdds <span class="dt">Choice</span> id</a>
<a class="sourceLine" id="cb9-3" data-line-number="3"></a>
<a class="sourceLine" id="cb9-4" data-line-number="4"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Odds</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  pure <span class="fu">=</span> <span class="dt">Certain</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6">  fs <span class="fu">&lt;*&gt;</span> xs <span class="fu">=</span> flatten (fmap (<span class="fu">&lt;$&gt;</span> xs) fs)</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">  </a>
<a class="sourceLine" id="cb9-8" data-line-number="8"><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Odds</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-9" data-line-number="9">  x <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> flatten (f <span class="fu">&lt;$&gt;</span> x)</a></code></pre></div>
<p>Finally, as a bonus, to remove duplicates:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">lcd ::</span> <span class="dt">Foldable</span> f <span class="ot">=&gt;</span> f <span class="dt">Rational</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">lcd <span class="fu">=</span> foldl&#39; (\a e <span class="ot">-&gt;</span> lcm a (denominator e)) <span class="dv">1</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3"></a>
<a class="sourceLine" id="cb10-4" data-line-number="4"><span class="ot">toDistrib ::</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> [(a,<span class="dt">Integer</span>)]</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">toDistrib <span class="fu">=</span> factorOut <span class="fu">.</span> foldOdds f b <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-6" data-line-number="6">  b x <span class="fu">=</span> [(x,<span class="dv">1</span>)]</a>
<a class="sourceLine" id="cb10-7" data-line-number="7">  f l p r <span class="fu">=</span> (map<span class="fu">.</span>fmap) (n<span class="fu">%</span>t<span class="fu">*</span>) l <span class="fu">++</span> (map<span class="fu">.</span>fmap) (d<span class="fu">%</span>t<span class="fu">*</span>) r <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-8" data-line-number="8">    n <span class="fu">=</span> numerator p</a>
<a class="sourceLine" id="cb10-9" data-line-number="9">    d <span class="fu">=</span> denominator p</a>
<a class="sourceLine" id="cb10-10" data-line-number="10">    t <span class="fu">=</span> n <span class="fu">+</span> d</a>
<a class="sourceLine" id="cb10-11" data-line-number="11">  factorOut xs <span class="fu">=</span> (map<span class="fu">.</span>fmap) (numerator <span class="fu">.</span> (lcd&#39;<span class="fu">*</span>)) xs <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-12" data-line-number="12">    lcd&#39; <span class="fu">=</span> fromIntegral <span class="fu">.</span> lcd <span class="fu">.</span> map snd <span class="fu">$</span> xs</a>
<a class="sourceLine" id="cb10-13" data-line-number="13"></a>
<a class="sourceLine" id="cb10-14" data-line-number="14"><span class="ot">counts ::</span> (<span class="dt">Ord</span> a, <span class="dt">Num</span> n) <span class="ot">=&gt;</span> [(a,n)] <span class="ot">-&gt;</span> [(a,n)]</a>
<a class="sourceLine" id="cb10-15" data-line-number="15">counts <span class="fu">=</span> </a>
<a class="sourceLine" id="cb10-16" data-line-number="16">  Map.assocs <span class="fu">.</span> </a>
<a class="sourceLine" id="cb10-17" data-line-number="17">  Map.fromListWith (<span class="fu">+</span>)</a>
<a class="sourceLine" id="cb10-18" data-line-number="18">      </a>
<a class="sourceLine" id="cb10-19" data-line-number="19"><span class="ot">compress ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Odds</span> a</a>
<a class="sourceLine" id="cb10-20" data-line-number="20">compress xs <span class="fu">=</span> <span class="kw">let</span> <span class="dt">Just</span> ys <span class="fu">=</span> (fromDistrib <span class="fu">.</span> counts <span class="fu">.</span> toDistrib) xs <span class="kw">in</span> ys</a></code></pre></div>
<p>After reading yet more on this, I found that the main issue with the monad is its performance. Two articles in particular: <span class="citation" data-cites="larsen_memory_2011">Larsen (<a href="#ref-larsen_memory_2011">2011</a>)</span>, and <span class="citation" data-cites="scibior_practical_2015">Ścibior, Ghahramani, and Gordon (<a href="#ref-scibior_practical_2015">2015</a>)</span>, refer to a GADT implementation of the monad which maximises laziness.</p>
<h3 id="references" class="unnumbered">References</h3>
<div id="refs" class="references">
<div id="ref-erwig_functional_2006">
<p>Erwig, Martin, and Steve Kollmansberger. 2006. “Functional pearls: Probabilistic functional programming in Haskell.” <em>Journal of Functional Programming</em> 16 (1): 21–34. doi:<a href="https://doi.org/10.1017/S0956796805005721">10.1017/S0956796805005721</a>.</p>
</div>
<div id="ref-kidd_build_2007">
<p>Kidd, Eric. 2007. “Build your own probability monads.”</p>
</div>
<div id="ref-larsen_memory_2011">
<p>Larsen, Ken Friis. 2011. “Memory Efficient Implementation of Probability Monads.”</p>
</div>
<div id="ref-scibior_practical_2015">
<p>Ścibior, Adam, Zoubin Ghahramani, and Andrew D. Gordon. 2015. “Practical Probabilistic Programming with Monads.” In <em>Proceedings of the 2015 ACM SIGPLAN Symposium on Haskell</em>, 50:165–176. Haskell ’15. New York, NY, USA: ACM. doi:<a href="https://doi.org/10.1145/2804302.2804317">10.1145/2804302.2804317</a>.</p>
</div>
</div>
]]></description>
    <pubDate>Fri, 30 Sep 2016 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2016-09-30-prob-trees-lhs.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>A Different Probability Monad</title>
    <link>https://doisinkidney.com/posts/2016-09-27-odds-lhs.html</link>
    <description><![CDATA[<div class="info">
    Posted on September 27, 2016
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Probability.html">Probability</a>
    
</div>

<p>One of the more unusual monads is the “probability monad”:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell literate hidden_source"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">{-# language PatternSynonyms, ViewPatterns #-}</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="ot">{-# language DeriveFunctor, DeriveFoldable #-}</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="ot">{-# language BangPatterns #-}</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="kw">module</span> <span class="dt">Prob</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="kw">import</span> <span class="dt">Control.Arrow</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"><span class="kw">import</span> <span class="dt">Data.Ratio</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9"><span class="kw">import</span> <span class="dt">Data.Foldable</span></a></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Probability</span> a <span class="fu">=</span> <span class="dt">Probability</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  {<span class="ot"> runProb ::</span> [(a,<span class="dt">Rational</span>)] }</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  </a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="kw">data</span> <span class="dt">Coin</span> <span class="fu">=</span> <span class="dt">Heads</span> <span class="fu">|</span> <span class="dt">Tails</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"></a>
<a class="sourceLine" id="cb2-6" data-line-number="6"><span class="ot">toss ::</span> <span class="dt">Probability</span> <span class="dt">Coin</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">toss <span class="fu">=</span> <span class="dt">Probability</span> [(<span class="dt">Heads</span>, <span class="dv">1</span> <span class="fu">%</span> <span class="dv">2</span>), (<span class="dt">Tails</span>, <span class="dv">1</span> <span class="fu">%</span> <span class="dv">2</span>)]</a></code></pre></div>
<p>Although it’s a little inefficient, it’s an elegant representation. I’ve written about it before <a href="2015-08-03-monty-hall.html">here</a>.</p>
<p>It has some notable deficiencies, though. For instance: the user has to constantly check that all the probabilities add up to one. Its list can be empty, which doesn’t make sense. Also, individual outcomes can appear more than once in the same list.</p>
<p>A first go a fixing the problem might look something like this:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Distrib</span> a <span class="fu">=</span> <span class="dt">Distrib</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  {<span class="ot"> runDist ::</span> [(a,<span class="dt">Rational</span>)] }</a>
<a class="sourceLine" id="cb3-3" data-line-number="3"></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="ot">tossProb ::</span> <span class="dt">Distrib</span> <span class="dt">Coin</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">tossProb <span class="fu">=</span> <span class="dt">Distrib</span> [(<span class="dt">Heads</span>, <span class="dv">1</span>), (<span class="dt">Tails</span>, <span class="dv">1</span>)]</a></code></pre></div>
<p>The type is the same as before: it’s the semantics which have changed. The second field of the tuples no longer have to add up to one. The list can still be empty, though, and now finding the probability of, say, the head, looks like this:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">probHead ::</span> <span class="dt">Distrib</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">probHead (<span class="dt">Distrib</span> xs<span class="fu">@</span>((_,p)<span class="fu">:</span>_)) <span class="fu">=</span> p <span class="fu">/</span> sum [ q <span class="fu">|</span> (_,q) <span class="ot">&lt;-</span> xs ]</a></code></pre></div>
<p>Infinite lists aren’t possible, either.</p>
<p>One other way to look at the problem is to mimic the structure of cons-lists. Something like this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Odds</span> a <span class="fu">=</span> <span class="dt">Certainly</span> a</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">            <span class="fu">|</span> <span class="dt">Odds</span> a <span class="dt">Rational</span> (<span class="dt">Odds</span> a)</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">            <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Functor</span>, <span class="dt">Foldable</span>, <span class="dt">Show</span>)</a></code></pre></div>
<p>Here, the <code class="sourceCode haskell"><span class="dt">Odds</span></code> constructor (analogous to <code class="sourceCode haskell">(<span class="fu">:</span>)</code>) contains the betting-style odds of the head element vs. <em>the rest of the list</em>. The coin from before is represented by:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">tossOdds ::</span> <span class="dt">Odds</span> <span class="dt">Coin</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">tossOdds <span class="fu">=</span> <span class="dt">Odds</span> <span class="dt">Heads</span> (<span class="dv">1</span> <span class="fu">%</span> <span class="dv">1</span>) (<span class="dt">Certainly</span> <span class="dt">Tails</span>)</a></code></pre></div>
<p>This representation has tons of nice properties. First, let’s use some pattern-synonym magic for rationals:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1">pattern<span class="ot"> (:%) ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Rational</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">pattern n <span class="fu">:%</span> d <span class="ot">&lt;-</span> (numerator <span class="fu">&amp;&amp;&amp;</span> denominator <span class="ot">-&gt;</span> (n,d)) <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  n <span class="fu">:%</span> d <span class="fu">=</span> n <span class="fu">%</span> d</a></code></pre></div>
<p>Then, finding the probability of the head element is this:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">probHeadOdds ::</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">probHeadOdds (<span class="dt">Certainly</span> _) <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">probHeadOdds (<span class="dt">Odds</span> _ (n <span class="fu">:%</span> d) _) <span class="fu">=</span> n <span class="fu">:%</span> (n <span class="fu">+</span> d)</a></code></pre></div>
<p>The representation can handle infinite lists no problem:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1">probHeadOdds (<span class="dt">Odds</span> <span class="ch">&#39;a&#39;</span> (<span class="dv">1</span> <span class="fu">:%</span> <span class="dv">1</span>) undefined)</a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="dv">1</span> <span class="fu">%</span> <span class="dv">2</span></a></code></pre></div>
<p>Taking the tail preserves semantics, also. To do some more involved manipulation, a fold helper is handy:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">foldOdds ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Rational</span> <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">foldOdds f b <span class="fu">=</span> r <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  r (<span class="dt">Certainly</span> x) <span class="fu">=</span> b x</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">  r (<span class="dt">Odds</span> x p xs) <span class="fu">=</span> f x p (r xs)</a></code></pre></div>
<p>You can use this function to find the probability of a given item:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">probOfEvent ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2">probOfEvent e <span class="fu">=</span> foldOdds f b <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  b x <span class="fu">=</span> <span class="kw">if</span> e <span class="fu">==</span> x <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4">  f x n r <span class="fu">=</span> (<span class="kw">if</span> e <span class="fu">==</span> x <span class="kw">then</span> n <span class="kw">else</span> r) <span class="fu">/</span> (n <span class="fu">+</span> <span class="dv">1</span>)</a></code></pre></div>
<p>This assumes that each item only occurs once. A function which combines multiple events might look like this:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="ot">probOf ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">probOf p <span class="fu">=</span> foldOdds f b <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">  b x <span class="fu">=</span> <span class="kw">if</span> p x <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">  f x n r <span class="fu">=</span> (<span class="kw">if</span> p x <span class="kw">then</span> r <span class="fu">+</span> n <span class="kw">else</span> r) <span class="fu">/</span> (n <span class="fu">+</span> <span class="dv">1</span>)</a></code></pre></div>
<p>Some utility functions to create <code class="sourceCode haskell"><span class="dt">Odds</span></code>:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="ot">equalOdds ::</span> <span class="dt">Foldable</span> f <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Odds</span> a)</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">equalOdds xs <span class="fu">=</span> <span class="kw">case</span> length xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">  <span class="dv">0</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4">  n <span class="ot">-&gt;</span> <span class="dt">Just</span> (foldr f undefined xs (n <span class="fu">-</span> <span class="dv">1</span>)) <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5">    f y a <span class="dv">0</span> <span class="fu">=</span> <span class="dt">Certainly</span> y</a>
<a class="sourceLine" id="cb13-6" data-line-number="6">    f y a n <span class="fu">=</span> <span class="dt">Odds</span> y (<span class="dv">1</span> <span class="fu">%</span> fromIntegral n) (a (n <span class="fu">-</span> <span class="dv">1</span>))</a>
<a class="sourceLine" id="cb13-7" data-line-number="7"></a>
<a class="sourceLine" id="cb13-8" data-line-number="8"><span class="ot">fromDistrib ::</span> [(a,<span class="dt">Integer</span>)] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Odds</span> a)</a>
<a class="sourceLine" id="cb13-9" data-line-number="9">fromDistrib [] <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb13-10" data-line-number="10">fromDistrib xs <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span> f (tot<span class="fu">*</span>lst) xs <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-11" data-line-number="11">  (tot,lst) <span class="fu">=</span> foldl&#39; (\(<span class="fu">!</span>t,_) e <span class="ot">-&gt;</span> (t<span class="fu">+</span>e,e)) (<span class="dv">0</span>,undefined) (map snd xs)</a>
<a class="sourceLine" id="cb13-12" data-line-number="12">  f _ [(x,_)] <span class="fu">=</span> <span class="dt">Certainly</span> x</a>
<a class="sourceLine" id="cb13-13" data-line-number="13">  f n ((x,p)<span class="fu">:</span>xs) <span class="fu">=</span> <span class="dt">Odds</span> x (mp <span class="fu">%</span> np) (f np xs) <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-14" data-line-number="14">    mp <span class="fu">=</span> p <span class="fu">*</span> lst</a>
<a class="sourceLine" id="cb13-15" data-line-number="15">    np <span class="fu">=</span> n <span class="fu">-</span> mp</a>
<a class="sourceLine" id="cb13-16" data-line-number="16">                  </a>
<a class="sourceLine" id="cb13-17" data-line-number="17"><span class="ot">probOfEach ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span></a>
<a class="sourceLine" id="cb13-18" data-line-number="18">probOfEach x xs <span class="fu">=</span> probOf (x<span class="fu">==</span>) xs</a>
<a class="sourceLine" id="cb13-19" data-line-number="19"></a>
<a class="sourceLine" id="cb13-20" data-line-number="20"><span class="ot">propOf ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Rational</span></a>
<a class="sourceLine" id="cb13-21" data-line-number="21">propOf _ [] <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb13-22" data-line-number="22">propOf x xs <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">.</span> uncurry (<span class="fu">%</span>) <span class="fu">$</span></a>
<a class="sourceLine" id="cb13-23" data-line-number="23">  foldl&#39; (\(<span class="fu">!</span>n,<span class="fu">!</span>m) e <span class="ot">-&gt;</span> (<span class="kw">if</span> x <span class="fu">==</span> e <span class="kw">then</span> n<span class="fu">+</span><span class="dv">1</span> <span class="kw">else</span> n, m<span class="fu">+</span><span class="dv">1</span>)) (<span class="dv">0</span>,<span class="dv">0</span>) xs</a></code></pre></div>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell literate prop"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1">propOf x xs <span class="fu">==</span> fmap (probOfEach x) (equalOdds xs)</a></code></pre></div>
<p>And finally, the instances:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="ot">append ::</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Rational</span> <span class="ot">-&gt;</span> <span class="dt">Odds</span> a <span class="ot">-&gt;</span> <span class="dt">Odds</span> a</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">append <span class="fu">=</span> foldOdds f <span class="dt">Odds</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-3" data-line-number="3">  f e r a p ys <span class="fu">=</span> <span class="dt">Odds</span> e ip (a op ys) <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-4" data-line-number="4">    ip <span class="fu">=</span> p <span class="fu">*</span> r <span class="fu">/</span> (p <span class="fu">+</span> r <span class="fu">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">    op <span class="fu">=</span> p <span class="fu">/</span> (r <span class="fu">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb15-6" data-line-number="6"></a>
<a class="sourceLine" id="cb15-7" data-line-number="7"><span class="ot">flatten ::</span> <span class="dt">Odds</span> (<span class="dt">Odds</span> a) <span class="ot">-&gt;</span> <span class="dt">Odds</span> a</a>
<a class="sourceLine" id="cb15-8" data-line-number="8">flatten <span class="fu">=</span> foldOdds append id</a>
<a class="sourceLine" id="cb15-9" data-line-number="9"></a>
<a class="sourceLine" id="cb15-10" data-line-number="10"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Odds</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-11" data-line-number="11">  pure <span class="fu">=</span> <span class="dt">Certainly</span></a>
<a class="sourceLine" id="cb15-12" data-line-number="12">  fs <span class="fu">&lt;*&gt;</span> xs <span class="fu">=</span> flatten (fmap (<span class="fu">&lt;$&gt;</span> xs) fs)</a>
<a class="sourceLine" id="cb15-13" data-line-number="13">  </a>
<a class="sourceLine" id="cb15-14" data-line-number="14"><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Odds</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-15" data-line-number="15">  x <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> flatten (f <span class="fu">&lt;$&gt;</span> x)</a></code></pre></div>
]]></description>
    <pubDate>Tue, 27 Sep 2016 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2016-09-27-odds-lhs.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Revisiting a Trie in Haskell</title>
    <link>https://doisinkidney.com/posts/2016-09-26-revisiting-trie-lhs.html</link>
    <description><![CDATA[<div class="info">
    Posted on September 26, 2016
</div>
<div class="info">
    
        Part 2 of a <a href="/series/tries.html">2-part series on tries</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Data%20Structures.html">Data Structures</a>
    
</div>

<h1 id="conforming-to-foldable">Conforming to Foldable</h1>
<p>When I ended the last post, I had a nice <code class="sourceCode haskell"><span class="dt">Trie</span></code> datatype, with plenty of functions, but I couldn’t get it to conform to the standard Haskell classes. The problem was to do with the type variables in the Trie:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell literate hidden_source"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">{-# language GADTs, FlexibleInstances, TypeFamilies #-}</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="ot">{-# language DeriveFoldable, DeriveFunctor, DeriveTraversable #-}</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="ot">{-# language FunctionalDependencies, FlexibleInstances #-}</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="kw">module</span> <span class="dt">Tries</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map.Strict</span> <span class="kw">as</span> <span class="dt">Map</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"><span class="kw">import</span> <span class="dt">Data.Map.Strict</span> (<span class="dt">Map</span>)</a>
<a class="sourceLine" id="cb1-9" data-line-number="9"><span class="kw">import</span> <span class="dt">Data.Foldable</span> <span class="kw">hiding</span> (toList)</a>
<a class="sourceLine" id="cb1-10" data-line-number="10"><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (lookup)</a>
<a class="sourceLine" id="cb1-11" data-line-number="11"><span class="kw">import</span> <span class="dt">Data.Monoid</span></a>
<a class="sourceLine" id="cb1-12" data-line-number="12"><span class="kw">import</span> <span class="dt">GHC.Exts</span> (<span class="dt">IsList</span>(..))</a></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> <span class="dt">OldTrie</span> a <span class="fu">=</span> <span class="dt">OldTrie</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  {<span class="ot"> otEndHere  ::</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  ,<span class="ot"> otChildren ::</span> <span class="dt">Map</span> a (<span class="dt">OldTrie</span> a) }</a></code></pre></div>
<p>Although the type variable is <code class="sourceCode haskell">a</code>, the trie really contains <em>lists</em> of <code class="sourceCode haskell">a</code>s. At least, that’s what’s reflected in functions like <code class="sourceCode haskell">insert</code>, <code class="sourceCode haskell">member</code>, etc.:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">member ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Ord</span> a) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">OldTrie</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">member <span class="fu">=</span> foldr f otEndHere <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">  f e a <span class="fu">=</span> maybe <span class="dt">False</span> a <span class="fu">.</span> Map.lookup e <span class="fu">.</span> otChildren</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">  </a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="ot">otInsert ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Ord</span> a) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">OldTrie</span> a <span class="ot">-&gt;</span> <span class="dt">OldTrie</span> a</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">otInsert <span class="fu">=</span> foldr f b <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7">  b (<span class="dt">OldTrie</span> _ c) <span class="fu">=</span> <span class="dt">OldTrie</span> <span class="dt">True</span> c</a>
<a class="sourceLine" id="cb3-8" data-line-number="8">  f e a (<span class="dt">OldTrie</span> n c) <span class="fu">=</span> <span class="dt">OldTrie</span> n (Map.alter (<span class="dt">Just</span> <span class="fu">.</span> a <span class="fu">.</span> fold) e c)</a>
<a class="sourceLine" id="cb3-9" data-line-number="9">  </a>
<a class="sourceLine" id="cb3-10" data-line-number="10"><span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">OldTrie</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-11" data-line-number="11">  mempty <span class="fu">=</span> <span class="dt">OldTrie</span> <span class="dt">False</span> mempty</a>
<a class="sourceLine" id="cb3-12" data-line-number="12">  <span class="dt">OldTrie</span> v c <span class="ot">`mappend`</span> <span class="dt">OldTrie</span> t d <span class="fu">=</span> </a>
<a class="sourceLine" id="cb3-13" data-line-number="13">    <span class="dt">OldTrie</span> (v <span class="fu">||</span> t) (Map.unionWith (<span class="fu">&lt;&gt;</span>) c d)</a></code></pre></div>
<p>Realistically, the type which the trie contains is more like:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="dt">Foldable</span> f <span class="ot">=&gt;</span> <span class="dt">Trie</span> (f a)</a></code></pre></div>
<p>That signature strongly hints at GADTs, as was indicated by <a href="http://stackoverflow.com/questions/33469157/foldable-instance-for-a-trie-set">this stackoverflow answer</a>. The particular GADT which is applicable here is this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">data</span> <span class="dt">TrieSet</span> a <span class="kw">where</span> <span class="dt">TrieSet</span><span class="ot"> ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Map</span> a (<span class="dt">TrieSet</span> [a]) <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> [a]</a></code></pre></div>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell literate hidden_source"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">tsEndHere ::</span> <span class="dt">TrieSet</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">tsEndHere (<span class="dt">TrieSet</span> e _) <span class="fu">=</span> e</a>
<a class="sourceLine" id="cb6-3" data-line-number="3"></a>
<a class="sourceLine" id="cb6-4" data-line-number="4"><span class="ot">tsChildren ::</span> <span class="dt">TrieSet</span> [a] <span class="ot">-&gt;</span> <span class="dt">Map</span> a (<span class="dt">TrieSet</span> [a])</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">tsChildren (<span class="dt">TrieSet</span> _ c) <span class="fu">=</span> c</a>
<a class="sourceLine" id="cb6-6" data-line-number="6"></a>
<a class="sourceLine" id="cb6-7" data-line-number="7"><span class="ot">tsInsert ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Ord</span> a) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> [a] <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> [a]</a>
<a class="sourceLine" id="cb6-8" data-line-number="8">tsInsert <span class="fu">=</span> foldr f b <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-9" data-line-number="9"><span class="ot">  b ::</span> <span class="dt">TrieSet</span> [a] <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> [a]</a>
<a class="sourceLine" id="cb6-10" data-line-number="10"><span class="ot">  f ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> (<span class="dt">TrieSet</span> [a] <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> [a]) <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> [a] <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> [a]</a>
<a class="sourceLine" id="cb6-11" data-line-number="11"></a>
<a class="sourceLine" id="cb6-12" data-line-number="12">  b (<span class="dt">TrieSet</span> _ c) <span class="fu">=</span> <span class="dt">TrieSet</span> <span class="dt">True</span> c</a>
<a class="sourceLine" id="cb6-13" data-line-number="13">  f e a (<span class="dt">TrieSet</span> n c) <span class="fu">=</span> <span class="dt">TrieSet</span> n (Map.alter (<span class="dt">Just</span> <span class="fu">.</span> a <span class="fu">.</span> fold) e c)</a>
<a class="sourceLine" id="cb6-14" data-line-number="14">  </a>
<a class="sourceLine" id="cb6-15" data-line-number="15"><span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">TrieSet</span> [a]) <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-16" data-line-number="16">  mempty <span class="fu">=</span> <span class="dt">TrieSet</span> <span class="dt">False</span> Map.empty</a>
<a class="sourceLine" id="cb6-17" data-line-number="17">  <span class="dt">TrieSet</span> v c <span class="ot">`mappend`</span> <span class="dt">TrieSet</span> t d <span class="fu">=</span> </a>
<a class="sourceLine" id="cb6-18" data-line-number="18">    <span class="dt">TrieSet</span> (v <span class="fu">||</span> t) (Map.unionWith (<span class="fu">&lt;&gt;</span>) c d)</a></code></pre></div>
<p>Why lists and not a general <code class="sourceCode haskell"><span class="dt">Foldable</span></code>? Well, for the particular use I had in mind (conforming to the <code class="sourceCode haskell"><span class="dt">Foldable</span></code> typeclass), I need <code class="sourceCode haskell">(<span class="fu">:</span>)</code>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Foldable</span> <span class="dt">TrieSet</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  foldr f b (<span class="dt">TrieSet</span> e c) <span class="fu">=</span> <span class="kw">if</span> e <span class="kw">then</span> f [] r <span class="kw">else</span> r <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">    r <span class="fu">=</span> Map.foldrWithKey (flip <span class="fu">.</span> g <span class="fu">.</span> (<span class="fu">:</span>)) b c</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">    g k <span class="fu">=</span> foldr (f <span class="fu">.</span> k)</a></code></pre></div>
<p>With some more helper functions, the interface becomes pretty nice:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">TrieSet</span> [a]) <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  showsPrec d t <span class="fu">=</span> </a>
<a class="sourceLine" id="cb8-3" data-line-number="3">    showParen </a>
<a class="sourceLine" id="cb8-4" data-line-number="4">      (d <span class="fu">&gt;</span> <span class="dv">10</span>)</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">      (showString <span class="st">&quot;fromList &quot;</span> <span class="fu">.</span> shows (foldr (<span class="fu">:</span>) [] t))</a>
<a class="sourceLine" id="cb8-6" data-line-number="6"></a>
<a class="sourceLine" id="cb8-7" data-line-number="7"><span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">IsList</span> (<span class="dt">TrieSet</span> [a]) <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8">  <span class="kw">type</span> <span class="dt">Item</span> (<span class="dt">TrieSet</span> [a]) <span class="fu">=</span> [a]</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">  fromList <span class="fu">=</span> foldr tsInsert mempty</a>
<a class="sourceLine" id="cb8-10" data-line-number="10">  toList <span class="fu">=</span> foldr (<span class="fu">:</span>) []</a></code></pre></div>
<p>The trie has the side-effect of lexicographically sorting what it’s given:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell literate example hidden_source"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="fu">:</span>set <span class="fu">-</span><span class="dt">XGADTs</span></a></code></pre></div>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">fromList [<span class="st">&quot;ced&quot;</span>, <span class="st">&quot;abc&quot;</span>, <span class="st">&quot;ced&quot;</span>, <span class="st">&quot;cb&quot;</span>, <span class="st">&quot;ab&quot;</span>]<span class="ot"> ::</span> <span class="dt">TrieSet</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">fromList [<span class="st">&quot;ab&quot;</span>,<span class="st">&quot;abc&quot;</span>,<span class="st">&quot;cb&quot;</span>,<span class="st">&quot;ced&quot;</span>]</a></code></pre></div>
<h1 id="further-generalizing">Further Generalizing</h1>
<p>Most implementations of tries that I’ve seen are map-like data structures, rather than set-like. In other words, instead of holding a <code class="sourceCode haskell"><span class="dt">Bool</span></code> at the value position, it holds a <code class="sourceCode haskell"><span class="dt">Maybe</span></code> something.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Trie</span> a b <span class="fu">=</span> <span class="dt">Trie</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2">  {<span class="ot"> endHere  ::</span> b</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  ,<span class="ot"> children ::</span> <span class="dt">Map</span> a (<span class="dt">Trie</span> a b) </a>
<a class="sourceLine" id="cb11-4" data-line-number="4">  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>, <span class="dt">Functor</span>, <span class="dt">Foldable</span>, <span class="dt">Traversable</span>)</a></code></pre></div>
<p>This is a much more straightforward datatype. <code class="sourceCode haskell"><span class="dt">Foldable</span></code> can even be automatically derived.</p>
<p>However, I haven’t made the <code class="sourceCode haskell">endHere</code> field a <code class="sourceCode haskell"><span class="dt">Maybe</span> a</code>. I want to be able to write something like this:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">type</span> <span class="dt">TrieSet</span> [a] <span class="fu">=</span> <span class="dt">Trie</span> a <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="kw">type</span> <span class="dt">TrieMap</span> a b <span class="fu">=</span> <span class="dt">Trie</span> a (<span class="dt">Maybe</span> b)</a></code></pre></div>
<p>And have it automatically choose the implementation of the functions I need<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>.</p>
<p>To do that, though, I’ll need to write the base functions, agnostic of the type of <code>b</code>. I <em>can</em> rely on something like <code class="sourceCode haskell"><span class="dt">Monoid</span></code>, though:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">instance</span> (<span class="dt">Ord</span> a, <span class="dt">Monoid</span> b) <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Trie</span> a b) <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">  mempty <span class="fu">=</span> <span class="dt">Trie</span> mempty Map.empty</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">  mappend (<span class="dt">Trie</span> v k) (<span class="dt">Trie</span> t l) <span class="fu">=</span> </a>
<a class="sourceLine" id="cb13-4" data-line-number="4">    <span class="dt">Trie</span> (v <span class="fu">&lt;&gt;</span> t) (Map.unionWith (<span class="fu">&lt;&gt;</span>) k l)</a></code></pre></div>
<p>In fact, quite a lot of functions naturally lend themselves to this fold + monoid style:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1">lookup<span class="ot"> ::</span> (<span class="dt">Ord</span> a, <span class="dt">Monoid</span> b, <span class="dt">Foldable</span> f) </a>
<a class="sourceLine" id="cb14-2" data-line-number="2">       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Trie</span> a b <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">lookup <span class="fu">=</span> foldr f endHere <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-4" data-line-number="4">  f e a <span class="fu">=</span> foldMap a <span class="fu">.</span> Map.lookup e <span class="fu">.</span> children</a>
<a class="sourceLine" id="cb14-5" data-line-number="5"></a>
<a class="sourceLine" id="cb14-6" data-line-number="6"><span class="ot">insert&#39; ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Ord</span> a, <span class="dt">Monoid</span> b) </a>
<a class="sourceLine" id="cb14-7" data-line-number="7">       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Trie</span> a b <span class="ot">-&gt;</span> <span class="dt">Trie</span> a b</a>
<a class="sourceLine" id="cb14-8" data-line-number="8">insert&#39; xs v <span class="fu">=</span> foldr f b xs <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-9" data-line-number="9">  b (<span class="dt">Trie</span> p c) <span class="fu">=</span> <span class="dt">Trie</span> (v <span class="fu">&lt;&gt;</span> p) c</a>
<a class="sourceLine" id="cb14-10" data-line-number="10">  f e a (<span class="dt">Trie</span> n c) <span class="fu">=</span> </a>
<a class="sourceLine" id="cb14-11" data-line-number="11">    <span class="dt">Trie</span> n (Map.alter (<span class="dt">Just</span> <span class="fu">.</span> a <span class="fu">.</span> fold) e c) </a></code></pre></div>
<p>A monoid is needed for the values, though, and neither <code class="sourceCode haskell"><span class="dt">Bool</span></code> nor <code class="sourceCode haskell"><span class="ot">∀</span> a<span class="fu">.</span> <span class="dt">Maybe</span> a</code> conform to <code class="sourceCode haskell"><span class="dt">Monoid</span></code>. Looking back to the implementation of the trie-set, the <code class="sourceCode haskell">(<span class="fu">||</span>)</code> function has been replaced by <code class="sourceCode haskell">mappend</code>. There <em>is</em> a newtype wrapper in <code class="sourceCode haskell"><span class="dt">Data.Monoid</span></code> which has exactly this behaviour, though: <code class="sourceCode haskell"><span class="dt">Any</span></code>.</p>
<p>Using that, the type signatures specialize to:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="kw">type</span> <span class="dt">TrieSet</span> a <span class="fu">=</span> <span class="dt">Trie</span> a <span class="dt">Any</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2">lookup<span class="ot"> ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) </a>
<a class="sourceLine" id="cb15-3" data-line-number="3">       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> a <span class="ot">-&gt;</span> <span class="dt">Any</span></a>
<a class="sourceLine" id="cb15-4" data-line-number="4"><span class="ot">insert ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) </a>
<a class="sourceLine" id="cb15-5" data-line-number="5">       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Any</span> <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> a <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> a</a></code></pre></div>
<p>Similarly, for <code class="sourceCode haskell"><span class="dt">Maybe</span></code>, there’s both <code class="sourceCode haskell"><span class="dt">First</span></code> and <code class="sourceCode haskell"><span class="dt">Last</span></code>. They have the behaviour:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell literate prop"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="dt">First</span> (<span class="dt">Just</span> x) <span class="fu">&lt;&gt;</span> <span class="dt">First</span> (<span class="dt">Just</span> y) <span class="fu">==</span> <span class="dt">First</span> (<span class="dt">Just</span> x)</a></code></pre></div>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell literate prop"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="dt">Last</span>  (<span class="dt">Just</span> x) <span class="fu">&lt;&gt;</span> <span class="dt">Last</span>  (<span class="dt">Just</span> y) <span class="fu">==</span> <span class="dt">Last</span>  (<span class="dt">Just</span> y)</a></code></pre></div>
<p>I think it makes more sense for a value inserted into a map to overwrite whatever was there before. Since the newer value is on the left in the <code class="sourceCode haskell">mappend</code>, then, <code class="sourceCode haskell"><span class="dt">First</span></code> makes most sense.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="kw">type</span> <span class="dt">TrieMap</span> a b <span class="fu">=</span> <span class="dt">Trie</span> a (<span class="dt">First</span> b)</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">lookup<span class="ot"> ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">TrieMap</span> a b <span class="ot">-&gt;</span> <span class="dt">First</span> b</a>
<a class="sourceLine" id="cb18-3" data-line-number="3"><span class="ot">insert ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) </a>
<a class="sourceLine" id="cb18-4" data-line-number="4">       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">First</span> b <span class="ot">-&gt;</span> <span class="dt">TrieMap</span> a b <span class="ot">-&gt;</span> <span class="dt">TrieMap</span> a b</a></code></pre></div>
<p>There are some other ways that you can interpret the monoid. For instance, subbing in <code class="sourceCode haskell"><span class="dt">Sum</span> <span class="dt">Int</span></code> gives you a bag-like trie:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="kw">type</span> <span class="dt">TrieBag</span> a <span class="fu">=</span> <span class="dt">Trie</span> a (<span class="dt">Sum</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">lookup<span class="ot"> ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">TrieBag</span> a <span class="ot">-&gt;</span> <span class="dt">Sum</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb19-3" data-line-number="3"><span class="ot">insert ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) </a>
<a class="sourceLine" id="cb19-4" data-line-number="4">       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Sum</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">TrieBag</span> a <span class="ot">-&gt;</span> <span class="dt">TrieBag</span> a</a></code></pre></div>
<p>This is a set which can store multiple copies of each member. Turned the other way around, a map which stores many values for each key looks like this:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="kw">type</span> <span class="dt">TrieBin</span> a b <span class="fu">=</span> <span class="dt">Trie</span> a [b]</a>
<a class="sourceLine" id="cb20-2" data-line-number="2">lookup<span class="ot"> ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">TrieBin</span> a b <span class="ot">-&gt;</span> [b]</a>
<a class="sourceLine" id="cb20-3" data-line-number="3"><span class="ot">insert ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) </a>
<a class="sourceLine" id="cb20-4" data-line-number="4">       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> <span class="dt">TrieBin</span> a b <span class="ot">-&gt;</span> <span class="dt">TrieBin</span> a b</a></code></pre></div>
<p>This method so far isn’t really satisfying, though. Really, the <code class="sourceCode haskell">insert</code> signatures should look like this:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="ot">insert ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) </a>
<a class="sourceLine" id="cb21-2" data-line-number="2">       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">TrieMap</span> a b <span class="ot">-&gt;</span> <span class="dt">TrieMap</span> a b</a>
<a class="sourceLine" id="cb21-3" data-line-number="3"><span class="ot">insert ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f)</a>
<a class="sourceLine" id="cb21-4" data-line-number="4">       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">TrieBin</span> a b <span class="ot">-&gt;</span> <span class="dt">TrieBin</span> a b</a></code></pre></div>
<p>Modifying insert slightly, you can get exactly that:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="ot">insert ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Ord</span> a, <span class="dt">Applicative</span> c, <span class="dt">Monoid</span> (c b)) </a>
<a class="sourceLine" id="cb22-2" data-line-number="2">       <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Trie</span> a (c b) <span class="ot">-&gt;</span> <span class="dt">Trie</span> a (c b)</a>
<a class="sourceLine" id="cb22-3" data-line-number="3">insert xs v <span class="fu">=</span> foldr f b xs <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-4" data-line-number="4">  b (<span class="dt">Trie</span> p c) <span class="fu">=</span> <span class="dt">Trie</span> (pure v <span class="fu">&lt;&gt;</span> p) c</a>
<a class="sourceLine" id="cb22-5" data-line-number="5">  f e a (<span class="dt">Trie</span> n c) <span class="fu">=</span> <span class="dt">Trie</span> n (Map.alter (<span class="dt">Just</span> <span class="fu">.</span> a <span class="fu">.</span> fold) e c)</a></code></pre></div>
<p><code class="sourceCode haskell">pure</code> from <code class="sourceCode haskell"><span class="dt">Applicative</span></code> is needed for the “embedding”.</p>
<p>Similarly, the “inserting” for the set-like types isn’t really right. The value argument is out of place. This should be the signature:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="ot">add ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f) </a>
<a class="sourceLine" id="cb23-2" data-line-number="2">    <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> a <span class="ot">-&gt;</span> <span class="dt">TrieSet</span> a</a>
<a class="sourceLine" id="cb23-3" data-line-number="3"><span class="ot">add ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> f)</a>
<a class="sourceLine" id="cb23-4" data-line-number="4">    <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">TrieBin</span> a <span class="ot">-&gt;</span> <span class="dt">TrieBin</span> a</a></code></pre></div>
<p>In particular, while we have an “empty” thing (0, False) for monoids, we need a “one” thing (1, True) for this function. A semiring<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a> gives this exact method:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Monoid</span> a <span class="ot">=&gt;</span> <span class="dt">Semiring</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-2" data-line-number="2"><span class="ot">  one ::</span> a</a>
<a class="sourceLine" id="cb24-3" data-line-number="3"><span class="ot">  mul ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb24-4" data-line-number="4">  </a>
<a class="sourceLine" id="cb24-5" data-line-number="5"><span class="kw">instance</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Semiring</span> (<span class="dt">Sum</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-6" data-line-number="6">  one <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb24-7" data-line-number="7">  mul <span class="fu">=</span> (<span class="fu">*</span>)</a>
<a class="sourceLine" id="cb24-8" data-line-number="8"></a>
<a class="sourceLine" id="cb24-9" data-line-number="9"><span class="kw">instance</span> <span class="dt">Semiring</span> <span class="dt">Any</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-10" data-line-number="10">  one <span class="fu">=</span> <span class="dt">Any</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb24-11" data-line-number="11">  <span class="dt">Any</span> x <span class="ot">`mul`</span> <span class="dt">Any</span> y <span class="fu">=</span> <span class="dt">Any</span> (x <span class="fu">&amp;&amp;</span> y)</a></code></pre></div>
<p>This class is kind of like a combination of both monoid wrappers for both <code class="sourceCode haskell"><span class="dt">Int</span></code> and <code class="sourceCode haskell"><span class="dt">Bool</span></code>. You could take advantage of that:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1"></a>
<a class="sourceLine" id="cb25-2" data-line-number="2"><span class="kw">class</span> (<span class="dt">Monoid</span> add, <span class="dt">Monoid</span> mult)</a>
<a class="sourceLine" id="cb25-3" data-line-number="3">  <span class="ot">=&gt;</span> <span class="dt">SemiringIso</span> a add mult <span class="fu">|</span> a <span class="ot">-&gt;</span> add, a <span class="ot">-&gt;</span> mult <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-4" data-line-number="4"><span class="ot">    toAdd    ::</span> a <span class="ot">-&gt;</span> add</a>
<a class="sourceLine" id="cb25-5" data-line-number="5"><span class="ot">    fromAdd  ::</span> add <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb25-6" data-line-number="6"><span class="ot">    toMult   ::</span> a <span class="ot">-&gt;</span> mult</a>
<a class="sourceLine" id="cb25-7" data-line-number="7"><span class="ot">    fromMult ::</span> mult <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb25-8" data-line-number="8">  </a>
<a class="sourceLine" id="cb25-9" data-line-number="9">(<span class="fu">&lt;+&gt;</span>),<span class="ot"> (&lt;.&gt;) ::</span> <span class="dt">SemiringIso</span> a add mult <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb25-10" data-line-number="10"></a>
<a class="sourceLine" id="cb25-11" data-line-number="11">x <span class="fu">&lt;+&gt;</span> y <span class="fu">=</span> fromAdd  (toAdd  x <span class="fu">&lt;&gt;</span> toAdd  y)</a>
<a class="sourceLine" id="cb25-12" data-line-number="12">x <span class="fu">&lt;.&gt;</span> y <span class="fu">=</span> fromMult (toMult x <span class="fu">&lt;&gt;</span> toMult y)</a>
<a class="sourceLine" id="cb25-13" data-line-number="13"></a>
<a class="sourceLine" id="cb25-14" data-line-number="14"><span class="kw">instance</span> <span class="dt">SemiringIso</span> <span class="dt">Int</span> (<span class="dt">Sum</span> <span class="dt">Int</span>) (<span class="dt">Product</span> <span class="dt">Int</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-15" data-line-number="15">  toAdd    <span class="fu">=</span> <span class="dt">Sum</span></a>
<a class="sourceLine" id="cb25-16" data-line-number="16">  fromAdd  <span class="fu">=</span> getSum</a>
<a class="sourceLine" id="cb25-17" data-line-number="17">  toMult   <span class="fu">=</span> <span class="dt">Product</span></a>
<a class="sourceLine" id="cb25-18" data-line-number="18">  fromMult <span class="fu">=</span> getProduct</a>
<a class="sourceLine" id="cb25-19" data-line-number="19"></a>
<a class="sourceLine" id="cb25-20" data-line-number="20"><span class="kw">instance</span> <span class="dt">SemiringIso</span> <span class="dt">Bool</span> <span class="dt">Any</span> <span class="dt">All</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-21" data-line-number="21">  toAdd    <span class="fu">=</span> <span class="dt">Any</span></a>
<a class="sourceLine" id="cb25-22" data-line-number="22">  fromAdd  <span class="fu">=</span> getAny</a>
<a class="sourceLine" id="cb25-23" data-line-number="23">  toMult   <span class="fu">=</span> <span class="dt">All</span></a>
<a class="sourceLine" id="cb25-24" data-line-number="24">  fromMult <span class="fu">=</span> getAll</a></code></pre></div>
<p>But it seems like overkill.</p>
<p>Anyway, assuming that we have the functions from <code class="sourceCode haskell"><span class="dt">Semiring</span></code>, here’s the <code>add</code> function:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="ot">add ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Ord</span> a, <span class="dt">Semiring</span> b) </a>
<a class="sourceLine" id="cb26-2" data-line-number="2">    <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Trie</span> a b <span class="ot">-&gt;</span> <span class="dt">Trie</span> a b</a>
<a class="sourceLine" id="cb26-3" data-line-number="3">add xs <span class="fu">=</span> foldr f b xs <span class="kw">where</span></a>
<a class="sourceLine" id="cb26-4" data-line-number="4">  b (<span class="dt">Trie</span> p c) <span class="fu">=</span> <span class="dt">Trie</span> (one <span class="fu">&lt;&gt;</span> p) c</a>
<a class="sourceLine" id="cb26-5" data-line-number="5">  f e a (<span class="dt">Trie</span> n c) <span class="fu">=</span> </a>
<a class="sourceLine" id="cb26-6" data-line-number="6">    <span class="dt">Trie</span> n (Map.alter (<span class="dt">Just</span> <span class="fu">.</span> a <span class="fu">.</span> fold) e c)</a></code></pre></div>
<p>Now, expressions can be built up without specifying the specific monoid implementation, and the whole behaviour can be changed with a type signature:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell literate hidden_source"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="kw">instance</span> (<span class="dt">Ord</span> a, <span class="dt">Semiring</span> b) <span class="ot">=&gt;</span> <span class="dt">IsList</span> (<span class="dt">Trie</span> a b) <span class="kw">where</span></a>
<a class="sourceLine" id="cb27-2" data-line-number="2">  <span class="kw">type</span> <span class="dt">Item</span> (<span class="dt">Trie</span> a b) <span class="fu">=</span> [a]</a>
<a class="sourceLine" id="cb27-3" data-line-number="3">  fromList <span class="fu">=</span> foldr add mempty</a>
<a class="sourceLine" id="cb27-4" data-line-number="4">  toList <span class="fu">=</span> undefined</a>
<a class="sourceLine" id="cb27-5" data-line-number="5"><span class="ot">ans ::</span> <span class="dt">Semiring</span> b <span class="ot">=&gt;</span> b</a></code></pre></div>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1">ans <span class="fu">=</span> lookup <span class="st">&quot;abc&quot;</span> (fromList [<span class="st">&quot;abc&quot;</span>, <span class="st">&quot;def&quot;</span>, <span class="st">&quot;abc&quot;</span>, <span class="st">&quot;ghi&quot;</span>])</a></code></pre></div>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" data-line-number="1"><span class="ot">ans ::</span> <span class="dt">Sum</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb29-2" data-line-number="2"><span class="dt">Sum</span> {getSum <span class="fu">=</span> <span class="dv">2</span>}</a></code></pre></div>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="ot">ans ::</span> <span class="dt">Any</span></a>
<a class="sourceLine" id="cb30-2" data-line-number="2"><span class="dt">Any</span> {getAny <span class="fu">=</span> <span class="dt">True</span>}</a></code></pre></div>
<p>Slightly fuller implementations of all of these are available <a href="https://github.com/oisdk/hstrie">here</a>.</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Kind of like <a href="https://www.youtube.com/watch?v=3U3lV5VPmOU">program inference in lieu of type inference</a><a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>This isn’t really a very good definition of semiring. While Haskell doesn’t have this class in base, <a href="https://github.com/purescript/purescript-prelude/blob/master/src/Data/Semiring.purs">Purescript has it in their prelude.</a><a href="#fnref2" class="footnote-back">↩</a></p></li>
</ol>
</section>
]]></description>
    <pubDate>Mon, 26 Sep 2016 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2016-09-26-revisiting-trie-lhs.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Lenses are Static Selectors</title>
    <link>https://doisinkidney.com/posts/2016-06-16-lenses-are-static-selectors.html</link>
    <description><![CDATA[<div class="info">
    Posted on June 16, 2016
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Swift.html">Swift</a>
    
</div>

<p>So I don’t really know what <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/KeyValueCoding/Articles/KeyValueCoding.html">KVC</a> is, or much about <code class="sourceCode scala">performSelector</code> functions. <a href="http://inessential.com/2016/05/20/updating_local_objects_with_server_objec">This</a> blogpost, from Brent Simmons, let me know a little bit about why I would want to use them.</p>
<p>It centred around removing code repetition of this type:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">if</span> localObject.<span class="fu">foo</span> != serverObject.<span class="fu">foo</span> {</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  localObject.<span class="fu">foo</span> = serverObject.<span class="fu">foo</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">}</a>
<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="kw">if</span> localObject.<span class="fu">bar</span> != serverObject.<span class="fu">bar</span> {</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">  localObject.<span class="fu">bar</span> = serverObject.<span class="fu">bar</span> <span class="co">// There was an (intentional)</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">}                                    <span class="co">// bug here in the original post</span></a></code></pre></div>
<p>To clean up the code, Brent used selector methods. At first, I was a little uncomfortable with the solution. As far as I could tell, the basis of a lot of this machinery used functions with types like this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb2-1" data-line-number="1">func <span class="fu">get</span>(fromSelector: String) -&gt; AnyObject?</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">func <span class="fu">set</span>(forSelector: String) -&gt; ()</a></code></pre></div>
<p>Which <em>seems</em> to be extremely dynamic. Stringly-typed and all that. Except that there are two different things going on here. One is the dynamic stuff; the ability to get rid of types when you need to. The other, though, has <em>nothing</em> to do with types. The other idea is being able to pass around something which can access the property (or method) of an object. Let’s look at the code that was being repeated:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">if</span> localObject.<span class="fu">foo</span> != serverObject.<span class="fu">foo</span> {</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  localObject.<span class="fu">foo</span> = serverObject.<span class="fu">foo</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">}</a>
<a class="sourceLine" id="cb3-4" data-line-number="4"></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="kw">if</span> localObject.<span class="fu">bar</span> != serverObject.<span class="fu">bar</span> {</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">  localObject.<span class="fu">bar</span> = serverObject.<span class="fu">bar</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7">}</a></code></pre></div>
<p>The logical, obvious thing to do here is try refactor out the common elements. In fact, the only things that <em>differ</em> between the two actions above are the <code class="sourceCode scala">foo</code> and <code class="sourceCode scala">bar</code>. It would be great to be able to write a function like this:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb4-1" data-line-number="1">func <span class="fu">checkThenUpdate</span>(selector) {</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  <span class="kw">if</span> localObject.<span class="fu">selector</span> != serverObject.<span class="fu">selector</span> {</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">    localObject.<span class="fu">selector</span> = serverObject.<span class="fu">selector</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">  }</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">}</a></code></pre></div>
<p>And then maybe a single line like this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb5-1" data-line-number="1">[foo, bar, baz].<span class="fu">forEach</span>(checkThenUpdate)</a></code></pre></div>
<p>That’s pretty obviously better. It’s just good programming: when faced with repetition, find the repeated part, and abstract it out. Is it more <em>dynamic</em> than the repetition, though? I don’t think so. All you have to figure out is an appropriate type for the selector, and you can keep all of your static checking. To me, it seems a lot like a <a href="https://hackage.haskell.org/package/lens">lens</a>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb6-1" data-line-number="1">struct Lens&lt;Whole, Part&gt; {</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  let get: Whole -&gt; Part</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  let set: (Whole, Part) -&gt; Whole</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">}</a></code></pre></div>
<p>(This is a lens similar to the ones used in the <a href="http://hackage.haskell.org/package/data-lens">data-lens</a> library, in contrast to van Laarhoven lenses, or LensFamilies. LensFamilies are used in the <a href="https://hackage.haskell.org/package/lens">lens</a> package, and they allow you to change the type of the <code class="sourceCode scala">Part</code>. They’re also just normal functions, rather than a separate type, so you can manipulate them in a pretty standard way. Swift’s type system isn’t able to model those lenses, though, unfortunately.) It has two things: a getter and a setter. The getter is pretty obvious: it takes the object, and returns the property. The setter is a little more confusing. It’s taking an object, and the new property you want to stick in to the object, and returns the object with that property updated. For instance, if we were to make a <code class="sourceCode scala">Person</code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb7-1" data-line-number="1">struct LocalPerson {</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  <span class="kw">var</span> age: Int</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  <span class="kw">var</span> name: String</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">}</a></code></pre></div>
<p>We could then have a lens for the <code class="sourceCode scala">name</code> field like this:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb8-1" data-line-number="1">let localName: Lens&lt;LocalPerson,String&gt; = <span class="fu">Lens</span>(</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  get: { p in p.<span class="fu">name</span> },</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  set: { (oldPerson,newName) in</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">    <span class="kw">var</span> newPerson = oldPerson</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">    newPerson.<span class="fu">name</span> = newName</a>
<a class="sourceLine" id="cb8-6" data-line-number="6">    <span class="kw">return</span> newPerson</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">  }</a>
<a class="sourceLine" id="cb8-8" data-line-number="8">)</a></code></pre></div>
<p>And you’d use it like this:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb9-1" data-line-number="1">let caoimhe = <span class="fu">LocalPerson</span>(age: <span class="dv">46</span>, name: <span class="st">&quot;caoimhe&quot;</span>)</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">localName.<span class="fu">get</span>(caoimhe) <span class="co">// 46</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">localName.<span class="fu">set</span>(caoimhe, <span class="st">&quot;breifne&quot;</span>) <span class="co">// LocalPerson(age: 46, name: &quot;breifne&quot;)</span></a></code></pre></div>
<p>Straight away, we’re able to do (something) like the <code class="sourceCode scala">checkThenUpdate</code> function:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb10-1" data-line-number="1">func checkThenUpdate</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">  &lt;A: Equatable&gt;</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  (localLens: Lens&lt;LocalPerson,A&gt;, serverLens: Lens&lt;ServerPerson,A&gt;) {</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">  let serverProp = serverLens.<span class="fu">get</span>(serverObject)</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">  <span class="kw">if</span> localLens.<span class="fu">get</span>(localObject) != serverProp {</a>
<a class="sourceLine" id="cb10-6" data-line-number="6">    localObject = localLens.<span class="fu">set</span>(localObject,serverProp)</a>
<a class="sourceLine" id="cb10-7" data-line-number="7">  }</a>
<a class="sourceLine" id="cb10-8" data-line-number="8">}</a></code></pre></div>
<p>And it could be called pretty tersely:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="fu">checkThenUpdate</span>(localName, serverLens: serverName)</a></code></pre></div>
<p>The biggest problem with this approach, obviously, is the boilerplate. In Haskell, that’s solved with Template Haskell, so the lens code is generated for you. (I’d love to see something like that in Swift) There’s a protocol-oriented spin on lenses, also. One of the variants on lenses in Haskell are called “classy-lenses”. That’s where, instead of just generating a lens with the same name as the field it looks into, you generate a typeclass (protocol) for anything with that lens. In Swift, it might work something like this:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb12-1" data-line-number="1">struct Place {</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">  <span class="kw">var</span> name: String</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">}</a>
<a class="sourceLine" id="cb12-4" data-line-number="4"></a>
<a class="sourceLine" id="cb12-5" data-line-number="5"><span class="co">// Instead of just having a lens for the name field, have a whole protocol</span></a>
<a class="sourceLine" id="cb12-6" data-line-number="6"><span class="co">// for things with a name field:</span></a>
<a class="sourceLine" id="cb12-7" data-line-number="7"></a>
<a class="sourceLine" id="cb12-8" data-line-number="8">protocol HasName {</a>
<a class="sourceLine" id="cb12-9" data-line-number="9">  associatedtype Name</a>
<a class="sourceLine" id="cb12-10" data-line-number="10">  static <span class="kw">var</span> name: Lens&lt;Self,Name&gt; { get }</a>
<a class="sourceLine" id="cb12-11" data-line-number="11">  <span class="kw">var</span> name: Name { get set }</a>
<a class="sourceLine" id="cb12-12" data-line-number="12">}</a>
<a class="sourceLine" id="cb12-13" data-line-number="13"></a>
<a class="sourceLine" id="cb12-14" data-line-number="14"><span class="co">// Because the mutable property is included in the protocol, you can rely on</span></a>
<a class="sourceLine" id="cb12-15" data-line-number="15"><span class="co">// it in extensions:</span></a>
<a class="sourceLine" id="cb12-16" data-line-number="16"></a>
<a class="sourceLine" id="cb12-17" data-line-number="17">extension HasName {</a>
<a class="sourceLine" id="cb12-18" data-line-number="18">  static <span class="kw">var</span> name: Lens&lt;Self,Name&gt; {</a>
<a class="sourceLine" id="cb12-19" data-line-number="19">    <span class="kw">return</span> <span class="fu">Lens</span>(</a>
<a class="sourceLine" id="cb12-20" data-line-number="20">      get: {$<span class="fl">0.</span>name},</a>
<a class="sourceLine" id="cb12-21" data-line-number="21">      set: { (w,p) in </a>
<a class="sourceLine" id="cb12-22" data-line-number="22">        <span class="kw">var</span> n = w</a>
<a class="sourceLine" id="cb12-23" data-line-number="23">        n.<span class="fu">name</span> = p</a>
<a class="sourceLine" id="cb12-24" data-line-number="24">        <span class="kw">return</span> n</a>
<a class="sourceLine" id="cb12-25" data-line-number="25">      }</a>
<a class="sourceLine" id="cb12-26" data-line-number="26">    )</a>
<a class="sourceLine" id="cb12-27" data-line-number="27">  }</a>
<a class="sourceLine" id="cb12-28" data-line-number="28">  <span class="kw">var</span> name: Name {</a>
<a class="sourceLine" id="cb12-29" data-line-number="29">    get { <span class="kw">return</span> Self.<span class="fu">name</span>.<span class="fu">get</span>(self) }</a>
<a class="sourceLine" id="cb12-30" data-line-number="30">    set { self = Self.<span class="fu">name</span>.<span class="fu">set</span>(self,newValue) }</a>
<a class="sourceLine" id="cb12-31" data-line-number="31">  }</a>
<a class="sourceLine" id="cb12-32" data-line-number="32">}</a>
<a class="sourceLine" id="cb12-33" data-line-number="33"></a>
<a class="sourceLine" id="cb12-34" data-line-number="34"><span class="co">// This way, you can provide either the lens or the property, and you get the</span></a>
<a class="sourceLine" id="cb12-35" data-line-number="35"><span class="co">// other for free.</span></a>
<a class="sourceLine" id="cb12-36" data-line-number="36"></a>
<a class="sourceLine" id="cb12-37" data-line-number="37">extension Place: HasName {}</a>
<a class="sourceLine" id="cb12-38" data-line-number="38"></a>
<a class="sourceLine" id="cb12-39" data-line-number="39"><span class="co">// Then, you can rely on that protocol, and all of the types:</span></a>
<a class="sourceLine" id="cb12-40" data-line-number="40"></a>
<a class="sourceLine" id="cb12-41" data-line-number="41">func checkEqualOnNames</a>
<a class="sourceLine" id="cb12-42" data-line-number="42">  &lt;A,B where A: HasName, B: HasName, A.<span class="fu">Name</span>: Equatable, A.<span class="fu">Name</span> == B.<span class="fu">Name</span>&gt;</a>
<a class="sourceLine" id="cb12-43" data-line-number="43">  (x: A, _ y: B) -&gt; Bool {</a>
<a class="sourceLine" id="cb12-44" data-line-number="44">    <span class="kw">return</span> x.<span class="fu">name</span> == y.<span class="fu">name</span></a>
<a class="sourceLine" id="cb12-45" data-line-number="45">}</a></code></pre></div>
<p>This protocol lets you do a kind of static <code class="sourceCode scala">respondsToSelector</code>, with all of the types intact. Other people have spoken about the other things you can do with lenses in Swift (<a href="https://www.youtube.com/watch?v=ofjehH9f-CU">Brandon Williams - Lenses in Swift</a>), like composing them together, chaining operations, etc. (One other thing they can emulate is <a href="https://gist.github.com/erica/6794d48d917e2084d6ed">method cascading</a>) Unfortunately, in current Swift, the boilerplate makes all of this a little unpleasant. Still, they’re an interesting idea, and they show how a good type system needn’t always get in the way.</p>
]]></description>
    <pubDate>Thu, 16 Jun 2016 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2016-06-16-lenses-are-static-selectors.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Folding Two Things at Once</title>
    <link>https://doisinkidney.com/posts/2016-04-17-folding-two-at-once.html</link>
    <description><![CDATA[<div class="info">
    Posted on April 17, 2016
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Recursion%20Schemes.html">Recursion Schemes</a>
    
</div>

<p>There’s a whole family of Haskell brainteasers surrounding one function: <code class="sourceCode haskell">foldr</code>. The general idea is to convert some function on lists which uses recursion into one that uses <code class="sourceCode haskell">foldr</code>. <code class="sourceCode haskell">map</code>, for instance:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1">map<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">map f <span class="fu">=</span> foldr (\e a <span class="ot">-&gt;</span> f e <span class="fu">:</span> a) []</a></code></pre></div>
<p>Some can get a little trickier. <code class="sourceCode haskell">dropWhile</code>, for instance. (See <a href="https://wiki.haskell.org/wikiupload/1/14/TMR-Issue6.pdf">here</a> and <a href="http://www.cs.nott.ac.uk/~pszgmh/fold.pdf">here</a> for interesting articles on that one in particular.)</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1">dropWhile<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">dropWhile p <span class="fu">=</span> fst <span class="fu">.</span> foldr f ([],[]) <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  f e <span class="fu">~</span>(xs,ys) <span class="fu">=</span> (<span class="kw">if</span> p e <span class="kw">then</span> xs <span class="kw">else</span> zs, zs) <span class="kw">where</span> zs <span class="fu">=</span> e <span class="fu">:</span> ys</a></code></pre></div>
<h2 id="zip">Zip</h2>
<p>One function which was a little harder to convert than it first seemed was <code class="sourceCode haskell">zip</code>.</p>
<p>Here’s the first (non) solution:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1">zip<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a,b)]</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">zip <span class="fu">=</span> foldr f (const []) <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">  f x xs (y<span class="fu">:</span>ys) <span class="fu">=</span> (x,y) <span class="fu">:</span> xs ys</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">  f _ _  [] <span class="fu">=</span> []</a></code></pre></div>
<p>The problem with the above isn’t that it doesn’t work: it does. The problem is that it’s not <em>really</em> using <code class="sourceCode haskell">foldr</code>. It’s only using it on the first list: there’s still a manual uncons being performed on the second. Ideally, I would want the function to look something like this:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">zip<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a,b)]</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">zip xs ys <span class="fu">=</span> foldr f (\_ _ <span class="ot">-&gt;</span> []) xs (foldr g (const []) ys)</a></code></pre></div>
<p>The best solution I found online only dealt with <code class="sourceCode haskell"><span class="dt">Fold</span></code>s, not <code class="sourceCode haskell"><span class="dt">Foldable</span></code>s. You can read it <a href="http://okmij.org/ftp/Haskell/zip-folds.lhs">here</a>.</p>
<h2 id="recursive-types">Recursive Types</h2>
<p>Reworking the solution online for <code class="sourceCode haskell"><span class="dt">Foldable</span></code>s, the initial intuition is to have the <code class="sourceCode haskell">foldr</code> on the <code class="sourceCode haskell">ys</code> produce a function which takes an element of the <code class="sourceCode haskell">xs</code>, and returns a function which takes an element of the <code class="sourceCode haskell">xs</code>, and so on, finally returning the created list. The <em>problem</em> with that approach is the types involved:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1">zip<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a,b)]</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">zip xs <span class="fu">=</span> foldr f (const []) xs <span class="fu">.</span> foldr g (\_ _ <span class="ot">-&gt;</span> []) <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  g e2 r2 e1 r1 <span class="fu">=</span> (e1,e2) <span class="fu">:</span> (r1 r2)</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">  f e r x <span class="fu">=</span> x e r</a></code></pre></div>
<p>You get the error:</p>
<blockquote>
<p><code class="sourceCode haskell"><span class="dt">Occurs</span> check<span class="fu">:</span> cannot construct the infinite <span class="kw">type</span><span class="fu">:</span> t0 <span class="fu">~</span> a <span class="ot">-&gt;</span> (t0 <span class="ot">-&gt;</span> [(a, b)]) <span class="ot">-&gt;</span> [(a, b)]</code>.</p>
</blockquote>
<p>Haskell’s typechecker doesn’t allow for infinitely recursive types.</p>
<p>You’ll be familiar with this problem if you’ve ever tried to encode the Y-combinator, or if you’ve fiddled around with the recursion-schemes package. You might also be familiar with the solution: a <code class="sourceCode haskell"><span class="kw">newtype</span></code>, encapsulating the recursion. In this case, the <code class="sourceCode haskell"><span class="kw">newtype</span></code> looks very similar to the signature for <code class="sourceCode haskell">foldr</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">RecFold</span> a b <span class="fu">=</span> </a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  <span class="dt">RecFold</span> {<span class="ot"> runRecFold ::</span> a <span class="ot">-&gt;</span> (<span class="dt">RecFold</span> a b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b }</a></code></pre></div>
<p>Now you can insert and remove the <code class="sourceCode haskell"><span class="dt">RecFold</span></code> wrapper, helping the typechecker to understand the recursive types as it goes:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1">zip<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a,b)]</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">zip xs <span class="fu">=</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  foldr f (const []) xs <span class="fu">.</span> <span class="dt">RecFold</span> <span class="fu">.</span> foldr g (\_ _ <span class="ot">-&gt;</span> []) <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">    g e2 r2 e1 r1 <span class="fu">=</span> (e1,e2) <span class="fu">:</span> (r1 (<span class="dt">RecFold</span> r2))</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">    f e r x <span class="fu">=</span> runRecFold x e r</a></code></pre></div>
<p>As an aside, the performance characteristics of the <code class="sourceCode haskell"><span class="kw">newtype</span></code> wrapper are totally opaque to me. There may be significant improvements by using <code class="sourceCode haskell">coerce</code> from <a href="https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Coerce.html">Data.Coerce</a>, but I haven’t looked into it.</p>
<h2 id="generalised-zips">Generalised Zips</h2>
<p>The immediate temptation from the function above is to generalise it. First to <code class="sourceCode haskell">zipWith</code>, obviously:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">zipWith<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [c]</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">zipWith c xs <span class="fu">=</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  foldr f (const []) xs <span class="fu">.</span> <span class="dt">RecFold</span> <span class="fu">.</span> foldr g (\_ _ <span class="ot">-&gt;</span> []) <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">    g e2 r2 e1 r1 <span class="fu">=</span> c e1 e2 <span class="fu">:</span> (r1 (<span class="dt">RecFold</span> r2))</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">    f e r x <span class="fu">=</span> runRecFold x e r</a></code></pre></div>
<p>What’s maybe a little more interesting, though, would be a <code class="sourceCode haskell">foldr</code> on two lists. Something which folds through both at once, using a supplied combining function:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">foldr2 ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Foldable</span> g)</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">       <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> c)</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">       <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> g b <span class="ot">-&gt;</span> c</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">foldr2 c i xs <span class="fu">=</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  foldr f (const i) xs <span class="fu">.</span> <span class="dt">RecFold</span> <span class="fu">.</span> foldr g (\_ _ <span class="ot">-&gt;</span> i) <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6">    g e2 r2 e1 r1 <span class="fu">=</span> c e1 e2 (r1 (<span class="dt">RecFold</span> r2))</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">    f e r x <span class="fu">=</span> runRecFold x e r</a></code></pre></div>
<p>Of course, once you can do two, you can do three:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">foldr3 ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Foldable</span> g, <span class="dt">Foldable</span> h)</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">       <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> d <span class="ot">-&gt;</span> d)</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">       <span class="ot">-&gt;</span> d <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> g b <span class="ot">-&gt;</span> h c <span class="ot">-&gt;</span> d</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">foldr3 c i xs ys <span class="fu">=</span></a>
<a class="sourceLine" id="cb10-5" data-line-number="5">  foldr f (const i) xs <span class="fu">.</span> <span class="dt">RecFold</span> <span class="fu">.</span> foldr2 g (\_ _ <span class="ot">-&gt;</span> i) ys <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-6" data-line-number="6">    g e2 e3 r2 e1 r1 <span class="fu">=</span> c e1 e2 e3 (r1 (<span class="dt">RecFold</span> r2))</a>
<a class="sourceLine" id="cb10-7" data-line-number="7">    f e r x <span class="fu">=</span> runRecFold x e r</a></code></pre></div>
<p>And so on.</p>
<p>There’s the added benefit that the above functions work on much more than just lists.</p>
<h2 id="catamorphisms">Catamorphisms</h2>
<p>Getting a little formal about the above functions, a <code class="sourceCode haskell">fold</code> can be described as a catamorphism. This is a name for a pattern of breaking down some recursive structure. There’s a bunch of them in the <a href="https://hackage.haskell.org/package/recursion-schemes-4.1.2/docs/Data-Functor-Foldable.html">recursion-schemes</a> package. The question is, then: can you express the above as a kind of catamorphism? Initially, using the same techniques as before, you can:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">RecF</span> f a <span class="fu">=</span> <span class="dt">RecF</span> {<span class="ot"> unRecF ::</span> <span class="dt">Base</span> f (<span class="dt">RecF</span> f a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a }</a>
<a class="sourceLine" id="cb11-2" data-line-number="2"></a>
<a class="sourceLine" id="cb11-3" data-line-number="3"><span class="ot">zipo ::</span> (<span class="dt">Functor</span><span class="fu">.</span><span class="dt">Foldable</span> f, <span class="dt">Functor</span><span class="fu">.</span><span class="dt">Foldable</span> g)</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">     <span class="ot">=&gt;</span> (<span class="dt">Base</span> f (<span class="dt">RecF</span> g c) <span class="ot">-&gt;</span> <span class="dt">Base</span> g (<span class="dt">RecF</span> g c <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> c)</a>
<a class="sourceLine" id="cb11-5" data-line-number="5">     <span class="ot">-&gt;</span> f <span class="ot">-&gt;</span> g <span class="ot">-&gt;</span> c</a>
<a class="sourceLine" id="cb11-6" data-line-number="6">zipo alg xs ys <span class="fu">=</span> cata (flip unRecF) ys (cata (<span class="dt">RecF</span> <span class="fu">.</span> alg) xs)</a></code></pre></div>
<p>Then, coming full circle, you get a quite nice encoding of <code class="sourceCode haskell">zip</code>:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1">zip<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a,b)]</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">zip <span class="fu">=</span> zipo alg <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">  alg <span class="dt">Nil</span> _ <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb12-4" data-line-number="4">  alg _ <span class="dt">Nil</span> <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">  alg (<span class="dt">Cons</span> x xs) (<span class="dt">Cons</span> y ys) <span class="fu">=</span> (x, y) <span class="fu">:</span> ys xs</a></code></pre></div>
<p>However, the <code class="sourceCode haskell"><span class="dt">RecF</span></code> is a little ugly. In fact, it’s possible to write the above without any recursive types. (It’s possible that you could do the same with <code class="sourceCode haskell">foldr2</code> as well, but I haven’t figured it out yet)</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="ot">zipo ::</span> (<span class="dt">Functor</span><span class="fu">.</span><span class="dt">Foldable</span> f, <span class="dt">Functor</span><span class="fu">.</span><span class="dt">Foldable</span> g)</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">     <span class="ot">=&gt;</span> (<span class="dt">Base</span> f (g <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> <span class="dt">Base</span> g g <span class="ot">-&gt;</span> c)</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">     <span class="ot">-&gt;</span> f <span class="ot">-&gt;</span> g <span class="ot">-&gt;</span> c</a>
<a class="sourceLine" id="cb13-4" data-line-number="4">zipo alg <span class="fu">=</span> cata (\x <span class="ot">-&gt;</span> alg x <span class="fu">.</span> project)</a></code></pre></div>
<p>And the new version of <code class="sourceCode haskell">zip</code> has a slightly more natural order of arguments:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1">zip<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a,b)]</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">zip <span class="fu">=</span> zipo alg <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3">  alg <span class="dt">Nil</span> _ <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb14-4" data-line-number="4">  alg _ <span class="dt">Nil</span> <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb14-5" data-line-number="5">  alg (<span class="dt">Cons</span> x xs) (<span class="dt">Cons</span> y ys) <span class="fu">=</span> (x,y) <span class="fu">:</span> xs ys</a></code></pre></div>
<h2 id="zipping-into">Zipping Into</h2>
<p>There’s one more issue, though, that’s slightly tangential. A lot of the time, the attraction of rewriting functions using folds and catamorphisms is that the function becomes more general: it no longer is restricted to lists. For <code class="sourceCode haskell">zip</code>, however, there’s still a pesky list left in the signature:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1">zip<span class="ot"> ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Foldable</span> g) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> g b <span class="ot">-&gt;</span> [(a,b)]</a></code></pre></div>
<p>It would be a little nicer to be able to zip through something <em>preserving</em> the structure of one of the things being zipped through. For no reason in particular, let’s assume we’ll preserve the structure of the first argument. The function will have to account for the second argument running out before the first, though. A <code class="sourceCode haskell"><span class="dt">Maybe</span></code> can account for that:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="ot">zipInto ::</span> (<span class="dt">Foldable</span> f, <span class="dt">Foldable</span> g) </a>
<a class="sourceLine" id="cb16-2" data-line-number="2">        <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b <span class="ot">-&gt;</span> c) </a>
<a class="sourceLine" id="cb16-3" data-line-number="3">        <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> g b <span class="ot">-&gt;</span> f c</a></code></pre></div>
<p>If the second argument runs out, <code class="sourceCode haskell"><span class="dt">Nothing</span></code> will be passed to the combining function.</p>
<p>It’s clear that this isn’t a <em>fold</em> over the first argument, it’s a <em>traversal</em>. A first go at the function uses the state monad, but restricts the second argument to a list:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="ot">zipInto ::</span> <span class="dt">Traversable</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> f c</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">zipInto c xs ys <span class="fu">=</span> evalState (traverse f xs) ys <span class="kw">where</span></a>
<a class="sourceLine" id="cb17-3" data-line-number="3">  f x <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb17-4" data-line-number="4">    h <span class="ot">&lt;-</span> gets uncons</a>
<a class="sourceLine" id="cb17-5" data-line-number="5">    <span class="kw">case</span> h <span class="kw">of</span> </a>
<a class="sourceLine" id="cb17-6" data-line-number="6">      <span class="dt">Just</span> (y,t) <span class="ot">-&gt;</span> <span class="kw">do</span> </a>
<a class="sourceLine" id="cb17-7" data-line-number="7">        put t</a>
<a class="sourceLine" id="cb17-8" data-line-number="8">        pure (c x (<span class="dt">Just</span> y))</a>
<a class="sourceLine" id="cb17-9" data-line-number="9">      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> pure (c x <span class="dt">Nothing</span>)</a></code></pre></div>
<p>That code can be cleaned up a little:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="ot">zipInto ::</span> <span class="dt">Traversable</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> f c </a>
<a class="sourceLine" id="cb18-2" data-line-number="2">zipInto c <span class="fu">=</span> evalState <span class="fu">.</span> traverse (state <span class="fu">.</span> f <span class="fu">.</span> c) <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3">  f x [] <span class="fu">=</span> (x <span class="dt">Nothing</span>, [])</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">  f x (y<span class="fu">:</span>ys) <span class="fu">=</span> (x (<span class="dt">Just</span> y), ys)</a></code></pre></div>
<p>But really, the uncons needs to go. Another <code class="sourceCode haskell"><span class="kw">newtype</span></code> wrapper is needed, and here’s the end result:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">RecAccu</span> a b <span class="fu">=</span></a>
<a class="sourceLine" id="cb19-2" data-line-number="2">  <span class="dt">RecAccu</span> {<span class="ot"> runRecAccu ::</span> a <span class="ot">-&gt;</span> (<span class="dt">RecAccu</span> a b, b) }</a>
<a class="sourceLine" id="cb19-3" data-line-number="3">  </a>
<a class="sourceLine" id="cb19-4" data-line-number="4"><span class="ot">zipInto ::</span> (<span class="dt">Traversable</span> t, <span class="dt">Foldable</span> f)</a>
<a class="sourceLine" id="cb19-5" data-line-number="5">        <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> t c</a>
<a class="sourceLine" id="cb19-6" data-line-number="6">zipInto f xs <span class="fu">=</span></a>
<a class="sourceLine" id="cb19-7" data-line-number="7">  snd <span class="fu">.</span> flip (mapAccumL runRecAccu) xs <span class="fu">.</span> <span class="dt">RecAccu</span> <span class="fu">.</span> foldr h i <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-8" data-line-number="8">    i e <span class="fu">=</span> (<span class="dt">RecAccu</span> i, f e <span class="dt">Nothing</span>)</a>
<a class="sourceLine" id="cb19-9" data-line-number="9">    h e2 a e1 <span class="fu">=</span> (<span class="dt">RecAccu</span> a, f e1 (<span class="dt">Just</span> e2))</a></code></pre></div>
]]></description>
    <pubDate>Sun, 17 Apr 2016 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2016-04-17-folding-two-at-once.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>A Trie in Haskell</title>
    <link>https://doisinkidney.com/posts/2015-10-06-haskell-trie-lhs.html</link>
    <description><![CDATA[<div class="info">
    Posted on October  6, 2015
</div>
<div class="info">
    
        Part 1 of a <a href="/series/tries.html">2-part series on tries</a>
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Data%20Structures.html">Data Structures</a>
    
</div>

<h2 id="basic-ops">Basic Ops</h2>
<p>A Trie is one of those data structures that I find myself writing very early on in almost every language I try to learn. It’s elegant and interesting, and easy enough to implement.</p>
<p>I usually write a version that is a set-like data structure, rather than a mapping type, for simplicity’s sake. It stores sequences, in a prefix-tree structure. It has a map (dictionary) where the keys are the first element of every sequence it stores, and the values are the Tries which store the rest of the sequence. It also has a boolean tag, representing whether or not the current Trie is a Trie on which a sequence ends. Here’s what the type looks like in Haskell:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell literate hidden_source"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">module</span> <span class="dt">Trie</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map.Strict</span> <span class="kw">as</span> <span class="dt">Map</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="kw">import</span> <span class="dt">Data.Map.Strict</span> (<span class="dt">Map</span>)</a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (null)</a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="kw">import</span> <span class="dt">Data.Maybe</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="kw">import</span> <span class="dt">Control.Monad</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"><span class="kw">import</span> <span class="dt">Data.Foldable</span> (fold)</a></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Trie</span> a <span class="fu">=</span> <span class="dt">Trie</span> {<span class="ot"> endHere ::</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">                   ,<span class="ot"> getTrie ::</span> <span class="dt">Map</span> a (<span class="dt">Trie</span> a)</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">                   } <span class="kw">deriving</span> (<span class="dt">Eq</span>)</a></code></pre></div>
<p>Now, inserting into the Trie is easy. You just <code class="sourceCode haskell">uncons</code> on a list, and insert the head into the map, with the value being the tail inserted into whatever existed at that key before:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">empty ::</span> <span class="dt">Trie</span> a</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">empty <span class="fu">=</span> <span class="dt">Trie</span> <span class="dt">False</span> Map.empty</a>
<a class="sourceLine" id="cb3-3" data-line-number="3"></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="ot">insertRec ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Trie</span> a</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">insertRec [] (<span class="dt">Trie</span> _ m)     <span class="fu">=</span> <span class="dt">Trie</span> <span class="dt">True</span> m</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">insertRec (x<span class="fu">:</span>xs) (<span class="dt">Trie</span> e m) <span class="fu">=</span> </a>
<a class="sourceLine" id="cb3-7" data-line-number="7">  <span class="dt">Trie</span> e (Map.alter (<span class="dt">Just</span> <span class="fu">.</span> insertRec xs <span class="fu">.</span> fromMaybe empty) x m)</a></code></pre></div>
<p>Searching is simple, also. For the empty list, you just check if the Trie has its <code class="sourceCode haskell">endHere</code> tag set to <code class="sourceCode haskell"><span class="dt">True</span></code>, otherwise, you uncons, search the map, and query the Trie with the tail if it eas found, or just return <code class="sourceCode haskell"><span class="dt">False</span></code> if it was not:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">memberRec ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">memberRec [] (<span class="dt">Trie</span> e _)     <span class="fu">=</span> e</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">memberRec (x<span class="fu">:</span>xs) (<span class="dt">Trie</span> _ m) <span class="fu">=</span> </a>
<a class="sourceLine" id="cb4-4" data-line-number="4">  fromMaybe <span class="dt">False</span> (memberRec xs <span class="fu">&lt;$&gt;</span> Map.lookup x m)</a></code></pre></div>
<p>Here’s my problem. <em>Both</em> of those functions have the same pattern:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1">f []     <span class="fu">=</span> <span class="fu">...</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">f (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="fu">...</span></a></code></pre></div>
<p>Any good Haskeller should be <em>begging</em> for a fold at this stage. But it proved a little trickier than I’d imagined. Take <code class="sourceCode haskell">member</code>, for instance. You want to fold over a list, with the base case being the tag on the Trie:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">member ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">member <span class="fu">=</span> foldr f base <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  base <span class="fu">=</span> <span class="fu">???</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">  f e a <span class="fu">=</span> Map.lookup e <span class="fu">???</span></a></code></pre></div>
<p>Where do you get the base case from, though? You have to specify it from the beginning, but the variable you’re looking for is nested deeply into the Trie. How can you look into the Trie, without traversing the list, to find the tag, <em>at the beginning of the function?</em></p>
<p>That had been my issue for a while. Every time I cam back to writing a Trie, I would see the pattern, try and write <code class="sourceCode haskell">insert</code> and <code class="sourceCode haskell">member</code> with a fold, and remember again the trouble I had had with it in the past. Recently, though, I saw a different problem, that gave me an idea for a solution.</p>
<h2 id="the-highest-order">The Highest Order</h2>
<blockquote>
<p>Rewrite <code class="sourceCode haskell">dropWhile</code> using <code class="sourceCode haskell">foldr</code></p>
</blockquote>
<p>It’s a (semi) well-known puzzle, that’s maybe a little more difficult than it seems at first. Here, for instance, was my first attempt at it:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">dropWhileWrong ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">dropWhileWrong p <span class="fu">=</span> foldr f [] <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  f e a <span class="fu">|</span> p e       <span class="fu">=</span> a</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">        <span class="fu">|</span> otherwise <span class="fu">=</span> e<span class="fu">:</span>a</a></code></pre></div>
<p>Yeah. That’s <code class="sourceCode haskell">filter</code>, not <code class="sourceCode haskell">dropWhile</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell literate example"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">dropWhileWrong (<span class="fu">&lt;</span><span class="dv">5</span>) [<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">6</span>, <span class="dv">3</span>, <span class="dv">1</span>]</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">[<span class="dv">6</span>]</a></code></pre></div>
<p>Here was my final solution:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">dropWhileCount ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">dropWhileCount p l <span class="fu">=</span> drop (foldr f <span class="dv">0</span> l) l <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  f e a <span class="fu">|</span> p e       <span class="fu">=</span> a <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4">        <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dv">0</span></a></code></pre></div>
<p>After the problem I found <a href="https://wiki.haskell.org/wikiupload/1/14/TMR-Issue6.pdf">this</a> issue of The Monad Reader, which talks about the same problem. In my <code class="sourceCode haskell">drop</code> version, I had been counting the number of items to drop as I went, adding one for every element that passed the test. The corresponding version in the article had been building up <code class="sourceCode haskell">tail</code> functions, using <code class="sourceCode haskell"><span class="fu">.</span></code> to add them together:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">dropWhileTail ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">dropWhileTail p l <span class="fu">=</span> (foldr f id l) l <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  f e a <span class="fu">|</span> p e       <span class="fu">=</span> tail <span class="fu">.</span> a</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">        <span class="fu">|</span> otherwise <span class="fu">=</span> id</a></code></pre></div>
<p>A quick visit to <a href="http://pointfree.io">pointfree.io</a> can generate some monadic pointsfree magic:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">dropWhilePf ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">dropWhilePf p <span class="fu">=</span> join (foldr f id) <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  f e a <span class="fu">|</span> p e       <span class="fu">=</span> tail <span class="fu">.</span> a</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">        <span class="fu">|</span> otherwise <span class="fu">=</span> id</a></code></pre></div>
<p>Now, the final version in the article did <em>not</em> use this technique, as it was very inefficient. It used some cleverness beyond the scope of this post. The second-from-last version I quite liked, though:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="ot">dropWhileFp ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">dropWhileFp p l <span class="fu">=</span> foldr f l l <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">  f e a <span class="fu">|</span> p e       <span class="fu">=</span> tail a</a>
<a class="sourceLine" id="cb12-4" data-line-number="4">        <span class="fu">|</span> otherwise <span class="fu">=</span> l</a></code></pre></div>
<p>However, the idea of building up a function in a fold gave me an idea for adapting it to some of the Trie functions.</p>
<h2 id="folding-inwards">Folding Inwards</h2>
<p>Let’s start with <code class="sourceCode haskell">member</code>. It needs to fold over a list, and generate a function which acts on a Trie:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="ot">member ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">member <span class="fu">=</span> foldr f base</a></code></pre></div>
<p>The <code class="sourceCode haskell">base</code> is the function being built up: the final part of the function chain. Each part of the function is generated based on each element of the list, and then chained with the base using <code class="sourceCode haskell"><span class="fu">.</span></code>:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1">member <span class="fu">=</span> foldr f base <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2">  f e a <span class="fu">=</span> <span class="fu">???</span> <span class="fu">.</span> a </a></code></pre></div>
<p>The base here is what’s called when the list is empty. Here’s what it looked like in the explicit recursion version:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1">member [] (<span class="dt">Trie</span> e _) <span class="fu">=</span> e</a></code></pre></div>
<p>We could simplify this by using record syntax, and <code class="sourceCode haskell">getTrie</code>:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1">member [] t <span class="fu">=</span> getTrie t</a></code></pre></div>
<p>And this has an obvious pointsfree version:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1">member [] <span class="fu">=</span> getTrie</a></code></pre></div>
<p>That fits for the base case. It’s just a function:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1">member <span class="fu">=</span> foldr f endHere <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2">  f e a <span class="fu">=</span> <span class="fu">???</span> <span class="fu">.</span> a </a></code></pre></div>
<p>Then, how to combine it. That’s easy enough, actually. It accesses the map, searches it for the key, and calls the accumulating function on it. If it’s not found in the map, just return <code class="sourceCode haskell"><span class="dt">False</span></code>. Here it is:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="ot">member ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb19-2" data-line-number="2">member <span class="fu">=</span> foldr f endHere <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-3" data-line-number="3">  f e a <span class="fu">=</span> fromMaybe <span class="dt">False</span> <span class="fu">.</span> fmap a <span class="fu">.</span> Map.lookup e <span class="fu">.</span> getTrie</a></code></pre></div>
<p>One of the other standard functions for a Trie is returning the “completions” for a given sequence. It’s a very similar function to <code class="sourceCode haskell">member</code>, actually: instead of calling <code class="sourceCode haskell">endHere</code> on the final Trie found, though, just return the Trie itself. And the thing to return if any given element of the sequence isn’t found is just an empty Trie:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="ot">complete ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Trie</span> a</a>
<a class="sourceLine" id="cb20-2" data-line-number="2">complete <span class="fu">=</span> foldr f id <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-3" data-line-number="3">  f e a <span class="fu">=</span> fromMaybe empty <span class="fu">.</span> fmap a <span class="fu">.</span> Map.lookup e <span class="fu">.</span> getTrie </a></code></pre></div>
<p>In fact, you could abstract out the commonality here:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="ot">follow ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> c <span class="ot">-&gt;</span> (<span class="dt">Trie</span> a <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> c</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">follow ifMiss onEnd <span class="fu">=</span> foldr f onEnd <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-3" data-line-number="3">  f e a <span class="fu">=</span> fromMaybe ifMiss <span class="fu">.</span> fmap a <span class="fu">.</span> Map.lookup e <span class="fu">.</span> getTrie </a>
<a class="sourceLine" id="cb21-4" data-line-number="4">  </a>
<a class="sourceLine" id="cb21-5" data-line-number="5"><span class="ot">memberAbs ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb21-6" data-line-number="6">memberAbs <span class="fu">=</span> follow <span class="dt">False</span> endHere</a>
<a class="sourceLine" id="cb21-7" data-line-number="7"></a>
<a class="sourceLine" id="cb21-8" data-line-number="8"><span class="ot">completeAbs ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Trie</span> a</a>
<a class="sourceLine" id="cb21-9" data-line-number="9">completeAbs <span class="fu">=</span> follow empty id</a></code></pre></div>
<h2 id="folding-in-and-out">Folding in and out</h2>
<p><code class="sourceCode haskell">insert</code> is another deal entirely. In <code class="sourceCode haskell">member</code>, the fold was tunneling into a Trie, applying the accumulator function to successively deeper Tries, and returning a result based on the final Trie. <code class="sourceCode haskell">insert</code> needs to do the same tunneling - but the Trie returned needs to be the <em>outer</em> Trie.</p>
<p>It turns out it’s not that difficult. Instead of “building up a function” that is then applied to a Trie, here a function is “sent” into the inner Tries. The cool thing here is that the function being sent hasn’t been generated yet.</p>
<p>Here’s some more illustration of what I mean. Start off with the normal <code class="sourceCode haskell">foldr</code>:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="ot">insert ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Trie</span> a</a>
<a class="sourceLine" id="cb22-2" data-line-number="2">insert <span class="fu">=</span> foldr f (\(<span class="dt">Trie</span> _ m) <span class="ot">-&gt;</span> <span class="dt">Trie</span> <span class="dt">True</span> m)</a></code></pre></div>
<p>With the final function to be applied being one that just flips the <code class="sourceCode haskell">endHere</code> tag to <code class="sourceCode haskell"><span class="dt">True</span></code>. Then <code class="sourceCode haskell">f</code>: this is going to act <em>over</em> the map of the Trie that it’s called on. It’s useful to define a function just for that:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="ot">overMap ::</span> <span class="dt">Ord</span> b </a>
<a class="sourceLine" id="cb23-2" data-line-number="2">        <span class="ot">=&gt;</span> (<span class="dt">Map.Map</span> a (<span class="dt">Trie</span> a)</a>
<a class="sourceLine" id="cb23-3" data-line-number="3">        <span class="ot">-&gt;</span> <span class="dt">Map.Map</span> b (<span class="dt">Trie</span> b))</a>
<a class="sourceLine" id="cb23-4" data-line-number="4">        <span class="ot">-&gt;</span> <span class="dt">Trie</span> a</a>
<a class="sourceLine" id="cb23-5" data-line-number="5">        <span class="ot">-&gt;</span> <span class="dt">Trie</span> b</a>
<a class="sourceLine" id="cb23-6" data-line-number="6">overMap f (<span class="dt">Trie</span> e m) <span class="fu">=</span> <span class="dt">Trie</span> e (f m)</a></code></pre></div>
<p>Then, it will look up the next element of the sequence in the Trie, and apply the accumulating function to it. (if it’s not found it will provide an empty Trie instead) Simple!</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell literate hidden_source"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Trie</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-2" data-line-number="2">  mempty <span class="fu">=</span> <span class="dt">Trie</span> <span class="dt">False</span> Map.empty</a>
<a class="sourceLine" id="cb24-3" data-line-number="3">  <span class="dt">Trie</span> v k <span class="ot">`mappend`</span> <span class="dt">Trie</span> t l <span class="fu">=</span></a>
<a class="sourceLine" id="cb24-4" data-line-number="4">    <span class="dt">Trie</span> (v <span class="fu">||</span> t) (Map.unionWith mappend k l)</a></code></pre></div>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="ot">insert ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Trie</span> a</a>
<a class="sourceLine" id="cb25-2" data-line-number="2">insert <span class="fu">=</span> foldr f (\(<span class="dt">Trie</span> _ m) <span class="ot">-&gt;</span> <span class="dt">Trie</span> <span class="dt">True</span> m) <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-3" data-line-number="3">  f e a <span class="fu">=</span> </a>
<a class="sourceLine" id="cb25-4" data-line-number="4">    overMap (Map.alter (<span class="dt">Just</span> <span class="fu">.</span> a <span class="fu">.</span> fold) e)</a></code></pre></div>
<p>I think this is really cool: with just a <code class="sourceCode haskell">foldr</code>, you’re burrowing into a Trie, changing it, and burrowing back out again.</p>
<h2 id="removal">Removal</h2>
<p>This is always the tricky one with a Trie. You <em>can</em> just follow a given sequence down to its tag, and flip it from on to off. But that doesn’t remove the sequence itself from the Trie. So maybe you just delete the sequence - but that doesn’t work either. How do you know that there are no other sequences stored below the one you were examining?</p>
<p>What you need to do is to send a function into the Trie, and have it report back as to whether or not it stores other sequences below it. So this version of <code class="sourceCode haskell">foldr</code> is going to burrow into the Trie, like <code class="sourceCode haskell">member</code>; maintain the outer Trie, like <code class="sourceCode haskell">insert</code>; but <em>also</em> send messages back up to the outer functions. Cool!</p>
<p>The way to do the “message sending” is with <code class="sourceCode haskell"><span class="dt">Maybe</span></code>. If the function you send into the Trie to delete the end of the sequence returns <code class="sourceCode haskell"><span class="dt">Nothing</span></code>, then it signifies that you can delete that member. Luckily, the <code class="sourceCode haskell">alter</code> function on <code class="sourceCode haskell"><span class="dt">Data.Map</span></code> works well with this:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="ot">alter ::</span> <span class="dt">Ord</span> k </a>
<a class="sourceLine" id="cb26-2" data-line-number="2">      <span class="ot">=&gt;</span> (<span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a)</a>
<a class="sourceLine" id="cb26-3" data-line-number="3">      <span class="ot">-&gt;</span> k</a>
<a class="sourceLine" id="cb26-4" data-line-number="4">      <span class="ot">-&gt;</span> <span class="dt">Map</span> k a</a>
<a class="sourceLine" id="cb26-5" data-line-number="5">      <span class="ot">-&gt;</span> <span class="dt">Map</span> k a</a></code></pre></div>
<p>Its first argument is a function which is given the result of looking up its <em>second</em> argument. If the function returns <code class="sourceCode haskell"><span class="dt">Nothing</span></code>, that key-value pair in the map is deleted (if it was there). If it returns <code class="sourceCode haskell"><span class="dt">Just</span></code> something, though, that key-value pair is added. In the delete function, we can chain the accumulating function with <code class="sourceCode haskell"><span class="fu">=&lt;&lt;</span></code>. This will skip the rest of the accumulation if any part of the sequence isn’t found. The actual function we’re chaining on is <code class="sourceCode haskell">nilIfEmpty</code>, which checks if a given Trie is empty, and returns <code class="sourceCode haskell"><span class="dt">Just</span></code> the Trie if it’s not, or <code class="sourceCode haskell"><span class="dt">Nothing</span></code> otherwise.</p>
<p>Here’s the finished version:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="ot">delete ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Trie</span> a</a>
<a class="sourceLine" id="cb27-2" data-line-number="2">delete <span class="fu">=</span> (fromMaybe empty <span class="fu">.</span>) <span class="fu">.</span> foldr f i <span class="kw">where</span></a>
<a class="sourceLine" id="cb27-3" data-line-number="3">  i (<span class="dt">Trie</span> _ m) <span class="fu">|</span> Map.null m  <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb27-4" data-line-number="4">               <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Just</span> (<span class="dt">Trie</span> <span class="dt">False</span> m)</a>
<a class="sourceLine" id="cb27-5" data-line-number="5">  f e a <span class="fu">=</span> nilIfEmpty <span class="fu">.</span> overMap (Map.alter (a <span class="fu">=&lt;&lt;</span>) e) </a>
<a class="sourceLine" id="cb27-6" data-line-number="6">  </a>
<a class="sourceLine" id="cb27-7" data-line-number="7">null<span class="ot"> ::</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb27-8" data-line-number="8">null (<span class="dt">Trie</span> e m) <span class="fu">=</span> (not e) <span class="fu">&amp;&amp;</span> (Map.null m)</a>
<a class="sourceLine" id="cb27-9" data-line-number="9"></a>
<a class="sourceLine" id="cb27-10" data-line-number="10"><span class="ot">nilIfEmpty ::</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Trie</span> a)</a>
<a class="sourceLine" id="cb27-11" data-line-number="11">nilIfEmpty t <span class="fu">|</span> null t    <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb27-12" data-line-number="12">             <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Just</span> t</a></code></pre></div>
<h2 id="folding-the-foldable">Folding the Foldable</h2>
<p>So how about folding the Trie itself? Same trick: build up a function with a fold. This time, a fold over the map, not a list. And the function being built up is a cons operation. When you hit a <code class="sourceCode haskell"><span class="dt">True</span></code> tag, fire off an empty list to the built-up function, allowing it to evaluate:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1"><span class="ot">foldrTrie ::</span> ([a] <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Trie</span> a <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb28-2" data-line-number="2">foldrTrie f i (<span class="dt">Trie</span> a m) <span class="fu">=</span> Map.foldrWithKey ff s m <span class="kw">where</span></a>
<a class="sourceLine" id="cb28-3" data-line-number="3">  s    <span class="fu">=</span> <span class="kw">if</span> a <span class="kw">then</span> f [] i <span class="kw">else</span> i</a>
<a class="sourceLine" id="cb28-4" data-line-number="4">  ff k <span class="fu">=</span> flip (foldrTrie <span class="fu">$</span> f <span class="fu">.</span> (k <span class="fu">:</span>))</a></code></pre></div>
<p>Unfortunately, <a href="http://stackoverflow.com/questions/33469157/foldable-instance-for-a-trie-set">it’s not easy</a> to make the Trie <em>conform</em> to <code class="sourceCode haskell"><span class="dt">Foldable</span></code>. It is possible, and it’s what I’m currently trying to figure out, but it’s non-trivial.</p>
]]></description>
    <pubDate>Tue, 06 Oct 2015 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2015-10-06-haskell-trie-lhs.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Faking dependent types in Swift</title>
    <link>https://doisinkidney.com/posts/2015-09-06-dependent-types.html</link>
    <description><![CDATA[<div class="info">
    Posted on September  6, 2015
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Swift.html">Swift</a>, <a href="/tags/Dependent%20Types.html">Dependent Types</a>
    
</div>

<p><a href="https://en.wikipedia.org/wiki/Dependent_type">Dependent types</a> are types “that depend on values”. Say you had a function <code class="sourceCode scala">f</code> that took an integer. If you can write that function whereby it returns a value of type <code class="sourceCode scala">A</code> when that integer is even, or a type <code class="sourceCode scala">B</code> if the integer is odd, then you’re working with dependent types. (I think. I’m not sure: if I’ve got it wrong <a href="https://twitter.com/oisdk">tweet me</a>.)</p>
<h2 id="dependent-pretendance">Dependent Pretendance</h2>
<p>As far as I can tell, this is not possible in Swift. All variables are statically typed, and those types must be found at compile-time. As long as you’re not messing around with casting:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb1-1" data-line-number="1">struct A {}</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">struct B {}</a>
<a class="sourceLine" id="cb1-3" data-line-number="3"></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">func <span class="fu">f</span>(i: Int) -&gt; AnyObject {</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">  <span class="kw">return</span> i % <span class="dv">2</span> == <span class="dv">0</span> ? <span class="fu">A</span>() as! AnyObject : <span class="fu">B</span>() as! AnyObject</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">}</a></code></pre></div>
<p>You won’t be able to manage it.</p>
<p>Now, sum types can give you something that <em>looks</em> like dependent types:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb2-1" data-line-number="1">struct A {}</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">struct B {}</a>
<a class="sourceLine" id="cb2-3" data-line-number="3"></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">enum SumType {</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">  <span class="kw">case</span> <span class="fu">Even</span>(A), <span class="fu">Odd</span>(B)</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">}</a>
<a class="sourceLine" id="cb2-7" data-line-number="7"></a>
<a class="sourceLine" id="cb2-8" data-line-number="8">func <span class="fu">f</span>(i: Int) -&gt; SumType {</a>
<a class="sourceLine" id="cb2-9" data-line-number="9">  <span class="kw">return</span> i % <span class="dv">2</span> == <span class="dv">0</span> ? .<span class="fu">Even</span>(<span class="fu">A</span>()) : .<span class="fu">Odd</span>(<span class="fu">B</span>())</a>
<a class="sourceLine" id="cb2-10" data-line-number="10">}</a></code></pre></div>
<p>But that doesn’t fit the description: the thing returned is of type <code class="sourceCode scala">SumType</code>, <em>not</em> <code class="sourceCode scala">A</code> or <code class="sourceCode scala">B</code>.</p>
<p>That’s fine, though. As with all of these highfalutin mathematical concepts in programming, you can steal some of the cool and fun <em>patterns</em> from your Haskells and Lisps and Idrises and implement them in whatever language you want.</p>
<p>As it happens, implementing this stuff in Swift gets you even <em>further</em> away from the formal definition of dependent types. Instead of allowing types to be decided at runtime, you end up forcing even <em>more</em> resolution and computation to happen at compile-time. Take “numbers-as-types”, for instance:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb3-1" data-line-number="1">protocol Nat { <span class="fu">init</span>() }</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">struct Zero : Nat {}</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">protocol NonZero: Nat { typealias Pred: Nat }</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">struct Succ&lt;N : Nat&gt; : NonZero { typealias Pred = N }</a></code></pre></div>
<p>Once you encode some numbers by hand:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb4-1" data-line-number="1">typealias One   = Succ&lt;Zero&gt;</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">typealias Two   = Succ&lt;One&gt;</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">typealias Three = Succ&lt;Two&gt;</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">typealias Four  = Succ&lt;Three&gt;</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">typealias Five  = Succ&lt;Four&gt;</a>
<a class="sourceLine" id="cb4-6" data-line-number="6">typealias Six   = Succ&lt;Five&gt;</a>
<a class="sourceLine" id="cb4-7" data-line-number="7">typealias Seven = Succ&lt;Six&gt;</a>
<a class="sourceLine" id="cb4-8" data-line-number="8">typealias Eight = Succ&lt;Seven&gt;</a>
<a class="sourceLine" id="cb4-9" data-line-number="9">typealias Nine  = Succ&lt;Eight&gt;</a></code></pre></div>
<p>You get thinking about exactly <em>how much</em> computation you can achieve at compile time:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb5-1" data-line-number="1">Sum&lt;One, Two&gt;.<span class="fu">Result</span>    <span class="co">// Three</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">Comp&lt;Five, Nine&gt;.<span class="fu">Result</span> <span class="co">// LT</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">Comp&lt;Four, Four&gt;.<span class="fu">Result</span> <span class="co">// EQ</span></a></code></pre></div>
<h2 id="sum-types-divide-types-multiply-types">Sum types, divide types, multiply types</h2>
<p>What I wanted, ideally, was some basic “Algebraic data types”. (Today. Today was the day I made the worst pun.) I wanted to be able to add the type <code class="sourceCode scala">One</code> to the type <code class="sourceCode scala">Two</code> and get the type <code class="sourceCode scala">Three</code>. Once you can manage those, multiplication, division and all kinds of silliness are possible. I set myself some rules: all calculations must be performed at compile-time, and all calculations must work with arbitrary values.</p>
<p>I’ve not been able to manage, unfortunately. If someone could figure out how to do it, I would <a href="https://twitter.com/oisdk">love to hear it</a>. I’ve been stealing ideas from <a href="http://strictlypositive.org/faking.ps.gz">Faking It: Simulating Dependent Types in Haskell</a> mainly.</p>
<p>Here’s the kind of code that made me think it was possible:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb6-1" data-line-number="1">let ar = [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>].<span class="fu">reverse</span>()</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">let se = <span class="fu">AnySequence</span>([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>]).<span class="fu">reverse</span>()</a></code></pre></div>
<p>The types returned by those two methods are different. This is all to do with that protocol-oriented-programming business: the compiler will try to select the most specialised version of a method to use. So in the example above, since an array can just be indexed backwards, the compiler uses a method that returns a lazy <code class="sourceCode scala">ReverseRandomAccessCollection</code>. However, for the <code class="sourceCode scala">AnySequence</code>, the <code class="sourceCode scala">reverse</code> method has to create a whole new array.</p>
<p>With that in mind, we can make a protocol:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb7-1" data-line-number="1">protocol BinaryOp {</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  typealias A: Nat</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  typealias B: Nat</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">}</a></code></pre></div>
<p>Then, we can extend it, like this:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb8-1" data-line-number="1">struct EQ {}</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">extension BinaryOp where A == B {</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  typealias Result = EQ</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">}</a></code></pre></div>
<p>So far, so good! The compiler will add that method to all types that conform to the <code class="sourceCode scala">where</code> clause. So if there is a concrete type that conforms to <code>BinaryOp</code>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb9-1" data-line-number="1">struct Comp&lt;E0: Nat, E1: Nat&gt; : BinaryOp {</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">  typealias A = E0</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  typealias B = E1</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">}</a></code></pre></div>
<p>Only instances where <code class="sourceCode scala">A</code> and <code class="sourceCode scala">B</code> are equal will get the type alias:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb10-1" data-line-number="1">Comp&lt;One, One&gt;.<span class="fu">Result</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">Comp&lt;One, Two&gt;.<span class="fu">Result</span> <span class="co">// Error</span></a></code></pre></div>
<p>But that’s not ideal. We want something that returns <code class="sourceCode scala">NEQ</code> when the types are not the same. Easy enough, right?</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb11-1" data-line-number="1">struct NEQ {}</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">extension BinaryOp {</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  typealias Result = NEQ</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">}</a></code></pre></div>
<p>But there’s an error: <code class="sourceCode scala">invalid redeclaration of &#39;Result&#39;</code>. The compiler won’t allow polymorphism with typealiases. It <em>does</em> allow polymorphism with properties, though:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb12-1" data-line-number="1">extension BinaryOp {</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">  <span class="kw">var</span> r: EQ { <span class="kw">return</span> <span class="fu">EQ</span>() }</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">}</a>
<a class="sourceLine" id="cb12-4" data-line-number="4">extension BinaryOp where A == B {</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">  <span class="kw">var</span> r: NEQ { <span class="kw">return</span> <span class="fu">NEQ</span>() }</a>
<a class="sourceLine" id="cb12-6" data-line-number="6">}</a></code></pre></div>
<p>This is already a less elegant solution than the typealiases, since we’re going to have to initialise things. All of the type information is available at compile-time, though, so I’ve not broken any of my rules.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb13-1" data-line-number="1">Comp&lt;One, One&gt;().<span class="fu">r</span> <span class="co">// EQ</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">Comp&lt;One, Two&gt;().<span class="fu">r</span> <span class="co">// NEQ</span></a></code></pre></div>
<p>How about something more complex? Instead of <code class="sourceCode scala">EQ</code> and <code class="sourceCode scala">NEQ</code>, maybe <code class="sourceCode scala">LT</code>, <code class="sourceCode scala">GT</code>, and <code>EQ</code>?</p>
<p>It’s hard to see how it would work. Well, here’s the base case:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb14-1" data-line-number="1">extension BinaryOp where A == B {</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">  <span class="kw">var</span> r: EQ { <span class="kw">return</span> <span class="fu">EQ</span>() }</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">}</a></code></pre></div>
<p>Then, any non-zero is bigger than zero:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb15-1" data-line-number="1">struct LT {}</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">extension BinaryOp where A == Zero, B : NonZero {</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">  <span class="kw">var</span> r: LT { <span class="kw">return</span> <span class="fu">LT</span>() }</a>
<a class="sourceLine" id="cb15-4" data-line-number="4">}</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">struct GT {}</a>
<a class="sourceLine" id="cb15-6" data-line-number="6">extension BinaryOp where A : NonZero, B == Zero {</a>
<a class="sourceLine" id="cb15-7" data-line-number="7">  <span class="kw">var</span> r: GT { <span class="kw">return</span> <span class="fu">GT</span>() }</a>
<a class="sourceLine" id="cb15-8" data-line-number="8">}</a></code></pre></div>
<p>If both <code class="sourceCode scala">A</code> and <code class="sourceCode scala">B</code> are nonzero, they should have a <code class="sourceCode scala">Pred</code> typealias, which we can use, recursively:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb16-1" data-line-number="1">extension BinaryOp where A : NonZero, B : NonZero {</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">  <span class="kw">var</span> r: ?? {</a>
<a class="sourceLine" id="cb16-3" data-line-number="3">    <span class="kw">return</span> Comp&lt;A.<span class="fu">Pred</span>, B.<span class="fu">Pred</span>&gt;().<span class="fu">r</span></a>
<a class="sourceLine" id="cb16-4" data-line-number="4">  }</a>
<a class="sourceLine" id="cb16-5" data-line-number="5">}</a></code></pre></div>
<p>This doesn’t work. I’m fairly sure this is a definitive dead end. Here’s the error: <code class="sourceCode scala">ambiguous reference to member <span class="ch">&#39;r&#39;</span></code>. The problem is that that error encapsulates exactly what I’m trying to achieve: I <em>want</em> the reference to be ambiguous, so it <em>depends</em> on the types of <code class="sourceCode scala">A</code> and <code class="sourceCode scala">B</code>. Most other routes I went down hit similar roadblocks:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb17-1" data-line-number="1">protocol BinaryOp {</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">  typealias A: Nat</a>
<a class="sourceLine" id="cb17-3" data-line-number="3">  typealias B: Nat</a>
<a class="sourceLine" id="cb17-4" data-line-number="4">  typealias Result</a>
<a class="sourceLine" id="cb17-5" data-line-number="5">  <span class="kw">var</span> r: Result { get }</a>
<a class="sourceLine" id="cb17-6" data-line-number="6">}</a></code></pre></div>
<p>The idea here was that you could have various implementations of <code class="sourceCode scala">r</code>, so that the <code class="sourceCode scala">Result</code> typealias would be inferred. The problem is the compiler wants to figure out what <code class="sourceCode scala">Result</code> is when you make a type that conforms to the protocol, so every type will get the default implementation.</p>
<p>Yet more versions I tried all hit the <code class="sourceCode scala">ambiguous</code> error, which makes me think this kind of thing is fundamentally impossible in Swift’s current form.</p>
<p>So I’ve got to break one of the rules: no more arbitrary numbers.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb18-1" data-line-number="1">struct AddOne&lt;N : Nat&gt; {</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">  typealias Result = Succ&lt;N&gt;</a>
<a class="sourceLine" id="cb18-3" data-line-number="3">}</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">struct AddTwo&lt;N : Nat&gt; {</a>
<a class="sourceLine" id="cb18-5" data-line-number="5">  typealias Result = Succ&lt;AddOne&lt;N&gt;.<span class="fu">Result</span>&gt;</a>
<a class="sourceLine" id="cb18-6" data-line-number="6">}</a></code></pre></div>
<p>And so on. Or:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb19-1" data-line-number="1">extension Binary where A == B {</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">  <span class="kw">var</span> sub: Zero { <span class="kw">return</span> <span class="fu">Zero</span>() }</a>
<a class="sourceLine" id="cb19-3" data-line-number="3">  <span class="kw">var</span> com: EQ { <span class="kw">return</span> <span class="fu">EQ</span>() }</a>
<a class="sourceLine" id="cb19-4" data-line-number="4">}</a>
<a class="sourceLine" id="cb19-5" data-line-number="5">extension Binary where A == Succ&lt;B&gt; {</a>
<a class="sourceLine" id="cb19-6" data-line-number="6">  <span class="kw">var</span> sub: One { <span class="kw">return</span> <span class="fu">One</span>() }</a>
<a class="sourceLine" id="cb19-7" data-line-number="7">  <span class="kw">var</span> com: GT { <span class="kw">return</span> <span class="fu">GT</span>() }</a>
<a class="sourceLine" id="cb19-8" data-line-number="8">}</a></code></pre></div>
<p>Which can give you subtraction.</p>
<h2 id="lets-pretend-to-be-useful">Let’s Pretend to be Useful</h2>
<p>All of that stuff is interesting, but very <em>very</em> far from being useful.</p>
<p>The <a href="https://bigonotetaking.wordpress.com/2015/09/04/in-which-i-misunderstand-dependent-types/">length-indexed list from the other day</a> probably is useful, though. As well as being kind of cool and safe, there are some (minor) optimisations it can do.</p>
<p>The other dependent type staple is the heterogenous list.</p>
<p>Now, this isn’t just any heterogenous list: we’re not writing Python here. This is a <em>statically typed</em> heterogenous list. Swift has a construct very similar to this already: a tuple!</p>
<p>But tuples aren’t very extensible:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb20-1" data-line-number="1">extension Tuple where First : Comparable {...</a>
<a class="sourceLine" id="cb20-2" data-line-number="2">extension Tuple where Count == Two {...</a></code></pre></div>
<p>And you can’t work with them in terms that most lists can:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb21-1" data-line-number="1">(<span class="dv">1</span>, <span class="st">&quot;a&quot;</span>, <span class="fl">2.0</span>) + (<span class="st">&quot;b&quot;</span>, <span class="dv">-3</span>)</a></code></pre></div>
<p>So that’s where another tuple type can come in. A la <a href="https://twitter.com/rob_rix/status/633262294336729088">Rob Rix</a>, we could make a right-recursive tuple, terminated by <code class="sourceCode scala">()</code>. There’ll be one overarching protocol:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb22-1" data-line-number="1">protocol _AnyTuple : CustomStringConvertible {</a>
<a class="sourceLine" id="cb22-2" data-line-number="2">  <span class="kw">var</span> tDesc: String { get }</a>
<a class="sourceLine" id="cb22-3" data-line-number="3">  <span class="kw">var</span> count: Int { get }</a>
<a class="sourceLine" id="cb22-4" data-line-number="4">  typealias Arity : Nat</a>
<a class="sourceLine" id="cb22-5" data-line-number="5">}</a></code></pre></div>
<p>And the empty tuple:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb23-1" data-line-number="1">struct EmptyTuple {}</a>
<a class="sourceLine" id="cb23-2" data-line-number="2"></a>
<a class="sourceLine" id="cb23-3" data-line-number="3">extension EmptyTuple : _AnyTuple {</a>
<a class="sourceLine" id="cb23-4" data-line-number="4">  <span class="kw">var</span> description: String { <span class="kw">return</span> <span class="st">&quot;()&quot;</span> }</a>
<a class="sourceLine" id="cb23-5" data-line-number="5">  <span class="kw">var</span> tDesc: String { <span class="kw">return</span>  <span class="st">&quot;)&quot;</span> }</a>
<a class="sourceLine" id="cb23-6" data-line-number="6">  <span class="kw">var</span> count: Int { <span class="kw">return</span> <span class="dv">0</span> }</a>
<a class="sourceLine" id="cb23-7" data-line-number="7">  typealias Arity = Zero</a>
<a class="sourceLine" id="cb23-8" data-line-number="8">}</a></code></pre></div>
<p>The descriptions are just there to give us a pretty printout. Here’s the tuple struct:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb24-1" data-line-number="1">struct NonEmptyTuple&lt;Element, Tail : _AnyTuple&gt; { <span class="kw">var</span> (head, tail): (Element, Tail) }</a>
<a class="sourceLine" id="cb24-2" data-line-number="2"></a>
<a class="sourceLine" id="cb24-3" data-line-number="3">extension NonEmptyTuple : _AnyTuple {</a>
<a class="sourceLine" id="cb24-4" data-line-number="4">  <span class="kw">var</span> count: Int { <span class="kw">return</span> tail.<span class="fu">count</span> + <span class="dv">1</span> }</a>
<a class="sourceLine" id="cb24-5" data-line-number="5">  <span class="kw">var</span> description: String {</a>
<a class="sourceLine" id="cb24-6" data-line-number="6">    <span class="kw">return</span> <span class="st">&quot;(&quot;</span> + String(reflecting: head) + tail.<span class="fu">tDesc</span></a>
<a class="sourceLine" id="cb24-7" data-line-number="7">  }</a>
<a class="sourceLine" id="cb24-8" data-line-number="8">  <span class="kw">var</span> tDesc: String {</a>
<a class="sourceLine" id="cb24-9" data-line-number="9">    <span class="kw">return</span> <span class="st">&quot;, &quot;</span> + String(reflecting: head) + tail.<span class="fu">tDesc</span></a>
<a class="sourceLine" id="cb24-10" data-line-number="10">  }</a>
<a class="sourceLine" id="cb24-11" data-line-number="11">  typealias Arity = Succ&lt;Tail.<span class="fu">Arity</span>&gt;</a>
<a class="sourceLine" id="cb24-12" data-line-number="12">}</a></code></pre></div>
<p>Now, to build a tuple. Since it’s right-recursive, it might look like this:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="dv">1</span> , <span class="st">&quot;a&quot;</span> , <span class="fl">4.0</span> , ()</a></code></pre></div>
<p>But there are two problems with that: first, the comma is not overloadable. That’s probably a good thing. Second, it doesn’t really look like a tuple.</p>
<p><a href="https://twitter.com/jckarter/status/639953308401057793">Joe Groff</a> solved the first problem (albeit by committing a mortal sin). Just use a unicode comma! The only one I could find that works has the delightful name of Hypodiastole.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb26-1" data-line-number="1">infix operator ⸒ { associativity right precedence <span class="dv">90</span> }</a></code></pre></div>
<p>Trying to find it in the character viewer each time was a pain, though. So I went with the boring vertical bar.</p>
<p>The second problem can be solved with some sneaky overloading. Here’s what these functions look like:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb27-1" data-line-number="1">infix operator | { associativity right precedence <span class="dv">90</span> }</a>
<a class="sourceLine" id="cb27-2" data-line-number="2"></a>
<a class="sourceLine" id="cb27-3" data-line-number="3">func |&lt;E, T:_AnyTuple&gt;(lhs: E, rhs: T) -&gt; NonEmptyTuple&lt;E, T&gt; {</a>
<a class="sourceLine" id="cb27-4" data-line-number="4">  <span class="kw">return</span> <span class="fu">NonEmptyTuple</span>(head: lhs, tail: rhs)</a>
<a class="sourceLine" id="cb27-5" data-line-number="5">}</a>
<a class="sourceLine" id="cb27-6" data-line-number="6"></a>
<a class="sourceLine" id="cb27-7" data-line-number="7">func |&lt;E, T&gt;(lhs: E, rhs: T) -&gt; NonEmptyTuple&lt;E, NonEmptyTuple&lt;T, EmptyTuple&gt;&gt; {</a>
<a class="sourceLine" id="cb27-8" data-line-number="8">  <span class="kw">return</span> <span class="fu">NonEmptyTuple</span>(head: lhs, tail: <span class="fu">NonEmptyTuple</span>(head: rhs, tail: <span class="fu">EmptyTuple</span>()))</a>
<a class="sourceLine" id="cb27-9" data-line-number="9">}</a></code></pre></div>
<p>We can now, finally, build a Tuple:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb28-1" data-line-number="1">(<span class="dv">1</span> | <span class="fl">2.0</span> | <span class="st">&quot;a&quot;</span> ) <span class="co">// (1, 2.0, &quot;a&quot;)</span></a></code></pre></div>
<p>One little wrinkle with protocols, though. If you try this:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb29-1" data-line-number="1">extension NonEmptyTuple where Arity == Two {...</a></code></pre></div>
<p>There’s an error: <code class="sourceCode scala">neither <span class="kw">type</span> in same-<span class="kw">type</span> refers to a generic parameter or associated <span class="kw">type</span></code>. Generally speaking, <code class="sourceCode scala">==</code> requirements in struct extensions don’t work. However, they do work on protocols. So a wrapper protocol is needed:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb30-1" data-line-number="1">protocol Tuple : _AnyTuple {</a>
<a class="sourceLine" id="cb30-2" data-line-number="2">  typealias Head</a>
<a class="sourceLine" id="cb30-3" data-line-number="3">  typealias Tail : _AnyTuple</a>
<a class="sourceLine" id="cb30-4" data-line-number="4">  typealias Arity : NonZero</a>
<a class="sourceLine" id="cb30-5" data-line-number="5">  <span class="kw">var</span> head : Head { get }</a>
<a class="sourceLine" id="cb30-6" data-line-number="6">  <span class="kw">var</span> tail : Tail { get }</a>
<a class="sourceLine" id="cb30-7" data-line-number="7">}</a>
<a class="sourceLine" id="cb30-8" data-line-number="8"></a>
<a class="sourceLine" id="cb30-9" data-line-number="9">extension NonEmptyTuple : Tuple {}</a></code></pre></div>
<p>Alright. Time to work with it.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb31-1" data-line-number="1">extension Tuple where</a>
<a class="sourceLine" id="cb31-2" data-line-number="2">  Head : IntegerArithmeticType,</a>
<a class="sourceLine" id="cb31-3" data-line-number="3">  Tail : Tuple,</a>
<a class="sourceLine" id="cb31-4" data-line-number="4">  Tail.<span class="fu">Head</span> : IntegerArithmeticType,</a>
<a class="sourceLine" id="cb31-5" data-line-number="5">  Arity == Two {</a>
<a class="sourceLine" id="cb31-6" data-line-number="6">  func <span class="fu">matSum</span>(<span class="kw">with</span>: Self) -&gt; NonEmptyTuple&lt;Head, NonEmptyTuple&lt;Tail.<span class="fu">Head</span>, EmptyTuple&gt;&gt; {</a>
<a class="sourceLine" id="cb31-7" data-line-number="7">    let a = head + <span class="kw">with</span>.<span class="fu">head</span></a>
<a class="sourceLine" id="cb31-8" data-line-number="8">    let b = tail.<span class="fu">head</span> + <span class="kw">with</span>.<span class="fu">tail</span>.<span class="fu">head</span></a>
<a class="sourceLine" id="cb31-9" data-line-number="9">    <span class="kw">return</span> (a | b)</a>
<a class="sourceLine" id="cb31-10" data-line-number="10">  }</a>
<a class="sourceLine" id="cb31-11" data-line-number="11">}</a>
<a class="sourceLine" id="cb31-12" data-line-number="12"></a>
<a class="sourceLine" id="cb31-13" data-line-number="13">(<span class="dv">1</span> | <span class="dv">4</span>).<span class="fu">matSum</span>(<span class="dv">3</span> | <span class="dv">2</span>) <span class="co">// (4, 6)</span></a></code></pre></div>
<p>The basic advantage of this heterogenous list in Swift is its extensibility: you can treat tuples of length 2 as a type, or tuples where the third element is comparable as a type, and so on.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb32-1" data-line-number="1">extension Tuple where Tail : Tuple, Tail.<span class="fu">Head</span> : Comparable {</a>
<a class="sourceLine" id="cb32-2" data-line-number="2">  func isSecondLessThan</a>
<a class="sourceLine" id="cb32-3" data-line-number="3">    &lt;T : Tuple where T.<span class="fu">Tail</span> : Tuple, T.<span class="fu">Tail</span>.<span class="fu">Head</span> == Tail.<span class="fu">Head</span>&gt;</a>
<a class="sourceLine" id="cb32-4" data-line-number="4">    (<span class="kw">with</span>: T) -&gt; Bool {</a>
<a class="sourceLine" id="cb32-5" data-line-number="5">    <span class="kw">return</span> tail.<span class="fu">head</span> &lt; <span class="kw">with</span>.<span class="fu">tail</span>.<span class="fu">head</span></a>
<a class="sourceLine" id="cb32-6" data-line-number="6">  }</a>
<a class="sourceLine" id="cb32-7" data-line-number="7">}</a>
<a class="sourceLine" id="cb32-8" data-line-number="8"></a>
<a class="sourceLine" id="cb32-9" data-line-number="9">let a = (<span class="dv">1</span> | <span class="fl">3.0</span> | <span class="st">&quot;a&quot;</span> | <span class="dv">43</span>)</a>
<a class="sourceLine" id="cb32-10" data-line-number="10">let b = (<span class="st">&quot;c&quot;</span> | <span class="fl">4.0</span> | <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb32-11" data-line-number="11"></a>
<a class="sourceLine" id="cb32-12" data-line-number="12">a.<span class="fu">isSecondLessThan</span>(b)</a></code></pre></div>
<p>Most of this stuff is madness. The custom infix unicode operator should have tipped you off to that: but it’s not to say that <em>nothing</em> here is useful. Compile-time warnings are great. I think the fixed-length array works. But this tuple stuff is too hacky: it only becomes useful if there are some low-level changes to the language.</p>
<p>What’s really useful, though, is <em>thinking</em> about types with dependency in mind. Getting familiar with what is and isn’t possible to write between the <code class="sourceCode scala">where</code> and the <code class="sourceCode scala">{</code> in an extension gives you a good idea of how powerful protocols and their specialisations are.</p>
<p>For some extra reading, check out <a href="https://ghc.haskell.org/trac/ghc/wiki/DependentHaskell">DependentHaskell</a>, <a href="https://wiki.haskell.org/Heterogenous_collections">Heterogenous Collections in Haskell</a>, and <a href="http://programmers.stackexchange.com/questions/132835/is-there-a-specific-purpose-for-heterogeneous-lists">Strongly Typed Heterogenous Collections</a>. I’m muddling my way through seeing what’s possible with length-indexed lists, heterogenous lists, and numeral types <a href="https://github.com/oisdk/PretendDependSwift">over here</a>, if you’re interested.</p>
]]></description>
    <pubDate>Sun, 06 Sep 2015 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2015-09-06-dependent-types.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Using Protocols to Build a (very) Generic Deque</title>
    <link>https://doisinkidney.com/posts/2015-08-24-generic-deque.html</link>
    <description><![CDATA[<div class="info">
    Posted on August 24, 2015
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Swift.html">Swift</a>, <a href="/tags/Data%20Structures.html">Data Structures</a>
    
</div>

<p>(Download the playground to use the code and see the outputs)</p>
<p>This post is an update on a <a href="https://bigonotetaking.wordpress.com/2015/08/09/yet-another-root-of-all-evil/">previous implementation of a Deque</a>. A full implementation of this Deque is available <a href="https://github.com/oisdk/SwiftDataStructures/blob/master/SwiftDataStructures/Deque.swift">here</a>.</p>
<p>A Deque is a data structure comprised of two stacks, facing opposite directions. In this way, operations at either end of the Deque have the same complexity as operations on one end of the underlying stack. This implementation uses two arrays, with the front reversed: appending, prepending, and removal of the first and last elements are all (amortized) O(1).</p>
<p>The standard library has three <code class="sourceCode scala">Array</code> structs: <code class="sourceCode scala">Array</code>, <code class="sourceCode scala">ArraySlice</code>, and <code class="sourceCode scala">ContiguousArray</code>. They all have the same interface, with different underlying implementations. An <code class="sourceCode scala">Array</code> is a standard vector-like structure, which allows O(1) amortized appending, fast iteration, etc. A <code class="sourceCode scala">ContiguousArray</code> has stricter rules about contiguity, but it’s not bridged to Objective-C.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb1-1" data-line-number="1">let array  = [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>]</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">let cArray: ContiguousArray = [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>]</a></code></pre></div>
<p>An <code class="sourceCode scala">ArraySlice</code> is a reference into an <code class="sourceCode scala">Array</code> or <code class="sourceCode scala">ContiguousArray</code>, for more efficient slicing. All the information an <code class="sourceCode scala">ArraySlice</code> contains is the beginning and end points of the slice (as well as any changes made to the slice separate from the array)</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb2-1" data-line-number="1">let slice = array[<span class="dv">0</span>..&lt;<span class="dv">6</span>]</a></code></pre></div>
<p>To replicate these semantics in a Deque requires three separate structs: one with an <code class="sourceCode scala">Array</code> as the stack, another with an <code class="sourceCode scala">ArraySlice</code> as the stack, and a third with a <code class="sourceCode scala">ContiguousArray</code>. The standard library seems to duplicate the structs, along with their methods and properties.</p>
<p>It would be much nicer to just define a protocol that represented the <em>difference</em> between the deque types: then you could just write the methods and properties once, on top of it. Something like this:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb3-1" data-line-number="1">protocol DequeType {</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  typealias Container : RangeReplaceableCollectionType, MutableSliceable</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">  <span class="kw">var</span> front: Container { get set }</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">  <span class="kw">var</span> back : Container { get set }</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">  <span class="fu">init</span>()</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">}</a></code></pre></div>
<p>There’s one problem with this: both stacks need to be made public. It would be much nicer to hide the stacks (especially since an invariant needs to be checked and maintained on every mutation). If anyone has an idea of how to accomplish that, <a href="https://twitter.com/oisdk">tweet me</a>.</p>
<p>The first method to implement is a subscript. Indexing is difficult, because the front stack will be reversed, so the index used to get in to the Deque will need to be translated into an equivalent index in the array.</p>
<p>Any (valid) index will point into either the front or back queue, and the transformations applied to it in each case is different. If it’s in the front, the end result will look like <code class="sourceCode scala">front[front.<span class="fu">endIndex</span> - <span class="dv">1</span> - i]</code>, whereas if it’s in the back, it should be <code class="sourceCode scala">back[i - front.<span class="fu">endIndex</span>]</code>. There’s nothing specified about the Containers except that they’re <code class="sourceCode scala">RangeReplaceableCollectionType</code> and <code class="sourceCode scala">MutableSliceable</code>, so the index types will have to be as generic as possible. (you could specify <code class="sourceCode scala">where Index == Int</code>, but that’s more specific than needed, and not very extensible.)</p>
<p>Both of those transformations are subtractions, an operation that’s possible on <code>RandomAccessIndexType</code>s with the <code class="sourceCode scala">advancedBy</code> method. <code class="sourceCode scala">advancedBy</code> takes the associated <code class="sourceCode scala">Distance</code> type of the <code class="sourceCode scala">RandomAccessIndexType</code>. That’s enough information to figure out that the Deque’s index type must be the same as the Distance of the Index of the Container.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb4-1" data-line-number="1">extension DequeType {</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  typealias Index = Container.<span class="fu">Index</span>.<span class="fu">Distance</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">}</a></code></pre></div>
<p>The method that will translate an index into the relevant index in the stacks will return an enum:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb5-1" data-line-number="1">public enum IndexLocation&lt;I&gt; {</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">  <span class="kw">case</span> <span class="fu">Front</span>(I), <span class="fu">Back</span>(I)</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">}</a></code></pre></div>
<p>Then, the translate method itself:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb6-1" data-line-number="1">extension DequeType where</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  Container.<span class="fu">Index</span> : RandomAccessIndexType,</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  Container.<span class="fu">Index</span>.<span class="fu">Distance</span> : ForwardIndexType {</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">  </a>
<a class="sourceLine" id="cb6-5" data-line-number="5">  <span class="kw">private</span> func <span class="fu">translate</span>(i: Container.<span class="fu">Index</span>.<span class="fu">Distance</span>)</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">    -&gt; IndexLocation&lt;Container.<span class="fu">Index</span>&gt; {</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">    <span class="kw">return</span> i &lt; front.<span class="fu">count</span> ?</a>
<a class="sourceLine" id="cb6-8" data-line-number="8">      .<span class="fu">Front</span>(front.<span class="fu">endIndex</span>.<span class="fu">predecessor</span>().<span class="fu">advancedBy</span>(-i)) :</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">      .<span class="fu">Back</span>(back.<span class="fu">startIndex</span>.<span class="fu">advancedBy</span>(i - front.<span class="fu">count</span>))</a>
<a class="sourceLine" id="cb6-10" data-line-number="10">  }</a>
<a class="sourceLine" id="cb6-11" data-line-number="11">}</a></code></pre></div>
<p>This performs two steps: 1. Check which stack it’s in. 2. Subtract in the appropriate order</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb7-1" data-line-number="1">let d: Deque = [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>] <span class="co">// [1, 2, 3 | 4, 5, 6]</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">d.<span class="fu">translate</span>(<span class="dv">0</span>) <span class="co">// Front: 2</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">d.<span class="fu">translate</span>(<span class="dv">4</span>) <span class="co">// Back: 1</span></a></code></pre></div>
<p>This means that the logic for converting distance to index is separated from the logic for actual indexing. Great! Here’s the indexing:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb8-1" data-line-number="1">extension DequeType where</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  Container.<span class="fu">Index</span> : RandomAccessIndexType,</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  Container.<span class="fu">Index</span>.<span class="fu">Distance</span> : ForwardIndexType {</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">  <span class="kw">var</span> startIndex: Container.<span class="fu">Index</span>.<span class="fu">Distance</span> { <span class="kw">return</span> <span class="dv">0</span> }</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">  <span class="kw">var</span> endIndex  : Container.<span class="fu">Index</span>.<span class="fu">Distance</span> { <span class="kw">return</span> front.<span class="fu">count</span> + back.<span class="fu">count</span> }</a>
<a class="sourceLine" id="cb8-6" data-line-number="6">  <span class="fu">subscript</span>(i: Container.<span class="fu">Index</span>.<span class="fu">Distance</span>) -&gt; Container.<span class="fu">Generator</span>.<span class="fu">Element</span> {</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">    get {</a>
<a class="sourceLine" id="cb8-8" data-line-number="8">      switch <span class="fu">translate</span>(i) {</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">      <span class="kw">case</span> let .<span class="fu">Front</span>(i): <span class="kw">return</span> front[i]</a>
<a class="sourceLine" id="cb8-10" data-line-number="10">      <span class="kw">case</span> let .<span class="fu">Back</span>(i): <span class="kw">return</span> back[i]</a>
<a class="sourceLine" id="cb8-11" data-line-number="11">      }</a>
<a class="sourceLine" id="cb8-12" data-line-number="12">    } set {</a>
<a class="sourceLine" id="cb8-13" data-line-number="13">      switch <span class="fu">translate</span>(i) {</a>
<a class="sourceLine" id="cb8-14" data-line-number="14">      <span class="kw">case</span> let .<span class="fu">Front</span>(i): front[i] = newValue</a>
<a class="sourceLine" id="cb8-15" data-line-number="15">      <span class="kw">case</span> let .<span class="fu">Back</span>(i): back[i] = newValue</a>
<a class="sourceLine" id="cb8-16" data-line-number="16">      }</a>
<a class="sourceLine" id="cb8-17" data-line-number="17">    }</a>
<a class="sourceLine" id="cb8-18" data-line-number="18">  }</a>
<a class="sourceLine" id="cb8-19" data-line-number="19">}</a></code></pre></div>
<p>This makes things much easier to test and debug.</p>
<p>Here’s where the power of protocols becomes obvious. If you go back to the original definition of <code class="sourceCode scala">DequeType</code>, you can add <code class="sourceCode scala">Indexable</code>. It may seem like now only indexable things can conform, but what happens in practice is that when <code class="sourceCode scala">Indexable</code> looks for its requirements, <em>it can use the implementations in DequeType</em>. That means that we’ve just made anything that can conform to <code class="sourceCode scala">DequeType</code> indexable. That’s awesome.</p>
<p>Next job is ranged indices. This is a good bit more complicated than the individual indices, so it definitely will benefit from being separated into a translate method:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb9-1" data-line-number="1">extension DequeType where</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">  Container.<span class="fu">Index</span> : RandomAccessIndexType,</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  Container.<span class="fu">Index</span>.<span class="fu">Distance</span> : BidirectionalIndexType {</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">  </a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  <span class="kw">private</span> func translate</a>
<a class="sourceLine" id="cb9-6" data-line-number="6">    (i: Range&lt;Container.<span class="fu">Index</span>.<span class="fu">Distance</span>&gt;)</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">    -&gt; IndexRangeLocation&lt;Container.<span class="fu">Index</span>&gt; {</a>
<a class="sourceLine" id="cb9-8" data-line-number="8">      <span class="kw">if</span> i.<span class="fu">endIndex</span> &lt;= front.<span class="fu">count</span> {</a>
<a class="sourceLine" id="cb9-9" data-line-number="9">        let s = front.<span class="fu">endIndex</span>.<span class="fu">advancedBy</span>(-i.<span class="fu">endIndex</span>)</a>
<a class="sourceLine" id="cb9-10" data-line-number="10">        <span class="kw">if</span> s == front.<span class="fu">startIndex</span> &amp;&amp; i.<span class="fu">isEmpty</span> { <span class="kw">return</span> .<span class="fu">Between</span> }</a>
<a class="sourceLine" id="cb9-11" data-line-number="11">        let e = front.<span class="fu">endIndex</span>.<span class="fu">advancedBy</span>(-i.<span class="fu">startIndex</span>)</a>
<a class="sourceLine" id="cb9-12" data-line-number="12">        <span class="kw">return</span> .<span class="fu">Front</span>(s..&lt;e)</a>
<a class="sourceLine" id="cb9-13" data-line-number="13">      }</a>
<a class="sourceLine" id="cb9-14" data-line-number="14">      <span class="kw">if</span> i.<span class="fu">startIndex</span> &gt;= front.<span class="fu">count</span> {</a>
<a class="sourceLine" id="cb9-15" data-line-number="15">        let s = back.<span class="fu">startIndex</span>.<span class="fu">advancedBy</span>(i.<span class="fu">startIndex</span> - front.<span class="fu">count</span>)</a>
<a class="sourceLine" id="cb9-16" data-line-number="16">        let e = back.<span class="fu">startIndex</span>.<span class="fu">advancedBy</span>(i.<span class="fu">endIndex</span> - front.<span class="fu">count</span>)</a>
<a class="sourceLine" id="cb9-17" data-line-number="17">        <span class="kw">return</span> .<span class="fu">Back</span>(s..&lt;e)</a>
<a class="sourceLine" id="cb9-18" data-line-number="18">      }</a>
<a class="sourceLine" id="cb9-19" data-line-number="19">      let f = front.<span class="fu">startIndex</span>..&lt;front.<span class="fu">endIndex</span>.<span class="fu">advancedBy</span>(-i.<span class="fu">startIndex</span>)</a>
<a class="sourceLine" id="cb9-20" data-line-number="20">      let b = back.<span class="fu">startIndex</span>..&lt;back.<span class="fu">startIndex</span>.<span class="fu">advancedBy</span>(i.<span class="fu">endIndex</span> - front.<span class="fu">count</span>)</a>
<a class="sourceLine" id="cb9-21" data-line-number="21">      <span class="kw">return</span> .<span class="fu">Over</span>(f, b)</a>
<a class="sourceLine" id="cb9-22" data-line-number="22">  }</a>
<a class="sourceLine" id="cb9-23" data-line-number="23">}</a>
<a class="sourceLine" id="cb9-24" data-line-number="24"></a>
<a class="sourceLine" id="cb9-25" data-line-number="25">let otherDeque: Deque = [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>] <span class="co">// [0, 1, 2 | 3, 4, 5]</span></a>
<a class="sourceLine" id="cb9-26" data-line-number="26"></a>
<a class="sourceLine" id="cb9-27" data-line-number="27">otherDeque.<span class="fu">translate</span>(<span class="dv">0</span>...<span class="dv">2</span>) <span class="co">// Front: 0..&lt;3</span></a>
<a class="sourceLine" id="cb9-28" data-line-number="28">otherDeque.<span class="fu">translate</span>(<span class="dv">4</span>...<span class="dv">5</span>) <span class="co">// Back: 1..&lt;3</span></a>
<a class="sourceLine" id="cb9-29" data-line-number="29">otherDeque.<span class="fu">translate</span>(<span class="dv">2</span>...<span class="dv">5</span>) <span class="co">// Over: 0..&lt;1, 0..&lt;3</span></a>
<a class="sourceLine" id="cb9-30" data-line-number="30">otherDeque.<span class="fu">translate</span>(<span class="dv">3</span>..&lt;<span class="dv">3</span>) <span class="co">// Between</span></a></code></pre></div>
<p>The invariant that must be maintained in the deque is this: if either stack has more than one element, the other cannot be empty. If the invariant is violated, the longer stack is reversed, and put in place of the shorter.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb10-1" data-line-number="1">public enum Balance {</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">  <span class="kw">case</span> FrontEmpty, BackEmpty, Balanced</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">}</a>
<a class="sourceLine" id="cb10-4" data-line-number="4"></a>
<a class="sourceLine" id="cb10-5" data-line-number="5">extension DequeType {</a>
<a class="sourceLine" id="cb10-6" data-line-number="6">  </a>
<a class="sourceLine" id="cb10-7" data-line-number="7">  public <span class="kw">var</span> balance: Balance {</a>
<a class="sourceLine" id="cb10-8" data-line-number="8">    <span class="fu">let</span> (f, b) = (front.<span class="fu">count</span>, back.<span class="fu">count</span>)</a>
<a class="sourceLine" id="cb10-9" data-line-number="9">    <span class="kw">if</span> f == <span class="dv">0</span> {</a>
<a class="sourceLine" id="cb10-10" data-line-number="10">      <span class="kw">if</span> b &gt; <span class="dv">1</span> {</a>
<a class="sourceLine" id="cb10-11" data-line-number="11">        <span class="kw">return</span> .<span class="fu">FrontEmpty</span></a>
<a class="sourceLine" id="cb10-12" data-line-number="12">      }</a>
<a class="sourceLine" id="cb10-13" data-line-number="13">    } <span class="kw">else</span> <span class="kw">if</span> b == <span class="dv">0</span> {</a>
<a class="sourceLine" id="cb10-14" data-line-number="14">      <span class="kw">if</span> f &gt; <span class="dv">1</span> {</a>
<a class="sourceLine" id="cb10-15" data-line-number="15">        <span class="kw">return</span> .<span class="fu">BackEmpty</span></a>
<a class="sourceLine" id="cb10-16" data-line-number="16">      }</a>
<a class="sourceLine" id="cb10-17" data-line-number="17">    }</a>
<a class="sourceLine" id="cb10-18" data-line-number="18">    <span class="kw">return</span> .<span class="fu">Balanced</span></a>
<a class="sourceLine" id="cb10-19" data-line-number="19">  }</a>
<a class="sourceLine" id="cb10-20" data-line-number="20">  </a>
<a class="sourceLine" id="cb10-21" data-line-number="21">  public <span class="kw">var</span> isBalanced: Bool {</a>
<a class="sourceLine" id="cb10-22" data-line-number="22">    <span class="kw">return</span> balance == .<span class="fu">Balanced</span></a>
<a class="sourceLine" id="cb10-23" data-line-number="23">  }</a>
<a class="sourceLine" id="cb10-24" data-line-number="24">}</a></code></pre></div>
<p>A deque is a good data structure for certain uses, especially those that require popping and appending from either end. <code class="sourceCode scala"><span class="fu">popFirst</span>()</code> and <code class="sourceCode scala"><span class="fu">popLast</span>()</code> aren’t included in the standard <code class="sourceCode scala">RangeReplaceableCollectionType</code>, though, so we’ll have to add our own.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb11-1" data-line-number="1">extension RangeReplaceableCollectionType where Index : BidirectionalIndexType {</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">  <span class="kw">private</span> mutating func <span class="fu">popLast</span>() -&gt; Generator.<span class="fu">Element</span>? {</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">    <span class="kw">return</span> isEmpty ? nil : <span class="fu">removeLast</span>()</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">  }</a>
<a class="sourceLine" id="cb11-5" data-line-number="5">}</a>
<a class="sourceLine" id="cb11-6" data-line-number="6"></a>
<a class="sourceLine" id="cb11-7" data-line-number="7"><span class="kw">var</span> mutableDeque: Deque = [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>]</a>
<a class="sourceLine" id="cb11-8" data-line-number="8">mutableDeque.<span class="fu">popLast</span>() <span class="co">// 5</span></a>
<a class="sourceLine" id="cb11-9" data-line-number="9">mutableDeque           <span class="co">// [0, 1, 2 | 3, 4]</span></a>
<a class="sourceLine" id="cb11-10" data-line-number="10"></a>
<a class="sourceLine" id="cb11-11" data-line-number="11">extension DequeType where Container.<span class="fu">Index</span> : BidirectionalIndexType {</a>
<a class="sourceLine" id="cb11-12" data-line-number="12">  public mutating func <span class="fu">popLast</span>() -&gt; Container.<span class="fu">Generator</span>.<span class="fu">Element</span>? {</a>
<a class="sourceLine" id="cb11-13" data-line-number="13">    <span class="kw">return</span> back.<span class="fu">popLast</span>()</a>
<a class="sourceLine" id="cb11-14" data-line-number="14">  }</a>
<a class="sourceLine" id="cb11-15" data-line-number="15">}</a></code></pre></div>
<p>The method needs to include <code class="sourceCode scala"><span class="fu">check</span>()</code>, which we can do with <code>defer</code></p>
<div class="sourceCode" id="cb12"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb12-1" data-line-number="1">mutating func <span class="fu">popLast</span>() -&gt; Container.<span class="fu">Generator</span>.<span class="fu">Element</span>? {</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">  defer { <span class="fu">check</span>() }</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">  <span class="kw">return</span> back.<span class="fu">popLast</span>()</a>
<a class="sourceLine" id="cb12-4" data-line-number="4">}</a>
<a class="sourceLine" id="cb12-5" data-line-number="5"></a>
<a class="sourceLine" id="cb12-6" data-line-number="6">mutableDeque.<span class="fu">popLast</span>() <span class="co">// 4</span></a>
<a class="sourceLine" id="cb12-7" data-line-number="7">mutableDeque           <span class="co">// [0, 1, 2 | 3]</span></a>
<a class="sourceLine" id="cb12-8" data-line-number="8">mutableDeque.<span class="fu">popLast</span>() <span class="co">// 3</span></a>
<a class="sourceLine" id="cb12-9" data-line-number="9">mutableDeque           <span class="co">// [0 | 1, 2]</span></a></code></pre></div>
<p>You also can’t just pop from the back queue in <code class="sourceCode scala"><span class="fu">popLast</span>()</code>, because it may be the case that the front stack has one element left</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb13-1" data-line-number="1">mutating func <span class="fu">popLast</span>() -&gt; Container.<span class="fu">Generator</span>.<span class="fu">Element</span>? {</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">  defer { <span class="fu">check</span>() }</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">  <span class="kw">return</span> back.<span class="fu">popLast</span>() ?? front.<span class="fu">popLast</span>()</a>
<a class="sourceLine" id="cb13-4" data-line-number="4">}</a>
<a class="sourceLine" id="cb13-5" data-line-number="5"></a>
<a class="sourceLine" id="cb13-6" data-line-number="6">mutableDeque.<span class="fu">popLast</span>() <span class="co">// 2</span></a>
<a class="sourceLine" id="cb13-7" data-line-number="7">mutableDeque.<span class="fu">popLast</span>() <span class="co">// 1</span></a>
<a class="sourceLine" id="cb13-8" data-line-number="8">mutableDeque           <span class="co">// [0|]</span></a>
<a class="sourceLine" id="cb13-9" data-line-number="9">mutableDeque.<span class="fu">popLast</span>() <span class="co">// 0</span></a>
<a class="sourceLine" id="cb13-10" data-line-number="10">mutableDeque           <span class="co">// [|]</span></a>
<a class="sourceLine" id="cb13-11" data-line-number="11">mutableDeque.<span class="fu">popLast</span>() <span class="co">// nil</span></a></code></pre></div>
<p>The rest of the Deque was easy, with little to no repetition. Using protocols in this way was really surprisingly powerful: now, you can define a <code class="sourceCode scala">DequeType</code>, with full access to all of the collection methods, all the way up to <code class="sourceCode scala">RangeReplaceableCollectionType</code>, in five lines:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb14-1" data-line-number="1">public struct Deque&lt;Element&gt; : DequeType {</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">  public <span class="kw">var</span> front, back: [Element]</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">  public typealias SubSequence = DequeSlice&lt;Element&gt;</a>
<a class="sourceLine" id="cb14-4" data-line-number="4">  public <span class="fu">init</span>() { (front, back) = ([], []) }</a>
<a class="sourceLine" id="cb14-5" data-line-number="5">}</a>
<a class="sourceLine" id="cb14-6" data-line-number="6"></a>
<a class="sourceLine" id="cb14-7" data-line-number="7">public struct DequeSlice&lt;Element&gt; : DequeType {</a>
<a class="sourceLine" id="cb14-8" data-line-number="8">  public <span class="kw">var</span> front, back: ArraySlice&lt;Element&gt;</a>
<a class="sourceLine" id="cb14-9" data-line-number="9">  public typealias SubSequence = DequeSlice</a>
<a class="sourceLine" id="cb14-10" data-line-number="10">  public <span class="fu">init</span>() { (front, back) = ([], []) }</a>
<a class="sourceLine" id="cb14-11" data-line-number="11">}</a></code></pre></div>
<p>There’s no performance hit, there’s no safety problems. I only have one version of code to test, one version to change, one version to read. It’s completely extensible: you could use any kind of stack for the front and back. Even another Deque, if you were so inclined:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb15-1" data-line-number="1">struct DequeDeque&lt;Element&gt; : DequeType {</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">  <span class="kw">var</span> front, back: Deque&lt;Element&gt;</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">  typealias SubSequence = DequeDequeSlice&lt;Element&gt;</a>
<a class="sourceLine" id="cb15-4" data-line-number="4">  <span class="fu">init</span>() { front = <span class="fu">Deque</span>(); back = <span class="fu">Deque</span>() }</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">}</a>
<a class="sourceLine" id="cb15-6" data-line-number="6"></a>
<a class="sourceLine" id="cb15-7" data-line-number="7">struct DequeDequeSlice&lt;Element&gt; : DequeType {</a>
<a class="sourceLine" id="cb15-8" data-line-number="8">  <span class="kw">var</span> front, back: DequeSlice&lt;Element&gt;</a>
<a class="sourceLine" id="cb15-9" data-line-number="9">  typealias SubSequence = DequeDequeSlice</a>
<a class="sourceLine" id="cb15-10" data-line-number="10">  <span class="fu">init</span>() { front = <span class="fu">DequeSlice</span>(); back = <span class="fu">DequeSlice</span>() }</a>
<a class="sourceLine" id="cb15-11" data-line-number="11">}</a>
<a class="sourceLine" id="cb15-12" data-line-number="12"></a>
<a class="sourceLine" id="cb15-13" data-line-number="13">let dd: DequeDeque = [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>]</a>
<a class="sourceLine" id="cb15-14" data-line-number="14">dd.<span class="fu">front</span> <span class="co">// [4 | 3, 2, 1]</span></a>
<a class="sourceLine" id="cb15-15" data-line-number="15">dd.<span class="fu">back</span>  <span class="co">// [5 | 6, 7, 8]</span></a></code></pre></div>
<p>Woo protocols!</p>
]]></description>
    <pubDate>Mon, 24 Aug 2015 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2015-08-24-generic-deque.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>A Trie in Swift</title>
    <link>https://doisinkidney.com/posts/2015-08-11-swift-trie.html</link>
    <description><![CDATA[<div class="info">
    Posted on August 11, 2015
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Swift.html">Swift</a>, <a href="/tags/Data%20Structures.html">Data Structures</a>
    
</div>

<p>If you google “cool data structures” you’ll get <a href="http://stackoverflow.com/questions/500607/what-are-the-lesser-known-but-useful-data-structures">this</a> as your first result. It’s a stackoverflow question: “What are the lesser known but useful data structures?”. And the top answer is a Trie. I read up on them, and found out a lot of cool things about their use (as well as finding out that I’m now the kind of person who googles “cool data structures”). So I rocked on up to my playground, and got writing.</p>
<p>A Trie is a prefix tree. It’s another recursive data structure: each Trie contains other children Tries, identifiable by their prefixes.</p>
<p>It’s a bit of a hipster data structure, not very widely used, but it’s got some useful applications. It’s got set-like operations, with insertion and searching each at <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math>, where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> is the length of the sequence being searched for. A Set is the only way to go for hashable, unordered elements. But, if you’ve got <em>sequences</em> of hashable elements, a Trie might be for you. (one thing to note is that Sets are hashable themselves, so if the sequences you want to store are unordered, a Set of Sets is more applicable)</p>
<figure>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/be/Trie_example.svg/1092px-Trie_example.svg.png" alt="A trie for keys" /><figcaption>A trie for keys</figcaption>
</figure>
<p>In Swift, we can do this by having every Trie contain a dictionary of prefixes and Tries. Something like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb1-1" data-line-number="1">public struct Trie&lt;Element : Hashable&gt; {</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  <span class="kw">private</span> <span class="kw">var</span> children: [Element:Trie&lt;Element&gt;]</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">}</a></code></pre></div>
<p>We don’t run into the problem of structs not being allowed to be recursive here, because we don’t directly store a Trie within a Trie - we store a <em>dictionary</em>, and therefore a reference to the child Tries. In this dictionary, the keys correspond to the prefixes. So how do we fill it up? Like lists, we can use the decomposition properties of generators:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb2-1" data-line-number="1">extension Trie {</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  <span class="kw">private</span> init&lt;G : GeneratorType where G.<span class="fu">Element</span> == Element&gt;(<span class="kw">var</span> gen: G) {</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">    <span class="kw">if</span> let head = gen.<span class="fu">next</span>() {</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">      children = [head:<span class="fu">Trie</span>(gen:gen)]</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">    } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">      children = [:]</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">    }</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">  }</a>
<a class="sourceLine" id="cb2-9" data-line-number="9">  public init</a>
<a class="sourceLine" id="cb2-10" data-line-number="10">    &lt;S : SequenceType where S.<span class="fu">Generator</span>.<span class="fu">Element</span> == Element&gt;</a>
<a class="sourceLine" id="cb2-11" data-line-number="11">    (_ seq: S) {</a>
<a class="sourceLine" id="cb2-12" data-line-number="12">      self.<span class="fu">init</span>(gen: seq.<span class="fu">generate</span>())</a>
<a class="sourceLine" id="cb2-13" data-line-number="13">  }</a>
<a class="sourceLine" id="cb2-14" data-line-number="14">}</a></code></pre></div>
<p>That’s not really enough. That can store one sequence, but we need an <code class="sourceCode scala">insert</code> function. Here ya go:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb3-1" data-line-number="1">extension Trie {</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  <span class="kw">private</span> mutating func insert</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">    &lt;G : GeneratorType where G.<span class="fu">Element</span> == Element&gt;</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">    (<span class="kw">var</span> gen: G) {</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">      <span class="kw">if</span> let head = gen.<span class="fu">next</span>() {</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">        children[head]?.<span class="fu">insert</span>(gen) ?? {children[head] = <span class="fu">Trie</span>(gen: gen)}()</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">      }</a>
<a class="sourceLine" id="cb3-8" data-line-number="8">  }</a>
<a class="sourceLine" id="cb3-9" data-line-number="9">  public mutating func insert</a>
<a class="sourceLine" id="cb3-10" data-line-number="10">    &lt;S : SequenceType where S.<span class="fu">Generator</span>.<span class="fu">Element</span> == Element&gt;</a>
<a class="sourceLine" id="cb3-11" data-line-number="11">    (seq: S) {</a>
<a class="sourceLine" id="cb3-12" data-line-number="12">      <span class="fu">insert</span>(seq.<span class="fu">generate</span>())</a>
<a class="sourceLine" id="cb3-13" data-line-number="13">  }</a>
<a class="sourceLine" id="cb3-14" data-line-number="14">}</a></code></pre></div>
<p>There’s a line in there that some may find offensive:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb4-1" data-line-number="1">children[head]?.<span class="fu">insert</span>(gen) ?? {children[head] = <span class="fu">Trie</span>(gen: gen)}()</a></code></pre></div>
<p>And, to be honest, I’m not a huge fan of it myself. It’s making use of the fact that you can call mutating methods on optionals with chaining. When you do it in this example, the optional is returned by the dictionary lookup: we then want to mutate that value, if it’s there, with an insertion.</p>
<p>If it’s <em>not</em> there, though, we want to add it in, so we’ve got to have some way of understanding and dealing with that. We could try and extract the child Trie, like this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">if</span> let head = gen.<span class="fu">next</span>() {</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">  <span class="kw">if</span> <span class="kw">var</span> child = children[head] {</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">    child.<span class="fu">insert</span>(gen)</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">  } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">    children[head] = <span class="fu">Trie</span>(gen: gen)</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">  }</a>
<a class="sourceLine" id="cb5-7" data-line-number="7">}</a></code></pre></div>
<p>But the child there is just a copy of the actual child in the Trie we want to mutate. We could then set it back to the dictionary entry - but at this stage it feels like a lot of extra, inefficient work.</p>
<p>So, you can make use of the fact the functions which don’t return anything actually <em>do</em> return something: a special value called <code class="sourceCode scala">Void</code>, or <code class="sourceCode scala">()</code>. Except that, in this case, it’s <code class="sourceCode scala">()?</code> (or <code class="sourceCode scala">Optional&amp;lt;Void&amp;gt;</code>). We’re not interested in the void itself, obviously, just whether or not it’s <code class="sourceCode scala">nil</code>. So, one way you could use it would be like this:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">if</span> let _ = children[head]?.<span class="fu">insert</span>(gen) { <span class="kw">return</span> }</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">children[head] = <span class="fu">Trie</span>(gen: gen)</a></code></pre></div>
<p>Or, to use <code class="sourceCode scala">guard</code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb7-1" data-line-number="1">guard let _ = children[head]?.<span class="fu">insert</span>(gen) <span class="kw">else</span> { children[head] = <span class="fu">Trie</span>(gen: gen) }</a></code></pre></div>
<p>But I think the nil coalescing operator is a little clearer, without the distraction of <code class="sourceCode scala">let</code> or <code class="sourceCode scala">_</code>.</p>
<p>This data structure, as you can see, has a very different feel to the list. For a start, it’s much more mutable, with in-place mutating methods being a little easier than methods that return a new Trie. Also, laziness is pretty much out of the question: almost every imaginable useful method would involve evaluation of the entire Trie. (if anyone <em>does</em> have a useful way of thinking about Tries lazily, I’d love to hear it)</p>
<p>The contains function, the most important of them all, is here:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb8-1" data-line-number="1">extension Trie {</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  <span class="kw">private</span> func contains</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">    &lt;G : GeneratorType where G.<span class="fu">Element</span> == Element&gt;</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">    (<span class="kw">var</span> gen: G) -&gt; Bool {</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">      <span class="kw">return</span> gen.<span class="fu">next</span>().<span class="fu">map</span>{self.<span class="fu">children</span>[$<span class="dv">0</span>]?.<span class="fu">contains</span>(gen) ?? <span class="kw">false</span>} ?? <span class="kw">true</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">  }</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">  public func contains</a>
<a class="sourceLine" id="cb8-8" data-line-number="8">    &lt;S : SequenceType where S.<span class="fu">Generator</span>.<span class="fu">Element</span> == Element&gt;</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">    (seq: S) -&gt; Bool {</a>
<a class="sourceLine" id="cb8-10" data-line-number="10">      <span class="kw">return</span> <span class="fu">contains</span>(seq.<span class="fu">generate</span>())</a>
<a class="sourceLine" id="cb8-11" data-line-number="11">  }</a>
<a class="sourceLine" id="cb8-12" data-line-number="12">}</a></code></pre></div>
<p>So this uses more generators. If the generator is empty (<code class="sourceCode scala">gen.<span class="fu">next</span>()</code> returns <code class="sourceCode scala">nil</code>), then the Trie contains that sequence, as we have not yet found a dictionary without that element. Within the <code class="sourceCode scala"><span class="fu">map</span>()</code> we search for the next element from the generator. If <em>that</em> returns <code class="sourceCode scala">nil</code>, then the Trie doesn’t contain that sequence. Finally, if none of that works, return whether or not the child Trie contains the rest of the generator. Let’s try it out:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">var</span> jo = <span class="fu">Trie</span>([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>])</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">jo.<span class="fu">insert</span>([<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>])</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">jo.<span class="fu">insert</span>([<span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>])</a>
<a class="sourceLine" id="cb9-4" data-line-number="4"></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">jo.<span class="fu">contains</span>([<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>]) <span class="co">// true</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6">jo.<span class="fu">contains</span>([<span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">3</span>]) <span class="co">// false</span></a></code></pre></div>
<p>There’s a catch. The <code class="sourceCode scala">contains</code> method doesn’t work as we’d like it to:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb10-1" data-line-number="1">jo.<span class="fu">contains</span>([<span class="dv">1</span>, <span class="dv">2</span>]) <span class="co">// true</span></a></code></pre></div>
<p>Because we return <code class="sourceCode scala"><span class="kw">true</span></code> <em>whenever</em> the generator runs out, our Trie “contains” every prefix of the sequences that have been inserted. This is not what we want. One way to solve this may be to return <code class="sourceCode scala"><span class="kw">true</span></code> only if the last Trie found has no children. Something like this:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb11-1" data-line-number="1">extension Trie {</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">  <span class="kw">private</span> func contains</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">    &lt;G : GeneratorType where G.<span class="fu">Element</span> == Element&gt;</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">    (<span class="kw">var</span> gen: G) -&gt; Bool {</a>
<a class="sourceLine" id="cb11-5" data-line-number="5">      <span class="kw">return</span> gen.<span class="fu">next</span>().<span class="fu">map</span>{self.<span class="fu">children</span>[$<span class="dv">0</span>]?.<span class="fu">contains</span>(gen) ?? <span class="kw">false</span>} ?? children.<span class="fu">isEmpty</span></a>
<a class="sourceLine" id="cb11-6" data-line-number="6">  }</a>
<a class="sourceLine" id="cb11-7" data-line-number="7">}</a></code></pre></div>
<p>But this doesn’t really work either. what if we did <code class="sourceCode scala">jo.<span class="fu">insert</span>([<span class="dv">1</span>, <span class="dv">2</span>])</code>? Now, if we check if the Trie contains <code class="sourceCode scala">[<span class="dv">1</span>, <span class="dv">2</span>]</code>, we’ll get back <code class="sourceCode scala"><span class="kw">false</span></code>.</p>
<p>It’s time for flags. We need to add an extra variable to our Trie: a Boolean, which describes whether or not that Trie represents the end of a sequence.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb12-1" data-line-number="1">public struct Trie&lt;Element : Hashable&gt; {</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">  <span class="kw">private</span> <span class="kw">var</span> children: [Element:Trie&lt;Element&gt;]</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">  <span class="kw">private</span> <span class="kw">var</span> endHere : Bool</a>
<a class="sourceLine" id="cb12-4" data-line-number="4">}</a></code></pre></div>
<p>We’ll also need to change our <code class="sourceCode scala">insert</code> and <code class="sourceCode scala">init</code> functions, so that when the generator returns <code class="sourceCode scala">nil</code>, <code class="sourceCode scala">endHere</code> gets initialised to <code class="sourceCode scala"><span class="kw">true</span></code>.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb13-1" data-line-number="1">extension Trie {</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">  <span class="kw">private</span> init&lt;G : GeneratorType where G.<span class="fu">Element</span> == Element&gt;(<span class="kw">var</span> gen: G) {</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">    <span class="kw">if</span> let head = gen.<span class="fu">next</span>() {</a>
<a class="sourceLine" id="cb13-4" data-line-number="4">      (children, endHere) = ([head:<span class="fu">Trie</span>(gen:gen)], <span class="kw">false</span>)</a>
<a class="sourceLine" id="cb13-5" data-line-number="5">    } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb13-6" data-line-number="6">      (children, endHere) = ([:], <span class="kw">true</span>)</a>
<a class="sourceLine" id="cb13-7" data-line-number="7">    }</a>
<a class="sourceLine" id="cb13-8" data-line-number="8">  }</a>
<a class="sourceLine" id="cb13-9" data-line-number="9">}</a>
<a class="sourceLine" id="cb13-10" data-line-number="10"></a>
<a class="sourceLine" id="cb13-11" data-line-number="11">extension Trie {</a>
<a class="sourceLine" id="cb13-12" data-line-number="12">  <span class="kw">private</span> mutating func insert</a>
<a class="sourceLine" id="cb13-13" data-line-number="13">    &lt;G : GeneratorType where G.<span class="fu">Element</span> == Element&gt;</a>
<a class="sourceLine" id="cb13-14" data-line-number="14">    (<span class="kw">var</span> gen: G) {</a>
<a class="sourceLine" id="cb13-15" data-line-number="15">      <span class="kw">if</span> let head = gen.<span class="fu">next</span>() {</a>
<a class="sourceLine" id="cb13-16" data-line-number="16">        children[head]?.<span class="fu">insert</span>(gen) ?? {children[head] = <span class="fu">Trie</span>(gen: gen)}()</a>
<a class="sourceLine" id="cb13-17" data-line-number="17">      } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb13-18" data-line-number="18">        endHere = <span class="kw">true</span></a>
<a class="sourceLine" id="cb13-19" data-line-number="19">      }</a>
<a class="sourceLine" id="cb13-20" data-line-number="20">  }</a>
<a class="sourceLine" id="cb13-21" data-line-number="21">}</a></code></pre></div>
<p>And the contains function now returns <code class="sourceCode scala">endHere</code>, instead of true:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb14-1" data-line-number="1">public extension Trie {</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">  <span class="kw">private</span> func contains</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">    &lt;G : GeneratorType where G.<span class="fu">Element</span> == Element&gt;</a>
<a class="sourceLine" id="cb14-4" data-line-number="4">    (<span class="kw">var</span> gen: G) -&gt; Bool {</a>
<a class="sourceLine" id="cb14-5" data-line-number="5">      <span class="kw">return</span> gen.<span class="fu">next</span>().<span class="fu">map</span>{self.<span class="fu">children</span>[$<span class="dv">0</span>]?.<span class="fu">contains</span>(gen) ?? <span class="kw">false</span>} ?? endHere</a>
<a class="sourceLine" id="cb14-6" data-line-number="6">  }</a>
<a class="sourceLine" id="cb14-7" data-line-number="7">}</a></code></pre></div>
<p>While we’re improving the <code class="sourceCode scala">contains</code> function, we could use <code class="sourceCode scala">guard</code> to make it much more readable:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb15-1" data-line-number="1">public extension Trie {</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">  <span class="kw">private</span> func contains&lt;</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">    G : GeneratorType where G.<span class="fu">Element</span> == Element</a>
<a class="sourceLine" id="cb15-4" data-line-number="4">    &gt;(<span class="kw">var</span> gen: G) -&gt; Bool {</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">      guard let head = gen.<span class="fu">next</span>() <span class="kw">else</span> { <span class="kw">return</span> endHere }</a>
<a class="sourceLine" id="cb15-6" data-line-number="6">      <span class="kw">return</span> children[head]?.<span class="fu">contains</span>(gen) ?? <span class="kw">false</span></a>
<a class="sourceLine" id="cb15-7" data-line-number="7">  }</a>
<a class="sourceLine" id="cb15-8" data-line-number="8">}</a></code></pre></div>
<p><a href="https://twitter.com/chriseidhof/status/629215881843884032">Chris Eidhof gave me this idea.</a> (Apparently there’s a Trie implementation in <a href="http://www.objc.io/books/fpinswift/">Functional Programming in Swift</a>, his book. I’ve not read it, but it’s on my list. If <a href="http://www.objc.io/books/advanced-swift/">Advanced Swift</a>is anything to go by, it should be fantastic.)</p>
<p>The objective of this Trie is to replicate all of the Set methods: Union, Intersect, etc. Most of those are manageable to build from just <code class="sourceCode scala">insert</code>, <code class="sourceCode scala">init</code>, and <code class="sourceCode scala">contains</code>, but there’s one other function that comes in handy: <code class="sourceCode scala">remove</code>.</p>
<p>Remove is deceptively difficult. You could just walk to the end of your given sequence to remove, and switch <code class="sourceCode scala">endHere</code> from <code class="sourceCode scala"><span class="kw">true</span></code> to <code class="sourceCode scala"><span class="kw">false</span></code>, but that’s kind of cheating. I mean, you’ll be storing the same amount of information that way after a removal. No, what you need is something that deletes branches of a tree that aren’t being used any more.</p>
<p>Again, this is a little complicated. You can’t just find the head of the sequence you want to remove, and then delete all children: you may be deleting other entries along with that. You <em>also</em> can’t just delete when a given Trie only contains one child: that child may branch off subsequently, or it may contain prefixes for the sequence you want to remove.</p>
<p>Crucially, all of the information telling you whether or not you can delete a given entry in a given Trie will come from the <em>children</em> of that Trie. What I decided to go with was this: I’ll have some mutating method that does the work recursively. However, this method also <em>returns</em> a value, representing some important information for whatever called it. In this case, the <code class="sourceCode scala">remove</code> method would remove, as you’d imagine, but it will also return a Boolean, signifying whether the Trie it was called on can be removed. Since I used the normal structure of having a private method take a generator, and then a public wrapper method take a sequence, I could have the public method just discard the Boolean.</p>
<p>Let’s go through it. Here’s the signature:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="kw">private</span> mutating func remove&lt;</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">  G : GeneratorType where G.<span class="fu">Element</span> == Element</a>
<a class="sourceLine" id="cb16-3" data-line-number="3">  &gt;(<span class="kw">var</span> g: G) -&gt; Bool {</a></code></pre></div>
<p>No surprises there. Similar to the other methods. Then, get the head from the generator:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw">if</span> let head = g.<span class="fu">next</span>() {</a></code></pre></div>
<p>Within that if block is the meat of the logic, so I might skip to what happens if <code class="sourceCode scala">g.<span class="fu">next</span>()</code> returns <code class="sourceCode scala">nil</code> for the start:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="kw">private</span> mutating func remove&lt;</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">  G : GeneratorType where G.<span class="fu">Element</span> == Element</a>
<a class="sourceLine" id="cb18-3" data-line-number="3">  &gt;(<span class="kw">var</span> g: G) -&gt; Bool {</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">    <span class="kw">if</span> let head = g.<span class="fu">next</span>() {...}</a>
<a class="sourceLine" id="cb18-5" data-line-number="5">    endHere = <span class="kw">false</span></a>
<a class="sourceLine" id="cb18-6" data-line-number="6">    <span class="kw">return</span> children.<span class="fu">isEmpty</span></a>
<a class="sourceLine" id="cb18-7" data-line-number="7">}</a></code></pre></div>
<p>So the sequence being removed has ended. That means that whatever Trie you’re on should have its <code class="sourceCode scala">endHere</code> set to <code class="sourceCode scala"><span class="kw">false</span></code>. To the user of the Trie, that’s all that matters: from now on, if the contains method on that Trie is used with that sequence, it will return false.</p>
<p>However, to find out if you can delete the data itself, it returns <code class="sourceCode scala">children.<span class="fu">isEmpty</span></code>. If it has no children, it does not hold any other sequences or information, so it can be deleted.</p>
<p>Now for inside the if block:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb19-1" data-line-number="1">guard children[head]?.<span class="fu">remove</span>(g) == <span class="kw">true</span> <span class="kw">else</span> { <span class="kw">return</span> <span class="kw">false</span> }</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">children.<span class="fu">removeValueForKey</span>(head)</a>
<a class="sourceLine" id="cb19-3" data-line-number="3"><span class="kw">return</span> !endHere &amp;&amp; children.<span class="fu">isEmpty</span></a></code></pre></div>
<p>So it calls <code class="sourceCode scala">remove</code> on the child Trie corresponding to <code class="sourceCode scala">head</code>. That guard statement will fail for two distinct reasons: if <code class="sourceCode scala">children</code> doesn’t contain <code class="sourceCode scala">head</code>, then the sequence being removed wasn’t in the Trie in the first place. The method will then return false, so that no removal or mutation is done.</p>
<p>If it <em>does</em> contain <code class="sourceCode scala">head</code>, but the Bool returned from the remove method is <code class="sourceCode scala"><span class="kw">false</span></code>, that means that its <em>child</em> is not removable, so it is also not removable, so it should return <code class="sourceCode scala"><span class="kw">false</span></code>.</p>
<p>Otherwise, it will remove that member (<code class="sourceCode scala">children.<span class="fu">removeValueForKey</span>(head)</code>). Then, the Trie can decide whether or not it itself is removable: <code class="sourceCode scala"><span class="kw">return</span> !endHere &amp;amp;&amp;amp; children.<span class="fu">isEmpty</span></code>. If the <code class="sourceCode scala">endHere</code> is set to true, then it is the end of some sequence: it is not removable. Otherwise, it’s removable if it has no children. Here’s the whole thing, with its public version:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb20-1" data-line-number="1">extension Trie {</a>
<a class="sourceLine" id="cb20-2" data-line-number="2">  <span class="kw">private</span> mutating func remove&lt;</a>
<a class="sourceLine" id="cb20-3" data-line-number="3">    G : GeneratorType where G.<span class="fu">Element</span> == Element</a>
<a class="sourceLine" id="cb20-4" data-line-number="4">    &gt;(<span class="kw">var</span> g: G) -&gt; Bool { <span class="co">// Return value signifies whether or not it can be removed</span></a>
<a class="sourceLine" id="cb20-5" data-line-number="5">      <span class="kw">if</span> let head = g.<span class="fu">next</span>() {</a>
<a class="sourceLine" id="cb20-6" data-line-number="6">        guard children[head]?.<span class="fu">remove</span>(g) == <span class="kw">true</span> <span class="kw">else</span> { <span class="kw">return</span> <span class="kw">false</span> }</a>
<a class="sourceLine" id="cb20-7" data-line-number="7">        children.<span class="fu">removeValueForKey</span>(head)</a>
<a class="sourceLine" id="cb20-8" data-line-number="8">        <span class="kw">return</span> !endHere &amp;&amp; children.<span class="fu">isEmpty</span></a>
<a class="sourceLine" id="cb20-9" data-line-number="9">      }</a>
<a class="sourceLine" id="cb20-10" data-line-number="10">      endHere = <span class="kw">false</span></a>
<a class="sourceLine" id="cb20-11" data-line-number="11">      <span class="kw">return</span> children.<span class="fu">isEmpty</span></a>
<a class="sourceLine" id="cb20-12" data-line-number="12">  }</a>
<a class="sourceLine" id="cb20-13" data-line-number="13">  public mutating func remove&lt;</a>
<a class="sourceLine" id="cb20-14" data-line-number="14">    S : SequenceType where S.<span class="fu">Generator</span>.<span class="fu">Element</span> == Element</a>
<a class="sourceLine" id="cb20-15" data-line-number="15">    &gt;(seq: S) {</a>
<a class="sourceLine" id="cb20-16" data-line-number="16">      <span class="fu">remove</span>(seq.<span class="fu">generate</span>())</a>
<a class="sourceLine" id="cb20-17" data-line-number="17">  }</a>
<a class="sourceLine" id="cb20-18" data-line-number="18">}</a></code></pre></div>
<p>That was a little heavy. And kind of ugly. Let’s lighten things up for a second, with one of the loveliest <code class="sourceCode scala">count</code> properties I’ve seen:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb21-1" data-line-number="1">extension Trie {</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">  public <span class="kw">var</span> count: Int {</a>
<a class="sourceLine" id="cb21-3" data-line-number="3">    <span class="kw">return</span> children.<span class="fu">values</span>.<span class="fu">reduce</span>(endHere ? <span class="dv">1</span> : <span class="dv">0</span>) { $<span class="dv">0</span> + $<span class="fl">1.</span>count }</a>
<a class="sourceLine" id="cb21-4" data-line-number="4">  }</a>
<a class="sourceLine" id="cb21-5" data-line-number="5">}</a></code></pre></div>
<p>All it’s really doing is counting the instances of a <code class="sourceCode scala"><span class="kw">true</span></code> <code class="sourceCode scala">endHere</code>. If the current Trie is an end, then it knows that it adds one to the count (<code class="sourceCode scala">endHere ? <span class="dv">1</span> : <span class="dv">0</span></code>), and it adds that to the sum of the counts of its children.</p>
<p>Now then. <code class="sourceCode scala">SequenceType</code>. <a href="http://airspeedvelocity.net/2015/07/22/a-persistent-tree-using-indirect-enums-in-swift/">Getting tree-like structures to conform to <code class="sourceCode scala">SequenceType</code> is a bit of a pain</a>, mainly because of their recursiveness. Getting a linear representation is easy enough:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb22-1" data-line-number="1">extension Trie {</a>
<a class="sourceLine" id="cb22-2" data-line-number="2">  public <span class="kw">var</span> contents: [[Element]] {</a>
<a class="sourceLine" id="cb22-3" data-line-number="3">    <span class="kw">return</span> children.<span class="fu">flatMap</span> {</a>
<a class="sourceLine" id="cb22-4" data-line-number="4">      (head: Element, child: Trie&lt;Element&gt;) -&gt; [[Element]] in</a>
<a class="sourceLine" id="cb22-5" data-line-number="5">      child.<span class="fu">contents</span>.<span class="fu">map</span> { [head] + $<span class="dv">0</span> } + (child.<span class="fu">endHere</span> ? [[head]] : [])</a>
<a class="sourceLine" id="cb22-6" data-line-number="6">    }</a>
<a class="sourceLine" id="cb22-7" data-line-number="7">  }</a>
<a class="sourceLine" id="cb22-8" data-line-number="8">}</a></code></pre></div>
<p>And then you could just return the generate method from that for your Trie’s generate method.</p>
<p>The problem is that it’s not very proper: you’re translating your data structure into another data structure just to iterate through it. What you really want is something that generates each element on demand.</p>
<p>But it gets ugly quick. You’ve got to do a lot of stuff by hand which it isn’t nice to do by hand, and you’ve got to employ some dirty tricks (like using closures as a kind of homemade <code class="sourceCode scala">indirect</code>). At any rate, here it is:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb23-1" data-line-number="1">public struct TrieGenerator&lt;Element : Hashable&gt; : GeneratorType {</a>
<a class="sourceLine" id="cb23-2" data-line-number="2">  <span class="kw">private</span> <span class="kw">var</span> children: DictionaryGenerator&lt;Element, Trie&lt;Element&gt;&gt;</a>
<a class="sourceLine" id="cb23-3" data-line-number="3">  <span class="kw">private</span> <span class="kw">var</span> curHead : Element?</a>
<a class="sourceLine" id="cb23-4" data-line-number="4">  <span class="kw">private</span> <span class="kw">var</span> curEnd  : Bool = <span class="kw">false</span></a>
<a class="sourceLine" id="cb23-5" data-line-number="5">  <span class="kw">private</span> <span class="kw">var</span> innerGen: (() -&gt; [Element]?)?</a>
<a class="sourceLine" id="cb23-6" data-line-number="6">  <span class="kw">private</span> mutating func <span class="fu">update</span>() {</a>
<a class="sourceLine" id="cb23-7" data-line-number="7">    guard <span class="fu">let</span> (head, child) = children.<span class="fu">next</span>() <span class="kw">else</span> { innerGen = nil; <span class="kw">return</span> }</a>
<a class="sourceLine" id="cb23-8" data-line-number="8">    curHead = head</a>
<a class="sourceLine" id="cb23-9" data-line-number="9">    <span class="kw">var</span> g = child.<span class="fu">generate</span>()</a>
<a class="sourceLine" id="cb23-10" data-line-number="10">    innerGen = {g.<span class="fu">next</span>()}</a>
<a class="sourceLine" id="cb23-11" data-line-number="11">    curEnd = child.<span class="fu">endHere</span></a>
<a class="sourceLine" id="cb23-12" data-line-number="12">  }</a>
<a class="sourceLine" id="cb23-13" data-line-number="13">  public mutating func <span class="fu">next</span>() -&gt; [Element]? {</a>
<a class="sourceLine" id="cb23-14" data-line-number="14">    <span class="kw">for</span> ; innerGen != nil; <span class="fu">update</span>() {</a>
<a class="sourceLine" id="cb23-15" data-line-number="15">      <span class="kw">if</span> let next = innerGen!() {</a>
<a class="sourceLine" id="cb23-16" data-line-number="16">        <span class="kw">return</span> [curHead!] + next</a>
<a class="sourceLine" id="cb23-17" data-line-number="17">      } <span class="kw">else</span> <span class="kw">if</span> curEnd {</a>
<a class="sourceLine" id="cb23-18" data-line-number="18">        curEnd = <span class="kw">false</span></a>
<a class="sourceLine" id="cb23-19" data-line-number="19">        <span class="kw">return</span> [curHead!]</a>
<a class="sourceLine" id="cb23-20" data-line-number="20">      }</a>
<a class="sourceLine" id="cb23-21" data-line-number="21">    }</a>
<a class="sourceLine" id="cb23-22" data-line-number="22">    <span class="kw">return</span> nil</a>
<a class="sourceLine" id="cb23-23" data-line-number="23">  }</a>
<a class="sourceLine" id="cb23-24" data-line-number="24">  <span class="kw">private</span> <span class="fu">init</span>(_ from: Trie&lt;Element&gt;) {</a>
<a class="sourceLine" id="cb23-25" data-line-number="25">    children = from.<span class="fu">children</span>.<span class="fu">generate</span>()</a>
<a class="sourceLine" id="cb23-26" data-line-number="26">    <span class="fu">update</span>()</a>
<a class="sourceLine" id="cb23-27" data-line-number="27">  }</a>
<a class="sourceLine" id="cb23-28" data-line-number="28">}</a></code></pre></div>
<p>It’s got a similar logic to the lazy flatMap I did from a while ago.</p>
<p>The code is all available <a href="https://github.com/oisdk/SwiftTrie">here</a>, as a playground, or <a href="https://github.com/oisdk/SwiftSequence">here</a>, in SwiftSequence, where it’s accompanied by some tests.</p>
]]></description>
    <pubDate>Tue, 11 Aug 2015 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2015-08-11-swift-trie.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Monty Hall</title>
    <link>https://doisinkidney.com/posts/2015-08-03-monty-hall.html</link>
    <description><![CDATA[<div class="info">
    Posted on August  3, 2015
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Swift.html">Swift</a>, <a href="/tags/Probability.html">Probability</a>
    
</div>

<p>The Monty Hall problem is a great example of how counter-intuitive probability can sometimes be. It goes something like this: say you’re on a gameshow, with the chance to win a car. You’re shown three doors, and the car is behind one, goats behind the other two. You pick a door, say the leftmost, but then the host of the gameshow stops you before it’s opened. He opens one of the two doors you didn’t pick, revealing a goat. He then asks you if you’d like to change your decision. So? Do you?</p>
<p>Perhaps surprisingly, you <em>should</em> change your decision. Your chances of winning a car go from 1/3 to 2/3.</p>
<p>If you’ve not thought for a while about the problem, the answer above might sound instinctively wrong. A few <a href="http://www.thomashanning.com/swift-playground-the-monty-hall-problem/">blog posts</a> over the past few weeks have made an effort to put some concrete numbers to the statistics, running simulations of each possibility, and counting up the amount of wins and losses.</p>
<p>I was still a little unsatisfied, though. I mean, showing me the actual numbers is fine, but I’d like something a little more <em>proof</em>-y. You can get close with a diagram:</p>
<p><img src="/images/monty-hall-tree.png" /></p>
<p>Which makes it pretty clear what’s going on: since the host <em>has</em> to show a goat when he opens a door, if you’ve picked a goat, then the only door left after the host opens one is the car. That means that if you switch and pick a goat, you <em>have</em> to win. So if you decide to switch, then what you want to do is pick a <em>goat</em> first, and the chances of that are 2/3.</p>
<p>It would be far cooler if you could get some representation of that diagram in code, though.</p>
<p>Turns out we can! In Swift and Haskell (I’m branching out) you can represent probability in a list-like structure, with each element of the list being a tuple of some value and that value’s probability. All the probabilities in the list itself should add up to one. Here’s what it looks like in Swift:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb1-1" data-line-number="1">struct Prob&lt;Element&gt; {</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  <span class="kw">private</span> let contents: [(Element, Double)]</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">}</a></code></pre></div>
<p>and Haskell:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Prob</span> a <span class="fu">=</span> <span class="dt">Prob</span> {<span class="ot"> getProb ::</span> [(a,<span class="dt">Rational</span>)] } <span class="kw">deriving</span> <span class="dt">Show</span>  </a></code></pre></div>
<p>Being a list kind of thing, ideally you’d want to be able to transform the elements, with a map kind of thing:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb3-1" data-line-number="1">extension Prob {</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  func fmap&lt;T&gt;(f: Element -&gt; T) -&gt; Prob&lt;T&gt; {</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">    <span class="kw">return</span> Prob&lt;T&gt;(contents.<span class="fu">map</span> { (v,p) <span class="fu">in</span> (<span class="fu">f</span>(v), p) })</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">  }</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">}</a></code></pre></div>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Prob</span> <span class="kw">where</span>  </a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  fmap f (<span class="dt">Prob</span> xs) <span class="fu">=</span> <span class="dt">Prob</span> [(f x,p)<span class="fu">|</span>(x,p) <span class="ot">&lt;-</span> xs]</a></code></pre></div>
<p>So far, though, the probability information is kind of superfluous. There’s not even a decent way to generate it. How about we get it from a list, where we assume all things in the list have equal chances of happening:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb5-1" data-line-number="1">extension CollectionType where Index.<span class="fu">Distance</span> == Int {</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">  <span class="kw">var</span> equalProbs: Prob&lt;Generator.<span class="fu">Element</span>&gt; {</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">    let p = <span class="fl">1.0</span> / Double(count)</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">    <span class="kw">return</span> Prob&lt;Generator.<span class="fu">Element</span>&gt;(map { v <span class="fu">in</span> (v,p) })</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">  }</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">}</a></code></pre></div>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">equalProbs ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Prob</span> a</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">equalProbs x <span class="fu">=</span> <span class="dt">Prob</span> <span class="fu">$</span> map (flip (,) (<span class="dv">1</span><span class="fu">%</span>n))  x</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  <span class="kw">where</span> n <span class="fu">=</span> fromIntegral (length x)</a></code></pre></div>
<p>Which is <em>fine</em>, I suppose, but still not very interesting. What we want is the idea of “branching” - like in the diagram. “If event A happens, then event B has X chance of happening, and event C has Y chance of happening”.</p>
<p>The normal rules of probability apply: the <em>overall</em> probability of B happening is equal to the probability of A multiplied by X. You could have several layers of branching from B and C onwards, with this multiplication happening at each stage.</p>
<p>You could represent this in code with a function <code>f</code>, which takes an event (A) and returns a new bunch of probabilities (B and C). Then, to get the overall probability of each, you’d have to <em>flatten</em> it. What you want, then, is a function that travels over a list of events and their probabilities, applying <code>f</code> to each, and flattening the result, by <em>multiplying</em> the probabilities of the inner lists by the probability of the event which generated it.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb7-1" data-line-number="1">extension Prob {</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  func flatMap&lt;T&gt;(f: Element -&gt; Prob&lt;T&gt;) -&gt; Prob&lt;T&gt; {</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">    <span class="kw">return</span> Prob&lt;T&gt;(contents.<span class="fu">flatMap</span> { (v,p) in</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">      <span class="fu">f</span>(v).<span class="fu">contents</span>.<span class="fu">map</span> { (x,ip) <span class="fu">in</span> (x,p*ip) }</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">    })</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">  }</a>
<a class="sourceLine" id="cb7-7" data-line-number="7">}</a></code></pre></div>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Prob</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  return <span class="fu">=</span> pure</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  <span class="dt">Prob</span> xs <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> </a>
<a class="sourceLine" id="cb8-4" data-line-number="4">    <span class="dt">Prob</span> [(y,px<span class="fu">*</span>py)<span class="fu">|</span>(x,px) <span class="ot">&lt;-</span> xs, (y,py) <span class="ot">&lt;-</span> getProb(f x)]</a></code></pre></div>
<p>Hey look! The M-word. Never mind that. Anyway…</p>
<p>Now we have enough tools to stimulate some basic probabilities. Let’s say you’re playing a game, which begins with a coin flip. If you get heads on the coin flip, it confers some advantage, and you have a 70% chance of winning. Otherwise, you’ve a 50% chance.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb9-1" data-line-number="1">enum Coin: String   { <span class="kw">case</span> H, T }</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">enum Result: String { <span class="kw">case</span> Win, Lose }</a>
<a class="sourceLine" id="cb9-3" data-line-number="3"></a>
<a class="sourceLine" id="cb9-4" data-line-number="4">func <span class="fu">play</span>(c: Coin) -&gt; Prob&lt;Result&gt; {</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  switch c {</a>
<a class="sourceLine" id="cb9-6" data-line-number="6">  <span class="kw">case</span> .<span class="fu">H</span>: <span class="kw">return</span> <span class="fu">Prob</span>([(.<span class="fu">Win</span>,<span class="fl">0.7</span>),(.<span class="fu">Lose</span>,<span class="fl">0.3</span>)])</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">  <span class="kw">case</span> .<span class="fu">T</span>: <span class="kw">return</span> [.<span class="fu">Win</span>,.<span class="fu">Lose</span>].<span class="fu">equalProbs</span></a>
<a class="sourceLine" id="cb9-8" data-line-number="8">  }</a>
<a class="sourceLine" id="cb9-9" data-line-number="9">}</a>
<a class="sourceLine" id="cb9-10" data-line-number="10"></a>
<a class="sourceLine" id="cb9-11" data-line-number="11">[Coin.<span class="fu">H</span>,.<span class="fu">T</span>]</a>
<a class="sourceLine" id="cb9-12" data-line-number="12">  .<span class="fu">equalProbs</span></a>
<a class="sourceLine" id="cb9-13" data-line-number="13">  .<span class="fu">flatMap</span>(play)</a>
<a class="sourceLine" id="cb9-14" data-line-number="14"></a>
<a class="sourceLine" id="cb9-15" data-line-number="15"><span class="co">// 0.35: Result.Win</span></a>
<a class="sourceLine" id="cb9-16" data-line-number="16"><span class="co">// 0.15: Result.Lose</span></a>
<a class="sourceLine" id="cb9-17" data-line-number="17"><span class="co">// 0.25: Result.Win</span></a>
<a class="sourceLine" id="cb9-18" data-line-number="18"><span class="co">// 0.25: Result.Lose</span></a></code></pre></div>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Coin</span>   <span class="fu">=</span> <span class="dt">H</span> <span class="fu">|</span> <span class="dt">T</span> <span class="kw">deriving</span> <span class="dt">Show</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Result</span> <span class="fu">=</span> <span class="dt">Win</span> <span class="fu">|</span> <span class="dt">Lose</span> <span class="kw">deriving</span> <span class="dt">Show</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3"></a>
<a class="sourceLine" id="cb10-4" data-line-number="4"><span class="kw">let</span> play <span class="dt">H</span> <span class="fu">=</span> <span class="dt">Prob</span> [(<span class="dt">Win</span>,<span class="dv">7</span><span class="fu">%</span><span class="dv">10</span>),(<span class="dt">Lose</span>,<span class="dv">3</span><span class="fu">%</span><span class="dv">10</span>)]</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">    play <span class="dt">T</span> <span class="fu">=</span> equalProbs [<span class="dt">Win</span>,<span class="dt">Lose</span>]</a>
<a class="sourceLine" id="cb10-6" data-line-number="6"></a>
<a class="sourceLine" id="cb10-7" data-line-number="7">equalProbs [<span class="dt">H</span>,<span class="dt">T</span>] <span class="fu">&gt;&gt;=</span> play</a></code></pre></div>
<p>There’s an obvious problem: duplicates. We need some way to <em>combine</em> the results by adding their probabilities together. To be honest, this was the least interesting part, so I’ll just dump the code here:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb11-1" data-line-number="1">public enum Ordering { <span class="kw">case</span> LT, EQ, GT }</a>
<a class="sourceLine" id="cb11-2" data-line-number="2"></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">extension SequenceType {</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">  <span class="kw">private</span> typealias A = Generator.<span class="fu">Element</span></a>
<a class="sourceLine" id="cb11-5" data-line-number="5">  public func <span class="fu">mergeBy</span>( comp: (A, A) -&gt; Ordering</a>
<a class="sourceLine" id="cb11-6" data-line-number="6">                     , _ merge: (A, A) -&gt; A) -&gt; [A] {</a>
<a class="sourceLine" id="cb11-7" data-line-number="7">    <span class="kw">var</span> result: [A] = []</a>
<a class="sourceLine" id="cb11-8" data-line-number="8">    <span class="kw">for</span> h in <span class="fu">sort</span>({ e in <span class="fu">comp</span>(e) == .<span class="fu">LT</span> }) {</a>
<a class="sourceLine" id="cb11-9" data-line-number="9">      <span class="kw">if</span> <span class="kw">case</span> .<span class="fu">EQ</span>? = result.<span class="fu">last</span>.<span class="fu">map</span>({e in <span class="fu">comp</span>(h,e)}) {</a>
<a class="sourceLine" id="cb11-10" data-line-number="10">        result.<span class="fu">append</span>(<span class="fu">merge</span>(result.<span class="fu">removeLast</span>(),h))</a>
<a class="sourceLine" id="cb11-11" data-line-number="11">      } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb11-12" data-line-number="12">        result.<span class="fu">append</span>(h)</a>
<a class="sourceLine" id="cb11-13" data-line-number="13">      }</a>
<a class="sourceLine" id="cb11-14" data-line-number="14">    }</a>
<a class="sourceLine" id="cb11-15" data-line-number="15">    <span class="kw">return</span> result</a>
<a class="sourceLine" id="cb11-16" data-line-number="16">  }</a>
<a class="sourceLine" id="cb11-17" data-line-number="17">}</a>
<a class="sourceLine" id="cb11-18" data-line-number="18"></a>
<a class="sourceLine" id="cb11-19" data-line-number="19">extension Prob {</a>
<a class="sourceLine" id="cb11-20" data-line-number="20">  public func mergeProbs</a>
<a class="sourceLine" id="cb11-21" data-line-number="21">    (comp: (Element,Element) -&gt; Ordering) -&gt; Prob {</a>
<a class="sourceLine" id="cb11-22" data-line-number="22">      <span class="kw">return</span> <span class="fu">Prob</span>(contents:</a>
<a class="sourceLine" id="cb11-23" data-line-number="23">        contents.<span class="fu">mergeBy</span>( {(a,b) in <span class="fu">comp</span>(a<span class="fl">.0</span>,b<span class="fl">.0</span>)}</a>
<a class="sourceLine" id="cb11-24" data-line-number="24">                        , {(a,b) <span class="fu">in</span> (a<span class="fl">.0</span>,a<span class="fl">.1</span>+b<span class="fl">.1</span>)})</a>
<a class="sourceLine" id="cb11-25" data-line-number="25">    )</a>
<a class="sourceLine" id="cb11-26" data-line-number="26">  }</a>
<a class="sourceLine" id="cb11-27" data-line-number="27">}</a></code></pre></div>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="ot">eqing ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Ordering</span>) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">eqing c <span class="fu">=</span> (\a b <span class="ot">-&gt;</span> <span class="kw">case</span> c a b <span class="kw">of</span> <span class="dt">EQ</span> <span class="ot">-&gt;</span> <span class="dt">True</span> </a>
<a class="sourceLine" id="cb12-3" data-line-number="3">                                 _  <span class="ot">-&gt;</span> <span class="dt">False</span>)</a>
<a class="sourceLine" id="cb12-4" data-line-number="4"></a>
<a class="sourceLine" id="cb12-5" data-line-number="5"><span class="ot">mergeBy ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Ordering</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb12-6" data-line-number="6">mergeBy m c <span class="fu">=</span> (foldl1&#39; m <span class="fu">&lt;$&gt;</span>) <span class="fu">.</span> groupBy (eqing c) <span class="fu">.</span> sortBy c</a>
<a class="sourceLine" id="cb12-7" data-line-number="7"></a>
<a class="sourceLine" id="cb12-8" data-line-number="8"><span class="ot">mergeProbs ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Prob</span> a <span class="ot">-&gt;</span> <span class="dt">Prob</span> a</a>
<a class="sourceLine" id="cb12-9" data-line-number="9">mergeProbs <span class="fu">=</span></a>
<a class="sourceLine" id="cb12-10" data-line-number="10">  <span class="dt">Prob</span> <span class="fu">.</span> mergeBy (fmap <span class="fu">.</span> (<span class="fu">+</span>) <span class="fu">.</span> snd) (comparing fst) <span class="fu">.</span> getProb</a></code></pre></div>
<p>Now we get some nicer probabilities, though:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb13-1" data-line-number="1">func <span class="fu">comp</span>(a: Result, b:Result) -&gt; Ordering {</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">  <span class="fu">switch</span> (a,b) {</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">  <span class="kw">case</span> (.<span class="fu">Win</span>,.<span class="fu">Win</span>),(.<span class="fu">Lose</span>,.<span class="fu">Lose</span>): <span class="kw">return</span> .<span class="fu">EQ</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4">  <span class="kw">case</span> (.<span class="fu">Lose</span>,.<span class="fu">Win</span>): <span class="kw">return</span> .<span class="fu">LT</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5">  <span class="kw">case</span> (.<span class="fu">Win</span>,.<span class="fu">Lose</span>): <span class="kw">return</span> .<span class="fu">GT</span></a>
<a class="sourceLine" id="cb13-6" data-line-number="6">  }</a>
<a class="sourceLine" id="cb13-7" data-line-number="7">}</a>
<a class="sourceLine" id="cb13-8" data-line-number="8"></a>
<a class="sourceLine" id="cb13-9" data-line-number="9">[Coin.<span class="fu">H</span>,.<span class="fu">T</span>]</a>
<a class="sourceLine" id="cb13-10" data-line-number="10">  .<span class="fu">equalProbs</span></a>
<a class="sourceLine" id="cb13-11" data-line-number="11">  .<span class="fu">flatMap</span>(play)</a>
<a class="sourceLine" id="cb13-12" data-line-number="12">  .<span class="fu">mergeProbs</span>(comp)</a>
<a class="sourceLine" id="cb13-13" data-line-number="13"></a>
<a class="sourceLine" id="cb13-14" data-line-number="14"><span class="co">// 0.4: Result.Lose</span></a>
<a class="sourceLine" id="cb13-15" data-line-number="15"><span class="co">// 0.6: Result.Win</span></a></code></pre></div>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Ord</span> <span class="dt">Result</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2">  compare <span class="dt">Win</span> <span class="dt">Lose</span> <span class="fu">=</span> <span class="dt">GT</span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3">  compare <span class="dt">Lose</span> <span class="dt">Win</span> <span class="fu">=</span> <span class="dt">LT</span></a>
<a class="sourceLine" id="cb14-4" data-line-number="4">  compare _    _   <span class="fu">=</span> <span class="dt">EQ</span></a>
<a class="sourceLine" id="cb14-5" data-line-number="5">  </a>
<a class="sourceLine" id="cb14-6" data-line-number="6">mergeProbs ( equalProbs [<span class="dt">H</span>,<span class="dt">T</span>] <span class="fu">&gt;&gt;=</span> play )</a></code></pre></div>
<p>And you can see what effect a loaded coin would have on your chances:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="fu">Prob</span>([(Coin.<span class="fu">H</span>,<span class="fl">0.7</span>),(.<span class="fu">T</span>,<span class="fl">0.3</span>)])</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">  .<span class="fu">flatMap</span>(play)</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">  .<span class="fu">mergeProbs</span>(comp)</a>
<a class="sourceLine" id="cb15-4" data-line-number="4"></a>
<a class="sourceLine" id="cb15-5" data-line-number="5"><span class="co">// 0.36: Result.Lose</span></a>
<a class="sourceLine" id="cb15-6" data-line-number="6"><span class="co">// 0.64: Result.Win</span></a></code></pre></div>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1">mergeProbs ( <span class="dt">Prob</span> [(<span class="dt">H</span>,<span class="dv">7</span><span class="fu">%</span><span class="dv">10</span>),(<span class="dt">T</span>,<span class="dv">3</span><span class="fu">%</span><span class="dv">10</span>)] <span class="fu">&gt;&gt;=</span> play )</a></code></pre></div>
<p>So how does this apply to Monty Hall? Well, we’ve actually done most of the work already. We’ll represent the doors as an Int, and the choice by an enum.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb17-1" data-line-number="1">public enum Choice { <span class="kw">case</span> Switch, Stick }</a></code></pre></div>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Choice</span> <span class="fu">=</span> <span class="dt">Switch</span> <span class="fu">|</span> <span class="dt">Stick</span></a></code></pre></div>
<p>Then, a <code class="sourceCode scala">chances</code> function. The logic here is a bit dense. First of all, if you’re going to stick, it doesn’t matter how many doors the host opens: your chance of getting a car is <code>1/n</code>, where <code>n</code> is the number of doors. However, if you’re going to switch, two things need to happen: you need to <em>not</em> pick the car on your first choice, <em>and</em> you need to pick the car on your second choice. The chance of picking the car on your second choice (if the one you picked on your first choice <em>wasn’t</em> the car) is the one over the number of doors, minus the number of doors the host opens, minus one.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb19-1" data-line-number="1">public func <span class="fu">chances</span>(n: Int, _ p: Int, _ c: Choice)(_ d: Int)</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">  -&gt; Prob&lt;Bool&gt; {</a>
<a class="sourceLine" id="cb19-3" data-line-number="3">    switch c {</a>
<a class="sourceLine" id="cb19-4" data-line-number="4">    <span class="kw">case</span> .<span class="fu">Stick</span> : <span class="kw">return</span> (<span class="dv">1</span>...<span class="fu">n</span>).<span class="fu">equalProbs</span>.<span class="fu">fmap</span>(==d)</a>
<a class="sourceLine" id="cb19-5" data-line-number="5">    <span class="kw">case</span> .<span class="fu">Switch</span>:</a>
<a class="sourceLine" id="cb19-6" data-line-number="6">      let notFirst = <span class="fu">chances</span>(n,p,.<span class="fu">Stick</span>)(d).<span class="fu">fmap</span>(!)</a>
<a class="sourceLine" id="cb19-7" data-line-number="7">      let second =</a>
<a class="sourceLine" id="cb19-8" data-line-number="8">        <span class="fu">Repeat</span>(count: (n-p)-<span class="dv">2</span>, repeatedValue: <span class="kw">false</span>) + [<span class="kw">true</span>]</a>
<a class="sourceLine" id="cb19-9" data-line-number="9">      <span class="kw">return</span> notFirst.<span class="fu">flatMap</span> { f in </a>
<a class="sourceLine" id="cb19-10" data-line-number="10">        second.<span class="fu">equalProbs</span>.<span class="fu">fmap</span> { s in f &amp;&amp; s } </a>
<a class="sourceLine" id="cb19-11" data-line-number="11">      }</a>
<a class="sourceLine" id="cb19-12" data-line-number="12">  }</a>
<a class="sourceLine" id="cb19-13" data-line-number="13">}</a></code></pre></div>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="ot">chances ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Choice</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Prob</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2">chances n _ <span class="dt">Stick</span>  d <span class="fu">=</span> fmap (<span class="fu">==</span>d) (equalProbs [<span class="dv">1</span><span class="fu">..</span>n])</a>
<a class="sourceLine" id="cb20-3" data-line-number="3">chances n p <span class="dt">Switch</span> d <span class="fu">=</span> </a>
<a class="sourceLine" id="cb20-4" data-line-number="4">  (<span class="fu">&amp;&amp;</span>) <span class="fu">.</span> not          <span class="fu">&lt;$&gt;</span></a>
<a class="sourceLine" id="cb20-5" data-line-number="5">  chances n p <span class="dt">Stick</span> d <span class="fu">&lt;*&gt;</span></a>
<a class="sourceLine" id="cb20-6" data-line-number="6">  (equalProbs <span class="fu">$</span> <span class="dt">True</span> <span class="fu">:</span> replicate (n<span class="fu">-</span>p<span class="fu">-</span><span class="dv">2</span>) <span class="dt">False</span>)</a></code></pre></div>
<p>Finally, the <code>chanceOfCar</code> function:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb21-1" data-line-number="1">public func chanceOfCar</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">  (n: Int, _ p: Int, _ s: Choice)</a>
<a class="sourceLine" id="cb21-3" data-line-number="3">  -&gt; Prob&lt;Bool&gt; {</a>
<a class="sourceLine" id="cb21-4" data-line-number="4">    <span class="kw">return</span> (<span class="dv">1</span>...<span class="fu">n</span>)</a>
<a class="sourceLine" id="cb21-5" data-line-number="5">      .<span class="fu">equalProbs</span></a>
<a class="sourceLine" id="cb21-6" data-line-number="6">      .<span class="fu">flatMap</span>(<span class="fu">chances</span>(n,p,s))</a>
<a class="sourceLine" id="cb21-7" data-line-number="7">      .<span class="fu">mergeProbs</span>(comp)</a>
<a class="sourceLine" id="cb21-8" data-line-number="8">}</a></code></pre></div>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="ot">chanceOfCar ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Choice</span> <span class="ot">-&gt;</span> <span class="dt">Prob</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb22-2" data-line-number="2">chanceOfCar n p s <span class="fu">=</span> mergeProbs <span class="fu">$</span></a>
<a class="sourceLine" id="cb22-3" data-line-number="3">                    equalProbs [<span class="dv">1</span><span class="fu">..</span>n] <span class="fu">&gt;&gt;=</span> </a>
<a class="sourceLine" id="cb22-4" data-line-number="4">                    chances n p s</a></code></pre></div>
<p>Which returns, as you’d expect, 1/3 chance of car if you stick, and 2/3 if you switch.</p>
<p>One of the final cool things you can do with this is change the number of doors, and the number of doors the host opens, and see what happens:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="fu">chanceOfCar</span>(<span class="dv">6</span>, <span class="dv">2</span>, .<span class="fu">Switch</span>) </a>
<a class="sourceLine" id="cb23-2" data-line-number="2"><span class="co">// 0.833333333333334: false, 0.166666666666667: true</span></a></code></pre></div>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1">chanceOfCar <span class="dv">8</span> <span class="dv">3</span> <span class="dt">Switch</span> <span class="fu">//</span> <span class="dv">7</span> <span class="fu">%</span> <span class="dv">32</span></a></code></pre></div>
<p>The advantage gets less and less, but never goes away.</p>
<p>If you check out the <a href="https://en.wikipedia.org/wiki/Monty_Hall_problem#N_doors">Wikipedia</a> entry on the problem, the formula for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>N</mi><annotation encoding="application/x-tex">N</annotation></semantics></math>-doors is given: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>N</mi><mo stretchy="false" form="prefix">(</mo><mi>N</mi><mo>−</mo><mi>p</mi><mo>−</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow></mfrac><annotation encoding="application/x-tex">\frac{N−1}{N(N−p−1)}</annotation></semantics></math>.</p>
<p>We can plug that straight in to our versions, to see if they’re correct:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="kw">let</span> sample <span class="fu">=</span> [(n,p)<span class="fu">|</span> n <span class="ot">&lt;-</span> [<span class="dv">3</span><span class="fu">..</span><span class="dv">20</span>], p <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span>(n<span class="fu">-</span><span class="dv">2</span>)]] </a>
<a class="sourceLine" id="cb25-2" data-line-number="2"><span class="kw">let</span> expect <span class="fu">=</span> fmap frmla sample</a>
<a class="sourceLine" id="cb25-3" data-line-number="3">             <span class="kw">where</span><span class="ot"> frmla ::</span> (<span class="dt">Integer</span>,<span class="dt">Integer</span>) <span class="ot">-&gt;</span> <span class="dt">Rational</span></a>
<a class="sourceLine" id="cb25-4" data-line-number="4">                   frmla (n,p) <span class="fu">=</span> (n <span class="fu">-</span> <span class="dv">1</span>)<span class="fu">%</span>(n<span class="fu">*</span>(n<span class="fu">-</span>p<span class="fu">-</span><span class="dv">1</span>))</a>
<a class="sourceLine" id="cb25-5" data-line-number="5"></a>
<a class="sourceLine" id="cb25-6" data-line-number="6"><span class="kw">let</span> actual <span class="fu">=</span> fmap t sample <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-7" data-line-number="7">  t (n,p) <span class="fu">=</span> truePrb <span class="fu">$</span> getProb <span class="fu">$</span> chanceOfCar n p <span class="dt">Switch</span></a>
<a class="sourceLine" id="cb25-8" data-line-number="8">  truePrb <span class="fu">=</span> fromJust <span class="fu">.</span> (fmap snd) <span class="fu">.</span> (find fst)</a>
<a class="sourceLine" id="cb25-9" data-line-number="9"></a>
<a class="sourceLine" id="cb25-10" data-line-number="10">expect <span class="fu">==</span> actual</a></code></pre></div>
<p>And it works! (I didn’t try the Swift version, because of floating-point inaccuracies)</p>
<p>You can see the code used <a href="https://github.com/oisdk/Monty-Hall">here</a>.</p>
]]></description>
    <pubDate>Mon, 03 Aug 2015 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2015-08-03-monty-hall.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>Deques, Queues, and Lists in Swift with Indirect</title>
    <link>https://doisinkidney.com/posts/2015-07-29-swift-queues.html</link>
    <description><![CDATA[<div class="info">
    Posted on July 29, 2015
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Swift.html">Swift</a>, <a href="/tags/Data%20Structures.html">Data Structures</a>
    
</div>

<p>Recursive enums have finally arrived. Woo! The first thing to do with these is to make a recursive list:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb1-1" data-line-number="1">public enum List&lt;Element&gt; {</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  <span class="kw">case</span> Nil</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  indirect <span class="kw">case</span> <span class="fu">Cons</span>(head: Element, tail: List&lt;Element&gt;)</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">}</a></code></pre></div>
<p>The <code class="sourceCode scala">head</code> stores the element, and <code class="sourceCode scala">tail</code> is a reference to the rest of the list. As you can imagine, getting at the <code class="sourceCode scala">head</code> is pretty easy, while accessing elements further along is more difficult. There’s a common pattern for dealing with these recursive structures: if you have a function that performs some transformation on a list, it will take the <code class="sourceCode scala">head</code>, perform that transformation on it, and then call itself recursively on the <code class="sourceCode scala">tail</code>. If it’s given an empty list, it returns an empty list. For instance, here’s the <code class="sourceCode haskell">map</code> function, defined in Haskell:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1">map _ []     <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">map f (x<span class="fu">:</span>xs) <span class="fu">=</span> f x <span class="fu">:</span> map f xs</a></code></pre></div>
<p>The two lines are analogous to a switch statement in Swift. The parameters for <code class="sourceCode haskell">map</code> are a transformation function and a list. So, the first line has <code class="sourceCode haskell">_</code> (wildcard) for the function, and <code class="sourceCode haskell">[]</code> (empty) for the list, meaning it will match any function and an empty list. It returns an empty list.</p>
<p>The second line matches a function (which it assigns the name <code class="sourceCode scala">f</code>) and then decomposes the list it’s given into a head (<code class="sourceCode scala">x</code>) and tail (<code class="sourceCode scala">xs</code>). It then calls <code class="sourceCode scala">f</code> on the head, and prepends (the <code class="sourceCode scala">:</code> operator is prepends, also called “cons” by convention) the result to itself called recursively on the tail.</p>
<p>With switch statements and the <code class="sourceCode scala">indirect</code> keyword, we’re getting pretty close to that level of brevity (terseness?) in Swift:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb3-1" data-line-number="1">extension List {</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  public func map&lt;T&gt;(@noescape transform: Element -&gt; T) -&gt; List&lt;T&gt; {</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">    switch self {</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">    <span class="kw">case</span> .<span class="fu">Nil</span>: <span class="kw">return</span> .<span class="fu">Nil</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">    <span class="kw">case</span> let .<span class="fu">Cons</span>(head, tail): <span class="kw">return</span></a>
<a class="sourceLine" id="cb3-6" data-line-number="6">      .<span class="fu">Cons</span>(head: <span class="fu">transform</span>(head), tail: tail.<span class="fu">map</span>(transform))</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">    }</a>
<a class="sourceLine" id="cb3-8" data-line-number="8">  }</a>
<a class="sourceLine" id="cb3-9" data-line-number="9">}</a></code></pre></div>
<p>We can define our own “cons”, to clean it up a little. We’re not allowed to use <code class="sourceCode scala">:</code>, so I went with <code class="sourceCode scala">|&gt;</code>, which is, in my mind, reasonably representative of “cons”.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb4-1" data-line-number="1">infix operator |&gt; {</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  associativity right</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  precedence <span class="dv">100</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">}</a>
<a class="sourceLine" id="cb4-5" data-line-number="5"></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">public func |&gt; &lt;T&gt;(lhs: T, rhs: List&lt;T&gt;) -&gt; List&lt;T&gt; {</a>
<a class="sourceLine" id="cb4-7" data-line-number="7">  <span class="kw">return</span> .<span class="fu">Cons</span>(head: lhs, tail: rhs)</a>
<a class="sourceLine" id="cb4-8" data-line-number="8">}</a>
<a class="sourceLine" id="cb4-9" data-line-number="9"></a>
<a class="sourceLine" id="cb4-10" data-line-number="10">extension List {</a>
<a class="sourceLine" id="cb4-11" data-line-number="11">  public func map&lt;T&gt;(@noescape transform: Element -&gt; T) -&gt; List&lt;T&gt; {</a>
<a class="sourceLine" id="cb4-12" data-line-number="12">    switch self {</a>
<a class="sourceLine" id="cb4-13" data-line-number="13">    <span class="kw">case</span> .<span class="fu">Nil</span>: <span class="kw">return</span> .<span class="fu">Nil</span></a>
<a class="sourceLine" id="cb4-14" data-line-number="14">    <span class="kw">case</span> let .<span class="fu">Cons</span>(head, tail):</a>
<a class="sourceLine" id="cb4-15" data-line-number="15">      <span class="kw">return</span> <span class="fu">transform</span>(head) |&gt; tail.<span class="fu">map</span>(transform)</a>
<a class="sourceLine" id="cb4-16" data-line-number="16">    }</a>
<a class="sourceLine" id="cb4-17" data-line-number="17">  }</a>
<a class="sourceLine" id="cb4-18" data-line-number="18">}</a></code></pre></div>
<p>Pretty soon you can start doing some elegant and exciting things with lists. The recursive pattern is <em>very</em> well suited to higher-order functions and other FP staples. Take, for instance, the <code class="sourceCode scala">reduce</code> function:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb5-1" data-line-number="1">extension List {</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">  public func reduce&lt;T&gt;(initial: T, @noescape combine: (T, Element) -&gt; T) -&gt; T {</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">    switch self {</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">    <span class="kw">case</span> .<span class="fu">Nil</span>: <span class="kw">return</span> initial</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">    <span class="kw">case</span> let .<span class="fu">Cons</span>(h, t):</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">      <span class="kw">return</span> t.<span class="fu">reduce</span>(<span class="fu">combine</span>(initial, h), combine: combine)</a>
<a class="sourceLine" id="cb5-7" data-line-number="7">    }</a>
<a class="sourceLine" id="cb5-8" data-line-number="8">  }</a>
<a class="sourceLine" id="cb5-9" data-line-number="9">}</a></code></pre></div>
<p>Or a transposing function:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb6-1" data-line-number="1">func transpose&lt;T&gt;(mat: List&lt;List&lt;T&gt;&gt;) -&gt; List&lt;List&lt;T&gt;&gt; {</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  switch mat {</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  <span class="kw">case</span> let .<span class="fu">Cons</span>(x, xs) where x.<span class="fu">isEmpty</span>: <span class="kw">return</span> <span class="fu">transpose</span>(xs)</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">  <span class="kw">case</span> let .<span class="fu">Cons</span>(.<span class="fu">Cons</span>(x, xs), xss):</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">    <span class="kw">return</span> (x |&gt; xss.<span class="fu">flatMap</span>{$<span class="fl">0.f</span>irst}) |&gt;</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">      <span class="fu">transpose</span>(xs |&gt; xss.<span class="fu">map</span>{$<span class="fl">0.</span>tail})</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">  default: <span class="kw">return</span> .<span class="fu">Nil</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">  }</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">}</a>
<a class="sourceLine" id="cb6-10" data-line-number="10"></a>
<a class="sourceLine" id="cb6-11" data-line-number="11">let jo: List&lt;List&lt;Int&gt;&gt; = [[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>], [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>], [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]]</a>
<a class="sourceLine" id="cb6-12" data-line-number="12"><span class="fu">transpose</span>(jo) <span class="co">// [[1, 1, 1], [2, 2, 2], [3, 3, 3]]</span></a></code></pre></div>
<p>You can do <code class="sourceCode scala">foldr</code>, which is like <code class="sourceCode scala">reduce</code>, but works in reverse:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb7-1" data-line-number="1">extension List {</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  func foldr&lt;T&gt;(initial: T, @noescape combine: (element: Element, accumulator: T) -&gt; T) -&gt; T {</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">    switch self {</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">    <span class="kw">case</span> .<span class="fu">Nil</span>: <span class="kw">return</span> initial</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">    <span class="kw">case</span> let .<span class="fu">Cons</span>(x, xs):</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">      <span class="kw">return</span> <span class="fu">combine</span>(</a>
<a class="sourceLine" id="cb7-7" data-line-number="7">        element: x,</a>
<a class="sourceLine" id="cb7-8" data-line-number="8">        accumulator: xs.<span class="fu">foldr</span>(initial, combine: combine)</a>
<a class="sourceLine" id="cb7-9" data-line-number="9">      )</a>
<a class="sourceLine" id="cb7-10" data-line-number="10">    }</a>
<a class="sourceLine" id="cb7-11" data-line-number="11">  }</a>
<a class="sourceLine" id="cb7-12" data-line-number="12">}</a></code></pre></div>
<p>Using <code class="sourceCode scala">foldr</code>, you can get all of the non-empty subsequences of a list:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb8-1" data-line-number="1">extension List {</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  <span class="kw">var</span> subsequences: List&lt;List&lt;Element&gt;&gt; {</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">    switch self {</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">    <span class="kw">case</span> .<span class="fu">Nil</span>: <span class="kw">return</span> .<span class="fu">Nil</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5">    <span class="kw">case</span> let .<span class="fu">Cons</span>(x, xs):</a>
<a class="sourceLine" id="cb8-6" data-line-number="6">      <span class="kw">return</span> [x] |&gt; xs.<span class="fu">subsequences</span>.<span class="fu">foldr</span>([]) {</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">        (ys, r) in ys |&gt; (x |&gt; ys) |&gt; r</a>
<a class="sourceLine" id="cb8-8" data-line-number="8">      }</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">    }</a>
<a class="sourceLine" id="cb8-10" data-line-number="10">  }</a>
<a class="sourceLine" id="cb8-11" data-line-number="11">}</a>
<a class="sourceLine" id="cb8-12" data-line-number="12">let jo: List = [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]</a>
<a class="sourceLine" id="cb8-13" data-line-number="13">jo.<span class="fu">subsequences</span> <span class="co">// [[1], [2], [1, 2], [1, 3], [2, 3], [1, 2, 3]]</span></a></code></pre></div>
<p>(these examples are all translated from the Haskell standard library) Lists are extremely fun, and some functions you would have found yourself writing on 10-15 lines can be got into 2-3. To get a better feel for playing around with lists, it’s useful to have them conform to some protocols that make them easier to work with in a playground.</p>
<p>For instance, making a list currently looks like this:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb9-1" data-line-number="1">let jo: List = <span class="dv">1</span> |&gt; <span class="dv">2</span> |&gt; <span class="dv">3</span> |&gt; .<span class="fu">Nil</span></a></code></pre></div>
<p>Which is fine, and better than:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb10-1" data-line-number="1">let jo: List = .<span class="fu">Cons</span>(head: <span class="dv">1</span>, tail: .<span class="fu">Cons</span>(head: <span class="dv">2</span>, tail: .<span class="fu">Cons</span>(head: <span class="dv">3</span>, tail: .<span class="fu">Nil</span>)))</a></code></pre></div>
<p>but still not fantastic. The obvious next step is making <code class="sourceCode scala">List</code> <code class="sourceCode scala">ArrayLiteralConvertible</code>, but there’s a small catch. We don’t have an <code class="sourceCode scala">append</code> function for lists (yet). So we can’t, off the bat, do something like this:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb11-1" data-line-number="1">extension List : ArrayLiteralConvertible {</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">  public <span class="fu">init</span>(arrayLiteral: Element...) {</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">    <span class="kw">var</span> ret: List&lt;Element&gt; = .<span class="fu">Nil</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4">    <span class="kw">for</span> el in arrayLiteral { ret.<span class="fu">append</span>(el) }</a>
<a class="sourceLine" id="cb11-5" data-line-number="5">    self = ret</a>
<a class="sourceLine" id="cb11-6" data-line-number="6">  }</a>
<a class="sourceLine" id="cb11-7" data-line-number="7">}</a></code></pre></div>
<p>And nor do I think we’d want to. Operations on the end of lists are slow: you have to walk along the entire list every time.</p>
<p>We could <em>reverse</em> the sequence we want to turn into a list, and prepend as we go. But… that’s inefficient too. Sure, <code class="sourceCode scala">Array</code>s are fast to reverse, but other sequences aren’t. For those that can’t be reversed lazily, you’re storing an extra sequence in memory unnecessarily.</p>
<p>But there’s something that we can use: generators. In Swift, generators are like super-imperative, crazy-unsafe recursive lists. When you can the <code class="sourceCode scala"><span class="fu">next</span>()</code> method on a generator, you get the “head” back. Crucially, though: <em>the generator is left with the tail</em>. Making use of this fact too often will lead to bugs, but if we wrap it up in <code class="sourceCode scala"><span class="kw">private</span></code>, it’s a perfect fit:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb12-1" data-line-number="1">extension List {</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">  <span class="kw">private</span> init&lt;G : GeneratorType where G.<span class="fu">Element</span> == Element&gt;(<span class="kw">var</span> gen: G) {</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">    <span class="kw">if</span> let head = gen.<span class="fu">next</span>() {</a>
<a class="sourceLine" id="cb12-4" data-line-number="4">      self = head |&gt; List(gen: gen)</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">    } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb12-6" data-line-number="6">      self = .<span class="fu">Nil</span></a>
<a class="sourceLine" id="cb12-7" data-line-number="7">    }</a>
<a class="sourceLine" id="cb12-8" data-line-number="8">  }</a>
<a class="sourceLine" id="cb12-9" data-line-number="9">}</a></code></pre></div>
<p>The potential bug here is kind of interesting. If, instead of an infix operator for cons, we’d had a method on <code class="sourceCode scala">List</code> that did the same thing:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb13-1" data-line-number="1">extension List {</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">  public func <span class="fu">prepended</span>(<span class="kw">with</span>: Element) -&gt; List&lt;Element&gt; {</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">    <span class="kw">return</span> .<span class="fu">Cons</span>(head: <span class="kw">with</span>, tail: self)</a>
<a class="sourceLine" id="cb13-4" data-line-number="4">  }</a>
<a class="sourceLine" id="cb13-5" data-line-number="5">}</a></code></pre></div>
<p>We’d be able to curry that function in a <code class="sourceCode scala"><span class="fu">map</span>()</code>, and get an <code class="sourceCode scala">init</code> function that’s very pretty:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb14-1" data-line-number="1">extension List {</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">  <span class="kw">private</span> init&lt;G : GeneratorType where G.<span class="fu">Element</span> == Element&gt;(<span class="kw">var</span> g: G) {</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">    self = g.<span class="fu">next</span>().<span class="fu">map</span>(List(g: g).<span class="fu">prepended</span>) ?? .<span class="fu">Nil</span></a>
<a class="sourceLine" id="cb14-4" data-line-number="4">  }</a>
<a class="sourceLine" id="cb14-5" data-line-number="5">}</a></code></pre></div>
<p>But it won’t run. Since the recursive call to the function is curried, it’s resolved before the <code class="sourceCode scala">g.<span class="fu">next</span>()</code> part. Which means that, regardless of whether <code class="sourceCode scala">g</code> returns <code class="sourceCode scala">nil</code> or not, the call will be made, causing an infinite loop of sadness. To fix it, you have to make the order of operations clear: <em>do not</em> make a recursive call if <code class="sourceCode scala">g.<span class="fu">next</span>()</code> returns <code class="sourceCode scala">nil</code>.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb15-1" data-line-number="1">extension List {</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">  <span class="kw">private</span> init&lt;G : GeneratorType where G.<span class="fu">Element</span> == Element&gt;(<span class="kw">var</span> gen: G) {</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">    <span class="kw">if</span> let head = gen.<span class="fu">next</span>() {</a>
<a class="sourceLine" id="cb15-4" data-line-number="4">      self = head |&gt; List(gen: gen)</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">    } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb15-6" data-line-number="6">      self = .<span class="fu">Nil</span></a>
<a class="sourceLine" id="cb15-7" data-line-number="7">    }</a>
<a class="sourceLine" id="cb15-8" data-line-number="8">  }</a>
<a class="sourceLine" id="cb15-9" data-line-number="9">  public init&lt;S : SequenceType where S.<span class="fu">Generator</span>.<span class="fu">Element</span> == Element&gt;(_ seq: S) {</a>
<a class="sourceLine" id="cb15-10" data-line-number="10">    self = List(gen: seq.<span class="fu">generate</span>())</a>
<a class="sourceLine" id="cb15-11" data-line-number="11">  }</a>
<a class="sourceLine" id="cb15-12" data-line-number="12">}</a>
<a class="sourceLine" id="cb15-13" data-line-number="13"></a>
<a class="sourceLine" id="cb15-14" data-line-number="14">extension List : ArrayLiteralConvertible {</a>
<a class="sourceLine" id="cb15-15" data-line-number="15">  public <span class="fu">init</span>(arrayLiteral: Element...) {</a>
<a class="sourceLine" id="cb15-16" data-line-number="16">    self = List(arrayLiteral.<span class="fu">generate</span>())</a>
<a class="sourceLine" id="cb15-17" data-line-number="17">  }</a>
<a class="sourceLine" id="cb15-18" data-line-number="18">}</a></code></pre></div>
<p>This all makes it easy to initialise a list. Being able to <em>see</em> the list and its contents is also important. Currently, we’ve got this mess:</p>
<p><img class="aligncenter size-full wp-image-404" src="https://bigonotetaking.files.wordpress.com/2015/07/screen-shot-2015-07-29-at-12-12-56.png" alt="Screen Shot 2015-07-29 at 12.12.56" width="660" height="39" /></p>
<p>When what we really want is a comma-separated list of the contents. We also probably want some demarcation at either end, so it’s easier to recognise nested lists. I’m not sure what the best demarcation would be: ideally it should be different to an Array’s square brackets, but not confusing either. I went with <code class="sourceCode scala">[:</code> and <code class="sourceCode scala">:]</code> in the end, though I’m not terribly happy about it:</p>
<p><img class="aligncenter size-full wp-image-406" src="https://bigonotetaking.files.wordpress.com/2015/07/screen-shot-2015-07-29-at-12-27-53.png" alt="Screen Shot 2015-07-29 at 12.27.53" width="522" height="32" /></p>
<p>To get that printout on the right-hand-side of your playground, you need to make your type <code class="sourceCode scala">CustomDebugStringConvertible</code>. There’s one one interesting problem with this: how do you know the contents of your list are printable? You can’t extend your struct to have conditional conformance, like this:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb16-1" data-line-number="1">extension List (where Element : CustomDebugStringConvertible) : CustomDebugStringConvertible {...</a></code></pre></div>
<p>However, you can’t just get a string representation of something that doesn’t have one. Luckily, <code class="sourceCode scala">String</code> has an initialiser that takes <em>anything</em>. It uses runtime reflection to do so. Here’s what the extension ends up looking like:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb17-1" data-line-number="1">extension List : CustomDebugStringConvertible {</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">  public <span class="kw">var</span> debugDescription: String {</a>
<a class="sourceLine" id="cb17-3" data-line-number="3">    return<span class="st">&quot;[:&quot;</span> + <span class="st">&quot;, &quot;</span>.<span class="fu">join</span>(map{String(reflecting: $<span class="dv">0</span>)}) + <span class="st">&quot;:]&quot;</span></a>
<a class="sourceLine" id="cb17-4" data-line-number="4">  }</a>
<a class="sourceLine" id="cb17-5" data-line-number="5">}</a></code></pre></div>
<p>To use the <code class="sourceCode scala"><span class="fu">join</span>()</code> function, of course, <code class="sourceCode scala">List</code> needs to conform to <code class="sourceCode scala">SequenceType</code>. We’ll need some generator that swaps out the current <code class="sourceCode scala">List</code> struct on each iteration, and returns the head. You <em>could</em> just use <code class="sourceCode scala">anyGenerator</code> but, since it’s a class, it’s significantly slower than defining a new struct.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb18-1" data-line-number="1">public struct ListGenerator&lt;Element&gt; : GeneratorType, SequenceType {</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">  <span class="kw">private</span> <span class="kw">var</span> list: List&lt;Element&gt;</a>
<a class="sourceLine" id="cb18-3" data-line-number="3">  public mutating func <span class="fu">next</span>() -&gt; Element? {</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">    switch list {</a>
<a class="sourceLine" id="cb18-5" data-line-number="5">    <span class="kw">case</span> .<span class="fu">Nil</span>: <span class="kw">return</span> nil</a>
<a class="sourceLine" id="cb18-6" data-line-number="6">    <span class="kw">case</span> let .<span class="fu">Cons</span>(head, tail):</a>
<a class="sourceLine" id="cb18-7" data-line-number="7">      list = tail</a>
<a class="sourceLine" id="cb18-8" data-line-number="8">      <span class="kw">return</span> head</a>
<a class="sourceLine" id="cb18-9" data-line-number="9">    }</a>
<a class="sourceLine" id="cb18-10" data-line-number="10">  }</a>
<a class="sourceLine" id="cb18-11" data-line-number="11">  public func <span class="fu">generate</span>() -&gt; ListGenerator { <span class="kw">return</span> self }</a>
<a class="sourceLine" id="cb18-12" data-line-number="12">}</a>
<a class="sourceLine" id="cb18-13" data-line-number="13"></a>
<a class="sourceLine" id="cb18-14" data-line-number="14">extension List : SequenceType {</a>
<a class="sourceLine" id="cb18-15" data-line-number="15">  public func <span class="fu">generate</span>() -&gt; ListGenerator&lt;Element&gt; {</a>
<a class="sourceLine" id="cb18-16" data-line-number="16">    <span class="kw">return</span> <span class="fu">ListGenerator</span>(list: self)</a>
<a class="sourceLine" id="cb18-17" data-line-number="17">  }</a>
<a class="sourceLine" id="cb18-18" data-line-number="18">}</a></code></pre></div>
<p>And you’ve got a <code class="sourceCode scala">SequenceType</code> that’s normal-looking and easy to work with.</p>
<h3 id="laziness">Laziness</h3>
<p>I’m not sure if this is entirely relevant here, but I <em>do</em> like laziness, so I thought I’d make a version of <code class="sourceCode scala">List</code> that was lazy. It turns out it’s easy to do: in fact, it was possible before <code class="sourceCode scala">indirect</code> enums. So, starting with the standard <code class="sourceCode scala">List</code> definition:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb19-1" data-line-number="1">public enum LazyList&lt;Element&gt; {</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">  <span class="kw">case</span> Nil</a>
<a class="sourceLine" id="cb19-3" data-line-number="3">  indirect <span class="kw">case</span> <span class="fu">Cons</span>(head: Element, tail: LazyList&lt;Element&gt;)</a>
<a class="sourceLine" id="cb19-4" data-line-number="4">}</a></code></pre></div>
<p>Let’s make it lazy. The main idea would be to defer the resolution of <code class="sourceCode scala">tail</code>. What we really want is for tail to be a function that <em>returns</em> a list, rather than a list itself.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb20-1" data-line-number="1">public enum LazyList&lt;Element&gt; {</a>
<a class="sourceLine" id="cb20-2" data-line-number="2">  <span class="kw">case</span> Nil</a>
<a class="sourceLine" id="cb20-3" data-line-number="3">  <span class="kw">case</span> <span class="fu">Cons</span>(head: Element, tail: () -&gt; LazyList&lt;Element&gt;)</a>
<a class="sourceLine" id="cb20-4" data-line-number="4">}</a></code></pre></div>
<p>This is the reason that <code class="sourceCode scala">indirect</code> isn’t needed: because tail isn’t a list, all that’s stored in the enum is the reference to the function. This is what <code class="sourceCode scala">indirect</code> does automatically, or what the <code class="sourceCode scala">Box</code> struct did manually.</p>
<p>There are some more wrinkles with laziness. For instance, our old infix operator won’t work:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb21-1" data-line-number="1">public func |&gt; &lt;T&gt;(lhs: T, rhs: LazyList&lt;T&gt;) -&gt; LazyList&lt;T&gt; {</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">  <span class="kw">return</span> .<span class="fu">Cons</span>(head: lhs, tail: rhs)</a>
<a class="sourceLine" id="cb21-3" data-line-number="3">}</a></code></pre></div>
<p>Again, because tail is meant to be a function that returns a list, not a list itself. This <em>would</em> work, but not in the way we intend it:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb22-1" data-line-number="1">public func |&gt; &lt;T&gt;(lhs: T, rhs: LazyList&lt;T&gt;) -&gt; LazyList&lt;T&gt; {</a>
<a class="sourceLine" id="cb22-2" data-line-number="2">  <span class="kw">return</span> .<span class="fu">Cons</span>(head: lhs, tail: {rhs})</a>
<a class="sourceLine" id="cb22-3" data-line-number="3">}</a></code></pre></div>
<p>Whatever’s to the right-hand-side of the operator will get resolved, and <em>then</em> put into the closure, which we don’t want. For instance, this:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb23-1" data-line-number="1">func <span class="fu">printAndGiveList</span>() -&gt; LazyList&lt;Int&gt; {</a>
<a class="sourceLine" id="cb23-2" data-line-number="2">  <span class="fu">print</span>(<span class="dv">2</span>)</a>
<a class="sourceLine" id="cb23-3" data-line-number="3">  <span class="kw">return</span> .<span class="fu">Nil</span></a>
<a class="sourceLine" id="cb23-4" data-line-number="4">}</a>
<a class="sourceLine" id="cb23-5" data-line-number="5"></a>
<a class="sourceLine" id="cb23-6" data-line-number="6"><span class="dv">2</span> |&gt; <span class="dv">1</span> |&gt; <span class="fu">printAndGiveList</span>()</a></code></pre></div>
<p>Will give you a “<code class="sourceCode scala">LazyList</code>”, but 2 gets printed, meaning that it’s not <em>really</em> behaving lazily.</p>
<p><code class="sourceCode scala">@autoclosure</code> to the rescue! This is a little annotation you put before your parameters that can let you decide when to evaluate the argument.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb24-1" data-line-number="1">public func |&gt; &lt;T&gt;(lhs: T, @<span class="fu">autoclosure</span>(escaping) rhs: () -&gt; LazyList&lt;T&gt;) -&gt; LazyList&lt;T&gt; {</a>
<a class="sourceLine" id="cb24-2" data-line-number="2">  <span class="kw">return</span> .<span class="fu">Cons</span>(head: lhs, tail: rhs)</a>
<a class="sourceLine" id="cb24-3" data-line-number="3">}</a></code></pre></div>
<p>The <code class="sourceCode scala">escaping</code> in the brackets is needed to signify that the closure will last longer than the lifetime of the scope it is declared in. If you test this new version with the <code class="sourceCode scala"><span class="fu">printAndGiveList</span>()</code> function, you’ll see that 2 does <em>not</em> get printed. In fact, the behaviour of this operator lets us use a lot of the same code from the strict list, <em>without</em> the strictness. (The generator initialiser, for instance: the same code, if used to initialise a lazy list, will work. In fact, if the underlying sequence that the generator comes from is lazy, <em>that laziness is maintained in the lazy list</em>. That’s pretty cool.)</p>
<p>There’s an interesting point to be made, here. The usual definition for a lazy programming language is one in which functions do not evaluate their arguments until they need to. In contrast, eager languages evaluate function arguments before the body of the function. This kind of makes it seem that you could treat Swift as a totally lazy language…</p>
<p>At any rate, this new-and-improved operator works exactly as we want it. It’s properly lazy. The rest is easy: every time <code class="sourceCode scala">tail</code> was used in <code class="sourceCode scala">List</code>, replace it with <code class="sourceCode scala"><span class="fu">tail</span>()</code>.</p>
<h3 id="the-deque">The Deque</h3>
<p>Lists are useful. They let you operate on their first element in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math> time, which makes a lot of sense, since you often find yourself starting there.</p>
<p>They’ve got some disadvantages, though: for one, to get to the nth element, you have to walk along n elements in the list. So while operations of the <em>start</em> are fast, operations on the end are painfully slow. And forget about efficient indexing.</p>
<p>This is where a Deque comes in. When you need to operate on two ends of a collection, a Deque is what you want to be using. Removal of the first and last element, prepending, and appending are all <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math>.</p>
<p>It’s made up of two lists: one for the front half, and one, in reverse, for the back half. With that information we’ve enough to get a definition down:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb25-1" data-line-number="1">public struct Deque&lt;Element&gt; {</a>
<a class="sourceLine" id="cb25-2" data-line-number="2">  <span class="kw">private</span> <span class="kw">var</span> front, back: List&lt;Element&gt;</a>
<a class="sourceLine" id="cb25-3" data-line-number="3">}</a></code></pre></div>
<p>You’ve got to do similar things that you did to the list to get an easy-to-work-with struct. <code class="sourceCode scala">CustomDebugStringConvertible</code>, <code class="sourceCode scala">ArrayLiteralConvertible</code>, etc. It’s not tremendously interesting, so here it is:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb26-1" data-line-number="1">extension Deque : CustomDebugStringConvertible {</a>
<a class="sourceLine" id="cb26-2" data-line-number="2">  public <span class="kw">var</span> debugDescription: String {</a>
<a class="sourceLine" id="cb26-3" data-line-number="3">    <span class="kw">return</span></a>
<a class="sourceLine" id="cb26-4" data-line-number="4">      <span class="st">&quot;, &quot;</span>.<span class="fu">join</span>(front.<span class="fu">map</span>{String(reflecting: $<span class="dv">0</span>)}) +</a>
<a class="sourceLine" id="cb26-5" data-line-number="5">      <span class="st">&quot; | &quot;</span> +</a>
<a class="sourceLine" id="cb26-6" data-line-number="6">      <span class="st">&quot;, &quot;</span>.<span class="fu">join</span>(back.<span class="fu">reverse</span>().<span class="fu">map</span>{String(reflecting: $<span class="dv">0</span>)})</a>
<a class="sourceLine" id="cb26-7" data-line-number="7">  }</a>
<a class="sourceLine" id="cb26-8" data-line-number="8">}</a>
<a class="sourceLine" id="cb26-9" data-line-number="9"></a>
<a class="sourceLine" id="cb26-10" data-line-number="10">extension Deque {</a>
<a class="sourceLine" id="cb26-11" data-line-number="11">  public <span class="fu">init</span>(array: [Element]) {</a>
<a class="sourceLine" id="cb26-12" data-line-number="12">    let half = array.<span class="fu">endIndex</span> / <span class="dv">2</span></a>
<a class="sourceLine" id="cb26-13" data-line-number="13">    front = List(array[<span class="dv">0</span>..&lt;half])</a>
<a class="sourceLine" id="cb26-14" data-line-number="14">    back = List(array[half..&lt;array.<span class="fu">endIndex</span>].<span class="fu">reverse</span>())</a>
<a class="sourceLine" id="cb26-15" data-line-number="15">  }</a>
<a class="sourceLine" id="cb26-16" data-line-number="16">}</a>
<a class="sourceLine" id="cb26-17" data-line-number="17"></a>
<a class="sourceLine" id="cb26-18" data-line-number="18">extension Deque : ArrayLiteralConvertible {</a>
<a class="sourceLine" id="cb26-19" data-line-number="19">  public <span class="fu">init</span>(arrayLiteral: Element...) {</a>
<a class="sourceLine" id="cb26-20" data-line-number="20">    self.<span class="fu">init</span>(array: arrayLiteral)</a>
<a class="sourceLine" id="cb26-21" data-line-number="21">  }</a>
<a class="sourceLine" id="cb26-22" data-line-number="22">}</a>
<a class="sourceLine" id="cb26-23" data-line-number="23"></a>
<a class="sourceLine" id="cb26-24" data-line-number="24">extension Deque {</a>
<a class="sourceLine" id="cb26-25" data-line-number="25">  public init&lt;S : SequenceType where S.<span class="fu">Generator</span>.<span class="fu">Element</span> == Element&gt;(_ seq: S) {</a>
<a class="sourceLine" id="cb26-26" data-line-number="26">    self.<span class="fu">init</span>(array: Array(seq))</a>
<a class="sourceLine" id="cb26-27" data-line-number="27">  }</a>
<a class="sourceLine" id="cb26-28" data-line-number="28">}</a></code></pre></div>
<p>The debug output puts a <code class="sourceCode scala">|</code> between the two lists:</p>
<p><img class="aligncenter size-full wp-image-395" src="https://bigonotetaking.files.wordpress.com/2015/07/screen-shot-2015-07-28-at-21-32-44.png" alt="Screen Shot 2015-07-28 at 21.32.44" width="660" height="29" /></p>
<p>This makes it clear how the performance characteristics come about: because the second half is a reversed list, all of the operations on the end of the Deque are operations on the beginning of a list. And that’s where lists are fast.</p>
<p>But there’s an obvious issue. Say we take that list, and start removing the first element from it:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb27-1" data-line-number="1">let a = an.<span class="fu">tail</span> <span class="co">// 2, 3 | 4, 5, 6</span></a>
<a class="sourceLine" id="cb27-2" data-line-number="2">let b = a.<span class="fu">tail</span>  <span class="co">// 3 | 4, 5, 6</span></a>
<a class="sourceLine" id="cb27-3" data-line-number="3">let c = b.<span class="fu">tail</span>  <span class="co">// | 4, 5, 6</span></a>
<a class="sourceLine" id="cb27-4" data-line-number="4">let d = c.<span class="fu">tail</span>  <span class="co">// ?????</span></a></code></pre></div>
<p>The front will end up being empty. The solution to this is the second important element to a Deque. It needs an invariant: if its number of elements is greater than one, neither the front list nor the back will be empty. When the invariant gets violated, it needs to fix it. We can check that the invariant has been upheld with a <code class="sourceCode scala">switch</code> statement:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb28-1" data-line-number="1">extension Deque {</a>
<a class="sourceLine" id="cb28-2" data-line-number="2">  <span class="kw">private</span> mutating func <span class="fu">check</span>() {</a>
<a class="sourceLine" id="cb28-3" data-line-number="3">    <span class="fu">switch</span> (front, back) {</a>
<a class="sourceLine" id="cb28-4" data-line-number="4">    <span class="kw">case</span> (.<span class="fu">Nil</span>, let .<span class="fu">Cons</span>(head, tail)) where !tail.<span class="fu">isEmpty</span>: <span class="fu">fix</span>()</a>
<a class="sourceLine" id="cb28-5" data-line-number="5">    <span class="kw">case</span> (let .<span class="fu">Cons</span>(head, tail), .<span class="fu">Nil</span>) where !tail.<span class="fu">isEmpty</span>: <span class="fu">fix</span>()</a>
<a class="sourceLine" id="cb28-6" data-line-number="6">    default:</a>
<a class="sourceLine" id="cb28-7" data-line-number="7">      <span class="kw">return</span></a>
<a class="sourceLine" id="cb28-8" data-line-number="8">    }</a>
<a class="sourceLine" id="cb28-9" data-line-number="9">  }</a>
<a class="sourceLine" id="cb28-10" data-line-number="10">}</a></code></pre></div>
<p>The first case is the front is empty, and the back has more than one element, and the second case is the back is empty, and the front has more than one element. To fix it, just chop off the tail of the non-empty list, reverse it, and assign it to the empty list:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb29-1" data-line-number="1">extension Deque {</a>
<a class="sourceLine" id="cb29-2" data-line-number="2">  <span class="kw">private</span> mutating func <span class="fu">check</span>() {</a>
<a class="sourceLine" id="cb29-3" data-line-number="3">    <span class="fu">switch</span> (front, back) {</a>
<a class="sourceLine" id="cb29-4" data-line-number="4">    <span class="kw">case</span> (.<span class="fu">Nil</span>, let .<span class="fu">Cons</span>(head, tail)) where !tail.<span class="fu">isEmpty</span>:</a>
<a class="sourceLine" id="cb29-5" data-line-number="5">      (front, back) = (tail.<span class="fu">reverse</span>(), [head])</a>
<a class="sourceLine" id="cb29-6" data-line-number="6">    <span class="kw">case</span> (let .<span class="fu">Cons</span>(head, tail), .<span class="fu">Nil</span>) where !tail.<span class="fu">isEmpty</span>:</a>
<a class="sourceLine" id="cb29-7" data-line-number="7">      (back, front) = (tail.<span class="fu">reverse</span>(), [head])</a>
<a class="sourceLine" id="cb29-8" data-line-number="8">    default:</a>
<a class="sourceLine" id="cb29-9" data-line-number="9">      <span class="kw">return</span></a>
<a class="sourceLine" id="cb29-10" data-line-number="10">    }</a>
<a class="sourceLine" id="cb29-11" data-line-number="11">  }</a>
<a class="sourceLine" id="cb29-12" data-line-number="12">}</a></code></pre></div>
<p>Now, wherever we have a mutating method that may cause a violation of the invariant, this <code class="sourceCode scala">check</code> is called. One particularly cool way to do this is by using <code class="sourceCode scala">didSet</code>:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb30-1" data-line-number="1">public struct Deque&lt;Element&gt; {</a>
<a class="sourceLine" id="cb30-2" data-line-number="2">  <span class="kw">private</span> <span class="kw">var</span> front: List&lt;Element&gt; { didSet { <span class="fu">check</span>() } }</a>
<a class="sourceLine" id="cb30-3" data-line-number="3">  <span class="kw">private</span> <span class="kw">var</span> back : List&lt;Element&gt; { didSet { <span class="fu">check</span>() } }</a>
<a class="sourceLine" id="cb30-4" data-line-number="4">}</a></code></pre></div>
<p>This will call <code class="sourceCode scala"><span class="fu">check</span>()</code> whenever either list is mutated, ensuring you can’t forget. If a <em>new</em> Deque is initialised, though, it won’t be called. I don’t trust myself to remember the <code class="sourceCode scala"><span class="fu">check</span>()</code> on every init, so we can put it into the initialiser:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb31-1" data-line-number="1">  <span class="kw">private</span> <span class="fu">init</span>(_ front: List&lt;Element&gt;, _ back: List&lt;Element&gt;) {</a>
<a class="sourceLine" id="cb31-2" data-line-number="2">    (self.<span class="fu">front</span>, self.<span class="fu">back</span>) = (front, back)</a>
<a class="sourceLine" id="cb31-3" data-line-number="3">    <span class="fu">check</span>()</a>
<a class="sourceLine" id="cb31-4" data-line-number="4">  }</a></code></pre></div>
<p>This is the only initialiser so far, so it’s the only one I’m allowed to call. However, there may be some cases where I <em>know</em> that the front and back are balanced. So I want a separate initialiser for those, for efficiency’s sake. But it’s got to be called <code class="sourceCode scala">init</code> no matter what, so how can I specify that I want to use the non-checking initialiser, over the checking one? I could have a function called something like <code class="sourceCode scala">initialiseFromBalanced</code> that returns a Deque, but I don’t like that. You could use labelled arguments. <a href="http://ericasadun.com/2015/06/01/swift-safe-array-indexing-my-favorite-thing-of-the-new-week/">Erica Sadun has a cool post on using them with subscripts</a>, and here’s what it would look like with <code class="sourceCode scala">init</code>:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb32-1" data-line-number="1">extension Deque {</a>
<a class="sourceLine" id="cb32-2" data-line-number="2">  <span class="kw">private</span> <span class="fu">init</span>(balancedFront: List&lt;Element&gt;, balancedBack: List&lt;Element&gt;) {</a>
<a class="sourceLine" id="cb32-3" data-line-number="3">    (front, back) = (balancedFront, balancedBack)</a>
<a class="sourceLine" id="cb32-4" data-line-number="4">  }</a>
<a class="sourceLine" id="cb32-5" data-line-number="5">}</a></code></pre></div>
<p>So now we have a default initialiser that automatically balances the Deque, and a specialised one that takes two lists already balanced.</p>
<p>There is an extra function on lists in the <code class="sourceCode scala"><span class="fu">check</span>()</code> function: <code class="sourceCode scala"><span class="fu">reverse</span>()</code>. There are a load of different ways to do it. If you’re in the mood for golf:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb33-1" data-line-number="1">let joanne: List = [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>]</a>
<a class="sourceLine" id="cb33-2" data-line-number="2">joanne.<span class="fu">reduce</span>(.<span class="fu">Nil</span>) { $<span class="dv">1</span> |&gt; $<span class="dv">0</span> } <span class="co">// 6, 5, 4, 3, 2, 1</span></a></code></pre></div>
<p>Or, if you’d like to keep it recursive:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb34-1" data-line-number="1">extension List {</a>
<a class="sourceLine" id="cb34-2" data-line-number="2">  <span class="kw">private</span> func <span class="fu">reverse</span>(other: List&lt;Element&gt;) -&gt; List&lt;Element&gt; {</a>
<a class="sourceLine" id="cb34-3" data-line-number="3">    switch self {</a>
<a class="sourceLine" id="cb34-4" data-line-number="4">    <span class="kw">case</span> .<span class="fu">Nil</span>: <span class="kw">return</span> other</a>
<a class="sourceLine" id="cb34-5" data-line-number="5">    <span class="kw">case</span> let .<span class="fu">Cons</span>(head, tail): <span class="kw">return</span> tail.<span class="fu">reverse</span>(head |&gt; other)</a>
<a class="sourceLine" id="cb34-6" data-line-number="6">    }</a>
<a class="sourceLine" id="cb34-7" data-line-number="7">  }</a>
<a class="sourceLine" id="cb34-8" data-line-number="8">  public func <span class="fu">reverse</span>() -&gt; List&lt;Element&gt; {</a>
<a class="sourceLine" id="cb34-9" data-line-number="9">    <span class="kw">return</span> <span class="fu">reverse</span>(.<span class="fu">Nil</span>)</a>
<a class="sourceLine" id="cb34-10" data-line-number="10">  }</a>
<a class="sourceLine" id="cb34-11" data-line-number="11">}</a></code></pre></div>
<p>Obviously, you want to avoid this operation as much as possible. We’ll have to bear that in mind when we’re adding other functions.</p>
<p>So what kind of operations do we want on Deques? Well, <code class="sourceCode scala"><span class="fu">removeFirst</span>()</code> and <code class="sourceCode scala"><span class="fu">removeLast</span>()</code> would be a start:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb35-1" data-line-number="1">extension Deque {</a>
<a class="sourceLine" id="cb35-2" data-line-number="2">  public mutating func <span class="fu">removeFirst</span>() -&gt; Element {</a>
<a class="sourceLine" id="cb35-3" data-line-number="3">    <span class="kw">return</span> front.<span class="fu">removeFirst</span>()</a>
<a class="sourceLine" id="cb35-4" data-line-number="4">  }</a>
<a class="sourceLine" id="cb35-5" data-line-number="5">  public mutating func <span class="fu">removeLast</span>() -&gt; Element {</a>
<a class="sourceLine" id="cb35-6" data-line-number="6">    <span class="kw">return</span> back.<span class="fu">removeFirst</span>()</a>
<a class="sourceLine" id="cb35-7" data-line-number="7">  }</a>
<a class="sourceLine" id="cb35-8" data-line-number="8">}</a></code></pre></div>
<p>And the function on lists:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb36-1" data-line-number="1">extension List {</a>
<a class="sourceLine" id="cb36-2" data-line-number="2">  public mutating func <span class="fu">removeFirst</span>() -&gt; Element {</a>
<a class="sourceLine" id="cb36-3" data-line-number="3">    switch self {</a>
<a class="sourceLine" id="cb36-4" data-line-number="4">    <span class="kw">case</span> .<span class="fu">Nil</span>: <span class="fu">fatalError</span>(<span class="st">&quot;Cannot call removeFirst() on an empty list&quot;</span>)</a>
<a class="sourceLine" id="cb36-5" data-line-number="5">    <span class="kw">case</span> let .<span class="fu">Cons</span>(head, tail):</a>
<a class="sourceLine" id="cb36-6" data-line-number="6">      self = tail</a>
<a class="sourceLine" id="cb36-7" data-line-number="7">      <span class="kw">return</span> head</a>
<a class="sourceLine" id="cb36-8" data-line-number="8">    }</a>
<a class="sourceLine" id="cb36-9" data-line-number="9">  }</a>
<a class="sourceLine" id="cb36-10" data-line-number="10">}</a></code></pre></div>
<p>The other functions are easy enough to figure out: <code class="sourceCode scala"><span class="fu">dropFirst</span>()</code>, <code class="sourceCode scala"><span class="fu">dropLast</span>()</code>, etc. And, since it conforms to <code class="sourceCode scala">SequenceType</code>, it gets all of the sequence methods from the standard library, as well. However, those methods are designed for other kinds of sequences - <code class="sourceCode scala">Array</code>s, <code class="sourceCode scala">String.<span class="fu">CharacterView</span></code>s, etc. There are <em>much</em> more efficient ways to do most of them. <code class="sourceCode scala">reverse</code>, for instance, is just this:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb37-1" data-line-number="1">extension Deque {</a>
<a class="sourceLine" id="cb37-2" data-line-number="2">  public func <span class="fu">reverse</span>() -&gt; Deque&lt;Element&gt; {</a>
<a class="sourceLine" id="cb37-3" data-line-number="3">    <span class="kw">return</span> <span class="fu">Deque</span>(balancedFront: back, balancedBack: front)</a>
<a class="sourceLine" id="cb37-4" data-line-number="4">  }</a>
<a class="sourceLine" id="cb37-5" data-line-number="5">}</a></code></pre></div>
<p>(Since reverse can’t change the number of elements in either list, we can use the initialiser that takes a balanced front and back.) Other methods like <code class="sourceCode scala"><span class="fu">map</span>()</code>, <code class="sourceCode scala"><span class="fu">filter</span>()</code>, etc., will just give you back an array. If we wanted to keep the Deque, we’d have to convert it back, which involves reversing, which is expensive. So we should do our own methods for those:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb38-1" data-line-number="1">extension Deque {</a>
<a class="sourceLine" id="cb38-2" data-line-number="2">  public func map&lt;T&gt;(@noescape transform: Element -&gt; T) -&gt; Deque&lt;T&gt; {</a>
<a class="sourceLine" id="cb38-3" data-line-number="3">    <span class="kw">return</span> Deque&lt;T&gt;(</a>
<a class="sourceLine" id="cb38-4" data-line-number="4">      balancedFront: front.<span class="fu">map</span>(transform),</a>
<a class="sourceLine" id="cb38-5" data-line-number="5">      balancedBack : back .<span class="fu">map</span>(transform)</a>
<a class="sourceLine" id="cb38-6" data-line-number="6">    )</a>
<a class="sourceLine" id="cb38-7" data-line-number="7">  }</a>
<a class="sourceLine" id="cb38-8" data-line-number="8">}</a>
<a class="sourceLine" id="cb38-9" data-line-number="9"></a>
<a class="sourceLine" id="cb38-10" data-line-number="10">extension Deque {</a>
<a class="sourceLine" id="cb38-11" data-line-number="11">  public func <span class="fu">filter</span>(@noescape includeElement: Element -&gt; Bool) -&gt; Deque&lt;Element&gt; {</a>
<a class="sourceLine" id="cb38-12" data-line-number="12">    <span class="kw">return</span> <span class="fu">Deque</span>(front.<span class="fu">filter</span>(includeElement), back.<span class="fu">filter</span>(includeElement))</a>
<a class="sourceLine" id="cb38-13" data-line-number="13">  }</a>
<a class="sourceLine" id="cb38-14" data-line-number="14">}</a></code></pre></div>
<p><code class="sourceCode scala"><span class="fu">filter</span>()</code> changes the number of elements in each list, which could cause violation of the invariant. So we use the unlabelled initialiser, which automatically <code class="sourceCode scala"><span class="fu">check</span>()</code>s.</p>
<p>Notice that we don’t have to do any reversing here. This is a huge efficiency gain, but you’ve got to bear in mind that we’re assuming the order of execution of the closures for <code class="sourceCode scala">filter</code> and <code class="sourceCode scala">map</code> don’t matter. This isn’t always the case. Take this function, which is supposed to skip two elements of a sequence:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb39-1" data-line-number="1"><span class="kw">var</span> i = <span class="dv">0</span></a>
<a class="sourceLine" id="cb39-2" data-line-number="2">[Int](<span class="dv">1</span>...<span class="dv">10</span>).<span class="fu">filter</span> { _ in i++ % <span class="dv">3</span> == <span class="dv">0</span> } <span class="co">// [1, 4, 7, 10]</span></a></code></pre></div>
<p>It won’t work for a Deque:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb40-1" data-line-number="1"><span class="fu">Deque</span>(<span class="dv">1</span>...<span class="dv">10</span>).<span class="fu">filter</span> { _ in i++ % <span class="dv">3</span> == <span class="dv">0</span> } <span class="co">// 1, 4 | 6, 9</span></a></code></pre></div>
<p>There’s been talk of a <code class="sourceCode scala">@pure</code> attribute. The idea is this: put it before your function or closure name, and the compiler will verify that it has no side effects. It can only use its arguments as variables, or call other <code class="sourceCode scala">@pure</code> functions. It would be very useful here, as it wouldn’t allow the <code class="sourceCode scala">i</code> to be used by <code class="sourceCode scala">filter</code>. Without it, you’ll probably just have to mention in the docs that the order of execution is not knowable.</p>
<p>For completeness’ sake, there are also <code class="sourceCode scala"><span class="fu">flatMap</span>()</code>s for the Deque, implemented in a similar fashion to the functions above:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb41-1" data-line-number="1">extension Deque {</a>
<a class="sourceLine" id="cb41-2" data-line-number="2">  public func flatMap&lt;T&gt;(@noescape transform: Element -&gt; Deque&lt;T&gt;) -&gt; Deque&lt;T&gt; {</a>
<a class="sourceLine" id="cb41-3" data-line-number="3">    <span class="kw">return</span> Deque&lt;T&gt;(</a>
<a class="sourceLine" id="cb41-4" data-line-number="4">      front.<span class="fu">flatMap</span>{List(<span class="fu">transform</span>($<span class="dv">0</span>))},</a>
<a class="sourceLine" id="cb41-5" data-line-number="5">      back .<span class="fu">flatMap</span>{List(<span class="fu">transform</span>($<span class="dv">0</span>).<span class="fu">reverse</span>())}</a>
<a class="sourceLine" id="cb41-6" data-line-number="6">    )</a>
<a class="sourceLine" id="cb41-7" data-line-number="7">  }</a>
<a class="sourceLine" id="cb41-8" data-line-number="8"></a>
<a class="sourceLine" id="cb41-9" data-line-number="9">  public func flatMap&lt;T&gt;(@noescape transform: Element -&gt; T?) -&gt; Deque&lt;T&gt; {</a>
<a class="sourceLine" id="cb41-10" data-line-number="10">    <span class="kw">return</span> Deque&lt;T&gt;(</a>
<a class="sourceLine" id="cb41-11" data-line-number="11">      front.<span class="fu">flatMap</span>(transform),</a>
<a class="sourceLine" id="cb41-12" data-line-number="12">      back .<span class="fu">flatMap</span>(transform)</a>
<a class="sourceLine" id="cb41-13" data-line-number="13">    )</a>
<a class="sourceLine" id="cb41-14" data-line-number="14">  }</a>
<a class="sourceLine" id="cb41-15" data-line-number="15">}</a></code></pre></div>
<p>All of this code is available as a playground, <a href="https://github.com/oisdk/Deques-Queues-and-Lists-in-Swift-with-indirect">here</a>. These two structs are also implemented a little more fully in <a href="https://github.com/oisdk/SwiftSequence">SwiftSequence</a>.</p>
<p>Since the only real constitutive part of the Deque is a list, it’s probably possible to implement it lazily, by just substituting in <code class="sourceCode scala">LazyList</code>s. Or, if you were feeling adventurous, you could have one of the lists lazy, and one strict. This isn’t as crazy as it sounds: <code class="sourceCode scala"><span class="fu">reverse</span>()</code> can <em>only</em> be performed eagerly, since the entire list needs to be walked to get to the last element. So the front and back lists have different functions (slightly). Also, because of the lazy initialisation of <code class="sourceCode scala">LazyList</code>, swapping between lazy and strict needn’t be very expensive. I’ll leave it up to someone else to try, though.</p>
]]></description>
    <pubDate>Wed, 29 Jul 2015 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2015-07-29-swift-queues.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>
<item>
    <title>A Strategy for Swift Protocols</title>
    <link>https://doisinkidney.com/posts/2015-07-17-swift-protocols-a-strategy.html</link>
    <description><![CDATA[<div class="info">
    Posted on July 17, 2015
</div>
<div class="info">
    
</div>
<div class="info">
    
        Tags: <a href="/tags/Swift.html">Swift</a>
    
</div>

<h3 id="a-misguided-over-simplified-strategy">A Misguided, Over-Simplified Strategy</h3>
<h1 id="it-makes-sense-to-me-so">It Makes Sense to Me, so…</h1>
<p>So I’ve been drinking the Protocol-Oriented-Programming gatorade for a while now. I’ve taken it to the extreme a little: you won’t find a class in pretty much any of my code these days. So, before I pull it back a little, I thought I’d put down my strategy so far for how to handle these protocol things.</p>
<p>To give you an idea of where I’m coming from: I never really understood object-oriented programming. It never clicked with me. I mean, I know the basic ideas, but they were never internalised. On the other hand, functional programming was a breeze (by comparison). I should be clear: by FP I don’t really mean monads or functors or applicative functors and monoids and commands and arrows and lenses and flux capacitors. I think everyone has a relatively difficult time wrapping their heads around that stuff.</p>
<p>I mean the <em>patterns</em> you see in FP. Pure functions - of course - but other things, also. Things that aren’t strictly FP, but just tend to be found among the FP: type classes, currying, immutability, declarative-ness, laziness, higher-order functions. Contrast that to the patterns you find in OOP: the delegate pattern, class inheritance, single-dependancy whatnot (I can’t even name them because I’m sure I’m mixing up and misunderstanding them).</p>
<p>Now, there are probably good reasons why I understand FP a little easier than OOP (or I think I do). OOP was what I saw first: when I began coding, it was in OOP. By the time I tried to understand, say, higher-order functions, I had already gotten my head around functions, types, variables, etc. Whereas when I first read “Python is an <em>object-oriented</em> programming language”, I had written my first hello world a few weeks before.</p>
<p>On top of that, I’m a hobbyist - I don’t like making things that really work, because that’s annoying. I am <em>very good</em> at finding you Fibonacci numbers. I don’t need to know about state, or IO, so I’m perfectly fine in the clean, pleasant world of FP (or semi-FP).</p>
<p>So what about protocols, then? Well, now that you know what kind of person you’re listening to, it might make sense when I say this: protocols are <em>awesome</em>. They make <em>so much</em> sense. I can’t believe we were ever doing things any other way.</p>
<p>Are protocols FP? Kind of. The first implementation of something protocol-like was probably in Haskell, with type classes. But OOP had a very similar system soon after, in the form of generics. And Dave Abrahams, who works on Swift, was the main guy for templates in C++ for a long time. They’re not FP in the traditional sense, but they <em>are</em> FP in the sense that I understand it: they’re a certain kind of style/technique. And they fit right in with the rest of the styles and techniques of FP.</p>
<h1 id="how-to-do-it">How to do it</h1>
<p>Anyway, I should get to my strategy for using them. Here’s my ridiculously oversimplified (mis)understanding of how you should see them: protocols describe <em>abilities</em> and <em>talents</em>. God that’s pretentious. Lemme try again: a protocol represents something a type <em>can</em> do, and <em>how well</em> it can do it. That’s a bit better.</p>
<p>Let’s look to the standard library for our examples here. Say you want to make a method that emulates Python’s slicing, where you can hop over elements of a sequence. Something like:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb1-1" data-line-number="1">public extension SequenceType {</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  func <span class="fu">hop</span>(n: Int) -&gt; [Generator.<span class="fu">Element</span>] {</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">    <span class="kw">var</span> i = n - <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">    <span class="kw">return</span> self.<span class="fu">filter</span> {</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">      _ -&gt; Bool in</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">      <span class="kw">if</span> ++i == n {</a>
<a class="sourceLine" id="cb1-7" data-line-number="7">        i = <span class="dv">0</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">        <span class="kw">return</span> <span class="kw">true</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9">      } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb1-10" data-line-number="10">        <span class="kw">return</span> <span class="kw">false</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11">      }</a>
<a class="sourceLine" id="cb1-12" data-line-number="12">    }</a>
<a class="sourceLine" id="cb1-13" data-line-number="13">  }</a>
<a class="sourceLine" id="cb1-14" data-line-number="14">}</a>
<a class="sourceLine" id="cb1-15" data-line-number="15">[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>].<span class="fu">hop</span>(<span class="dv">2</span>) <span class="co">// [1, 3, 5]</span></a></code></pre></div>
<p>We’re in protocol-land right away: <code class="sourceCode scala">SequenceType</code>. This is an “ability”. The method exists on everything with the <em>ability</em> to act like a sequence. That means arrays, sets, dictionaries, strings. Actually, a better example of the “ability” would be this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb2-1" data-line-number="1">extension IntegerArithmeticType {</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  func <span class="dt">double</span>() -&gt; Self {</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">    <span class="kw">return</span> self + self</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">  }</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">}</a>
<a class="sourceLine" id="cb2-6" data-line-number="6"></a>
<a class="sourceLine" id="cb2-7" data-line-number="7"><span class="fl">2.</span><span class="dt">double</span>() <span class="co">// 4</span></a></code></pre></div>
<p>Goodness gracious that’s contrived. But anyway, you get the idea. Anything that can do integer arithmetic gets that method.</p>
<p>Now, back to the hop method. Maybe it’s very expensive to actually retrieve every intermediate element and then discard it - that’s what filter is doing, after all. Why not just do an index lookup?</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb3-1" data-line-number="1">public extension CollectionType {</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  func <span class="fu">hop</span>(n: Index.<span class="fu">Distance</span>) -&gt; [Generator.<span class="fu">Element</span>] {</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">    </a>
<a class="sourceLine" id="cb3-4" data-line-number="4">    <span class="kw">var</span> ar: [Generator.<span class="fu">Element</span>] = []</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">    </a>
<a class="sourceLine" id="cb3-6" data-line-number="6">    <span class="kw">for</span> <span class="kw">var</span> i = startIndex; </a>
<a class="sourceLine" id="cb3-7" data-line-number="7">        indices.<span class="fu">contains</span>(i); </a>
<a class="sourceLine" id="cb3-8" data-line-number="8">        i = <span class="fu">advance</span>(i, n) {</a>
<a class="sourceLine" id="cb3-9" data-line-number="9">          ar.<span class="fu">append</span>(self[i])</a>
<a class="sourceLine" id="cb3-10" data-line-number="10">    }</a>
<a class="sourceLine" id="cb3-11" data-line-number="11">    </a>
<a class="sourceLine" id="cb3-12" data-line-number="12">    <span class="kw">return</span> ar</a>
<a class="sourceLine" id="cb3-13" data-line-number="13">  }</a>
<a class="sourceLine" id="cb3-14" data-line-number="14">}</a></code></pre></div>
<p>There we go! Everything can <em>do</em> the hop method, but <code class="sourceCode scala">CollectionType</code>s can do it <em>well</em>. In fact, some <code class="sourceCode scala">CollectionType</code>s can do it very well indeed:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb4-1" data-line-number="1">public extension CollectionType where Index : RandomAccessIndexType {  </a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  func <span class="fu">hop</span>(n: Index.<span class="fu">Stride</span>) -&gt; [Generator.<span class="fu">Element</span>] {</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">    <span class="kw">return</span> <span class="fu">stride</span>(from: startIndex, to: endIndex, by: n).<span class="fu">map</span>{self[$<span class="dv">0</span>]}</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">  }</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">}</a></code></pre></div>
<p>You see this kind of thing all around the standard library, but most prominently with the index types. If something is able to do something, it gets the bare-bones, inefficient implementation. Then, for types with all the bells and whistles, you get the clever, blazing-fast version. And to the user, all you see is some easy-looking <code class="sourceCode scala"><span class="fu">indexOf</span>()</code> function.</p>
<p>So here’s how I think you should be doing your APIs: if at all possible, write your function as a method. Write the most bare-bones, slow version of it you possibly can that still makes sense. Then, specialise where it suits.</p>
<p>(I realise now that I may have just described a design pattern that was very obvious to everyone but me. Ah, well)</p>
<h1 id="the-why">The Why</h1>
<p>There are pretty major advantages to this. Your two other options are generally class inheritance, or global functions with generics. <a href="https://developer.apple.com/videos/wwdc/2015/?id=408">The best video from WWDC</a> talks about class inheritance, so I’ll stay away from that. In contrast to global functions, here are the advantages:</p>
<h2 id="more-discoverable">More discoverable</h2>
<p>Hit dot after whatever thing you’re interested in, and the little list of available goodies pops up. It’s also easy to find in the documentation (what kind of methods do I have on sequences? vs. Right, here’s the page for the global functions, cmd-f “Sequence”… hmm, <code class="sourceCode scala">indexOf</code> isn’t here…)</p>
<h2 id="function-compositionish">Function composition(ish)</h2>
<p>We currently have this:</p>
<pre><code>g(f(x))</code></pre>
<p>Now, if we were in Haskell-land, you could write:</p>
<pre><code>(g . f) x</code></pre>
<p>But we’re not. However, if f is a method on x, and g is a method on whatever if returned by f, you can have:</p>
<pre><code>x.f().g()</code></pre>
<p>Maybe a bit of a bad example, but <a href="http://airspeedvelocity.net/2015/06/23/protocol-extensions-and-the-death-of-the-pipe-forward-operator/">combine that with <code class="sourceCode scala">flatMap</code> and laziness and you’ve got some handsome-looking, powerful functions right there.</a></p>
<h2 id="easy-to-build-hierarchies">Easy-to-build hierarchies</h2>
<p>I find myself often getting a bit philosophical around all of these protocols (“yeah, but what does it <em>mean</em> to be <code class="sourceCode scala">IntegerLiteralConvertible</code>? I mean, aren’t we <em>all</em> <code class="sourceCode scala">IntegerLiteralConvertible</code>, in a way?”, “Woah”). I see places where I can extend a previous method to things I hadn’t even thought of applying it to. And with the quicklook, and the way the documentation is structured, none of this stuff becomes complicated.</p>
<p>Obviously this is a little bit of a straw man - there are some obvious cases where protocol extensions don’t make a lot of sense. Having “double” as an extension on <code class="sourceCode scala">IntegerArithmeticType</code> is sheer silliness - but I think something like <code class="sourceCode scala"><span class="fu">sqrt</span>()</code> would be odd, as well. If only because it decreases readability, I’m not sure that those kinds of things are good ideas. At the end of the day, you’re a reasonable, intelligent person, and you know where this stuff works. Just have it knocking around in your brain, so when you come across something that doesn’t work <em>quite right</em>, you’ll have protocol extensions as one of your other options.</p>
<p>If you want to see an example of protocols taken to the nth degree, the examples I’ve had here are taken from my library, <a href="https://github.com/oisdk/SwiftSequence">SwiftSequence</a>.</p>
<p>If you’ve kept reading this far, I’m going to I’m going to really test your patience with this next bit:</p>
<h1 id="what-do-i-want">What do I want?</h1>
<h2 id="beef-up-some-of-the-meta-language">Beef up some of the meta-language</h2>
<p>You know the tiny little meta-language for protocol extensions? The one that exists between the angle brackets, after the where?</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb8-1" data-line-number="1"></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">extension SomeProtocol <span class="fu">where</span> (This bit) {...</a>
<a class="sourceLine" id="cb8-3" data-line-number="3"></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">func f&lt;T : SomeProtocol <span class="fu">where</span> (This bit, also)...</a></code></pre></div>
<p>That needs to get more powerful. Swift is big on doing loads of stuff at compile-time, and that little meta-language is effectively a script that runs as your code compiles. When it’s between the angle brackets it’s ugly, and it seems like too small a place for a lot of code, but if you start doing anything complex with it, you hit its limits quickly. Say you want to write a recursive function that works with slices. This is the absolute minimum in the angle brackets you need:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb9-1" data-line-number="1">&lt;  </a>
<a class="sourceLine" id="cb9-2" data-line-number="2">  S : Sliceable where S.<span class="fu">SubSlice</span> : Sliceable,  </a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  S.<span class="fu">SubSlice</span>.<span class="fu">Generator</span>.<span class="fu">Element</span> == S.<span class="fu">Generator</span>.<span class="fu">Element</span>,  </a>
<a class="sourceLine" id="cb9-4" data-line-number="4">  S.<span class="fu">SubSlice</span>.<span class="fu">SubSlice</span> == S.<span class="fu">SubSlice</span>  </a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  &gt;</a></code></pre></div>
<p>And if you need anything complex, well…</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb10-1" data-line-number="1">func bSearch&lt;</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">  S : Sliceable where S.<span class="fu">SubSlice</span> : Sliceable,</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  S.<span class="fu">SubSlice</span>.<span class="fu">Generator</span>.<span class="fu">Element</span> == S.<span class="fu">Generator</span>.<span class="fu">Element</span>,</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">  S.<span class="fu">SubSlice</span>.<span class="fu">SubSlice</span> == S.<span class="fu">SubSlice</span>,</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">  S.<span class="fu">Generator</span>.<span class="fu">Element</span> : Comparable,</a>
<a class="sourceLine" id="cb10-6" data-line-number="6">  S.<span class="fu">Index</span> : IntegerArithmeticType,</a>
<a class="sourceLine" id="cb10-7" data-line-number="7">  S.<span class="fu">Index</span> : IntegerLiteralConvertible,</a>
<a class="sourceLine" id="cb10-8" data-line-number="8">  S.<span class="fu">SubSlice</span>.<span class="fu">Index</span> == S.<span class="fu">Index</span></a>
<a class="sourceLine" id="cb10-9" data-line-number="9">  &gt;(el: S.<span class="fu">Generator</span>.<span class="fu">Element</span>, list: S) -&gt; S.<span class="fu">Generator</span>.<span class="fu">Element</span>? {</a>
<a class="sourceLine" id="cb10-10" data-line-number="10"></a>
<a class="sourceLine" id="cb10-11" data-line-number="11">    <span class="kw">if</span> list.<span class="fu">isEmpty</span> { <span class="kw">return</span> nil }</a>
<a class="sourceLine" id="cb10-12" data-line-number="12"></a>
<a class="sourceLine" id="cb10-13" data-line-number="13">    let midInd = list.<span class="fu">endIndex</span> / <span class="dv">2</span></a>
<a class="sourceLine" id="cb10-14" data-line-number="14"></a>
<a class="sourceLine" id="cb10-15" data-line-number="15">    let midEl: S.<span class="fu">Generator</span>.<span class="fu">Element</span> = list[midInd] </a>
<a class="sourceLine" id="cb10-16" data-line-number="16">    <span class="co">// type inference giving me some bugs here</span></a>
<a class="sourceLine" id="cb10-17" data-line-number="17"></a>
<a class="sourceLine" id="cb10-18" data-line-number="18">    <span class="kw">if</span> midEl == el {</a>
<a class="sourceLine" id="cb10-19" data-line-number="19">      <span class="kw">return</span> el</a>
<a class="sourceLine" id="cb10-20" data-line-number="20">    }</a>
<a class="sourceLine" id="cb10-21" data-line-number="21"></a>
<a class="sourceLine" id="cb10-22" data-line-number="22">    <span class="kw">return</span> midEl &lt; el ?</a>
<a class="sourceLine" id="cb10-23" data-line-number="23">      <span class="fu">bSearch</span>(el, list: list[midInd+<span class="dv">1</span>..&lt;list.<span class="fu">endIndex</span>]) :</a>
<a class="sourceLine" id="cb10-24" data-line-number="24">      <span class="fu">bSearch</span>(el, list: list[<span class="dv">0</span>..&lt;midInd])</a>
<a class="sourceLine" id="cb10-25" data-line-number="25">}</a></code></pre></div>
<p>Yeah. And it’s only going to get more and more complex: with every new beta, more functions become methods. This protocol business is going to cause more and more function signatures to end up looking like that. With that in mind, two things, in particular, need to go into the meta-language:</p>
<ul>
<li><p>A way to summarise all of those protocols into one. Like, I should be able to declare a protocol that’s just other protocols put together:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb11-1" data-line-number="1">protocol RecursiveSliceable:</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">  Sliceable where SubSlice : Sliceable,</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  SubSlice.<span class="fu">Generator</span>.<span class="fu">Element</span> == Generator.<span class="fu">Element</span>,</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">  SubSlice.<span class="fu">SubSlice</span> == SubSlice</a>
<a class="sourceLine" id="cb11-5" data-line-number="5"></a>
<a class="sourceLine" id="cb11-6" data-line-number="6">protocol RecursiveSliceableIntegerIndices:</a>
<a class="sourceLine" id="cb11-7" data-line-number="7">  RecursiveSliceable where</a>
<a class="sourceLine" id="cb11-8" data-line-number="8">  Index : IntegerArithmeticType,</a>
<a class="sourceLine" id="cb11-9" data-line-number="9">  Index : IntegerLiteralConvertible,</a>
<a class="sourceLine" id="cb11-10" data-line-number="10">  SubSlice.<span class="fu">Index</span> == Index</a>
<a class="sourceLine" id="cb11-11" data-line-number="11"></a>
<a class="sourceLine" id="cb11-12" data-line-number="12">func bSearch&lt;</a>
<a class="sourceLine" id="cb11-13" data-line-number="13">  S : RecursiveSliceableIntegerIndices where</a>
<a class="sourceLine" id="cb11-14" data-line-number="14">  S.<span class="fu">Generator</span>.<span class="fu">Element</span> : Comparable</a>
<a class="sourceLine" id="cb11-15" data-line-number="15">  &gt;(seq: S)...</a></code></pre></div></li>
<li><p>Support for expressions, statements and whatnot, all of which get evaluated at compile-time.</p></li>
</ul>
<h2 id="more-pop-in-the-standard-library">More POP in the Standard Library</h2>
<p>The standard library, at the moment, still has not fully crossed over to the protocol way of doing things. It’s probably more to do with resource pressure than anything else, but I’m worried that some areas may not get the full protocol treatment. I’m talking about sequences. Currently, there are structs like <code class="sourceCode scala">AnySequence</code>, which represent the old, dark days of Swift 1.2. In its description:</p>
<blockquote>
<p>A type-erased sequence.</p>
</blockquote>
<blockquote>
<p>Forwards operations to an arbitrary underlying sequence having the same <code>Element</code> type, hiding the specifics of the underlying <code class="sourceCode scala">SequenceType</code>.</p>
</blockquote>
<p>That’s no good. You shouldn’t have to erase types - your methods and functions should act on <code class="sourceCode scala">SequenceType</code>, regardless of which <code class="sourceCode scala">SequenceType</code> it is. I’m not suggesting you should get rid of that struct - it’s trivial to come up with cases where it’s needed - I’m saying you shouldn’t be using it if you don’t have to. And in one particular area of the Swift standard library, they use structs where (I feel) they should be using protocols: <code class="sourceCode scala">LazySequence</code>. It’s a wrapper struct, mainly used for functional-style methods like <code class="sourceCode scala">map</code> and <code class="sourceCode scala">filter</code> that can act lazily. <em>Why isn’t it a protocol</em>?! Currently, the lazy versions of <code class="sourceCode scala">map</code> and <code class="sourceCode scala">filter</code> are defined as methods on <code class="sourceCode scala">LazySequence</code>. What they return is a <code class="sourceCode scala">MapSequenceView</code> <em>wrapped</em> in <code class="sourceCode scala">LazySequence</code>. That way, you can chain map and filter, keeping things lazy. But why not make <code class="sourceCode scala">LazySequenceType</code> a protocol, and have <code class="sourceCode scala">MapSequenceView</code> conform to it? There’s more - <code class="sourceCode scala">LazyRandomAccessCollection</code>, <code class="sourceCode scala">LazyForwardCollection</code>, etc. <em>These should all be protocols</em>. It’s a nightmare to try and deal with these things: if you want to write a lazy method on a sequence, you have to write one for <code class="sourceCode scala">LazySequence</code>, then one for <code class="sourceCode scala">LazyForwardCollection</code>, and so on. It would be so much easier to have.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb12-1" data-line-number="1">extension LazySequenceType where </a>
<a class="sourceLine" id="cb12-2" data-line-number="2">  Self: CollectionType, </a>
<a class="sourceLine" id="cb12-3" data-line-number="3">  Index: RandomAccessIndexType</a></code></pre></div>
<p>I really don’t know why it’s not this way. Again, the Swift team may well <em>want</em> to do it, but just hasn’t got round to it. I hope so. A very optimistic voice in my mind does keep whispering, though: “<em>they’re just waiting for recursive enums, so they can introduce lazy lists… they’ve been working on a whole load of lazy sequence functions… pattern matching… uncons…</em>”</p>
]]></description>
    <pubDate>Fri, 17 Jul 2015 00:00:00 UT</pubDate>
    <guid>https://doisinkidney.com/posts/2015-07-17-swift-protocols-a-strategy.html</guid>
    <dc:creator>Donnacha Oisín Kidney</dc:creator>
</item>

    </channel>
</rss>
